------------------------------------------------------------------------
-- Checking declarations
------------------------------------------------------------------------
-- Solved Metas: 14227
-- Unsolved Metas: 0
------------------------------------------------------------------------
-- Unsolved problems: 0
------------------------------------------------------------------------
module MathScheme where
  data Prod
    (A : Set) (B : Set) : Set where
    
  module NatNums where
    
  
  data Nat : Set where
    zero : Nat
    suc : Nat -> Nat
  module Prelude where
    
  
  data Fin (n : Nat) : Set where
    fzero :
      (m : Nat) (p : n == suc m) ->
      Fin n
    fsuc :
      (m : Nat) (p : n == suc m)
      (i : Fin m) -> Fin n
  pred : Nat -> Nat
  pred (zero) = zero
  pred (suc n) = n
  data Vec
    (A : Set) (n : Nat) : Set where
    nil : n == zero -> Vec A n
    cons :
      (m : Nat) (p : n == suc m)
      (x : A)
      (xs : Vec A m) -> Vec A n
  data Unit : Set where
    unit : Unit
  EmptyT : Set
  EmptyT = (A : Set) -> A
  subst :
    (A : Set) (x : A) (y : A)
    (P : A -> Set) ->
    x == y -> P x -> P y
  subst _ _ _ P =
    J _ _ _ (\ x y _ -> P x -> P y)
      (\ x p -> p)
  sym :
    (A : Set) (x : A) (y : A) ->
    x == y -> y == x
  sym A x y p =
    subst _ _ _ (\ y -> y == x) p
      refl
  cong :
    (A : Set) (B : Set) (x : A)
    (y : A)
    (f : A -> B) ->
    x == y -> f x == f y
  cong _ _ _ _ f p =
    subst _ _ _ (\ y -> f _ == f y)
      p
      refl
  IsZero : Nat -> Set
  IsZero (zero) = Unit
  IsZero (suc n) = EmptyT
  zeroNOTsuc :
    (n : Nat) ->
    zero == suc n -> EmptyT
  zeroNOTsuc _ p =
    subst _ _ _ IsZero p unit
  trans :
    (A : Set) (x : A) (y : A)
    (z : A) ->
    x == y -> y == z -> x == z
  trans A x _ _ p q =
    subst _ _ _ (\ y -> x == y) q p
  lemma :
    (n : Nat) (m : Nat) ->
    n == suc m ->
    n == zero -> EmptyT
  lemma _ _ p q =
    zeroNOTsuc _
      (trans _ _ _ _ (sym _ _ _ q) p)
  sucInj :
    (n : Nat) (m : Nat) ->
    suc n == suc m -> n == m
  sucInj _ _ p =
    cong _ _ _ _ pred p
  lookup :
    (A : Set) (n : Nat) (i : Fin n)
    (v : Vec A n) -> A
  lookup A n (fzero m p) (nil q) =
    lemma _ _ p q A
  lookup A n (fzero m p) (cons
                          l
                          q
                          x
                          xs) = x
  lookup A n (fsuc m p i) (nil
                           q) = lemma _ _ p q A
  lookup A n (fsuc m p i) (cons
                           l
                           q
                           x
                           xs) =
    lookup _ m i
      (subst _ _ _ (Vec A)
         (sucInj _ _
            (trans _ _ _ _ (sym _ _ _ q) p))
         xs)
  module AdditiveCommutativeSemigroup where
    record AdditiveCommutativeSemigroup
      (A : Set) : Set where
      constructor AdditiveCommutativeSemigroupC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record AdditiveCommutativeSemigroupSig
      (AS : Set) : Set where
      constructor AdditiveCommutativeSemigroupSigSigC
      field
        +S : AS -> AS -> AS
    record AdditiveCommutativeSemigroupProd
      (AP : Set) : Set where
      constructor AdditiveCommutativeSemigroupProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record AdditiveCommutativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveCommutativeSemigroup
         A1)
      (Ad2 : AdditiveCommutativeSemigroup
         A2) : Set where
      constructor AdditiveCommutativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveCommutativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveCommutativeSemigroup
         A1)
      (Ad2 : AdditiveCommutativeSemigroup
         A2) : Set where
      constructor AdditiveCommutativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveCommutativeSemigroupLang
      : Set where
      +L :
        AdditiveCommutativeSemigroupLang ->
        AdditiveCommutativeSemigroupLang ->
        AdditiveCommutativeSemigroupLang
    data AdditiveCommutativeSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AdditiveCommutativeSemigroupOpenLang
          n
      +OL :
        AdditiveCommutativeSemigroupOpenLang
          n ->
        AdditiveCommutativeSemigroupOpenLang
          n ->
        AdditiveCommutativeSemigroupOpenLang
          n
    evalTerm :
      (A : Set) ->
      AdditiveCommutativeSemigroup
        A ->
      AdditiveCommutativeSemigroupLang ->
      A
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditiveCommutativeSemigroup
        A ->
      AdditiveCommutativeSemigroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    simplify :
      AdditiveCommutativeSemigroupLang ->
      AdditiveCommutativeSemigroupLang
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
  
  module AdditiveMagma where
    record AdditiveMagma
      (A : Set) : Set where
      constructor AdditiveMagmaC
      field
        + : A -> A -> A
    record AdditiveMagmaSig
      (AS : Set) : Set where
      constructor AdditiveMagmaSigSigC
      field
        +S : AS -> AS -> AS
    record AdditiveMagmaProd
      (AP : Set) : Set where
      constructor AdditiveMagmaProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record AdditiveMagmaHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveMagma A1)
      (Ad2 : AdditiveMagma A2) :
      Set where
      constructor AdditiveMagmaHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveMagma A1)
      (Ad2 : AdditiveMagma A2) :
      Set where
      constructor AdditiveMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveMagmaLang
      : Set where
      +L :
        AdditiveMagmaLang ->
        AdditiveMagmaLang ->
        AdditiveMagmaLang
    data AdditiveMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> AdditiveMagmaOpenLang n
      +OL :
        AdditiveMagmaOpenLang n ->
        AdditiveMagmaOpenLang n ->
        AdditiveMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      AdditiveMagma A ->
      AdditiveMagmaLang -> A
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditiveMagma A ->
      AdditiveMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    simplify :
      AdditiveMagmaLang ->
      AdditiveMagmaLang
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
  
  module AdditiveMonoid where
    record AdditiveMonoid
      (A : Set) : Set where
      constructor AdditiveMonoidC
      field
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
    record AdditiveMonoidSig
      (AS : Set) : Set where
      constructor AdditiveMonoidSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
    record AdditiveMonoidProd
      (AP : Set) : Set where
      constructor AdditiveMonoidProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
    record AdditiveMonoidHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveMonoid A1)
      (Ad2 : AdditiveMonoid A2) :
      Set where
      constructor AdditiveMonoidHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
        pres-0 : hom (0 Ad1) == 0 Ad2
    record AdditiveMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveMonoid A1)
      (Ad2 : AdditiveMonoid A2) :
      Set where
      constructor AdditiveMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
        interp-0 :
          interp (0 Ad1) (0 Ad2)
    data AdditiveMonoidLang
      : Set where
      +L :
        AdditiveMonoidLang ->
        AdditiveMonoidLang ->
        AdditiveMonoidLang
      0L : AdditiveMonoidLang
    data AdditiveMonoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AdditiveMonoidOpenLang n
      +OL :
        AdditiveMonoidOpenLang n ->
        AdditiveMonoidOpenLang n ->
        AdditiveMonoidOpenLang n
      0OL : AdditiveMonoidOpenLang n
    evalTerm :
      (A : Set) ->
      AdditiveMonoid A ->
      AdditiveMonoidLang -> A
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalTerm _ Ad (0L) = 0 Ad
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditiveMonoid A ->
      AdditiveMonoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    evalOpenTerm _ n ad (0OL) vars =
      0 ad
    simplify :
      AdditiveMonoidLang ->
      AdditiveMonoidLang
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (0L) = 0L
  
  module AdditivePointedMagma where
    record AdditivePointedMagma
      (A : Set) : Set where
      constructor AdditivePointedMagmaC
      field
        0 : A
        + : A -> A -> A
    record AdditivePointedMagmaSig
      (AS : Set) : Set where
      constructor AdditivePointedMagmaSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
    record AdditivePointedMagmaProd
      (AP : Set) : Set where
      constructor AdditivePointedMagmaProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record AdditivePointedMagmaHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditivePointedMagma A1)
      (Ad2 : AdditivePointedMagma
         A2) : Set where
      constructor AdditivePointedMagmaHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditivePointedMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditivePointedMagma A1)
      (Ad2 : AdditivePointedMagma
         A2) : Set where
      constructor AdditivePointedMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditivePointedMagmaLang
      : Set where
      0L : AdditivePointedMagmaLang
      +L :
        AdditivePointedMagmaLang ->
        AdditivePointedMagmaLang ->
        AdditivePointedMagmaLang
    data AdditivePointedMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AdditivePointedMagmaOpenLang n
      0OL :
        AdditivePointedMagmaOpenLang n
      +OL :
        AdditivePointedMagmaOpenLang
          n ->
        AdditivePointedMagmaOpenLang
          n ->
        AdditivePointedMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      AdditivePointedMagma A ->
      AdditivePointedMagmaLang -> A
    evalTerm _ Ad (0L) = 0 Ad
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditivePointedMagma A ->
      AdditivePointedMagmaOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (0OL) vars =
      0 ad
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    simplify :
      AdditivePointedMagmaLang ->
      AdditivePointedMagmaLang
    simplify (0L) = 0L
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
  
  module AdditivePointedSemigroup where
    record AdditivePointedSemigroup
      (A : Set) : Set where
      constructor AdditivePointedSemigroupC
      field
        0 : A
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record AdditivePointedSemigroupSig
      (AS : Set) : Set where
      constructor AdditivePointedSemigroupSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
    record AdditivePointedSemigroupProd
      (AP : Set) : Set where
      constructor AdditivePointedSemigroupProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record AdditivePointedSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditivePointedSemigroup
         A1)
      (Ad2 : AdditivePointedSemigroup
         A2) : Set where
      constructor AdditivePointedSemigroupHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditivePointedSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditivePointedSemigroup
         A1)
      (Ad2 : AdditivePointedSemigroup
         A2) : Set where
      constructor AdditivePointedSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditivePointedSemigroupLang
      : Set where
      0L :
        AdditivePointedSemigroupLang
      +L :
        AdditivePointedSemigroupLang ->
        AdditivePointedSemigroupLang ->
        AdditivePointedSemigroupLang
    data AdditivePointedSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AdditivePointedSemigroupOpenLang
          n
      0OL :
        AdditivePointedSemigroupOpenLang
          n
      +OL :
        AdditivePointedSemigroupOpenLang
          n ->
        AdditivePointedSemigroupOpenLang
          n ->
        AdditivePointedSemigroupOpenLang
          n
    evalTerm :
      (A : Set) ->
      AdditivePointedSemigroup A ->
      AdditivePointedSemigroupLang ->
      A
    evalTerm _ Ad (0L) = 0 Ad
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditivePointedSemigroup A ->
      AdditivePointedSemigroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (0OL) vars =
      0 ad
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    simplify :
      AdditivePointedSemigroupLang ->
      AdditivePointedSemigroupLang
    simplify (0L) = 0L
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
  
  module AdditiveSemigroup where
    record AdditiveSemigroup
      (A : Set) : Set where
      constructor AdditiveSemigroupC
      field
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record AdditiveSemigroupSig
      (AS : Set) : Set where
      constructor AdditiveSemigroupSigSigC
      field
        +S : AS -> AS -> AS
    record AdditiveSemigroupProd
      (AP : Set) : Set where
      constructor AdditiveSemigroupProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record AdditiveSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveSemigroup A1)
      (Ad2 : AdditiveSemigroup A2) :
      Set where
      constructor AdditiveSemigroupHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveSemigroup A1)
      (Ad2 : AdditiveSemigroup A2) :
      Set where
      constructor AdditiveSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveSemigroupLang
      : Set where
      +L :
        AdditiveSemigroupLang ->
        AdditiveSemigroupLang ->
        AdditiveSemigroupLang
    data AdditiveSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AdditiveSemigroupOpenLang n
      +OL :
        AdditiveSemigroupOpenLang n ->
        AdditiveSemigroupOpenLang n ->
        AdditiveSemigroupOpenLang n
    evalTerm :
      (A : Set) ->
      AdditiveSemigroup A ->
      AdditiveSemigroupLang -> A
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditiveSemigroup A ->
      AdditiveSemigroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    simplify :
      AdditiveSemigroupLang ->
      AdditiveSemigroupLang
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
  
  module AdditiveUnital where
    record AdditiveUnital
      (A : Set) : Set where
      constructor AdditiveUnitalC
      field
        0 : A
        + : A -> A -> A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
    record AdditiveUnitalSig
      (AS : Set) : Set where
      constructor AdditiveUnitalSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
    record AdditiveUnitalProd
      (AP : Set) : Set where
      constructor AdditiveUnitalProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
    record AdditiveUnitalHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveUnital A1)
      (Ad2 : AdditiveUnital A2) :
      Set where
      constructor AdditiveUnitalHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveUnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveUnital A1)
      (Ad2 : AdditiveUnital A2) :
      Set where
      constructor AdditiveUnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveUnitalLang
      : Set where
      0L : AdditiveUnitalLang
      +L :
        AdditiveUnitalLang ->
        AdditiveUnitalLang ->
        AdditiveUnitalLang
    data AdditiveUnitalOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AdditiveUnitalOpenLang n
      0OL : AdditiveUnitalOpenLang n
      +OL :
        AdditiveUnitalOpenLang n ->
        AdditiveUnitalOpenLang n ->
        AdditiveUnitalOpenLang n
    evalTerm :
      (A : Set) ->
      AdditiveUnital A ->
      AdditiveUnitalLang -> A
    evalTerm _ Ad (0L) = 0 Ad
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditiveUnital A ->
      AdditiveUnitalOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (0OL) vars =
      0 ad
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    simplify :
      AdditiveUnitalLang ->
      AdditiveUnitalLang
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (0L) = 0L
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
  
  module Carrier where
    record Carrier
      (A : Set) : Set where
      constructor CarrierC
      field
        
    record CarrierSig
      (AS : Set) : Set where
      constructor CarrierSigSigC
      field
        
    record CarrierProd
      (AP : Set) : Set where
      constructor CarrierProdC
      field
        
    record CarrierHom
      (A1 : Set) (A2 : Set)
      (Ca1 : Carrier A1)
      (Ca2 : Carrier A2) : Set where
      constructor CarrierHomC
      field
        hom : A1 -> A2
    record CarrierRelInterp
      (A1 : Set) (A2 : Set)
      (Ca1 : Carrier A1)
      (Ca2 : Carrier A2) : Set where
      constructor CarrierRelInterpC
      field
        interp : A1 -> A2 -> Set
    data CarrierLang : Set where
      
    data CarrierOpenLang
      (n : Nat) : Set where
      v : Fin n -> CarrierOpenLang n
    evalTerm :
      (A : Set) ->
      Carrier A -> CarrierLang -> A
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Carrier A ->
      CarrierOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ca (v
                         fin) vars = lookup _ n fin vars
    simplify :
      CarrierLang -> CarrierLang
  
  module CommutativeMagma where
    record CommutativeMagma
      (A : Set) : Set where
      constructor CommutativeMagmaC
      field
        op : A -> A -> A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CommutativeMagmaSig
      (AS : Set) : Set where
      constructor CommutativeMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record CommutativeMagmaProd
      (AP : Set) : Set where
      constructor CommutativeMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CommutativeMagmaHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMagma A1)
      (Co2 : CommutativeMagma A2) :
      Set where
      constructor CommutativeMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
    record CommutativeMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMagma A1)
      (Co2 : CommutativeMagma A2) :
      Set where
      constructor CommutativeMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
    data CommutativeMagmaLang
      : Set where
      opL :
        CommutativeMagmaLang ->
        CommutativeMagmaLang ->
        CommutativeMagmaLang
    data CommutativeMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CommutativeMagmaOpenLang n
      opOL :
        CommutativeMagmaOpenLang n ->
        CommutativeMagmaOpenLang n ->
        CommutativeMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      CommutativeMagma A ->
      CommutativeMagmaLang -> A
    evalTerm _ Co (opL x1 x2) =
      op Co (evalTerm _ Co x1)
        (evalTerm _ Co x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CommutativeMagma A ->
      CommutativeMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n co (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n co (opOL
                         x1
                         x2) vars =
      op co
        (evalOpenTerm _ n co x1 vars)
        (evalOpenTerm _ n co x2 vars)
    simplify :
      CommutativeMagmaLang ->
      CommutativeMagmaLang
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
  
  module CommutativeMonoid where
    record CommutativeMonoid
      (A : Set) : Set where
      constructor CommutativeMonoidC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        e : A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CommutativeMonoidSig
      (AS : Set) : Set where
      constructor CommutativeMonoidSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record CommutativeMonoidProd
      (AP : Set) : Set where
      constructor CommutativeMonoidProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CommutativeMonoidHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMonoid A1)
      (Co2 : CommutativeMonoid A2) :
      Set where
      constructor CommutativeMonoidHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
        pres-e : hom (e Co1) == e Co2
    record CommutativeMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMonoid A1)
      (Co2 : CommutativeMonoid A2) :
      Set where
      constructor CommutativeMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
        interp-e :
          interp (e Co1) (e Co2)
    data CommutativeMonoidLang
      : Set where
      opL :
        CommutativeMonoidLang ->
        CommutativeMonoidLang ->
        CommutativeMonoidLang
      eL : CommutativeMonoidLang
    data CommutativeMonoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CommutativeMonoidOpenLang n
      opOL :
        CommutativeMonoidOpenLang n ->
        CommutativeMonoidOpenLang n ->
        CommutativeMonoidOpenLang n
      eOL :
        CommutativeMonoidOpenLang n
    evalTerm :
      (A : Set) ->
      CommutativeMonoid A ->
      CommutativeMonoidLang -> A
    evalTerm _ Co (opL x1 x2) =
      op Co (evalTerm _ Co x1)
        (evalTerm _ Co x2)
    evalTerm _ Co (eL) = e Co
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CommutativeMonoid A ->
      CommutativeMonoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n co (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n co (opOL
                         x1
                         x2) vars =
      op co
        (evalOpenTerm _ n co x1 vars)
        (evalOpenTerm _ n co x2 vars)
    evalOpenTerm _ n co (eOL) vars =
      e co
    simplify :
      CommutativeMonoidLang ->
      CommutativeMonoidLang
    simplify (opL (eL) x) = x
    simplify (opL x (eL)) = x
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (eL) = eL
  
  module CommutativeSemigroup where
    record CommutativeSemigroup
      (A : Set) : Set where
      constructor CommutativeSemigroupC
      field
        op : A -> A -> A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record CommutativeSemigroupSig
      (AS : Set) : Set where
      constructor CommutativeSemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record CommutativeSemigroupProd
      (AP : Set) : Set where
      constructor CommutativeSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record CommutativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeSemigroup A1)
      (Co2 : CommutativeSemigroup
         A2) : Set where
      constructor CommutativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
    record CommutativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeSemigroup A1)
      (Co2 : CommutativeSemigroup
         A2) : Set where
      constructor CommutativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
    data CommutativeSemigroupLang
      : Set where
      opL :
        CommutativeSemigroupLang ->
        CommutativeSemigroupLang ->
        CommutativeSemigroupLang
    data CommutativeSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CommutativeSemigroupOpenLang n
      opOL :
        CommutativeSemigroupOpenLang
          n ->
        CommutativeSemigroupOpenLang
          n ->
        CommutativeSemigroupOpenLang n
    evalTerm :
      (A : Set) ->
      CommutativeSemigroup A ->
      CommutativeSemigroupLang -> A
    evalTerm _ Co (opL x1 x2) =
      op Co (evalTerm _ Co x1)
        (evalTerm _ Co x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CommutativeSemigroup A ->
      CommutativeSemigroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n co (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n co (opOL
                         x1
                         x2) vars =
      op co
        (evalOpenTerm _ n co x1 vars)
        (evalOpenTerm _ n co x2 vars)
    simplify :
      CommutativeSemigroupLang ->
      CommutativeSemigroupLang
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
  
  module Empty where
    record Empty : Set where
      constructor EmptyC
      field
        
  
  module LeftUnital where
    record LeftUnital
      (A : Set) : Set where
      constructor LeftUnitalC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
    record LeftUnitalSig
      (AS : Set) : Set where
      constructor LeftUnitalSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record LeftUnitalProd
      (AP : Set) : Set where
      constructor LeftUnitalProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
    record LeftUnitalHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftUnital A1)
      (Le2 : LeftUnital A2) :
      Set where
      constructor LeftUnitalHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Le1) == e Le2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record LeftUnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftUnital A1)
      (Le2 : LeftUnital A2) :
      Set where
      constructor LeftUnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Le1) (e Le2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data LeftUnitalLang : Set where
      eL : LeftUnitalLang
      opL :
        LeftUnitalLang ->
        LeftUnitalLang -> LeftUnitalLang
    data LeftUnitalOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> LeftUnitalOpenLang n
      eOL : LeftUnitalOpenLang n
      opOL :
        LeftUnitalOpenLang n ->
        LeftUnitalOpenLang n ->
        LeftUnitalOpenLang n
    evalTerm :
      (A : Set) ->
      LeftUnital A ->
      LeftUnitalLang -> A
    evalTerm _ Le (eL) = e Le
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftUnital A ->
      LeftUnitalOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (eOL) vars =
      e le
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    simplify :
      LeftUnitalLang -> LeftUnitalLang
    simplify (opL (eL) x) = x
    simplify (eL) = eL
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
  
  module Magma where
    record Magma
      (A : Set) : Set where
      constructor MagmaC
      field
        op : A -> A -> A
    record MagmaSig
      (AS : Set) : Set where
      constructor MagmaSigSigC
      field
        opS : AS -> AS -> AS
    record MagmaProd
      (AP : Set) : Set where
      constructor MagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record MagmaHom
      (A1 : Set) (A2 : Set)
      (Ma1 : Magma A1)
      (Ma2 : Magma A2) : Set where
      constructor MagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ma1 x1 x2) ==
            op Ma2 (hom x1) (hom x2)
    record MagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ma1 : Magma A1)
      (Ma2 : Magma A2) : Set where
      constructor MagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ma1 x1 x2)
            (op Ma2 y1 y2)
    data MagmaLang : Set where
      opL :
        MagmaLang ->
        MagmaLang -> MagmaLang
    data MagmaOpenLang
      (n : Nat) : Set where
      v : Fin n -> MagmaOpenLang n
      opOL :
        MagmaOpenLang n ->
        MagmaOpenLang n ->
        MagmaOpenLang n
    evalTerm :
      (A : Set) ->
      Magma A -> MagmaLang -> A
    evalTerm _ Ma (opL x1 x2) =
      op Ma (evalTerm _ Ma x1)
        (evalTerm _ Ma x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Magma A ->
      MagmaOpenLang n -> Vec A n -> A
    evalOpenTerm _ n ma (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ma (opOL
                         x1
                         x2) vars =
      op ma
        (evalOpenTerm _ n ma x1 vars)
        (evalOpenTerm _ n ma x2 vars)
    simplify :
      MagmaLang -> MagmaLang
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
  
  module Monoid where
    record Monoid
      (A : Set) : Set where
      constructor MonoidC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record MonoidSig
      (AS : Set) : Set where
      constructor MonoidSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record MonoidProd
      (AP : Set) : Set where
      constructor MonoidProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record MonoidHom
      (A1 : Set) (A2 : Set)
      (Mo1 : Monoid A1)
      (Mo2 : Monoid A2) : Set where
      constructor MonoidHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Mo1) == e Mo2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mo1 x1 x2) ==
            op Mo2 (hom x1) (hom x2)
    record MonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : Monoid A1)
      (Mo2 : Monoid A2) : Set where
      constructor MonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Mo1) (e Mo2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mo1 x1 x2)
            (op Mo2 y1 y2)
    data MonoidLang : Set where
      eL : MonoidLang
      opL :
        MonoidLang ->
        MonoidLang -> MonoidLang
    data MonoidOpenLang
      (n : Nat) : Set where
      v : Fin n -> MonoidOpenLang n
      eOL : MonoidOpenLang n
      opOL :
        MonoidOpenLang n ->
        MonoidOpenLang n ->
        MonoidOpenLang n
    evalTerm :
      (A : Set) ->
      Monoid A -> MonoidLang -> A
    evalTerm _ Mo (eL) = e Mo
    evalTerm _ Mo (opL x1 x2) =
      op Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Monoid A ->
      MonoidOpenLang n -> Vec A n -> A
    evalOpenTerm _ n mo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mo (eOL) vars =
      e mo
    evalOpenTerm _ n mo (opOL
                         x1
                         x2) vars =
      op mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
    simplify :
      MonoidLang -> MonoidLang
    simplify (opL (eL) x) = x
    simplify (opL x (eL)) = x
    simplify (eL) = eL
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
  
  module Pointed where
    record Pointed
      (A : Set) : Set where
      constructor PointedC
      field
        e : A
    record PointedSig
      (AS : Set) : Set where
      constructor PointedSigSigC
      field
        eS : AS
    record PointedProd
      (AP : Set) : Set where
      constructor PointedProdC
      field
        eP : Prod AP AP
    record PointedHom
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed A1)
      (Po2 : Pointed A2) : Set where
      constructor PointedHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Po1) == e Po2
    record PointedRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed A1)
      (Po2 : Pointed A2) : Set where
      constructor PointedRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Po1) (e Po2)
    data PointedLang : Set where
      eL : PointedLang
    data PointedOpenLang
      (n : Nat) : Set where
      v : Fin n -> PointedOpenLang n
      eOL : PointedOpenLang n
    evalTerm :
      (A : Set) ->
      Pointed A -> PointedLang -> A
    evalTerm _ Po (eL) = e Po
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Pointed A ->
      PointedOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (eOL) vars =
      e po
    simplify :
      PointedLang -> PointedLang
    simplify (eL) = eL
  
  module Pointed0Magma where
    record Pointed0Magma
      (A : Set) : Set where
      constructor Pointed0MagmaC
      field
        0 : A
        op : A -> A -> A
    record Pointed0MagmaSig
      (AS : Set) : Set where
      constructor Pointed0MagmaSigSigC
      field
        0S : AS
        opS : AS -> AS -> AS
    record Pointed0MagmaProd
      (AP : Set) : Set where
      constructor Pointed0MagmaProdC
      field
        0P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record Pointed0MagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed0Magma A1)
      (Po2 : Pointed0Magma A2) :
      Set where
      constructor Pointed0MagmaHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Po1) == 0 Po2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Po1 x1 x2) ==
            op Po2 (hom x1) (hom x2)
    record Pointed0MagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed0Magma A1)
      (Po2 : Pointed0Magma A2) :
      Set where
      constructor Pointed0MagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Po1) (0 Po2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Po1 x1 x2)
            (op Po2 y1 y2)
    data Pointed0MagmaLang
      : Set where
      0L : Pointed0MagmaLang
      opL :
        Pointed0MagmaLang ->
        Pointed0MagmaLang ->
        Pointed0MagmaLang
    data Pointed0MagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> Pointed0MagmaOpenLang n
      0OL : Pointed0MagmaOpenLang n
      opOL :
        Pointed0MagmaOpenLang n ->
        Pointed0MagmaOpenLang n ->
        Pointed0MagmaOpenLang n
    evalTerm :
      (A : Set) ->
      Pointed0Magma A ->
      Pointed0MagmaLang -> A
    evalTerm _ Po (0L) = 0 Po
    evalTerm _ Po (opL x1 x2) =
      op Po (evalTerm _ Po x1)
        (evalTerm _ Po x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Pointed0Magma A ->
      Pointed0MagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (0OL) vars =
      0 po
    evalOpenTerm _ n po (opOL
                         x1
                         x2) vars =
      op po
        (evalOpenTerm _ n po x1 vars)
        (evalOpenTerm _ n po x2 vars)
    simplify :
      Pointed0MagmaLang ->
      Pointed0MagmaLang
    simplify (0L) = 0L
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
  
  module PointedMagma where
    record PointedMagma
      (A : Set) : Set where
      constructor PointedMagmaC
      field
        e : A
        op : A -> A -> A
    record PointedMagmaSig
      (AS : Set) : Set where
      constructor PointedMagmaSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record PointedMagmaProd
      (AP : Set) : Set where
      constructor PointedMagmaProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record PointedMagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedMagma A1)
      (Po2 : PointedMagma A2) :
      Set where
      constructor PointedMagmaHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Po1) == e Po2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Po1 x1 x2) ==
            op Po2 (hom x1) (hom x2)
    record PointedMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedMagma A1)
      (Po2 : PointedMagma A2) :
      Set where
      constructor PointedMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Po1) (e Po2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Po1 x1 x2)
            (op Po2 y1 y2)
    data PointedMagmaLang
      : Set where
      eL : PointedMagmaLang
      opL :
        PointedMagmaLang ->
        PointedMagmaLang ->
        PointedMagmaLang
    data PointedMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> PointedMagmaOpenLang n
      eOL : PointedMagmaOpenLang n
      opOL :
        PointedMagmaOpenLang n ->
        PointedMagmaOpenLang n ->
        PointedMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      PointedMagma A ->
      PointedMagmaLang -> A
    evalTerm _ Po (eL) = e Po
    evalTerm _ Po (opL x1 x2) =
      op Po (evalTerm _ Po x1)
        (evalTerm _ Po x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PointedMagma A ->
      PointedMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (eOL) vars =
      e po
    evalOpenTerm _ n po (opOL
                         x1
                         x2) vars =
      op po
        (evalOpenTerm _ n po x1 vars)
        (evalOpenTerm _ n po x2 vars)
    simplify :
      PointedMagmaLang ->
      PointedMagmaLang
    simplify (eL) = eL
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
  
  module PointedOne where
    record PointedOne
      (A : Set) : Set where
      constructor PointedOneC
      field
        1 : A
    record PointedOneSig
      (AS : Set) : Set where
      constructor PointedOneSigSigC
      field
        1S : AS
    record PointedOneProd
      (AP : Set) : Set where
      constructor PointedOneProdC
      field
        1P : Prod AP AP
    record PointedOneHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedOne A1)
      (Po2 : PointedOne A2) :
      Set where
      constructor PointedOneHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Po1) == 1 Po2
    record PointedOneRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedOne A1)
      (Po2 : PointedOne A2) :
      Set where
      constructor PointedOneRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Po1) (1 Po2)
    data PointedOneLang : Set where
      1L : PointedOneLang
    data PointedOneOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> PointedOneOpenLang n
      1OL : PointedOneOpenLang n
    evalTerm :
      (A : Set) ->
      PointedOne A ->
      PointedOneLang -> A
    evalTerm _ Po (1L) = 1 Po
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PointedOne A ->
      PointedOneOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (1OL) vars =
      1 po
    simplify :
      PointedOneLang -> PointedOneLang
    simplify (1L) = 1L
  
  module PointedPlusMagma where
    record PointedPlusMagma
      (A : Set) : Set where
      constructor PointedPlusMagmaC
      field
        + : A -> A -> A
        e : A
    record PointedPlusMagmaSig
      (AS : Set) : Set where
      constructor PointedPlusMagmaSigSigC
      field
        +S : AS -> AS -> AS
        eS : AS
    record PointedPlusMagmaProd
      (AP : Set) : Set where
      constructor PointedPlusMagmaProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
    record PointedPlusMagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedPlusMagma A1)
      (Po2 : PointedPlusMagma A2) :
      Set where
      constructor PointedPlusMagmaHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Po1 x1 x2) ==
            + Po2 (hom x1) (hom x2)
        pres-e : hom (e Po1) == e Po2
    record PointedPlusMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedPlusMagma A1)
      (Po2 : PointedPlusMagma A2) :
      Set where
      constructor PointedPlusMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Po1 x1 x2)
            (+ Po2 y1 y2)
        interp-e :
          interp (e Po1) (e Po2)
    data PointedPlusMagmaLang
      : Set where
      +L :
        PointedPlusMagmaLang ->
        PointedPlusMagmaLang ->
        PointedPlusMagmaLang
      eL : PointedPlusMagmaLang
    data PointedPlusMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        PointedPlusMagmaOpenLang n
      +OL :
        PointedPlusMagmaOpenLang n ->
        PointedPlusMagmaOpenLang n ->
        PointedPlusMagmaOpenLang n
      eOL : PointedPlusMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      PointedPlusMagma A ->
      PointedPlusMagmaLang -> A
    evalTerm _ Po (+L x1 x2) =
      + Po (evalTerm _ Po x1)
        (evalTerm _ Po x2)
    evalTerm _ Po (eL) = e Po
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PointedPlusMagma A ->
      PointedPlusMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (+OL
                         x1
                         x2) vars =
      + po
        (evalOpenTerm _ n po x1 vars)
        (evalOpenTerm _ n po x2 vars)
    evalOpenTerm _ n po (eOL) vars =
      e po
    simplify :
      PointedPlusMagmaLang ->
      PointedPlusMagmaLang
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (eL) = eL
  
  module PointedSemigroup where
    record PointedSemigroup
      (A : Set) : Set where
      constructor PointedSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        e : A
    record PointedSemigroupSig
      (AS : Set) : Set where
      constructor PointedSemigroupSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record PointedSemigroupProd
      (AP : Set) : Set where
      constructor PointedSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record PointedSemigroupHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedSemigroup A1)
      (Po2 : PointedSemigroup A2) :
      Set where
      constructor PointedSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Po1 x1 x2) ==
            op Po2 (hom x1) (hom x2)
        pres-e : hom (e Po1) == e Po2
    record PointedSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedSemigroup A1)
      (Po2 : PointedSemigroup A2) :
      Set where
      constructor PointedSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Po1 x1 x2)
            (op Po2 y1 y2)
        interp-e :
          interp (e Po1) (e Po2)
    data PointedSemigroupLang
      : Set where
      opL :
        PointedSemigroupLang ->
        PointedSemigroupLang ->
        PointedSemigroupLang
      eL : PointedSemigroupLang
    data PointedSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        PointedSemigroupOpenLang n
      opOL :
        PointedSemigroupOpenLang n ->
        PointedSemigroupOpenLang n ->
        PointedSemigroupOpenLang n
      eOL : PointedSemigroupOpenLang n
    evalTerm :
      (A : Set) ->
      PointedSemigroup A ->
      PointedSemigroupLang -> A
    evalTerm _ Po (opL x1 x2) =
      op Po (evalTerm _ Po x1)
        (evalTerm _ Po x2)
    evalTerm _ Po (eL) = e Po
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PointedSemigroup A ->
      PointedSemigroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (opOL
                         x1
                         x2) vars =
      op po
        (evalOpenTerm _ n po x1 vars)
        (evalOpenTerm _ n po x2 vars)
    evalOpenTerm _ n po (eOL) vars =
      e po
    simplify :
      PointedSemigroupLang ->
      PointedSemigroupLang
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (eL) = eL
  
  module PointedZero where
    record PointedZero
      (A : Set) : Set where
      constructor PointedZeroC
      field
        0 : A
    record PointedZeroSig
      (AS : Set) : Set where
      constructor PointedZeroSigSigC
      field
        0S : AS
    record PointedZeroProd
      (AP : Set) : Set where
      constructor PointedZeroProdC
      field
        0P : Prod AP AP
    record PointedZeroHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedZero A1)
      (Po2 : PointedZero A2) :
      Set where
      constructor PointedZeroHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Po1) == 0 Po2
    record PointedZeroRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedZero A1)
      (Po2 : PointedZero A2) :
      Set where
      constructor PointedZeroRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Po1) (0 Po2)
    data PointedZeroLang : Set where
      0L : PointedZeroLang
    data PointedZeroOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> PointedZeroOpenLang n
      0OL : PointedZeroOpenLang n
    evalTerm :
      (A : Set) ->
      PointedZero A ->
      PointedZeroLang -> A
    evalTerm _ Po (0L) = 0 Po
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PointedZero A ->
      PointedZeroOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (0OL) vars =
      0 po
    simplify :
      PointedZeroLang ->
      PointedZeroLang
    simplify (0L) = 0L
  
  module RightUnital where
    record RightUnital
      (A : Set) : Set where
      constructor RightUnitalC
      field
        e : A
        op : A -> A -> A
        runit_e : (x : A) -> op x e == x
    record RightUnitalSig
      (AS : Set) : Set where
      constructor RightUnitalSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record RightUnitalProd
      (AP : Set) : Set where
      constructor RightUnitalProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
    record RightUnitalHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightUnital A1)
      (Ri2 : RightUnital A2) :
      Set where
      constructor RightUnitalHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Ri1) == e Ri2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record RightUnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightUnital A1)
      (Ri2 : RightUnital A2) :
      Set where
      constructor RightUnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Ri1) (e Ri2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data RightUnitalLang : Set where
      eL : RightUnitalLang
      opL :
        RightUnitalLang ->
        RightUnitalLang ->
        RightUnitalLang
    data RightUnitalOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> RightUnitalOpenLang n
      eOL : RightUnitalOpenLang n
      opOL :
        RightUnitalOpenLang n ->
        RightUnitalOpenLang n ->
        RightUnitalOpenLang n
    evalTerm :
      (A : Set) ->
      RightUnital A ->
      RightUnitalLang -> A
    evalTerm _ Ri (eL) = e Ri
    evalTerm _ Ri (opL x1 x2) =
      op Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightUnital A ->
      RightUnitalOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (eOL) vars =
      e ri
    evalOpenTerm _ n ri (opOL
                         x1
                         x2) vars =
      op ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RightUnitalLang ->
      RightUnitalLang
    simplify (opL x (eL)) = x
    simplify (eL) = eL
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
  
  module Semigroup where
    record Semigroup
      (A : Set) : Set where
      constructor SemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record SemigroupSig
      (AS : Set) : Set where
      constructor SemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record SemigroupProd
      (AP : Set) : Set where
      constructor SemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record SemigroupHom
      (A1 : Set) (A2 : Set)
      (Se1 : Semigroup A1)
      (Se2 : Semigroup A2) : Set where
      constructor SemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Se1 x1 x2) ==
            op Se2 (hom x1) (hom x2)
    record SemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Se1 : Semigroup A1)
      (Se2 : Semigroup A2) : Set where
      constructor SemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Se1 x1 x2)
            (op Se2 y1 y2)
    data SemigroupLang : Set where
      opL :
        SemigroupLang ->
        SemigroupLang -> SemigroupLang
    data SemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> SemigroupOpenLang n
      opOL :
        SemigroupOpenLang n ->
        SemigroupOpenLang n ->
        SemigroupOpenLang n
    evalTerm :
      (A : Set) ->
      Semigroup A ->
      SemigroupLang -> A
    evalTerm _ Se (opL x1 x2) =
      op Se (evalTerm _ Se x1)
        (evalTerm _ Se x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Semigroup A ->
      SemigroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n se (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n se (opOL
                         x1
                         x2) vars =
      op se
        (evalOpenTerm _ n se x1 vars)
        (evalOpenTerm _ n se x2 vars)
    simplify :
      SemigroupLang -> SemigroupLang
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
  
  module Unital where
    record Unital
      (A : Set) : Set where
      constructor UnitalC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
    record UnitalSig
      (AS : Set) : Set where
      constructor UnitalSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record UnitalProd
      (AP : Set) : Set where
      constructor UnitalProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
    record UnitalHom
      (A1 : Set) (A2 : Set)
      (Un1 : Unital A1)
      (Un2 : Unital A2) : Set where
      constructor UnitalHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Un1) == e Un2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Un1 x1 x2) ==
            op Un2 (hom x1) (hom x2)
    record UnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Un1 : Unital A1)
      (Un2 : Unital A2) : Set where
      constructor UnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Un1) (e Un2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Un1 x1 x2)
            (op Un2 y1 y2)
    data UnitalLang : Set where
      eL : UnitalLang
      opL :
        UnitalLang ->
        UnitalLang -> UnitalLang
    data UnitalOpenLang
      (n : Nat) : Set where
      v : Fin n -> UnitalOpenLang n
      eOL : UnitalOpenLang n
      opOL :
        UnitalOpenLang n ->
        UnitalOpenLang n ->
        UnitalOpenLang n
    evalTerm :
      (A : Set) ->
      Unital A -> UnitalLang -> A
    evalTerm _ Un (eL) = e Un
    evalTerm _ Un (opL x1 x2) =
      op Un (evalTerm _ Un x1)
        (evalTerm _ Un x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Unital A ->
      UnitalOpenLang n -> Vec A n -> A
    evalOpenTerm _ n un (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n un (eOL) vars =
      e un
    evalOpenTerm _ n un (opOL
                         x1
                         x2) vars =
      op un
        (evalOpenTerm _ n un x1 vars)
        (evalOpenTerm _ n un x2 vars)
    simplify :
      UnitalLang -> UnitalLang
    simplify (opL (eL) x) = x
    simplify (opL x (eL)) = x
    simplify (eL) = eL
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
  

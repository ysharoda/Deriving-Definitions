------------------------------------------------------------------------
-- Checking declarations
------------------------------------------------------------------------
-- Solved Metas: 48383
-- Unsolved Metas: 0
------------------------------------------------------------------------
-- Unsolved problems: 0
------------------------------------------------------------------------
module MathScheme where
  data Prod
    (A : Set) (B : Set) : Set where
    
  module NatNums where
    
  
  data Nat : Set where
    zero : Nat
    suc : Nat -> Nat
  module Prelude where
    
  
  data Fin (n : Nat) : Set where
    fzero :
      (m : Nat) (p : n == suc m) ->
      Fin n
    fsuc :
      (m : Nat) (p : n == suc m)
      (i : Fin m) -> Fin n
  pred : Nat -> Nat
  pred (zero) = zero
  pred (suc n) = n
  data Vec
    (A : Set) (n : Nat) : Set where
    nil : n == zero -> Vec A n
    cons :
      (m : Nat) (p : n == suc m)
      (x : A)
      (xs : Vec A m) -> Vec A n
  data Unit : Set where
    unit : Unit
  EmptyT : Set
  EmptyT = (A : Set) -> A
  subst :
    (A : Set) (x : A) (y : A)
    (P : A -> Set) ->
    x == y -> P x -> P y
  subst _ _ _ P =
    J _ _ _ (\ x y _ -> P x -> P y)
      (\ x p -> p)
  sym :
    (A : Set) (x : A) (y : A) ->
    x == y -> y == x
  sym A x y p =
    subst _ _ _ (\ y -> y == x) p
      refl
  cong :
    (A : Set) (B : Set) (x : A)
    (y : A)
    (f : A -> B) ->
    x == y -> f x == f y
  cong _ _ _ _ f p =
    subst _ _ _ (\ y -> f _ == f y)
      p
      refl
  IsZero : Nat -> Set
  IsZero (zero) = Unit
  IsZero (suc n) = EmptyT
  zeroNOTsuc :
    (n : Nat) ->
    zero == suc n -> EmptyT
  zeroNOTsuc _ p =
    subst _ _ _ IsZero p unit
  trans :
    (A : Set) (x : A) (y : A)
    (z : A) ->
    x == y -> y == z -> x == z
  trans A x _ _ p q =
    subst _ _ _ (\ y -> x == y) q p
  lemma :
    (n : Nat) (m : Nat) ->
    n == suc m ->
    n == zero -> EmptyT
  lemma _ _ p q =
    zeroNOTsuc _
      (trans _ _ _ _ (sym _ _ _ q) p)
  sucInj :
    (n : Nat) (m : Nat) ->
    suc n == suc m -> n == m
  sucInj _ _ p =
    cong _ _ _ _ pred p
  lookup :
    (A : Set) (n : Nat) (i : Fin n)
    (v : Vec A n) -> A
  lookup A n (fzero m p) (nil q) =
    lemma _ _ p q A
  lookup A n (fzero m p) (cons
                          l
                          q
                          x
                          xs) = x
  lookup A n (fsuc m p i) (nil
                           q) = lemma _ _ p q A
  lookup A n (fsuc m p i) (cons
                           l
                           q
                           x
                           xs) =
    lookup _ m i
      (subst _ _ _ (Vec A)
         (sucInj _ _
            (trans _ _ _ _ (sym _ _ _ q) p))
         xs)
  module Code where
    
  
  open NatNums
  data Wrap (A : Set) : Set where
    Q : A -> Wrap A
  data Stage : Set where
    s0 : Stage
    s1 : Stage
  CodeRep :
    (A : Set) (s : Stage) -> Set
  CodeRep A (s0) = A
  CodeRep A (s1) =
    Wrap (CodeRep A s0)
  uncode :
    (A : Set) ->
    CodeRep A s1 -> CodeRep A s0
  uncode _ (Q x) = x
  code :
    (A : Set) ->
    CodeRep A s0 -> CodeRep A s1
  code _ x = Q x
  run :
    (A : Set) -> CodeRep A s1 -> A
  run _ (Q x) = x
  module Staging where
    
  
  open Code
  data Choice : Set where
    Expr : Choice
    Const : Choice
  data Comp
    (A : Set) (s : Stage) :
    Set where
    Computation :
      Choice ->
      CodeRep A s -> Comp A s
  data Staged
    (A : Set) : Set where
    Now : A -> Staged A
    Later : Comp A s1 -> Staged A
  expr :
    (A : Set) ->
    CodeRep A s1 -> Staged A
  expr _ x =
    Later (Computation Expr x)
  const :
    (A : Set) ->
    CodeRep A s1 -> Staged A
  const _ x =
    Later (Computation Const x)
  stage0 :
    (A : Set) -> A -> Staged A
  stage0 _ x = Now x
  stage1 :
    (A : Set) (B : Set) ->
    (A -> B) ->
    (CodeRep A s1 ->
     CodeRep B s1) ->
    Staged A -> Staged B
  stage1 _ _ f g (Now x) =
    Now (f x)
  stage1 _ _ f g (Later
                  (Computation _ x)) =
    expr _ (g x)
  stage2 :
    (A : Set) (B : Set) (C : Set) ->
    (A -> B -> C) ->
    (CodeRep A s1 ->
     CodeRep B s1 -> CodeRep C s1) ->
    Staged A -> Staged B -> Staged C
  stage2 _ _ _ f _ (Now x) (Now
                            y) = stage0 _ (f x y)
  stage2 _ _ _ _ g (Now x) (Later
                            (Computation _ y)) =
    expr _ (g (code _ x) y)
  stage2 _ _ _ _ g (Later
                    (Computation _ x)) (Now y) =
    expr _ (g x (code _ y))
  stage2 _ _ _ _ g (Later
                    (Computation _ x)) (Later
                                        (Computation _ y)) =
    expr _ (g x y)
  codeLift1 :
    (A : Set) (B : Set) ->
    (A -> B) ->
    CodeRep A s1 -> CodeRep B s1
  codeLift1 _ _ f (Q x) = Q (f x)
  codeLift2 :
    (A : Set) (B : Set) (C : Set) ->
    (A -> B -> C) ->
    CodeRep A s1 ->
    CodeRep B s1 -> CodeRep C s1
  codeLift2 _ _ _ f (Q x) (Q y) =
    Q (f x y)
  module AdditiveCommutativeSemigroup where
    record AdditiveCommutativeSemigroup
      (A : Set) : Set where
      constructor AdditiveCommutativeSemigroupC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record AdditiveCommutativeSemigroupSig
      (AS : Set) : Set where
      constructor AdditiveCommutativeSemigroupSigSigC
      field
        +S : AS -> AS -> AS
    record AdditiveCommutativeSemigroupProd
      (AP : Set) : Set where
      constructor AdditiveCommutativeSemigroupProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record AdditiveCommutativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveCommutativeSemigroup
         A1)
      (Ad2 : AdditiveCommutativeSemigroup
         A2) : Set where
      constructor AdditiveCommutativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveCommutativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveCommutativeSemigroup
         A1)
      (Ad2 : AdditiveCommutativeSemigroup
         A2) : Set where
      constructor AdditiveCommutativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveCommutativeSemigroupTerm
      : Set where
      +L :
        AdditiveCommutativeSemigroupTerm ->
        AdditiveCommutativeSemigroupTerm ->
        AdditiveCommutativeSemigroupTerm
    data ClAdditiveCommutativeSemigroupTerm
      (A : Set) : Set where
      sing :
        A ->
        ClAdditiveCommutativeSemigroupTerm
          A
      +Cl :
        ClAdditiveCommutativeSemigroupTerm
          A ->
        ClAdditiveCommutativeSemigroupTerm
          A ->
        ClAdditiveCommutativeSemigroupTerm
          A
    data OpAdditiveCommutativeSemigroupTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpAdditiveCommutativeSemigroupTerm
          n
      +OL :
        OpAdditiveCommutativeSemigroupTerm
          n ->
        OpAdditiveCommutativeSemigroupTerm
          n ->
        OpAdditiveCommutativeSemigroupTerm
          n
    data OpAdditiveCommutativeSemigroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAdditiveCommutativeSemigroupTerm2
          n
          A
      sing2 :
        A ->
        OpAdditiveCommutativeSemigroupTerm2
          n
          A
      +OL2 :
        OpAdditiveCommutativeSemigroupTerm2
          n
          A ->
        OpAdditiveCommutativeSemigroupTerm2
          n
          A ->
        OpAdditiveCommutativeSemigroupTerm2
          n
          A
    simplifyB :
      AdditiveCommutativeSemigroupTerm ->
      AdditiveCommutativeSemigroupTerm
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClAdditiveCommutativeSemigroupTerm
        A ->
      ClAdditiveCommutativeSemigroupTerm
        A
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAdditiveCommutativeSemigroupTerm
        n ->
      OpAdditiveCommutativeSemigroupTerm
        n
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAdditiveCommutativeSemigroupTerm2
        n
        A ->
      OpAdditiveCommutativeSemigroupTerm2
        n
        A
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AdditiveCommutativeSemigroup
        A ->
      AdditiveCommutativeSemigroupTerm ->
      A
    evalB _ Ad (+L x1 x2) =
      + Ad (evalB _ Ad x1)
        (evalB _ Ad x2)
    evalCl :
      (A : Set) ->
      AdditiveCommutativeSemigroup
        A ->
      ClAdditiveCommutativeSemigroupTerm
        A -> A
    evalCl _ Ad (sing x1) = x1
    evalCl _ Ad (+Cl x1 x2) =
      + Ad (evalCl _ Ad x1)
        (evalCl _ Ad x2)
    evalOp :
      (A : Set) (n : Nat) ->
      AdditiveCommutativeSemigroup
        A ->
      Vec A n ->
      OpAdditiveCommutativeSemigroupTerm
        n -> A
    evalOp _ n Ad vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ad vars (+OL x1 x2) =
      + Ad (evalOp _ n Ad vars x1)
        (evalOp _ n Ad vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      AdditiveCommutativeSemigroup
        A ->
      Vec A n ->
      OpAdditiveCommutativeSemigroupTerm2
        n
        A -> A
    evalOpE _ n Ad vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ad vars (sing2 x1) =
      x1
    evalOpE _ n Ad vars (+OL2
                         x1
                         x2) =
      + Ad (evalOpE _ n Ad vars x1)
        (evalOpE _ n Ad vars x2)
    inductionB :
      (P : AdditiveCommutativeSemigroupTerm ->
           Set) ->
      ((x1 : AdditiveCommutativeSemigroupTerm)
       (x2 : AdditiveCommutativeSemigroupTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : AdditiveCommutativeSemigroupTerm) ->
      P x
    inductionB p p+l (+L x1 x2) =
      p+l _ _ (inductionB p p+l x1)
        (inductionB p p+l x2)
    inductionCl :
      (A : Set)
      (P : ClAdditiveCommutativeSemigroupTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClAdditiveCommutativeSemigroupTerm
          A)
       (x2 : ClAdditiveCommutativeSemigroupTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClAdditiveCommutativeSemigroupTerm
         A) -> P x
    inductionCl _ p psing p+cl (sing
                                x1) = psing x1
    inductionCl _ p psing p+cl (+Cl
                                x1
                                x2) =
      p+cl _ _
        (inductionCl _ p psing p+cl x1)
        (inductionCl _ p psing p+cl x2)
    inductionOp :
      (n : Nat)
      (P : OpAdditiveCommutativeSemigroupTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpAdditiveCommutativeSemigroupTerm
          n)
       (x2 : OpAdditiveCommutativeSemigroupTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpAdditiveCommutativeSemigroupTerm
         n) -> P x
    inductionOp _ p pv p+ol (v x1) =
      pv x1
    inductionOp _ p pv p+ol (+OL
                             x1
                             x2) =
      p+ol _ _
        (inductionOp _ p pv p+ol x1)
        (inductionOp _ p pv p+ol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAdditiveCommutativeSemigroupTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpAdditiveCommutativeSemigroupTerm2
          n
          A)
       (x2 : OpAdditiveCommutativeSemigroupTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpAdditiveCommutativeSemigroupTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p+ol2 (v2
                                         x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 (sing2
                                         x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 (+OL2
                                         x1
                                         x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           x2)
    +L' :
      AdditiveCommutativeSemigroupTerm ->
      AdditiveCommutativeSemigroupTerm ->
      AdditiveCommutativeSemigroupTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      AdditiveCommutativeSemigroupTerm ->
      Staged
        AdditiveCommutativeSemigroupTerm
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    +Cl' :
      (A : Set) ->
      ClAdditiveCommutativeSemigroupTerm
        A ->
      ClAdditiveCommutativeSemigroupTerm
        A ->
      ClAdditiveCommutativeSemigroupTerm
        A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClAdditiveCommutativeSemigroupTerm
        A ->
      Staged
        (ClAdditiveCommutativeSemigroupTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    +OL' :
      (n : Nat) ->
      OpAdditiveCommutativeSemigroupTerm
        n ->
      OpAdditiveCommutativeSemigroupTerm
        n ->
      OpAdditiveCommutativeSemigroupTerm
        n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpAdditiveCommutativeSemigroupTerm
        n ->
      Staged
        (OpAdditiveCommutativeSemigroupTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAdditiveCommutativeSemigroupTerm2
        n
        A ->
      OpAdditiveCommutativeSemigroupTerm2
        n
        A ->
      OpAdditiveCommutativeSemigroupTerm2
        n
        A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAdditiveCommutativeSemigroupTerm2
        n
        A ->
      Staged
        (OpAdditiveCommutativeSemigroupTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record AdditiveCommutativeSemigroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        +T : Repr A -> Repr A -> Repr A
  
  module AdditiveMagma where
    record AdditiveMagma
      (A : Set) : Set where
      constructor AdditiveMagmaC
      field
        + : A -> A -> A
    record AdditiveMagmaSig
      (AS : Set) : Set where
      constructor AdditiveMagmaSigSigC
      field
        +S : AS -> AS -> AS
    record AdditiveMagmaProd
      (AP : Set) : Set where
      constructor AdditiveMagmaProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record AdditiveMagmaHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveMagma A1)
      (Ad2 : AdditiveMagma A2) :
      Set where
      constructor AdditiveMagmaHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveMagma A1)
      (Ad2 : AdditiveMagma A2) :
      Set where
      constructor AdditiveMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveMagmaTerm
      : Set where
      +L :
        AdditiveMagmaTerm ->
        AdditiveMagmaTerm ->
        AdditiveMagmaTerm
    data ClAdditiveMagmaTerm
      (A : Set) : Set where
      sing :
        A -> ClAdditiveMagmaTerm A
      +Cl :
        ClAdditiveMagmaTerm A ->
        ClAdditiveMagmaTerm A ->
        ClAdditiveMagmaTerm A
    data OpAdditiveMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpAdditiveMagmaTerm n
      +OL :
        OpAdditiveMagmaTerm n ->
        OpAdditiveMagmaTerm n ->
        OpAdditiveMagmaTerm n
    data OpAdditiveMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAdditiveMagmaTerm2 n A
      sing2 :
        A -> OpAdditiveMagmaTerm2 n A
      +OL2 :
        OpAdditiveMagmaTerm2 n A ->
        OpAdditiveMagmaTerm2 n A ->
        OpAdditiveMagmaTerm2 n A
    simplifyB :
      AdditiveMagmaTerm ->
      AdditiveMagmaTerm
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClAdditiveMagmaTerm A ->
      ClAdditiveMagmaTerm A
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAdditiveMagmaTerm n ->
      OpAdditiveMagmaTerm n
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAdditiveMagmaTerm2 n A ->
      OpAdditiveMagmaTerm2 n A
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AdditiveMagma A ->
      AdditiveMagmaTerm -> A
    evalB _ Ad (+L x1 x2) =
      + Ad (evalB _ Ad x1)
        (evalB _ Ad x2)
    evalCl :
      (A : Set) ->
      AdditiveMagma A ->
      ClAdditiveMagmaTerm A -> A
    evalCl _ Ad (sing x1) = x1
    evalCl _ Ad (+Cl x1 x2) =
      + Ad (evalCl _ Ad x1)
        (evalCl _ Ad x2)
    evalOp :
      (A : Set) (n : Nat) ->
      AdditiveMagma A ->
      Vec A n ->
      OpAdditiveMagmaTerm n -> A
    evalOp _ n Ad vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ad vars (+OL x1 x2) =
      + Ad (evalOp _ n Ad vars x1)
        (evalOp _ n Ad vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      AdditiveMagma A ->
      Vec A n ->
      OpAdditiveMagmaTerm2 n A -> A
    evalOpE _ n Ad vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ad vars (sing2 x1) =
      x1
    evalOpE _ n Ad vars (+OL2
                         x1
                         x2) =
      + Ad (evalOpE _ n Ad vars x1)
        (evalOpE _ n Ad vars x2)
    inductionB :
      (P : AdditiveMagmaTerm ->
           Set) ->
      ((x1 : AdditiveMagmaTerm)
       (x2 : AdditiveMagmaTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : AdditiveMagmaTerm) -> P x
    inductionB p p+l (+L x1 x2) =
      p+l _ _ (inductionB p p+l x1)
        (inductionB p p+l x2)
    inductionCl :
      (A : Set)
      (P : ClAdditiveMagmaTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClAdditiveMagmaTerm A)
       (x2 : ClAdditiveMagmaTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClAdditiveMagmaTerm A) ->
      P x
    inductionCl _ p psing p+cl (sing
                                x1) = psing x1
    inductionCl _ p psing p+cl (+Cl
                                x1
                                x2) =
      p+cl _ _
        (inductionCl _ p psing p+cl x1)
        (inductionCl _ p psing p+cl x2)
    inductionOp :
      (n : Nat)
      (P : OpAdditiveMagmaTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpAdditiveMagmaTerm n)
       (x2 : OpAdditiveMagmaTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpAdditiveMagmaTerm n) ->
      P x
    inductionOp _ p pv p+ol (v x1) =
      pv x1
    inductionOp _ p pv p+ol (+OL
                             x1
                             x2) =
      p+ol _ _
        (inductionOp _ p pv p+ol x1)
        (inductionOp _ p pv p+ol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAdditiveMagmaTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpAdditiveMagmaTerm2 n A)
       (x2 : OpAdditiveMagmaTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpAdditiveMagmaTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p+ol2 (v2
                                         x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 (sing2
                                         x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 (+OL2
                                         x1
                                         x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           x2)
    +L' :
      AdditiveMagmaTerm ->
      AdditiveMagmaTerm ->
      AdditiveMagmaTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      AdditiveMagmaTerm ->
      Staged AdditiveMagmaTerm
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    +Cl' :
      (A : Set) ->
      ClAdditiveMagmaTerm A ->
      ClAdditiveMagmaTerm A ->
      ClAdditiveMagmaTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClAdditiveMagmaTerm A ->
      Staged (ClAdditiveMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    +OL' :
      (n : Nat) ->
      OpAdditiveMagmaTerm n ->
      OpAdditiveMagmaTerm n ->
      OpAdditiveMagmaTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpAdditiveMagmaTerm n ->
      Staged (OpAdditiveMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAdditiveMagmaTerm2 n A ->
      OpAdditiveMagmaTerm2 n A ->
      OpAdditiveMagmaTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAdditiveMagmaTerm2 n A ->
      Staged
        (OpAdditiveMagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record AdditiveMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        +T : Repr A -> Repr A -> Repr A
  
  module AdditiveMonoid where
    record AdditiveMonoid
      (A : Set) : Set where
      constructor AdditiveMonoidC
      field
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
    record AdditiveMonoidSig
      (AS : Set) : Set where
      constructor AdditiveMonoidSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
    record AdditiveMonoidProd
      (AP : Set) : Set where
      constructor AdditiveMonoidProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
    record AdditiveMonoidHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveMonoid A1)
      (Ad2 : AdditiveMonoid A2) :
      Set where
      constructor AdditiveMonoidHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
        pres-0 : hom (0 Ad1) == 0 Ad2
    record AdditiveMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveMonoid A1)
      (Ad2 : AdditiveMonoid A2) :
      Set where
      constructor AdditiveMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
        interp-0 :
          interp (0 Ad1) (0 Ad2)
    data AdditiveMonoidTerm
      : Set where
      +L :
        AdditiveMonoidTerm ->
        AdditiveMonoidTerm ->
        AdditiveMonoidTerm
      0L : AdditiveMonoidTerm
    data ClAdditiveMonoidTerm
      (A : Set) : Set where
      sing :
        A -> ClAdditiveMonoidTerm A
      +Cl :
        ClAdditiveMonoidTerm A ->
        ClAdditiveMonoidTerm A ->
        ClAdditiveMonoidTerm A
      0Cl : ClAdditiveMonoidTerm A
    data OpAdditiveMonoidTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpAdditiveMonoidTerm n
      +OL :
        OpAdditiveMonoidTerm n ->
        OpAdditiveMonoidTerm n ->
        OpAdditiveMonoidTerm n
      0OL : OpAdditiveMonoidTerm n
    data OpAdditiveMonoidTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAdditiveMonoidTerm2 n A
      sing2 :
        A -> OpAdditiveMonoidTerm2 n A
      +OL2 :
        OpAdditiveMonoidTerm2 n A ->
        OpAdditiveMonoidTerm2 n A ->
        OpAdditiveMonoidTerm2 n A
      0OL2 : OpAdditiveMonoidTerm2 n A
    simplifyB :
      AdditiveMonoidTerm ->
      AdditiveMonoidTerm
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (0L) = 0L
    simplifyCl :
      (A : Set) ->
      ClAdditiveMonoidTerm A ->
      ClAdditiveMonoidTerm A
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAdditiveMonoidTerm n ->
      OpAdditiveMonoidTerm n
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAdditiveMonoidTerm2 n A ->
      OpAdditiveMonoidTerm2 n A
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AdditiveMonoid A ->
      AdditiveMonoidTerm -> A
    evalB _ Ad (+L x1 x2) =
      + Ad (evalB _ Ad x1)
        (evalB _ Ad x2)
    evalB _ Ad (0L) = 0 Ad
    evalCl :
      (A : Set) ->
      AdditiveMonoid A ->
      ClAdditiveMonoidTerm A -> A
    evalCl _ Ad (sing x1) = x1
    evalCl _ Ad (+Cl x1 x2) =
      + Ad (evalCl _ Ad x1)
        (evalCl _ Ad x2)
    evalCl _ Ad (0Cl) = 0 Ad
    evalOp :
      (A : Set) (n : Nat) ->
      AdditiveMonoid A ->
      Vec A n ->
      OpAdditiveMonoidTerm n -> A
    evalOp _ n Ad vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ad vars (+OL x1 x2) =
      + Ad (evalOp _ n Ad vars x1)
        (evalOp _ n Ad vars x2)
    evalOp _ n Ad vars (0OL) = 0 Ad
    evalOpE :
      (A : Set) (n : Nat) ->
      AdditiveMonoid A ->
      Vec A n ->
      OpAdditiveMonoidTerm2 n A -> A
    evalOpE _ n Ad vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ad vars (sing2 x1) =
      x1
    evalOpE _ n Ad vars (+OL2
                         x1
                         x2) =
      + Ad (evalOpE _ n Ad vars x1)
        (evalOpE _ n Ad vars x2)
    evalOpE _ n Ad vars (0OL2) =
      0 Ad
    inductionB :
      (P : AdditiveMonoidTerm ->
           Set) ->
      ((x1 : AdditiveMonoidTerm)
       (x2 : AdditiveMonoidTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      P 0L ->
      (x : AdditiveMonoidTerm) -> P x
    inductionB p p+l p0l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p+l p0l x1)
        (inductionB p p+l p0l x2)
    inductionB p p+l p0l (0L) = p0l
    inductionCl :
      (A : Set)
      (P : ClAdditiveMonoidTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClAdditiveMonoidTerm A)
       (x2 : ClAdditiveMonoidTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      P 0Cl ->
      (x : ClAdditiveMonoidTerm A) ->
      P x
    inductionCl _ p psing p+cl p0cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p+cl p0cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p+cl p0cl
           x1)
        (inductionCl _ p psing p+cl p0cl
           x2)
    inductionCl _ p psing p+cl p0cl (0Cl) =
      p0cl
    inductionOp :
      (n : Nat)
      (P : OpAdditiveMonoidTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpAdditiveMonoidTerm n)
       (x2 : OpAdditiveMonoidTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      P 0OL ->
      (x : OpAdditiveMonoidTerm n) ->
      P x
    inductionOp _ p pv p+ol p0ol (v
                                  x1) = pv x1
    inductionOp _ p pv p+ol p0ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p+ol p0ol
           x1)
        (inductionOp _ p pv p+ol p0ol
           x2)
    inductionOp _ p pv p+ol p0ol (0OL) =
      p0ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAdditiveMonoidTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpAdditiveMonoidTerm2 n
          A)
       (x2 : OpAdditiveMonoidTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      P 0OL2 ->
      (x : OpAdditiveMonoidTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p0ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p0ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 (0OL2) =
      p0ol2
    +L' :
      AdditiveMonoidTerm ->
      AdditiveMonoidTerm ->
      AdditiveMonoidTerm
    +L' x1 x2 = +L x1 x2
    0L' : AdditiveMonoidTerm
    0L' = 0L
    stageB :
      AdditiveMonoidTerm ->
      Staged AdditiveMonoidTerm
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (0L) = Now 0L
    +Cl' :
      (A : Set) ->
      ClAdditiveMonoidTerm A ->
      ClAdditiveMonoidTerm A ->
      ClAdditiveMonoidTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    0Cl' :
      (A : Set) ->
      ClAdditiveMonoidTerm A
    0Cl' _ = 0Cl
    stageCl :
      (A : Set) ->
      ClAdditiveMonoidTerm A ->
      Staged (ClAdditiveMonoidTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (0Cl) = Now 0Cl
    +OL' :
      (n : Nat) ->
      OpAdditiveMonoidTerm n ->
      OpAdditiveMonoidTerm n ->
      OpAdditiveMonoidTerm n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      OpAdditiveMonoidTerm n
    0OL' _ = 0OL
    stageOp :
      (n : Nat) ->
      OpAdditiveMonoidTerm n ->
      Staged (OpAdditiveMonoidTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (0OL) = Now 0OL
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAdditiveMonoidTerm2 n A ->
      OpAdditiveMonoidTerm2 n A ->
      OpAdditiveMonoidTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    0OL2' :
      (n : Nat) (A : Set) ->
      OpAdditiveMonoidTerm2 n A
    0OL2' _ _ = 0OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAdditiveMonoidTerm2 n A ->
      Staged
        (OpAdditiveMonoidTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (0OL2) = Now 0OL2
    record AdditiveMonoidTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        +T : Repr A -> Repr A -> Repr A
        0T : Repr A
  
  module AdditivePointedMagma where
    record AdditivePointedMagma
      (A : Set) : Set where
      constructor AdditivePointedMagmaC
      field
        0 : A
        + : A -> A -> A
    record AdditivePointedMagmaSig
      (AS : Set) : Set where
      constructor AdditivePointedMagmaSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
    record AdditivePointedMagmaProd
      (AP : Set) : Set where
      constructor AdditivePointedMagmaProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record AdditivePointedMagmaHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditivePointedMagma A1)
      (Ad2 : AdditivePointedMagma
         A2) : Set where
      constructor AdditivePointedMagmaHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditivePointedMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditivePointedMagma A1)
      (Ad2 : AdditivePointedMagma
         A2) : Set where
      constructor AdditivePointedMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditivePointedMagmaTerm
      : Set where
      0L : AdditivePointedMagmaTerm
      +L :
        AdditivePointedMagmaTerm ->
        AdditivePointedMagmaTerm ->
        AdditivePointedMagmaTerm
    data ClAdditivePointedMagmaTerm
      (A : Set) : Set where
      sing :
        A ->
        ClAdditivePointedMagmaTerm A
      0Cl :
        ClAdditivePointedMagmaTerm A
      +Cl :
        ClAdditivePointedMagmaTerm A ->
        ClAdditivePointedMagmaTerm A ->
        ClAdditivePointedMagmaTerm A
    data OpAdditivePointedMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpAdditivePointedMagmaTerm n
      0OL :
        OpAdditivePointedMagmaTerm n
      +OL :
        OpAdditivePointedMagmaTerm n ->
        OpAdditivePointedMagmaTerm n ->
        OpAdditivePointedMagmaTerm n
    data OpAdditivePointedMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAdditivePointedMagmaTerm2 n A
      sing2 :
        A ->
        OpAdditivePointedMagmaTerm2 n A
      0OL2 :
        OpAdditivePointedMagmaTerm2 n A
      +OL2 :
        OpAdditivePointedMagmaTerm2 n
          A ->
        OpAdditivePointedMagmaTerm2 n
          A ->
        OpAdditivePointedMagmaTerm2 n A
    simplifyB :
      AdditivePointedMagmaTerm ->
      AdditivePointedMagmaTerm
    simplifyB (0L) = 0L
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClAdditivePointedMagmaTerm A ->
      ClAdditivePointedMagmaTerm A
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAdditivePointedMagmaTerm n ->
      OpAdditivePointedMagmaTerm n
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAdditivePointedMagmaTerm2 n
        A ->
      OpAdditivePointedMagmaTerm2 n A
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AdditivePointedMagma A ->
      AdditivePointedMagmaTerm -> A
    evalB _ Ad (0L) = 0 Ad
    evalB _ Ad (+L x1 x2) =
      + Ad (evalB _ Ad x1)
        (evalB _ Ad x2)
    evalCl :
      (A : Set) ->
      AdditivePointedMagma A ->
      ClAdditivePointedMagmaTerm A ->
      A
    evalCl _ Ad (sing x1) = x1
    evalCl _ Ad (0Cl) = 0 Ad
    evalCl _ Ad (+Cl x1 x2) =
      + Ad (evalCl _ Ad x1)
        (evalCl _ Ad x2)
    evalOp :
      (A : Set) (n : Nat) ->
      AdditivePointedMagma A ->
      Vec A n ->
      OpAdditivePointedMagmaTerm n ->
      A
    evalOp _ n Ad vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ad vars (0OL) = 0 Ad
    evalOp _ n Ad vars (+OL x1 x2) =
      + Ad (evalOp _ n Ad vars x1)
        (evalOp _ n Ad vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      AdditivePointedMagma A ->
      Vec A n ->
      OpAdditivePointedMagmaTerm2 n
        A -> A
    evalOpE _ n Ad vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ad vars (sing2 x1) =
      x1
    evalOpE _ n Ad vars (0OL2) =
      0 Ad
    evalOpE _ n Ad vars (+OL2
                         x1
                         x2) =
      + Ad (evalOpE _ n Ad vars x1)
        (evalOpE _ n Ad vars x2)
    inductionB :
      (P : AdditivePointedMagmaTerm ->
           Set) ->
      P 0L ->
      ((x1 : AdditivePointedMagmaTerm)
       (x2 : AdditivePointedMagmaTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : AdditivePointedMagmaTerm) ->
      P x
    inductionB p p0l p+l (0L) = p0l
    inductionB p p0l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p0l p+l x1)
        (inductionB p p0l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClAdditivePointedMagmaTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 0Cl ->
      ((x1 : ClAdditivePointedMagmaTerm
          A)
       (x2 : ClAdditivePointedMagmaTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClAdditivePointedMagmaTerm
         A) -> P x
    inductionCl _ p psing p0cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p0cl p+cl (0Cl) =
      p0cl
    inductionCl _ p psing p0cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p0cl p+cl
           x1)
        (inductionCl _ p psing p0cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpAdditivePointedMagmaTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 0OL ->
      ((x1 : OpAdditivePointedMagmaTerm
          n)
       (x2 : OpAdditivePointedMagmaTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpAdditivePointedMagmaTerm
         n) -> P x
    inductionOp _ p pv p0ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p0ol p+ol (0OL) =
      p0ol
    inductionOp _ p pv p0ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p0ol p+ol
           x1)
        (inductionOp _ p pv p0ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAdditivePointedMagmaTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 0OL2 ->
      ((x1 : OpAdditivePointedMagmaTerm2
          n
          A)
       (x2 : OpAdditivePointedMagmaTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpAdditivePointedMagmaTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           x2)
    0L' : AdditivePointedMagmaTerm
    0L' = 0L
    +L' :
      AdditivePointedMagmaTerm ->
      AdditivePointedMagmaTerm ->
      AdditivePointedMagmaTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      AdditivePointedMagmaTerm ->
      Staged AdditivePointedMagmaTerm
    stageB (0L) = Now 0L
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    0Cl' :
      (A : Set) ->
      ClAdditivePointedMagmaTerm A
    0Cl' _ = 0Cl
    +Cl' :
      (A : Set) ->
      ClAdditivePointedMagmaTerm A ->
      ClAdditivePointedMagmaTerm A ->
      ClAdditivePointedMagmaTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClAdditivePointedMagmaTerm A ->
      Staged
        (ClAdditivePointedMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    0OL' :
      (n : Nat) ->
      OpAdditivePointedMagmaTerm n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      OpAdditivePointedMagmaTerm n ->
      OpAdditivePointedMagmaTerm n ->
      OpAdditivePointedMagmaTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpAdditivePointedMagmaTerm n ->
      Staged
        (OpAdditivePointedMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (0OL) = Now 0OL
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    0OL2' :
      (n : Nat) (A : Set) ->
      OpAdditivePointedMagmaTerm2 n A
    0OL2' _ _ = 0OL2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAdditivePointedMagmaTerm2 n
        A ->
      OpAdditivePointedMagmaTerm2 n
        A ->
      OpAdditivePointedMagmaTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAdditivePointedMagmaTerm2 n
        A ->
      Staged
        (OpAdditivePointedMagmaTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record AdditivePointedMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        0T : Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module AdditivePointedSemigroup where
    record AdditivePointedSemigroup
      (A : Set) : Set where
      constructor AdditivePointedSemigroupC
      field
        0 : A
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record AdditivePointedSemigroupSig
      (AS : Set) : Set where
      constructor AdditivePointedSemigroupSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
    record AdditivePointedSemigroupProd
      (AP : Set) : Set where
      constructor AdditivePointedSemigroupProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record AdditivePointedSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditivePointedSemigroup
         A1)
      (Ad2 : AdditivePointedSemigroup
         A2) : Set where
      constructor AdditivePointedSemigroupHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditivePointedSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditivePointedSemigroup
         A1)
      (Ad2 : AdditivePointedSemigroup
         A2) : Set where
      constructor AdditivePointedSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditivePointedSemigroupTerm
      : Set where
      0L :
        AdditivePointedSemigroupTerm
      +L :
        AdditivePointedSemigroupTerm ->
        AdditivePointedSemigroupTerm ->
        AdditivePointedSemigroupTerm
    data ClAdditivePointedSemigroupTerm
      (A : Set) : Set where
      sing :
        A ->
        ClAdditivePointedSemigroupTerm A
      0Cl :
        ClAdditivePointedSemigroupTerm A
      +Cl :
        ClAdditivePointedSemigroupTerm
          A ->
        ClAdditivePointedSemigroupTerm
          A ->
        ClAdditivePointedSemigroupTerm A
    data OpAdditivePointedSemigroupTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpAdditivePointedSemigroupTerm n
      0OL :
        OpAdditivePointedSemigroupTerm n
      +OL :
        OpAdditivePointedSemigroupTerm
          n ->
        OpAdditivePointedSemigroupTerm
          n ->
        OpAdditivePointedSemigroupTerm n
    data OpAdditivePointedSemigroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAdditivePointedSemigroupTerm2
          n
          A
      sing2 :
        A ->
        OpAdditivePointedSemigroupTerm2
          n
          A
      0OL2 :
        OpAdditivePointedSemigroupTerm2
          n
          A
      +OL2 :
        OpAdditivePointedSemigroupTerm2
          n
          A ->
        OpAdditivePointedSemigroupTerm2
          n
          A ->
        OpAdditivePointedSemigroupTerm2
          n
          A
    simplifyB :
      AdditivePointedSemigroupTerm ->
      AdditivePointedSemigroupTerm
    simplifyB (0L) = 0L
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClAdditivePointedSemigroupTerm
        A ->
      ClAdditivePointedSemigroupTerm A
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAdditivePointedSemigroupTerm
        n ->
      OpAdditivePointedSemigroupTerm n
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAdditivePointedSemigroupTerm2
        n
        A ->
      OpAdditivePointedSemigroupTerm2
        n
        A
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AdditivePointedSemigroup A ->
      AdditivePointedSemigroupTerm ->
      A
    evalB _ Ad (0L) = 0 Ad
    evalB _ Ad (+L x1 x2) =
      + Ad (evalB _ Ad x1)
        (evalB _ Ad x2)
    evalCl :
      (A : Set) ->
      AdditivePointedSemigroup A ->
      ClAdditivePointedSemigroupTerm
        A -> A
    evalCl _ Ad (sing x1) = x1
    evalCl _ Ad (0Cl) = 0 Ad
    evalCl _ Ad (+Cl x1 x2) =
      + Ad (evalCl _ Ad x1)
        (evalCl _ Ad x2)
    evalOp :
      (A : Set) (n : Nat) ->
      AdditivePointedSemigroup A ->
      Vec A n ->
      OpAdditivePointedSemigroupTerm
        n -> A
    evalOp _ n Ad vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ad vars (0OL) = 0 Ad
    evalOp _ n Ad vars (+OL x1 x2) =
      + Ad (evalOp _ n Ad vars x1)
        (evalOp _ n Ad vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      AdditivePointedSemigroup A ->
      Vec A n ->
      OpAdditivePointedSemigroupTerm2
        n
        A -> A
    evalOpE _ n Ad vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ad vars (sing2 x1) =
      x1
    evalOpE _ n Ad vars (0OL2) =
      0 Ad
    evalOpE _ n Ad vars (+OL2
                         x1
                         x2) =
      + Ad (evalOpE _ n Ad vars x1)
        (evalOpE _ n Ad vars x2)
    inductionB :
      (P : AdditivePointedSemigroupTerm ->
           Set) ->
      P 0L ->
      ((x1 : AdditivePointedSemigroupTerm)
       (x2 : AdditivePointedSemigroupTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : AdditivePointedSemigroupTerm) ->
      P x
    inductionB p p0l p+l (0L) = p0l
    inductionB p p0l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p0l p+l x1)
        (inductionB p p0l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClAdditivePointedSemigroupTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 0Cl ->
      ((x1 : ClAdditivePointedSemigroupTerm
          A)
       (x2 : ClAdditivePointedSemigroupTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClAdditivePointedSemigroupTerm
         A) -> P x
    inductionCl _ p psing p0cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p0cl p+cl (0Cl) =
      p0cl
    inductionCl _ p psing p0cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p0cl p+cl
           x1)
        (inductionCl _ p psing p0cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpAdditivePointedSemigroupTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 0OL ->
      ((x1 : OpAdditivePointedSemigroupTerm
          n)
       (x2 : OpAdditivePointedSemigroupTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpAdditivePointedSemigroupTerm
         n) -> P x
    inductionOp _ p pv p0ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p0ol p+ol (0OL) =
      p0ol
    inductionOp _ p pv p0ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p0ol p+ol
           x1)
        (inductionOp _ p pv p0ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAdditivePointedSemigroupTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 0OL2 ->
      ((x1 : OpAdditivePointedSemigroupTerm2
          n
          A)
       (x2 : OpAdditivePointedSemigroupTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpAdditivePointedSemigroupTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           x2)
    0L' :
      AdditivePointedSemigroupTerm
    0L' = 0L
    +L' :
      AdditivePointedSemigroupTerm ->
      AdditivePointedSemigroupTerm ->
      AdditivePointedSemigroupTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      AdditivePointedSemigroupTerm ->
      Staged
        AdditivePointedSemigroupTerm
    stageB (0L) = Now 0L
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    0Cl' :
      (A : Set) ->
      ClAdditivePointedSemigroupTerm A
    0Cl' _ = 0Cl
    +Cl' :
      (A : Set) ->
      ClAdditivePointedSemigroupTerm
        A ->
      ClAdditivePointedSemigroupTerm
        A ->
      ClAdditivePointedSemigroupTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClAdditivePointedSemigroupTerm
        A ->
      Staged
        (ClAdditivePointedSemigroupTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    0OL' :
      (n : Nat) ->
      OpAdditivePointedSemigroupTerm n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      OpAdditivePointedSemigroupTerm
        n ->
      OpAdditivePointedSemigroupTerm
        n ->
      OpAdditivePointedSemigroupTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpAdditivePointedSemigroupTerm
        n ->
      Staged
        (OpAdditivePointedSemigroupTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (0OL) = Now 0OL
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    0OL2' :
      (n : Nat) (A : Set) ->
      OpAdditivePointedSemigroupTerm2
        n
        A
    0OL2' _ _ = 0OL2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAdditivePointedSemigroupTerm2
        n
        A ->
      OpAdditivePointedSemigroupTerm2
        n
        A ->
      OpAdditivePointedSemigroupTerm2
        n
        A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAdditivePointedSemigroupTerm2
        n
        A ->
      Staged
        (OpAdditivePointedSemigroupTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record AdditivePointedSemigroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        0T : Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module AdditiveSemigroup where
    record AdditiveSemigroup
      (A : Set) : Set where
      constructor AdditiveSemigroupC
      field
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record AdditiveSemigroupSig
      (AS : Set) : Set where
      constructor AdditiveSemigroupSigSigC
      field
        +S : AS -> AS -> AS
    record AdditiveSemigroupProd
      (AP : Set) : Set where
      constructor AdditiveSemigroupProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record AdditiveSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveSemigroup A1)
      (Ad2 : AdditiveSemigroup A2) :
      Set where
      constructor AdditiveSemigroupHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveSemigroup A1)
      (Ad2 : AdditiveSemigroup A2) :
      Set where
      constructor AdditiveSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveSemigroupTerm
      : Set where
      +L :
        AdditiveSemigroupTerm ->
        AdditiveSemigroupTerm ->
        AdditiveSemigroupTerm
    data ClAdditiveSemigroupTerm
      (A : Set) : Set where
      sing :
        A -> ClAdditiveSemigroupTerm A
      +Cl :
        ClAdditiveSemigroupTerm A ->
        ClAdditiveSemigroupTerm A ->
        ClAdditiveSemigroupTerm A
    data OpAdditiveSemigroupTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpAdditiveSemigroupTerm n
      +OL :
        OpAdditiveSemigroupTerm n ->
        OpAdditiveSemigroupTerm n ->
        OpAdditiveSemigroupTerm n
    data OpAdditiveSemigroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAdditiveSemigroupTerm2 n A
      sing2 :
        A ->
        OpAdditiveSemigroupTerm2 n A
      +OL2 :
        OpAdditiveSemigroupTerm2 n A ->
        OpAdditiveSemigroupTerm2 n A ->
        OpAdditiveSemigroupTerm2 n A
    simplifyB :
      AdditiveSemigroupTerm ->
      AdditiveSemigroupTerm
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClAdditiveSemigroupTerm A ->
      ClAdditiveSemigroupTerm A
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAdditiveSemigroupTerm n ->
      OpAdditiveSemigroupTerm n
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAdditiveSemigroupTerm2 n A ->
      OpAdditiveSemigroupTerm2 n A
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AdditiveSemigroup A ->
      AdditiveSemigroupTerm -> A
    evalB _ Ad (+L x1 x2) =
      + Ad (evalB _ Ad x1)
        (evalB _ Ad x2)
    evalCl :
      (A : Set) ->
      AdditiveSemigroup A ->
      ClAdditiveSemigroupTerm A -> A
    evalCl _ Ad (sing x1) = x1
    evalCl _ Ad (+Cl x1 x2) =
      + Ad (evalCl _ Ad x1)
        (evalCl _ Ad x2)
    evalOp :
      (A : Set) (n : Nat) ->
      AdditiveSemigroup A ->
      Vec A n ->
      OpAdditiveSemigroupTerm n -> A
    evalOp _ n Ad vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ad vars (+OL x1 x2) =
      + Ad (evalOp _ n Ad vars x1)
        (evalOp _ n Ad vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      AdditiveSemigroup A ->
      Vec A n ->
      OpAdditiveSemigroupTerm2 n A ->
      A
    evalOpE _ n Ad vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ad vars (sing2 x1) =
      x1
    evalOpE _ n Ad vars (+OL2
                         x1
                         x2) =
      + Ad (evalOpE _ n Ad vars x1)
        (evalOpE _ n Ad vars x2)
    inductionB :
      (P : AdditiveSemigroupTerm ->
           Set) ->
      ((x1 : AdditiveSemigroupTerm)
       (x2 : AdditiveSemigroupTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : AdditiveSemigroupTerm) ->
      P x
    inductionB p p+l (+L x1 x2) =
      p+l _ _ (inductionB p p+l x1)
        (inductionB p p+l x2)
    inductionCl :
      (A : Set)
      (P : ClAdditiveSemigroupTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClAdditiveSemigroupTerm
          A)
       (x2 : ClAdditiveSemigroupTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClAdditiveSemigroupTerm
         A) -> P x
    inductionCl _ p psing p+cl (sing
                                x1) = psing x1
    inductionCl _ p psing p+cl (+Cl
                                x1
                                x2) =
      p+cl _ _
        (inductionCl _ p psing p+cl x1)
        (inductionCl _ p psing p+cl x2)
    inductionOp :
      (n : Nat)
      (P : OpAdditiveSemigroupTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpAdditiveSemigroupTerm
          n)
       (x2 : OpAdditiveSemigroupTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpAdditiveSemigroupTerm
         n) -> P x
    inductionOp _ p pv p+ol (v x1) =
      pv x1
    inductionOp _ p pv p+ol (+OL
                             x1
                             x2) =
      p+ol _ _
        (inductionOp _ p pv p+ol x1)
        (inductionOp _ p pv p+ol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAdditiveSemigroupTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpAdditiveSemigroupTerm2
          n
          A)
       (x2 : OpAdditiveSemigroupTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpAdditiveSemigroupTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p+ol2 (v2
                                         x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 (sing2
                                         x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 (+OL2
                                         x1
                                         x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           x2)
    +L' :
      AdditiveSemigroupTerm ->
      AdditiveSemigroupTerm ->
      AdditiveSemigroupTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      AdditiveSemigroupTerm ->
      Staged AdditiveSemigroupTerm
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    +Cl' :
      (A : Set) ->
      ClAdditiveSemigroupTerm A ->
      ClAdditiveSemigroupTerm A ->
      ClAdditiveSemigroupTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClAdditiveSemigroupTerm A ->
      Staged
        (ClAdditiveSemigroupTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    +OL' :
      (n : Nat) ->
      OpAdditiveSemigroupTerm n ->
      OpAdditiveSemigroupTerm n ->
      OpAdditiveSemigroupTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpAdditiveSemigroupTerm n ->
      Staged
        (OpAdditiveSemigroupTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAdditiveSemigroupTerm2 n A ->
      OpAdditiveSemigroupTerm2 n A ->
      OpAdditiveSemigroupTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAdditiveSemigroupTerm2 n A ->
      Staged
        (OpAdditiveSemigroupTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record AdditiveSemigroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        +T : Repr A -> Repr A -> Repr A
  
  module AdditiveUnital where
    record AdditiveUnital
      (A : Set) : Set where
      constructor AdditiveUnitalC
      field
        0 : A
        + : A -> A -> A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
    record AdditiveUnitalSig
      (AS : Set) : Set where
      constructor AdditiveUnitalSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
    record AdditiveUnitalProd
      (AP : Set) : Set where
      constructor AdditiveUnitalProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
    record AdditiveUnitalHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveUnital A1)
      (Ad2 : AdditiveUnital A2) :
      Set where
      constructor AdditiveUnitalHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveUnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveUnital A1)
      (Ad2 : AdditiveUnital A2) :
      Set where
      constructor AdditiveUnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveUnitalTerm
      : Set where
      0L : AdditiveUnitalTerm
      +L :
        AdditiveUnitalTerm ->
        AdditiveUnitalTerm ->
        AdditiveUnitalTerm
    data ClAdditiveUnitalTerm
      (A : Set) : Set where
      sing :
        A -> ClAdditiveUnitalTerm A
      0Cl : ClAdditiveUnitalTerm A
      +Cl :
        ClAdditiveUnitalTerm A ->
        ClAdditiveUnitalTerm A ->
        ClAdditiveUnitalTerm A
    data OpAdditiveUnitalTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpAdditiveUnitalTerm n
      0OL : OpAdditiveUnitalTerm n
      +OL :
        OpAdditiveUnitalTerm n ->
        OpAdditiveUnitalTerm n ->
        OpAdditiveUnitalTerm n
    data OpAdditiveUnitalTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAdditiveUnitalTerm2 n A
      sing2 :
        A -> OpAdditiveUnitalTerm2 n A
      0OL2 : OpAdditiveUnitalTerm2 n A
      +OL2 :
        OpAdditiveUnitalTerm2 n A ->
        OpAdditiveUnitalTerm2 n A ->
        OpAdditiveUnitalTerm2 n A
    simplifyB :
      AdditiveUnitalTerm ->
      AdditiveUnitalTerm
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (0L) = 0L
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClAdditiveUnitalTerm A ->
      ClAdditiveUnitalTerm A
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAdditiveUnitalTerm n ->
      OpAdditiveUnitalTerm n
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAdditiveUnitalTerm2 n A ->
      OpAdditiveUnitalTerm2 n A
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AdditiveUnital A ->
      AdditiveUnitalTerm -> A
    evalB _ Ad (0L) = 0 Ad
    evalB _ Ad (+L x1 x2) =
      + Ad (evalB _ Ad x1)
        (evalB _ Ad x2)
    evalCl :
      (A : Set) ->
      AdditiveUnital A ->
      ClAdditiveUnitalTerm A -> A
    evalCl _ Ad (sing x1) = x1
    evalCl _ Ad (0Cl) = 0 Ad
    evalCl _ Ad (+Cl x1 x2) =
      + Ad (evalCl _ Ad x1)
        (evalCl _ Ad x2)
    evalOp :
      (A : Set) (n : Nat) ->
      AdditiveUnital A ->
      Vec A n ->
      OpAdditiveUnitalTerm n -> A
    evalOp _ n Ad vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ad vars (0OL) = 0 Ad
    evalOp _ n Ad vars (+OL x1 x2) =
      + Ad (evalOp _ n Ad vars x1)
        (evalOp _ n Ad vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      AdditiveUnital A ->
      Vec A n ->
      OpAdditiveUnitalTerm2 n A -> A
    evalOpE _ n Ad vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ad vars (sing2 x1) =
      x1
    evalOpE _ n Ad vars (0OL2) =
      0 Ad
    evalOpE _ n Ad vars (+OL2
                         x1
                         x2) =
      + Ad (evalOpE _ n Ad vars x1)
        (evalOpE _ n Ad vars x2)
    inductionB :
      (P : AdditiveUnitalTerm ->
           Set) ->
      P 0L ->
      ((x1 : AdditiveUnitalTerm)
       (x2 : AdditiveUnitalTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : AdditiveUnitalTerm) -> P x
    inductionB p p0l p+l (0L) = p0l
    inductionB p p0l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p0l p+l x1)
        (inductionB p p0l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClAdditiveUnitalTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 0Cl ->
      ((x1 : ClAdditiveUnitalTerm A)
       (x2 : ClAdditiveUnitalTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClAdditiveUnitalTerm A) ->
      P x
    inductionCl _ p psing p0cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p0cl p+cl (0Cl) =
      p0cl
    inductionCl _ p psing p0cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p0cl p+cl
           x1)
        (inductionCl _ p psing p0cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpAdditiveUnitalTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 0OL ->
      ((x1 : OpAdditiveUnitalTerm n)
       (x2 : OpAdditiveUnitalTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpAdditiveUnitalTerm n) ->
      P x
    inductionOp _ p pv p0ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p0ol p+ol (0OL) =
      p0ol
    inductionOp _ p pv p0ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p0ol p+ol
           x1)
        (inductionOp _ p pv p0ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAdditiveUnitalTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 0OL2 ->
      ((x1 : OpAdditiveUnitalTerm2 n
          A)
       (x2 : OpAdditiveUnitalTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpAdditiveUnitalTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           x2)
    0L' : AdditiveUnitalTerm
    0L' = 0L
    +L' :
      AdditiveUnitalTerm ->
      AdditiveUnitalTerm ->
      AdditiveUnitalTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      AdditiveUnitalTerm ->
      Staged AdditiveUnitalTerm
    stageB (0L) = Now 0L
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    0Cl' :
      (A : Set) ->
      ClAdditiveUnitalTerm A
    0Cl' _ = 0Cl
    +Cl' :
      (A : Set) ->
      ClAdditiveUnitalTerm A ->
      ClAdditiveUnitalTerm A ->
      ClAdditiveUnitalTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClAdditiveUnitalTerm A ->
      Staged (ClAdditiveUnitalTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    0OL' :
      (n : Nat) ->
      OpAdditiveUnitalTerm n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      OpAdditiveUnitalTerm n ->
      OpAdditiveUnitalTerm n ->
      OpAdditiveUnitalTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpAdditiveUnitalTerm n ->
      Staged (OpAdditiveUnitalTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (0OL) = Now 0OL
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    0OL2' :
      (n : Nat) (A : Set) ->
      OpAdditiveUnitalTerm2 n A
    0OL2' _ _ = 0OL2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAdditiveUnitalTerm2 n A ->
      OpAdditiveUnitalTerm2 n A ->
      OpAdditiveUnitalTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAdditiveUnitalTerm2 n A ->
      Staged
        (OpAdditiveUnitalTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record AdditiveUnitalTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        0T : Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module Carrier where
    record Carrier
      (A : Set) : Set where
      constructor CarrierC
      field
        
    record CarrierSig
      (AS : Set) : Set where
      constructor CarrierSigSigC
      field
        
    record CarrierProd
      (AP : Set) : Set where
      constructor CarrierProdC
      field
        
    record CarrierHom
      (A1 : Set) (A2 : Set)
      (Ca1 : Carrier A1)
      (Ca2 : Carrier A2) : Set where
      constructor CarrierHomC
      field
        hom : A1 -> A2
    record CarrierRelInterp
      (A1 : Set) (A2 : Set)
      (Ca1 : Carrier A1)
      (Ca2 : Carrier A2) : Set where
      constructor CarrierRelInterpC
      field
        interp : A1 -> A2 -> Set
    data CarrierTerm : Set where
      
    data ClCarrierTerm
      (A : Set) : Set where
      sing : A -> ClCarrierTerm A
    data OpCarrierTerm
      (n : Nat) : Set where
      v : Fin n -> OpCarrierTerm n
    data OpCarrierTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpCarrierTerm2 n A
      sing2 : A -> OpCarrierTerm2 n A
    simplifyB :
      CarrierTerm -> CarrierTerm
    simplifyCl :
      (A : Set) ->
      ClCarrierTerm A ->
      ClCarrierTerm A
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpCarrierTerm n ->
      OpCarrierTerm n
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpCarrierTerm2 n A ->
      OpCarrierTerm2 n A
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Carrier A -> CarrierTerm -> A
    evalCl :
      (A : Set) ->
      Carrier A ->
      ClCarrierTerm A -> A
    evalCl _ Ca (sing x1) = x1
    evalOp :
      (A : Set) (n : Nat) ->
      Carrier A ->
      Vec A n -> OpCarrierTerm n -> A
    evalOp _ n Ca vars (v x1) =
      lookup _ n x1 vars
    evalOpE :
      (A : Set) (n : Nat) ->
      Carrier A ->
      Vec A n ->
      OpCarrierTerm2 n A -> A
    evalOpE _ n Ca vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ca vars (sing2 x1) =
      x1
    inductionB :
      (P : CarrierTerm -> Set)
      (x : CarrierTerm) -> P x
    inductionCl :
      (A : Set)
      (P : ClCarrierTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      (x : ClCarrierTerm A) -> P x
    inductionCl _ p psing (sing
                           x1) = psing x1
    inductionOp :
      (n : Nat)
      (P : OpCarrierTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      (x : OpCarrierTerm n) -> P x
    inductionOp _ p pv (v x1) =
      pv x1
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpCarrierTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      (x : OpCarrierTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 (v2
                                   x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 (sing2
                                   x1) = psing2 x1
    stageB :
      CarrierTerm ->
      Staged CarrierTerm
    stageCl :
      (A : Set) ->
      ClCarrierTerm A ->
      Staged (ClCarrierTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageOp :
      (n : Nat) ->
      OpCarrierTerm n ->
      Staged (OpCarrierTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOpE :
      (n : Nat) (A : Set) ->
      OpCarrierTerm2 n A ->
      Staged (OpCarrierTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    record CarrierTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        
  
  module CommutativeMagma where
    record CommutativeMagma
      (A : Set) : Set where
      constructor CommutativeMagmaC
      field
        op : A -> A -> A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CommutativeMagmaSig
      (AS : Set) : Set where
      constructor CommutativeMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record CommutativeMagmaProd
      (AP : Set) : Set where
      constructor CommutativeMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CommutativeMagmaHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMagma A1)
      (Co2 : CommutativeMagma A2) :
      Set where
      constructor CommutativeMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
    record CommutativeMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMagma A1)
      (Co2 : CommutativeMagma A2) :
      Set where
      constructor CommutativeMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
    data CommutativeMagmaTerm
      : Set where
      opL :
        CommutativeMagmaTerm ->
        CommutativeMagmaTerm ->
        CommutativeMagmaTerm
    data ClCommutativeMagmaTerm
      (A : Set) : Set where
      sing :
        A -> ClCommutativeMagmaTerm A
      opCl :
        ClCommutativeMagmaTerm A ->
        ClCommutativeMagmaTerm A ->
        ClCommutativeMagmaTerm A
    data OpCommutativeMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpCommutativeMagmaTerm n
      opOL :
        OpCommutativeMagmaTerm n ->
        OpCommutativeMagmaTerm n ->
        OpCommutativeMagmaTerm n
    data OpCommutativeMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpCommutativeMagmaTerm2 n A
      sing2 :
        A -> OpCommutativeMagmaTerm2 n A
      opOL2 :
        OpCommutativeMagmaTerm2 n A ->
        OpCommutativeMagmaTerm2 n A ->
        OpCommutativeMagmaTerm2 n A
    simplifyB :
      CommutativeMagmaTerm ->
      CommutativeMagmaTerm
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClCommutativeMagmaTerm A ->
      ClCommutativeMagmaTerm A
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpCommutativeMagmaTerm n ->
      OpCommutativeMagmaTerm n
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpCommutativeMagmaTerm2 n A ->
      OpCommutativeMagmaTerm2 n A
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      CommutativeMagma A ->
      CommutativeMagmaTerm -> A
    evalB _ Co (opL x1 x2) =
      op Co (evalB _ Co x1)
        (evalB _ Co x2)
    evalCl :
      (A : Set) ->
      CommutativeMagma A ->
      ClCommutativeMagmaTerm A -> A
    evalCl _ Co (sing x1) = x1
    evalCl _ Co (opCl x1 x2) =
      op Co (evalCl _ Co x1)
        (evalCl _ Co x2)
    evalOp :
      (A : Set) (n : Nat) ->
      CommutativeMagma A ->
      Vec A n ->
      OpCommutativeMagmaTerm n -> A
    evalOp _ n Co vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Co vars (opOL
                        x1
                        x2) =
      op Co (evalOp _ n Co vars x1)
        (evalOp _ n Co vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      CommutativeMagma A ->
      Vec A n ->
      OpCommutativeMagmaTerm2 n A -> A
    evalOpE _ n Co vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Co vars (sing2 x1) =
      x1
    evalOpE _ n Co vars (opOL2
                         x1
                         x2) =
      op Co (evalOpE _ n Co vars x1)
        (evalOpE _ n Co vars x2)
    inductionB :
      (P : CommutativeMagmaTerm ->
           Set) ->
      ((x1 : CommutativeMagmaTerm)
       (x2 : CommutativeMagmaTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : CommutativeMagmaTerm) ->
      P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClCommutativeMagmaTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClCommutativeMagmaTerm A)
       (x2 : ClCommutativeMagmaTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClCommutativeMagmaTerm
         A) -> P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpCommutativeMagmaTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpCommutativeMagmaTerm n)
       (x2 : OpCommutativeMagmaTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpCommutativeMagmaTerm
         n) -> P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpCommutativeMagmaTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpCommutativeMagmaTerm2 n
          A)
       (x2 : OpCommutativeMagmaTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpCommutativeMagmaTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      CommutativeMagmaTerm ->
      CommutativeMagmaTerm ->
      CommutativeMagmaTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      CommutativeMagmaTerm ->
      Staged CommutativeMagmaTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClCommutativeMagmaTerm A ->
      ClCommutativeMagmaTerm A ->
      ClCommutativeMagmaTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClCommutativeMagmaTerm A ->
      Staged
        (ClCommutativeMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpCommutativeMagmaTerm n ->
      OpCommutativeMagmaTerm n ->
      OpCommutativeMagmaTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpCommutativeMagmaTerm n ->
      Staged
        (OpCommutativeMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpCommutativeMagmaTerm2 n A ->
      OpCommutativeMagmaTerm2 n A ->
      OpCommutativeMagmaTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpCommutativeMagmaTerm2 n A ->
      Staged
        (OpCommutativeMagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record CommutativeMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module CommutativeMonoid where
    record CommutativeMonoid
      (A : Set) : Set where
      constructor CommutativeMonoidC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        e : A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CommutativeMonoidSig
      (AS : Set) : Set where
      constructor CommutativeMonoidSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record CommutativeMonoidProd
      (AP : Set) : Set where
      constructor CommutativeMonoidProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CommutativeMonoidHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMonoid A1)
      (Co2 : CommutativeMonoid A2) :
      Set where
      constructor CommutativeMonoidHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
        pres-e : hom (e Co1) == e Co2
    record CommutativeMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMonoid A1)
      (Co2 : CommutativeMonoid A2) :
      Set where
      constructor CommutativeMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
        interp-e :
          interp (e Co1) (e Co2)
    data CommutativeMonoidTerm
      : Set where
      opL :
        CommutativeMonoidTerm ->
        CommutativeMonoidTerm ->
        CommutativeMonoidTerm
      eL : CommutativeMonoidTerm
    data ClCommutativeMonoidTerm
      (A : Set) : Set where
      sing :
        A -> ClCommutativeMonoidTerm A
      opCl :
        ClCommutativeMonoidTerm A ->
        ClCommutativeMonoidTerm A ->
        ClCommutativeMonoidTerm A
      eCl : ClCommutativeMonoidTerm A
    data OpCommutativeMonoidTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpCommutativeMonoidTerm n
      opOL :
        OpCommutativeMonoidTerm n ->
        OpCommutativeMonoidTerm n ->
        OpCommutativeMonoidTerm n
      eOL : OpCommutativeMonoidTerm n
    data OpCommutativeMonoidTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpCommutativeMonoidTerm2 n A
      sing2 :
        A ->
        OpCommutativeMonoidTerm2 n A
      opOL2 :
        OpCommutativeMonoidTerm2 n A ->
        OpCommutativeMonoidTerm2 n A ->
        OpCommutativeMonoidTerm2 n A
      eOL2 :
        OpCommutativeMonoidTerm2 n A
    simplifyB :
      CommutativeMonoidTerm ->
      CommutativeMonoidTerm
    simplifyB (opL (eL) x) = x
    simplifyB (opL x (eL)) = x
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (eL) = eL
    simplifyCl :
      (A : Set) ->
      ClCommutativeMonoidTerm A ->
      ClCommutativeMonoidTerm A
    simplifyCl _ (opCl (eCl) x) = x
    simplifyCl _ (opCl x (eCl)) = x
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpCommutativeMonoidTerm n ->
      OpCommutativeMonoidTerm n
    simplifyOp _ (opOL (eOL) x) = x
    simplifyOp _ (opOL x (eOL)) = x
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpCommutativeMonoidTerm2 n A ->
      OpCommutativeMonoidTerm2 n A
    simplifyOpE _ _ (opOL2
                     (eOL2)
                     x) = x
    simplifyOpE _ _ (opOL2
                     x
                     (eOL2)) = x
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      CommutativeMonoid A ->
      CommutativeMonoidTerm -> A
    evalB _ Co (opL x1 x2) =
      op Co (evalB _ Co x1)
        (evalB _ Co x2)
    evalB _ Co (eL) = e Co
    evalCl :
      (A : Set) ->
      CommutativeMonoid A ->
      ClCommutativeMonoidTerm A -> A
    evalCl _ Co (sing x1) = x1
    evalCl _ Co (opCl x1 x2) =
      op Co (evalCl _ Co x1)
        (evalCl _ Co x2)
    evalCl _ Co (eCl) = e Co
    evalOp :
      (A : Set) (n : Nat) ->
      CommutativeMonoid A ->
      Vec A n ->
      OpCommutativeMonoidTerm n -> A
    evalOp _ n Co vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Co vars (opOL
                        x1
                        x2) =
      op Co (evalOp _ n Co vars x1)
        (evalOp _ n Co vars x2)
    evalOp _ n Co vars (eOL) = e Co
    evalOpE :
      (A : Set) (n : Nat) ->
      CommutativeMonoid A ->
      Vec A n ->
      OpCommutativeMonoidTerm2 n A ->
      A
    evalOpE _ n Co vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Co vars (sing2 x1) =
      x1
    evalOpE _ n Co vars (opOL2
                         x1
                         x2) =
      op Co (evalOpE _ n Co vars x1)
        (evalOpE _ n Co vars x2)
    evalOpE _ n Co vars (eOL2) =
      e Co
    inductionB :
      (P : CommutativeMonoidTerm ->
           Set) ->
      ((x1 : CommutativeMonoidTerm)
       (x2 : CommutativeMonoidTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      P eL ->
      (x : CommutativeMonoidTerm) ->
      P x
    inductionB p popl pel (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p popl pel x1)
        (inductionB p popl pel x2)
    inductionB p popl pel (eL) = pel
    inductionCl :
      (A : Set)
      (P : ClCommutativeMonoidTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClCommutativeMonoidTerm
          A)
       (x2 : ClCommutativeMonoidTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      P eCl ->
      (x : ClCommutativeMonoidTerm
         A) -> P x
    inductionCl _ p psing popcl pecl (sing
                                      x1) = psing x1
    inductionCl _ p psing popcl pecl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing popcl
           pecl
           x1)
        (inductionCl _ p psing popcl
           pecl
           x2)
    inductionCl _ p psing popcl pecl (eCl) =
      pecl
    inductionOp :
      (n : Nat)
      (P : OpCommutativeMonoidTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpCommutativeMonoidTerm
          n)
       (x2 : OpCommutativeMonoidTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      P eOL ->
      (x : OpCommutativeMonoidTerm
         n) -> P x
    inductionOp _ p pv popol peol (v
                                   x1) = pv x1
    inductionOp _ p pv popol peol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv popol peol
           x1)
        (inductionOp _ p pv popol peol
           x2)
    inductionOp _ p pv popol peol (eOL) =
      peol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpCommutativeMonoidTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpCommutativeMonoidTerm2
          n
          A)
       (x2 : OpCommutativeMonoidTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      P eOL2 ->
      (x : OpCommutativeMonoidTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (eOL2) =
      peol2
    opL' :
      CommutativeMonoidTerm ->
      CommutativeMonoidTerm ->
      CommutativeMonoidTerm
    opL' x1 x2 = opL x1 x2
    eL' : CommutativeMonoidTerm
    eL' = eL
    stageB :
      CommutativeMonoidTerm ->
      Staged CommutativeMonoidTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (eL) = Now eL
    opCl' :
      (A : Set) ->
      ClCommutativeMonoidTerm A ->
      ClCommutativeMonoidTerm A ->
      ClCommutativeMonoidTerm A
    opCl' _ x1 x2 = opCl x1 x2
    eCl' :
      (A : Set) ->
      ClCommutativeMonoidTerm A
    eCl' _ = eCl
    stageCl :
      (A : Set) ->
      ClCommutativeMonoidTerm A ->
      Staged
        (ClCommutativeMonoidTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (eCl) = Now eCl
    opOL' :
      (n : Nat) ->
      OpCommutativeMonoidTerm n ->
      OpCommutativeMonoidTerm n ->
      OpCommutativeMonoidTerm n
    opOL' _ x1 x2 = opOL x1 x2
    eOL' :
      (n : Nat) ->
      OpCommutativeMonoidTerm n
    eOL' _ = eOL
    stageOp :
      (n : Nat) ->
      OpCommutativeMonoidTerm n ->
      Staged
        (OpCommutativeMonoidTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (eOL) = Now eOL
    opOL2' :
      (n : Nat) (A : Set) ->
      OpCommutativeMonoidTerm2 n A ->
      OpCommutativeMonoidTerm2 n A ->
      OpCommutativeMonoidTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    eOL2' :
      (n : Nat) (A : Set) ->
      OpCommutativeMonoidTerm2 n A
    eOL2' _ _ = eOL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpCommutativeMonoidTerm2 n A ->
      Staged
        (OpCommutativeMonoidTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (eOL2) = Now eOL2
    record CommutativeMonoidTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
        eT : Repr A
  
  module CommutativeSemigroup where
    record CommutativeSemigroup
      (A : Set) : Set where
      constructor CommutativeSemigroupC
      field
        op : A -> A -> A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record CommutativeSemigroupSig
      (AS : Set) : Set where
      constructor CommutativeSemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record CommutativeSemigroupProd
      (AP : Set) : Set where
      constructor CommutativeSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record CommutativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeSemigroup A1)
      (Co2 : CommutativeSemigroup
         A2) : Set where
      constructor CommutativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
    record CommutativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeSemigroup A1)
      (Co2 : CommutativeSemigroup
         A2) : Set where
      constructor CommutativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
    data CommutativeSemigroupTerm
      : Set where
      opL :
        CommutativeSemigroupTerm ->
        CommutativeSemigroupTerm ->
        CommutativeSemigroupTerm
    data ClCommutativeSemigroupTerm
      (A : Set) : Set where
      sing :
        A ->
        ClCommutativeSemigroupTerm A
      opCl :
        ClCommutativeSemigroupTerm A ->
        ClCommutativeSemigroupTerm A ->
        ClCommutativeSemigroupTerm A
    data OpCommutativeSemigroupTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpCommutativeSemigroupTerm n
      opOL :
        OpCommutativeSemigroupTerm n ->
        OpCommutativeSemigroupTerm n ->
        OpCommutativeSemigroupTerm n
    data OpCommutativeSemigroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpCommutativeSemigroupTerm2 n A
      sing2 :
        A ->
        OpCommutativeSemigroupTerm2 n A
      opOL2 :
        OpCommutativeSemigroupTerm2 n
          A ->
        OpCommutativeSemigroupTerm2 n
          A ->
        OpCommutativeSemigroupTerm2 n A
    simplifyB :
      CommutativeSemigroupTerm ->
      CommutativeSemigroupTerm
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClCommutativeSemigroupTerm A ->
      ClCommutativeSemigroupTerm A
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpCommutativeSemigroupTerm n ->
      OpCommutativeSemigroupTerm n
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpCommutativeSemigroupTerm2 n
        A ->
      OpCommutativeSemigroupTerm2 n A
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      CommutativeSemigroup A ->
      CommutativeSemigroupTerm -> A
    evalB _ Co (opL x1 x2) =
      op Co (evalB _ Co x1)
        (evalB _ Co x2)
    evalCl :
      (A : Set) ->
      CommutativeSemigroup A ->
      ClCommutativeSemigroupTerm A ->
      A
    evalCl _ Co (sing x1) = x1
    evalCl _ Co (opCl x1 x2) =
      op Co (evalCl _ Co x1)
        (evalCl _ Co x2)
    evalOp :
      (A : Set) (n : Nat) ->
      CommutativeSemigroup A ->
      Vec A n ->
      OpCommutativeSemigroupTerm n ->
      A
    evalOp _ n Co vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Co vars (opOL
                        x1
                        x2) =
      op Co (evalOp _ n Co vars x1)
        (evalOp _ n Co vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      CommutativeSemigroup A ->
      Vec A n ->
      OpCommutativeSemigroupTerm2 n
        A -> A
    evalOpE _ n Co vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Co vars (sing2 x1) =
      x1
    evalOpE _ n Co vars (opOL2
                         x1
                         x2) =
      op Co (evalOpE _ n Co vars x1)
        (evalOpE _ n Co vars x2)
    inductionB :
      (P : CommutativeSemigroupTerm ->
           Set) ->
      ((x1 : CommutativeSemigroupTerm)
       (x2 : CommutativeSemigroupTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : CommutativeSemigroupTerm) ->
      P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClCommutativeSemigroupTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClCommutativeSemigroupTerm
          A)
       (x2 : ClCommutativeSemigroupTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClCommutativeSemigroupTerm
         A) -> P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpCommutativeSemigroupTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpCommutativeSemigroupTerm
          n)
       (x2 : OpCommutativeSemigroupTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpCommutativeSemigroupTerm
         n) -> P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpCommutativeSemigroupTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpCommutativeSemigroupTerm2
          n
          A)
       (x2 : OpCommutativeSemigroupTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpCommutativeSemigroupTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      CommutativeSemigroupTerm ->
      CommutativeSemigroupTerm ->
      CommutativeSemigroupTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      CommutativeSemigroupTerm ->
      Staged CommutativeSemigroupTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClCommutativeSemigroupTerm A ->
      ClCommutativeSemigroupTerm A ->
      ClCommutativeSemigroupTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClCommutativeSemigroupTerm A ->
      Staged
        (ClCommutativeSemigroupTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpCommutativeSemigroupTerm n ->
      OpCommutativeSemigroupTerm n ->
      OpCommutativeSemigroupTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpCommutativeSemigroupTerm n ->
      Staged
        (OpCommutativeSemigroupTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpCommutativeSemigroupTerm2 n
        A ->
      OpCommutativeSemigroupTerm2 n
        A ->
      OpCommutativeSemigroupTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpCommutativeSemigroupTerm2 n
        A ->
      Staged
        (OpCommutativeSemigroupTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record CommutativeSemigroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module Empty where
    record Empty : Set where
      constructor EmptyC
      field
        
  
  module LeftUnital where
    record LeftUnital
      (A : Set) : Set where
      constructor LeftUnitalC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
    record LeftUnitalSig
      (AS : Set) : Set where
      constructor LeftUnitalSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record LeftUnitalProd
      (AP : Set) : Set where
      constructor LeftUnitalProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
    record LeftUnitalHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftUnital A1)
      (Le2 : LeftUnital A2) :
      Set where
      constructor LeftUnitalHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Le1) == e Le2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record LeftUnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftUnital A1)
      (Le2 : LeftUnital A2) :
      Set where
      constructor LeftUnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Le1) (e Le2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data LeftUnitalTerm : Set where
      eL : LeftUnitalTerm
      opL :
        LeftUnitalTerm ->
        LeftUnitalTerm -> LeftUnitalTerm
    data ClLeftUnitalTerm
      (A : Set) : Set where
      sing : A -> ClLeftUnitalTerm A
      eCl : ClLeftUnitalTerm A
      opCl :
        ClLeftUnitalTerm A ->
        ClLeftUnitalTerm A ->
        ClLeftUnitalTerm A
    data OpLeftUnitalTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpLeftUnitalTerm n
      eOL : OpLeftUnitalTerm n
      opOL :
        OpLeftUnitalTerm n ->
        OpLeftUnitalTerm n ->
        OpLeftUnitalTerm n
    data OpLeftUnitalTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpLeftUnitalTerm2 n A
      sing2 :
        A -> OpLeftUnitalTerm2 n A
      eOL2 : OpLeftUnitalTerm2 n A
      opOL2 :
        OpLeftUnitalTerm2 n A ->
        OpLeftUnitalTerm2 n A ->
        OpLeftUnitalTerm2 n A
    simplifyB :
      LeftUnitalTerm -> LeftUnitalTerm
    simplifyB (opL (eL) x) = x
    simplifyB (eL) = eL
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLeftUnitalTerm A ->
      ClLeftUnitalTerm A
    simplifyCl _ (opCl (eCl) x) = x
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeftUnitalTerm n ->
      OpLeftUnitalTerm n
    simplifyOp _ (opOL (eOL) x) = x
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeftUnitalTerm2 n A ->
      OpLeftUnitalTerm2 n A
    simplifyOpE _ _ (opOL2
                     (eOL2)
                     x) = x
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LeftUnital A ->
      LeftUnitalTerm -> A
    evalB _ Le (eL) = e Le
    evalB _ Le (opL x1 x2) =
      op Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalCl :
      (A : Set) ->
      LeftUnital A ->
      ClLeftUnitalTerm A -> A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (eCl) = e Le
    evalCl _ Le (opCl x1 x2) =
      op Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalOp :
      (A : Set) (n : Nat) ->
      LeftUnital A ->
      Vec A n ->
      OpLeftUnitalTerm n -> A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (eOL) = e Le
    evalOp _ n Le vars (opOL
                        x1
                        x2) =
      op Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      LeftUnital A ->
      Vec A n ->
      OpLeftUnitalTerm2 n A -> A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (eOL2) =
      e Le
    evalOpE _ n Le vars (opOL2
                         x1
                         x2) =
      op Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    inductionB :
      (P : LeftUnitalTerm -> Set) ->
      P eL ->
      ((x1 : LeftUnitalTerm)
       (x2 : LeftUnitalTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : LeftUnitalTerm) -> P x
    inductionB p pel popl (eL) = pel
    inductionB p pel popl (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p pel popl x1)
        (inductionB p pel popl x2)
    inductionCl :
      (A : Set)
      (P : ClLeftUnitalTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P eCl ->
      ((x1 : ClLeftUnitalTerm A)
       (x2 : ClLeftUnitalTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClLeftUnitalTerm A) -> P x
    inductionCl _ p psing pecl popcl (sing
                                      x1) = psing x1
    inductionCl _ p psing pecl popcl (eCl) =
      pecl
    inductionCl _ p psing pecl popcl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing pecl
           popcl
           x1)
        (inductionCl _ p psing pecl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpLeftUnitalTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P eOL ->
      ((x1 : OpLeftUnitalTerm n)
       (x2 : OpLeftUnitalTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpLeftUnitalTerm n) -> P x
    inductionOp _ p pv peol popol (v
                                   x1) = pv x1
    inductionOp _ p pv peol popol (eOL) =
      peol
    inductionOp _ p pv peol popol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv peol popol
           x1)
        (inductionOp _ p pv peol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeftUnitalTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P eOL2 ->
      ((x1 : OpLeftUnitalTerm2 n A)
       (x2 : OpLeftUnitalTerm2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpLeftUnitalTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x2)
    eL' : LeftUnitalTerm
    eL' = eL
    opL' :
      LeftUnitalTerm ->
      LeftUnitalTerm -> LeftUnitalTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      LeftUnitalTerm ->
      Staged LeftUnitalTerm
    stageB (eL) = Now eL
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    eCl' :
      (A : Set) -> ClLeftUnitalTerm A
    eCl' _ = eCl
    opCl' :
      (A : Set) ->
      ClLeftUnitalTerm A ->
      ClLeftUnitalTerm A ->
      ClLeftUnitalTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClLeftUnitalTerm A ->
      Staged (ClLeftUnitalTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (eCl) = Now eCl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    eOL' :
      (n : Nat) -> OpLeftUnitalTerm n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      OpLeftUnitalTerm n ->
      OpLeftUnitalTerm n ->
      OpLeftUnitalTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpLeftUnitalTerm n ->
      Staged (OpLeftUnitalTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (eOL) = Now eOL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    eOL2' :
      (n : Nat) (A : Set) ->
      OpLeftUnitalTerm2 n A
    eOL2' _ _ = eOL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpLeftUnitalTerm2 n A ->
      OpLeftUnitalTerm2 n A ->
      OpLeftUnitalTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeftUnitalTerm2 n A ->
      Staged (OpLeftUnitalTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LeftUnitalTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        eT : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module Magma where
    record Magma
      (A : Set) : Set where
      constructor MagmaC
      field
        op : A -> A -> A
    record MagmaSig
      (AS : Set) : Set where
      constructor MagmaSigSigC
      field
        opS : AS -> AS -> AS
    record MagmaProd
      (AP : Set) : Set where
      constructor MagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record MagmaHom
      (A1 : Set) (A2 : Set)
      (Ma1 : Magma A1)
      (Ma2 : Magma A2) : Set where
      constructor MagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ma1 x1 x2) ==
            op Ma2 (hom x1) (hom x2)
    record MagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ma1 : Magma A1)
      (Ma2 : Magma A2) : Set where
      constructor MagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ma1 x1 x2)
            (op Ma2 y1 y2)
    data MagmaTerm : Set where
      opL :
        MagmaTerm ->
        MagmaTerm -> MagmaTerm
    data ClMagmaTerm
      (A : Set) : Set where
      sing : A -> ClMagmaTerm A
      opCl :
        ClMagmaTerm A ->
        ClMagmaTerm A -> ClMagmaTerm A
    data OpMagmaTerm
      (n : Nat) : Set where
      v : Fin n -> OpMagmaTerm n
      opOL :
        OpMagmaTerm n ->
        OpMagmaTerm n -> OpMagmaTerm n
    data OpMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 : Fin n -> OpMagmaTerm2 n A
      sing2 : A -> OpMagmaTerm2 n A
      opOL2 :
        OpMagmaTerm2 n A ->
        OpMagmaTerm2 n A ->
        OpMagmaTerm2 n A
    simplifyB :
      MagmaTerm -> MagmaTerm
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClMagmaTerm A -> ClMagmaTerm A
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpMagmaTerm n -> OpMagmaTerm n
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpMagmaTerm2 n A ->
      OpMagmaTerm2 n A
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Magma A -> MagmaTerm -> A
    evalB _ Ma (opL x1 x2) =
      op Ma (evalB _ Ma x1)
        (evalB _ Ma x2)
    evalCl :
      (A : Set) ->
      Magma A -> ClMagmaTerm A -> A
    evalCl _ Ma (sing x1) = x1
    evalCl _ Ma (opCl x1 x2) =
      op Ma (evalCl _ Ma x1)
        (evalCl _ Ma x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Magma A ->
      Vec A n -> OpMagmaTerm n -> A
    evalOp _ n Ma vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ma vars (opOL
                        x1
                        x2) =
      op Ma (evalOp _ n Ma vars x1)
        (evalOp _ n Ma vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Magma A ->
      Vec A n -> OpMagmaTerm2 n A -> A
    evalOpE _ n Ma vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ma vars (sing2 x1) =
      x1
    evalOpE _ n Ma vars (opOL2
                         x1
                         x2) =
      op Ma (evalOpE _ n Ma vars x1)
        (evalOpE _ n Ma vars x2)
    inductionB :
      (P : MagmaTerm -> Set) ->
      ((x1 : MagmaTerm)
       (x2 : MagmaTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : MagmaTerm) -> P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClMagmaTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClMagmaTerm A)
       (x2 : ClMagmaTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClMagmaTerm A) -> P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpMagmaTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpMagmaTerm n)
       (x2 : OpMagmaTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpMagmaTerm n) -> P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpMagmaTerm2 n A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpMagmaTerm2 n A)
       (x2 : OpMagmaTerm2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpMagmaTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      MagmaTerm ->
      MagmaTerm -> MagmaTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      MagmaTerm -> Staged MagmaTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClMagmaTerm A ->
      ClMagmaTerm A -> ClMagmaTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClMagmaTerm A ->
      Staged (ClMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpMagmaTerm n ->
      OpMagmaTerm n -> OpMagmaTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpMagmaTerm n ->
      Staged (OpMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpMagmaTerm2 n A ->
      OpMagmaTerm2 n A ->
      OpMagmaTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpMagmaTerm2 n A ->
      Staged (OpMagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record MagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module Monoid where
    record Monoid
      (A : Set) : Set where
      constructor MonoidC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record MonoidSig
      (AS : Set) : Set where
      constructor MonoidSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record MonoidProd
      (AP : Set) : Set where
      constructor MonoidProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record MonoidHom
      (A1 : Set) (A2 : Set)
      (Mo1 : Monoid A1)
      (Mo2 : Monoid A2) : Set where
      constructor MonoidHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Mo1) == e Mo2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mo1 x1 x2) ==
            op Mo2 (hom x1) (hom x2)
    record MonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : Monoid A1)
      (Mo2 : Monoid A2) : Set where
      constructor MonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Mo1) (e Mo2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mo1 x1 x2)
            (op Mo2 y1 y2)
    data MonoidTerm : Set where
      eL : MonoidTerm
      opL :
        MonoidTerm ->
        MonoidTerm -> MonoidTerm
    data ClMonoidTerm
      (A : Set) : Set where
      sing : A -> ClMonoidTerm A
      eCl : ClMonoidTerm A
      opCl :
        ClMonoidTerm A ->
        ClMonoidTerm A -> ClMonoidTerm A
    data OpMonoidTerm
      (n : Nat) : Set where
      v : Fin n -> OpMonoidTerm n
      eOL : OpMonoidTerm n
      opOL :
        OpMonoidTerm n ->
        OpMonoidTerm n -> OpMonoidTerm n
    data OpMonoidTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpMonoidTerm2 n A
      sing2 : A -> OpMonoidTerm2 n A
      eOL2 : OpMonoidTerm2 n A
      opOL2 :
        OpMonoidTerm2 n A ->
        OpMonoidTerm2 n A ->
        OpMonoidTerm2 n A
    simplifyB :
      MonoidTerm -> MonoidTerm
    simplifyB (opL (eL) x) = x
    simplifyB (opL x (eL)) = x
    simplifyB (eL) = eL
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClMonoidTerm A -> ClMonoidTerm A
    simplifyCl _ (opCl (eCl) x) = x
    simplifyCl _ (opCl x (eCl)) = x
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpMonoidTerm n -> OpMonoidTerm n
    simplifyOp _ (opOL (eOL) x) = x
    simplifyOp _ (opOL x (eOL)) = x
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpMonoidTerm2 n A ->
      OpMonoidTerm2 n A
    simplifyOpE _ _ (opOL2
                     (eOL2)
                     x) = x
    simplifyOpE _ _ (opOL2
                     x
                     (eOL2)) = x
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Monoid A -> MonoidTerm -> A
    evalB _ Mo (eL) = e Mo
    evalB _ Mo (opL x1 x2) =
      op Mo (evalB _ Mo x1)
        (evalB _ Mo x2)
    evalCl :
      (A : Set) ->
      Monoid A -> ClMonoidTerm A -> A
    evalCl _ Mo (sing x1) = x1
    evalCl _ Mo (eCl) = e Mo
    evalCl _ Mo (opCl x1 x2) =
      op Mo (evalCl _ Mo x1)
        (evalCl _ Mo x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Monoid A ->
      Vec A n -> OpMonoidTerm n -> A
    evalOp _ n Mo vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Mo vars (eOL) = e Mo
    evalOp _ n Mo vars (opOL
                        x1
                        x2) =
      op Mo (evalOp _ n Mo vars x1)
        (evalOp _ n Mo vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Monoid A ->
      Vec A n ->
      OpMonoidTerm2 n A -> A
    evalOpE _ n Mo vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Mo vars (sing2 x1) =
      x1
    evalOpE _ n Mo vars (eOL2) =
      e Mo
    evalOpE _ n Mo vars (opOL2
                         x1
                         x2) =
      op Mo (evalOpE _ n Mo vars x1)
        (evalOpE _ n Mo vars x2)
    inductionB :
      (P : MonoidTerm -> Set) ->
      P eL ->
      ((x1 : MonoidTerm)
       (x2 : MonoidTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : MonoidTerm) -> P x
    inductionB p pel popl (eL) = pel
    inductionB p pel popl (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p pel popl x1)
        (inductionB p pel popl x2)
    inductionCl :
      (A : Set)
      (P : ClMonoidTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P eCl ->
      ((x1 : ClMonoidTerm A)
       (x2 : ClMonoidTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClMonoidTerm A) -> P x
    inductionCl _ p psing pecl popcl (sing
                                      x1) = psing x1
    inductionCl _ p psing pecl popcl (eCl) =
      pecl
    inductionCl _ p psing pecl popcl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing pecl
           popcl
           x1)
        (inductionCl _ p psing pecl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpMonoidTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P eOL ->
      ((x1 : OpMonoidTerm n)
       (x2 : OpMonoidTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpMonoidTerm n) -> P x
    inductionOp _ p pv peol popol (v
                                   x1) = pv x1
    inductionOp _ p pv peol popol (eOL) =
      peol
    inductionOp _ p pv peol popol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv peol popol
           x1)
        (inductionOp _ p pv peol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpMonoidTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P eOL2 ->
      ((x1 : OpMonoidTerm2 n A)
       (x2 : OpMonoidTerm2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpMonoidTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x2)
    eL' : MonoidTerm
    eL' = eL
    opL' :
      MonoidTerm ->
      MonoidTerm -> MonoidTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      MonoidTerm -> Staged MonoidTerm
    stageB (eL) = Now eL
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    eCl' :
      (A : Set) -> ClMonoidTerm A
    eCl' _ = eCl
    opCl' :
      (A : Set) ->
      ClMonoidTerm A ->
      ClMonoidTerm A -> ClMonoidTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClMonoidTerm A ->
      Staged (ClMonoidTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (eCl) = Now eCl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    eOL' :
      (n : Nat) -> OpMonoidTerm n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      OpMonoidTerm n ->
      OpMonoidTerm n -> OpMonoidTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpMonoidTerm n ->
      Staged (OpMonoidTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (eOL) = Now eOL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    eOL2' :
      (n : Nat) (A : Set) ->
      OpMonoidTerm2 n A
    eOL2' _ _ = eOL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpMonoidTerm2 n A ->
      OpMonoidTerm2 n A ->
      OpMonoidTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpMonoidTerm2 n A ->
      Staged (OpMonoidTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record MonoidTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        eT : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module Pointed where
    record Pointed
      (A : Set) : Set where
      constructor PointedC
      field
        e : A
    record PointedSig
      (AS : Set) : Set where
      constructor PointedSigSigC
      field
        eS : AS
    record PointedProd
      (AP : Set) : Set where
      constructor PointedProdC
      field
        eP : Prod AP AP
    record PointedHom
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed A1)
      (Po2 : Pointed A2) : Set where
      constructor PointedHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Po1) == e Po2
    record PointedRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed A1)
      (Po2 : Pointed A2) : Set where
      constructor PointedRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Po1) (e Po2)
    data PointedTerm : Set where
      eL : PointedTerm
    data ClPointedTerm
      (A : Set) : Set where
      sing : A -> ClPointedTerm A
      eCl : ClPointedTerm A
    data OpPointedTerm
      (n : Nat) : Set where
      v : Fin n -> OpPointedTerm n
      eOL : OpPointedTerm n
    data OpPointedTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpPointedTerm2 n A
      sing2 : A -> OpPointedTerm2 n A
      eOL2 : OpPointedTerm2 n A
    simplifyB :
      PointedTerm -> PointedTerm
    simplifyB (eL) = eL
    simplifyCl :
      (A : Set) ->
      ClPointedTerm A ->
      ClPointedTerm A
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpPointedTerm n ->
      OpPointedTerm n
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpPointedTerm2 n A ->
      OpPointedTerm2 n A
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Pointed A -> PointedTerm -> A
    evalB _ Po (eL) = e Po
    evalCl :
      (A : Set) ->
      Pointed A ->
      ClPointedTerm A -> A
    evalCl _ Po (sing x1) = x1
    evalCl _ Po (eCl) = e Po
    evalOp :
      (A : Set) (n : Nat) ->
      Pointed A ->
      Vec A n -> OpPointedTerm n -> A
    evalOp _ n Po vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Po vars (eOL) = e Po
    evalOpE :
      (A : Set) (n : Nat) ->
      Pointed A ->
      Vec A n ->
      OpPointedTerm2 n A -> A
    evalOpE _ n Po vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Po vars (sing2 x1) =
      x1
    evalOpE _ n Po vars (eOL2) =
      e Po
    inductionB :
      (P : PointedTerm -> Set) ->
      P eL -> (x : PointedTerm) -> P x
    inductionB p pel (eL) = pel
    inductionCl :
      (A : Set)
      (P : ClPointedTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P eCl ->
      (x : ClPointedTerm A) -> P x
    inductionCl _ p psing pecl (sing
                                x1) = psing x1
    inductionCl _ p psing pecl (eCl) =
      pecl
    inductionOp :
      (n : Nat)
      (P : OpPointedTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P eOL ->
      (x : OpPointedTerm n) -> P x
    inductionOp _ p pv peol (v x1) =
      pv x1
    inductionOp _ p pv peol (eOL) =
      peol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpPointedTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P eOL2 ->
      (x : OpPointedTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 peol2 (v2
                                         x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 peol2 (sing2
                                         x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 peol2 (eOL2) =
      peol2
    eL' : PointedTerm
    eL' = eL
    stageB :
      PointedTerm ->
      Staged PointedTerm
    stageB (eL) = Now eL
    eCl' :
      (A : Set) -> ClPointedTerm A
    eCl' _ = eCl
    stageCl :
      (A : Set) ->
      ClPointedTerm A ->
      Staged (ClPointedTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (eCl) = Now eCl
    eOL' :
      (n : Nat) -> OpPointedTerm n
    eOL' _ = eOL
    stageOp :
      (n : Nat) ->
      OpPointedTerm n ->
      Staged (OpPointedTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (eOL) = Now eOL
    eOL2' :
      (n : Nat) (A : Set) ->
      OpPointedTerm2 n A
    eOL2' _ _ = eOL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpPointedTerm2 n A ->
      Staged (OpPointedTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (eOL2) = Now eOL2
    record PointedTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        eT : Repr A
  
  module Pointed0Magma where
    record Pointed0Magma
      (A : Set) : Set where
      constructor Pointed0MagmaC
      field
        0 : A
        op : A -> A -> A
    record Pointed0MagmaSig
      (AS : Set) : Set where
      constructor Pointed0MagmaSigSigC
      field
        0S : AS
        opS : AS -> AS -> AS
    record Pointed0MagmaProd
      (AP : Set) : Set where
      constructor Pointed0MagmaProdC
      field
        0P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record Pointed0MagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed0Magma A1)
      (Po2 : Pointed0Magma A2) :
      Set where
      constructor Pointed0MagmaHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Po1) == 0 Po2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Po1 x1 x2) ==
            op Po2 (hom x1) (hom x2)
    record Pointed0MagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed0Magma A1)
      (Po2 : Pointed0Magma A2) :
      Set where
      constructor Pointed0MagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Po1) (0 Po2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Po1 x1 x2)
            (op Po2 y1 y2)
    data Pointed0MagmaTerm
      : Set where
      0L : Pointed0MagmaTerm
      opL :
        Pointed0MagmaTerm ->
        Pointed0MagmaTerm ->
        Pointed0MagmaTerm
    data ClPointed0MagmaTerm
      (A : Set) : Set where
      sing :
        A -> ClPointed0MagmaTerm A
      0Cl : ClPointed0MagmaTerm A
      opCl :
        ClPointed0MagmaTerm A ->
        ClPointed0MagmaTerm A ->
        ClPointed0MagmaTerm A
    data OpPointed0MagmaTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpPointed0MagmaTerm n
      0OL : OpPointed0MagmaTerm n
      opOL :
        OpPointed0MagmaTerm n ->
        OpPointed0MagmaTerm n ->
        OpPointed0MagmaTerm n
    data OpPointed0MagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpPointed0MagmaTerm2 n A
      sing2 :
        A -> OpPointed0MagmaTerm2 n A
      0OL2 : OpPointed0MagmaTerm2 n A
      opOL2 :
        OpPointed0MagmaTerm2 n A ->
        OpPointed0MagmaTerm2 n A ->
        OpPointed0MagmaTerm2 n A
    simplifyB :
      Pointed0MagmaTerm ->
      Pointed0MagmaTerm
    simplifyB (0L) = 0L
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClPointed0MagmaTerm A ->
      ClPointed0MagmaTerm A
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpPointed0MagmaTerm n ->
      OpPointed0MagmaTerm n
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpPointed0MagmaTerm2 n A ->
      OpPointed0MagmaTerm2 n A
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Pointed0Magma A ->
      Pointed0MagmaTerm -> A
    evalB _ Po (0L) = 0 Po
    evalB _ Po (opL x1 x2) =
      op Po (evalB _ Po x1)
        (evalB _ Po x2)
    evalCl :
      (A : Set) ->
      Pointed0Magma A ->
      ClPointed0MagmaTerm A -> A
    evalCl _ Po (sing x1) = x1
    evalCl _ Po (0Cl) = 0 Po
    evalCl _ Po (opCl x1 x2) =
      op Po (evalCl _ Po x1)
        (evalCl _ Po x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Pointed0Magma A ->
      Vec A n ->
      OpPointed0MagmaTerm n -> A
    evalOp _ n Po vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Po vars (0OL) = 0 Po
    evalOp _ n Po vars (opOL
                        x1
                        x2) =
      op Po (evalOp _ n Po vars x1)
        (evalOp _ n Po vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Pointed0Magma A ->
      Vec A n ->
      OpPointed0MagmaTerm2 n A -> A
    evalOpE _ n Po vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Po vars (sing2 x1) =
      x1
    evalOpE _ n Po vars (0OL2) =
      0 Po
    evalOpE _ n Po vars (opOL2
                         x1
                         x2) =
      op Po (evalOpE _ n Po vars x1)
        (evalOpE _ n Po vars x2)
    inductionB :
      (P : Pointed0MagmaTerm ->
           Set) ->
      P 0L ->
      ((x1 : Pointed0MagmaTerm)
       (x2 : Pointed0MagmaTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : Pointed0MagmaTerm) -> P x
    inductionB p p0l popl (0L) = p0l
    inductionB p p0l popl (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p p0l popl x1)
        (inductionB p p0l popl x2)
    inductionCl :
      (A : Set)
      (P : ClPointed0MagmaTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 0Cl ->
      ((x1 : ClPointed0MagmaTerm A)
       (x2 : ClPointed0MagmaTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClPointed0MagmaTerm A) ->
      P x
    inductionCl _ p psing p0cl popcl (sing
                                      x1) = psing x1
    inductionCl _ p psing p0cl popcl (0Cl) =
      p0cl
    inductionCl _ p psing p0cl popcl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing p0cl
           popcl
           x1)
        (inductionCl _ p psing p0cl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpPointed0MagmaTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 0OL ->
      ((x1 : OpPointed0MagmaTerm n)
       (x2 : OpPointed0MagmaTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpPointed0MagmaTerm n) ->
      P x
    inductionOp _ p pv p0ol popol (v
                                   x1) = pv x1
    inductionOp _ p pv p0ol popol (0OL) =
      p0ol
    inductionOp _ p pv p0ol popol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv p0ol popol
           x1)
        (inductionOp _ p pv p0ol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpPointed0MagmaTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 0OL2 ->
      ((x1 : OpPointed0MagmaTerm2 n A)
       (x2 : OpPointed0MagmaTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpPointed0MagmaTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p0ol2 popol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 popol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 popol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p0ol2 popol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           popol2
           x2)
    0L' : Pointed0MagmaTerm
    0L' = 0L
    opL' :
      Pointed0MagmaTerm ->
      Pointed0MagmaTerm ->
      Pointed0MagmaTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      Pointed0MagmaTerm ->
      Staged Pointed0MagmaTerm
    stageB (0L) = Now 0L
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    0Cl' :
      (A : Set) ->
      ClPointed0MagmaTerm A
    0Cl' _ = 0Cl
    opCl' :
      (A : Set) ->
      ClPointed0MagmaTerm A ->
      ClPointed0MagmaTerm A ->
      ClPointed0MagmaTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClPointed0MagmaTerm A ->
      Staged (ClPointed0MagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    0OL' :
      (n : Nat) ->
      OpPointed0MagmaTerm n
    0OL' _ = 0OL
    opOL' :
      (n : Nat) ->
      OpPointed0MagmaTerm n ->
      OpPointed0MagmaTerm n ->
      OpPointed0MagmaTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpPointed0MagmaTerm n ->
      Staged (OpPointed0MagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (0OL) = Now 0OL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    0OL2' :
      (n : Nat) (A : Set) ->
      OpPointed0MagmaTerm2 n A
    0OL2' _ _ = 0OL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpPointed0MagmaTerm2 n A ->
      OpPointed0MagmaTerm2 n A ->
      OpPointed0MagmaTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpPointed0MagmaTerm2 n A ->
      Staged
        (OpPointed0MagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record Pointed0MagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        0T : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module PointedMagma where
    record PointedMagma
      (A : Set) : Set where
      constructor PointedMagmaC
      field
        e : A
        op : A -> A -> A
    record PointedMagmaSig
      (AS : Set) : Set where
      constructor PointedMagmaSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record PointedMagmaProd
      (AP : Set) : Set where
      constructor PointedMagmaProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record PointedMagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedMagma A1)
      (Po2 : PointedMagma A2) :
      Set where
      constructor PointedMagmaHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Po1) == e Po2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Po1 x1 x2) ==
            op Po2 (hom x1) (hom x2)
    record PointedMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedMagma A1)
      (Po2 : PointedMagma A2) :
      Set where
      constructor PointedMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Po1) (e Po2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Po1 x1 x2)
            (op Po2 y1 y2)
    data PointedMagmaTerm
      : Set where
      eL : PointedMagmaTerm
      opL :
        PointedMagmaTerm ->
        PointedMagmaTerm ->
        PointedMagmaTerm
    data ClPointedMagmaTerm
      (A : Set) : Set where
      sing :
        A -> ClPointedMagmaTerm A
      eCl : ClPointedMagmaTerm A
      opCl :
        ClPointedMagmaTerm A ->
        ClPointedMagmaTerm A ->
        ClPointedMagmaTerm A
    data OpPointedMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpPointedMagmaTerm n
      eOL : OpPointedMagmaTerm n
      opOL :
        OpPointedMagmaTerm n ->
        OpPointedMagmaTerm n ->
        OpPointedMagmaTerm n
    data OpPointedMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpPointedMagmaTerm2 n A
      sing2 :
        A -> OpPointedMagmaTerm2 n A
      eOL2 : OpPointedMagmaTerm2 n A
      opOL2 :
        OpPointedMagmaTerm2 n A ->
        OpPointedMagmaTerm2 n A ->
        OpPointedMagmaTerm2 n A
    simplifyB :
      PointedMagmaTerm ->
      PointedMagmaTerm
    simplifyB (eL) = eL
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClPointedMagmaTerm A ->
      ClPointedMagmaTerm A
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpPointedMagmaTerm n ->
      OpPointedMagmaTerm n
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpPointedMagmaTerm2 n A ->
      OpPointedMagmaTerm2 n A
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      PointedMagma A ->
      PointedMagmaTerm -> A
    evalB _ Po (eL) = e Po
    evalB _ Po (opL x1 x2) =
      op Po (evalB _ Po x1)
        (evalB _ Po x2)
    evalCl :
      (A : Set) ->
      PointedMagma A ->
      ClPointedMagmaTerm A -> A
    evalCl _ Po (sing x1) = x1
    evalCl _ Po (eCl) = e Po
    evalCl _ Po (opCl x1 x2) =
      op Po (evalCl _ Po x1)
        (evalCl _ Po x2)
    evalOp :
      (A : Set) (n : Nat) ->
      PointedMagma A ->
      Vec A n ->
      OpPointedMagmaTerm n -> A
    evalOp _ n Po vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Po vars (eOL) = e Po
    evalOp _ n Po vars (opOL
                        x1
                        x2) =
      op Po (evalOp _ n Po vars x1)
        (evalOp _ n Po vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      PointedMagma A ->
      Vec A n ->
      OpPointedMagmaTerm2 n A -> A
    evalOpE _ n Po vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Po vars (sing2 x1) =
      x1
    evalOpE _ n Po vars (eOL2) =
      e Po
    evalOpE _ n Po vars (opOL2
                         x1
                         x2) =
      op Po (evalOpE _ n Po vars x1)
        (evalOpE _ n Po vars x2)
    inductionB :
      (P : PointedMagmaTerm -> Set) ->
      P eL ->
      ((x1 : PointedMagmaTerm)
       (x2 : PointedMagmaTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : PointedMagmaTerm) -> P x
    inductionB p pel popl (eL) = pel
    inductionB p pel popl (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p pel popl x1)
        (inductionB p pel popl x2)
    inductionCl :
      (A : Set)
      (P : ClPointedMagmaTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P eCl ->
      ((x1 : ClPointedMagmaTerm A)
       (x2 : ClPointedMagmaTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClPointedMagmaTerm A) ->
      P x
    inductionCl _ p psing pecl popcl (sing
                                      x1) = psing x1
    inductionCl _ p psing pecl popcl (eCl) =
      pecl
    inductionCl _ p psing pecl popcl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing pecl
           popcl
           x1)
        (inductionCl _ p psing pecl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpPointedMagmaTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P eOL ->
      ((x1 : OpPointedMagmaTerm n)
       (x2 : OpPointedMagmaTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpPointedMagmaTerm n) ->
      P x
    inductionOp _ p pv peol popol (v
                                   x1) = pv x1
    inductionOp _ p pv peol popol (eOL) =
      peol
    inductionOp _ p pv peol popol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv peol popol
           x1)
        (inductionOp _ p pv peol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpPointedMagmaTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P eOL2 ->
      ((x1 : OpPointedMagmaTerm2 n A)
       (x2 : OpPointedMagmaTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpPointedMagmaTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x2)
    eL' : PointedMagmaTerm
    eL' = eL
    opL' :
      PointedMagmaTerm ->
      PointedMagmaTerm ->
      PointedMagmaTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      PointedMagmaTerm ->
      Staged PointedMagmaTerm
    stageB (eL) = Now eL
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    eCl' :
      (A : Set) ->
      ClPointedMagmaTerm A
    eCl' _ = eCl
    opCl' :
      (A : Set) ->
      ClPointedMagmaTerm A ->
      ClPointedMagmaTerm A ->
      ClPointedMagmaTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClPointedMagmaTerm A ->
      Staged (ClPointedMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (eCl) = Now eCl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    eOL' :
      (n : Nat) ->
      OpPointedMagmaTerm n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      OpPointedMagmaTerm n ->
      OpPointedMagmaTerm n ->
      OpPointedMagmaTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpPointedMagmaTerm n ->
      Staged (OpPointedMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (eOL) = Now eOL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    eOL2' :
      (n : Nat) (A : Set) ->
      OpPointedMagmaTerm2 n A
    eOL2' _ _ = eOL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpPointedMagmaTerm2 n A ->
      OpPointedMagmaTerm2 n A ->
      OpPointedMagmaTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpPointedMagmaTerm2 n A ->
      Staged (OpPointedMagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record PointedMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        eT : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module PointedOne where
    record PointedOne
      (A : Set) : Set where
      constructor PointedOneC
      field
        1 : A
    record PointedOneSig
      (AS : Set) : Set where
      constructor PointedOneSigSigC
      field
        1S : AS
    record PointedOneProd
      (AP : Set) : Set where
      constructor PointedOneProdC
      field
        1P : Prod AP AP
    record PointedOneHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedOne A1)
      (Po2 : PointedOne A2) :
      Set where
      constructor PointedOneHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Po1) == 1 Po2
    record PointedOneRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedOne A1)
      (Po2 : PointedOne A2) :
      Set where
      constructor PointedOneRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Po1) (1 Po2)
    data PointedOneTerm : Set where
      1L : PointedOneTerm
    data ClPointedOneTerm
      (A : Set) : Set where
      sing : A -> ClPointedOneTerm A
      1Cl : ClPointedOneTerm A
    data OpPointedOneTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpPointedOneTerm n
      1OL : OpPointedOneTerm n
    data OpPointedOneTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpPointedOneTerm2 n A
      sing2 :
        A -> OpPointedOneTerm2 n A
      1OL2 : OpPointedOneTerm2 n A
    simplifyB :
      PointedOneTerm -> PointedOneTerm
    simplifyB (1L) = 1L
    simplifyCl :
      (A : Set) ->
      ClPointedOneTerm A ->
      ClPointedOneTerm A
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpPointedOneTerm n ->
      OpPointedOneTerm n
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpPointedOneTerm2 n A ->
      OpPointedOneTerm2 n A
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      PointedOne A ->
      PointedOneTerm -> A
    evalB _ Po (1L) = 1 Po
    evalCl :
      (A : Set) ->
      PointedOne A ->
      ClPointedOneTerm A -> A
    evalCl _ Po (sing x1) = x1
    evalCl _ Po (1Cl) = 1 Po
    evalOp :
      (A : Set) (n : Nat) ->
      PointedOne A ->
      Vec A n ->
      OpPointedOneTerm n -> A
    evalOp _ n Po vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Po vars (1OL) = 1 Po
    evalOpE :
      (A : Set) (n : Nat) ->
      PointedOne A ->
      Vec A n ->
      OpPointedOneTerm2 n A -> A
    evalOpE _ n Po vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Po vars (sing2 x1) =
      x1
    evalOpE _ n Po vars (1OL2) =
      1 Po
    inductionB :
      (P : PointedOneTerm -> Set) ->
      P 1L ->
      (x : PointedOneTerm) -> P x
    inductionB p p1l (1L) = p1l
    inductionCl :
      (A : Set)
      (P : ClPointedOneTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 1Cl ->
      (x : ClPointedOneTerm A) -> P x
    inductionCl _ p psing p1cl (sing
                                x1) = psing x1
    inductionCl _ p psing p1cl (1Cl) =
      p1cl
    inductionOp :
      (n : Nat)
      (P : OpPointedOneTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 1OL ->
      (x : OpPointedOneTerm n) -> P x
    inductionOp _ p pv p1ol (v x1) =
      pv x1
    inductionOp _ p pv p1ol (1OL) =
      p1ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpPointedOneTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 1OL2 ->
      (x : OpPointedOneTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p1ol2 (v2
                                         x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p1ol2 (sing2
                                         x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p1ol2 (1OL2) =
      p1ol2
    1L' : PointedOneTerm
    1L' = 1L
    stageB :
      PointedOneTerm ->
      Staged PointedOneTerm
    stageB (1L) = Now 1L
    1Cl' :
      (A : Set) -> ClPointedOneTerm A
    1Cl' _ = 1Cl
    stageCl :
      (A : Set) ->
      ClPointedOneTerm A ->
      Staged (ClPointedOneTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (1Cl) = Now 1Cl
    1OL' :
      (n : Nat) -> OpPointedOneTerm n
    1OL' _ = 1OL
    stageOp :
      (n : Nat) ->
      OpPointedOneTerm n ->
      Staged (OpPointedOneTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (1OL) = Now 1OL
    1OL2' :
      (n : Nat) (A : Set) ->
      OpPointedOneTerm2 n A
    1OL2' _ _ = 1OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpPointedOneTerm2 n A ->
      Staged (OpPointedOneTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (1OL2) = Now 1OL2
    record PointedOneTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        1T : Repr A
  
  module PointedPlusMagma where
    record PointedPlusMagma
      (A : Set) : Set where
      constructor PointedPlusMagmaC
      field
        + : A -> A -> A
        e : A
    record PointedPlusMagmaSig
      (AS : Set) : Set where
      constructor PointedPlusMagmaSigSigC
      field
        +S : AS -> AS -> AS
        eS : AS
    record PointedPlusMagmaProd
      (AP : Set) : Set where
      constructor PointedPlusMagmaProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
    record PointedPlusMagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedPlusMagma A1)
      (Po2 : PointedPlusMagma A2) :
      Set where
      constructor PointedPlusMagmaHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Po1 x1 x2) ==
            + Po2 (hom x1) (hom x2)
        pres-e : hom (e Po1) == e Po2
    record PointedPlusMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedPlusMagma A1)
      (Po2 : PointedPlusMagma A2) :
      Set where
      constructor PointedPlusMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Po1 x1 x2)
            (+ Po2 y1 y2)
        interp-e :
          interp (e Po1) (e Po2)
    data PointedPlusMagmaTerm
      : Set where
      +L :
        PointedPlusMagmaTerm ->
        PointedPlusMagmaTerm ->
        PointedPlusMagmaTerm
      eL : PointedPlusMagmaTerm
    data ClPointedPlusMagmaTerm
      (A : Set) : Set where
      sing :
        A -> ClPointedPlusMagmaTerm A
      +Cl :
        ClPointedPlusMagmaTerm A ->
        ClPointedPlusMagmaTerm A ->
        ClPointedPlusMagmaTerm A
      eCl : ClPointedPlusMagmaTerm A
    data OpPointedPlusMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpPointedPlusMagmaTerm n
      +OL :
        OpPointedPlusMagmaTerm n ->
        OpPointedPlusMagmaTerm n ->
        OpPointedPlusMagmaTerm n
      eOL : OpPointedPlusMagmaTerm n
    data OpPointedPlusMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpPointedPlusMagmaTerm2 n A
      sing2 :
        A -> OpPointedPlusMagmaTerm2 n A
      +OL2 :
        OpPointedPlusMagmaTerm2 n A ->
        OpPointedPlusMagmaTerm2 n A ->
        OpPointedPlusMagmaTerm2 n A
      eOL2 :
        OpPointedPlusMagmaTerm2 n A
    simplifyB :
      PointedPlusMagmaTerm ->
      PointedPlusMagmaTerm
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (eL) = eL
    simplifyCl :
      (A : Set) ->
      ClPointedPlusMagmaTerm A ->
      ClPointedPlusMagmaTerm A
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpPointedPlusMagmaTerm n ->
      OpPointedPlusMagmaTerm n
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpPointedPlusMagmaTerm2 n A ->
      OpPointedPlusMagmaTerm2 n A
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      PointedPlusMagma A ->
      PointedPlusMagmaTerm -> A
    evalB _ Po (+L x1 x2) =
      + Po (evalB _ Po x1)
        (evalB _ Po x2)
    evalB _ Po (eL) = e Po
    evalCl :
      (A : Set) ->
      PointedPlusMagma A ->
      ClPointedPlusMagmaTerm A -> A
    evalCl _ Po (sing x1) = x1
    evalCl _ Po (+Cl x1 x2) =
      + Po (evalCl _ Po x1)
        (evalCl _ Po x2)
    evalCl _ Po (eCl) = e Po
    evalOp :
      (A : Set) (n : Nat) ->
      PointedPlusMagma A ->
      Vec A n ->
      OpPointedPlusMagmaTerm n -> A
    evalOp _ n Po vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Po vars (+OL x1 x2) =
      + Po (evalOp _ n Po vars x1)
        (evalOp _ n Po vars x2)
    evalOp _ n Po vars (eOL) = e Po
    evalOpE :
      (A : Set) (n : Nat) ->
      PointedPlusMagma A ->
      Vec A n ->
      OpPointedPlusMagmaTerm2 n A -> A
    evalOpE _ n Po vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Po vars (sing2 x1) =
      x1
    evalOpE _ n Po vars (+OL2
                         x1
                         x2) =
      + Po (evalOpE _ n Po vars x1)
        (evalOpE _ n Po vars x2)
    evalOpE _ n Po vars (eOL2) =
      e Po
    inductionB :
      (P : PointedPlusMagmaTerm ->
           Set) ->
      ((x1 : PointedPlusMagmaTerm)
       (x2 : PointedPlusMagmaTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      P eL ->
      (x : PointedPlusMagmaTerm) ->
      P x
    inductionB p p+l pel (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p+l pel x1)
        (inductionB p p+l pel x2)
    inductionB p p+l pel (eL) = pel
    inductionCl :
      (A : Set)
      (P : ClPointedPlusMagmaTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClPointedPlusMagmaTerm A)
       (x2 : ClPointedPlusMagmaTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      P eCl ->
      (x : ClPointedPlusMagmaTerm
         A) -> P x
    inductionCl _ p psing p+cl pecl (sing
                                     x1) = psing x1
    inductionCl _ p psing p+cl pecl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p+cl pecl
           x1)
        (inductionCl _ p psing p+cl pecl
           x2)
    inductionCl _ p psing p+cl pecl (eCl) =
      pecl
    inductionOp :
      (n : Nat)
      (P : OpPointedPlusMagmaTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpPointedPlusMagmaTerm n)
       (x2 : OpPointedPlusMagmaTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      P eOL ->
      (x : OpPointedPlusMagmaTerm
         n) -> P x
    inductionOp _ p pv p+ol peol (v
                                  x1) = pv x1
    inductionOp _ p pv p+ol peol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p+ol peol
           x1)
        (inductionOp _ p pv p+ol peol
           x2)
    inductionOp _ p pv p+ol peol (eOL) =
      peol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpPointedPlusMagmaTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpPointedPlusMagmaTerm2 n
          A)
       (x2 : OpPointedPlusMagmaTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      P eOL2 ->
      (x : OpPointedPlusMagmaTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p+ol2 peol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 peol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 peol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           peol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           peol2
           x2)
    inductionOpE _ _ p pv2 psing2 p+ol2 peol2 (eOL2) =
      peol2
    +L' :
      PointedPlusMagmaTerm ->
      PointedPlusMagmaTerm ->
      PointedPlusMagmaTerm
    +L' x1 x2 = +L x1 x2
    eL' : PointedPlusMagmaTerm
    eL' = eL
    stageB :
      PointedPlusMagmaTerm ->
      Staged PointedPlusMagmaTerm
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (eL) = Now eL
    +Cl' :
      (A : Set) ->
      ClPointedPlusMagmaTerm A ->
      ClPointedPlusMagmaTerm A ->
      ClPointedPlusMagmaTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    eCl' :
      (A : Set) ->
      ClPointedPlusMagmaTerm A
    eCl' _ = eCl
    stageCl :
      (A : Set) ->
      ClPointedPlusMagmaTerm A ->
      Staged
        (ClPointedPlusMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (eCl) = Now eCl
    +OL' :
      (n : Nat) ->
      OpPointedPlusMagmaTerm n ->
      OpPointedPlusMagmaTerm n ->
      OpPointedPlusMagmaTerm n
    +OL' _ x1 x2 = +OL x1 x2
    eOL' :
      (n : Nat) ->
      OpPointedPlusMagmaTerm n
    eOL' _ = eOL
    stageOp :
      (n : Nat) ->
      OpPointedPlusMagmaTerm n ->
      Staged
        (OpPointedPlusMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (eOL) = Now eOL
    +OL2' :
      (n : Nat) (A : Set) ->
      OpPointedPlusMagmaTerm2 n A ->
      OpPointedPlusMagmaTerm2 n A ->
      OpPointedPlusMagmaTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    eOL2' :
      (n : Nat) (A : Set) ->
      OpPointedPlusMagmaTerm2 n A
    eOL2' _ _ = eOL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpPointedPlusMagmaTerm2 n A ->
      Staged
        (OpPointedPlusMagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (eOL2) = Now eOL2
    record PointedPlusMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        +T : Repr A -> Repr A -> Repr A
        eT : Repr A
  
  module PointedSemigroup where
    record PointedSemigroup
      (A : Set) : Set where
      constructor PointedSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        e : A
    record PointedSemigroupSig
      (AS : Set) : Set where
      constructor PointedSemigroupSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record PointedSemigroupProd
      (AP : Set) : Set where
      constructor PointedSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record PointedSemigroupHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedSemigroup A1)
      (Po2 : PointedSemigroup A2) :
      Set where
      constructor PointedSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Po1 x1 x2) ==
            op Po2 (hom x1) (hom x2)
        pres-e : hom (e Po1) == e Po2
    record PointedSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedSemigroup A1)
      (Po2 : PointedSemigroup A2) :
      Set where
      constructor PointedSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Po1 x1 x2)
            (op Po2 y1 y2)
        interp-e :
          interp (e Po1) (e Po2)
    data PointedSemigroupTerm
      : Set where
      opL :
        PointedSemigroupTerm ->
        PointedSemigroupTerm ->
        PointedSemigroupTerm
      eL : PointedSemigroupTerm
    data ClPointedSemigroupTerm
      (A : Set) : Set where
      sing :
        A -> ClPointedSemigroupTerm A
      opCl :
        ClPointedSemigroupTerm A ->
        ClPointedSemigroupTerm A ->
        ClPointedSemigroupTerm A
      eCl : ClPointedSemigroupTerm A
    data OpPointedSemigroupTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpPointedSemigroupTerm n
      opOL :
        OpPointedSemigroupTerm n ->
        OpPointedSemigroupTerm n ->
        OpPointedSemigroupTerm n
      eOL : OpPointedSemigroupTerm n
    data OpPointedSemigroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpPointedSemigroupTerm2 n A
      sing2 :
        A -> OpPointedSemigroupTerm2 n A
      opOL2 :
        OpPointedSemigroupTerm2 n A ->
        OpPointedSemigroupTerm2 n A ->
        OpPointedSemigroupTerm2 n A
      eOL2 :
        OpPointedSemigroupTerm2 n A
    simplifyB :
      PointedSemigroupTerm ->
      PointedSemigroupTerm
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (eL) = eL
    simplifyCl :
      (A : Set) ->
      ClPointedSemigroupTerm A ->
      ClPointedSemigroupTerm A
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpPointedSemigroupTerm n ->
      OpPointedSemigroupTerm n
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpPointedSemigroupTerm2 n A ->
      OpPointedSemigroupTerm2 n A
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      PointedSemigroup A ->
      PointedSemigroupTerm -> A
    evalB _ Po (opL x1 x2) =
      op Po (evalB _ Po x1)
        (evalB _ Po x2)
    evalB _ Po (eL) = e Po
    evalCl :
      (A : Set) ->
      PointedSemigroup A ->
      ClPointedSemigroupTerm A -> A
    evalCl _ Po (sing x1) = x1
    evalCl _ Po (opCl x1 x2) =
      op Po (evalCl _ Po x1)
        (evalCl _ Po x2)
    evalCl _ Po (eCl) = e Po
    evalOp :
      (A : Set) (n : Nat) ->
      PointedSemigroup A ->
      Vec A n ->
      OpPointedSemigroupTerm n -> A
    evalOp _ n Po vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Po vars (opOL
                        x1
                        x2) =
      op Po (evalOp _ n Po vars x1)
        (evalOp _ n Po vars x2)
    evalOp _ n Po vars (eOL) = e Po
    evalOpE :
      (A : Set) (n : Nat) ->
      PointedSemigroup A ->
      Vec A n ->
      OpPointedSemigroupTerm2 n A -> A
    evalOpE _ n Po vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Po vars (sing2 x1) =
      x1
    evalOpE _ n Po vars (opOL2
                         x1
                         x2) =
      op Po (evalOpE _ n Po vars x1)
        (evalOpE _ n Po vars x2)
    evalOpE _ n Po vars (eOL2) =
      e Po
    inductionB :
      (P : PointedSemigroupTerm ->
           Set) ->
      ((x1 : PointedSemigroupTerm)
       (x2 : PointedSemigroupTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      P eL ->
      (x : PointedSemigroupTerm) ->
      P x
    inductionB p popl pel (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p popl pel x1)
        (inductionB p popl pel x2)
    inductionB p popl pel (eL) = pel
    inductionCl :
      (A : Set)
      (P : ClPointedSemigroupTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClPointedSemigroupTerm A)
       (x2 : ClPointedSemigroupTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      P eCl ->
      (x : ClPointedSemigroupTerm
         A) -> P x
    inductionCl _ p psing popcl pecl (sing
                                      x1) = psing x1
    inductionCl _ p psing popcl pecl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing popcl
           pecl
           x1)
        (inductionCl _ p psing popcl
           pecl
           x2)
    inductionCl _ p psing popcl pecl (eCl) =
      pecl
    inductionOp :
      (n : Nat)
      (P : OpPointedSemigroupTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpPointedSemigroupTerm n)
       (x2 : OpPointedSemigroupTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      P eOL ->
      (x : OpPointedSemigroupTerm
         n) -> P x
    inductionOp _ p pv popol peol (v
                                   x1) = pv x1
    inductionOp _ p pv popol peol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv popol peol
           x1)
        (inductionOp _ p pv popol peol
           x2)
    inductionOp _ p pv popol peol (eOL) =
      peol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpPointedSemigroupTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpPointedSemigroupTerm2 n
          A)
       (x2 : OpPointedSemigroupTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      P eOL2 ->
      (x : OpPointedSemigroupTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (eOL2) =
      peol2
    opL' :
      PointedSemigroupTerm ->
      PointedSemigroupTerm ->
      PointedSemigroupTerm
    opL' x1 x2 = opL x1 x2
    eL' : PointedSemigroupTerm
    eL' = eL
    stageB :
      PointedSemigroupTerm ->
      Staged PointedSemigroupTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (eL) = Now eL
    opCl' :
      (A : Set) ->
      ClPointedSemigroupTerm A ->
      ClPointedSemigroupTerm A ->
      ClPointedSemigroupTerm A
    opCl' _ x1 x2 = opCl x1 x2
    eCl' :
      (A : Set) ->
      ClPointedSemigroupTerm A
    eCl' _ = eCl
    stageCl :
      (A : Set) ->
      ClPointedSemigroupTerm A ->
      Staged
        (ClPointedSemigroupTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (eCl) = Now eCl
    opOL' :
      (n : Nat) ->
      OpPointedSemigroupTerm n ->
      OpPointedSemigroupTerm n ->
      OpPointedSemigroupTerm n
    opOL' _ x1 x2 = opOL x1 x2
    eOL' :
      (n : Nat) ->
      OpPointedSemigroupTerm n
    eOL' _ = eOL
    stageOp :
      (n : Nat) ->
      OpPointedSemigroupTerm n ->
      Staged
        (OpPointedSemigroupTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (eOL) = Now eOL
    opOL2' :
      (n : Nat) (A : Set) ->
      OpPointedSemigroupTerm2 n A ->
      OpPointedSemigroupTerm2 n A ->
      OpPointedSemigroupTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    eOL2' :
      (n : Nat) (A : Set) ->
      OpPointedSemigroupTerm2 n A
    eOL2' _ _ = eOL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpPointedSemigroupTerm2 n A ->
      Staged
        (OpPointedSemigroupTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (eOL2) = Now eOL2
    record PointedSemigroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
        eT : Repr A
  
  module PointedZero where
    record PointedZero
      (A : Set) : Set where
      constructor PointedZeroC
      field
        0 : A
    record PointedZeroSig
      (AS : Set) : Set where
      constructor PointedZeroSigSigC
      field
        0S : AS
    record PointedZeroProd
      (AP : Set) : Set where
      constructor PointedZeroProdC
      field
        0P : Prod AP AP
    record PointedZeroHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedZero A1)
      (Po2 : PointedZero A2) :
      Set where
      constructor PointedZeroHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Po1) == 0 Po2
    record PointedZeroRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedZero A1)
      (Po2 : PointedZero A2) :
      Set where
      constructor PointedZeroRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Po1) (0 Po2)
    data PointedZeroTerm : Set where
      0L : PointedZeroTerm
    data ClPointedZeroTerm
      (A : Set) : Set where
      sing :
        A -> ClPointedZeroTerm A
      0Cl : ClPointedZeroTerm A
    data OpPointedZeroTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpPointedZeroTerm n
      0OL : OpPointedZeroTerm n
    data OpPointedZeroTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpPointedZeroTerm2 n A
      sing2 :
        A -> OpPointedZeroTerm2 n A
      0OL2 : OpPointedZeroTerm2 n A
    simplifyB :
      PointedZeroTerm ->
      PointedZeroTerm
    simplifyB (0L) = 0L
    simplifyCl :
      (A : Set) ->
      ClPointedZeroTerm A ->
      ClPointedZeroTerm A
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpPointedZeroTerm n ->
      OpPointedZeroTerm n
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpPointedZeroTerm2 n A ->
      OpPointedZeroTerm2 n A
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      PointedZero A ->
      PointedZeroTerm -> A
    evalB _ Po (0L) = 0 Po
    evalCl :
      (A : Set) ->
      PointedZero A ->
      ClPointedZeroTerm A -> A
    evalCl _ Po (sing x1) = x1
    evalCl _ Po (0Cl) = 0 Po
    evalOp :
      (A : Set) (n : Nat) ->
      PointedZero A ->
      Vec A n ->
      OpPointedZeroTerm n -> A
    evalOp _ n Po vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Po vars (0OL) = 0 Po
    evalOpE :
      (A : Set) (n : Nat) ->
      PointedZero A ->
      Vec A n ->
      OpPointedZeroTerm2 n A -> A
    evalOpE _ n Po vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Po vars (sing2 x1) =
      x1
    evalOpE _ n Po vars (0OL2) =
      0 Po
    inductionB :
      (P : PointedZeroTerm -> Set) ->
      P 0L ->
      (x : PointedZeroTerm) -> P x
    inductionB p p0l (0L) = p0l
    inductionCl :
      (A : Set)
      (P : ClPointedZeroTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 0Cl ->
      (x : ClPointedZeroTerm A) -> P x
    inductionCl _ p psing p0cl (sing
                                x1) = psing x1
    inductionCl _ p psing p0cl (0Cl) =
      p0cl
    inductionOp :
      (n : Nat)
      (P : OpPointedZeroTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 0OL ->
      (x : OpPointedZeroTerm n) -> P x
    inductionOp _ p pv p0ol (v x1) =
      pv x1
    inductionOp _ p pv p0ol (0OL) =
      p0ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpPointedZeroTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 0OL2 ->
      (x : OpPointedZeroTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p0ol2 (v2
                                         x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 (sing2
                                         x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 (0OL2) =
      p0ol2
    0L' : PointedZeroTerm
    0L' = 0L
    stageB :
      PointedZeroTerm ->
      Staged PointedZeroTerm
    stageB (0L) = Now 0L
    0Cl' :
      (A : Set) -> ClPointedZeroTerm A
    0Cl' _ = 0Cl
    stageCl :
      (A : Set) ->
      ClPointedZeroTerm A ->
      Staged (ClPointedZeroTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (0Cl) = Now 0Cl
    0OL' :
      (n : Nat) -> OpPointedZeroTerm n
    0OL' _ = 0OL
    stageOp :
      (n : Nat) ->
      OpPointedZeroTerm n ->
      Staged (OpPointedZeroTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (0OL) = Now 0OL
    0OL2' :
      (n : Nat) (A : Set) ->
      OpPointedZeroTerm2 n A
    0OL2' _ _ = 0OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpPointedZeroTerm2 n A ->
      Staged (OpPointedZeroTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (0OL2) = Now 0OL2
    record PointedZeroTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        0T : Repr A
  
  module RightUnital where
    record RightUnital
      (A : Set) : Set where
      constructor RightUnitalC
      field
        e : A
        op : A -> A -> A
        runit_e : (x : A) -> op x e == x
    record RightUnitalSig
      (AS : Set) : Set where
      constructor RightUnitalSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record RightUnitalProd
      (AP : Set) : Set where
      constructor RightUnitalProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
    record RightUnitalHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightUnital A1)
      (Ri2 : RightUnital A2) :
      Set where
      constructor RightUnitalHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Ri1) == e Ri2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record RightUnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightUnital A1)
      (Ri2 : RightUnital A2) :
      Set where
      constructor RightUnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Ri1) (e Ri2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data RightUnitalTerm : Set where
      eL : RightUnitalTerm
      opL :
        RightUnitalTerm ->
        RightUnitalTerm ->
        RightUnitalTerm
    data ClRightUnitalTerm
      (A : Set) : Set where
      sing :
        A -> ClRightUnitalTerm A
      eCl : ClRightUnitalTerm A
      opCl :
        ClRightUnitalTerm A ->
        ClRightUnitalTerm A ->
        ClRightUnitalTerm A
    data OpRightUnitalTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpRightUnitalTerm n
      eOL : OpRightUnitalTerm n
      opOL :
        OpRightUnitalTerm n ->
        OpRightUnitalTerm n ->
        OpRightUnitalTerm n
    data OpRightUnitalTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpRightUnitalTerm2 n A
      sing2 :
        A -> OpRightUnitalTerm2 n A
      eOL2 : OpRightUnitalTerm2 n A
      opOL2 :
        OpRightUnitalTerm2 n A ->
        OpRightUnitalTerm2 n A ->
        OpRightUnitalTerm2 n A
    simplifyB :
      RightUnitalTerm ->
      RightUnitalTerm
    simplifyB (opL x (eL)) = x
    simplifyB (eL) = eL
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRightUnitalTerm A ->
      ClRightUnitalTerm A
    simplifyCl _ (opCl x (eCl)) = x
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRightUnitalTerm n ->
      OpRightUnitalTerm n
    simplifyOp _ (opOL x (eOL)) = x
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRightUnitalTerm2 n A ->
      OpRightUnitalTerm2 n A
    simplifyOpE _ _ (opOL2
                     x
                     (eOL2)) = x
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RightUnital A ->
      RightUnitalTerm -> A
    evalB _ Ri (eL) = e Ri
    evalB _ Ri (opL x1 x2) =
      op Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      RightUnital A ->
      ClRightUnitalTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (eCl) = e Ri
    evalCl _ Ri (opCl x1 x2) =
      op Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RightUnital A ->
      Vec A n ->
      OpRightUnitalTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (eOL) = e Ri
    evalOp _ n Ri vars (opOL
                        x1
                        x2) =
      op Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RightUnital A ->
      Vec A n ->
      OpRightUnitalTerm2 n A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (eOL2) =
      e Ri
    evalOpE _ n Ri vars (opOL2
                         x1
                         x2) =
      op Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RightUnitalTerm -> Set) ->
      P eL ->
      ((x1 : RightUnitalTerm)
       (x2 : RightUnitalTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : RightUnitalTerm) -> P x
    inductionB p pel popl (eL) = pel
    inductionB p pel popl (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p pel popl x1)
        (inductionB p pel popl x2)
    inductionCl :
      (A : Set)
      (P : ClRightUnitalTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P eCl ->
      ((x1 : ClRightUnitalTerm A)
       (x2 : ClRightUnitalTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClRightUnitalTerm A) -> P x
    inductionCl _ p psing pecl popcl (sing
                                      x1) = psing x1
    inductionCl _ p psing pecl popcl (eCl) =
      pecl
    inductionCl _ p psing pecl popcl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing pecl
           popcl
           x1)
        (inductionCl _ p psing pecl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpRightUnitalTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P eOL ->
      ((x1 : OpRightUnitalTerm n)
       (x2 : OpRightUnitalTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpRightUnitalTerm n) -> P x
    inductionOp _ p pv peol popol (v
                                   x1) = pv x1
    inductionOp _ p pv peol popol (eOL) =
      peol
    inductionOp _ p pv peol popol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv peol popol
           x1)
        (inductionOp _ p pv peol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRightUnitalTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P eOL2 ->
      ((x1 : OpRightUnitalTerm2 n A)
       (x2 : OpRightUnitalTerm2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpRightUnitalTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x2)
    eL' : RightUnitalTerm
    eL' = eL
    opL' :
      RightUnitalTerm ->
      RightUnitalTerm ->
      RightUnitalTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      RightUnitalTerm ->
      Staged RightUnitalTerm
    stageB (eL) = Now eL
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    eCl' :
      (A : Set) -> ClRightUnitalTerm A
    eCl' _ = eCl
    opCl' :
      (A : Set) ->
      ClRightUnitalTerm A ->
      ClRightUnitalTerm A ->
      ClRightUnitalTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClRightUnitalTerm A ->
      Staged (ClRightUnitalTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (eCl) = Now eCl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    eOL' :
      (n : Nat) -> OpRightUnitalTerm n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      OpRightUnitalTerm n ->
      OpRightUnitalTerm n ->
      OpRightUnitalTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpRightUnitalTerm n ->
      Staged (OpRightUnitalTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (eOL) = Now eOL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    eOL2' :
      (n : Nat) (A : Set) ->
      OpRightUnitalTerm2 n A
    eOL2' _ _ = eOL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpRightUnitalTerm2 n A ->
      OpRightUnitalTerm2 n A ->
      OpRightUnitalTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRightUnitalTerm2 n A ->
      Staged (OpRightUnitalTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RightUnitalTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        eT : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module Semigroup where
    record Semigroup
      (A : Set) : Set where
      constructor SemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record SemigroupSig
      (AS : Set) : Set where
      constructor SemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record SemigroupProd
      (AP : Set) : Set where
      constructor SemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record SemigroupHom
      (A1 : Set) (A2 : Set)
      (Se1 : Semigroup A1)
      (Se2 : Semigroup A2) : Set where
      constructor SemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Se1 x1 x2) ==
            op Se2 (hom x1) (hom x2)
    record SemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Se1 : Semigroup A1)
      (Se2 : Semigroup A2) : Set where
      constructor SemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Se1 x1 x2)
            (op Se2 y1 y2)
    data SemigroupTerm : Set where
      opL :
        SemigroupTerm ->
        SemigroupTerm -> SemigroupTerm
    data ClSemigroupTerm
      (A : Set) : Set where
      sing : A -> ClSemigroupTerm A
      opCl :
        ClSemigroupTerm A ->
        ClSemigroupTerm A ->
        ClSemigroupTerm A
    data OpSemigroupTerm
      (n : Nat) : Set where
      v : Fin n -> OpSemigroupTerm n
      opOL :
        OpSemigroupTerm n ->
        OpSemigroupTerm n ->
        OpSemigroupTerm n
    data OpSemigroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpSemigroupTerm2 n A
      sing2 :
        A -> OpSemigroupTerm2 n A
      opOL2 :
        OpSemigroupTerm2 n A ->
        OpSemigroupTerm2 n A ->
        OpSemigroupTerm2 n A
    simplifyB :
      SemigroupTerm -> SemigroupTerm
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClSemigroupTerm A ->
      ClSemigroupTerm A
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpSemigroupTerm n ->
      OpSemigroupTerm n
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpSemigroupTerm2 n A ->
      OpSemigroupTerm2 n A
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Semigroup A ->
      SemigroupTerm -> A
    evalB _ Se (opL x1 x2) =
      op Se (evalB _ Se x1)
        (evalB _ Se x2)
    evalCl :
      (A : Set) ->
      Semigroup A ->
      ClSemigroupTerm A -> A
    evalCl _ Se (sing x1) = x1
    evalCl _ Se (opCl x1 x2) =
      op Se (evalCl _ Se x1)
        (evalCl _ Se x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Semigroup A ->
      Vec A n ->
      OpSemigroupTerm n -> A
    evalOp _ n Se vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Se vars (opOL
                        x1
                        x2) =
      op Se (evalOp _ n Se vars x1)
        (evalOp _ n Se vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Semigroup A ->
      Vec A n ->
      OpSemigroupTerm2 n A -> A
    evalOpE _ n Se vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Se vars (sing2 x1) =
      x1
    evalOpE _ n Se vars (opOL2
                         x1
                         x2) =
      op Se (evalOpE _ n Se vars x1)
        (evalOpE _ n Se vars x2)
    inductionB :
      (P : SemigroupTerm -> Set) ->
      ((x1 : SemigroupTerm)
       (x2 : SemigroupTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : SemigroupTerm) -> P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClSemigroupTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClSemigroupTerm A)
       (x2 : ClSemigroupTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClSemigroupTerm A) -> P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpSemigroupTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpSemigroupTerm n)
       (x2 : OpSemigroupTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpSemigroupTerm n) -> P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpSemigroupTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpSemigroupTerm2 n A)
       (x2 : OpSemigroupTerm2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpSemigroupTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      SemigroupTerm ->
      SemigroupTerm -> SemigroupTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      SemigroupTerm ->
      Staged SemigroupTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClSemigroupTerm A ->
      ClSemigroupTerm A ->
      ClSemigroupTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClSemigroupTerm A ->
      Staged (ClSemigroupTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpSemigroupTerm n ->
      OpSemigroupTerm n ->
      OpSemigroupTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpSemigroupTerm n ->
      Staged (OpSemigroupTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpSemigroupTerm2 n A ->
      OpSemigroupTerm2 n A ->
      OpSemigroupTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpSemigroupTerm2 n A ->
      Staged (OpSemigroupTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record SemigroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module Unital where
    record Unital
      (A : Set) : Set where
      constructor UnitalC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
    record UnitalSig
      (AS : Set) : Set where
      constructor UnitalSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record UnitalProd
      (AP : Set) : Set where
      constructor UnitalProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
    record UnitalHom
      (A1 : Set) (A2 : Set)
      (Un1 : Unital A1)
      (Un2 : Unital A2) : Set where
      constructor UnitalHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Un1) == e Un2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Un1 x1 x2) ==
            op Un2 (hom x1) (hom x2)
    record UnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Un1 : Unital A1)
      (Un2 : Unital A2) : Set where
      constructor UnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Un1) (e Un2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Un1 x1 x2)
            (op Un2 y1 y2)
    data UnitalTerm : Set where
      eL : UnitalTerm
      opL :
        UnitalTerm ->
        UnitalTerm -> UnitalTerm
    data ClUnitalTerm
      (A : Set) : Set where
      sing : A -> ClUnitalTerm A
      eCl : ClUnitalTerm A
      opCl :
        ClUnitalTerm A ->
        ClUnitalTerm A -> ClUnitalTerm A
    data OpUnitalTerm
      (n : Nat) : Set where
      v : Fin n -> OpUnitalTerm n
      eOL : OpUnitalTerm n
      opOL :
        OpUnitalTerm n ->
        OpUnitalTerm n -> OpUnitalTerm n
    data OpUnitalTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpUnitalTerm2 n A
      sing2 : A -> OpUnitalTerm2 n A
      eOL2 : OpUnitalTerm2 n A
      opOL2 :
        OpUnitalTerm2 n A ->
        OpUnitalTerm2 n A ->
        OpUnitalTerm2 n A
    simplifyB :
      UnitalTerm -> UnitalTerm
    simplifyB (opL (eL) x) = x
    simplifyB (opL x (eL)) = x
    simplifyB (eL) = eL
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClUnitalTerm A -> ClUnitalTerm A
    simplifyCl _ (opCl (eCl) x) = x
    simplifyCl _ (opCl x (eCl)) = x
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpUnitalTerm n -> OpUnitalTerm n
    simplifyOp _ (opOL (eOL) x) = x
    simplifyOp _ (opOL x (eOL)) = x
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpUnitalTerm2 n A ->
      OpUnitalTerm2 n A
    simplifyOpE _ _ (opOL2
                     (eOL2)
                     x) = x
    simplifyOpE _ _ (opOL2
                     x
                     (eOL2)) = x
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Unital A -> UnitalTerm -> A
    evalB _ Un (eL) = e Un
    evalB _ Un (opL x1 x2) =
      op Un (evalB _ Un x1)
        (evalB _ Un x2)
    evalCl :
      (A : Set) ->
      Unital A -> ClUnitalTerm A -> A
    evalCl _ Un (sing x1) = x1
    evalCl _ Un (eCl) = e Un
    evalCl _ Un (opCl x1 x2) =
      op Un (evalCl _ Un x1)
        (evalCl _ Un x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Unital A ->
      Vec A n -> OpUnitalTerm n -> A
    evalOp _ n Un vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Un vars (eOL) = e Un
    evalOp _ n Un vars (opOL
                        x1
                        x2) =
      op Un (evalOp _ n Un vars x1)
        (evalOp _ n Un vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Unital A ->
      Vec A n ->
      OpUnitalTerm2 n A -> A
    evalOpE _ n Un vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Un vars (sing2 x1) =
      x1
    evalOpE _ n Un vars (eOL2) =
      e Un
    evalOpE _ n Un vars (opOL2
                         x1
                         x2) =
      op Un (evalOpE _ n Un vars x1)
        (evalOpE _ n Un vars x2)
    inductionB :
      (P : UnitalTerm -> Set) ->
      P eL ->
      ((x1 : UnitalTerm)
       (x2 : UnitalTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : UnitalTerm) -> P x
    inductionB p pel popl (eL) = pel
    inductionB p pel popl (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p pel popl x1)
        (inductionB p pel popl x2)
    inductionCl :
      (A : Set)
      (P : ClUnitalTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P eCl ->
      ((x1 : ClUnitalTerm A)
       (x2 : ClUnitalTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClUnitalTerm A) -> P x
    inductionCl _ p psing pecl popcl (sing
                                      x1) = psing x1
    inductionCl _ p psing pecl popcl (eCl) =
      pecl
    inductionCl _ p psing pecl popcl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing pecl
           popcl
           x1)
        (inductionCl _ p psing pecl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpUnitalTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P eOL ->
      ((x1 : OpUnitalTerm n)
       (x2 : OpUnitalTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpUnitalTerm n) -> P x
    inductionOp _ p pv peol popol (v
                                   x1) = pv x1
    inductionOp _ p pv peol popol (eOL) =
      peol
    inductionOp _ p pv peol popol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv peol popol
           x1)
        (inductionOp _ p pv peol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpUnitalTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P eOL2 ->
      ((x1 : OpUnitalTerm2 n A)
       (x2 : OpUnitalTerm2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpUnitalTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x2)
    eL' : UnitalTerm
    eL' = eL
    opL' :
      UnitalTerm ->
      UnitalTerm -> UnitalTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      UnitalTerm -> Staged UnitalTerm
    stageB (eL) = Now eL
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    eCl' :
      (A : Set) -> ClUnitalTerm A
    eCl' _ = eCl
    opCl' :
      (A : Set) ->
      ClUnitalTerm A ->
      ClUnitalTerm A -> ClUnitalTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClUnitalTerm A ->
      Staged (ClUnitalTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (eCl) = Now eCl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    eOL' :
      (n : Nat) -> OpUnitalTerm n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      OpUnitalTerm n ->
      OpUnitalTerm n -> OpUnitalTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpUnitalTerm n ->
      Staged (OpUnitalTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (eOL) = Now eOL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    eOL2' :
      (n : Nat) (A : Set) ->
      OpUnitalTerm2 n A
    eOL2' _ _ = eOL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpUnitalTerm2 n A ->
      OpUnitalTerm2 n A ->
      OpUnitalTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpUnitalTerm2 n A ->
      Staged (OpUnitalTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record UnitalTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        eT : Repr A
        opT : Repr A -> Repr A -> Repr A
  

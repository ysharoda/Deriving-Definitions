module MathScheme  where
  record Prod (A B : Set) : Set where
    constructor prodC
    field
      fst : A
      snd : B
  data Nat  : Set where
    zero : Nat
    suc : (Nat -> Nat)
  data Fin (n : Nat) : Set where
    fzero : {m : Nat} (p : n == (suc m)) -> (Fin n)
    fsuc : {m : Nat} (p : n == (suc m)) (i : (Fin m)) -> (Fin n)
  pred : (Nat -> Nat)
  pred zero = zero 
  pred (suc n) = n 
  data Vec (A : Set) (n : Nat) : Set where
    nil : (n == zero -> (Vec A n))
    cons : {m : Nat} (p : n == (suc m)) (x : A) (xs : (Vec A m)) -> (Vec A n)
  data Unit  : Set where
    unit : Unit
  EmptyT : Set
  EmptyT  = ((A : Set) -> A) 
  subst : {A : Set} {x y : A} (P : (A -> Set)) -> (x == y -> ((P x) -> (P y)))
  subst P = (J (\ x y _ -> ((P x) -> (P y))) (\ x p -> p)) 
  sym : {A : Set} {x : A} {y : A} -> (x == y -> y == x)
  sym {A} {x} {y} p = (subst (\ y -> y == x) p refl) 
  cong : {A B : Set} {x : A} {y : A} (f : (A -> B)) -> (x == y -> (f x) == (f y))
  cong f p = (subst (\ y -> (f _) == (f y)) p refl) 
  IsZero : (Nat -> Set)
  IsZero zero = Unit 
  IsZero (suc n) = EmptyT 
  zeroNOTsuc : {n : Nat} -> (zero == (suc n) -> EmptyT)
  zeroNOTsuc p = (subst IsZero p unit) 
  trans : {A : Set} {x : A} {y : A} {z : A} -> (x == y -> (y == z -> x == z))
  trans {A} {x} p q = (subst (\ y -> x == y) q p) 
  lemma : {n m : Nat} -> (n == (suc m) -> (n == zero -> EmptyT))
  lemma p q = (zeroNOTsuc (trans (sym q) p)) 
  sucInj : {n m : Nat} -> ((suc n) == (suc m) -> n == m)
  sucInj p = (cong pred p) 
  lookup : {A : Set} (n : Nat) (i : (Fin n)) (v : (Vec A n)) -> A
  lookup {A} n (fzero {m} p) (nil q) = (lemma p q A) 
  lookup {A} n (fzero {m} p) (cons {l} q x xs) = x 
  lookup {A} n (fsuc {m} p i) (nil q) = (lemma p q A) 
  lookup {A} n (fsuc {m} p i) (cons {l} q x xs) = (lookup m i (subst (Vec A) (sucInj (trans (sym q) p)) xs)) 
  data Wrap (A : Set) : Set where
    Q : (A -> (Wrap A))
  data Stage  : Set where
    s0 : Stage
    s1 : Stage
  CodeRep : ((A : Set) (s : Stage) -> Set)
  CodeRep A s0 = A 
  CodeRep A s1 = (Wrap (CodeRep A s0)) 
  uncode : {A : Set} -> ((CodeRep A s1) -> (CodeRep A s0))
  uncode (Q x) = x 
  code : {A : Set} -> ((CodeRep A s0) -> (CodeRep A s1))
  code x = (Q x) 
  run : {A : Set} -> ((CodeRep A s1) -> A)
  run (Q x) = x 
  data Choice  : Set where
    Expr : Choice
    Const : Choice
  data Comp (A : Set) (s : Stage) : Set where
    Computation : (Choice -> ((CodeRep A s) -> (Comp A s)))
  data Staged (A : Set) : Set where
    Now : (A -> (Staged A))
    Later : ((Comp A s1) -> (Staged A))
  expr : {A : Set} -> ((CodeRep A s1) -> (Staged A))
  expr x = (Later (Computation Expr x)) 
  const : {A : Set} -> ((CodeRep A s1) -> (Staged A))
  const x = (Later (Computation Const x)) 
  stage0 : {A : Set} -> (A -> (Staged A))
  stage0 x = (Now x) 
  stage1 : {A B : Set} -> ((A -> B) -> (((CodeRep A s1) -> (CodeRep B s1)) -> ((Staged A) -> (Staged B))))
  stage1 f g (Now x) = (Now (f x)) 
  stage1 f g (Later (Computation _ x)) = (expr (g x)) 
  stage2 : {A B C : Set} -> ((A -> (B -> C)) -> (((CodeRep A s1) -> ((CodeRep B s1) -> (CodeRep C s1))) -> ((Staged A) -> ((Staged B) -> (Staged C)))))
  stage2 f _ (Now x) (Now y) = (stage0 (f x y)) 
  stage2 _ g (Now x) (Later (Computation _ y)) = (expr (g (code x) y)) 
  stage2 _ g (Later (Computation _ x)) (Now y) = (expr (g x (code y))) 
  stage2 _ g (Later (Computation _ x)) (Later (Computation _ y)) = (expr (g x y)) 
  codeLift1 : {A B : Set} -> ((A -> B) -> ((CodeRep A s1) -> (CodeRep B s1)))
  codeLift1 f x = (code (f (uncode x))) 
  codeLift2 : {A B C : Set} -> ((A -> (B -> C)) -> ((CodeRep A s1) -> ((CodeRep B s1) -> (CodeRep C s1))))
  codeLift2 f x y = (code (f (uncode x) (uncode y))) 
  module AbelianAdditiveGroup  where
    record AbelianAdditiveGroup (A : Set) : Set where
      constructor AbelianAdditiveGroupC
      field
        + : (A -> (A -> A))
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        0 : A
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        neg : (A -> A)
        leftInverse_inv_op_0 : {x : A} -> (+ x (neg x)) == 0
        rightInverse_inv_op_0 : {x : A} -> (+ (neg x) x) == 0
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        +S : (AS -> (AS -> AS))
        0S : AS
        negS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        0P : (Prod A A)
        negP : ((Prod A A) -> (Prod A A))
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        leftInverse_inv_op_0P : {xP : (Prod A A)} -> (+P xP (negP xP)) == 0P
        rightInverse_inv_op_0P : {xP : (Prod A A)} -> (+P (negP xP) xP) == 0P
    record Hom {A1 : Set} {A2 : Set} (Ab1 : (AbelianAdditiveGroup A1)) (Ab2 : (AbelianAdditiveGroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ab1) x1 x2)) == ((+ Ab2) (hom x1) (hom x2))
        pres-0 : (hom (0 Ab1)) == (0 Ab2)
        pres-neg : {x1 : A1} -> (hom ((neg Ab1) x1)) == ((neg Ab2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (Ab1 : (AbelianAdditiveGroup A1)) (Ab2 : (AbelianAdditiveGroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ab1) x1 x2) ((+ Ab2) y1 y2))))
        interp-0 : (interp (0 Ab1) (0 Ab2))
        interp-neg : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((neg Ab1) x1) ((neg Ab2) y1)))
    data AbelianAdditiveGroupTerm  : Set where
      +L : (AbelianAdditiveGroupTerm -> (AbelianAdditiveGroupTerm -> AbelianAdditiveGroupTerm))
      0L : AbelianAdditiveGroupTerm
      negL : (AbelianAdditiveGroupTerm -> AbelianAdditiveGroupTerm)
    data ClAbelianAdditiveGroupTerm (A : Set) : Set where
      sing : (A -> (ClAbelianAdditiveGroupTerm A))
      +Cl : ((ClAbelianAdditiveGroupTerm A) -> ((ClAbelianAdditiveGroupTerm A) -> (ClAbelianAdditiveGroupTerm A)))
      0Cl : (ClAbelianAdditiveGroupTerm A)
      negCl : ((ClAbelianAdditiveGroupTerm A) -> (ClAbelianAdditiveGroupTerm A))
    data OpAbelianAdditiveGroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpAbelianAdditiveGroupTerm n))
      +OL : ((OpAbelianAdditiveGroupTerm n) -> ((OpAbelianAdditiveGroupTerm n) -> (OpAbelianAdditiveGroupTerm n)))
      0OL : (OpAbelianAdditiveGroupTerm n)
      negOL : ((OpAbelianAdditiveGroupTerm n) -> (OpAbelianAdditiveGroupTerm n))
    data OpAbelianAdditiveGroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpAbelianAdditiveGroupTerm2 n A))
      sing2 : (A -> (OpAbelianAdditiveGroupTerm2 n A))
      +OL2 : ((OpAbelianAdditiveGroupTerm2 n A) -> ((OpAbelianAdditiveGroupTerm2 n A) -> (OpAbelianAdditiveGroupTerm2 n A)))
      0OL2 : (OpAbelianAdditiveGroupTerm2 n A)
      negOL2 : ((OpAbelianAdditiveGroupTerm2 n A) -> (OpAbelianAdditiveGroupTerm2 n A))
    simplifyCl : {A : Set} -> ((ClAbelianAdditiveGroupTerm A) -> (ClAbelianAdditiveGroupTerm A))
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 0Cl = 0Cl 
    simplifyCl (negCl x1) = (negCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpAbelianAdditiveGroupTerm n) -> (OpAbelianAdditiveGroupTerm n))
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 0OL = 0OL 
    simplifyOpB (negOL x1) = (negOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpAbelianAdditiveGroupTerm2 n A) -> (OpAbelianAdditiveGroupTerm2 n A))
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (negOL2 x1) = (negOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((AbelianAdditiveGroup A) -> (AbelianAdditiveGroupTerm -> A))
    evalB Ab (+L x1 x2) = ((+ Ab) (evalB Ab x1) (evalB Ab x2)) 
    evalB Ab 0L = (0 Ab) 
    evalB Ab (negL x1) = ((neg Ab) (evalB Ab x1)) 
    evalCl : {A : Set} -> ((AbelianAdditiveGroup A) -> ((ClAbelianAdditiveGroupTerm A) -> A))
    evalCl Ab (sing x1) = x1 
    evalCl Ab (+Cl x1 x2) = ((+ Ab) (evalCl Ab x1) (evalCl Ab x2)) 
    evalCl Ab 0Cl = (0 Ab) 
    evalCl Ab (negCl x1) = ((neg Ab) (evalCl Ab x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((AbelianAdditiveGroup A) -> ((Vec A n) -> ((OpAbelianAdditiveGroupTerm n) -> A)))
    evalOpB Ab vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ab vars (+OL x1 x2) = ((+ Ab) (evalOpB Ab vars x1) (evalOpB Ab vars x2)) 
    evalOpB Ab vars 0OL = (0 Ab) 
    evalOpB Ab vars (negOL x1) = ((neg Ab) (evalOpB Ab vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((AbelianAdditiveGroup A) -> ((Vec A n) -> ((OpAbelianAdditiveGroupTerm2 n A) -> A)))
    evalOp Ab vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ab vars (sing2 x1) = x1 
    evalOp Ab vars (+OL2 x1 x2) = ((+ Ab) (evalOp Ab vars x1) (evalOp Ab vars x2)) 
    evalOp Ab vars 0OL2 = (0 Ab) 
    evalOp Ab vars (negOL2 x1) = ((neg Ab) (evalOp Ab vars x1)) 
    inductionB : {P : (AbelianAdditiveGroupTerm -> Set)} -> (((x1 x2 : AbelianAdditiveGroupTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((P 0L) -> (((x1 : AbelianAdditiveGroupTerm) -> ((P x1) -> (P (negL x1)))) -> ((x : AbelianAdditiveGroupTerm) -> (P x)))))
    inductionB {p} p+l p0l pnegl (+L x1 x2) = (p+l _ _ (inductionB {p} p+l p0l pnegl x1) (inductionB {p} p+l p0l pnegl x2)) 
    inductionB {p} p+l p0l pnegl 0L = p0l 
    inductionB {p} p+l p0l pnegl (negL x1) = (pnegl _ (inductionB {p} p+l p0l pnegl x1)) 
    inductionCl : {A : Set} {P : ((ClAbelianAdditiveGroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClAbelianAdditiveGroupTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((P 0Cl) -> (((x1 : (ClAbelianAdditiveGroupTerm A)) -> ((P x1) -> (P (negCl x1)))) -> ((x : (ClAbelianAdditiveGroupTerm A)) -> (P x))))))
    inductionCl {_} {p} psing p+cl p0cl pnegcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p+cl p0cl pnegcl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p+cl p0cl pnegcl x1) (inductionCl {_} {p} psing p+cl p0cl pnegcl x2)) 
    inductionCl {_} {p} psing p+cl p0cl pnegcl 0Cl = p0cl 
    inductionCl {_} {p} psing p+cl p0cl pnegcl (negCl x1) = (pnegcl _ (inductionCl {_} {p} psing p+cl p0cl pnegcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpAbelianAdditiveGroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpAbelianAdditiveGroupTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((P 0OL) -> (((x1 : (OpAbelianAdditiveGroupTerm n)) -> ((P x1) -> (P (negOL x1)))) -> ((x : (OpAbelianAdditiveGroupTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv p+ol p0ol pnegol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p+ol p0ol pnegol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p+ol p0ol pnegol x1) (inductionOpB {_} {p} pv p+ol p0ol pnegol x2)) 
    inductionOpB {_} {p} pv p+ol p0ol pnegol 0OL = p0ol 
    inductionOpB {_} {p} pv p+ol p0ol pnegol (negOL x1) = (pnegol _ (inductionOpB {_} {p} pv p+ol p0ol pnegol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpAbelianAdditiveGroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpAbelianAdditiveGroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((P 0OL2) -> (((x1 : (OpAbelianAdditiveGroupTerm2 n A)) -> ((P x1) -> (P (negOL2 x1)))) -> ((x : (OpAbelianAdditiveGroupTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 (negOL2 x1) = (pnegol2 _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 x1)) 
    +L' : (AbelianAdditiveGroupTerm -> (AbelianAdditiveGroupTerm -> AbelianAdditiveGroupTerm))
    +L' x1 x2 = (+L x1 x2) 
    0L' : AbelianAdditiveGroupTerm
    0L'  = 0L 
    negL' : (AbelianAdditiveGroupTerm -> AbelianAdditiveGroupTerm)
    negL' x1 = (negL x1) 
    stageB : (AbelianAdditiveGroupTerm -> (Staged AbelianAdditiveGroupTerm))
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB 0L = (Now 0L) 
    stageB (negL x1) = (stage1 negL' (codeLift1 negL') (stageB x1)) 
    +Cl' : {A : Set} -> ((ClAbelianAdditiveGroupTerm A) -> ((ClAbelianAdditiveGroupTerm A) -> (ClAbelianAdditiveGroupTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    0Cl' : {A : Set} -> (ClAbelianAdditiveGroupTerm A)
    0Cl'  = 0Cl 
    negCl' : {A : Set} -> ((ClAbelianAdditiveGroupTerm A) -> (ClAbelianAdditiveGroupTerm A))
    negCl' x1 = (negCl x1) 
    stageCl : {A : Set} -> ((ClAbelianAdditiveGroupTerm A) -> (Staged (ClAbelianAdditiveGroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (negCl x1) = (stage1 negCl' (codeLift1 negCl') (stageCl x1)) 
    +OL' : {n : Nat} -> ((OpAbelianAdditiveGroupTerm n) -> ((OpAbelianAdditiveGroupTerm n) -> (OpAbelianAdditiveGroupTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    0OL' : {n : Nat} -> (OpAbelianAdditiveGroupTerm n)
    0OL'  = 0OL 
    negOL' : {n : Nat} -> ((OpAbelianAdditiveGroupTerm n) -> (OpAbelianAdditiveGroupTerm n))
    negOL' x1 = (negOL x1) 
    stageOpB : {n : Nat} -> ((OpAbelianAdditiveGroupTerm n) -> (Staged (OpAbelianAdditiveGroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (negOL x1) = (stage1 negOL' (codeLift1 negOL') (stageOpB x1)) 
    +OL2' : {n : Nat} {A : Set} -> ((OpAbelianAdditiveGroupTerm2 n A) -> ((OpAbelianAdditiveGroupTerm2 n A) -> (OpAbelianAdditiveGroupTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    0OL2' : {n : Nat} {A : Set} -> (OpAbelianAdditiveGroupTerm2 n A)
    0OL2'  = 0OL2 
    negOL2' : {n : Nat} {A : Set} -> ((OpAbelianAdditiveGroupTerm2 n A) -> (OpAbelianAdditiveGroupTerm2 n A))
    negOL2' x1 = (negOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpAbelianAdditiveGroupTerm2 n A) -> (Staged (OpAbelianAdditiveGroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (negOL2 x1) = (stage1 negOL2' (codeLift1 negOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        0T : (Repr A)
        negT : ((Repr A) -> (Repr A))
  module AbelianGroup  where
    record AbelianGroup (A : Set) : Set where
      constructor AbelianGroupC
      field
        1 : A
        * : (A -> (A -> A))
        lunit_1 : {x : A} -> (* 1 x) == x
        runit_1 : {x : A} -> (* x 1) == x
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        inv : (A -> A)
        leftInverse_inv_op_1 : {x : A} -> (* x (inv x)) == 1
        rightInverse_inv_op_1 : {x : A} -> (* (inv x) x) == 1
        commutative_* : {x y : A} -> (* x y) == (* y x)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        1S : AS
        *S : (AS -> (AS -> AS))
        invS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        1P : (Prod A A)
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        invP : ((Prod A A) -> (Prod A A))
        lunit_1P : {xP : (Prod A A)} -> (*P 1P xP) == xP
        runit_1P : {xP : (Prod A A)} -> (*P xP 1P) == xP
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        leftInverse_inv_op_1P : {xP : (Prod A A)} -> (*P xP (invP xP)) == 1P
        rightInverse_inv_op_1P : {xP : (Prod A A)} -> (*P (invP xP) xP) == 1P
        commutative_*P : {xP yP : (Prod A A)} -> (*P xP yP) == (*P yP xP)
    record Hom {A1 : Set} {A2 : Set} (Ab1 : (AbelianGroup A1)) (Ab2 : (AbelianGroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-1 : (hom (1 Ab1)) == (1 Ab2)
        pres-* : {x1 x2 : A1} -> (hom ((* Ab1) x1 x2)) == ((* Ab2) (hom x1) (hom x2))
        pres-inv : {x1 : A1} -> (hom ((inv Ab1) x1)) == ((inv Ab2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (Ab1 : (AbelianGroup A1)) (Ab2 : (AbelianGroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-1 : (interp (1 Ab1) (1 Ab2))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Ab1) x1 x2) ((* Ab2) y1 y2))))
        interp-inv : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((inv Ab1) x1) ((inv Ab2) y1)))
    data AbelianGroupTerm  : Set where
      1L : AbelianGroupTerm
      *L : (AbelianGroupTerm -> (AbelianGroupTerm -> AbelianGroupTerm))
      invL : (AbelianGroupTerm -> AbelianGroupTerm)
    data ClAbelianGroupTerm (A : Set) : Set where
      sing : (A -> (ClAbelianGroupTerm A))
      1Cl : (ClAbelianGroupTerm A)
      *Cl : ((ClAbelianGroupTerm A) -> ((ClAbelianGroupTerm A) -> (ClAbelianGroupTerm A)))
      invCl : ((ClAbelianGroupTerm A) -> (ClAbelianGroupTerm A))
    data OpAbelianGroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpAbelianGroupTerm n))
      1OL : (OpAbelianGroupTerm n)
      *OL : ((OpAbelianGroupTerm n) -> ((OpAbelianGroupTerm n) -> (OpAbelianGroupTerm n)))
      invOL : ((OpAbelianGroupTerm n) -> (OpAbelianGroupTerm n))
    data OpAbelianGroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpAbelianGroupTerm2 n A))
      sing2 : (A -> (OpAbelianGroupTerm2 n A))
      1OL2 : (OpAbelianGroupTerm2 n A)
      *OL2 : ((OpAbelianGroupTerm2 n A) -> ((OpAbelianGroupTerm2 n A) -> (OpAbelianGroupTerm2 n A)))
      invOL2 : ((OpAbelianGroupTerm2 n A) -> (OpAbelianGroupTerm2 n A))
    simplifyCl : {A : Set} -> ((ClAbelianGroupTerm A) -> (ClAbelianGroupTerm A))
    simplifyCl (*Cl 1Cl x) = x 
    simplifyCl (*Cl x 1Cl) = x 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (invCl x1) = (invCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpAbelianGroupTerm n) -> (OpAbelianGroupTerm n))
    simplifyOpB (*OL 1OL x) = x 
    simplifyOpB (*OL x 1OL) = x 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (invOL x1) = (invOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpAbelianGroupTerm2 n A) -> (OpAbelianGroupTerm2 n A))
    simplifyOp (*OL2 1OL2 x) = x 
    simplifyOp (*OL2 x 1OL2) = x 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (invOL2 x1) = (invOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((AbelianGroup A) -> (AbelianGroupTerm -> A))
    evalB Ab 1L = (1 Ab) 
    evalB Ab (*L x1 x2) = ((* Ab) (evalB Ab x1) (evalB Ab x2)) 
    evalB Ab (invL x1) = ((inv Ab) (evalB Ab x1)) 
    evalCl : {A : Set} -> ((AbelianGroup A) -> ((ClAbelianGroupTerm A) -> A))
    evalCl Ab (sing x1) = x1 
    evalCl Ab 1Cl = (1 Ab) 
    evalCl Ab (*Cl x1 x2) = ((* Ab) (evalCl Ab x1) (evalCl Ab x2)) 
    evalCl Ab (invCl x1) = ((inv Ab) (evalCl Ab x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((AbelianGroup A) -> ((Vec A n) -> ((OpAbelianGroupTerm n) -> A)))
    evalOpB Ab vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ab vars 1OL = (1 Ab) 
    evalOpB Ab vars (*OL x1 x2) = ((* Ab) (evalOpB Ab vars x1) (evalOpB Ab vars x2)) 
    evalOpB Ab vars (invOL x1) = ((inv Ab) (evalOpB Ab vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((AbelianGroup A) -> ((Vec A n) -> ((OpAbelianGroupTerm2 n A) -> A)))
    evalOp Ab vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ab vars (sing2 x1) = x1 
    evalOp Ab vars 1OL2 = (1 Ab) 
    evalOp Ab vars (*OL2 x1 x2) = ((* Ab) (evalOp Ab vars x1) (evalOp Ab vars x2)) 
    evalOp Ab vars (invOL2 x1) = ((inv Ab) (evalOp Ab vars x1)) 
    inductionB : {P : (AbelianGroupTerm -> Set)} -> ((P 1L) -> (((x1 x2 : AbelianGroupTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 : AbelianGroupTerm) -> ((P x1) -> (P (invL x1)))) -> ((x : AbelianGroupTerm) -> (P x)))))
    inductionB {p} p1l p*l pinvl 1L = p1l 
    inductionB {p} p1l p*l pinvl (*L x1 x2) = (p*l _ _ (inductionB {p} p1l p*l pinvl x1) (inductionB {p} p1l p*l pinvl x2)) 
    inductionB {p} p1l p*l pinvl (invL x1) = (pinvl _ (inductionB {p} p1l p*l pinvl x1)) 
    inductionCl : {A : Set} {P : ((ClAbelianGroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 1Cl) -> (((x1 x2 : (ClAbelianGroupTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 : (ClAbelianGroupTerm A)) -> ((P x1) -> (P (invCl x1)))) -> ((x : (ClAbelianGroupTerm A)) -> (P x))))))
    inductionCl {_} {p} psing p1cl p*cl pinvcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p1cl p*cl pinvcl 1Cl = p1cl 
    inductionCl {_} {p} psing p1cl p*cl pinvcl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p1cl p*cl pinvcl x1) (inductionCl {_} {p} psing p1cl p*cl pinvcl x2)) 
    inductionCl {_} {p} psing p1cl p*cl pinvcl (invCl x1) = (pinvcl _ (inductionCl {_} {p} psing p1cl p*cl pinvcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpAbelianGroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 1OL) -> (((x1 x2 : (OpAbelianGroupTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 : (OpAbelianGroupTerm n)) -> ((P x1) -> (P (invOL x1)))) -> ((x : (OpAbelianGroupTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv p1ol p*ol pinvol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p1ol p*ol pinvol 1OL = p1ol 
    inductionOpB {_} {p} pv p1ol p*ol pinvol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p1ol p*ol pinvol x1) (inductionOpB {_} {p} pv p1ol p*ol pinvol x2)) 
    inductionOpB {_} {p} pv p1ol p*ol pinvol (invOL x1) = (pinvol _ (inductionOpB {_} {p} pv p1ol p*ol pinvol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpAbelianGroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 1OL2) -> (((x1 x2 : (OpAbelianGroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 : (OpAbelianGroupTerm2 n A)) -> ((P x1) -> (P (invOL2 x1)))) -> ((x : (OpAbelianGroupTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 pinvol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 pinvol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 pinvol2 1OL2 = p1ol2 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 pinvol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 pinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 pinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 pinvol2 (invOL2 x1) = (pinvol2 _ (inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 pinvol2 x1)) 
    1L' : AbelianGroupTerm
    1L'  = 1L 
    *L' : (AbelianGroupTerm -> (AbelianGroupTerm -> AbelianGroupTerm))
    *L' x1 x2 = (*L x1 x2) 
    invL' : (AbelianGroupTerm -> AbelianGroupTerm)
    invL' x1 = (invL x1) 
    stageB : (AbelianGroupTerm -> (Staged AbelianGroupTerm))
    stageB 1L = (Now 1L) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (invL x1) = (stage1 invL' (codeLift1 invL') (stageB x1)) 
    1Cl' : {A : Set} -> (ClAbelianGroupTerm A)
    1Cl'  = 1Cl 
    *Cl' : {A : Set} -> ((ClAbelianGroupTerm A) -> ((ClAbelianGroupTerm A) -> (ClAbelianGroupTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    invCl' : {A : Set} -> ((ClAbelianGroupTerm A) -> (ClAbelianGroupTerm A))
    invCl' x1 = (invCl x1) 
    stageCl : {A : Set} -> ((ClAbelianGroupTerm A) -> (Staged (ClAbelianGroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 1Cl = (Now 1Cl) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (invCl x1) = (stage1 invCl' (codeLift1 invCl') (stageCl x1)) 
    1OL' : {n : Nat} -> (OpAbelianGroupTerm n)
    1OL'  = 1OL 
    *OL' : {n : Nat} -> ((OpAbelianGroupTerm n) -> ((OpAbelianGroupTerm n) -> (OpAbelianGroupTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    invOL' : {n : Nat} -> ((OpAbelianGroupTerm n) -> (OpAbelianGroupTerm n))
    invOL' x1 = (invOL x1) 
    stageOpB : {n : Nat} -> ((OpAbelianGroupTerm n) -> (Staged (OpAbelianGroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 1OL = (Now 1OL) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (invOL x1) = (stage1 invOL' (codeLift1 invOL') (stageOpB x1)) 
    1OL2' : {n : Nat} {A : Set} -> (OpAbelianGroupTerm2 n A)
    1OL2'  = 1OL2 
    *OL2' : {n : Nat} {A : Set} -> ((OpAbelianGroupTerm2 n A) -> ((OpAbelianGroupTerm2 n A) -> (OpAbelianGroupTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    invOL2' : {n : Nat} {A : Set} -> ((OpAbelianGroupTerm2 n A) -> (OpAbelianGroupTerm2 n A))
    invOL2' x1 = (invOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpAbelianGroupTerm2 n A) -> (Staged (OpAbelianGroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 1OL2 = (Now 1OL2) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (invOL2 x1) = (stage1 invOL2' (codeLift1 invOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        1T : (Repr A)
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        invT : ((Repr A) -> (Repr A))
  module Absorption  where
    record Absorption (A : Set) : Set where
      constructor AbsorptionC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        leftAbsorp_*_+ : {x y : A} -> (* x (+ x y)) == x
        leftAbsorp_+_* : {x y : A} -> (+ x (* x y)) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftAbsorp_*_+P : {xP yP : (Prod A A)} -> (*P xP (+P xP yP)) == xP
        leftAbsorp_+_*P : {xP yP : (Prod A A)} -> (+P xP (*P xP yP)) == xP
    record Hom {A1 : Set} {A2 : Set} (Ab1 : (Absorption A1)) (Ab2 : (Absorption A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Ab1) x1 x2)) == ((* Ab2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ab1) x1 x2)) == ((+ Ab2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ab1 : (Absorption A1)) (Ab2 : (Absorption A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Ab1) x1 x2) ((* Ab2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ab1) x1 x2) ((+ Ab2) y1 y2))))
    data AbsorptionTerm  : Set where
      *L : (AbsorptionTerm -> (AbsorptionTerm -> AbsorptionTerm))
      +L : (AbsorptionTerm -> (AbsorptionTerm -> AbsorptionTerm))
    data ClAbsorptionTerm (A : Set) : Set where
      sing : (A -> (ClAbsorptionTerm A))
      *Cl : ((ClAbsorptionTerm A) -> ((ClAbsorptionTerm A) -> (ClAbsorptionTerm A)))
      +Cl : ((ClAbsorptionTerm A) -> ((ClAbsorptionTerm A) -> (ClAbsorptionTerm A)))
    data OpAbsorptionTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpAbsorptionTerm n))
      *OL : ((OpAbsorptionTerm n) -> ((OpAbsorptionTerm n) -> (OpAbsorptionTerm n)))
      +OL : ((OpAbsorptionTerm n) -> ((OpAbsorptionTerm n) -> (OpAbsorptionTerm n)))
    data OpAbsorptionTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpAbsorptionTerm2 n A))
      sing2 : (A -> (OpAbsorptionTerm2 n A))
      *OL2 : ((OpAbsorptionTerm2 n A) -> ((OpAbsorptionTerm2 n A) -> (OpAbsorptionTerm2 n A)))
      +OL2 : ((OpAbsorptionTerm2 n A) -> ((OpAbsorptionTerm2 n A) -> (OpAbsorptionTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClAbsorptionTerm A) -> (ClAbsorptionTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpAbsorptionTerm n) -> (OpAbsorptionTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpAbsorptionTerm2 n A) -> (OpAbsorptionTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Absorption A) -> (AbsorptionTerm -> A))
    evalB Ab (*L x1 x2) = ((* Ab) (evalB Ab x1) (evalB Ab x2)) 
    evalB Ab (+L x1 x2) = ((+ Ab) (evalB Ab x1) (evalB Ab x2)) 
    evalCl : {A : Set} -> ((Absorption A) -> ((ClAbsorptionTerm A) -> A))
    evalCl Ab (sing x1) = x1 
    evalCl Ab (*Cl x1 x2) = ((* Ab) (evalCl Ab x1) (evalCl Ab x2)) 
    evalCl Ab (+Cl x1 x2) = ((+ Ab) (evalCl Ab x1) (evalCl Ab x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Absorption A) -> ((Vec A n) -> ((OpAbsorptionTerm n) -> A)))
    evalOpB Ab vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ab vars (*OL x1 x2) = ((* Ab) (evalOpB Ab vars x1) (evalOpB Ab vars x2)) 
    evalOpB Ab vars (+OL x1 x2) = ((+ Ab) (evalOpB Ab vars x1) (evalOpB Ab vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Absorption A) -> ((Vec A n) -> ((OpAbsorptionTerm2 n A) -> A)))
    evalOp Ab vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ab vars (sing2 x1) = x1 
    evalOp Ab vars (*OL2 x1 x2) = ((* Ab) (evalOp Ab vars x1) (evalOp Ab vars x2)) 
    evalOp Ab vars (+OL2 x1 x2) = ((+ Ab) (evalOp Ab vars x1) (evalOp Ab vars x2)) 
    inductionB : {P : (AbsorptionTerm -> Set)} -> (((x1 x2 : AbsorptionTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : AbsorptionTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : AbsorptionTerm) -> (P x))))
    inductionB {p} p*l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionB {p} p*l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClAbsorptionTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClAbsorptionTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClAbsorptionTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClAbsorptionTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p*cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpAbsorptionTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpAbsorptionTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpAbsorptionTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpAbsorptionTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p*ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpAbsorptionTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpAbsorptionTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpAbsorptionTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpAbsorptionTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    *L' : (AbsorptionTerm -> (AbsorptionTerm -> AbsorptionTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (AbsorptionTerm -> (AbsorptionTerm -> AbsorptionTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (AbsorptionTerm -> (Staged AbsorptionTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClAbsorptionTerm A) -> ((ClAbsorptionTerm A) -> (ClAbsorptionTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClAbsorptionTerm A) -> ((ClAbsorptionTerm A) -> (ClAbsorptionTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClAbsorptionTerm A) -> (Staged (ClAbsorptionTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpAbsorptionTerm n) -> ((OpAbsorptionTerm n) -> (OpAbsorptionTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpAbsorptionTerm n) -> ((OpAbsorptionTerm n) -> (OpAbsorptionTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpAbsorptionTerm n) -> (Staged (OpAbsorptionTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpAbsorptionTerm2 n A) -> ((OpAbsorptionTerm2 n A) -> (OpAbsorptionTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpAbsorptionTerm2 n A) -> ((OpAbsorptionTerm2 n A) -> (OpAbsorptionTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpAbsorptionTerm2 n A) -> (Staged (OpAbsorptionTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module AddCommMonWithMultMagma  where
    record AddCommMonWithMultMagma (A : Set) : Set where
      constructor AddCommMonWithMultMagmaC
      field
        0 : A
        + : (A -> (A -> A))
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        * : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        0S : AS
        +S : (AS -> (AS -> AS))
        *S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        0P : (Prod A A)
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
    record Hom {A1 : Set} {A2 : Set} (Ad1 : (AddCommMonWithMultMagma A1)) (Ad2 : (AddCommMonWithMultMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-0 : (hom (0 Ad1)) == (0 Ad2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ad1) x1 x2)) == ((+ Ad2) (hom x1) (hom x2))
        pres-* : {x1 x2 : A1} -> (hom ((* Ad1) x1 x2)) == ((* Ad2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ad1 : (AddCommMonWithMultMagma A1)) (Ad2 : (AddCommMonWithMultMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-0 : (interp (0 Ad1) (0 Ad2))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ad1) x1 x2) ((+ Ad2) y1 y2))))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Ad1) x1 x2) ((* Ad2) y1 y2))))
    data AddCommMonWithMultMagmaTerm  : Set where
      0L : AddCommMonWithMultMagmaTerm
      +L : (AddCommMonWithMultMagmaTerm -> (AddCommMonWithMultMagmaTerm -> AddCommMonWithMultMagmaTerm))
      *L : (AddCommMonWithMultMagmaTerm -> (AddCommMonWithMultMagmaTerm -> AddCommMonWithMultMagmaTerm))
    data ClAddCommMonWithMultMagmaTerm (A : Set) : Set where
      sing : (A -> (ClAddCommMonWithMultMagmaTerm A))
      0Cl : (ClAddCommMonWithMultMagmaTerm A)
      +Cl : ((ClAddCommMonWithMultMagmaTerm A) -> ((ClAddCommMonWithMultMagmaTerm A) -> (ClAddCommMonWithMultMagmaTerm A)))
      *Cl : ((ClAddCommMonWithMultMagmaTerm A) -> ((ClAddCommMonWithMultMagmaTerm A) -> (ClAddCommMonWithMultMagmaTerm A)))
    data OpAddCommMonWithMultMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpAddCommMonWithMultMagmaTerm n))
      0OL : (OpAddCommMonWithMultMagmaTerm n)
      +OL : ((OpAddCommMonWithMultMagmaTerm n) -> ((OpAddCommMonWithMultMagmaTerm n) -> (OpAddCommMonWithMultMagmaTerm n)))
      *OL : ((OpAddCommMonWithMultMagmaTerm n) -> ((OpAddCommMonWithMultMagmaTerm n) -> (OpAddCommMonWithMultMagmaTerm n)))
    data OpAddCommMonWithMultMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpAddCommMonWithMultMagmaTerm2 n A))
      sing2 : (A -> (OpAddCommMonWithMultMagmaTerm2 n A))
      0OL2 : (OpAddCommMonWithMultMagmaTerm2 n A)
      +OL2 : ((OpAddCommMonWithMultMagmaTerm2 n A) -> ((OpAddCommMonWithMultMagmaTerm2 n A) -> (OpAddCommMonWithMultMagmaTerm2 n A)))
      *OL2 : ((OpAddCommMonWithMultMagmaTerm2 n A) -> ((OpAddCommMonWithMultMagmaTerm2 n A) -> (OpAddCommMonWithMultMagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClAddCommMonWithMultMagmaTerm A) -> (ClAddCommMonWithMultMagmaTerm A))
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl 0Cl = 0Cl 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpAddCommMonWithMultMagmaTerm n) -> (OpAddCommMonWithMultMagmaTerm n))
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB 0OL = 0OL 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpAddCommMonWithMultMagmaTerm2 n A) -> (OpAddCommMonWithMultMagmaTerm2 n A))
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((AddCommMonWithMultMagma A) -> (AddCommMonWithMultMagmaTerm -> A))
    evalB Ad 0L = (0 Ad) 
    evalB Ad (+L x1 x2) = ((+ Ad) (evalB Ad x1) (evalB Ad x2)) 
    evalB Ad (*L x1 x2) = ((* Ad) (evalB Ad x1) (evalB Ad x2)) 
    evalCl : {A : Set} -> ((AddCommMonWithMultMagma A) -> ((ClAddCommMonWithMultMagmaTerm A) -> A))
    evalCl Ad (sing x1) = x1 
    evalCl Ad 0Cl = (0 Ad) 
    evalCl Ad (+Cl x1 x2) = ((+ Ad) (evalCl Ad x1) (evalCl Ad x2)) 
    evalCl Ad (*Cl x1 x2) = ((* Ad) (evalCl Ad x1) (evalCl Ad x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((AddCommMonWithMultMagma A) -> ((Vec A n) -> ((OpAddCommMonWithMultMagmaTerm n) -> A)))
    evalOpB Ad vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ad vars 0OL = (0 Ad) 
    evalOpB Ad vars (+OL x1 x2) = ((+ Ad) (evalOpB Ad vars x1) (evalOpB Ad vars x2)) 
    evalOpB Ad vars (*OL x1 x2) = ((* Ad) (evalOpB Ad vars x1) (evalOpB Ad vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((AddCommMonWithMultMagma A) -> ((Vec A n) -> ((OpAddCommMonWithMultMagmaTerm2 n A) -> A)))
    evalOp Ad vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ad vars (sing2 x1) = x1 
    evalOp Ad vars 0OL2 = (0 Ad) 
    evalOp Ad vars (+OL2 x1 x2) = ((+ Ad) (evalOp Ad vars x1) (evalOp Ad vars x2)) 
    evalOp Ad vars (*OL2 x1 x2) = ((* Ad) (evalOp Ad vars x1) (evalOp Ad vars x2)) 
    inductionB : {P : (AddCommMonWithMultMagmaTerm -> Set)} -> ((P 0L) -> (((x1 x2 : AddCommMonWithMultMagmaTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> (((x1 x2 : AddCommMonWithMultMagmaTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((x : AddCommMonWithMultMagmaTerm) -> (P x)))))
    inductionB {p} p0l p+l p*l 0L = p0l 
    inductionB {p} p0l p+l p*l (+L x1 x2) = (p+l _ _ (inductionB {p} p0l p+l p*l x1) (inductionB {p} p0l p+l p*l x2)) 
    inductionB {p} p0l p+l p*l (*L x1 x2) = (p*l _ _ (inductionB {p} p0l p+l p*l x1) (inductionB {p} p0l p+l p*l x2)) 
    inductionCl : {A : Set} {P : ((ClAddCommMonWithMultMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 0Cl) -> (((x1 x2 : (ClAddCommMonWithMultMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> (((x1 x2 : (ClAddCommMonWithMultMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((x : (ClAddCommMonWithMultMagmaTerm A)) -> (P x))))))
    inductionCl {_} {p} psing p0cl p+cl p*cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p0cl p+cl p*cl 0Cl = p0cl 
    inductionCl {_} {p} psing p0cl p+cl p*cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p0cl p+cl p*cl x1) (inductionCl {_} {p} psing p0cl p+cl p*cl x2)) 
    inductionCl {_} {p} psing p0cl p+cl p*cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p0cl p+cl p*cl x1) (inductionCl {_} {p} psing p0cl p+cl p*cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpAddCommMonWithMultMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 0OL) -> (((x1 x2 : (OpAddCommMonWithMultMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> (((x1 x2 : (OpAddCommMonWithMultMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((x : (OpAddCommMonWithMultMagmaTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv p0ol p+ol p*ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p0ol p+ol p*ol 0OL = p0ol 
    inductionOpB {_} {p} pv p0ol p+ol p*ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p0ol p+ol p*ol x1) (inductionOpB {_} {p} pv p0ol p+ol p*ol x2)) 
    inductionOpB {_} {p} pv p0ol p+ol p*ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p0ol p+ol p*ol x1) (inductionOpB {_} {p} pv p0ol p+ol p*ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpAddCommMonWithMultMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 0OL2) -> (((x1 x2 : (OpAddCommMonWithMultMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> (((x1 x2 : (OpAddCommMonWithMultMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((x : (OpAddCommMonWithMultMagmaTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 x2)) 
    0L' : AddCommMonWithMultMagmaTerm
    0L'  = 0L 
    +L' : (AddCommMonWithMultMagmaTerm -> (AddCommMonWithMultMagmaTerm -> AddCommMonWithMultMagmaTerm))
    +L' x1 x2 = (+L x1 x2) 
    *L' : (AddCommMonWithMultMagmaTerm -> (AddCommMonWithMultMagmaTerm -> AddCommMonWithMultMagmaTerm))
    *L' x1 x2 = (*L x1 x2) 
    stageB : (AddCommMonWithMultMagmaTerm -> (Staged AddCommMonWithMultMagmaTerm))
    stageB 0L = (Now 0L) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    0Cl' : {A : Set} -> (ClAddCommMonWithMultMagmaTerm A)
    0Cl'  = 0Cl 
    +Cl' : {A : Set} -> ((ClAddCommMonWithMultMagmaTerm A) -> ((ClAddCommMonWithMultMagmaTerm A) -> (ClAddCommMonWithMultMagmaTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    *Cl' : {A : Set} -> ((ClAddCommMonWithMultMagmaTerm A) -> ((ClAddCommMonWithMultMagmaTerm A) -> (ClAddCommMonWithMultMagmaTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    stageCl : {A : Set} -> ((ClAddCommMonWithMultMagmaTerm A) -> (Staged (ClAddCommMonWithMultMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    0OL' : {n : Nat} -> (OpAddCommMonWithMultMagmaTerm n)
    0OL'  = 0OL 
    +OL' : {n : Nat} -> ((OpAddCommMonWithMultMagmaTerm n) -> ((OpAddCommMonWithMultMagmaTerm n) -> (OpAddCommMonWithMultMagmaTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    *OL' : {n : Nat} -> ((OpAddCommMonWithMultMagmaTerm n) -> ((OpAddCommMonWithMultMagmaTerm n) -> (OpAddCommMonWithMultMagmaTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpAddCommMonWithMultMagmaTerm n) -> (Staged (OpAddCommMonWithMultMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    0OL2' : {n : Nat} {A : Set} -> (OpAddCommMonWithMultMagmaTerm2 n A)
    0OL2'  = 0OL2 
    +OL2' : {n : Nat} {A : Set} -> ((OpAddCommMonWithMultMagmaTerm2 n A) -> ((OpAddCommMonWithMultMagmaTerm2 n A) -> (OpAddCommMonWithMultMagmaTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    *OL2' : {n : Nat} {A : Set} -> ((OpAddCommMonWithMultMagmaTerm2 n A) -> ((OpAddCommMonWithMultMagmaTerm2 n A) -> (OpAddCommMonWithMultMagmaTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpAddCommMonWithMultMagmaTerm2 n A) -> (Staged (OpAddCommMonWithMultMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        0T : (Repr A)
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module AddCommMonWithMultSemigroup  where
    record AddCommMonWithMultSemigroup (A : Set) : Set where
      constructor AddCommMonWithMultSemigroupC
      field
        * : (A -> (A -> A))
        0 : A
        + : (A -> (A -> A))
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        0S : AS
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        0P : (Prod A A)
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
    record Hom {A1 : Set} {A2 : Set} (Ad1 : (AddCommMonWithMultSemigroup A1)) (Ad2 : (AddCommMonWithMultSemigroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Ad1) x1 x2)) == ((* Ad2) (hom x1) (hom x2))
        pres-0 : (hom (0 Ad1)) == (0 Ad2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ad1) x1 x2)) == ((+ Ad2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ad1 : (AddCommMonWithMultSemigroup A1)) (Ad2 : (AddCommMonWithMultSemigroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Ad1) x1 x2) ((* Ad2) y1 y2))))
        interp-0 : (interp (0 Ad1) (0 Ad2))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ad1) x1 x2) ((+ Ad2) y1 y2))))
    data AddCommMonWithMultSemigroupTerm  : Set where
      *L : (AddCommMonWithMultSemigroupTerm -> (AddCommMonWithMultSemigroupTerm -> AddCommMonWithMultSemigroupTerm))
      0L : AddCommMonWithMultSemigroupTerm
      +L : (AddCommMonWithMultSemigroupTerm -> (AddCommMonWithMultSemigroupTerm -> AddCommMonWithMultSemigroupTerm))
    data ClAddCommMonWithMultSemigroupTerm (A : Set) : Set where
      sing : (A -> (ClAddCommMonWithMultSemigroupTerm A))
      *Cl : ((ClAddCommMonWithMultSemigroupTerm A) -> ((ClAddCommMonWithMultSemigroupTerm A) -> (ClAddCommMonWithMultSemigroupTerm A)))
      0Cl : (ClAddCommMonWithMultSemigroupTerm A)
      +Cl : ((ClAddCommMonWithMultSemigroupTerm A) -> ((ClAddCommMonWithMultSemigroupTerm A) -> (ClAddCommMonWithMultSemigroupTerm A)))
    data OpAddCommMonWithMultSemigroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpAddCommMonWithMultSemigroupTerm n))
      *OL : ((OpAddCommMonWithMultSemigroupTerm n) -> ((OpAddCommMonWithMultSemigroupTerm n) -> (OpAddCommMonWithMultSemigroupTerm n)))
      0OL : (OpAddCommMonWithMultSemigroupTerm n)
      +OL : ((OpAddCommMonWithMultSemigroupTerm n) -> ((OpAddCommMonWithMultSemigroupTerm n) -> (OpAddCommMonWithMultSemigroupTerm n)))
    data OpAddCommMonWithMultSemigroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpAddCommMonWithMultSemigroupTerm2 n A))
      sing2 : (A -> (OpAddCommMonWithMultSemigroupTerm2 n A))
      *OL2 : ((OpAddCommMonWithMultSemigroupTerm2 n A) -> ((OpAddCommMonWithMultSemigroupTerm2 n A) -> (OpAddCommMonWithMultSemigroupTerm2 n A)))
      0OL2 : (OpAddCommMonWithMultSemigroupTerm2 n A)
      +OL2 : ((OpAddCommMonWithMultSemigroupTerm2 n A) -> ((OpAddCommMonWithMultSemigroupTerm2 n A) -> (OpAddCommMonWithMultSemigroupTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClAddCommMonWithMultSemigroupTerm A) -> (ClAddCommMonWithMultSemigroupTerm A))
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 0Cl = 0Cl 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpAddCommMonWithMultSemigroupTerm n) -> (OpAddCommMonWithMultSemigroupTerm n))
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 0OL = 0OL 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpAddCommMonWithMultSemigroupTerm2 n A) -> (OpAddCommMonWithMultSemigroupTerm2 n A))
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((AddCommMonWithMultSemigroup A) -> (AddCommMonWithMultSemigroupTerm -> A))
    evalB Ad (*L x1 x2) = ((* Ad) (evalB Ad x1) (evalB Ad x2)) 
    evalB Ad 0L = (0 Ad) 
    evalB Ad (+L x1 x2) = ((+ Ad) (evalB Ad x1) (evalB Ad x2)) 
    evalCl : {A : Set} -> ((AddCommMonWithMultSemigroup A) -> ((ClAddCommMonWithMultSemigroupTerm A) -> A))
    evalCl Ad (sing x1) = x1 
    evalCl Ad (*Cl x1 x2) = ((* Ad) (evalCl Ad x1) (evalCl Ad x2)) 
    evalCl Ad 0Cl = (0 Ad) 
    evalCl Ad (+Cl x1 x2) = ((+ Ad) (evalCl Ad x1) (evalCl Ad x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((AddCommMonWithMultSemigroup A) -> ((Vec A n) -> ((OpAddCommMonWithMultSemigroupTerm n) -> A)))
    evalOpB Ad vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ad vars (*OL x1 x2) = ((* Ad) (evalOpB Ad vars x1) (evalOpB Ad vars x2)) 
    evalOpB Ad vars 0OL = (0 Ad) 
    evalOpB Ad vars (+OL x1 x2) = ((+ Ad) (evalOpB Ad vars x1) (evalOpB Ad vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((AddCommMonWithMultSemigroup A) -> ((Vec A n) -> ((OpAddCommMonWithMultSemigroupTerm2 n A) -> A)))
    evalOp Ad vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ad vars (sing2 x1) = x1 
    evalOp Ad vars (*OL2 x1 x2) = ((* Ad) (evalOp Ad vars x1) (evalOp Ad vars x2)) 
    evalOp Ad vars 0OL2 = (0 Ad) 
    evalOp Ad vars (+OL2 x1 x2) = ((+ Ad) (evalOp Ad vars x1) (evalOp Ad vars x2)) 
    inductionB : {P : (AddCommMonWithMultSemigroupTerm -> Set)} -> (((x1 x2 : AddCommMonWithMultSemigroupTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((P 0L) -> (((x1 x2 : AddCommMonWithMultSemigroupTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : AddCommMonWithMultSemigroupTerm) -> (P x)))))
    inductionB {p} p*l p0l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p0l p+l x1) (inductionB {p} p*l p0l p+l x2)) 
    inductionB {p} p*l p0l p+l 0L = p0l 
    inductionB {p} p*l p0l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p0l p+l x1) (inductionB {p} p*l p0l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClAddCommMonWithMultSemigroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClAddCommMonWithMultSemigroupTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((P 0Cl) -> (((x1 x2 : (ClAddCommMonWithMultSemigroupTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClAddCommMonWithMultSemigroupTerm A)) -> (P x))))))
    inductionCl {_} {p} psing p*cl p0cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p0cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p0cl p+cl x1) (inductionCl {_} {p} psing p*cl p0cl p+cl x2)) 
    inductionCl {_} {p} psing p*cl p0cl p+cl 0Cl = p0cl 
    inductionCl {_} {p} psing p*cl p0cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p0cl p+cl x1) (inductionCl {_} {p} psing p*cl p0cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpAddCommMonWithMultSemigroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpAddCommMonWithMultSemigroupTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((P 0OL) -> (((x1 x2 : (OpAddCommMonWithMultSemigroupTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpAddCommMonWithMultSemigroupTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv p*ol p0ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p0ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p0ol p+ol x1) (inductionOpB {_} {p} pv p*ol p0ol p+ol x2)) 
    inductionOpB {_} {p} pv p*ol p0ol p+ol 0OL = p0ol 
    inductionOpB {_} {p} pv p*ol p0ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p0ol p+ol x1) (inductionOpB {_} {p} pv p*ol p0ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpAddCommMonWithMultSemigroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpAddCommMonWithMultSemigroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((P 0OL2) -> (((x1 x2 : (OpAddCommMonWithMultSemigroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpAddCommMonWithMultSemigroupTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p0ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p0ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p0ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p0ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p0ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p0ol2 p+ol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p0ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p0ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p0ol2 p+ol2 x2)) 
    *L' : (AddCommMonWithMultSemigroupTerm -> (AddCommMonWithMultSemigroupTerm -> AddCommMonWithMultSemigroupTerm))
    *L' x1 x2 = (*L x1 x2) 
    0L' : AddCommMonWithMultSemigroupTerm
    0L'  = 0L 
    +L' : (AddCommMonWithMultSemigroupTerm -> (AddCommMonWithMultSemigroupTerm -> AddCommMonWithMultSemigroupTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (AddCommMonWithMultSemigroupTerm -> (Staged AddCommMonWithMultSemigroupTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB 0L = (Now 0L) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClAddCommMonWithMultSemigroupTerm A) -> ((ClAddCommMonWithMultSemigroupTerm A) -> (ClAddCommMonWithMultSemigroupTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    0Cl' : {A : Set} -> (ClAddCommMonWithMultSemigroupTerm A)
    0Cl'  = 0Cl 
    +Cl' : {A : Set} -> ((ClAddCommMonWithMultSemigroupTerm A) -> ((ClAddCommMonWithMultSemigroupTerm A) -> (ClAddCommMonWithMultSemigroupTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClAddCommMonWithMultSemigroupTerm A) -> (Staged (ClAddCommMonWithMultSemigroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpAddCommMonWithMultSemigroupTerm n) -> ((OpAddCommMonWithMultSemigroupTerm n) -> (OpAddCommMonWithMultSemigroupTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    0OL' : {n : Nat} -> (OpAddCommMonWithMultSemigroupTerm n)
    0OL'  = 0OL 
    +OL' : {n : Nat} -> ((OpAddCommMonWithMultSemigroupTerm n) -> ((OpAddCommMonWithMultSemigroupTerm n) -> (OpAddCommMonWithMultSemigroupTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpAddCommMonWithMultSemigroupTerm n) -> (Staged (OpAddCommMonWithMultSemigroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpAddCommMonWithMultSemigroupTerm2 n A) -> ((OpAddCommMonWithMultSemigroupTerm2 n A) -> (OpAddCommMonWithMultSemigroupTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    0OL2' : {n : Nat} {A : Set} -> (OpAddCommMonWithMultSemigroupTerm2 n A)
    0OL2'  = 0OL2 
    +OL2' : {n : Nat} {A : Set} -> ((OpAddCommMonWithMultSemigroupTerm2 n A) -> ((OpAddCommMonWithMultSemigroupTerm2 n A) -> (OpAddCommMonWithMultSemigroupTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpAddCommMonWithMultSemigroupTerm2 n A) -> (Staged (OpAddCommMonWithMultSemigroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        0T : (Repr A)
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module AddGroup_RingoidSig  where
    record AddGroup_RingoidSig (A : Set) : Set where
      constructor AddGroup_RingoidSigC
      field
        + : (A -> (A -> A))
        0 : A
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        neg : (A -> A)
        leftInverse_inv_op_0 : {x : A} -> (+ x (neg x)) == 0
        rightInverse_inv_op_0 : {x : A} -> (+ (neg x) x) == 0
        * : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        +S : (AS -> (AS -> AS))
        0S : AS
        negS : (AS -> AS)
        *S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        0P : (Prod A A)
        negP : ((Prod A A) -> (Prod A A))
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        leftInverse_inv_op_0P : {xP : (Prod A A)} -> (+P xP (negP xP)) == 0P
        rightInverse_inv_op_0P : {xP : (Prod A A)} -> (+P (negP xP) xP) == 0P
    record Hom {A1 : Set} {A2 : Set} (Ad1 : (AddGroup_RingoidSig A1)) (Ad2 : (AddGroup_RingoidSig A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ad1) x1 x2)) == ((+ Ad2) (hom x1) (hom x2))
        pres-0 : (hom (0 Ad1)) == (0 Ad2)
        pres-neg : {x1 : A1} -> (hom ((neg Ad1) x1)) == ((neg Ad2) (hom x1))
        pres-* : {x1 x2 : A1} -> (hom ((* Ad1) x1 x2)) == ((* Ad2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ad1 : (AddGroup_RingoidSig A1)) (Ad2 : (AddGroup_RingoidSig A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ad1) x1 x2) ((+ Ad2) y1 y2))))
        interp-0 : (interp (0 Ad1) (0 Ad2))
        interp-neg : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((neg Ad1) x1) ((neg Ad2) y1)))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Ad1) x1 x2) ((* Ad2) y1 y2))))
    data AddGroup_RingoidSigTerm  : Set where
      +L : (AddGroup_RingoidSigTerm -> (AddGroup_RingoidSigTerm -> AddGroup_RingoidSigTerm))
      0L : AddGroup_RingoidSigTerm
      negL : (AddGroup_RingoidSigTerm -> AddGroup_RingoidSigTerm)
      *L : (AddGroup_RingoidSigTerm -> (AddGroup_RingoidSigTerm -> AddGroup_RingoidSigTerm))
    data ClAddGroup_RingoidSigTerm (A : Set) : Set where
      sing : (A -> (ClAddGroup_RingoidSigTerm A))
      +Cl : ((ClAddGroup_RingoidSigTerm A) -> ((ClAddGroup_RingoidSigTerm A) -> (ClAddGroup_RingoidSigTerm A)))
      0Cl : (ClAddGroup_RingoidSigTerm A)
      negCl : ((ClAddGroup_RingoidSigTerm A) -> (ClAddGroup_RingoidSigTerm A))
      *Cl : ((ClAddGroup_RingoidSigTerm A) -> ((ClAddGroup_RingoidSigTerm A) -> (ClAddGroup_RingoidSigTerm A)))
    data OpAddGroup_RingoidSigTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpAddGroup_RingoidSigTerm n))
      +OL : ((OpAddGroup_RingoidSigTerm n) -> ((OpAddGroup_RingoidSigTerm n) -> (OpAddGroup_RingoidSigTerm n)))
      0OL : (OpAddGroup_RingoidSigTerm n)
      negOL : ((OpAddGroup_RingoidSigTerm n) -> (OpAddGroup_RingoidSigTerm n))
      *OL : ((OpAddGroup_RingoidSigTerm n) -> ((OpAddGroup_RingoidSigTerm n) -> (OpAddGroup_RingoidSigTerm n)))
    data OpAddGroup_RingoidSigTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpAddGroup_RingoidSigTerm2 n A))
      sing2 : (A -> (OpAddGroup_RingoidSigTerm2 n A))
      +OL2 : ((OpAddGroup_RingoidSigTerm2 n A) -> ((OpAddGroup_RingoidSigTerm2 n A) -> (OpAddGroup_RingoidSigTerm2 n A)))
      0OL2 : (OpAddGroup_RingoidSigTerm2 n A)
      negOL2 : ((OpAddGroup_RingoidSigTerm2 n A) -> (OpAddGroup_RingoidSigTerm2 n A))
      *OL2 : ((OpAddGroup_RingoidSigTerm2 n A) -> ((OpAddGroup_RingoidSigTerm2 n A) -> (OpAddGroup_RingoidSigTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClAddGroup_RingoidSigTerm A) -> (ClAddGroup_RingoidSigTerm A))
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 0Cl = 0Cl 
    simplifyCl (negCl x1) = (negCl (simplifyCl x1)) 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpAddGroup_RingoidSigTerm n) -> (OpAddGroup_RingoidSigTerm n))
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 0OL = 0OL 
    simplifyOpB (negOL x1) = (negOL (simplifyOpB x1)) 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpAddGroup_RingoidSigTerm2 n A) -> (OpAddGroup_RingoidSigTerm2 n A))
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (negOL2 x1) = (negOL2 (simplifyOp x1)) 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((AddGroup_RingoidSig A) -> (AddGroup_RingoidSigTerm -> A))
    evalB Ad (+L x1 x2) = ((+ Ad) (evalB Ad x1) (evalB Ad x2)) 
    evalB Ad 0L = (0 Ad) 
    evalB Ad (negL x1) = ((neg Ad) (evalB Ad x1)) 
    evalB Ad (*L x1 x2) = ((* Ad) (evalB Ad x1) (evalB Ad x2)) 
    evalCl : {A : Set} -> ((AddGroup_RingoidSig A) -> ((ClAddGroup_RingoidSigTerm A) -> A))
    evalCl Ad (sing x1) = x1 
    evalCl Ad (+Cl x1 x2) = ((+ Ad) (evalCl Ad x1) (evalCl Ad x2)) 
    evalCl Ad 0Cl = (0 Ad) 
    evalCl Ad (negCl x1) = ((neg Ad) (evalCl Ad x1)) 
    evalCl Ad (*Cl x1 x2) = ((* Ad) (evalCl Ad x1) (evalCl Ad x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((AddGroup_RingoidSig A) -> ((Vec A n) -> ((OpAddGroup_RingoidSigTerm n) -> A)))
    evalOpB Ad vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ad vars (+OL x1 x2) = ((+ Ad) (evalOpB Ad vars x1) (evalOpB Ad vars x2)) 
    evalOpB Ad vars 0OL = (0 Ad) 
    evalOpB Ad vars (negOL x1) = ((neg Ad) (evalOpB Ad vars x1)) 
    evalOpB Ad vars (*OL x1 x2) = ((* Ad) (evalOpB Ad vars x1) (evalOpB Ad vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((AddGroup_RingoidSig A) -> ((Vec A n) -> ((OpAddGroup_RingoidSigTerm2 n A) -> A)))
    evalOp Ad vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ad vars (sing2 x1) = x1 
    evalOp Ad vars (+OL2 x1 x2) = ((+ Ad) (evalOp Ad vars x1) (evalOp Ad vars x2)) 
    evalOp Ad vars 0OL2 = (0 Ad) 
    evalOp Ad vars (negOL2 x1) = ((neg Ad) (evalOp Ad vars x1)) 
    evalOp Ad vars (*OL2 x1 x2) = ((* Ad) (evalOp Ad vars x1) (evalOp Ad vars x2)) 
    inductionB : {P : (AddGroup_RingoidSigTerm -> Set)} -> (((x1 x2 : AddGroup_RingoidSigTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((P 0L) -> (((x1 : AddGroup_RingoidSigTerm) -> ((P x1) -> (P (negL x1)))) -> (((x1 x2 : AddGroup_RingoidSigTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((x : AddGroup_RingoidSigTerm) -> (P x))))))
    inductionB {p} p+l p0l pnegl p*l (+L x1 x2) = (p+l _ _ (inductionB {p} p+l p0l pnegl p*l x1) (inductionB {p} p+l p0l pnegl p*l x2)) 
    inductionB {p} p+l p0l pnegl p*l 0L = p0l 
    inductionB {p} p+l p0l pnegl p*l (negL x1) = (pnegl _ (inductionB {p} p+l p0l pnegl p*l x1)) 
    inductionB {p} p+l p0l pnegl p*l (*L x1 x2) = (p*l _ _ (inductionB {p} p+l p0l pnegl p*l x1) (inductionB {p} p+l p0l pnegl p*l x2)) 
    inductionCl : {A : Set} {P : ((ClAddGroup_RingoidSigTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClAddGroup_RingoidSigTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((P 0Cl) -> (((x1 : (ClAddGroup_RingoidSigTerm A)) -> ((P x1) -> (P (negCl x1)))) -> (((x1 x2 : (ClAddGroup_RingoidSigTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((x : (ClAddGroup_RingoidSigTerm A)) -> (P x)))))))
    inductionCl {_} {p} psing p+cl p0cl pnegcl p*cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p+cl p0cl pnegcl p*cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p+cl p0cl pnegcl p*cl x1) (inductionCl {_} {p} psing p+cl p0cl pnegcl p*cl x2)) 
    inductionCl {_} {p} psing p+cl p0cl pnegcl p*cl 0Cl = p0cl 
    inductionCl {_} {p} psing p+cl p0cl pnegcl p*cl (negCl x1) = (pnegcl _ (inductionCl {_} {p} psing p+cl p0cl pnegcl p*cl x1)) 
    inductionCl {_} {p} psing p+cl p0cl pnegcl p*cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p+cl p0cl pnegcl p*cl x1) (inductionCl {_} {p} psing p+cl p0cl pnegcl p*cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpAddGroup_RingoidSigTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpAddGroup_RingoidSigTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((P 0OL) -> (((x1 : (OpAddGroup_RingoidSigTerm n)) -> ((P x1) -> (P (negOL x1)))) -> (((x1 x2 : (OpAddGroup_RingoidSigTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((x : (OpAddGroup_RingoidSigTerm n)) -> (P x)))))))
    inductionOpB {_} {p} pv p+ol p0ol pnegol p*ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p+ol p0ol pnegol p*ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p+ol p0ol pnegol p*ol x1) (inductionOpB {_} {p} pv p+ol p0ol pnegol p*ol x2)) 
    inductionOpB {_} {p} pv p+ol p0ol pnegol p*ol 0OL = p0ol 
    inductionOpB {_} {p} pv p+ol p0ol pnegol p*ol (negOL x1) = (pnegol _ (inductionOpB {_} {p} pv p+ol p0ol pnegol p*ol x1)) 
    inductionOpB {_} {p} pv p+ol p0ol pnegol p*ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p+ol p0ol pnegol p*ol x1) (inductionOpB {_} {p} pv p+ol p0ol pnegol p*ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpAddGroup_RingoidSigTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpAddGroup_RingoidSigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((P 0OL2) -> (((x1 : (OpAddGroup_RingoidSigTerm2 n A)) -> ((P x1) -> (P (negOL2 x1)))) -> (((x1 x2 : (OpAddGroup_RingoidSigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((x : (OpAddGroup_RingoidSigTerm2 n A)) -> (P x))))))))
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 (negOL2 x1) = (pnegol2 _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 x2)) 
    +L' : (AddGroup_RingoidSigTerm -> (AddGroup_RingoidSigTerm -> AddGroup_RingoidSigTerm))
    +L' x1 x2 = (+L x1 x2) 
    0L' : AddGroup_RingoidSigTerm
    0L'  = 0L 
    negL' : (AddGroup_RingoidSigTerm -> AddGroup_RingoidSigTerm)
    negL' x1 = (negL x1) 
    *L' : (AddGroup_RingoidSigTerm -> (AddGroup_RingoidSigTerm -> AddGroup_RingoidSigTerm))
    *L' x1 x2 = (*L x1 x2) 
    stageB : (AddGroup_RingoidSigTerm -> (Staged AddGroup_RingoidSigTerm))
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB 0L = (Now 0L) 
    stageB (negL x1) = (stage1 negL' (codeLift1 negL') (stageB x1)) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    +Cl' : {A : Set} -> ((ClAddGroup_RingoidSigTerm A) -> ((ClAddGroup_RingoidSigTerm A) -> (ClAddGroup_RingoidSigTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    0Cl' : {A : Set} -> (ClAddGroup_RingoidSigTerm A)
    0Cl'  = 0Cl 
    negCl' : {A : Set} -> ((ClAddGroup_RingoidSigTerm A) -> (ClAddGroup_RingoidSigTerm A))
    negCl' x1 = (negCl x1) 
    *Cl' : {A : Set} -> ((ClAddGroup_RingoidSigTerm A) -> ((ClAddGroup_RingoidSigTerm A) -> (ClAddGroup_RingoidSigTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    stageCl : {A : Set} -> ((ClAddGroup_RingoidSigTerm A) -> (Staged (ClAddGroup_RingoidSigTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (negCl x1) = (stage1 negCl' (codeLift1 negCl') (stageCl x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    +OL' : {n : Nat} -> ((OpAddGroup_RingoidSigTerm n) -> ((OpAddGroup_RingoidSigTerm n) -> (OpAddGroup_RingoidSigTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    0OL' : {n : Nat} -> (OpAddGroup_RingoidSigTerm n)
    0OL'  = 0OL 
    negOL' : {n : Nat} -> ((OpAddGroup_RingoidSigTerm n) -> (OpAddGroup_RingoidSigTerm n))
    negOL' x1 = (negOL x1) 
    *OL' : {n : Nat} -> ((OpAddGroup_RingoidSigTerm n) -> ((OpAddGroup_RingoidSigTerm n) -> (OpAddGroup_RingoidSigTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpAddGroup_RingoidSigTerm n) -> (Staged (OpAddGroup_RingoidSigTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (negOL x1) = (stage1 negOL' (codeLift1 negOL') (stageOpB x1)) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    +OL2' : {n : Nat} {A : Set} -> ((OpAddGroup_RingoidSigTerm2 n A) -> ((OpAddGroup_RingoidSigTerm2 n A) -> (OpAddGroup_RingoidSigTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    0OL2' : {n : Nat} {A : Set} -> (OpAddGroup_RingoidSigTerm2 n A)
    0OL2'  = 0OL2 
    negOL2' : {n : Nat} {A : Set} -> ((OpAddGroup_RingoidSigTerm2 n A) -> (OpAddGroup_RingoidSigTerm2 n A))
    negOL2' x1 = (negOL2 x1) 
    *OL2' : {n : Nat} {A : Set} -> ((OpAddGroup_RingoidSigTerm2 n A) -> ((OpAddGroup_RingoidSigTerm2 n A) -> (OpAddGroup_RingoidSigTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpAddGroup_RingoidSigTerm2 n A) -> (Staged (OpAddGroup_RingoidSigTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (negOL2 x1) = (stage1 negOL2' (codeLift1 negOL2') (stageOp x1)) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        0T : (Repr A)
        negT : ((Repr A) -> (Repr A))
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module AdditiveCommutativeMonoid  where
    record AdditiveCommutativeMonoid (A : Set) : Set where
      constructor AdditiveCommutativeMonoidC
      field
        + : (A -> (A -> A))
        0 : A
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        +S : (AS -> (AS -> AS))
        0S : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        0P : (Prod A A)
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
    record Hom {A1 : Set} {A2 : Set} (Ad1 : (AdditiveCommutativeMonoid A1)) (Ad2 : (AdditiveCommutativeMonoid A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ad1) x1 x2)) == ((+ Ad2) (hom x1) (hom x2))
        pres-0 : (hom (0 Ad1)) == (0 Ad2)
    record RelInterp {A1 : Set} {A2 : Set} (Ad1 : (AdditiveCommutativeMonoid A1)) (Ad2 : (AdditiveCommutativeMonoid A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ad1) x1 x2) ((+ Ad2) y1 y2))))
        interp-0 : (interp (0 Ad1) (0 Ad2))
    data AdditiveCommutativeMonoidTerm  : Set where
      +L : (AdditiveCommutativeMonoidTerm -> (AdditiveCommutativeMonoidTerm -> AdditiveCommutativeMonoidTerm))
      0L : AdditiveCommutativeMonoidTerm
    data ClAdditiveCommutativeMonoidTerm (A : Set) : Set where
      sing : (A -> (ClAdditiveCommutativeMonoidTerm A))
      +Cl : ((ClAdditiveCommutativeMonoidTerm A) -> ((ClAdditiveCommutativeMonoidTerm A) -> (ClAdditiveCommutativeMonoidTerm A)))
      0Cl : (ClAdditiveCommutativeMonoidTerm A)
    data OpAdditiveCommutativeMonoidTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpAdditiveCommutativeMonoidTerm n))
      +OL : ((OpAdditiveCommutativeMonoidTerm n) -> ((OpAdditiveCommutativeMonoidTerm n) -> (OpAdditiveCommutativeMonoidTerm n)))
      0OL : (OpAdditiveCommutativeMonoidTerm n)
    data OpAdditiveCommutativeMonoidTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpAdditiveCommutativeMonoidTerm2 n A))
      sing2 : (A -> (OpAdditiveCommutativeMonoidTerm2 n A))
      +OL2 : ((OpAdditiveCommutativeMonoidTerm2 n A) -> ((OpAdditiveCommutativeMonoidTerm2 n A) -> (OpAdditiveCommutativeMonoidTerm2 n A)))
      0OL2 : (OpAdditiveCommutativeMonoidTerm2 n A)
    simplifyCl : {A : Set} -> ((ClAdditiveCommutativeMonoidTerm A) -> (ClAdditiveCommutativeMonoidTerm A))
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 0Cl = 0Cl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpAdditiveCommutativeMonoidTerm n) -> (OpAdditiveCommutativeMonoidTerm n))
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 0OL = 0OL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpAdditiveCommutativeMonoidTerm2 n A) -> (OpAdditiveCommutativeMonoidTerm2 n A))
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((AdditiveCommutativeMonoid A) -> (AdditiveCommutativeMonoidTerm -> A))
    evalB Ad (+L x1 x2) = ((+ Ad) (evalB Ad x1) (evalB Ad x2)) 
    evalB Ad 0L = (0 Ad) 
    evalCl : {A : Set} -> ((AdditiveCommutativeMonoid A) -> ((ClAdditiveCommutativeMonoidTerm A) -> A))
    evalCl Ad (sing x1) = x1 
    evalCl Ad (+Cl x1 x2) = ((+ Ad) (evalCl Ad x1) (evalCl Ad x2)) 
    evalCl Ad 0Cl = (0 Ad) 
    evalOpB : {A : Set} {n : Nat} -> ((AdditiveCommutativeMonoid A) -> ((Vec A n) -> ((OpAdditiveCommutativeMonoidTerm n) -> A)))
    evalOpB Ad vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ad vars (+OL x1 x2) = ((+ Ad) (evalOpB Ad vars x1) (evalOpB Ad vars x2)) 
    evalOpB Ad vars 0OL = (0 Ad) 
    evalOp : {A : Set} {n : Nat} -> ((AdditiveCommutativeMonoid A) -> ((Vec A n) -> ((OpAdditiveCommutativeMonoidTerm2 n A) -> A)))
    evalOp Ad vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ad vars (sing2 x1) = x1 
    evalOp Ad vars (+OL2 x1 x2) = ((+ Ad) (evalOp Ad vars x1) (evalOp Ad vars x2)) 
    evalOp Ad vars 0OL2 = (0 Ad) 
    inductionB : {P : (AdditiveCommutativeMonoidTerm -> Set)} -> (((x1 x2 : AdditiveCommutativeMonoidTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((P 0L) -> ((x : AdditiveCommutativeMonoidTerm) -> (P x))))
    inductionB {p} p+l p0l (+L x1 x2) = (p+l _ _ (inductionB {p} p+l p0l x1) (inductionB {p} p+l p0l x2)) 
    inductionB {p} p+l p0l 0L = p0l 
    inductionCl : {A : Set} {P : ((ClAdditiveCommutativeMonoidTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClAdditiveCommutativeMonoidTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((P 0Cl) -> ((x : (ClAdditiveCommutativeMonoidTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p+cl p0cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p+cl p0cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p+cl p0cl x1) (inductionCl {_} {p} psing p+cl p0cl x2)) 
    inductionCl {_} {p} psing p+cl p0cl 0Cl = p0cl 
    inductionOpB : {n : Nat} {P : ((OpAdditiveCommutativeMonoidTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpAdditiveCommutativeMonoidTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((P 0OL) -> ((x : (OpAdditiveCommutativeMonoidTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p+ol p0ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p+ol p0ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p+ol p0ol x1) (inductionOpB {_} {p} pv p+ol p0ol x2)) 
    inductionOpB {_} {p} pv p+ol p0ol 0OL = p0ol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpAdditiveCommutativeMonoidTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpAdditiveCommutativeMonoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((P 0OL2) -> ((x : (OpAdditiveCommutativeMonoidTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 0OL2 = p0ol2 
    +L' : (AdditiveCommutativeMonoidTerm -> (AdditiveCommutativeMonoidTerm -> AdditiveCommutativeMonoidTerm))
    +L' x1 x2 = (+L x1 x2) 
    0L' : AdditiveCommutativeMonoidTerm
    0L'  = 0L 
    stageB : (AdditiveCommutativeMonoidTerm -> (Staged AdditiveCommutativeMonoidTerm))
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB 0L = (Now 0L) 
    +Cl' : {A : Set} -> ((ClAdditiveCommutativeMonoidTerm A) -> ((ClAdditiveCommutativeMonoidTerm A) -> (ClAdditiveCommutativeMonoidTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    0Cl' : {A : Set} -> (ClAdditiveCommutativeMonoidTerm A)
    0Cl'  = 0Cl 
    stageCl : {A : Set} -> ((ClAdditiveCommutativeMonoidTerm A) -> (Staged (ClAdditiveCommutativeMonoidTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl 0Cl = (Now 0Cl) 
    +OL' : {n : Nat} -> ((OpAdditiveCommutativeMonoidTerm n) -> ((OpAdditiveCommutativeMonoidTerm n) -> (OpAdditiveCommutativeMonoidTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    0OL' : {n : Nat} -> (OpAdditiveCommutativeMonoidTerm n)
    0OL'  = 0OL 
    stageOpB : {n : Nat} -> ((OpAdditiveCommutativeMonoidTerm n) -> (Staged (OpAdditiveCommutativeMonoidTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 0OL = (Now 0OL) 
    +OL2' : {n : Nat} {A : Set} -> ((OpAdditiveCommutativeMonoidTerm2 n A) -> ((OpAdditiveCommutativeMonoidTerm2 n A) -> (OpAdditiveCommutativeMonoidTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    0OL2' : {n : Nat} {A : Set} -> (OpAdditiveCommutativeMonoidTerm2 n A)
    0OL2'  = 0OL2 
    stageOp : {n : Nat} {A : Set} -> ((OpAdditiveCommutativeMonoidTerm2 n A) -> (Staged (OpAdditiveCommutativeMonoidTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp 0OL2 = (Now 0OL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        0T : (Repr A)
  module AdditiveCommutativeSemigroup  where
    record AdditiveCommutativeSemigroup (A : Set) : Set where
      constructor AdditiveCommutativeSemigroupC
      field
        + : (A -> (A -> A))
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
    record Hom {A1 : Set} {A2 : Set} (Ad1 : (AdditiveCommutativeSemigroup A1)) (Ad2 : (AdditiveCommutativeSemigroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ad1) x1 x2)) == ((+ Ad2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ad1 : (AdditiveCommutativeSemigroup A1)) (Ad2 : (AdditiveCommutativeSemigroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ad1) x1 x2) ((+ Ad2) y1 y2))))
    data AdditiveCommutativeSemigroupTerm  : Set where
      +L : (AdditiveCommutativeSemigroupTerm -> (AdditiveCommutativeSemigroupTerm -> AdditiveCommutativeSemigroupTerm))
    data ClAdditiveCommutativeSemigroupTerm (A : Set) : Set where
      sing : (A -> (ClAdditiveCommutativeSemigroupTerm A))
      +Cl : ((ClAdditiveCommutativeSemigroupTerm A) -> ((ClAdditiveCommutativeSemigroupTerm A) -> (ClAdditiveCommutativeSemigroupTerm A)))
    data OpAdditiveCommutativeSemigroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpAdditiveCommutativeSemigroupTerm n))
      +OL : ((OpAdditiveCommutativeSemigroupTerm n) -> ((OpAdditiveCommutativeSemigroupTerm n) -> (OpAdditiveCommutativeSemigroupTerm n)))
    data OpAdditiveCommutativeSemigroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpAdditiveCommutativeSemigroupTerm2 n A))
      sing2 : (A -> (OpAdditiveCommutativeSemigroupTerm2 n A))
      +OL2 : ((OpAdditiveCommutativeSemigroupTerm2 n A) -> ((OpAdditiveCommutativeSemigroupTerm2 n A) -> (OpAdditiveCommutativeSemigroupTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClAdditiveCommutativeSemigroupTerm A) -> (ClAdditiveCommutativeSemigroupTerm A))
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpAdditiveCommutativeSemigroupTerm n) -> (OpAdditiveCommutativeSemigroupTerm n))
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpAdditiveCommutativeSemigroupTerm2 n A) -> (OpAdditiveCommutativeSemigroupTerm2 n A))
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((AdditiveCommutativeSemigroup A) -> (AdditiveCommutativeSemigroupTerm -> A))
    evalB Ad (+L x1 x2) = ((+ Ad) (evalB Ad x1) (evalB Ad x2)) 
    evalCl : {A : Set} -> ((AdditiveCommutativeSemigroup A) -> ((ClAdditiveCommutativeSemigroupTerm A) -> A))
    evalCl Ad (sing x1) = x1 
    evalCl Ad (+Cl x1 x2) = ((+ Ad) (evalCl Ad x1) (evalCl Ad x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((AdditiveCommutativeSemigroup A) -> ((Vec A n) -> ((OpAdditiveCommutativeSemigroupTerm n) -> A)))
    evalOpB Ad vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ad vars (+OL x1 x2) = ((+ Ad) (evalOpB Ad vars x1) (evalOpB Ad vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((AdditiveCommutativeSemigroup A) -> ((Vec A n) -> ((OpAdditiveCommutativeSemigroupTerm2 n A) -> A)))
    evalOp Ad vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ad vars (sing2 x1) = x1 
    evalOp Ad vars (+OL2 x1 x2) = ((+ Ad) (evalOp Ad vars x1) (evalOp Ad vars x2)) 
    inductionB : {P : (AdditiveCommutativeSemigroupTerm -> Set)} -> (((x1 x2 : AdditiveCommutativeSemigroupTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : AdditiveCommutativeSemigroupTerm) -> (P x)))
    inductionB {p} p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p+l x1) (inductionB {p} p+l x2)) 
    inductionCl : {A : Set} {P : ((ClAdditiveCommutativeSemigroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClAdditiveCommutativeSemigroupTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClAdditiveCommutativeSemigroupTerm A)) -> (P x))))
    inductionCl {_} {p} psing p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p+cl x1) (inductionCl {_} {p} psing p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpAdditiveCommutativeSemigroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpAdditiveCommutativeSemigroupTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpAdditiveCommutativeSemigroupTerm n)) -> (P x))))
    inductionOpB {_} {p} pv p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p+ol x1) (inductionOpB {_} {p} pv p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpAdditiveCommutativeSemigroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpAdditiveCommutativeSemigroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpAdditiveCommutativeSemigroupTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 x2)) 
    +L' : (AdditiveCommutativeSemigroupTerm -> (AdditiveCommutativeSemigroupTerm -> AdditiveCommutativeSemigroupTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (AdditiveCommutativeSemigroupTerm -> (Staged AdditiveCommutativeSemigroupTerm))
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    +Cl' : {A : Set} -> ((ClAdditiveCommutativeSemigroupTerm A) -> ((ClAdditiveCommutativeSemigroupTerm A) -> (ClAdditiveCommutativeSemigroupTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClAdditiveCommutativeSemigroupTerm A) -> (Staged (ClAdditiveCommutativeSemigroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    +OL' : {n : Nat} -> ((OpAdditiveCommutativeSemigroupTerm n) -> ((OpAdditiveCommutativeSemigroupTerm n) -> (OpAdditiveCommutativeSemigroupTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpAdditiveCommutativeSemigroupTerm n) -> (Staged (OpAdditiveCommutativeSemigroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    +OL2' : {n : Nat} {A : Set} -> ((OpAdditiveCommutativeSemigroupTerm2 n A) -> ((OpAdditiveCommutativeSemigroupTerm2 n A) -> (OpAdditiveCommutativeSemigroupTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpAdditiveCommutativeSemigroupTerm2 n A) -> (Staged (OpAdditiveCommutativeSemigroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module AdditiveGroup  where
    record AdditiveGroup (A : Set) : Set where
      constructor AdditiveGroupC
      field
        + : (A -> (A -> A))
        0 : A
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        neg : (A -> A)
        leftInverse_inv_op_0 : {x : A} -> (+ x (neg x)) == 0
        rightInverse_inv_op_0 : {x : A} -> (+ (neg x) x) == 0
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        +S : (AS -> (AS -> AS))
        0S : AS
        negS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        0P : (Prod A A)
        negP : ((Prod A A) -> (Prod A A))
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        leftInverse_inv_op_0P : {xP : (Prod A A)} -> (+P xP (negP xP)) == 0P
        rightInverse_inv_op_0P : {xP : (Prod A A)} -> (+P (negP xP) xP) == 0P
    record Hom {A1 : Set} {A2 : Set} (Ad1 : (AdditiveGroup A1)) (Ad2 : (AdditiveGroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ad1) x1 x2)) == ((+ Ad2) (hom x1) (hom x2))
        pres-0 : (hom (0 Ad1)) == (0 Ad2)
        pres-neg : {x1 : A1} -> (hom ((neg Ad1) x1)) == ((neg Ad2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (Ad1 : (AdditiveGroup A1)) (Ad2 : (AdditiveGroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ad1) x1 x2) ((+ Ad2) y1 y2))))
        interp-0 : (interp (0 Ad1) (0 Ad2))
        interp-neg : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((neg Ad1) x1) ((neg Ad2) y1)))
    data AdditiveGroupTerm  : Set where
      +L : (AdditiveGroupTerm -> (AdditiveGroupTerm -> AdditiveGroupTerm))
      0L : AdditiveGroupTerm
      negL : (AdditiveGroupTerm -> AdditiveGroupTerm)
    data ClAdditiveGroupTerm (A : Set) : Set where
      sing : (A -> (ClAdditiveGroupTerm A))
      +Cl : ((ClAdditiveGroupTerm A) -> ((ClAdditiveGroupTerm A) -> (ClAdditiveGroupTerm A)))
      0Cl : (ClAdditiveGroupTerm A)
      negCl : ((ClAdditiveGroupTerm A) -> (ClAdditiveGroupTerm A))
    data OpAdditiveGroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpAdditiveGroupTerm n))
      +OL : ((OpAdditiveGroupTerm n) -> ((OpAdditiveGroupTerm n) -> (OpAdditiveGroupTerm n)))
      0OL : (OpAdditiveGroupTerm n)
      negOL : ((OpAdditiveGroupTerm n) -> (OpAdditiveGroupTerm n))
    data OpAdditiveGroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpAdditiveGroupTerm2 n A))
      sing2 : (A -> (OpAdditiveGroupTerm2 n A))
      +OL2 : ((OpAdditiveGroupTerm2 n A) -> ((OpAdditiveGroupTerm2 n A) -> (OpAdditiveGroupTerm2 n A)))
      0OL2 : (OpAdditiveGroupTerm2 n A)
      negOL2 : ((OpAdditiveGroupTerm2 n A) -> (OpAdditiveGroupTerm2 n A))
    simplifyCl : {A : Set} -> ((ClAdditiveGroupTerm A) -> (ClAdditiveGroupTerm A))
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 0Cl = 0Cl 
    simplifyCl (negCl x1) = (negCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpAdditiveGroupTerm n) -> (OpAdditiveGroupTerm n))
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 0OL = 0OL 
    simplifyOpB (negOL x1) = (negOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpAdditiveGroupTerm2 n A) -> (OpAdditiveGroupTerm2 n A))
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (negOL2 x1) = (negOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((AdditiveGroup A) -> (AdditiveGroupTerm -> A))
    evalB Ad (+L x1 x2) = ((+ Ad) (evalB Ad x1) (evalB Ad x2)) 
    evalB Ad 0L = (0 Ad) 
    evalB Ad (negL x1) = ((neg Ad) (evalB Ad x1)) 
    evalCl : {A : Set} -> ((AdditiveGroup A) -> ((ClAdditiveGroupTerm A) -> A))
    evalCl Ad (sing x1) = x1 
    evalCl Ad (+Cl x1 x2) = ((+ Ad) (evalCl Ad x1) (evalCl Ad x2)) 
    evalCl Ad 0Cl = (0 Ad) 
    evalCl Ad (negCl x1) = ((neg Ad) (evalCl Ad x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((AdditiveGroup A) -> ((Vec A n) -> ((OpAdditiveGroupTerm n) -> A)))
    evalOpB Ad vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ad vars (+OL x1 x2) = ((+ Ad) (evalOpB Ad vars x1) (evalOpB Ad vars x2)) 
    evalOpB Ad vars 0OL = (0 Ad) 
    evalOpB Ad vars (negOL x1) = ((neg Ad) (evalOpB Ad vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((AdditiveGroup A) -> ((Vec A n) -> ((OpAdditiveGroupTerm2 n A) -> A)))
    evalOp Ad vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ad vars (sing2 x1) = x1 
    evalOp Ad vars (+OL2 x1 x2) = ((+ Ad) (evalOp Ad vars x1) (evalOp Ad vars x2)) 
    evalOp Ad vars 0OL2 = (0 Ad) 
    evalOp Ad vars (negOL2 x1) = ((neg Ad) (evalOp Ad vars x1)) 
    inductionB : {P : (AdditiveGroupTerm -> Set)} -> (((x1 x2 : AdditiveGroupTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((P 0L) -> (((x1 : AdditiveGroupTerm) -> ((P x1) -> (P (negL x1)))) -> ((x : AdditiveGroupTerm) -> (P x)))))
    inductionB {p} p+l p0l pnegl (+L x1 x2) = (p+l _ _ (inductionB {p} p+l p0l pnegl x1) (inductionB {p} p+l p0l pnegl x2)) 
    inductionB {p} p+l p0l pnegl 0L = p0l 
    inductionB {p} p+l p0l pnegl (negL x1) = (pnegl _ (inductionB {p} p+l p0l pnegl x1)) 
    inductionCl : {A : Set} {P : ((ClAdditiveGroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClAdditiveGroupTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((P 0Cl) -> (((x1 : (ClAdditiveGroupTerm A)) -> ((P x1) -> (P (negCl x1)))) -> ((x : (ClAdditiveGroupTerm A)) -> (P x))))))
    inductionCl {_} {p} psing p+cl p0cl pnegcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p+cl p0cl pnegcl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p+cl p0cl pnegcl x1) (inductionCl {_} {p} psing p+cl p0cl pnegcl x2)) 
    inductionCl {_} {p} psing p+cl p0cl pnegcl 0Cl = p0cl 
    inductionCl {_} {p} psing p+cl p0cl pnegcl (negCl x1) = (pnegcl _ (inductionCl {_} {p} psing p+cl p0cl pnegcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpAdditiveGroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpAdditiveGroupTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((P 0OL) -> (((x1 : (OpAdditiveGroupTerm n)) -> ((P x1) -> (P (negOL x1)))) -> ((x : (OpAdditiveGroupTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv p+ol p0ol pnegol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p+ol p0ol pnegol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p+ol p0ol pnegol x1) (inductionOpB {_} {p} pv p+ol p0ol pnegol x2)) 
    inductionOpB {_} {p} pv p+ol p0ol pnegol 0OL = p0ol 
    inductionOpB {_} {p} pv p+ol p0ol pnegol (negOL x1) = (pnegol _ (inductionOpB {_} {p} pv p+ol p0ol pnegol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpAdditiveGroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpAdditiveGroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((P 0OL2) -> (((x1 : (OpAdditiveGroupTerm2 n A)) -> ((P x1) -> (P (negOL2 x1)))) -> ((x : (OpAdditiveGroupTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 (negOL2 x1) = (pnegol2 _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 x1)) 
    +L' : (AdditiveGroupTerm -> (AdditiveGroupTerm -> AdditiveGroupTerm))
    +L' x1 x2 = (+L x1 x2) 
    0L' : AdditiveGroupTerm
    0L'  = 0L 
    negL' : (AdditiveGroupTerm -> AdditiveGroupTerm)
    negL' x1 = (negL x1) 
    stageB : (AdditiveGroupTerm -> (Staged AdditiveGroupTerm))
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB 0L = (Now 0L) 
    stageB (negL x1) = (stage1 negL' (codeLift1 negL') (stageB x1)) 
    +Cl' : {A : Set} -> ((ClAdditiveGroupTerm A) -> ((ClAdditiveGroupTerm A) -> (ClAdditiveGroupTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    0Cl' : {A : Set} -> (ClAdditiveGroupTerm A)
    0Cl'  = 0Cl 
    negCl' : {A : Set} -> ((ClAdditiveGroupTerm A) -> (ClAdditiveGroupTerm A))
    negCl' x1 = (negCl x1) 
    stageCl : {A : Set} -> ((ClAdditiveGroupTerm A) -> (Staged (ClAdditiveGroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (negCl x1) = (stage1 negCl' (codeLift1 negCl') (stageCl x1)) 
    +OL' : {n : Nat} -> ((OpAdditiveGroupTerm n) -> ((OpAdditiveGroupTerm n) -> (OpAdditiveGroupTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    0OL' : {n : Nat} -> (OpAdditiveGroupTerm n)
    0OL'  = 0OL 
    negOL' : {n : Nat} -> ((OpAdditiveGroupTerm n) -> (OpAdditiveGroupTerm n))
    negOL' x1 = (negOL x1) 
    stageOpB : {n : Nat} -> ((OpAdditiveGroupTerm n) -> (Staged (OpAdditiveGroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (negOL x1) = (stage1 negOL' (codeLift1 negOL') (stageOpB x1)) 
    +OL2' : {n : Nat} {A : Set} -> ((OpAdditiveGroupTerm2 n A) -> ((OpAdditiveGroupTerm2 n A) -> (OpAdditiveGroupTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    0OL2' : {n : Nat} {A : Set} -> (OpAdditiveGroupTerm2 n A)
    0OL2'  = 0OL2 
    negOL2' : {n : Nat} {A : Set} -> ((OpAdditiveGroupTerm2 n A) -> (OpAdditiveGroupTerm2 n A))
    negOL2' x1 = (negOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpAdditiveGroupTerm2 n A) -> (Staged (OpAdditiveGroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (negOL2 x1) = (stage1 negOL2' (codeLift1 negOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        0T : (Repr A)
        negT : ((Repr A) -> (Repr A))
  module AdditiveMagma  where
    record AdditiveMagma (A : Set) : Set where
      constructor AdditiveMagmaC
      field
        + : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
    record Hom {A1 : Set} {A2 : Set} (Ad1 : (AdditiveMagma A1)) (Ad2 : (AdditiveMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ad1) x1 x2)) == ((+ Ad2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ad1 : (AdditiveMagma A1)) (Ad2 : (AdditiveMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ad1) x1 x2) ((+ Ad2) y1 y2))))
    data AdditiveMagmaTerm  : Set where
      +L : (AdditiveMagmaTerm -> (AdditiveMagmaTerm -> AdditiveMagmaTerm))
    data ClAdditiveMagmaTerm (A : Set) : Set where
      sing : (A -> (ClAdditiveMagmaTerm A))
      +Cl : ((ClAdditiveMagmaTerm A) -> ((ClAdditiveMagmaTerm A) -> (ClAdditiveMagmaTerm A)))
    data OpAdditiveMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpAdditiveMagmaTerm n))
      +OL : ((OpAdditiveMagmaTerm n) -> ((OpAdditiveMagmaTerm n) -> (OpAdditiveMagmaTerm n)))
    data OpAdditiveMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpAdditiveMagmaTerm2 n A))
      sing2 : (A -> (OpAdditiveMagmaTerm2 n A))
      +OL2 : ((OpAdditiveMagmaTerm2 n A) -> ((OpAdditiveMagmaTerm2 n A) -> (OpAdditiveMagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClAdditiveMagmaTerm A) -> (ClAdditiveMagmaTerm A))
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpAdditiveMagmaTerm n) -> (OpAdditiveMagmaTerm n))
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpAdditiveMagmaTerm2 n A) -> (OpAdditiveMagmaTerm2 n A))
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((AdditiveMagma A) -> (AdditiveMagmaTerm -> A))
    evalB Ad (+L x1 x2) = ((+ Ad) (evalB Ad x1) (evalB Ad x2)) 
    evalCl : {A : Set} -> ((AdditiveMagma A) -> ((ClAdditiveMagmaTerm A) -> A))
    evalCl Ad (sing x1) = x1 
    evalCl Ad (+Cl x1 x2) = ((+ Ad) (evalCl Ad x1) (evalCl Ad x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((AdditiveMagma A) -> ((Vec A n) -> ((OpAdditiveMagmaTerm n) -> A)))
    evalOpB Ad vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ad vars (+OL x1 x2) = ((+ Ad) (evalOpB Ad vars x1) (evalOpB Ad vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((AdditiveMagma A) -> ((Vec A n) -> ((OpAdditiveMagmaTerm2 n A) -> A)))
    evalOp Ad vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ad vars (sing2 x1) = x1 
    evalOp Ad vars (+OL2 x1 x2) = ((+ Ad) (evalOp Ad vars x1) (evalOp Ad vars x2)) 
    inductionB : {P : (AdditiveMagmaTerm -> Set)} -> (((x1 x2 : AdditiveMagmaTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : AdditiveMagmaTerm) -> (P x)))
    inductionB {p} p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p+l x1) (inductionB {p} p+l x2)) 
    inductionCl : {A : Set} {P : ((ClAdditiveMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClAdditiveMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClAdditiveMagmaTerm A)) -> (P x))))
    inductionCl {_} {p} psing p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p+cl x1) (inductionCl {_} {p} psing p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpAdditiveMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpAdditiveMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpAdditiveMagmaTerm n)) -> (P x))))
    inductionOpB {_} {p} pv p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p+ol x1) (inductionOpB {_} {p} pv p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpAdditiveMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpAdditiveMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpAdditiveMagmaTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 x2)) 
    +L' : (AdditiveMagmaTerm -> (AdditiveMagmaTerm -> AdditiveMagmaTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (AdditiveMagmaTerm -> (Staged AdditiveMagmaTerm))
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    +Cl' : {A : Set} -> ((ClAdditiveMagmaTerm A) -> ((ClAdditiveMagmaTerm A) -> (ClAdditiveMagmaTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClAdditiveMagmaTerm A) -> (Staged (ClAdditiveMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    +OL' : {n : Nat} -> ((OpAdditiveMagmaTerm n) -> ((OpAdditiveMagmaTerm n) -> (OpAdditiveMagmaTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpAdditiveMagmaTerm n) -> (Staged (OpAdditiveMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    +OL2' : {n : Nat} {A : Set} -> ((OpAdditiveMagmaTerm2 n A) -> ((OpAdditiveMagmaTerm2 n A) -> (OpAdditiveMagmaTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpAdditiveMagmaTerm2 n A) -> (Staged (OpAdditiveMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module AdditiveMonoid  where
    record AdditiveMonoid (A : Set) : Set where
      constructor AdditiveMonoidC
      field
        0 : A
        + : (A -> (A -> A))
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        0S : AS
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        0P : (Prod A A)
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
    record Hom {A1 : Set} {A2 : Set} (Ad1 : (AdditiveMonoid A1)) (Ad2 : (AdditiveMonoid A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-0 : (hom (0 Ad1)) == (0 Ad2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ad1) x1 x2)) == ((+ Ad2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ad1 : (AdditiveMonoid A1)) (Ad2 : (AdditiveMonoid A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-0 : (interp (0 Ad1) (0 Ad2))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ad1) x1 x2) ((+ Ad2) y1 y2))))
    data AdditiveMonoidTerm  : Set where
      0L : AdditiveMonoidTerm
      +L : (AdditiveMonoidTerm -> (AdditiveMonoidTerm -> AdditiveMonoidTerm))
    data ClAdditiveMonoidTerm (A : Set) : Set where
      sing : (A -> (ClAdditiveMonoidTerm A))
      0Cl : (ClAdditiveMonoidTerm A)
      +Cl : ((ClAdditiveMonoidTerm A) -> ((ClAdditiveMonoidTerm A) -> (ClAdditiveMonoidTerm A)))
    data OpAdditiveMonoidTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpAdditiveMonoidTerm n))
      0OL : (OpAdditiveMonoidTerm n)
      +OL : ((OpAdditiveMonoidTerm n) -> ((OpAdditiveMonoidTerm n) -> (OpAdditiveMonoidTerm n)))
    data OpAdditiveMonoidTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpAdditiveMonoidTerm2 n A))
      sing2 : (A -> (OpAdditiveMonoidTerm2 n A))
      0OL2 : (OpAdditiveMonoidTerm2 n A)
      +OL2 : ((OpAdditiveMonoidTerm2 n A) -> ((OpAdditiveMonoidTerm2 n A) -> (OpAdditiveMonoidTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClAdditiveMonoidTerm A) -> (ClAdditiveMonoidTerm A))
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl 0Cl = 0Cl 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpAdditiveMonoidTerm n) -> (OpAdditiveMonoidTerm n))
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB 0OL = 0OL 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpAdditiveMonoidTerm2 n A) -> (OpAdditiveMonoidTerm2 n A))
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((AdditiveMonoid A) -> (AdditiveMonoidTerm -> A))
    evalB Ad 0L = (0 Ad) 
    evalB Ad (+L x1 x2) = ((+ Ad) (evalB Ad x1) (evalB Ad x2)) 
    evalCl : {A : Set} -> ((AdditiveMonoid A) -> ((ClAdditiveMonoidTerm A) -> A))
    evalCl Ad (sing x1) = x1 
    evalCl Ad 0Cl = (0 Ad) 
    evalCl Ad (+Cl x1 x2) = ((+ Ad) (evalCl Ad x1) (evalCl Ad x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((AdditiveMonoid A) -> ((Vec A n) -> ((OpAdditiveMonoidTerm n) -> A)))
    evalOpB Ad vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ad vars 0OL = (0 Ad) 
    evalOpB Ad vars (+OL x1 x2) = ((+ Ad) (evalOpB Ad vars x1) (evalOpB Ad vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((AdditiveMonoid A) -> ((Vec A n) -> ((OpAdditiveMonoidTerm2 n A) -> A)))
    evalOp Ad vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ad vars (sing2 x1) = x1 
    evalOp Ad vars 0OL2 = (0 Ad) 
    evalOp Ad vars (+OL2 x1 x2) = ((+ Ad) (evalOp Ad vars x1) (evalOp Ad vars x2)) 
    inductionB : {P : (AdditiveMonoidTerm -> Set)} -> ((P 0L) -> (((x1 x2 : AdditiveMonoidTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : AdditiveMonoidTerm) -> (P x))))
    inductionB {p} p0l p+l 0L = p0l 
    inductionB {p} p0l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p0l p+l x1) (inductionB {p} p0l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClAdditiveMonoidTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 0Cl) -> (((x1 x2 : (ClAdditiveMonoidTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClAdditiveMonoidTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p0cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p0cl p+cl 0Cl = p0cl 
    inductionCl {_} {p} psing p0cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p0cl p+cl x1) (inductionCl {_} {p} psing p0cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpAdditiveMonoidTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 0OL) -> (((x1 x2 : (OpAdditiveMonoidTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpAdditiveMonoidTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p0ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p0ol p+ol 0OL = p0ol 
    inductionOpB {_} {p} pv p0ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p0ol p+ol x1) (inductionOpB {_} {p} pv p0ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpAdditiveMonoidTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 0OL2) -> (((x1 x2 : (OpAdditiveMonoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpAdditiveMonoidTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 x2)) 
    0L' : AdditiveMonoidTerm
    0L'  = 0L 
    +L' : (AdditiveMonoidTerm -> (AdditiveMonoidTerm -> AdditiveMonoidTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (AdditiveMonoidTerm -> (Staged AdditiveMonoidTerm))
    stageB 0L = (Now 0L) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    0Cl' : {A : Set} -> (ClAdditiveMonoidTerm A)
    0Cl'  = 0Cl 
    +Cl' : {A : Set} -> ((ClAdditiveMonoidTerm A) -> ((ClAdditiveMonoidTerm A) -> (ClAdditiveMonoidTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClAdditiveMonoidTerm A) -> (Staged (ClAdditiveMonoidTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    0OL' : {n : Nat} -> (OpAdditiveMonoidTerm n)
    0OL'  = 0OL 
    +OL' : {n : Nat} -> ((OpAdditiveMonoidTerm n) -> ((OpAdditiveMonoidTerm n) -> (OpAdditiveMonoidTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpAdditiveMonoidTerm n) -> (Staged (OpAdditiveMonoidTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    0OL2' : {n : Nat} {A : Set} -> (OpAdditiveMonoidTerm2 n A)
    0OL2'  = 0OL2 
    +OL2' : {n : Nat} {A : Set} -> ((OpAdditiveMonoidTerm2 n A) -> ((OpAdditiveMonoidTerm2 n A) -> (OpAdditiveMonoidTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpAdditiveMonoidTerm2 n A) -> (Staged (OpAdditiveMonoidTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        0T : (Repr A)
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module AdditivePointedMagma  where
    record AdditivePointedMagma (A : Set) : Set where
      constructor AdditivePointedMagmaC
      field
        0 : A
        + : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        0S : AS
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        0P : (Prod A A)
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
    record Hom {A1 : Set} {A2 : Set} (Ad1 : (AdditivePointedMagma A1)) (Ad2 : (AdditivePointedMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-0 : (hom (0 Ad1)) == (0 Ad2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ad1) x1 x2)) == ((+ Ad2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ad1 : (AdditivePointedMagma A1)) (Ad2 : (AdditivePointedMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-0 : (interp (0 Ad1) (0 Ad2))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ad1) x1 x2) ((+ Ad2) y1 y2))))
    data AdditivePointedMagmaTerm  : Set where
      0L : AdditivePointedMagmaTerm
      +L : (AdditivePointedMagmaTerm -> (AdditivePointedMagmaTerm -> AdditivePointedMagmaTerm))
    data ClAdditivePointedMagmaTerm (A : Set) : Set where
      sing : (A -> (ClAdditivePointedMagmaTerm A))
      0Cl : (ClAdditivePointedMagmaTerm A)
      +Cl : ((ClAdditivePointedMagmaTerm A) -> ((ClAdditivePointedMagmaTerm A) -> (ClAdditivePointedMagmaTerm A)))
    data OpAdditivePointedMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpAdditivePointedMagmaTerm n))
      0OL : (OpAdditivePointedMagmaTerm n)
      +OL : ((OpAdditivePointedMagmaTerm n) -> ((OpAdditivePointedMagmaTerm n) -> (OpAdditivePointedMagmaTerm n)))
    data OpAdditivePointedMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpAdditivePointedMagmaTerm2 n A))
      sing2 : (A -> (OpAdditivePointedMagmaTerm2 n A))
      0OL2 : (OpAdditivePointedMagmaTerm2 n A)
      +OL2 : ((OpAdditivePointedMagmaTerm2 n A) -> ((OpAdditivePointedMagmaTerm2 n A) -> (OpAdditivePointedMagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClAdditivePointedMagmaTerm A) -> (ClAdditivePointedMagmaTerm A))
    simplifyCl 0Cl = 0Cl 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpAdditivePointedMagmaTerm n) -> (OpAdditivePointedMagmaTerm n))
    simplifyOpB 0OL = 0OL 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpAdditivePointedMagmaTerm2 n A) -> (OpAdditivePointedMagmaTerm2 n A))
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((AdditivePointedMagma A) -> (AdditivePointedMagmaTerm -> A))
    evalB Ad 0L = (0 Ad) 
    evalB Ad (+L x1 x2) = ((+ Ad) (evalB Ad x1) (evalB Ad x2)) 
    evalCl : {A : Set} -> ((AdditivePointedMagma A) -> ((ClAdditivePointedMagmaTerm A) -> A))
    evalCl Ad (sing x1) = x1 
    evalCl Ad 0Cl = (0 Ad) 
    evalCl Ad (+Cl x1 x2) = ((+ Ad) (evalCl Ad x1) (evalCl Ad x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((AdditivePointedMagma A) -> ((Vec A n) -> ((OpAdditivePointedMagmaTerm n) -> A)))
    evalOpB Ad vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ad vars 0OL = (0 Ad) 
    evalOpB Ad vars (+OL x1 x2) = ((+ Ad) (evalOpB Ad vars x1) (evalOpB Ad vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((AdditivePointedMagma A) -> ((Vec A n) -> ((OpAdditivePointedMagmaTerm2 n A) -> A)))
    evalOp Ad vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ad vars (sing2 x1) = x1 
    evalOp Ad vars 0OL2 = (0 Ad) 
    evalOp Ad vars (+OL2 x1 x2) = ((+ Ad) (evalOp Ad vars x1) (evalOp Ad vars x2)) 
    inductionB : {P : (AdditivePointedMagmaTerm -> Set)} -> ((P 0L) -> (((x1 x2 : AdditivePointedMagmaTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : AdditivePointedMagmaTerm) -> (P x))))
    inductionB {p} p0l p+l 0L = p0l 
    inductionB {p} p0l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p0l p+l x1) (inductionB {p} p0l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClAdditivePointedMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 0Cl) -> (((x1 x2 : (ClAdditivePointedMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClAdditivePointedMagmaTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p0cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p0cl p+cl 0Cl = p0cl 
    inductionCl {_} {p} psing p0cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p0cl p+cl x1) (inductionCl {_} {p} psing p0cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpAdditivePointedMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 0OL) -> (((x1 x2 : (OpAdditivePointedMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpAdditivePointedMagmaTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p0ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p0ol p+ol 0OL = p0ol 
    inductionOpB {_} {p} pv p0ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p0ol p+ol x1) (inductionOpB {_} {p} pv p0ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpAdditivePointedMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 0OL2) -> (((x1 x2 : (OpAdditivePointedMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpAdditivePointedMagmaTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 x2)) 
    0L' : AdditivePointedMagmaTerm
    0L'  = 0L 
    +L' : (AdditivePointedMagmaTerm -> (AdditivePointedMagmaTerm -> AdditivePointedMagmaTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (AdditivePointedMagmaTerm -> (Staged AdditivePointedMagmaTerm))
    stageB 0L = (Now 0L) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    0Cl' : {A : Set} -> (ClAdditivePointedMagmaTerm A)
    0Cl'  = 0Cl 
    +Cl' : {A : Set} -> ((ClAdditivePointedMagmaTerm A) -> ((ClAdditivePointedMagmaTerm A) -> (ClAdditivePointedMagmaTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClAdditivePointedMagmaTerm A) -> (Staged (ClAdditivePointedMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    0OL' : {n : Nat} -> (OpAdditivePointedMagmaTerm n)
    0OL'  = 0OL 
    +OL' : {n : Nat} -> ((OpAdditivePointedMagmaTerm n) -> ((OpAdditivePointedMagmaTerm n) -> (OpAdditivePointedMagmaTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpAdditivePointedMagmaTerm n) -> (Staged (OpAdditivePointedMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    0OL2' : {n : Nat} {A : Set} -> (OpAdditivePointedMagmaTerm2 n A)
    0OL2'  = 0OL2 
    +OL2' : {n : Nat} {A : Set} -> ((OpAdditivePointedMagmaTerm2 n A) -> ((OpAdditivePointedMagmaTerm2 n A) -> (OpAdditivePointedMagmaTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpAdditivePointedMagmaTerm2 n A) -> (Staged (OpAdditivePointedMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        0T : (Repr A)
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module AdditivePointedSemigroup  where
    record AdditivePointedSemigroup (A : Set) : Set where
      constructor AdditivePointedSemigroupC
      field
        0 : A
        + : (A -> (A -> A))
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        0S : AS
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        0P : (Prod A A)
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
    record Hom {A1 : Set} {A2 : Set} (Ad1 : (AdditivePointedSemigroup A1)) (Ad2 : (AdditivePointedSemigroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-0 : (hom (0 Ad1)) == (0 Ad2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ad1) x1 x2)) == ((+ Ad2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ad1 : (AdditivePointedSemigroup A1)) (Ad2 : (AdditivePointedSemigroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-0 : (interp (0 Ad1) (0 Ad2))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ad1) x1 x2) ((+ Ad2) y1 y2))))
    data AdditivePointedSemigroupTerm  : Set where
      0L : AdditivePointedSemigroupTerm
      +L : (AdditivePointedSemigroupTerm -> (AdditivePointedSemigroupTerm -> AdditivePointedSemigroupTerm))
    data ClAdditivePointedSemigroupTerm (A : Set) : Set where
      sing : (A -> (ClAdditivePointedSemigroupTerm A))
      0Cl : (ClAdditivePointedSemigroupTerm A)
      +Cl : ((ClAdditivePointedSemigroupTerm A) -> ((ClAdditivePointedSemigroupTerm A) -> (ClAdditivePointedSemigroupTerm A)))
    data OpAdditivePointedSemigroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpAdditivePointedSemigroupTerm n))
      0OL : (OpAdditivePointedSemigroupTerm n)
      +OL : ((OpAdditivePointedSemigroupTerm n) -> ((OpAdditivePointedSemigroupTerm n) -> (OpAdditivePointedSemigroupTerm n)))
    data OpAdditivePointedSemigroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpAdditivePointedSemigroupTerm2 n A))
      sing2 : (A -> (OpAdditivePointedSemigroupTerm2 n A))
      0OL2 : (OpAdditivePointedSemigroupTerm2 n A)
      +OL2 : ((OpAdditivePointedSemigroupTerm2 n A) -> ((OpAdditivePointedSemigroupTerm2 n A) -> (OpAdditivePointedSemigroupTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClAdditivePointedSemigroupTerm A) -> (ClAdditivePointedSemigroupTerm A))
    simplifyCl 0Cl = 0Cl 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpAdditivePointedSemigroupTerm n) -> (OpAdditivePointedSemigroupTerm n))
    simplifyOpB 0OL = 0OL 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpAdditivePointedSemigroupTerm2 n A) -> (OpAdditivePointedSemigroupTerm2 n A))
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((AdditivePointedSemigroup A) -> (AdditivePointedSemigroupTerm -> A))
    evalB Ad 0L = (0 Ad) 
    evalB Ad (+L x1 x2) = ((+ Ad) (evalB Ad x1) (evalB Ad x2)) 
    evalCl : {A : Set} -> ((AdditivePointedSemigroup A) -> ((ClAdditivePointedSemigroupTerm A) -> A))
    evalCl Ad (sing x1) = x1 
    evalCl Ad 0Cl = (0 Ad) 
    evalCl Ad (+Cl x1 x2) = ((+ Ad) (evalCl Ad x1) (evalCl Ad x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((AdditivePointedSemigroup A) -> ((Vec A n) -> ((OpAdditivePointedSemigroupTerm n) -> A)))
    evalOpB Ad vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ad vars 0OL = (0 Ad) 
    evalOpB Ad vars (+OL x1 x2) = ((+ Ad) (evalOpB Ad vars x1) (evalOpB Ad vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((AdditivePointedSemigroup A) -> ((Vec A n) -> ((OpAdditivePointedSemigroupTerm2 n A) -> A)))
    evalOp Ad vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ad vars (sing2 x1) = x1 
    evalOp Ad vars 0OL2 = (0 Ad) 
    evalOp Ad vars (+OL2 x1 x2) = ((+ Ad) (evalOp Ad vars x1) (evalOp Ad vars x2)) 
    inductionB : {P : (AdditivePointedSemigroupTerm -> Set)} -> ((P 0L) -> (((x1 x2 : AdditivePointedSemigroupTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : AdditivePointedSemigroupTerm) -> (P x))))
    inductionB {p} p0l p+l 0L = p0l 
    inductionB {p} p0l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p0l p+l x1) (inductionB {p} p0l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClAdditivePointedSemigroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 0Cl) -> (((x1 x2 : (ClAdditivePointedSemigroupTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClAdditivePointedSemigroupTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p0cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p0cl p+cl 0Cl = p0cl 
    inductionCl {_} {p} psing p0cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p0cl p+cl x1) (inductionCl {_} {p} psing p0cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpAdditivePointedSemigroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 0OL) -> (((x1 x2 : (OpAdditivePointedSemigroupTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpAdditivePointedSemigroupTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p0ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p0ol p+ol 0OL = p0ol 
    inductionOpB {_} {p} pv p0ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p0ol p+ol x1) (inductionOpB {_} {p} pv p0ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpAdditivePointedSemigroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 0OL2) -> (((x1 x2 : (OpAdditivePointedSemigroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpAdditivePointedSemigroupTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 x2)) 
    0L' : AdditivePointedSemigroupTerm
    0L'  = 0L 
    +L' : (AdditivePointedSemigroupTerm -> (AdditivePointedSemigroupTerm -> AdditivePointedSemigroupTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (AdditivePointedSemigroupTerm -> (Staged AdditivePointedSemigroupTerm))
    stageB 0L = (Now 0L) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    0Cl' : {A : Set} -> (ClAdditivePointedSemigroupTerm A)
    0Cl'  = 0Cl 
    +Cl' : {A : Set} -> ((ClAdditivePointedSemigroupTerm A) -> ((ClAdditivePointedSemigroupTerm A) -> (ClAdditivePointedSemigroupTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClAdditivePointedSemigroupTerm A) -> (Staged (ClAdditivePointedSemigroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    0OL' : {n : Nat} -> (OpAdditivePointedSemigroupTerm n)
    0OL'  = 0OL 
    +OL' : {n : Nat} -> ((OpAdditivePointedSemigroupTerm n) -> ((OpAdditivePointedSemigroupTerm n) -> (OpAdditivePointedSemigroupTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpAdditivePointedSemigroupTerm n) -> (Staged (OpAdditivePointedSemigroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    0OL2' : {n : Nat} {A : Set} -> (OpAdditivePointedSemigroupTerm2 n A)
    0OL2'  = 0OL2 
    +OL2' : {n : Nat} {A : Set} -> ((OpAdditivePointedSemigroupTerm2 n A) -> ((OpAdditivePointedSemigroupTerm2 n A) -> (OpAdditivePointedSemigroupTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpAdditivePointedSemigroupTerm2 n A) -> (Staged (OpAdditivePointedSemigroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        0T : (Repr A)
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module AdditiveSemigroup  where
    record AdditiveSemigroup (A : Set) : Set where
      constructor AdditiveSemigroupC
      field
        + : (A -> (A -> A))
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
    record Hom {A1 : Set} {A2 : Set} (Ad1 : (AdditiveSemigroup A1)) (Ad2 : (AdditiveSemigroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ad1) x1 x2)) == ((+ Ad2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ad1 : (AdditiveSemigroup A1)) (Ad2 : (AdditiveSemigroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ad1) x1 x2) ((+ Ad2) y1 y2))))
    data AdditiveSemigroupTerm  : Set where
      +L : (AdditiveSemigroupTerm -> (AdditiveSemigroupTerm -> AdditiveSemigroupTerm))
    data ClAdditiveSemigroupTerm (A : Set) : Set where
      sing : (A -> (ClAdditiveSemigroupTerm A))
      +Cl : ((ClAdditiveSemigroupTerm A) -> ((ClAdditiveSemigroupTerm A) -> (ClAdditiveSemigroupTerm A)))
    data OpAdditiveSemigroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpAdditiveSemigroupTerm n))
      +OL : ((OpAdditiveSemigroupTerm n) -> ((OpAdditiveSemigroupTerm n) -> (OpAdditiveSemigroupTerm n)))
    data OpAdditiveSemigroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpAdditiveSemigroupTerm2 n A))
      sing2 : (A -> (OpAdditiveSemigroupTerm2 n A))
      +OL2 : ((OpAdditiveSemigroupTerm2 n A) -> ((OpAdditiveSemigroupTerm2 n A) -> (OpAdditiveSemigroupTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClAdditiveSemigroupTerm A) -> (ClAdditiveSemigroupTerm A))
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpAdditiveSemigroupTerm n) -> (OpAdditiveSemigroupTerm n))
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpAdditiveSemigroupTerm2 n A) -> (OpAdditiveSemigroupTerm2 n A))
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((AdditiveSemigroup A) -> (AdditiveSemigroupTerm -> A))
    evalB Ad (+L x1 x2) = ((+ Ad) (evalB Ad x1) (evalB Ad x2)) 
    evalCl : {A : Set} -> ((AdditiveSemigroup A) -> ((ClAdditiveSemigroupTerm A) -> A))
    evalCl Ad (sing x1) = x1 
    evalCl Ad (+Cl x1 x2) = ((+ Ad) (evalCl Ad x1) (evalCl Ad x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((AdditiveSemigroup A) -> ((Vec A n) -> ((OpAdditiveSemigroupTerm n) -> A)))
    evalOpB Ad vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ad vars (+OL x1 x2) = ((+ Ad) (evalOpB Ad vars x1) (evalOpB Ad vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((AdditiveSemigroup A) -> ((Vec A n) -> ((OpAdditiveSemigroupTerm2 n A) -> A)))
    evalOp Ad vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ad vars (sing2 x1) = x1 
    evalOp Ad vars (+OL2 x1 x2) = ((+ Ad) (evalOp Ad vars x1) (evalOp Ad vars x2)) 
    inductionB : {P : (AdditiveSemigroupTerm -> Set)} -> (((x1 x2 : AdditiveSemigroupTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : AdditiveSemigroupTerm) -> (P x)))
    inductionB {p} p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p+l x1) (inductionB {p} p+l x2)) 
    inductionCl : {A : Set} {P : ((ClAdditiveSemigroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClAdditiveSemigroupTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClAdditiveSemigroupTerm A)) -> (P x))))
    inductionCl {_} {p} psing p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p+cl x1) (inductionCl {_} {p} psing p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpAdditiveSemigroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpAdditiveSemigroupTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpAdditiveSemigroupTerm n)) -> (P x))))
    inductionOpB {_} {p} pv p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p+ol x1) (inductionOpB {_} {p} pv p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpAdditiveSemigroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpAdditiveSemigroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpAdditiveSemigroupTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 x2)) 
    +L' : (AdditiveSemigroupTerm -> (AdditiveSemigroupTerm -> AdditiveSemigroupTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (AdditiveSemigroupTerm -> (Staged AdditiveSemigroupTerm))
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    +Cl' : {A : Set} -> ((ClAdditiveSemigroupTerm A) -> ((ClAdditiveSemigroupTerm A) -> (ClAdditiveSemigroupTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClAdditiveSemigroupTerm A) -> (Staged (ClAdditiveSemigroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    +OL' : {n : Nat} -> ((OpAdditiveSemigroupTerm n) -> ((OpAdditiveSemigroupTerm n) -> (OpAdditiveSemigroupTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpAdditiveSemigroupTerm n) -> (Staged (OpAdditiveSemigroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    +OL2' : {n : Nat} {A : Set} -> ((OpAdditiveSemigroupTerm2 n A) -> ((OpAdditiveSemigroupTerm2 n A) -> (OpAdditiveSemigroupTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpAdditiveSemigroupTerm2 n A) -> (Staged (OpAdditiveSemigroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module AdditiveUnaryAntiDistribution  where
    record AdditiveUnaryAntiDistribution (A : Set) : Set where
      constructor AdditiveUnaryAntiDistributionC
      field
        prim : (A -> A)
        + : (A -> (A -> A))
        antidis_prim_+ : {x y : A} -> (prim (+ x y)) == (+ (prim y) (prim x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        primS : (AS -> AS)
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        primP : ((Prod A A) -> (Prod A A))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        antidis_prim_+P : {xP yP : (Prod A A)} -> (primP (+P xP yP)) == (+P (primP yP) (primP xP))
    record Hom {A1 : Set} {A2 : Set} (Ad1 : (AdditiveUnaryAntiDistribution A1)) (Ad2 : (AdditiveUnaryAntiDistribution A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-prim : {x1 : A1} -> (hom ((prim Ad1) x1)) == ((prim Ad2) (hom x1))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ad1) x1 x2)) == ((+ Ad2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ad1 : (AdditiveUnaryAntiDistribution A1)) (Ad2 : (AdditiveUnaryAntiDistribution A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim Ad1) x1) ((prim Ad2) y1)))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ad1) x1 x2) ((+ Ad2) y1 y2))))
    data AdditiveUnaryAntiDistributionTerm  : Set where
      primL : (AdditiveUnaryAntiDistributionTerm -> AdditiveUnaryAntiDistributionTerm)
      +L : (AdditiveUnaryAntiDistributionTerm -> (AdditiveUnaryAntiDistributionTerm -> AdditiveUnaryAntiDistributionTerm))
    data ClAdditiveUnaryAntiDistributionTerm (A : Set) : Set where
      sing : (A -> (ClAdditiveUnaryAntiDistributionTerm A))
      primCl : ((ClAdditiveUnaryAntiDistributionTerm A) -> (ClAdditiveUnaryAntiDistributionTerm A))
      +Cl : ((ClAdditiveUnaryAntiDistributionTerm A) -> ((ClAdditiveUnaryAntiDistributionTerm A) -> (ClAdditiveUnaryAntiDistributionTerm A)))
    data OpAdditiveUnaryAntiDistributionTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpAdditiveUnaryAntiDistributionTerm n))
      primOL : ((OpAdditiveUnaryAntiDistributionTerm n) -> (OpAdditiveUnaryAntiDistributionTerm n))
      +OL : ((OpAdditiveUnaryAntiDistributionTerm n) -> ((OpAdditiveUnaryAntiDistributionTerm n) -> (OpAdditiveUnaryAntiDistributionTerm n)))
    data OpAdditiveUnaryAntiDistributionTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpAdditiveUnaryAntiDistributionTerm2 n A))
      sing2 : (A -> (OpAdditiveUnaryAntiDistributionTerm2 n A))
      primOL2 : ((OpAdditiveUnaryAntiDistributionTerm2 n A) -> (OpAdditiveUnaryAntiDistributionTerm2 n A))
      +OL2 : ((OpAdditiveUnaryAntiDistributionTerm2 n A) -> ((OpAdditiveUnaryAntiDistributionTerm2 n A) -> (OpAdditiveUnaryAntiDistributionTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClAdditiveUnaryAntiDistributionTerm A) -> (ClAdditiveUnaryAntiDistributionTerm A))
    simplifyCl (+Cl (primCl y) (primCl x)) = (primCl (+Cl x y)) 
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpAdditiveUnaryAntiDistributionTerm n) -> (OpAdditiveUnaryAntiDistributionTerm n))
    simplifyOpB (+OL (primOL y) (primOL x)) = (primOL (+OL x y)) 
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpAdditiveUnaryAntiDistributionTerm2 n A) -> (OpAdditiveUnaryAntiDistributionTerm2 n A))
    simplifyOp (+OL2 (primOL2 y) (primOL2 x)) = (primOL2 (+OL2 x y)) 
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((AdditiveUnaryAntiDistribution A) -> (AdditiveUnaryAntiDistributionTerm -> A))
    evalB Ad (primL x1) = ((prim Ad) (evalB Ad x1)) 
    evalB Ad (+L x1 x2) = ((+ Ad) (evalB Ad x1) (evalB Ad x2)) 
    evalCl : {A : Set} -> ((AdditiveUnaryAntiDistribution A) -> ((ClAdditiveUnaryAntiDistributionTerm A) -> A))
    evalCl Ad (sing x1) = x1 
    evalCl Ad (primCl x1) = ((prim Ad) (evalCl Ad x1)) 
    evalCl Ad (+Cl x1 x2) = ((+ Ad) (evalCl Ad x1) (evalCl Ad x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((AdditiveUnaryAntiDistribution A) -> ((Vec A n) -> ((OpAdditiveUnaryAntiDistributionTerm n) -> A)))
    evalOpB Ad vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ad vars (primOL x1) = ((prim Ad) (evalOpB Ad vars x1)) 
    evalOpB Ad vars (+OL x1 x2) = ((+ Ad) (evalOpB Ad vars x1) (evalOpB Ad vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((AdditiveUnaryAntiDistribution A) -> ((Vec A n) -> ((OpAdditiveUnaryAntiDistributionTerm2 n A) -> A)))
    evalOp Ad vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ad vars (sing2 x1) = x1 
    evalOp Ad vars (primOL2 x1) = ((prim Ad) (evalOp Ad vars x1)) 
    evalOp Ad vars (+OL2 x1 x2) = ((+ Ad) (evalOp Ad vars x1) (evalOp Ad vars x2)) 
    inductionB : {P : (AdditiveUnaryAntiDistributionTerm -> Set)} -> (((x1 : AdditiveUnaryAntiDistributionTerm) -> ((P x1) -> (P (primL x1)))) -> (((x1 x2 : AdditiveUnaryAntiDistributionTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : AdditiveUnaryAntiDistributionTerm) -> (P x))))
    inductionB {p} ppriml p+l (primL x1) = (ppriml _ (inductionB {p} ppriml p+l x1)) 
    inductionB {p} ppriml p+l (+L x1 x2) = (p+l _ _ (inductionB {p} ppriml p+l x1) (inductionB {p} ppriml p+l x2)) 
    inductionCl : {A : Set} {P : ((ClAdditiveUnaryAntiDistributionTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 : (ClAdditiveUnaryAntiDistributionTerm A)) -> ((P x1) -> (P (primCl x1)))) -> (((x1 x2 : (ClAdditiveUnaryAntiDistributionTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClAdditiveUnaryAntiDistributionTerm A)) -> (P x)))))
    inductionCl {_} {p} psing pprimcl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pprimcl p+cl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing pprimcl p+cl x1)) 
    inductionCl {_} {p} psing pprimcl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing pprimcl p+cl x1) (inductionCl {_} {p} psing pprimcl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpAdditiveUnaryAntiDistributionTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 : (OpAdditiveUnaryAntiDistributionTerm n)) -> ((P x1) -> (P (primOL x1)))) -> (((x1 x2 : (OpAdditiveUnaryAntiDistributionTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpAdditiveUnaryAntiDistributionTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv pprimol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pprimol p+ol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv pprimol p+ol x1)) 
    inductionOpB {_} {p} pv pprimol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv pprimol p+ol x1) (inductionOpB {_} {p} pv pprimol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpAdditiveUnaryAntiDistributionTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 : (OpAdditiveUnaryAntiDistributionTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> (((x1 x2 : (OpAdditiveUnaryAntiDistributionTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpAdditiveUnaryAntiDistributionTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 p+ol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 pprimol2 p+ol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 pprimol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 pprimol2 p+ol2 x2)) 
    primL' : (AdditiveUnaryAntiDistributionTerm -> AdditiveUnaryAntiDistributionTerm)
    primL' x1 = (primL x1) 
    +L' : (AdditiveUnaryAntiDistributionTerm -> (AdditiveUnaryAntiDistributionTerm -> AdditiveUnaryAntiDistributionTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (AdditiveUnaryAntiDistributionTerm -> (Staged AdditiveUnaryAntiDistributionTerm))
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    primCl' : {A : Set} -> ((ClAdditiveUnaryAntiDistributionTerm A) -> (ClAdditiveUnaryAntiDistributionTerm A))
    primCl' x1 = (primCl x1) 
    +Cl' : {A : Set} -> ((ClAdditiveUnaryAntiDistributionTerm A) -> ((ClAdditiveUnaryAntiDistributionTerm A) -> (ClAdditiveUnaryAntiDistributionTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClAdditiveUnaryAntiDistributionTerm A) -> (Staged (ClAdditiveUnaryAntiDistributionTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    primOL' : {n : Nat} -> ((OpAdditiveUnaryAntiDistributionTerm n) -> (OpAdditiveUnaryAntiDistributionTerm n))
    primOL' x1 = (primOL x1) 
    +OL' : {n : Nat} -> ((OpAdditiveUnaryAntiDistributionTerm n) -> ((OpAdditiveUnaryAntiDistributionTerm n) -> (OpAdditiveUnaryAntiDistributionTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpAdditiveUnaryAntiDistributionTerm n) -> (Staged (OpAdditiveUnaryAntiDistributionTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    primOL2' : {n : Nat} {A : Set} -> ((OpAdditiveUnaryAntiDistributionTerm2 n A) -> (OpAdditiveUnaryAntiDistributionTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    +OL2' : {n : Nat} {A : Set} -> ((OpAdditiveUnaryAntiDistributionTerm2 n A) -> ((OpAdditiveUnaryAntiDistributionTerm2 n A) -> (OpAdditiveUnaryAntiDistributionTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpAdditiveUnaryAntiDistributionTerm2 n A) -> (Staged (OpAdditiveUnaryAntiDistributionTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        primT : ((Repr A) -> (Repr A))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module AdditiveUnital  where
    record AdditiveUnital (A : Set) : Set where
      constructor AdditiveUnitalC
      field
        0 : A
        + : (A -> (A -> A))
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        0S : AS
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        0P : (Prod A A)
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
    record Hom {A1 : Set} {A2 : Set} (Ad1 : (AdditiveUnital A1)) (Ad2 : (AdditiveUnital A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-0 : (hom (0 Ad1)) == (0 Ad2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ad1) x1 x2)) == ((+ Ad2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ad1 : (AdditiveUnital A1)) (Ad2 : (AdditiveUnital A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-0 : (interp (0 Ad1) (0 Ad2))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ad1) x1 x2) ((+ Ad2) y1 y2))))
    data AdditiveUnitalTerm  : Set where
      0L : AdditiveUnitalTerm
      +L : (AdditiveUnitalTerm -> (AdditiveUnitalTerm -> AdditiveUnitalTerm))
    data ClAdditiveUnitalTerm (A : Set) : Set where
      sing : (A -> (ClAdditiveUnitalTerm A))
      0Cl : (ClAdditiveUnitalTerm A)
      +Cl : ((ClAdditiveUnitalTerm A) -> ((ClAdditiveUnitalTerm A) -> (ClAdditiveUnitalTerm A)))
    data OpAdditiveUnitalTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpAdditiveUnitalTerm n))
      0OL : (OpAdditiveUnitalTerm n)
      +OL : ((OpAdditiveUnitalTerm n) -> ((OpAdditiveUnitalTerm n) -> (OpAdditiveUnitalTerm n)))
    data OpAdditiveUnitalTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpAdditiveUnitalTerm2 n A))
      sing2 : (A -> (OpAdditiveUnitalTerm2 n A))
      0OL2 : (OpAdditiveUnitalTerm2 n A)
      +OL2 : ((OpAdditiveUnitalTerm2 n A) -> ((OpAdditiveUnitalTerm2 n A) -> (OpAdditiveUnitalTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClAdditiveUnitalTerm A) -> (ClAdditiveUnitalTerm A))
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl 0Cl = 0Cl 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpAdditiveUnitalTerm n) -> (OpAdditiveUnitalTerm n))
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB 0OL = 0OL 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpAdditiveUnitalTerm2 n A) -> (OpAdditiveUnitalTerm2 n A))
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((AdditiveUnital A) -> (AdditiveUnitalTerm -> A))
    evalB Ad 0L = (0 Ad) 
    evalB Ad (+L x1 x2) = ((+ Ad) (evalB Ad x1) (evalB Ad x2)) 
    evalCl : {A : Set} -> ((AdditiveUnital A) -> ((ClAdditiveUnitalTerm A) -> A))
    evalCl Ad (sing x1) = x1 
    evalCl Ad 0Cl = (0 Ad) 
    evalCl Ad (+Cl x1 x2) = ((+ Ad) (evalCl Ad x1) (evalCl Ad x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((AdditiveUnital A) -> ((Vec A n) -> ((OpAdditiveUnitalTerm n) -> A)))
    evalOpB Ad vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ad vars 0OL = (0 Ad) 
    evalOpB Ad vars (+OL x1 x2) = ((+ Ad) (evalOpB Ad vars x1) (evalOpB Ad vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((AdditiveUnital A) -> ((Vec A n) -> ((OpAdditiveUnitalTerm2 n A) -> A)))
    evalOp Ad vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ad vars (sing2 x1) = x1 
    evalOp Ad vars 0OL2 = (0 Ad) 
    evalOp Ad vars (+OL2 x1 x2) = ((+ Ad) (evalOp Ad vars x1) (evalOp Ad vars x2)) 
    inductionB : {P : (AdditiveUnitalTerm -> Set)} -> ((P 0L) -> (((x1 x2 : AdditiveUnitalTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : AdditiveUnitalTerm) -> (P x))))
    inductionB {p} p0l p+l 0L = p0l 
    inductionB {p} p0l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p0l p+l x1) (inductionB {p} p0l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClAdditiveUnitalTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 0Cl) -> (((x1 x2 : (ClAdditiveUnitalTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClAdditiveUnitalTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p0cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p0cl p+cl 0Cl = p0cl 
    inductionCl {_} {p} psing p0cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p0cl p+cl x1) (inductionCl {_} {p} psing p0cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpAdditiveUnitalTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 0OL) -> (((x1 x2 : (OpAdditiveUnitalTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpAdditiveUnitalTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p0ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p0ol p+ol 0OL = p0ol 
    inductionOpB {_} {p} pv p0ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p0ol p+ol x1) (inductionOpB {_} {p} pv p0ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpAdditiveUnitalTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 0OL2) -> (((x1 x2 : (OpAdditiveUnitalTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpAdditiveUnitalTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 x2)) 
    0L' : AdditiveUnitalTerm
    0L'  = 0L 
    +L' : (AdditiveUnitalTerm -> (AdditiveUnitalTerm -> AdditiveUnitalTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (AdditiveUnitalTerm -> (Staged AdditiveUnitalTerm))
    stageB 0L = (Now 0L) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    0Cl' : {A : Set} -> (ClAdditiveUnitalTerm A)
    0Cl'  = 0Cl 
    +Cl' : {A : Set} -> ((ClAdditiveUnitalTerm A) -> ((ClAdditiveUnitalTerm A) -> (ClAdditiveUnitalTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClAdditiveUnitalTerm A) -> (Staged (ClAdditiveUnitalTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    0OL' : {n : Nat} -> (OpAdditiveUnitalTerm n)
    0OL'  = 0OL 
    +OL' : {n : Nat} -> ((OpAdditiveUnitalTerm n) -> ((OpAdditiveUnitalTerm n) -> (OpAdditiveUnitalTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpAdditiveUnitalTerm n) -> (Staged (OpAdditiveUnitalTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    0OL2' : {n : Nat} {A : Set} -> (OpAdditiveUnitalTerm2 n A)
    0OL2'  = 0OL2 
    +OL2' : {n : Nat} {A : Set} -> ((OpAdditiveUnitalTerm2 n A) -> ((OpAdditiveUnitalTerm2 n A) -> (OpAdditiveUnitalTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpAdditiveUnitalTerm2 n A) -> (Staged (OpAdditiveUnitalTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        0T : (Repr A)
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module AndDeMorgan  where
    record AndDeMorgan (A : Set) : Set where
      constructor AndDeMorganC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        prim : (A -> A)
        andDeMorgan_*_+_prim : {x y z : A} -> (prim (* x y)) == (+ (prim x) (prim y))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
        primS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        primP : ((Prod A A) -> (Prod A A))
        andDeMorgan_*_+_primP : {xP yP zP : (Prod A A)} -> (primP (*P xP yP)) == (+P (primP xP) (primP yP))
    record Hom {A1 : Set} {A2 : Set} (An1 : (AndDeMorgan A1)) (An2 : (AndDeMorgan A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* An1) x1 x2)) == ((* An2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ An1) x1 x2)) == ((+ An2) (hom x1) (hom x2))
        pres-prim : {x1 : A1} -> (hom ((prim An1) x1)) == ((prim An2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (An1 : (AndDeMorgan A1)) (An2 : (AndDeMorgan A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* An1) x1 x2) ((* An2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ An1) x1 x2) ((+ An2) y1 y2))))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim An1) x1) ((prim An2) y1)))
    data AndDeMorganTerm  : Set where
      *L : (AndDeMorganTerm -> (AndDeMorganTerm -> AndDeMorganTerm))
      +L : (AndDeMorganTerm -> (AndDeMorganTerm -> AndDeMorganTerm))
      primL : (AndDeMorganTerm -> AndDeMorganTerm)
    data ClAndDeMorganTerm (A : Set) : Set where
      sing : (A -> (ClAndDeMorganTerm A))
      *Cl : ((ClAndDeMorganTerm A) -> ((ClAndDeMorganTerm A) -> (ClAndDeMorganTerm A)))
      +Cl : ((ClAndDeMorganTerm A) -> ((ClAndDeMorganTerm A) -> (ClAndDeMorganTerm A)))
      primCl : ((ClAndDeMorganTerm A) -> (ClAndDeMorganTerm A))
    data OpAndDeMorganTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpAndDeMorganTerm n))
      *OL : ((OpAndDeMorganTerm n) -> ((OpAndDeMorganTerm n) -> (OpAndDeMorganTerm n)))
      +OL : ((OpAndDeMorganTerm n) -> ((OpAndDeMorganTerm n) -> (OpAndDeMorganTerm n)))
      primOL : ((OpAndDeMorganTerm n) -> (OpAndDeMorganTerm n))
    data OpAndDeMorganTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpAndDeMorganTerm2 n A))
      sing2 : (A -> (OpAndDeMorganTerm2 n A))
      *OL2 : ((OpAndDeMorganTerm2 n A) -> ((OpAndDeMorganTerm2 n A) -> (OpAndDeMorganTerm2 n A)))
      +OL2 : ((OpAndDeMorganTerm2 n A) -> ((OpAndDeMorganTerm2 n A) -> (OpAndDeMorganTerm2 n A)))
      primOL2 : ((OpAndDeMorganTerm2 n A) -> (OpAndDeMorganTerm2 n A))
    simplifyCl : {A : Set} -> ((ClAndDeMorganTerm A) -> (ClAndDeMorganTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpAndDeMorganTerm n) -> (OpAndDeMorganTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpAndDeMorganTerm2 n A) -> (OpAndDeMorganTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((AndDeMorgan A) -> (AndDeMorganTerm -> A))
    evalB An (*L x1 x2) = ((* An) (evalB An x1) (evalB An x2)) 
    evalB An (+L x1 x2) = ((+ An) (evalB An x1) (evalB An x2)) 
    evalB An (primL x1) = ((prim An) (evalB An x1)) 
    evalCl : {A : Set} -> ((AndDeMorgan A) -> ((ClAndDeMorganTerm A) -> A))
    evalCl An (sing x1) = x1 
    evalCl An (*Cl x1 x2) = ((* An) (evalCl An x1) (evalCl An x2)) 
    evalCl An (+Cl x1 x2) = ((+ An) (evalCl An x1) (evalCl An x2)) 
    evalCl An (primCl x1) = ((prim An) (evalCl An x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((AndDeMorgan A) -> ((Vec A n) -> ((OpAndDeMorganTerm n) -> A)))
    evalOpB An vars (v x1) = (lookup _ x1 vars) 
    evalOpB An vars (*OL x1 x2) = ((* An) (evalOpB An vars x1) (evalOpB An vars x2)) 
    evalOpB An vars (+OL x1 x2) = ((+ An) (evalOpB An vars x1) (evalOpB An vars x2)) 
    evalOpB An vars (primOL x1) = ((prim An) (evalOpB An vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((AndDeMorgan A) -> ((Vec A n) -> ((OpAndDeMorganTerm2 n A) -> A)))
    evalOp An vars (v2 x1) = (lookup _ x1 vars) 
    evalOp An vars (sing2 x1) = x1 
    evalOp An vars (*OL2 x1 x2) = ((* An) (evalOp An vars x1) (evalOp An vars x2)) 
    evalOp An vars (+OL2 x1 x2) = ((+ An) (evalOp An vars x1) (evalOp An vars x2)) 
    evalOp An vars (primOL2 x1) = ((prim An) (evalOp An vars x1)) 
    inductionB : {P : (AndDeMorganTerm -> Set)} -> (((x1 x2 : AndDeMorganTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : AndDeMorganTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> (((x1 : AndDeMorganTerm) -> ((P x1) -> (P (primL x1)))) -> ((x : AndDeMorganTerm) -> (P x)))))
    inductionB {p} p*l p+l ppriml (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l ppriml x1) (inductionB {p} p*l p+l ppriml x2)) 
    inductionB {p} p*l p+l ppriml (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l ppriml x1) (inductionB {p} p*l p+l ppriml x2)) 
    inductionB {p} p*l p+l ppriml (primL x1) = (ppriml _ (inductionB {p} p*l p+l ppriml x1)) 
    inductionCl : {A : Set} {P : ((ClAndDeMorganTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClAndDeMorganTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClAndDeMorganTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> (((x1 : (ClAndDeMorganTerm A)) -> ((P x1) -> (P (primCl x1)))) -> ((x : (ClAndDeMorganTerm A)) -> (P x))))))
    inductionCl {_} {p} psing p*cl p+cl pprimcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl pprimcl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl pprimcl x1) (inductionCl {_} {p} psing p*cl p+cl pprimcl x2)) 
    inductionCl {_} {p} psing p*cl p+cl pprimcl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl pprimcl x1) (inductionCl {_} {p} psing p*cl p+cl pprimcl x2)) 
    inductionCl {_} {p} psing p*cl p+cl pprimcl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing p*cl p+cl pprimcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpAndDeMorganTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpAndDeMorganTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpAndDeMorganTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> (((x1 : (OpAndDeMorganTerm n)) -> ((P x1) -> (P (primOL x1)))) -> ((x : (OpAndDeMorganTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv p*ol p+ol pprimol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol pprimol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol pprimol x1) (inductionOpB {_} {p} pv p*ol p+ol pprimol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol pprimol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol pprimol x1) (inductionOpB {_} {p} pv p*ol p+ol pprimol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol pprimol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv p*ol p+ol pprimol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpAndDeMorganTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpAndDeMorganTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpAndDeMorganTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> (((x1 : (OpAndDeMorganTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> ((x : (OpAndDeMorganTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x1)) 
    *L' : (AndDeMorganTerm -> (AndDeMorganTerm -> AndDeMorganTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (AndDeMorganTerm -> (AndDeMorganTerm -> AndDeMorganTerm))
    +L' x1 x2 = (+L x1 x2) 
    primL' : (AndDeMorganTerm -> AndDeMorganTerm)
    primL' x1 = (primL x1) 
    stageB : (AndDeMorganTerm -> (Staged AndDeMorganTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    *Cl' : {A : Set} -> ((ClAndDeMorganTerm A) -> ((ClAndDeMorganTerm A) -> (ClAndDeMorganTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClAndDeMorganTerm A) -> ((ClAndDeMorganTerm A) -> (ClAndDeMorganTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    primCl' : {A : Set} -> ((ClAndDeMorganTerm A) -> (ClAndDeMorganTerm A))
    primCl' x1 = (primCl x1) 
    stageCl : {A : Set} -> ((ClAndDeMorganTerm A) -> (Staged (ClAndDeMorganTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    *OL' : {n : Nat} -> ((OpAndDeMorganTerm n) -> ((OpAndDeMorganTerm n) -> (OpAndDeMorganTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpAndDeMorganTerm n) -> ((OpAndDeMorganTerm n) -> (OpAndDeMorganTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    primOL' : {n : Nat} -> ((OpAndDeMorganTerm n) -> (OpAndDeMorganTerm n))
    primOL' x1 = (primOL x1) 
    stageOpB : {n : Nat} -> ((OpAndDeMorganTerm n) -> (Staged (OpAndDeMorganTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpAndDeMorganTerm2 n A) -> ((OpAndDeMorganTerm2 n A) -> (OpAndDeMorganTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpAndDeMorganTerm2 n A) -> ((OpAndDeMorganTerm2 n A) -> (OpAndDeMorganTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    primOL2' : {n : Nat} {A : Set} -> ((OpAndDeMorganTerm2 n A) -> (OpAndDeMorganTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpAndDeMorganTerm2 n A) -> (Staged (OpAndDeMorganTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        primT : ((Repr A) -> (Repr A))
  module AntiAbsorbent  where
    record AntiAbsorbent (A : Set) : Set where
      constructor AntiAbsorbentC
      field
        op : (A -> (A -> A))
        antiAbsorbent : {x y : A} -> (op x (op x y)) == y
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        antiAbsorbentP : {xP yP : (Prod A A)} -> (opP xP (opP xP yP)) == yP
    record Hom {A1 : Set} {A2 : Set} (An1 : (AntiAbsorbent A1)) (An2 : (AntiAbsorbent A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op An1) x1 x2)) == ((op An2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (An1 : (AntiAbsorbent A1)) (An2 : (AntiAbsorbent A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op An1) x1 x2) ((op An2) y1 y2))))
    data AntiAbsorbentTerm  : Set where
      opL : (AntiAbsorbentTerm -> (AntiAbsorbentTerm -> AntiAbsorbentTerm))
    data ClAntiAbsorbentTerm (A : Set) : Set where
      sing : (A -> (ClAntiAbsorbentTerm A))
      opCl : ((ClAntiAbsorbentTerm A) -> ((ClAntiAbsorbentTerm A) -> (ClAntiAbsorbentTerm A)))
    data OpAntiAbsorbentTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpAntiAbsorbentTerm n))
      opOL : ((OpAntiAbsorbentTerm n) -> ((OpAntiAbsorbentTerm n) -> (OpAntiAbsorbentTerm n)))
    data OpAntiAbsorbentTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpAntiAbsorbentTerm2 n A))
      sing2 : (A -> (OpAntiAbsorbentTerm2 n A))
      opOL2 : ((OpAntiAbsorbentTerm2 n A) -> ((OpAntiAbsorbentTerm2 n A) -> (OpAntiAbsorbentTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClAntiAbsorbentTerm A) -> (ClAntiAbsorbentTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpAntiAbsorbentTerm n) -> (OpAntiAbsorbentTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpAntiAbsorbentTerm2 n A) -> (OpAntiAbsorbentTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((AntiAbsorbent A) -> (AntiAbsorbentTerm -> A))
    evalB An (opL x1 x2) = ((op An) (evalB An x1) (evalB An x2)) 
    evalCl : {A : Set} -> ((AntiAbsorbent A) -> ((ClAntiAbsorbentTerm A) -> A))
    evalCl An (sing x1) = x1 
    evalCl An (opCl x1 x2) = ((op An) (evalCl An x1) (evalCl An x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((AntiAbsorbent A) -> ((Vec A n) -> ((OpAntiAbsorbentTerm n) -> A)))
    evalOpB An vars (v x1) = (lookup _ x1 vars) 
    evalOpB An vars (opOL x1 x2) = ((op An) (evalOpB An vars x1) (evalOpB An vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((AntiAbsorbent A) -> ((Vec A n) -> ((OpAntiAbsorbentTerm2 n A) -> A)))
    evalOp An vars (v2 x1) = (lookup _ x1 vars) 
    evalOp An vars (sing2 x1) = x1 
    evalOp An vars (opOL2 x1 x2) = ((op An) (evalOp An vars x1) (evalOp An vars x2)) 
    inductionB : {P : (AntiAbsorbentTerm -> Set)} -> (((x1 x2 : AntiAbsorbentTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : AntiAbsorbentTerm) -> (P x)))
    inductionB {p} popl (opL x1 x2) = (popl _ _ (inductionB {p} popl x1) (inductionB {p} popl x2)) 
    inductionCl : {A : Set} {P : ((ClAntiAbsorbentTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClAntiAbsorbentTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClAntiAbsorbentTerm A)) -> (P x))))
    inductionCl {_} {p} psing popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl x1) (inductionCl {_} {p} psing popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpAntiAbsorbentTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpAntiAbsorbentTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpAntiAbsorbentTerm n)) -> (P x))))
    inductionOpB {_} {p} pv popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol x1) (inductionOpB {_} {p} pv popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpAntiAbsorbentTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpAntiAbsorbentTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpAntiAbsorbentTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 x2)) 
    opL' : (AntiAbsorbentTerm -> (AntiAbsorbentTerm -> AntiAbsorbentTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (AntiAbsorbentTerm -> (Staged AntiAbsorbentTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClAntiAbsorbentTerm A) -> ((ClAntiAbsorbentTerm A) -> (ClAntiAbsorbentTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClAntiAbsorbentTerm A) -> (Staged (ClAntiAbsorbentTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpAntiAbsorbentTerm n) -> ((OpAntiAbsorbentTerm n) -> (OpAntiAbsorbentTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpAntiAbsorbentTerm n) -> (Staged (OpAntiAbsorbentTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpAntiAbsorbentTerm2 n A) -> ((OpAntiAbsorbentTerm2 n A) -> (OpAntiAbsorbentTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpAntiAbsorbentTerm2 n A) -> (Staged (OpAntiAbsorbentTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module AntiCommutativeRing  where
    record AntiCommutativeRing (A : Set) : Set where
      constructor AntiCommutativeRingC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        0 : A
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        leftDistributive_*_+ : {x y z : A} -> (* x (+ y z)) == (+ (* x y) (* x z))
        rightDistributive_*_+ : {x y z : A} -> (* (+ y z) x) == (+ (* y x) (* z x))
        neg : (A -> A)
        leftInverse_inv_op_0 : {x : A} -> (+ x (neg x)) == 0
        rightInverse_inv_op_0 : {x : A} -> (+ (neg x) x) == 0
        1 : A
        lunit_1 : {x : A} -> (* 1 x) == x
        runit_1 : {x : A} -> (* x 1) == x
        leftZero_op_0 : {x : A} -> (* 0 x) == 0
        rightZero_op_0 : {x : A} -> (* x 0) == 0
        antiCommutative : {x y : A} -> (* x y) == (neg (* y x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
        0S : AS
        negS : (AS -> AS)
        1S : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        0P : (Prod A A)
        negP : ((Prod A A) -> (Prod A A))
        1P : (Prod A A)
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        leftDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P xP (+P yP zP)) == (+P (*P xP yP) (*P xP zP))
        rightDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P (+P yP zP) xP) == (+P (*P yP xP) (*P zP xP))
        leftInverse_inv_op_0P : {xP : (Prod A A)} -> (+P xP (negP xP)) == 0P
        rightInverse_inv_op_0P : {xP : (Prod A A)} -> (+P (negP xP) xP) == 0P
        lunit_1P : {xP : (Prod A A)} -> (*P 1P xP) == xP
        runit_1P : {xP : (Prod A A)} -> (*P xP 1P) == xP
        leftZero_op_0P : {xP : (Prod A A)} -> (*P 0P xP) == 0P
        rightZero_op_0P : {xP : (Prod A A)} -> (*P xP 0P) == 0P
        antiCommutativeP : {xP yP : (Prod A A)} -> (*P xP yP) == (negP (*P yP xP))
    record Hom {A1 : Set} {A2 : Set} (An1 : (AntiCommutativeRing A1)) (An2 : (AntiCommutativeRing A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* An1) x1 x2)) == ((* An2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ An1) x1 x2)) == ((+ An2) (hom x1) (hom x2))
        pres-0 : (hom (0 An1)) == (0 An2)
        pres-neg : {x1 : A1} -> (hom ((neg An1) x1)) == ((neg An2) (hom x1))
        pres-1 : (hom (1 An1)) == (1 An2)
    record RelInterp {A1 : Set} {A2 : Set} (An1 : (AntiCommutativeRing A1)) (An2 : (AntiCommutativeRing A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* An1) x1 x2) ((* An2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ An1) x1 x2) ((+ An2) y1 y2))))
        interp-0 : (interp (0 An1) (0 An2))
        interp-neg : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((neg An1) x1) ((neg An2) y1)))
        interp-1 : (interp (1 An1) (1 An2))
    data AntiCommutativeRingTerm  : Set where
      *L : (AntiCommutativeRingTerm -> (AntiCommutativeRingTerm -> AntiCommutativeRingTerm))
      +L : (AntiCommutativeRingTerm -> (AntiCommutativeRingTerm -> AntiCommutativeRingTerm))
      0L : AntiCommutativeRingTerm
      negL : (AntiCommutativeRingTerm -> AntiCommutativeRingTerm)
      1L : AntiCommutativeRingTerm
    data ClAntiCommutativeRingTerm (A : Set) : Set where
      sing : (A -> (ClAntiCommutativeRingTerm A))
      *Cl : ((ClAntiCommutativeRingTerm A) -> ((ClAntiCommutativeRingTerm A) -> (ClAntiCommutativeRingTerm A)))
      +Cl : ((ClAntiCommutativeRingTerm A) -> ((ClAntiCommutativeRingTerm A) -> (ClAntiCommutativeRingTerm A)))
      0Cl : (ClAntiCommutativeRingTerm A)
      negCl : ((ClAntiCommutativeRingTerm A) -> (ClAntiCommutativeRingTerm A))
      1Cl : (ClAntiCommutativeRingTerm A)
    data OpAntiCommutativeRingTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpAntiCommutativeRingTerm n))
      *OL : ((OpAntiCommutativeRingTerm n) -> ((OpAntiCommutativeRingTerm n) -> (OpAntiCommutativeRingTerm n)))
      +OL : ((OpAntiCommutativeRingTerm n) -> ((OpAntiCommutativeRingTerm n) -> (OpAntiCommutativeRingTerm n)))
      0OL : (OpAntiCommutativeRingTerm n)
      negOL : ((OpAntiCommutativeRingTerm n) -> (OpAntiCommutativeRingTerm n))
      1OL : (OpAntiCommutativeRingTerm n)
    data OpAntiCommutativeRingTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpAntiCommutativeRingTerm2 n A))
      sing2 : (A -> (OpAntiCommutativeRingTerm2 n A))
      *OL2 : ((OpAntiCommutativeRingTerm2 n A) -> ((OpAntiCommutativeRingTerm2 n A) -> (OpAntiCommutativeRingTerm2 n A)))
      +OL2 : ((OpAntiCommutativeRingTerm2 n A) -> ((OpAntiCommutativeRingTerm2 n A) -> (OpAntiCommutativeRingTerm2 n A)))
      0OL2 : (OpAntiCommutativeRingTerm2 n A)
      negOL2 : ((OpAntiCommutativeRingTerm2 n A) -> (OpAntiCommutativeRingTerm2 n A))
      1OL2 : (OpAntiCommutativeRingTerm2 n A)
    simplifyCl : {A : Set} -> ((ClAntiCommutativeRingTerm A) -> (ClAntiCommutativeRingTerm A))
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl (*Cl 1Cl x) = x 
    simplifyCl (*Cl x 1Cl) = x 
    simplifyCl (negCl (*Cl y x)) = (*Cl x y) 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 0Cl = 0Cl 
    simplifyCl (negCl x1) = (negCl (simplifyCl x1)) 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpAntiCommutativeRingTerm n) -> (OpAntiCommutativeRingTerm n))
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB (*OL 1OL x) = x 
    simplifyOpB (*OL x 1OL) = x 
    simplifyOpB (negOL (*OL y x)) = (*OL x y) 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 0OL = 0OL 
    simplifyOpB (negOL x1) = (negOL (simplifyOpB x1)) 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpAntiCommutativeRingTerm2 n A) -> (OpAntiCommutativeRingTerm2 n A))
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp (*OL2 1OL2 x) = x 
    simplifyOp (*OL2 x 1OL2) = x 
    simplifyOp (negOL2 (*OL2 y x)) = (*OL2 x y) 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (negOL2 x1) = (negOL2 (simplifyOp x1)) 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((AntiCommutativeRing A) -> (AntiCommutativeRingTerm -> A))
    evalB An (*L x1 x2) = ((* An) (evalB An x1) (evalB An x2)) 
    evalB An (+L x1 x2) = ((+ An) (evalB An x1) (evalB An x2)) 
    evalB An 0L = (0 An) 
    evalB An (negL x1) = ((neg An) (evalB An x1)) 
    evalB An 1L = (1 An) 
    evalCl : {A : Set} -> ((AntiCommutativeRing A) -> ((ClAntiCommutativeRingTerm A) -> A))
    evalCl An (sing x1) = x1 
    evalCl An (*Cl x1 x2) = ((* An) (evalCl An x1) (evalCl An x2)) 
    evalCl An (+Cl x1 x2) = ((+ An) (evalCl An x1) (evalCl An x2)) 
    evalCl An 0Cl = (0 An) 
    evalCl An (negCl x1) = ((neg An) (evalCl An x1)) 
    evalCl An 1Cl = (1 An) 
    evalOpB : {A : Set} {n : Nat} -> ((AntiCommutativeRing A) -> ((Vec A n) -> ((OpAntiCommutativeRingTerm n) -> A)))
    evalOpB An vars (v x1) = (lookup _ x1 vars) 
    evalOpB An vars (*OL x1 x2) = ((* An) (evalOpB An vars x1) (evalOpB An vars x2)) 
    evalOpB An vars (+OL x1 x2) = ((+ An) (evalOpB An vars x1) (evalOpB An vars x2)) 
    evalOpB An vars 0OL = (0 An) 
    evalOpB An vars (negOL x1) = ((neg An) (evalOpB An vars x1)) 
    evalOpB An vars 1OL = (1 An) 
    evalOp : {A : Set} {n : Nat} -> ((AntiCommutativeRing A) -> ((Vec A n) -> ((OpAntiCommutativeRingTerm2 n A) -> A)))
    evalOp An vars (v2 x1) = (lookup _ x1 vars) 
    evalOp An vars (sing2 x1) = x1 
    evalOp An vars (*OL2 x1 x2) = ((* An) (evalOp An vars x1) (evalOp An vars x2)) 
    evalOp An vars (+OL2 x1 x2) = ((+ An) (evalOp An vars x1) (evalOp An vars x2)) 
    evalOp An vars 0OL2 = (0 An) 
    evalOp An vars (negOL2 x1) = ((neg An) (evalOp An vars x1)) 
    evalOp An vars 1OL2 = (1 An) 
    inductionB : {P : (AntiCommutativeRingTerm -> Set)} -> (((x1 x2 : AntiCommutativeRingTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : AntiCommutativeRingTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((P 0L) -> (((x1 : AntiCommutativeRingTerm) -> ((P x1) -> (P (negL x1)))) -> ((P 1L) -> ((x : AntiCommutativeRingTerm) -> (P x)))))))
    inductionB {p} p*l p+l p0l pnegl p1l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l p0l pnegl p1l x1) (inductionB {p} p*l p+l p0l pnegl p1l x2)) 
    inductionB {p} p*l p+l p0l pnegl p1l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l p0l pnegl p1l x1) (inductionB {p} p*l p+l p0l pnegl p1l x2)) 
    inductionB {p} p*l p+l p0l pnegl p1l 0L = p0l 
    inductionB {p} p*l p+l p0l pnegl p1l (negL x1) = (pnegl _ (inductionB {p} p*l p+l p0l pnegl p1l x1)) 
    inductionB {p} p*l p+l p0l pnegl p1l 1L = p1l 
    inductionCl : {A : Set} {P : ((ClAntiCommutativeRingTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClAntiCommutativeRingTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClAntiCommutativeRingTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((P 0Cl) -> (((x1 : (ClAntiCommutativeRingTerm A)) -> ((P x1) -> (P (negCl x1)))) -> ((P 1Cl) -> ((x : (ClAntiCommutativeRingTerm A)) -> (P x))))))))
    inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl p1cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl p1cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl p1cl x1) (inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl p1cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl p1cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl p1cl x1) (inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl p1cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl p1cl 0Cl = p0cl 
    inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl p1cl (negCl x1) = (pnegcl _ (inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl p1cl x1)) 
    inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl p1cl 1Cl = p1cl 
    inductionOpB : {n : Nat} {P : ((OpAntiCommutativeRingTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpAntiCommutativeRingTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpAntiCommutativeRingTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((P 0OL) -> (((x1 : (OpAntiCommutativeRingTerm n)) -> ((P x1) -> (P (negOL x1)))) -> ((P 1OL) -> ((x : (OpAntiCommutativeRingTerm n)) -> (P x))))))))
    inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol p1ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol p1ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol p1ol x1) (inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol p1ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol p1ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol p1ol x1) (inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol p1ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol p1ol 0OL = p0ol 
    inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol p1ol (negOL x1) = (pnegol _ (inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol p1ol x1)) 
    inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol p1ol 1OL = p1ol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpAntiCommutativeRingTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpAntiCommutativeRingTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpAntiCommutativeRingTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((P 0OL2) -> (((x1 : (OpAntiCommutativeRingTerm2 n A)) -> ((P x1) -> (P (negOL2 x1)))) -> ((P 1OL2) -> ((x : (OpAntiCommutativeRingTerm2 n A)) -> (P x)))))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 (negOL2 x1) = (pnegol2 _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 1OL2 = p1ol2 
    *L' : (AntiCommutativeRingTerm -> (AntiCommutativeRingTerm -> AntiCommutativeRingTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (AntiCommutativeRingTerm -> (AntiCommutativeRingTerm -> AntiCommutativeRingTerm))
    +L' x1 x2 = (+L x1 x2) 
    0L' : AntiCommutativeRingTerm
    0L'  = 0L 
    negL' : (AntiCommutativeRingTerm -> AntiCommutativeRingTerm)
    negL' x1 = (negL x1) 
    1L' : AntiCommutativeRingTerm
    1L'  = 1L 
    stageB : (AntiCommutativeRingTerm -> (Staged AntiCommutativeRingTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB 0L = (Now 0L) 
    stageB (negL x1) = (stage1 negL' (codeLift1 negL') (stageB x1)) 
    stageB 1L = (Now 1L) 
    *Cl' : {A : Set} -> ((ClAntiCommutativeRingTerm A) -> ((ClAntiCommutativeRingTerm A) -> (ClAntiCommutativeRingTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClAntiCommutativeRingTerm A) -> ((ClAntiCommutativeRingTerm A) -> (ClAntiCommutativeRingTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    0Cl' : {A : Set} -> (ClAntiCommutativeRingTerm A)
    0Cl'  = 0Cl 
    negCl' : {A : Set} -> ((ClAntiCommutativeRingTerm A) -> (ClAntiCommutativeRingTerm A))
    negCl' x1 = (negCl x1) 
    1Cl' : {A : Set} -> (ClAntiCommutativeRingTerm A)
    1Cl'  = 1Cl 
    stageCl : {A : Set} -> ((ClAntiCommutativeRingTerm A) -> (Staged (ClAntiCommutativeRingTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (negCl x1) = (stage1 negCl' (codeLift1 negCl') (stageCl x1)) 
    stageCl 1Cl = (Now 1Cl) 
    *OL' : {n : Nat} -> ((OpAntiCommutativeRingTerm n) -> ((OpAntiCommutativeRingTerm n) -> (OpAntiCommutativeRingTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpAntiCommutativeRingTerm n) -> ((OpAntiCommutativeRingTerm n) -> (OpAntiCommutativeRingTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    0OL' : {n : Nat} -> (OpAntiCommutativeRingTerm n)
    0OL'  = 0OL 
    negOL' : {n : Nat} -> ((OpAntiCommutativeRingTerm n) -> (OpAntiCommutativeRingTerm n))
    negOL' x1 = (negOL x1) 
    1OL' : {n : Nat} -> (OpAntiCommutativeRingTerm n)
    1OL'  = 1OL 
    stageOpB : {n : Nat} -> ((OpAntiCommutativeRingTerm n) -> (Staged (OpAntiCommutativeRingTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (negOL x1) = (stage1 negOL' (codeLift1 negOL') (stageOpB x1)) 
    stageOpB 1OL = (Now 1OL) 
    *OL2' : {n : Nat} {A : Set} -> ((OpAntiCommutativeRingTerm2 n A) -> ((OpAntiCommutativeRingTerm2 n A) -> (OpAntiCommutativeRingTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpAntiCommutativeRingTerm2 n A) -> ((OpAntiCommutativeRingTerm2 n A) -> (OpAntiCommutativeRingTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    0OL2' : {n : Nat} {A : Set} -> (OpAntiCommutativeRingTerm2 n A)
    0OL2'  = 0OL2 
    negOL2' : {n : Nat} {A : Set} -> ((OpAntiCommutativeRingTerm2 n A) -> (OpAntiCommutativeRingTerm2 n A))
    negOL2' x1 = (negOL2 x1) 
    1OL2' : {n : Nat} {A : Set} -> (OpAntiCommutativeRingTerm2 n A)
    1OL2'  = 1OL2 
    stageOp : {n : Nat} {A : Set} -> ((OpAntiCommutativeRingTerm2 n A) -> (Staged (OpAntiCommutativeRingTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (negOL2 x1) = (stage1 negOL2' (codeLift1 negOL2') (stageOp x1)) 
    stageOp 1OL2 = (Now 1OL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        0T : (Repr A)
        negT : ((Repr A) -> (Repr A))
        1T : (Repr A)
  module AssocPlusRingoid  where
    record AssocPlusRingoid (A : Set) : Set where
      constructor AssocPlusRingoidC
      field
        + : (A -> (A -> A))
        * : (A -> (A -> A))
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        +S : (AS -> (AS -> AS))
        *S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
    record Hom {A1 : Set} {A2 : Set} (As1 : (AssocPlusRingoid A1)) (As2 : (AssocPlusRingoid A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ As1) x1 x2)) == ((+ As2) (hom x1) (hom x2))
        pres-* : {x1 x2 : A1} -> (hom ((* As1) x1 x2)) == ((* As2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (As1 : (AssocPlusRingoid A1)) (As2 : (AssocPlusRingoid A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ As1) x1 x2) ((+ As2) y1 y2))))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* As1) x1 x2) ((* As2) y1 y2))))
    data AssocPlusRingoidTerm  : Set where
      +L : (AssocPlusRingoidTerm -> (AssocPlusRingoidTerm -> AssocPlusRingoidTerm))
      *L : (AssocPlusRingoidTerm -> (AssocPlusRingoidTerm -> AssocPlusRingoidTerm))
    data ClAssocPlusRingoidTerm (A : Set) : Set where
      sing : (A -> (ClAssocPlusRingoidTerm A))
      +Cl : ((ClAssocPlusRingoidTerm A) -> ((ClAssocPlusRingoidTerm A) -> (ClAssocPlusRingoidTerm A)))
      *Cl : ((ClAssocPlusRingoidTerm A) -> ((ClAssocPlusRingoidTerm A) -> (ClAssocPlusRingoidTerm A)))
    data OpAssocPlusRingoidTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpAssocPlusRingoidTerm n))
      +OL : ((OpAssocPlusRingoidTerm n) -> ((OpAssocPlusRingoidTerm n) -> (OpAssocPlusRingoidTerm n)))
      *OL : ((OpAssocPlusRingoidTerm n) -> ((OpAssocPlusRingoidTerm n) -> (OpAssocPlusRingoidTerm n)))
    data OpAssocPlusRingoidTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpAssocPlusRingoidTerm2 n A))
      sing2 : (A -> (OpAssocPlusRingoidTerm2 n A))
      +OL2 : ((OpAssocPlusRingoidTerm2 n A) -> ((OpAssocPlusRingoidTerm2 n A) -> (OpAssocPlusRingoidTerm2 n A)))
      *OL2 : ((OpAssocPlusRingoidTerm2 n A) -> ((OpAssocPlusRingoidTerm2 n A) -> (OpAssocPlusRingoidTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClAssocPlusRingoidTerm A) -> (ClAssocPlusRingoidTerm A))
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpAssocPlusRingoidTerm n) -> (OpAssocPlusRingoidTerm n))
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpAssocPlusRingoidTerm2 n A) -> (OpAssocPlusRingoidTerm2 n A))
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((AssocPlusRingoid A) -> (AssocPlusRingoidTerm -> A))
    evalB As (+L x1 x2) = ((+ As) (evalB As x1) (evalB As x2)) 
    evalB As (*L x1 x2) = ((* As) (evalB As x1) (evalB As x2)) 
    evalCl : {A : Set} -> ((AssocPlusRingoid A) -> ((ClAssocPlusRingoidTerm A) -> A))
    evalCl As (sing x1) = x1 
    evalCl As (+Cl x1 x2) = ((+ As) (evalCl As x1) (evalCl As x2)) 
    evalCl As (*Cl x1 x2) = ((* As) (evalCl As x1) (evalCl As x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((AssocPlusRingoid A) -> ((Vec A n) -> ((OpAssocPlusRingoidTerm n) -> A)))
    evalOpB As vars (v x1) = (lookup _ x1 vars) 
    evalOpB As vars (+OL x1 x2) = ((+ As) (evalOpB As vars x1) (evalOpB As vars x2)) 
    evalOpB As vars (*OL x1 x2) = ((* As) (evalOpB As vars x1) (evalOpB As vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((AssocPlusRingoid A) -> ((Vec A n) -> ((OpAssocPlusRingoidTerm2 n A) -> A)))
    evalOp As vars (v2 x1) = (lookup _ x1 vars) 
    evalOp As vars (sing2 x1) = x1 
    evalOp As vars (+OL2 x1 x2) = ((+ As) (evalOp As vars x1) (evalOp As vars x2)) 
    evalOp As vars (*OL2 x1 x2) = ((* As) (evalOp As vars x1) (evalOp As vars x2)) 
    inductionB : {P : (AssocPlusRingoidTerm -> Set)} -> (((x1 x2 : AssocPlusRingoidTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> (((x1 x2 : AssocPlusRingoidTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((x : AssocPlusRingoidTerm) -> (P x))))
    inductionB {p} p+l p*l (+L x1 x2) = (p+l _ _ (inductionB {p} p+l p*l x1) (inductionB {p} p+l p*l x2)) 
    inductionB {p} p+l p*l (*L x1 x2) = (p*l _ _ (inductionB {p} p+l p*l x1) (inductionB {p} p+l p*l x2)) 
    inductionCl : {A : Set} {P : ((ClAssocPlusRingoidTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClAssocPlusRingoidTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> (((x1 x2 : (ClAssocPlusRingoidTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((x : (ClAssocPlusRingoidTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p+cl p*cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p+cl p*cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p+cl p*cl x1) (inductionCl {_} {p} psing p+cl p*cl x2)) 
    inductionCl {_} {p} psing p+cl p*cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p+cl p*cl x1) (inductionCl {_} {p} psing p+cl p*cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpAssocPlusRingoidTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpAssocPlusRingoidTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> (((x1 x2 : (OpAssocPlusRingoidTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((x : (OpAssocPlusRingoidTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p+ol p*ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p+ol p*ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p+ol p*ol x1) (inductionOpB {_} {p} pv p+ol p*ol x2)) 
    inductionOpB {_} {p} pv p+ol p*ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p+ol p*ol x1) (inductionOpB {_} {p} pv p+ol p*ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpAssocPlusRingoidTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpAssocPlusRingoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> (((x1 x2 : (OpAssocPlusRingoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((x : (OpAssocPlusRingoidTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 x2)) 
    +L' : (AssocPlusRingoidTerm -> (AssocPlusRingoidTerm -> AssocPlusRingoidTerm))
    +L' x1 x2 = (+L x1 x2) 
    *L' : (AssocPlusRingoidTerm -> (AssocPlusRingoidTerm -> AssocPlusRingoidTerm))
    *L' x1 x2 = (*L x1 x2) 
    stageB : (AssocPlusRingoidTerm -> (Staged AssocPlusRingoidTerm))
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    +Cl' : {A : Set} -> ((ClAssocPlusRingoidTerm A) -> ((ClAssocPlusRingoidTerm A) -> (ClAssocPlusRingoidTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    *Cl' : {A : Set} -> ((ClAssocPlusRingoidTerm A) -> ((ClAssocPlusRingoidTerm A) -> (ClAssocPlusRingoidTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    stageCl : {A : Set} -> ((ClAssocPlusRingoidTerm A) -> (Staged (ClAssocPlusRingoidTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    +OL' : {n : Nat} -> ((OpAssocPlusRingoidTerm n) -> ((OpAssocPlusRingoidTerm n) -> (OpAssocPlusRingoidTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    *OL' : {n : Nat} -> ((OpAssocPlusRingoidTerm n) -> ((OpAssocPlusRingoidTerm n) -> (OpAssocPlusRingoidTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpAssocPlusRingoidTerm n) -> (Staged (OpAssocPlusRingoidTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    +OL2' : {n : Nat} {A : Set} -> ((OpAssocPlusRingoidTerm2 n A) -> ((OpAssocPlusRingoidTerm2 n A) -> (OpAssocPlusRingoidTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    *OL2' : {n : Nat} {A : Set} -> ((OpAssocPlusRingoidTerm2 n A) -> ((OpAssocPlusRingoidTerm2 n A) -> (OpAssocPlusRingoidTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpAssocPlusRingoidTerm2 n A) -> (Staged (OpAssocPlusRingoidTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module AssocTimesRingoid  where
    record AssocTimesRingoid (A : Set) : Set where
      constructor AssocTimesRingoidC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
    record Hom {A1 : Set} {A2 : Set} (As1 : (AssocTimesRingoid A1)) (As2 : (AssocTimesRingoid A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* As1) x1 x2)) == ((* As2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ As1) x1 x2)) == ((+ As2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (As1 : (AssocTimesRingoid A1)) (As2 : (AssocTimesRingoid A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* As1) x1 x2) ((* As2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ As1) x1 x2) ((+ As2) y1 y2))))
    data AssocTimesRingoidTerm  : Set where
      *L : (AssocTimesRingoidTerm -> (AssocTimesRingoidTerm -> AssocTimesRingoidTerm))
      +L : (AssocTimesRingoidTerm -> (AssocTimesRingoidTerm -> AssocTimesRingoidTerm))
    data ClAssocTimesRingoidTerm (A : Set) : Set where
      sing : (A -> (ClAssocTimesRingoidTerm A))
      *Cl : ((ClAssocTimesRingoidTerm A) -> ((ClAssocTimesRingoidTerm A) -> (ClAssocTimesRingoidTerm A)))
      +Cl : ((ClAssocTimesRingoidTerm A) -> ((ClAssocTimesRingoidTerm A) -> (ClAssocTimesRingoidTerm A)))
    data OpAssocTimesRingoidTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpAssocTimesRingoidTerm n))
      *OL : ((OpAssocTimesRingoidTerm n) -> ((OpAssocTimesRingoidTerm n) -> (OpAssocTimesRingoidTerm n)))
      +OL : ((OpAssocTimesRingoidTerm n) -> ((OpAssocTimesRingoidTerm n) -> (OpAssocTimesRingoidTerm n)))
    data OpAssocTimesRingoidTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpAssocTimesRingoidTerm2 n A))
      sing2 : (A -> (OpAssocTimesRingoidTerm2 n A))
      *OL2 : ((OpAssocTimesRingoidTerm2 n A) -> ((OpAssocTimesRingoidTerm2 n A) -> (OpAssocTimesRingoidTerm2 n A)))
      +OL2 : ((OpAssocTimesRingoidTerm2 n A) -> ((OpAssocTimesRingoidTerm2 n A) -> (OpAssocTimesRingoidTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClAssocTimesRingoidTerm A) -> (ClAssocTimesRingoidTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpAssocTimesRingoidTerm n) -> (OpAssocTimesRingoidTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpAssocTimesRingoidTerm2 n A) -> (OpAssocTimesRingoidTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((AssocTimesRingoid A) -> (AssocTimesRingoidTerm -> A))
    evalB As (*L x1 x2) = ((* As) (evalB As x1) (evalB As x2)) 
    evalB As (+L x1 x2) = ((+ As) (evalB As x1) (evalB As x2)) 
    evalCl : {A : Set} -> ((AssocTimesRingoid A) -> ((ClAssocTimesRingoidTerm A) -> A))
    evalCl As (sing x1) = x1 
    evalCl As (*Cl x1 x2) = ((* As) (evalCl As x1) (evalCl As x2)) 
    evalCl As (+Cl x1 x2) = ((+ As) (evalCl As x1) (evalCl As x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((AssocTimesRingoid A) -> ((Vec A n) -> ((OpAssocTimesRingoidTerm n) -> A)))
    evalOpB As vars (v x1) = (lookup _ x1 vars) 
    evalOpB As vars (*OL x1 x2) = ((* As) (evalOpB As vars x1) (evalOpB As vars x2)) 
    evalOpB As vars (+OL x1 x2) = ((+ As) (evalOpB As vars x1) (evalOpB As vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((AssocTimesRingoid A) -> ((Vec A n) -> ((OpAssocTimesRingoidTerm2 n A) -> A)))
    evalOp As vars (v2 x1) = (lookup _ x1 vars) 
    evalOp As vars (sing2 x1) = x1 
    evalOp As vars (*OL2 x1 x2) = ((* As) (evalOp As vars x1) (evalOp As vars x2)) 
    evalOp As vars (+OL2 x1 x2) = ((+ As) (evalOp As vars x1) (evalOp As vars x2)) 
    inductionB : {P : (AssocTimesRingoidTerm -> Set)} -> (((x1 x2 : AssocTimesRingoidTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : AssocTimesRingoidTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : AssocTimesRingoidTerm) -> (P x))))
    inductionB {p} p*l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionB {p} p*l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClAssocTimesRingoidTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClAssocTimesRingoidTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClAssocTimesRingoidTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClAssocTimesRingoidTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p*cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpAssocTimesRingoidTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpAssocTimesRingoidTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpAssocTimesRingoidTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpAssocTimesRingoidTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p*ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpAssocTimesRingoidTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpAssocTimesRingoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpAssocTimesRingoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpAssocTimesRingoidTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    *L' : (AssocTimesRingoidTerm -> (AssocTimesRingoidTerm -> AssocTimesRingoidTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (AssocTimesRingoidTerm -> (AssocTimesRingoidTerm -> AssocTimesRingoidTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (AssocTimesRingoidTerm -> (Staged AssocTimesRingoidTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClAssocTimesRingoidTerm A) -> ((ClAssocTimesRingoidTerm A) -> (ClAssocTimesRingoidTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClAssocTimesRingoidTerm A) -> ((ClAssocTimesRingoidTerm A) -> (ClAssocTimesRingoidTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClAssocTimesRingoidTerm A) -> (Staged (ClAssocTimesRingoidTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpAssocTimesRingoidTerm n) -> ((OpAssocTimesRingoidTerm n) -> (OpAssocTimesRingoidTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpAssocTimesRingoidTerm n) -> ((OpAssocTimesRingoidTerm n) -> (OpAssocTimesRingoidTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpAssocTimesRingoidTerm n) -> (Staged (OpAssocTimesRingoidTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpAssocTimesRingoidTerm2 n A) -> ((OpAssocTimesRingoidTerm2 n A) -> (OpAssocTimesRingoidTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpAssocTimesRingoidTerm2 n A) -> ((OpAssocTimesRingoidTerm2 n A) -> (OpAssocTimesRingoidTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpAssocTimesRingoidTerm2 n A) -> (Staged (OpAssocTimesRingoidTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module AssociativeLeftRingoid  where
    record AssociativeLeftRingoid (A : Set) : Set where
      constructor AssociativeLeftRingoidC
      field
        * : (A -> (A -> A))
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        + : (A -> (A -> A))
        leftDistributive_*_+ : {x y z : A} -> (* x (+ y z)) == (+ (* x y) (* x z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        leftDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P xP (+P yP zP)) == (+P (*P xP yP) (*P xP zP))
    record Hom {A1 : Set} {A2 : Set} (As1 : (AssociativeLeftRingoid A1)) (As2 : (AssociativeLeftRingoid A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* As1) x1 x2)) == ((* As2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ As1) x1 x2)) == ((+ As2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (As1 : (AssociativeLeftRingoid A1)) (As2 : (AssociativeLeftRingoid A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* As1) x1 x2) ((* As2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ As1) x1 x2) ((+ As2) y1 y2))))
    data AssociativeLeftRingoidTerm  : Set where
      *L : (AssociativeLeftRingoidTerm -> (AssociativeLeftRingoidTerm -> AssociativeLeftRingoidTerm))
      +L : (AssociativeLeftRingoidTerm -> (AssociativeLeftRingoidTerm -> AssociativeLeftRingoidTerm))
    data ClAssociativeLeftRingoidTerm (A : Set) : Set where
      sing : (A -> (ClAssociativeLeftRingoidTerm A))
      *Cl : ((ClAssociativeLeftRingoidTerm A) -> ((ClAssociativeLeftRingoidTerm A) -> (ClAssociativeLeftRingoidTerm A)))
      +Cl : ((ClAssociativeLeftRingoidTerm A) -> ((ClAssociativeLeftRingoidTerm A) -> (ClAssociativeLeftRingoidTerm A)))
    data OpAssociativeLeftRingoidTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpAssociativeLeftRingoidTerm n))
      *OL : ((OpAssociativeLeftRingoidTerm n) -> ((OpAssociativeLeftRingoidTerm n) -> (OpAssociativeLeftRingoidTerm n)))
      +OL : ((OpAssociativeLeftRingoidTerm n) -> ((OpAssociativeLeftRingoidTerm n) -> (OpAssociativeLeftRingoidTerm n)))
    data OpAssociativeLeftRingoidTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpAssociativeLeftRingoidTerm2 n A))
      sing2 : (A -> (OpAssociativeLeftRingoidTerm2 n A))
      *OL2 : ((OpAssociativeLeftRingoidTerm2 n A) -> ((OpAssociativeLeftRingoidTerm2 n A) -> (OpAssociativeLeftRingoidTerm2 n A)))
      +OL2 : ((OpAssociativeLeftRingoidTerm2 n A) -> ((OpAssociativeLeftRingoidTerm2 n A) -> (OpAssociativeLeftRingoidTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClAssociativeLeftRingoidTerm A) -> (ClAssociativeLeftRingoidTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpAssociativeLeftRingoidTerm n) -> (OpAssociativeLeftRingoidTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpAssociativeLeftRingoidTerm2 n A) -> (OpAssociativeLeftRingoidTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((AssociativeLeftRingoid A) -> (AssociativeLeftRingoidTerm -> A))
    evalB As (*L x1 x2) = ((* As) (evalB As x1) (evalB As x2)) 
    evalB As (+L x1 x2) = ((+ As) (evalB As x1) (evalB As x2)) 
    evalCl : {A : Set} -> ((AssociativeLeftRingoid A) -> ((ClAssociativeLeftRingoidTerm A) -> A))
    evalCl As (sing x1) = x1 
    evalCl As (*Cl x1 x2) = ((* As) (evalCl As x1) (evalCl As x2)) 
    evalCl As (+Cl x1 x2) = ((+ As) (evalCl As x1) (evalCl As x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((AssociativeLeftRingoid A) -> ((Vec A n) -> ((OpAssociativeLeftRingoidTerm n) -> A)))
    evalOpB As vars (v x1) = (lookup _ x1 vars) 
    evalOpB As vars (*OL x1 x2) = ((* As) (evalOpB As vars x1) (evalOpB As vars x2)) 
    evalOpB As vars (+OL x1 x2) = ((+ As) (evalOpB As vars x1) (evalOpB As vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((AssociativeLeftRingoid A) -> ((Vec A n) -> ((OpAssociativeLeftRingoidTerm2 n A) -> A)))
    evalOp As vars (v2 x1) = (lookup _ x1 vars) 
    evalOp As vars (sing2 x1) = x1 
    evalOp As vars (*OL2 x1 x2) = ((* As) (evalOp As vars x1) (evalOp As vars x2)) 
    evalOp As vars (+OL2 x1 x2) = ((+ As) (evalOp As vars x1) (evalOp As vars x2)) 
    inductionB : {P : (AssociativeLeftRingoidTerm -> Set)} -> (((x1 x2 : AssociativeLeftRingoidTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : AssociativeLeftRingoidTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : AssociativeLeftRingoidTerm) -> (P x))))
    inductionB {p} p*l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionB {p} p*l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClAssociativeLeftRingoidTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClAssociativeLeftRingoidTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClAssociativeLeftRingoidTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClAssociativeLeftRingoidTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p*cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpAssociativeLeftRingoidTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpAssociativeLeftRingoidTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpAssociativeLeftRingoidTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpAssociativeLeftRingoidTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p*ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpAssociativeLeftRingoidTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpAssociativeLeftRingoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpAssociativeLeftRingoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpAssociativeLeftRingoidTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    *L' : (AssociativeLeftRingoidTerm -> (AssociativeLeftRingoidTerm -> AssociativeLeftRingoidTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (AssociativeLeftRingoidTerm -> (AssociativeLeftRingoidTerm -> AssociativeLeftRingoidTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (AssociativeLeftRingoidTerm -> (Staged AssociativeLeftRingoidTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClAssociativeLeftRingoidTerm A) -> ((ClAssociativeLeftRingoidTerm A) -> (ClAssociativeLeftRingoidTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClAssociativeLeftRingoidTerm A) -> ((ClAssociativeLeftRingoidTerm A) -> (ClAssociativeLeftRingoidTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClAssociativeLeftRingoidTerm A) -> (Staged (ClAssociativeLeftRingoidTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpAssociativeLeftRingoidTerm n) -> ((OpAssociativeLeftRingoidTerm n) -> (OpAssociativeLeftRingoidTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpAssociativeLeftRingoidTerm n) -> ((OpAssociativeLeftRingoidTerm n) -> (OpAssociativeLeftRingoidTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpAssociativeLeftRingoidTerm n) -> (Staged (OpAssociativeLeftRingoidTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpAssociativeLeftRingoidTerm2 n A) -> ((OpAssociativeLeftRingoidTerm2 n A) -> (OpAssociativeLeftRingoidTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpAssociativeLeftRingoidTerm2 n A) -> ((OpAssociativeLeftRingoidTerm2 n A) -> (OpAssociativeLeftRingoidTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpAssociativeLeftRingoidTerm2 n A) -> (Staged (OpAssociativeLeftRingoidTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module AssociativeNonDistributiveRingoid  where
    record AssociativeNonDistributiveRingoid (A : Set) : Set where
      constructor AssociativeNonDistributiveRingoidC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
    record Hom {A1 : Set} {A2 : Set} (As1 : (AssociativeNonDistributiveRingoid A1)) (As2 : (AssociativeNonDistributiveRingoid A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* As1) x1 x2)) == ((* As2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ As1) x1 x2)) == ((+ As2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (As1 : (AssociativeNonDistributiveRingoid A1)) (As2 : (AssociativeNonDistributiveRingoid A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* As1) x1 x2) ((* As2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ As1) x1 x2) ((+ As2) y1 y2))))
    data AssociativeNonDistributiveRingoidTerm  : Set where
      *L : (AssociativeNonDistributiveRingoidTerm -> (AssociativeNonDistributiveRingoidTerm -> AssociativeNonDistributiveRingoidTerm))
      +L : (AssociativeNonDistributiveRingoidTerm -> (AssociativeNonDistributiveRingoidTerm -> AssociativeNonDistributiveRingoidTerm))
    data ClAssociativeNonDistributiveRingoidTerm (A : Set) : Set where
      sing : (A -> (ClAssociativeNonDistributiveRingoidTerm A))
      *Cl : ((ClAssociativeNonDistributiveRingoidTerm A) -> ((ClAssociativeNonDistributiveRingoidTerm A) -> (ClAssociativeNonDistributiveRingoidTerm A)))
      +Cl : ((ClAssociativeNonDistributiveRingoidTerm A) -> ((ClAssociativeNonDistributiveRingoidTerm A) -> (ClAssociativeNonDistributiveRingoidTerm A)))
    data OpAssociativeNonDistributiveRingoidTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpAssociativeNonDistributiveRingoidTerm n))
      *OL : ((OpAssociativeNonDistributiveRingoidTerm n) -> ((OpAssociativeNonDistributiveRingoidTerm n) -> (OpAssociativeNonDistributiveRingoidTerm n)))
      +OL : ((OpAssociativeNonDistributiveRingoidTerm n) -> ((OpAssociativeNonDistributiveRingoidTerm n) -> (OpAssociativeNonDistributiveRingoidTerm n)))
    data OpAssociativeNonDistributiveRingoidTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpAssociativeNonDistributiveRingoidTerm2 n A))
      sing2 : (A -> (OpAssociativeNonDistributiveRingoidTerm2 n A))
      *OL2 : ((OpAssociativeNonDistributiveRingoidTerm2 n A) -> ((OpAssociativeNonDistributiveRingoidTerm2 n A) -> (OpAssociativeNonDistributiveRingoidTerm2 n A)))
      +OL2 : ((OpAssociativeNonDistributiveRingoidTerm2 n A) -> ((OpAssociativeNonDistributiveRingoidTerm2 n A) -> (OpAssociativeNonDistributiveRingoidTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClAssociativeNonDistributiveRingoidTerm A) -> (ClAssociativeNonDistributiveRingoidTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpAssociativeNonDistributiveRingoidTerm n) -> (OpAssociativeNonDistributiveRingoidTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpAssociativeNonDistributiveRingoidTerm2 n A) -> (OpAssociativeNonDistributiveRingoidTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((AssociativeNonDistributiveRingoid A) -> (AssociativeNonDistributiveRingoidTerm -> A))
    evalB As (*L x1 x2) = ((* As) (evalB As x1) (evalB As x2)) 
    evalB As (+L x1 x2) = ((+ As) (evalB As x1) (evalB As x2)) 
    evalCl : {A : Set} -> ((AssociativeNonDistributiveRingoid A) -> ((ClAssociativeNonDistributiveRingoidTerm A) -> A))
    evalCl As (sing x1) = x1 
    evalCl As (*Cl x1 x2) = ((* As) (evalCl As x1) (evalCl As x2)) 
    evalCl As (+Cl x1 x2) = ((+ As) (evalCl As x1) (evalCl As x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((AssociativeNonDistributiveRingoid A) -> ((Vec A n) -> ((OpAssociativeNonDistributiveRingoidTerm n) -> A)))
    evalOpB As vars (v x1) = (lookup _ x1 vars) 
    evalOpB As vars (*OL x1 x2) = ((* As) (evalOpB As vars x1) (evalOpB As vars x2)) 
    evalOpB As vars (+OL x1 x2) = ((+ As) (evalOpB As vars x1) (evalOpB As vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((AssociativeNonDistributiveRingoid A) -> ((Vec A n) -> ((OpAssociativeNonDistributiveRingoidTerm2 n A) -> A)))
    evalOp As vars (v2 x1) = (lookup _ x1 vars) 
    evalOp As vars (sing2 x1) = x1 
    evalOp As vars (*OL2 x1 x2) = ((* As) (evalOp As vars x1) (evalOp As vars x2)) 
    evalOp As vars (+OL2 x1 x2) = ((+ As) (evalOp As vars x1) (evalOp As vars x2)) 
    inductionB : {P : (AssociativeNonDistributiveRingoidTerm -> Set)} -> (((x1 x2 : AssociativeNonDistributiveRingoidTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : AssociativeNonDistributiveRingoidTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : AssociativeNonDistributiveRingoidTerm) -> (P x))))
    inductionB {p} p*l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionB {p} p*l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClAssociativeNonDistributiveRingoidTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClAssociativeNonDistributiveRingoidTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClAssociativeNonDistributiveRingoidTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClAssociativeNonDistributiveRingoidTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p*cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpAssociativeNonDistributiveRingoidTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpAssociativeNonDistributiveRingoidTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpAssociativeNonDistributiveRingoidTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpAssociativeNonDistributiveRingoidTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p*ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpAssociativeNonDistributiveRingoidTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpAssociativeNonDistributiveRingoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpAssociativeNonDistributiveRingoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpAssociativeNonDistributiveRingoidTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    *L' : (AssociativeNonDistributiveRingoidTerm -> (AssociativeNonDistributiveRingoidTerm -> AssociativeNonDistributiveRingoidTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (AssociativeNonDistributiveRingoidTerm -> (AssociativeNonDistributiveRingoidTerm -> AssociativeNonDistributiveRingoidTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (AssociativeNonDistributiveRingoidTerm -> (Staged AssociativeNonDistributiveRingoidTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClAssociativeNonDistributiveRingoidTerm A) -> ((ClAssociativeNonDistributiveRingoidTerm A) -> (ClAssociativeNonDistributiveRingoidTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClAssociativeNonDistributiveRingoidTerm A) -> ((ClAssociativeNonDistributiveRingoidTerm A) -> (ClAssociativeNonDistributiveRingoidTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClAssociativeNonDistributiveRingoidTerm A) -> (Staged (ClAssociativeNonDistributiveRingoidTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpAssociativeNonDistributiveRingoidTerm n) -> ((OpAssociativeNonDistributiveRingoidTerm n) -> (OpAssociativeNonDistributiveRingoidTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpAssociativeNonDistributiveRingoidTerm n) -> ((OpAssociativeNonDistributiveRingoidTerm n) -> (OpAssociativeNonDistributiveRingoidTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpAssociativeNonDistributiveRingoidTerm n) -> (Staged (OpAssociativeNonDistributiveRingoidTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpAssociativeNonDistributiveRingoidTerm2 n A) -> ((OpAssociativeNonDistributiveRingoidTerm2 n A) -> (OpAssociativeNonDistributiveRingoidTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpAssociativeNonDistributiveRingoidTerm2 n A) -> ((OpAssociativeNonDistributiveRingoidTerm2 n A) -> (OpAssociativeNonDistributiveRingoidTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpAssociativeNonDistributiveRingoidTerm2 n A) -> (Staged (OpAssociativeNonDistributiveRingoidTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module AssociativeRightRingoid  where
    record AssociativeRightRingoid (A : Set) : Set where
      constructor AssociativeRightRingoidC
      field
        * : (A -> (A -> A))
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        + : (A -> (A -> A))
        rightDistributive_*_+ : {x y z : A} -> (* (+ y z) x) == (+ (* y x) (* z x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        rightDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P (+P yP zP) xP) == (+P (*P yP xP) (*P zP xP))
    record Hom {A1 : Set} {A2 : Set} (As1 : (AssociativeRightRingoid A1)) (As2 : (AssociativeRightRingoid A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* As1) x1 x2)) == ((* As2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ As1) x1 x2)) == ((+ As2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (As1 : (AssociativeRightRingoid A1)) (As2 : (AssociativeRightRingoid A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* As1) x1 x2) ((* As2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ As1) x1 x2) ((+ As2) y1 y2))))
    data AssociativeRightRingoidTerm  : Set where
      *L : (AssociativeRightRingoidTerm -> (AssociativeRightRingoidTerm -> AssociativeRightRingoidTerm))
      +L : (AssociativeRightRingoidTerm -> (AssociativeRightRingoidTerm -> AssociativeRightRingoidTerm))
    data ClAssociativeRightRingoidTerm (A : Set) : Set where
      sing : (A -> (ClAssociativeRightRingoidTerm A))
      *Cl : ((ClAssociativeRightRingoidTerm A) -> ((ClAssociativeRightRingoidTerm A) -> (ClAssociativeRightRingoidTerm A)))
      +Cl : ((ClAssociativeRightRingoidTerm A) -> ((ClAssociativeRightRingoidTerm A) -> (ClAssociativeRightRingoidTerm A)))
    data OpAssociativeRightRingoidTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpAssociativeRightRingoidTerm n))
      *OL : ((OpAssociativeRightRingoidTerm n) -> ((OpAssociativeRightRingoidTerm n) -> (OpAssociativeRightRingoidTerm n)))
      +OL : ((OpAssociativeRightRingoidTerm n) -> ((OpAssociativeRightRingoidTerm n) -> (OpAssociativeRightRingoidTerm n)))
    data OpAssociativeRightRingoidTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpAssociativeRightRingoidTerm2 n A))
      sing2 : (A -> (OpAssociativeRightRingoidTerm2 n A))
      *OL2 : ((OpAssociativeRightRingoidTerm2 n A) -> ((OpAssociativeRightRingoidTerm2 n A) -> (OpAssociativeRightRingoidTerm2 n A)))
      +OL2 : ((OpAssociativeRightRingoidTerm2 n A) -> ((OpAssociativeRightRingoidTerm2 n A) -> (OpAssociativeRightRingoidTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClAssociativeRightRingoidTerm A) -> (ClAssociativeRightRingoidTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpAssociativeRightRingoidTerm n) -> (OpAssociativeRightRingoidTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpAssociativeRightRingoidTerm2 n A) -> (OpAssociativeRightRingoidTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((AssociativeRightRingoid A) -> (AssociativeRightRingoidTerm -> A))
    evalB As (*L x1 x2) = ((* As) (evalB As x1) (evalB As x2)) 
    evalB As (+L x1 x2) = ((+ As) (evalB As x1) (evalB As x2)) 
    evalCl : {A : Set} -> ((AssociativeRightRingoid A) -> ((ClAssociativeRightRingoidTerm A) -> A))
    evalCl As (sing x1) = x1 
    evalCl As (*Cl x1 x2) = ((* As) (evalCl As x1) (evalCl As x2)) 
    evalCl As (+Cl x1 x2) = ((+ As) (evalCl As x1) (evalCl As x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((AssociativeRightRingoid A) -> ((Vec A n) -> ((OpAssociativeRightRingoidTerm n) -> A)))
    evalOpB As vars (v x1) = (lookup _ x1 vars) 
    evalOpB As vars (*OL x1 x2) = ((* As) (evalOpB As vars x1) (evalOpB As vars x2)) 
    evalOpB As vars (+OL x1 x2) = ((+ As) (evalOpB As vars x1) (evalOpB As vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((AssociativeRightRingoid A) -> ((Vec A n) -> ((OpAssociativeRightRingoidTerm2 n A) -> A)))
    evalOp As vars (v2 x1) = (lookup _ x1 vars) 
    evalOp As vars (sing2 x1) = x1 
    evalOp As vars (*OL2 x1 x2) = ((* As) (evalOp As vars x1) (evalOp As vars x2)) 
    evalOp As vars (+OL2 x1 x2) = ((+ As) (evalOp As vars x1) (evalOp As vars x2)) 
    inductionB : {P : (AssociativeRightRingoidTerm -> Set)} -> (((x1 x2 : AssociativeRightRingoidTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : AssociativeRightRingoidTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : AssociativeRightRingoidTerm) -> (P x))))
    inductionB {p} p*l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionB {p} p*l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClAssociativeRightRingoidTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClAssociativeRightRingoidTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClAssociativeRightRingoidTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClAssociativeRightRingoidTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p*cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpAssociativeRightRingoidTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpAssociativeRightRingoidTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpAssociativeRightRingoidTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpAssociativeRightRingoidTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p*ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpAssociativeRightRingoidTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpAssociativeRightRingoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpAssociativeRightRingoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpAssociativeRightRingoidTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    *L' : (AssociativeRightRingoidTerm -> (AssociativeRightRingoidTerm -> AssociativeRightRingoidTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (AssociativeRightRingoidTerm -> (AssociativeRightRingoidTerm -> AssociativeRightRingoidTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (AssociativeRightRingoidTerm -> (Staged AssociativeRightRingoidTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClAssociativeRightRingoidTerm A) -> ((ClAssociativeRightRingoidTerm A) -> (ClAssociativeRightRingoidTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClAssociativeRightRingoidTerm A) -> ((ClAssociativeRightRingoidTerm A) -> (ClAssociativeRightRingoidTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClAssociativeRightRingoidTerm A) -> (Staged (ClAssociativeRightRingoidTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpAssociativeRightRingoidTerm n) -> ((OpAssociativeRightRingoidTerm n) -> (OpAssociativeRightRingoidTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpAssociativeRightRingoidTerm n) -> ((OpAssociativeRightRingoidTerm n) -> (OpAssociativeRightRingoidTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpAssociativeRightRingoidTerm n) -> (Staged (OpAssociativeRightRingoidTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpAssociativeRightRingoidTerm2 n A) -> ((OpAssociativeRightRingoidTerm2 n A) -> (OpAssociativeRightRingoidTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpAssociativeRightRingoidTerm2 n A) -> ((OpAssociativeRightRingoidTerm2 n A) -> (OpAssociativeRightRingoidTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpAssociativeRightRingoidTerm2 n A) -> (Staged (OpAssociativeRightRingoidTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module Band  where
    record Band (A : Set) : Set where
      constructor BandC
      field
        op : (A -> (A -> A))
        associative_op : {x y z : A} -> (op (op x y) z) == (op x (op y z))
        idempotent_op : {x : A} -> (op x x) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        associative_opP : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP (opP yP zP))
        idempotent_opP : {xP : (Prod A A)} -> (opP xP xP) == xP
    record Hom {A1 : Set} {A2 : Set} (Ba1 : (Band A1)) (Ba2 : (Band A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Ba1) x1 x2)) == ((op Ba2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ba1 : (Band A1)) (Ba2 : (Band A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Ba1) x1 x2) ((op Ba2) y1 y2))))
    data BandTerm  : Set where
      opL : (BandTerm -> (BandTerm -> BandTerm))
    data ClBandTerm (A : Set) : Set where
      sing : (A -> (ClBandTerm A))
      opCl : ((ClBandTerm A) -> ((ClBandTerm A) -> (ClBandTerm A)))
    data OpBandTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpBandTerm n))
      opOL : ((OpBandTerm n) -> ((OpBandTerm n) -> (OpBandTerm n)))
    data OpBandTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpBandTerm2 n A))
      sing2 : (A -> (OpBandTerm2 n A))
      opOL2 : ((OpBandTerm2 n A) -> ((OpBandTerm2 n A) -> (OpBandTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClBandTerm A) -> (ClBandTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpBandTerm n) -> (OpBandTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpBandTerm2 n A) -> (OpBandTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Band A) -> (BandTerm -> A))
    evalB Ba (opL x1 x2) = ((op Ba) (evalB Ba x1) (evalB Ba x2)) 
    evalCl : {A : Set} -> ((Band A) -> ((ClBandTerm A) -> A))
    evalCl Ba (sing x1) = x1 
    evalCl Ba (opCl x1 x2) = ((op Ba) (evalCl Ba x1) (evalCl Ba x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Band A) -> ((Vec A n) -> ((OpBandTerm n) -> A)))
    evalOpB Ba vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ba vars (opOL x1 x2) = ((op Ba) (evalOpB Ba vars x1) (evalOpB Ba vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Band A) -> ((Vec A n) -> ((OpBandTerm2 n A) -> A)))
    evalOp Ba vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ba vars (sing2 x1) = x1 
    evalOp Ba vars (opOL2 x1 x2) = ((op Ba) (evalOp Ba vars x1) (evalOp Ba vars x2)) 
    inductionB : {P : (BandTerm -> Set)} -> (((x1 x2 : BandTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : BandTerm) -> (P x)))
    inductionB {p} popl (opL x1 x2) = (popl _ _ (inductionB {p} popl x1) (inductionB {p} popl x2)) 
    inductionCl : {A : Set} {P : ((ClBandTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClBandTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClBandTerm A)) -> (P x))))
    inductionCl {_} {p} psing popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl x1) (inductionCl {_} {p} psing popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpBandTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpBandTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpBandTerm n)) -> (P x))))
    inductionOpB {_} {p} pv popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol x1) (inductionOpB {_} {p} pv popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpBandTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpBandTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpBandTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 x2)) 
    opL' : (BandTerm -> (BandTerm -> BandTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (BandTerm -> (Staged BandTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClBandTerm A) -> ((ClBandTerm A) -> (ClBandTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClBandTerm A) -> (Staged (ClBandTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpBandTerm n) -> ((OpBandTerm n) -> (OpBandTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpBandTerm n) -> (Staged (OpBandTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpBandTerm2 n A) -> ((OpBandTerm2 n A) -> (OpBandTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpBandTerm2 n A) -> (Staged (OpBandTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module BinaryInverse  where
    record BinaryInverse (A : Set) : Set where
      constructor BinaryInverseC
      field
        |> : (A -> (A -> A))
        <| : (A -> (A -> A))
        leftInverse : {x y : A} -> (<| (|> x y) x) == y
        rightInverse : {x y : A} -> (|> x (<| y x)) == y
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        |>S : (AS -> (AS -> AS))
        <|S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        |>P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        <|P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftInverseP : {xP yP : (Prod A A)} -> (<|P (|>P xP yP) xP) == yP
        rightInverseP : {xP yP : (Prod A A)} -> (|>P xP (<|P yP xP)) == yP
    record Hom {A1 : Set} {A2 : Set} (Bi1 : (BinaryInverse A1)) (Bi2 : (BinaryInverse A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-|> : {x1 x2 : A1} -> (hom ((|> Bi1) x1 x2)) == ((|> Bi2) (hom x1) (hom x2))
        pres-<| : {x1 x2 : A1} -> (hom ((<| Bi1) x1 x2)) == ((<| Bi2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Bi1 : (BinaryInverse A1)) (Bi2 : (BinaryInverse A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-|> : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((|> Bi1) x1 x2) ((|> Bi2) y1 y2))))
        interp-<| : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((<| Bi1) x1 x2) ((<| Bi2) y1 y2))))
    data BinaryInverseTerm  : Set where
      |>L : (BinaryInverseTerm -> (BinaryInverseTerm -> BinaryInverseTerm))
      <|L : (BinaryInverseTerm -> (BinaryInverseTerm -> BinaryInverseTerm))
    data ClBinaryInverseTerm (A : Set) : Set where
      sing : (A -> (ClBinaryInverseTerm A))
      |>Cl : ((ClBinaryInverseTerm A) -> ((ClBinaryInverseTerm A) -> (ClBinaryInverseTerm A)))
      <|Cl : ((ClBinaryInverseTerm A) -> ((ClBinaryInverseTerm A) -> (ClBinaryInverseTerm A)))
    data OpBinaryInverseTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpBinaryInverseTerm n))
      |>OL : ((OpBinaryInverseTerm n) -> ((OpBinaryInverseTerm n) -> (OpBinaryInverseTerm n)))
      <|OL : ((OpBinaryInverseTerm n) -> ((OpBinaryInverseTerm n) -> (OpBinaryInverseTerm n)))
    data OpBinaryInverseTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpBinaryInverseTerm2 n A))
      sing2 : (A -> (OpBinaryInverseTerm2 n A))
      |>OL2 : ((OpBinaryInverseTerm2 n A) -> ((OpBinaryInverseTerm2 n A) -> (OpBinaryInverseTerm2 n A)))
      <|OL2 : ((OpBinaryInverseTerm2 n A) -> ((OpBinaryInverseTerm2 n A) -> (OpBinaryInverseTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClBinaryInverseTerm A) -> (ClBinaryInverseTerm A))
    simplifyCl (|>Cl x1 x2) = (|>Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (<|Cl x1 x2) = (<|Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpBinaryInverseTerm n) -> (OpBinaryInverseTerm n))
    simplifyOpB (|>OL x1 x2) = (|>OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (<|OL x1 x2) = (<|OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpBinaryInverseTerm2 n A) -> (OpBinaryInverseTerm2 n A))
    simplifyOp (|>OL2 x1 x2) = (|>OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (<|OL2 x1 x2) = (<|OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((BinaryInverse A) -> (BinaryInverseTerm -> A))
    evalB Bi (|>L x1 x2) = ((|> Bi) (evalB Bi x1) (evalB Bi x2)) 
    evalB Bi (<|L x1 x2) = ((<| Bi) (evalB Bi x1) (evalB Bi x2)) 
    evalCl : {A : Set} -> ((BinaryInverse A) -> ((ClBinaryInverseTerm A) -> A))
    evalCl Bi (sing x1) = x1 
    evalCl Bi (|>Cl x1 x2) = ((|> Bi) (evalCl Bi x1) (evalCl Bi x2)) 
    evalCl Bi (<|Cl x1 x2) = ((<| Bi) (evalCl Bi x1) (evalCl Bi x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((BinaryInverse A) -> ((Vec A n) -> ((OpBinaryInverseTerm n) -> A)))
    evalOpB Bi vars (v x1) = (lookup _ x1 vars) 
    evalOpB Bi vars (|>OL x1 x2) = ((|> Bi) (evalOpB Bi vars x1) (evalOpB Bi vars x2)) 
    evalOpB Bi vars (<|OL x1 x2) = ((<| Bi) (evalOpB Bi vars x1) (evalOpB Bi vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((BinaryInverse A) -> ((Vec A n) -> ((OpBinaryInverseTerm2 n A) -> A)))
    evalOp Bi vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Bi vars (sing2 x1) = x1 
    evalOp Bi vars (|>OL2 x1 x2) = ((|> Bi) (evalOp Bi vars x1) (evalOp Bi vars x2)) 
    evalOp Bi vars (<|OL2 x1 x2) = ((<| Bi) (evalOp Bi vars x1) (evalOp Bi vars x2)) 
    inductionB : {P : (BinaryInverseTerm -> Set)} -> (((x1 x2 : BinaryInverseTerm) -> ((P x1) -> ((P x2) -> (P (|>L x1 x2))))) -> (((x1 x2 : BinaryInverseTerm) -> ((P x1) -> ((P x2) -> (P (<|L x1 x2))))) -> ((x : BinaryInverseTerm) -> (P x))))
    inductionB {p} p|>l p<|l (|>L x1 x2) = (p|>l _ _ (inductionB {p} p|>l p<|l x1) (inductionB {p} p|>l p<|l x2)) 
    inductionB {p} p|>l p<|l (<|L x1 x2) = (p<|l _ _ (inductionB {p} p|>l p<|l x1) (inductionB {p} p|>l p<|l x2)) 
    inductionCl : {A : Set} {P : ((ClBinaryInverseTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClBinaryInverseTerm A)) -> ((P x1) -> ((P x2) -> (P (|>Cl x1 x2))))) -> (((x1 x2 : (ClBinaryInverseTerm A)) -> ((P x1) -> ((P x2) -> (P (<|Cl x1 x2))))) -> ((x : (ClBinaryInverseTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p|>cl p<|cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p|>cl p<|cl (|>Cl x1 x2) = (p|>cl _ _ (inductionCl {_} {p} psing p|>cl p<|cl x1) (inductionCl {_} {p} psing p|>cl p<|cl x2)) 
    inductionCl {_} {p} psing p|>cl p<|cl (<|Cl x1 x2) = (p<|cl _ _ (inductionCl {_} {p} psing p|>cl p<|cl x1) (inductionCl {_} {p} psing p|>cl p<|cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpBinaryInverseTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpBinaryInverseTerm n)) -> ((P x1) -> ((P x2) -> (P (|>OL x1 x2))))) -> (((x1 x2 : (OpBinaryInverseTerm n)) -> ((P x1) -> ((P x2) -> (P (<|OL x1 x2))))) -> ((x : (OpBinaryInverseTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p|>ol p<|ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p|>ol p<|ol (|>OL x1 x2) = (p|>ol _ _ (inductionOpB {_} {p} pv p|>ol p<|ol x1) (inductionOpB {_} {p} pv p|>ol p<|ol x2)) 
    inductionOpB {_} {p} pv p|>ol p<|ol (<|OL x1 x2) = (p<|ol _ _ (inductionOpB {_} {p} pv p|>ol p<|ol x1) (inductionOpB {_} {p} pv p|>ol p<|ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpBinaryInverseTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpBinaryInverseTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (|>OL2 x1 x2))))) -> (((x1 x2 : (OpBinaryInverseTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (<|OL2 x1 x2))))) -> ((x : (OpBinaryInverseTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (|>OL2 x1 x2) = (p|>ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (<|OL2 x1 x2) = (p<|ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x2)) 
    |>L' : (BinaryInverseTerm -> (BinaryInverseTerm -> BinaryInverseTerm))
    |>L' x1 x2 = (|>L x1 x2) 
    <|L' : (BinaryInverseTerm -> (BinaryInverseTerm -> BinaryInverseTerm))
    <|L' x1 x2 = (<|L x1 x2) 
    stageB : (BinaryInverseTerm -> (Staged BinaryInverseTerm))
    stageB (|>L x1 x2) = (stage2 |>L' (codeLift2 |>L') (stageB x1) (stageB x2)) 
    stageB (<|L x1 x2) = (stage2 <|L' (codeLift2 <|L') (stageB x1) (stageB x2)) 
    |>Cl' : {A : Set} -> ((ClBinaryInverseTerm A) -> ((ClBinaryInverseTerm A) -> (ClBinaryInverseTerm A)))
    |>Cl' x1 x2 = (|>Cl x1 x2) 
    <|Cl' : {A : Set} -> ((ClBinaryInverseTerm A) -> ((ClBinaryInverseTerm A) -> (ClBinaryInverseTerm A)))
    <|Cl' x1 x2 = (<|Cl x1 x2) 
    stageCl : {A : Set} -> ((ClBinaryInverseTerm A) -> (Staged (ClBinaryInverseTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (|>Cl x1 x2) = (stage2 |>Cl' (codeLift2 |>Cl') (stageCl x1) (stageCl x2)) 
    stageCl (<|Cl x1 x2) = (stage2 <|Cl' (codeLift2 <|Cl') (stageCl x1) (stageCl x2)) 
    |>OL' : {n : Nat} -> ((OpBinaryInverseTerm n) -> ((OpBinaryInverseTerm n) -> (OpBinaryInverseTerm n)))
    |>OL' x1 x2 = (|>OL x1 x2) 
    <|OL' : {n : Nat} -> ((OpBinaryInverseTerm n) -> ((OpBinaryInverseTerm n) -> (OpBinaryInverseTerm n)))
    <|OL' x1 x2 = (<|OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpBinaryInverseTerm n) -> (Staged (OpBinaryInverseTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (|>OL x1 x2) = (stage2 |>OL' (codeLift2 |>OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (<|OL x1 x2) = (stage2 <|OL' (codeLift2 <|OL') (stageOpB x1) (stageOpB x2)) 
    |>OL2' : {n : Nat} {A : Set} -> ((OpBinaryInverseTerm2 n A) -> ((OpBinaryInverseTerm2 n A) -> (OpBinaryInverseTerm2 n A)))
    |>OL2' x1 x2 = (|>OL2 x1 x2) 
    <|OL2' : {n : Nat} {A : Set} -> ((OpBinaryInverseTerm2 n A) -> ((OpBinaryInverseTerm2 n A) -> (OpBinaryInverseTerm2 n A)))
    <|OL2' x1 x2 = (<|OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpBinaryInverseTerm2 n A) -> (Staged (OpBinaryInverseTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (|>OL2 x1 x2) = (stage2 |>OL2' (codeLift2 |>OL2') (stageOp x1) (stageOp x2)) 
    stageOp (<|OL2 x1 x2) = (stage2 <|OL2' (codeLift2 <|OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        |>T : ((Repr A) -> ((Repr A) -> (Repr A)))
        <|T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module BooleanGroup  where
    record BooleanGroup (A : Set) : Set where
      constructor BooleanGroupC
      field
        e : A
        op : (A -> (A -> A))
        lunit_e : {x : A} -> (op e x) == x
        runit_e : {x : A} -> (op x e) == x
        associative_op : {x y z : A} -> (op (op x y) z) == (op x (op y z))
        unipotence : {x : A} -> (op x x) == e
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        eS : AS
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        eP : (Prod A A)
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        lunit_eP : {xP : (Prod A A)} -> (opP eP xP) == xP
        runit_eP : {xP : (Prod A A)} -> (opP xP eP) == xP
        associative_opP : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP (opP yP zP))
        unipotenceP : {xP : (Prod A A)} -> (opP xP xP) == eP
    record Hom {A1 : Set} {A2 : Set} (Bo1 : (BooleanGroup A1)) (Bo2 : (BooleanGroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-e : (hom (e Bo1)) == (e Bo2)
        pres-op : {x1 x2 : A1} -> (hom ((op Bo1) x1 x2)) == ((op Bo2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Bo1 : (BooleanGroup A1)) (Bo2 : (BooleanGroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-e : (interp (e Bo1) (e Bo2))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Bo1) x1 x2) ((op Bo2) y1 y2))))
    data BooleanGroupTerm  : Set where
      eL : BooleanGroupTerm
      opL : (BooleanGroupTerm -> (BooleanGroupTerm -> BooleanGroupTerm))
    data ClBooleanGroupTerm (A : Set) : Set where
      sing : (A -> (ClBooleanGroupTerm A))
      eCl : (ClBooleanGroupTerm A)
      opCl : ((ClBooleanGroupTerm A) -> ((ClBooleanGroupTerm A) -> (ClBooleanGroupTerm A)))
    data OpBooleanGroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpBooleanGroupTerm n))
      eOL : (OpBooleanGroupTerm n)
      opOL : ((OpBooleanGroupTerm n) -> ((OpBooleanGroupTerm n) -> (OpBooleanGroupTerm n)))
    data OpBooleanGroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpBooleanGroupTerm2 n A))
      sing2 : (A -> (OpBooleanGroupTerm2 n A))
      eOL2 : (OpBooleanGroupTerm2 n A)
      opOL2 : ((OpBooleanGroupTerm2 n A) -> ((OpBooleanGroupTerm2 n A) -> (OpBooleanGroupTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClBooleanGroupTerm A) -> (ClBooleanGroupTerm A))
    simplifyCl (opCl eCl x) = x 
    simplifyCl (opCl x eCl) = x 
    simplifyCl eCl = eCl 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpBooleanGroupTerm n) -> (OpBooleanGroupTerm n))
    simplifyOpB (opOL eOL x) = x 
    simplifyOpB (opOL x eOL) = x 
    simplifyOpB eOL = eOL 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpBooleanGroupTerm2 n A) -> (OpBooleanGroupTerm2 n A))
    simplifyOp (opOL2 eOL2 x) = x 
    simplifyOp (opOL2 x eOL2) = x 
    simplifyOp eOL2 = eOL2 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((BooleanGroup A) -> (BooleanGroupTerm -> A))
    evalB Bo eL = (e Bo) 
    evalB Bo (opL x1 x2) = ((op Bo) (evalB Bo x1) (evalB Bo x2)) 
    evalCl : {A : Set} -> ((BooleanGroup A) -> ((ClBooleanGroupTerm A) -> A))
    evalCl Bo (sing x1) = x1 
    evalCl Bo eCl = (e Bo) 
    evalCl Bo (opCl x1 x2) = ((op Bo) (evalCl Bo x1) (evalCl Bo x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((BooleanGroup A) -> ((Vec A n) -> ((OpBooleanGroupTerm n) -> A)))
    evalOpB Bo vars (v x1) = (lookup _ x1 vars) 
    evalOpB Bo vars eOL = (e Bo) 
    evalOpB Bo vars (opOL x1 x2) = ((op Bo) (evalOpB Bo vars x1) (evalOpB Bo vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((BooleanGroup A) -> ((Vec A n) -> ((OpBooleanGroupTerm2 n A) -> A)))
    evalOp Bo vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Bo vars (sing2 x1) = x1 
    evalOp Bo vars eOL2 = (e Bo) 
    evalOp Bo vars (opOL2 x1 x2) = ((op Bo) (evalOp Bo vars x1) (evalOp Bo vars x2)) 
    inductionB : {P : (BooleanGroupTerm -> Set)} -> ((P eL) -> (((x1 x2 : BooleanGroupTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : BooleanGroupTerm) -> (P x))))
    inductionB {p} pel popl eL = pel 
    inductionB {p} pel popl (opL x1 x2) = (popl _ _ (inductionB {p} pel popl x1) (inductionB {p} pel popl x2)) 
    inductionCl : {A : Set} {P : ((ClBooleanGroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P eCl) -> (((x1 x2 : (ClBooleanGroupTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClBooleanGroupTerm A)) -> (P x)))))
    inductionCl {_} {p} psing pecl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pecl popcl eCl = pecl 
    inductionCl {_} {p} psing pecl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing pecl popcl x1) (inductionCl {_} {p} psing pecl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpBooleanGroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P eOL) -> (((x1 x2 : (OpBooleanGroupTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpBooleanGroupTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv peol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv peol popol eOL = peol 
    inductionOpB {_} {p} pv peol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv peol popol x1) (inductionOpB {_} {p} pv peol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpBooleanGroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P eOL2) -> (((x1 x2 : (OpBooleanGroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpBooleanGroupTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 eOL2 = peol2 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 x2)) 
    eL' : BooleanGroupTerm
    eL'  = eL 
    opL' : (BooleanGroupTerm -> (BooleanGroupTerm -> BooleanGroupTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (BooleanGroupTerm -> (Staged BooleanGroupTerm))
    stageB eL = (Now eL) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    eCl' : {A : Set} -> (ClBooleanGroupTerm A)
    eCl'  = eCl 
    opCl' : {A : Set} -> ((ClBooleanGroupTerm A) -> ((ClBooleanGroupTerm A) -> (ClBooleanGroupTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClBooleanGroupTerm A) -> (Staged (ClBooleanGroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl eCl = (Now eCl) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    eOL' : {n : Nat} -> (OpBooleanGroupTerm n)
    eOL'  = eOL 
    opOL' : {n : Nat} -> ((OpBooleanGroupTerm n) -> ((OpBooleanGroupTerm n) -> (OpBooleanGroupTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpBooleanGroupTerm n) -> (Staged (OpBooleanGroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB eOL = (Now eOL) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    eOL2' : {n : Nat} {A : Set} -> (OpBooleanGroupTerm2 n A)
    eOL2'  = eOL2 
    opOL2' : {n : Nat} {A : Set} -> ((OpBooleanGroupTerm2 n A) -> ((OpBooleanGroupTerm2 n A) -> (OpBooleanGroupTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpBooleanGroupTerm2 n A) -> (Staged (OpBooleanGroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp eOL2 = (Now eOL2) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        eT : (Repr A)
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module BooleanRing  where
    record BooleanRing (A : Set) : Set where
      constructor BooleanRingC
      field
        * : (A -> (A -> A))
        1 : A
        lunit_1 : {x : A} -> (* 1 x) == x
        runit_1 : {x : A} -> (* x 1) == x
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        commutative_* : {x y : A} -> (* x y) == (* y x)
        + : (A -> (A -> A))
        0 : A
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        leftDistributive_*_+ : {x y z : A} -> (* x (+ y z)) == (+ (* x y) (* x z))
        rightDistributive_*_+ : {x y z : A} -> (* (+ y z) x) == (+ (* y x) (* z x))
        neg : (A -> A)
        leftInverse_inv_op_0 : {x : A} -> (+ x (neg x)) == 0
        rightInverse_inv_op_0 : {x : A} -> (+ (neg x) x) == 0
        leftZero_op_0 : {x : A} -> (* 0 x) == 0
        rightZero_op_0 : {x : A} -> (* x 0) == 0
        idempotent_* : {x : A} -> (* x x) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        1S : AS
        +S : (AS -> (AS -> AS))
        0S : AS
        negS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        1P : (Prod A A)
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        0P : (Prod A A)
        negP : ((Prod A A) -> (Prod A A))
        lunit_1P : {xP : (Prod A A)} -> (*P 1P xP) == xP
        runit_1P : {xP : (Prod A A)} -> (*P xP 1P) == xP
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        commutative_*P : {xP yP : (Prod A A)} -> (*P xP yP) == (*P yP xP)
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        leftDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P xP (+P yP zP)) == (+P (*P xP yP) (*P xP zP))
        rightDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P (+P yP zP) xP) == (+P (*P yP xP) (*P zP xP))
        leftInverse_inv_op_0P : {xP : (Prod A A)} -> (+P xP (negP xP)) == 0P
        rightInverse_inv_op_0P : {xP : (Prod A A)} -> (+P (negP xP) xP) == 0P
        leftZero_op_0P : {xP : (Prod A A)} -> (*P 0P xP) == 0P
        rightZero_op_0P : {xP : (Prod A A)} -> (*P xP 0P) == 0P
        idempotent_*P : {xP : (Prod A A)} -> (*P xP xP) == xP
    record Hom {A1 : Set} {A2 : Set} (Bo1 : (BooleanRing A1)) (Bo2 : (BooleanRing A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Bo1) x1 x2)) == ((* Bo2) (hom x1) (hom x2))
        pres-1 : (hom (1 Bo1)) == (1 Bo2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Bo1) x1 x2)) == ((+ Bo2) (hom x1) (hom x2))
        pres-0 : (hom (0 Bo1)) == (0 Bo2)
        pres-neg : {x1 : A1} -> (hom ((neg Bo1) x1)) == ((neg Bo2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (Bo1 : (BooleanRing A1)) (Bo2 : (BooleanRing A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Bo1) x1 x2) ((* Bo2) y1 y2))))
        interp-1 : (interp (1 Bo1) (1 Bo2))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Bo1) x1 x2) ((+ Bo2) y1 y2))))
        interp-0 : (interp (0 Bo1) (0 Bo2))
        interp-neg : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((neg Bo1) x1) ((neg Bo2) y1)))
    data BooleanRingTerm  : Set where
      *L : (BooleanRingTerm -> (BooleanRingTerm -> BooleanRingTerm))
      1L : BooleanRingTerm
      +L : (BooleanRingTerm -> (BooleanRingTerm -> BooleanRingTerm))
      0L : BooleanRingTerm
      negL : (BooleanRingTerm -> BooleanRingTerm)
    data ClBooleanRingTerm (A : Set) : Set where
      sing : (A -> (ClBooleanRingTerm A))
      *Cl : ((ClBooleanRingTerm A) -> ((ClBooleanRingTerm A) -> (ClBooleanRingTerm A)))
      1Cl : (ClBooleanRingTerm A)
      +Cl : ((ClBooleanRingTerm A) -> ((ClBooleanRingTerm A) -> (ClBooleanRingTerm A)))
      0Cl : (ClBooleanRingTerm A)
      negCl : ((ClBooleanRingTerm A) -> (ClBooleanRingTerm A))
    data OpBooleanRingTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpBooleanRingTerm n))
      *OL : ((OpBooleanRingTerm n) -> ((OpBooleanRingTerm n) -> (OpBooleanRingTerm n)))
      1OL : (OpBooleanRingTerm n)
      +OL : ((OpBooleanRingTerm n) -> ((OpBooleanRingTerm n) -> (OpBooleanRingTerm n)))
      0OL : (OpBooleanRingTerm n)
      negOL : ((OpBooleanRingTerm n) -> (OpBooleanRingTerm n))
    data OpBooleanRingTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpBooleanRingTerm2 n A))
      sing2 : (A -> (OpBooleanRingTerm2 n A))
      *OL2 : ((OpBooleanRingTerm2 n A) -> ((OpBooleanRingTerm2 n A) -> (OpBooleanRingTerm2 n A)))
      1OL2 : (OpBooleanRingTerm2 n A)
      +OL2 : ((OpBooleanRingTerm2 n A) -> ((OpBooleanRingTerm2 n A) -> (OpBooleanRingTerm2 n A)))
      0OL2 : (OpBooleanRingTerm2 n A)
      negOL2 : ((OpBooleanRingTerm2 n A) -> (OpBooleanRingTerm2 n A))
    simplifyCl : {A : Set} -> ((ClBooleanRingTerm A) -> (ClBooleanRingTerm A))
    simplifyCl (*Cl 1Cl x) = x 
    simplifyCl (*Cl x 1Cl) = x 
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 0Cl = 0Cl 
    simplifyCl (negCl x1) = (negCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpBooleanRingTerm n) -> (OpBooleanRingTerm n))
    simplifyOpB (*OL 1OL x) = x 
    simplifyOpB (*OL x 1OL) = x 
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 0OL = 0OL 
    simplifyOpB (negOL x1) = (negOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpBooleanRingTerm2 n A) -> (OpBooleanRingTerm2 n A))
    simplifyOp (*OL2 1OL2 x) = x 
    simplifyOp (*OL2 x 1OL2) = x 
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (negOL2 x1) = (negOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((BooleanRing A) -> (BooleanRingTerm -> A))
    evalB Bo (*L x1 x2) = ((* Bo) (evalB Bo x1) (evalB Bo x2)) 
    evalB Bo 1L = (1 Bo) 
    evalB Bo (+L x1 x2) = ((+ Bo) (evalB Bo x1) (evalB Bo x2)) 
    evalB Bo 0L = (0 Bo) 
    evalB Bo (negL x1) = ((neg Bo) (evalB Bo x1)) 
    evalCl : {A : Set} -> ((BooleanRing A) -> ((ClBooleanRingTerm A) -> A))
    evalCl Bo (sing x1) = x1 
    evalCl Bo (*Cl x1 x2) = ((* Bo) (evalCl Bo x1) (evalCl Bo x2)) 
    evalCl Bo 1Cl = (1 Bo) 
    evalCl Bo (+Cl x1 x2) = ((+ Bo) (evalCl Bo x1) (evalCl Bo x2)) 
    evalCl Bo 0Cl = (0 Bo) 
    evalCl Bo (negCl x1) = ((neg Bo) (evalCl Bo x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((BooleanRing A) -> ((Vec A n) -> ((OpBooleanRingTerm n) -> A)))
    evalOpB Bo vars (v x1) = (lookup _ x1 vars) 
    evalOpB Bo vars (*OL x1 x2) = ((* Bo) (evalOpB Bo vars x1) (evalOpB Bo vars x2)) 
    evalOpB Bo vars 1OL = (1 Bo) 
    evalOpB Bo vars (+OL x1 x2) = ((+ Bo) (evalOpB Bo vars x1) (evalOpB Bo vars x2)) 
    evalOpB Bo vars 0OL = (0 Bo) 
    evalOpB Bo vars (negOL x1) = ((neg Bo) (evalOpB Bo vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((BooleanRing A) -> ((Vec A n) -> ((OpBooleanRingTerm2 n A) -> A)))
    evalOp Bo vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Bo vars (sing2 x1) = x1 
    evalOp Bo vars (*OL2 x1 x2) = ((* Bo) (evalOp Bo vars x1) (evalOp Bo vars x2)) 
    evalOp Bo vars 1OL2 = (1 Bo) 
    evalOp Bo vars (+OL2 x1 x2) = ((+ Bo) (evalOp Bo vars x1) (evalOp Bo vars x2)) 
    evalOp Bo vars 0OL2 = (0 Bo) 
    evalOp Bo vars (negOL2 x1) = ((neg Bo) (evalOp Bo vars x1)) 
    inductionB : {P : (BooleanRingTerm -> Set)} -> (((x1 x2 : BooleanRingTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((P 1L) -> (((x1 x2 : BooleanRingTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((P 0L) -> (((x1 : BooleanRingTerm) -> ((P x1) -> (P (negL x1)))) -> ((x : BooleanRingTerm) -> (P x)))))))
    inductionB {p} p*l p1l p+l p0l pnegl (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p1l p+l p0l pnegl x1) (inductionB {p} p*l p1l p+l p0l pnegl x2)) 
    inductionB {p} p*l p1l p+l p0l pnegl 1L = p1l 
    inductionB {p} p*l p1l p+l p0l pnegl (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p1l p+l p0l pnegl x1) (inductionB {p} p*l p1l p+l p0l pnegl x2)) 
    inductionB {p} p*l p1l p+l p0l pnegl 0L = p0l 
    inductionB {p} p*l p1l p+l p0l pnegl (negL x1) = (pnegl _ (inductionB {p} p*l p1l p+l p0l pnegl x1)) 
    inductionCl : {A : Set} {P : ((ClBooleanRingTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClBooleanRingTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((P 1Cl) -> (((x1 x2 : (ClBooleanRingTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((P 0Cl) -> (((x1 : (ClBooleanRingTerm A)) -> ((P x1) -> (P (negCl x1)))) -> ((x : (ClBooleanRingTerm A)) -> (P x))))))))
    inductionCl {_} {p} psing p*cl p1cl p+cl p0cl pnegcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p1cl p+cl p0cl pnegcl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p1cl p+cl p0cl pnegcl x1) (inductionCl {_} {p} psing p*cl p1cl p+cl p0cl pnegcl x2)) 
    inductionCl {_} {p} psing p*cl p1cl p+cl p0cl pnegcl 1Cl = p1cl 
    inductionCl {_} {p} psing p*cl p1cl p+cl p0cl pnegcl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p1cl p+cl p0cl pnegcl x1) (inductionCl {_} {p} psing p*cl p1cl p+cl p0cl pnegcl x2)) 
    inductionCl {_} {p} psing p*cl p1cl p+cl p0cl pnegcl 0Cl = p0cl 
    inductionCl {_} {p} psing p*cl p1cl p+cl p0cl pnegcl (negCl x1) = (pnegcl _ (inductionCl {_} {p} psing p*cl p1cl p+cl p0cl pnegcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpBooleanRingTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpBooleanRingTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((P 1OL) -> (((x1 x2 : (OpBooleanRingTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((P 0OL) -> (((x1 : (OpBooleanRingTerm n)) -> ((P x1) -> (P (negOL x1)))) -> ((x : (OpBooleanRingTerm n)) -> (P x))))))))
    inductionOpB {_} {p} pv p*ol p1ol p+ol p0ol pnegol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p1ol p+ol p0ol pnegol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p1ol p+ol p0ol pnegol x1) (inductionOpB {_} {p} pv p*ol p1ol p+ol p0ol pnegol x2)) 
    inductionOpB {_} {p} pv p*ol p1ol p+ol p0ol pnegol 1OL = p1ol 
    inductionOpB {_} {p} pv p*ol p1ol p+ol p0ol pnegol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p1ol p+ol p0ol pnegol x1) (inductionOpB {_} {p} pv p*ol p1ol p+ol p0ol pnegol x2)) 
    inductionOpB {_} {p} pv p*ol p1ol p+ol p0ol pnegol 0OL = p0ol 
    inductionOpB {_} {p} pv p*ol p1ol p+ol p0ol pnegol (negOL x1) = (pnegol _ (inductionOpB {_} {p} pv p*ol p1ol p+ol p0ol pnegol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpBooleanRingTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpBooleanRingTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((P 1OL2) -> (((x1 x2 : (OpBooleanRingTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((P 0OL2) -> (((x1 : (OpBooleanRingTerm2 n A)) -> ((P x1) -> (P (negOL2 x1)))) -> ((x : (OpBooleanRingTerm2 n A)) -> (P x)))))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 pnegol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 pnegol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 pnegol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 pnegol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 pnegol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 pnegol2 1OL2 = p1ol2 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 pnegol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 pnegol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 pnegol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 pnegol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 pnegol2 (negOL2 x1) = (pnegol2 _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 pnegol2 x1)) 
    *L' : (BooleanRingTerm -> (BooleanRingTerm -> BooleanRingTerm))
    *L' x1 x2 = (*L x1 x2) 
    1L' : BooleanRingTerm
    1L'  = 1L 
    +L' : (BooleanRingTerm -> (BooleanRingTerm -> BooleanRingTerm))
    +L' x1 x2 = (+L x1 x2) 
    0L' : BooleanRingTerm
    0L'  = 0L 
    negL' : (BooleanRingTerm -> BooleanRingTerm)
    negL' x1 = (negL x1) 
    stageB : (BooleanRingTerm -> (Staged BooleanRingTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB 1L = (Now 1L) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB 0L = (Now 0L) 
    stageB (negL x1) = (stage1 negL' (codeLift1 negL') (stageB x1)) 
    *Cl' : {A : Set} -> ((ClBooleanRingTerm A) -> ((ClBooleanRingTerm A) -> (ClBooleanRingTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    1Cl' : {A : Set} -> (ClBooleanRingTerm A)
    1Cl'  = 1Cl 
    +Cl' : {A : Set} -> ((ClBooleanRingTerm A) -> ((ClBooleanRingTerm A) -> (ClBooleanRingTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    0Cl' : {A : Set} -> (ClBooleanRingTerm A)
    0Cl'  = 0Cl 
    negCl' : {A : Set} -> ((ClBooleanRingTerm A) -> (ClBooleanRingTerm A))
    negCl' x1 = (negCl x1) 
    stageCl : {A : Set} -> ((ClBooleanRingTerm A) -> (Staged (ClBooleanRingTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl 1Cl = (Now 1Cl) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (negCl x1) = (stage1 negCl' (codeLift1 negCl') (stageCl x1)) 
    *OL' : {n : Nat} -> ((OpBooleanRingTerm n) -> ((OpBooleanRingTerm n) -> (OpBooleanRingTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    1OL' : {n : Nat} -> (OpBooleanRingTerm n)
    1OL'  = 1OL 
    +OL' : {n : Nat} -> ((OpBooleanRingTerm n) -> ((OpBooleanRingTerm n) -> (OpBooleanRingTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    0OL' : {n : Nat} -> (OpBooleanRingTerm n)
    0OL'  = 0OL 
    negOL' : {n : Nat} -> ((OpBooleanRingTerm n) -> (OpBooleanRingTerm n))
    negOL' x1 = (negOL x1) 
    stageOpB : {n : Nat} -> ((OpBooleanRingTerm n) -> (Staged (OpBooleanRingTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 1OL = (Now 1OL) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (negOL x1) = (stage1 negOL' (codeLift1 negOL') (stageOpB x1)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpBooleanRingTerm2 n A) -> ((OpBooleanRingTerm2 n A) -> (OpBooleanRingTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    1OL2' : {n : Nat} {A : Set} -> (OpBooleanRingTerm2 n A)
    1OL2'  = 1OL2 
    +OL2' : {n : Nat} {A : Set} -> ((OpBooleanRingTerm2 n A) -> ((OpBooleanRingTerm2 n A) -> (OpBooleanRingTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    0OL2' : {n : Nat} {A : Set} -> (OpBooleanRingTerm2 n A)
    0OL2'  = 0OL2 
    negOL2' : {n : Nat} {A : Set} -> ((OpBooleanRingTerm2 n A) -> (OpBooleanRingTerm2 n A))
    negOL2' x1 = (negOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpBooleanRingTerm2 n A) -> (Staged (OpBooleanRingTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp 1OL2 = (Now 1OL2) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (negOL2 x1) = (stage1 negOL2' (codeLift1 negOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        1T : (Repr A)
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        0T : (Repr A)
        negT : ((Repr A) -> (Repr A))
  module BoundedDistributiveLattice  where
    record BoundedDistributiveLattice (A : Set) : Set where
      constructor BoundedDistributiveLatticeC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        commutative_* : {x y : A} -> (* x y) == (* y x)
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        idempotent_* : {x : A} -> (* x x) == x
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        idempotent_+ : {x : A} -> (+ x x) == x
        leftAbsorp_*_+ : {x y : A} -> (* x (+ x y)) == x
        leftAbsorp_+_* : {x y : A} -> (+ x (* x y)) == x
        leftModular_*_+ : {x y z : A} -> (+ (* x y) (* x z)) == (* x (+ y (* x z)))
        0 : A
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
        1 : A
        lunit_1 : {x : A} -> (* 1 x) == x
        runit_1 : {x : A} -> (* x 1) == x
        leftDistributive_*_+ : {x y z : A} -> (* x (+ y z)) == (+ (* x y) (* x z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
        0S : AS
        1S : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        0P : (Prod A A)
        1P : (Prod A A)
        commutative_*P : {xP yP : (Prod A A)} -> (*P xP yP) == (*P yP xP)
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        idempotent_*P : {xP : (Prod A A)} -> (*P xP xP) == xP
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        idempotent_+P : {xP : (Prod A A)} -> (+P xP xP) == xP
        leftAbsorp_*_+P : {xP yP : (Prod A A)} -> (*P xP (+P xP yP)) == xP
        leftAbsorp_+_*P : {xP yP : (Prod A A)} -> (+P xP (*P xP yP)) == xP
        leftModular_*_+P : {xP yP zP : (Prod A A)} -> (+P (*P xP yP) (*P xP zP)) == (*P xP (+P yP (*P xP zP)))
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
        lunit_1P : {xP : (Prod A A)} -> (*P 1P xP) == xP
        runit_1P : {xP : (Prod A A)} -> (*P xP 1P) == xP
        leftDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P xP (+P yP zP)) == (+P (*P xP yP) (*P xP zP))
    record Hom {A1 : Set} {A2 : Set} (Bo1 : (BoundedDistributiveLattice A1)) (Bo2 : (BoundedDistributiveLattice A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Bo1) x1 x2)) == ((* Bo2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Bo1) x1 x2)) == ((+ Bo2) (hom x1) (hom x2))
        pres-0 : (hom (0 Bo1)) == (0 Bo2)
        pres-1 : (hom (1 Bo1)) == (1 Bo2)
    record RelInterp {A1 : Set} {A2 : Set} (Bo1 : (BoundedDistributiveLattice A1)) (Bo2 : (BoundedDistributiveLattice A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Bo1) x1 x2) ((* Bo2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Bo1) x1 x2) ((+ Bo2) y1 y2))))
        interp-0 : (interp (0 Bo1) (0 Bo2))
        interp-1 : (interp (1 Bo1) (1 Bo2))
    data BoundedDistributiveLatticeTerm  : Set where
      *L : (BoundedDistributiveLatticeTerm -> (BoundedDistributiveLatticeTerm -> BoundedDistributiveLatticeTerm))
      +L : (BoundedDistributiveLatticeTerm -> (BoundedDistributiveLatticeTerm -> BoundedDistributiveLatticeTerm))
      0L : BoundedDistributiveLatticeTerm
      1L : BoundedDistributiveLatticeTerm
    data ClBoundedDistributiveLatticeTerm (A : Set) : Set where
      sing : (A -> (ClBoundedDistributiveLatticeTerm A))
      *Cl : ((ClBoundedDistributiveLatticeTerm A) -> ((ClBoundedDistributiveLatticeTerm A) -> (ClBoundedDistributiveLatticeTerm A)))
      +Cl : ((ClBoundedDistributiveLatticeTerm A) -> ((ClBoundedDistributiveLatticeTerm A) -> (ClBoundedDistributiveLatticeTerm A)))
      0Cl : (ClBoundedDistributiveLatticeTerm A)
      1Cl : (ClBoundedDistributiveLatticeTerm A)
    data OpBoundedDistributiveLatticeTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpBoundedDistributiveLatticeTerm n))
      *OL : ((OpBoundedDistributiveLatticeTerm n) -> ((OpBoundedDistributiveLatticeTerm n) -> (OpBoundedDistributiveLatticeTerm n)))
      +OL : ((OpBoundedDistributiveLatticeTerm n) -> ((OpBoundedDistributiveLatticeTerm n) -> (OpBoundedDistributiveLatticeTerm n)))
      0OL : (OpBoundedDistributiveLatticeTerm n)
      1OL : (OpBoundedDistributiveLatticeTerm n)
    data OpBoundedDistributiveLatticeTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpBoundedDistributiveLatticeTerm2 n A))
      sing2 : (A -> (OpBoundedDistributiveLatticeTerm2 n A))
      *OL2 : ((OpBoundedDistributiveLatticeTerm2 n A) -> ((OpBoundedDistributiveLatticeTerm2 n A) -> (OpBoundedDistributiveLatticeTerm2 n A)))
      +OL2 : ((OpBoundedDistributiveLatticeTerm2 n A) -> ((OpBoundedDistributiveLatticeTerm2 n A) -> (OpBoundedDistributiveLatticeTerm2 n A)))
      0OL2 : (OpBoundedDistributiveLatticeTerm2 n A)
      1OL2 : (OpBoundedDistributiveLatticeTerm2 n A)
    simplifyCl : {A : Set} -> ((ClBoundedDistributiveLatticeTerm A) -> (ClBoundedDistributiveLatticeTerm A))
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl (*Cl 1Cl x) = x 
    simplifyCl (*Cl x 1Cl) = x 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 0Cl = 0Cl 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpBoundedDistributiveLatticeTerm n) -> (OpBoundedDistributiveLatticeTerm n))
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB (*OL 1OL x) = x 
    simplifyOpB (*OL x 1OL) = x 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 0OL = 0OL 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpBoundedDistributiveLatticeTerm2 n A) -> (OpBoundedDistributiveLatticeTerm2 n A))
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp (*OL2 1OL2 x) = x 
    simplifyOp (*OL2 x 1OL2) = x 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((BoundedDistributiveLattice A) -> (BoundedDistributiveLatticeTerm -> A))
    evalB Bo (*L x1 x2) = ((* Bo) (evalB Bo x1) (evalB Bo x2)) 
    evalB Bo (+L x1 x2) = ((+ Bo) (evalB Bo x1) (evalB Bo x2)) 
    evalB Bo 0L = (0 Bo) 
    evalB Bo 1L = (1 Bo) 
    evalCl : {A : Set} -> ((BoundedDistributiveLattice A) -> ((ClBoundedDistributiveLatticeTerm A) -> A))
    evalCl Bo (sing x1) = x1 
    evalCl Bo (*Cl x1 x2) = ((* Bo) (evalCl Bo x1) (evalCl Bo x2)) 
    evalCl Bo (+Cl x1 x2) = ((+ Bo) (evalCl Bo x1) (evalCl Bo x2)) 
    evalCl Bo 0Cl = (0 Bo) 
    evalCl Bo 1Cl = (1 Bo) 
    evalOpB : {A : Set} {n : Nat} -> ((BoundedDistributiveLattice A) -> ((Vec A n) -> ((OpBoundedDistributiveLatticeTerm n) -> A)))
    evalOpB Bo vars (v x1) = (lookup _ x1 vars) 
    evalOpB Bo vars (*OL x1 x2) = ((* Bo) (evalOpB Bo vars x1) (evalOpB Bo vars x2)) 
    evalOpB Bo vars (+OL x1 x2) = ((+ Bo) (evalOpB Bo vars x1) (evalOpB Bo vars x2)) 
    evalOpB Bo vars 0OL = (0 Bo) 
    evalOpB Bo vars 1OL = (1 Bo) 
    evalOp : {A : Set} {n : Nat} -> ((BoundedDistributiveLattice A) -> ((Vec A n) -> ((OpBoundedDistributiveLatticeTerm2 n A) -> A)))
    evalOp Bo vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Bo vars (sing2 x1) = x1 
    evalOp Bo vars (*OL2 x1 x2) = ((* Bo) (evalOp Bo vars x1) (evalOp Bo vars x2)) 
    evalOp Bo vars (+OL2 x1 x2) = ((+ Bo) (evalOp Bo vars x1) (evalOp Bo vars x2)) 
    evalOp Bo vars 0OL2 = (0 Bo) 
    evalOp Bo vars 1OL2 = (1 Bo) 
    inductionB : {P : (BoundedDistributiveLatticeTerm -> Set)} -> (((x1 x2 : BoundedDistributiveLatticeTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : BoundedDistributiveLatticeTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((P 0L) -> ((P 1L) -> ((x : BoundedDistributiveLatticeTerm) -> (P x))))))
    inductionB {p} p*l p+l p0l p1l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l p0l p1l x1) (inductionB {p} p*l p+l p0l p1l x2)) 
    inductionB {p} p*l p+l p0l p1l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l p0l p1l x1) (inductionB {p} p*l p+l p0l p1l x2)) 
    inductionB {p} p*l p+l p0l p1l 0L = p0l 
    inductionB {p} p*l p+l p0l p1l 1L = p1l 
    inductionCl : {A : Set} {P : ((ClBoundedDistributiveLatticeTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClBoundedDistributiveLatticeTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClBoundedDistributiveLatticeTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((P 0Cl) -> ((P 1Cl) -> ((x : (ClBoundedDistributiveLatticeTerm A)) -> (P x)))))))
    inductionCl {_} {p} psing p*cl p+cl p0cl p1cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl p0cl p1cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl p0cl p1cl x1) (inductionCl {_} {p} psing p*cl p+cl p0cl p1cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl p0cl p1cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl p0cl p1cl x1) (inductionCl {_} {p} psing p*cl p+cl p0cl p1cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl p0cl p1cl 0Cl = p0cl 
    inductionCl {_} {p} psing p*cl p+cl p0cl p1cl 1Cl = p1cl 
    inductionOpB : {n : Nat} {P : ((OpBoundedDistributiveLatticeTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpBoundedDistributiveLatticeTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpBoundedDistributiveLatticeTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((P 0OL) -> ((P 1OL) -> ((x : (OpBoundedDistributiveLatticeTerm n)) -> (P x)))))))
    inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol x1) (inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol x1) (inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol 0OL = p0ol 
    inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol 1OL = p1ol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpBoundedDistributiveLatticeTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpBoundedDistributiveLatticeTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpBoundedDistributiveLatticeTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((P 0OL2) -> ((P 1OL2) -> ((x : (OpBoundedDistributiveLatticeTerm2 n A)) -> (P x))))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 1OL2 = p1ol2 
    *L' : (BoundedDistributiveLatticeTerm -> (BoundedDistributiveLatticeTerm -> BoundedDistributiveLatticeTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (BoundedDistributiveLatticeTerm -> (BoundedDistributiveLatticeTerm -> BoundedDistributiveLatticeTerm))
    +L' x1 x2 = (+L x1 x2) 
    0L' : BoundedDistributiveLatticeTerm
    0L'  = 0L 
    1L' : BoundedDistributiveLatticeTerm
    1L'  = 1L 
    stageB : (BoundedDistributiveLatticeTerm -> (Staged BoundedDistributiveLatticeTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB 0L = (Now 0L) 
    stageB 1L = (Now 1L) 
    *Cl' : {A : Set} -> ((ClBoundedDistributiveLatticeTerm A) -> ((ClBoundedDistributiveLatticeTerm A) -> (ClBoundedDistributiveLatticeTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClBoundedDistributiveLatticeTerm A) -> ((ClBoundedDistributiveLatticeTerm A) -> (ClBoundedDistributiveLatticeTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    0Cl' : {A : Set} -> (ClBoundedDistributiveLatticeTerm A)
    0Cl'  = 0Cl 
    1Cl' : {A : Set} -> (ClBoundedDistributiveLatticeTerm A)
    1Cl'  = 1Cl 
    stageCl : {A : Set} -> ((ClBoundedDistributiveLatticeTerm A) -> (Staged (ClBoundedDistributiveLatticeTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl 1Cl = (Now 1Cl) 
    *OL' : {n : Nat} -> ((OpBoundedDistributiveLatticeTerm n) -> ((OpBoundedDistributiveLatticeTerm n) -> (OpBoundedDistributiveLatticeTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpBoundedDistributiveLatticeTerm n) -> ((OpBoundedDistributiveLatticeTerm n) -> (OpBoundedDistributiveLatticeTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    0OL' : {n : Nat} -> (OpBoundedDistributiveLatticeTerm n)
    0OL'  = 0OL 
    1OL' : {n : Nat} -> (OpBoundedDistributiveLatticeTerm n)
    1OL'  = 1OL 
    stageOpB : {n : Nat} -> ((OpBoundedDistributiveLatticeTerm n) -> (Staged (OpBoundedDistributiveLatticeTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB 1OL = (Now 1OL) 
    *OL2' : {n : Nat} {A : Set} -> ((OpBoundedDistributiveLatticeTerm2 n A) -> ((OpBoundedDistributiveLatticeTerm2 n A) -> (OpBoundedDistributiveLatticeTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpBoundedDistributiveLatticeTerm2 n A) -> ((OpBoundedDistributiveLatticeTerm2 n A) -> (OpBoundedDistributiveLatticeTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    0OL2' : {n : Nat} {A : Set} -> (OpBoundedDistributiveLatticeTerm2 n A)
    0OL2'  = 0OL2 
    1OL2' : {n : Nat} {A : Set} -> (OpBoundedDistributiveLatticeTerm2 n A)
    1OL2'  = 1OL2 
    stageOp : {n : Nat} {A : Set} -> ((OpBoundedDistributiveLatticeTerm2 n A) -> (Staged (OpBoundedDistributiveLatticeTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp 1OL2 = (Now 1OL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        0T : (Repr A)
        1T : (Repr A)
  module BoundedJoinLattice  where
    record BoundedJoinLattice (A : Set) : Set where
      constructor BoundedJoinLatticeC
      field
        + : (A -> (A -> A))
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        idempotent_+ : {x : A} -> (+ x x) == x
        0 : A
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
        * : (A -> (A -> A))
        commutative_* : {x y : A} -> (* x y) == (* y x)
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        idempotent_* : {x : A} -> (* x x) == x
        leftAbsorp_*_+ : {x y : A} -> (* x (+ x y)) == x
        leftAbsorp_+_* : {x y : A} -> (+ x (* x y)) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        +S : (AS -> (AS -> AS))
        0S : AS
        *S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        0P : (Prod A A)
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        idempotent_+P : {xP : (Prod A A)} -> (+P xP xP) == xP
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
        commutative_*P : {xP yP : (Prod A A)} -> (*P xP yP) == (*P yP xP)
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        idempotent_*P : {xP : (Prod A A)} -> (*P xP xP) == xP
        leftAbsorp_*_+P : {xP yP : (Prod A A)} -> (*P xP (+P xP yP)) == xP
        leftAbsorp_+_*P : {xP yP : (Prod A A)} -> (+P xP (*P xP yP)) == xP
    record Hom {A1 : Set} {A2 : Set} (Bo1 : (BoundedJoinLattice A1)) (Bo2 : (BoundedJoinLattice A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Bo1) x1 x2)) == ((+ Bo2) (hom x1) (hom x2))
        pres-0 : (hom (0 Bo1)) == (0 Bo2)
        pres-* : {x1 x2 : A1} -> (hom ((* Bo1) x1 x2)) == ((* Bo2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Bo1 : (BoundedJoinLattice A1)) (Bo2 : (BoundedJoinLattice A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Bo1) x1 x2) ((+ Bo2) y1 y2))))
        interp-0 : (interp (0 Bo1) (0 Bo2))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Bo1) x1 x2) ((* Bo2) y1 y2))))
    data BoundedJoinLatticeTerm  : Set where
      +L : (BoundedJoinLatticeTerm -> (BoundedJoinLatticeTerm -> BoundedJoinLatticeTerm))
      0L : BoundedJoinLatticeTerm
      *L : (BoundedJoinLatticeTerm -> (BoundedJoinLatticeTerm -> BoundedJoinLatticeTerm))
    data ClBoundedJoinLatticeTerm (A : Set) : Set where
      sing : (A -> (ClBoundedJoinLatticeTerm A))
      +Cl : ((ClBoundedJoinLatticeTerm A) -> ((ClBoundedJoinLatticeTerm A) -> (ClBoundedJoinLatticeTerm A)))
      0Cl : (ClBoundedJoinLatticeTerm A)
      *Cl : ((ClBoundedJoinLatticeTerm A) -> ((ClBoundedJoinLatticeTerm A) -> (ClBoundedJoinLatticeTerm A)))
    data OpBoundedJoinLatticeTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpBoundedJoinLatticeTerm n))
      +OL : ((OpBoundedJoinLatticeTerm n) -> ((OpBoundedJoinLatticeTerm n) -> (OpBoundedJoinLatticeTerm n)))
      0OL : (OpBoundedJoinLatticeTerm n)
      *OL : ((OpBoundedJoinLatticeTerm n) -> ((OpBoundedJoinLatticeTerm n) -> (OpBoundedJoinLatticeTerm n)))
    data OpBoundedJoinLatticeTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpBoundedJoinLatticeTerm2 n A))
      sing2 : (A -> (OpBoundedJoinLatticeTerm2 n A))
      +OL2 : ((OpBoundedJoinLatticeTerm2 n A) -> ((OpBoundedJoinLatticeTerm2 n A) -> (OpBoundedJoinLatticeTerm2 n A)))
      0OL2 : (OpBoundedJoinLatticeTerm2 n A)
      *OL2 : ((OpBoundedJoinLatticeTerm2 n A) -> ((OpBoundedJoinLatticeTerm2 n A) -> (OpBoundedJoinLatticeTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClBoundedJoinLatticeTerm A) -> (ClBoundedJoinLatticeTerm A))
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 0Cl = 0Cl 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpBoundedJoinLatticeTerm n) -> (OpBoundedJoinLatticeTerm n))
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 0OL = 0OL 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpBoundedJoinLatticeTerm2 n A) -> (OpBoundedJoinLatticeTerm2 n A))
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((BoundedJoinLattice A) -> (BoundedJoinLatticeTerm -> A))
    evalB Bo (+L x1 x2) = ((+ Bo) (evalB Bo x1) (evalB Bo x2)) 
    evalB Bo 0L = (0 Bo) 
    evalB Bo (*L x1 x2) = ((* Bo) (evalB Bo x1) (evalB Bo x2)) 
    evalCl : {A : Set} -> ((BoundedJoinLattice A) -> ((ClBoundedJoinLatticeTerm A) -> A))
    evalCl Bo (sing x1) = x1 
    evalCl Bo (+Cl x1 x2) = ((+ Bo) (evalCl Bo x1) (evalCl Bo x2)) 
    evalCl Bo 0Cl = (0 Bo) 
    evalCl Bo (*Cl x1 x2) = ((* Bo) (evalCl Bo x1) (evalCl Bo x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((BoundedJoinLattice A) -> ((Vec A n) -> ((OpBoundedJoinLatticeTerm n) -> A)))
    evalOpB Bo vars (v x1) = (lookup _ x1 vars) 
    evalOpB Bo vars (+OL x1 x2) = ((+ Bo) (evalOpB Bo vars x1) (evalOpB Bo vars x2)) 
    evalOpB Bo vars 0OL = (0 Bo) 
    evalOpB Bo vars (*OL x1 x2) = ((* Bo) (evalOpB Bo vars x1) (evalOpB Bo vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((BoundedJoinLattice A) -> ((Vec A n) -> ((OpBoundedJoinLatticeTerm2 n A) -> A)))
    evalOp Bo vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Bo vars (sing2 x1) = x1 
    evalOp Bo vars (+OL2 x1 x2) = ((+ Bo) (evalOp Bo vars x1) (evalOp Bo vars x2)) 
    evalOp Bo vars 0OL2 = (0 Bo) 
    evalOp Bo vars (*OL2 x1 x2) = ((* Bo) (evalOp Bo vars x1) (evalOp Bo vars x2)) 
    inductionB : {P : (BoundedJoinLatticeTerm -> Set)} -> (((x1 x2 : BoundedJoinLatticeTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((P 0L) -> (((x1 x2 : BoundedJoinLatticeTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((x : BoundedJoinLatticeTerm) -> (P x)))))
    inductionB {p} p+l p0l p*l (+L x1 x2) = (p+l _ _ (inductionB {p} p+l p0l p*l x1) (inductionB {p} p+l p0l p*l x2)) 
    inductionB {p} p+l p0l p*l 0L = p0l 
    inductionB {p} p+l p0l p*l (*L x1 x2) = (p*l _ _ (inductionB {p} p+l p0l p*l x1) (inductionB {p} p+l p0l p*l x2)) 
    inductionCl : {A : Set} {P : ((ClBoundedJoinLatticeTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClBoundedJoinLatticeTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((P 0Cl) -> (((x1 x2 : (ClBoundedJoinLatticeTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((x : (ClBoundedJoinLatticeTerm A)) -> (P x))))))
    inductionCl {_} {p} psing p+cl p0cl p*cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p+cl p0cl p*cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p+cl p0cl p*cl x1) (inductionCl {_} {p} psing p+cl p0cl p*cl x2)) 
    inductionCl {_} {p} psing p+cl p0cl p*cl 0Cl = p0cl 
    inductionCl {_} {p} psing p+cl p0cl p*cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p+cl p0cl p*cl x1) (inductionCl {_} {p} psing p+cl p0cl p*cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpBoundedJoinLatticeTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpBoundedJoinLatticeTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((P 0OL) -> (((x1 x2 : (OpBoundedJoinLatticeTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((x : (OpBoundedJoinLatticeTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv p+ol p0ol p*ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p+ol p0ol p*ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p+ol p0ol p*ol x1) (inductionOpB {_} {p} pv p+ol p0ol p*ol x2)) 
    inductionOpB {_} {p} pv p+ol p0ol p*ol 0OL = p0ol 
    inductionOpB {_} {p} pv p+ol p0ol p*ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p+ol p0ol p*ol x1) (inductionOpB {_} {p} pv p+ol p0ol p*ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpBoundedJoinLatticeTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpBoundedJoinLatticeTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((P 0OL2) -> (((x1 x2 : (OpBoundedJoinLatticeTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((x : (OpBoundedJoinLatticeTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 p*ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 p*ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 p*ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 p*ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 p*ol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 p*ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 p*ol2 x2)) 
    +L' : (BoundedJoinLatticeTerm -> (BoundedJoinLatticeTerm -> BoundedJoinLatticeTerm))
    +L' x1 x2 = (+L x1 x2) 
    0L' : BoundedJoinLatticeTerm
    0L'  = 0L 
    *L' : (BoundedJoinLatticeTerm -> (BoundedJoinLatticeTerm -> BoundedJoinLatticeTerm))
    *L' x1 x2 = (*L x1 x2) 
    stageB : (BoundedJoinLatticeTerm -> (Staged BoundedJoinLatticeTerm))
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB 0L = (Now 0L) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    +Cl' : {A : Set} -> ((ClBoundedJoinLatticeTerm A) -> ((ClBoundedJoinLatticeTerm A) -> (ClBoundedJoinLatticeTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    0Cl' : {A : Set} -> (ClBoundedJoinLatticeTerm A)
    0Cl'  = 0Cl 
    *Cl' : {A : Set} -> ((ClBoundedJoinLatticeTerm A) -> ((ClBoundedJoinLatticeTerm A) -> (ClBoundedJoinLatticeTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    stageCl : {A : Set} -> ((ClBoundedJoinLatticeTerm A) -> (Staged (ClBoundedJoinLatticeTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    +OL' : {n : Nat} -> ((OpBoundedJoinLatticeTerm n) -> ((OpBoundedJoinLatticeTerm n) -> (OpBoundedJoinLatticeTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    0OL' : {n : Nat} -> (OpBoundedJoinLatticeTerm n)
    0OL'  = 0OL 
    *OL' : {n : Nat} -> ((OpBoundedJoinLatticeTerm n) -> ((OpBoundedJoinLatticeTerm n) -> (OpBoundedJoinLatticeTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpBoundedJoinLatticeTerm n) -> (Staged (OpBoundedJoinLatticeTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    +OL2' : {n : Nat} {A : Set} -> ((OpBoundedJoinLatticeTerm2 n A) -> ((OpBoundedJoinLatticeTerm2 n A) -> (OpBoundedJoinLatticeTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    0OL2' : {n : Nat} {A : Set} -> (OpBoundedJoinLatticeTerm2 n A)
    0OL2'  = 0OL2 
    *OL2' : {n : Nat} {A : Set} -> ((OpBoundedJoinLatticeTerm2 n A) -> ((OpBoundedJoinLatticeTerm2 n A) -> (OpBoundedJoinLatticeTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpBoundedJoinLatticeTerm2 n A) -> (Staged (OpBoundedJoinLatticeTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        0T : (Repr A)
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module BoundedJoinSemilattice  where
    record BoundedJoinSemilattice (A : Set) : Set where
      constructor BoundedJoinSemilatticeC
      field
        + : (A -> (A -> A))
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        0 : A
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
        idempotent_+ : {x : A} -> (+ x x) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        +S : (AS -> (AS -> AS))
        0S : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        0P : (Prod A A)
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
        idempotent_+P : {xP : (Prod A A)} -> (+P xP xP) == xP
    record Hom {A1 : Set} {A2 : Set} (Bo1 : (BoundedJoinSemilattice A1)) (Bo2 : (BoundedJoinSemilattice A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Bo1) x1 x2)) == ((+ Bo2) (hom x1) (hom x2))
        pres-0 : (hom (0 Bo1)) == (0 Bo2)
    record RelInterp {A1 : Set} {A2 : Set} (Bo1 : (BoundedJoinSemilattice A1)) (Bo2 : (BoundedJoinSemilattice A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Bo1) x1 x2) ((+ Bo2) y1 y2))))
        interp-0 : (interp (0 Bo1) (0 Bo2))
    data BoundedJoinSemilatticeTerm  : Set where
      +L : (BoundedJoinSemilatticeTerm -> (BoundedJoinSemilatticeTerm -> BoundedJoinSemilatticeTerm))
      0L : BoundedJoinSemilatticeTerm
    data ClBoundedJoinSemilatticeTerm (A : Set) : Set where
      sing : (A -> (ClBoundedJoinSemilatticeTerm A))
      +Cl : ((ClBoundedJoinSemilatticeTerm A) -> ((ClBoundedJoinSemilatticeTerm A) -> (ClBoundedJoinSemilatticeTerm A)))
      0Cl : (ClBoundedJoinSemilatticeTerm A)
    data OpBoundedJoinSemilatticeTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpBoundedJoinSemilatticeTerm n))
      +OL : ((OpBoundedJoinSemilatticeTerm n) -> ((OpBoundedJoinSemilatticeTerm n) -> (OpBoundedJoinSemilatticeTerm n)))
      0OL : (OpBoundedJoinSemilatticeTerm n)
    data OpBoundedJoinSemilatticeTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpBoundedJoinSemilatticeTerm2 n A))
      sing2 : (A -> (OpBoundedJoinSemilatticeTerm2 n A))
      +OL2 : ((OpBoundedJoinSemilatticeTerm2 n A) -> ((OpBoundedJoinSemilatticeTerm2 n A) -> (OpBoundedJoinSemilatticeTerm2 n A)))
      0OL2 : (OpBoundedJoinSemilatticeTerm2 n A)
    simplifyCl : {A : Set} -> ((ClBoundedJoinSemilatticeTerm A) -> (ClBoundedJoinSemilatticeTerm A))
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 0Cl = 0Cl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpBoundedJoinSemilatticeTerm n) -> (OpBoundedJoinSemilatticeTerm n))
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 0OL = 0OL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpBoundedJoinSemilatticeTerm2 n A) -> (OpBoundedJoinSemilatticeTerm2 n A))
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((BoundedJoinSemilattice A) -> (BoundedJoinSemilatticeTerm -> A))
    evalB Bo (+L x1 x2) = ((+ Bo) (evalB Bo x1) (evalB Bo x2)) 
    evalB Bo 0L = (0 Bo) 
    evalCl : {A : Set} -> ((BoundedJoinSemilattice A) -> ((ClBoundedJoinSemilatticeTerm A) -> A))
    evalCl Bo (sing x1) = x1 
    evalCl Bo (+Cl x1 x2) = ((+ Bo) (evalCl Bo x1) (evalCl Bo x2)) 
    evalCl Bo 0Cl = (0 Bo) 
    evalOpB : {A : Set} {n : Nat} -> ((BoundedJoinSemilattice A) -> ((Vec A n) -> ((OpBoundedJoinSemilatticeTerm n) -> A)))
    evalOpB Bo vars (v x1) = (lookup _ x1 vars) 
    evalOpB Bo vars (+OL x1 x2) = ((+ Bo) (evalOpB Bo vars x1) (evalOpB Bo vars x2)) 
    evalOpB Bo vars 0OL = (0 Bo) 
    evalOp : {A : Set} {n : Nat} -> ((BoundedJoinSemilattice A) -> ((Vec A n) -> ((OpBoundedJoinSemilatticeTerm2 n A) -> A)))
    evalOp Bo vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Bo vars (sing2 x1) = x1 
    evalOp Bo vars (+OL2 x1 x2) = ((+ Bo) (evalOp Bo vars x1) (evalOp Bo vars x2)) 
    evalOp Bo vars 0OL2 = (0 Bo) 
    inductionB : {P : (BoundedJoinSemilatticeTerm -> Set)} -> (((x1 x2 : BoundedJoinSemilatticeTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((P 0L) -> ((x : BoundedJoinSemilatticeTerm) -> (P x))))
    inductionB {p} p+l p0l (+L x1 x2) = (p+l _ _ (inductionB {p} p+l p0l x1) (inductionB {p} p+l p0l x2)) 
    inductionB {p} p+l p0l 0L = p0l 
    inductionCl : {A : Set} {P : ((ClBoundedJoinSemilatticeTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClBoundedJoinSemilatticeTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((P 0Cl) -> ((x : (ClBoundedJoinSemilatticeTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p+cl p0cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p+cl p0cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p+cl p0cl x1) (inductionCl {_} {p} psing p+cl p0cl x2)) 
    inductionCl {_} {p} psing p+cl p0cl 0Cl = p0cl 
    inductionOpB : {n : Nat} {P : ((OpBoundedJoinSemilatticeTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpBoundedJoinSemilatticeTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((P 0OL) -> ((x : (OpBoundedJoinSemilatticeTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p+ol p0ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p+ol p0ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p+ol p0ol x1) (inductionOpB {_} {p} pv p+ol p0ol x2)) 
    inductionOpB {_} {p} pv p+ol p0ol 0OL = p0ol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpBoundedJoinSemilatticeTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpBoundedJoinSemilatticeTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((P 0OL2) -> ((x : (OpBoundedJoinSemilatticeTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 0OL2 = p0ol2 
    +L' : (BoundedJoinSemilatticeTerm -> (BoundedJoinSemilatticeTerm -> BoundedJoinSemilatticeTerm))
    +L' x1 x2 = (+L x1 x2) 
    0L' : BoundedJoinSemilatticeTerm
    0L'  = 0L 
    stageB : (BoundedJoinSemilatticeTerm -> (Staged BoundedJoinSemilatticeTerm))
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB 0L = (Now 0L) 
    +Cl' : {A : Set} -> ((ClBoundedJoinSemilatticeTerm A) -> ((ClBoundedJoinSemilatticeTerm A) -> (ClBoundedJoinSemilatticeTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    0Cl' : {A : Set} -> (ClBoundedJoinSemilatticeTerm A)
    0Cl'  = 0Cl 
    stageCl : {A : Set} -> ((ClBoundedJoinSemilatticeTerm A) -> (Staged (ClBoundedJoinSemilatticeTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl 0Cl = (Now 0Cl) 
    +OL' : {n : Nat} -> ((OpBoundedJoinSemilatticeTerm n) -> ((OpBoundedJoinSemilatticeTerm n) -> (OpBoundedJoinSemilatticeTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    0OL' : {n : Nat} -> (OpBoundedJoinSemilatticeTerm n)
    0OL'  = 0OL 
    stageOpB : {n : Nat} -> ((OpBoundedJoinSemilatticeTerm n) -> (Staged (OpBoundedJoinSemilatticeTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 0OL = (Now 0OL) 
    +OL2' : {n : Nat} {A : Set} -> ((OpBoundedJoinSemilatticeTerm2 n A) -> ((OpBoundedJoinSemilatticeTerm2 n A) -> (OpBoundedJoinSemilatticeTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    0OL2' : {n : Nat} {A : Set} -> (OpBoundedJoinSemilatticeTerm2 n A)
    0OL2'  = 0OL2 
    stageOp : {n : Nat} {A : Set} -> ((OpBoundedJoinSemilatticeTerm2 n A) -> (Staged (OpBoundedJoinSemilatticeTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp 0OL2 = (Now 0OL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        0T : (Repr A)
  module BoundedLattice  where
    record BoundedLattice (A : Set) : Set where
      constructor BoundedLatticeC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        commutative_* : {x y : A} -> (* x y) == (* y x)
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        idempotent_* : {x : A} -> (* x x) == x
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        idempotent_+ : {x : A} -> (+ x x) == x
        leftAbsorp_*_+ : {x y : A} -> (* x (+ x y)) == x
        leftAbsorp_+_* : {x y : A} -> (+ x (* x y)) == x
        0 : A
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
        1 : A
        lunit_1 : {x : A} -> (* 1 x) == x
        runit_1 : {x : A} -> (* x 1) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
        0S : AS
        1S : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        0P : (Prod A A)
        1P : (Prod A A)
        commutative_*P : {xP yP : (Prod A A)} -> (*P xP yP) == (*P yP xP)
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        idempotent_*P : {xP : (Prod A A)} -> (*P xP xP) == xP
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        idempotent_+P : {xP : (Prod A A)} -> (+P xP xP) == xP
        leftAbsorp_*_+P : {xP yP : (Prod A A)} -> (*P xP (+P xP yP)) == xP
        leftAbsorp_+_*P : {xP yP : (Prod A A)} -> (+P xP (*P xP yP)) == xP
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
        lunit_1P : {xP : (Prod A A)} -> (*P 1P xP) == xP
        runit_1P : {xP : (Prod A A)} -> (*P xP 1P) == xP
    record Hom {A1 : Set} {A2 : Set} (Bo1 : (BoundedLattice A1)) (Bo2 : (BoundedLattice A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Bo1) x1 x2)) == ((* Bo2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Bo1) x1 x2)) == ((+ Bo2) (hom x1) (hom x2))
        pres-0 : (hom (0 Bo1)) == (0 Bo2)
        pres-1 : (hom (1 Bo1)) == (1 Bo2)
    record RelInterp {A1 : Set} {A2 : Set} (Bo1 : (BoundedLattice A1)) (Bo2 : (BoundedLattice A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Bo1) x1 x2) ((* Bo2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Bo1) x1 x2) ((+ Bo2) y1 y2))))
        interp-0 : (interp (0 Bo1) (0 Bo2))
        interp-1 : (interp (1 Bo1) (1 Bo2))
    data BoundedLatticeTerm  : Set where
      *L : (BoundedLatticeTerm -> (BoundedLatticeTerm -> BoundedLatticeTerm))
      +L : (BoundedLatticeTerm -> (BoundedLatticeTerm -> BoundedLatticeTerm))
      0L : BoundedLatticeTerm
      1L : BoundedLatticeTerm
    data ClBoundedLatticeTerm (A : Set) : Set where
      sing : (A -> (ClBoundedLatticeTerm A))
      *Cl : ((ClBoundedLatticeTerm A) -> ((ClBoundedLatticeTerm A) -> (ClBoundedLatticeTerm A)))
      +Cl : ((ClBoundedLatticeTerm A) -> ((ClBoundedLatticeTerm A) -> (ClBoundedLatticeTerm A)))
      0Cl : (ClBoundedLatticeTerm A)
      1Cl : (ClBoundedLatticeTerm A)
    data OpBoundedLatticeTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpBoundedLatticeTerm n))
      *OL : ((OpBoundedLatticeTerm n) -> ((OpBoundedLatticeTerm n) -> (OpBoundedLatticeTerm n)))
      +OL : ((OpBoundedLatticeTerm n) -> ((OpBoundedLatticeTerm n) -> (OpBoundedLatticeTerm n)))
      0OL : (OpBoundedLatticeTerm n)
      1OL : (OpBoundedLatticeTerm n)
    data OpBoundedLatticeTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpBoundedLatticeTerm2 n A))
      sing2 : (A -> (OpBoundedLatticeTerm2 n A))
      *OL2 : ((OpBoundedLatticeTerm2 n A) -> ((OpBoundedLatticeTerm2 n A) -> (OpBoundedLatticeTerm2 n A)))
      +OL2 : ((OpBoundedLatticeTerm2 n A) -> ((OpBoundedLatticeTerm2 n A) -> (OpBoundedLatticeTerm2 n A)))
      0OL2 : (OpBoundedLatticeTerm2 n A)
      1OL2 : (OpBoundedLatticeTerm2 n A)
    simplifyCl : {A : Set} -> ((ClBoundedLatticeTerm A) -> (ClBoundedLatticeTerm A))
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl (*Cl 1Cl x) = x 
    simplifyCl (*Cl x 1Cl) = x 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 0Cl = 0Cl 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpBoundedLatticeTerm n) -> (OpBoundedLatticeTerm n))
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB (*OL 1OL x) = x 
    simplifyOpB (*OL x 1OL) = x 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 0OL = 0OL 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpBoundedLatticeTerm2 n A) -> (OpBoundedLatticeTerm2 n A))
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp (*OL2 1OL2 x) = x 
    simplifyOp (*OL2 x 1OL2) = x 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((BoundedLattice A) -> (BoundedLatticeTerm -> A))
    evalB Bo (*L x1 x2) = ((* Bo) (evalB Bo x1) (evalB Bo x2)) 
    evalB Bo (+L x1 x2) = ((+ Bo) (evalB Bo x1) (evalB Bo x2)) 
    evalB Bo 0L = (0 Bo) 
    evalB Bo 1L = (1 Bo) 
    evalCl : {A : Set} -> ((BoundedLattice A) -> ((ClBoundedLatticeTerm A) -> A))
    evalCl Bo (sing x1) = x1 
    evalCl Bo (*Cl x1 x2) = ((* Bo) (evalCl Bo x1) (evalCl Bo x2)) 
    evalCl Bo (+Cl x1 x2) = ((+ Bo) (evalCl Bo x1) (evalCl Bo x2)) 
    evalCl Bo 0Cl = (0 Bo) 
    evalCl Bo 1Cl = (1 Bo) 
    evalOpB : {A : Set} {n : Nat} -> ((BoundedLattice A) -> ((Vec A n) -> ((OpBoundedLatticeTerm n) -> A)))
    evalOpB Bo vars (v x1) = (lookup _ x1 vars) 
    evalOpB Bo vars (*OL x1 x2) = ((* Bo) (evalOpB Bo vars x1) (evalOpB Bo vars x2)) 
    evalOpB Bo vars (+OL x1 x2) = ((+ Bo) (evalOpB Bo vars x1) (evalOpB Bo vars x2)) 
    evalOpB Bo vars 0OL = (0 Bo) 
    evalOpB Bo vars 1OL = (1 Bo) 
    evalOp : {A : Set} {n : Nat} -> ((BoundedLattice A) -> ((Vec A n) -> ((OpBoundedLatticeTerm2 n A) -> A)))
    evalOp Bo vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Bo vars (sing2 x1) = x1 
    evalOp Bo vars (*OL2 x1 x2) = ((* Bo) (evalOp Bo vars x1) (evalOp Bo vars x2)) 
    evalOp Bo vars (+OL2 x1 x2) = ((+ Bo) (evalOp Bo vars x1) (evalOp Bo vars x2)) 
    evalOp Bo vars 0OL2 = (0 Bo) 
    evalOp Bo vars 1OL2 = (1 Bo) 
    inductionB : {P : (BoundedLatticeTerm -> Set)} -> (((x1 x2 : BoundedLatticeTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : BoundedLatticeTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((P 0L) -> ((P 1L) -> ((x : BoundedLatticeTerm) -> (P x))))))
    inductionB {p} p*l p+l p0l p1l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l p0l p1l x1) (inductionB {p} p*l p+l p0l p1l x2)) 
    inductionB {p} p*l p+l p0l p1l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l p0l p1l x1) (inductionB {p} p*l p+l p0l p1l x2)) 
    inductionB {p} p*l p+l p0l p1l 0L = p0l 
    inductionB {p} p*l p+l p0l p1l 1L = p1l 
    inductionCl : {A : Set} {P : ((ClBoundedLatticeTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClBoundedLatticeTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClBoundedLatticeTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((P 0Cl) -> ((P 1Cl) -> ((x : (ClBoundedLatticeTerm A)) -> (P x)))))))
    inductionCl {_} {p} psing p*cl p+cl p0cl p1cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl p0cl p1cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl p0cl p1cl x1) (inductionCl {_} {p} psing p*cl p+cl p0cl p1cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl p0cl p1cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl p0cl p1cl x1) (inductionCl {_} {p} psing p*cl p+cl p0cl p1cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl p0cl p1cl 0Cl = p0cl 
    inductionCl {_} {p} psing p*cl p+cl p0cl p1cl 1Cl = p1cl 
    inductionOpB : {n : Nat} {P : ((OpBoundedLatticeTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpBoundedLatticeTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpBoundedLatticeTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((P 0OL) -> ((P 1OL) -> ((x : (OpBoundedLatticeTerm n)) -> (P x)))))))
    inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol x1) (inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol x1) (inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol 0OL = p0ol 
    inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol 1OL = p1ol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpBoundedLatticeTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpBoundedLatticeTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpBoundedLatticeTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((P 0OL2) -> ((P 1OL2) -> ((x : (OpBoundedLatticeTerm2 n A)) -> (P x))))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 1OL2 = p1ol2 
    *L' : (BoundedLatticeTerm -> (BoundedLatticeTerm -> BoundedLatticeTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (BoundedLatticeTerm -> (BoundedLatticeTerm -> BoundedLatticeTerm))
    +L' x1 x2 = (+L x1 x2) 
    0L' : BoundedLatticeTerm
    0L'  = 0L 
    1L' : BoundedLatticeTerm
    1L'  = 1L 
    stageB : (BoundedLatticeTerm -> (Staged BoundedLatticeTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB 0L = (Now 0L) 
    stageB 1L = (Now 1L) 
    *Cl' : {A : Set} -> ((ClBoundedLatticeTerm A) -> ((ClBoundedLatticeTerm A) -> (ClBoundedLatticeTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClBoundedLatticeTerm A) -> ((ClBoundedLatticeTerm A) -> (ClBoundedLatticeTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    0Cl' : {A : Set} -> (ClBoundedLatticeTerm A)
    0Cl'  = 0Cl 
    1Cl' : {A : Set} -> (ClBoundedLatticeTerm A)
    1Cl'  = 1Cl 
    stageCl : {A : Set} -> ((ClBoundedLatticeTerm A) -> (Staged (ClBoundedLatticeTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl 1Cl = (Now 1Cl) 
    *OL' : {n : Nat} -> ((OpBoundedLatticeTerm n) -> ((OpBoundedLatticeTerm n) -> (OpBoundedLatticeTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpBoundedLatticeTerm n) -> ((OpBoundedLatticeTerm n) -> (OpBoundedLatticeTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    0OL' : {n : Nat} -> (OpBoundedLatticeTerm n)
    0OL'  = 0OL 
    1OL' : {n : Nat} -> (OpBoundedLatticeTerm n)
    1OL'  = 1OL 
    stageOpB : {n : Nat} -> ((OpBoundedLatticeTerm n) -> (Staged (OpBoundedLatticeTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB 1OL = (Now 1OL) 
    *OL2' : {n : Nat} {A : Set} -> ((OpBoundedLatticeTerm2 n A) -> ((OpBoundedLatticeTerm2 n A) -> (OpBoundedLatticeTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpBoundedLatticeTerm2 n A) -> ((OpBoundedLatticeTerm2 n A) -> (OpBoundedLatticeTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    0OL2' : {n : Nat} {A : Set} -> (OpBoundedLatticeTerm2 n A)
    0OL2'  = 0OL2 
    1OL2' : {n : Nat} {A : Set} -> (OpBoundedLatticeTerm2 n A)
    1OL2'  = 1OL2 
    stageOp : {n : Nat} {A : Set} -> ((OpBoundedLatticeTerm2 n A) -> (Staged (OpBoundedLatticeTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp 1OL2 = (Now 1OL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        0T : (Repr A)
        1T : (Repr A)
  module BoundedMeetLattice  where
    record BoundedMeetLattice (A : Set) : Set where
      constructor BoundedMeetLatticeC
      field
        * : (A -> (A -> A))
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        idempotent_* : {x : A} -> (* x x) == x
        commutative_* : {x y : A} -> (* x y) == (* y x)
        1 : A
        lunit_1 : {x : A} -> (* 1 x) == x
        runit_1 : {x : A} -> (* x 1) == x
        + : (A -> (A -> A))
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        idempotent_+ : {x : A} -> (+ x x) == x
        leftAbsorp_*_+ : {x y : A} -> (* x (+ x y)) == x
        leftAbsorp_+_* : {x y : A} -> (+ x (* x y)) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        1S : AS
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        1P : (Prod A A)
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        idempotent_*P : {xP : (Prod A A)} -> (*P xP xP) == xP
        commutative_*P : {xP yP : (Prod A A)} -> (*P xP yP) == (*P yP xP)
        lunit_1P : {xP : (Prod A A)} -> (*P 1P xP) == xP
        runit_1P : {xP : (Prod A A)} -> (*P xP 1P) == xP
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        idempotent_+P : {xP : (Prod A A)} -> (+P xP xP) == xP
        leftAbsorp_*_+P : {xP yP : (Prod A A)} -> (*P xP (+P xP yP)) == xP
        leftAbsorp_+_*P : {xP yP : (Prod A A)} -> (+P xP (*P xP yP)) == xP
    record Hom {A1 : Set} {A2 : Set} (Bo1 : (BoundedMeetLattice A1)) (Bo2 : (BoundedMeetLattice A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Bo1) x1 x2)) == ((* Bo2) (hom x1) (hom x2))
        pres-1 : (hom (1 Bo1)) == (1 Bo2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Bo1) x1 x2)) == ((+ Bo2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Bo1 : (BoundedMeetLattice A1)) (Bo2 : (BoundedMeetLattice A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Bo1) x1 x2) ((* Bo2) y1 y2))))
        interp-1 : (interp (1 Bo1) (1 Bo2))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Bo1) x1 x2) ((+ Bo2) y1 y2))))
    data BoundedMeetLatticeTerm  : Set where
      *L : (BoundedMeetLatticeTerm -> (BoundedMeetLatticeTerm -> BoundedMeetLatticeTerm))
      1L : BoundedMeetLatticeTerm
      +L : (BoundedMeetLatticeTerm -> (BoundedMeetLatticeTerm -> BoundedMeetLatticeTerm))
    data ClBoundedMeetLatticeTerm (A : Set) : Set where
      sing : (A -> (ClBoundedMeetLatticeTerm A))
      *Cl : ((ClBoundedMeetLatticeTerm A) -> ((ClBoundedMeetLatticeTerm A) -> (ClBoundedMeetLatticeTerm A)))
      1Cl : (ClBoundedMeetLatticeTerm A)
      +Cl : ((ClBoundedMeetLatticeTerm A) -> ((ClBoundedMeetLatticeTerm A) -> (ClBoundedMeetLatticeTerm A)))
    data OpBoundedMeetLatticeTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpBoundedMeetLatticeTerm n))
      *OL : ((OpBoundedMeetLatticeTerm n) -> ((OpBoundedMeetLatticeTerm n) -> (OpBoundedMeetLatticeTerm n)))
      1OL : (OpBoundedMeetLatticeTerm n)
      +OL : ((OpBoundedMeetLatticeTerm n) -> ((OpBoundedMeetLatticeTerm n) -> (OpBoundedMeetLatticeTerm n)))
    data OpBoundedMeetLatticeTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpBoundedMeetLatticeTerm2 n A))
      sing2 : (A -> (OpBoundedMeetLatticeTerm2 n A))
      *OL2 : ((OpBoundedMeetLatticeTerm2 n A) -> ((OpBoundedMeetLatticeTerm2 n A) -> (OpBoundedMeetLatticeTerm2 n A)))
      1OL2 : (OpBoundedMeetLatticeTerm2 n A)
      +OL2 : ((OpBoundedMeetLatticeTerm2 n A) -> ((OpBoundedMeetLatticeTerm2 n A) -> (OpBoundedMeetLatticeTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClBoundedMeetLatticeTerm A) -> (ClBoundedMeetLatticeTerm A))
    simplifyCl (*Cl 1Cl x) = x 
    simplifyCl (*Cl x 1Cl) = x 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpBoundedMeetLatticeTerm n) -> (OpBoundedMeetLatticeTerm n))
    simplifyOpB (*OL 1OL x) = x 
    simplifyOpB (*OL x 1OL) = x 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpBoundedMeetLatticeTerm2 n A) -> (OpBoundedMeetLatticeTerm2 n A))
    simplifyOp (*OL2 1OL2 x) = x 
    simplifyOp (*OL2 x 1OL2) = x 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((BoundedMeetLattice A) -> (BoundedMeetLatticeTerm -> A))
    evalB Bo (*L x1 x2) = ((* Bo) (evalB Bo x1) (evalB Bo x2)) 
    evalB Bo 1L = (1 Bo) 
    evalB Bo (+L x1 x2) = ((+ Bo) (evalB Bo x1) (evalB Bo x2)) 
    evalCl : {A : Set} -> ((BoundedMeetLattice A) -> ((ClBoundedMeetLatticeTerm A) -> A))
    evalCl Bo (sing x1) = x1 
    evalCl Bo (*Cl x1 x2) = ((* Bo) (evalCl Bo x1) (evalCl Bo x2)) 
    evalCl Bo 1Cl = (1 Bo) 
    evalCl Bo (+Cl x1 x2) = ((+ Bo) (evalCl Bo x1) (evalCl Bo x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((BoundedMeetLattice A) -> ((Vec A n) -> ((OpBoundedMeetLatticeTerm n) -> A)))
    evalOpB Bo vars (v x1) = (lookup _ x1 vars) 
    evalOpB Bo vars (*OL x1 x2) = ((* Bo) (evalOpB Bo vars x1) (evalOpB Bo vars x2)) 
    evalOpB Bo vars 1OL = (1 Bo) 
    evalOpB Bo vars (+OL x1 x2) = ((+ Bo) (evalOpB Bo vars x1) (evalOpB Bo vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((BoundedMeetLattice A) -> ((Vec A n) -> ((OpBoundedMeetLatticeTerm2 n A) -> A)))
    evalOp Bo vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Bo vars (sing2 x1) = x1 
    evalOp Bo vars (*OL2 x1 x2) = ((* Bo) (evalOp Bo vars x1) (evalOp Bo vars x2)) 
    evalOp Bo vars 1OL2 = (1 Bo) 
    evalOp Bo vars (+OL2 x1 x2) = ((+ Bo) (evalOp Bo vars x1) (evalOp Bo vars x2)) 
    inductionB : {P : (BoundedMeetLatticeTerm -> Set)} -> (((x1 x2 : BoundedMeetLatticeTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((P 1L) -> (((x1 x2 : BoundedMeetLatticeTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : BoundedMeetLatticeTerm) -> (P x)))))
    inductionB {p} p*l p1l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p1l p+l x1) (inductionB {p} p*l p1l p+l x2)) 
    inductionB {p} p*l p1l p+l 1L = p1l 
    inductionB {p} p*l p1l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p1l p+l x1) (inductionB {p} p*l p1l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClBoundedMeetLatticeTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClBoundedMeetLatticeTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((P 1Cl) -> (((x1 x2 : (ClBoundedMeetLatticeTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClBoundedMeetLatticeTerm A)) -> (P x))))))
    inductionCl {_} {p} psing p*cl p1cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p1cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p1cl p+cl x1) (inductionCl {_} {p} psing p*cl p1cl p+cl x2)) 
    inductionCl {_} {p} psing p*cl p1cl p+cl 1Cl = p1cl 
    inductionCl {_} {p} psing p*cl p1cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p1cl p+cl x1) (inductionCl {_} {p} psing p*cl p1cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpBoundedMeetLatticeTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpBoundedMeetLatticeTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((P 1OL) -> (((x1 x2 : (OpBoundedMeetLatticeTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpBoundedMeetLatticeTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv p*ol p1ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p1ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p1ol p+ol x1) (inductionOpB {_} {p} pv p*ol p1ol p+ol x2)) 
    inductionOpB {_} {p} pv p*ol p1ol p+ol 1OL = p1ol 
    inductionOpB {_} {p} pv p*ol p1ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p1ol p+ol x1) (inductionOpB {_} {p} pv p*ol p1ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpBoundedMeetLatticeTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpBoundedMeetLatticeTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((P 1OL2) -> (((x1 x2 : (OpBoundedMeetLatticeTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpBoundedMeetLatticeTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 1OL2 = p1ol2 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 x2)) 
    *L' : (BoundedMeetLatticeTerm -> (BoundedMeetLatticeTerm -> BoundedMeetLatticeTerm))
    *L' x1 x2 = (*L x1 x2) 
    1L' : BoundedMeetLatticeTerm
    1L'  = 1L 
    +L' : (BoundedMeetLatticeTerm -> (BoundedMeetLatticeTerm -> BoundedMeetLatticeTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (BoundedMeetLatticeTerm -> (Staged BoundedMeetLatticeTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB 1L = (Now 1L) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClBoundedMeetLatticeTerm A) -> ((ClBoundedMeetLatticeTerm A) -> (ClBoundedMeetLatticeTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    1Cl' : {A : Set} -> (ClBoundedMeetLatticeTerm A)
    1Cl'  = 1Cl 
    +Cl' : {A : Set} -> ((ClBoundedMeetLatticeTerm A) -> ((ClBoundedMeetLatticeTerm A) -> (ClBoundedMeetLatticeTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClBoundedMeetLatticeTerm A) -> (Staged (ClBoundedMeetLatticeTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl 1Cl = (Now 1Cl) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpBoundedMeetLatticeTerm n) -> ((OpBoundedMeetLatticeTerm n) -> (OpBoundedMeetLatticeTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    1OL' : {n : Nat} -> (OpBoundedMeetLatticeTerm n)
    1OL'  = 1OL 
    +OL' : {n : Nat} -> ((OpBoundedMeetLatticeTerm n) -> ((OpBoundedMeetLatticeTerm n) -> (OpBoundedMeetLatticeTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpBoundedMeetLatticeTerm n) -> (Staged (OpBoundedMeetLatticeTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 1OL = (Now 1OL) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpBoundedMeetLatticeTerm2 n A) -> ((OpBoundedMeetLatticeTerm2 n A) -> (OpBoundedMeetLatticeTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    1OL2' : {n : Nat} {A : Set} -> (OpBoundedMeetLatticeTerm2 n A)
    1OL2'  = 1OL2 
    +OL2' : {n : Nat} {A : Set} -> ((OpBoundedMeetLatticeTerm2 n A) -> ((OpBoundedMeetLatticeTerm2 n A) -> (OpBoundedMeetLatticeTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpBoundedMeetLatticeTerm2 n A) -> (Staged (OpBoundedMeetLatticeTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp 1OL2 = (Now 1OL2) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        1T : (Repr A)
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module BoundedMeetSemilattice  where
    record BoundedMeetSemilattice (A : Set) : Set where
      constructor BoundedMeetSemilatticeC
      field
        * : (A -> (A -> A))
        commutative_* : {x y : A} -> (* x y) == (* y x)
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        1 : A
        lunit_1 : {x : A} -> (* 1 x) == x
        runit_1 : {x : A} -> (* x 1) == x
        idempotent_* : {x : A} -> (* x x) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        1S : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        1P : (Prod A A)
        commutative_*P : {xP yP : (Prod A A)} -> (*P xP yP) == (*P yP xP)
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        lunit_1P : {xP : (Prod A A)} -> (*P 1P xP) == xP
        runit_1P : {xP : (Prod A A)} -> (*P xP 1P) == xP
        idempotent_*P : {xP : (Prod A A)} -> (*P xP xP) == xP
    record Hom {A1 : Set} {A2 : Set} (Bo1 : (BoundedMeetSemilattice A1)) (Bo2 : (BoundedMeetSemilattice A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Bo1) x1 x2)) == ((* Bo2) (hom x1) (hom x2))
        pres-1 : (hom (1 Bo1)) == (1 Bo2)
    record RelInterp {A1 : Set} {A2 : Set} (Bo1 : (BoundedMeetSemilattice A1)) (Bo2 : (BoundedMeetSemilattice A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Bo1) x1 x2) ((* Bo2) y1 y2))))
        interp-1 : (interp (1 Bo1) (1 Bo2))
    data BoundedMeetSemilatticeTerm  : Set where
      *L : (BoundedMeetSemilatticeTerm -> (BoundedMeetSemilatticeTerm -> BoundedMeetSemilatticeTerm))
      1L : BoundedMeetSemilatticeTerm
    data ClBoundedMeetSemilatticeTerm (A : Set) : Set where
      sing : (A -> (ClBoundedMeetSemilatticeTerm A))
      *Cl : ((ClBoundedMeetSemilatticeTerm A) -> ((ClBoundedMeetSemilatticeTerm A) -> (ClBoundedMeetSemilatticeTerm A)))
      1Cl : (ClBoundedMeetSemilatticeTerm A)
    data OpBoundedMeetSemilatticeTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpBoundedMeetSemilatticeTerm n))
      *OL : ((OpBoundedMeetSemilatticeTerm n) -> ((OpBoundedMeetSemilatticeTerm n) -> (OpBoundedMeetSemilatticeTerm n)))
      1OL : (OpBoundedMeetSemilatticeTerm n)
    data OpBoundedMeetSemilatticeTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpBoundedMeetSemilatticeTerm2 n A))
      sing2 : (A -> (OpBoundedMeetSemilatticeTerm2 n A))
      *OL2 : ((OpBoundedMeetSemilatticeTerm2 n A) -> ((OpBoundedMeetSemilatticeTerm2 n A) -> (OpBoundedMeetSemilatticeTerm2 n A)))
      1OL2 : (OpBoundedMeetSemilatticeTerm2 n A)
    simplifyCl : {A : Set} -> ((ClBoundedMeetSemilatticeTerm A) -> (ClBoundedMeetSemilatticeTerm A))
    simplifyCl (*Cl 1Cl x) = x 
    simplifyCl (*Cl x 1Cl) = x 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpBoundedMeetSemilatticeTerm n) -> (OpBoundedMeetSemilatticeTerm n))
    simplifyOpB (*OL 1OL x) = x 
    simplifyOpB (*OL x 1OL) = x 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpBoundedMeetSemilatticeTerm2 n A) -> (OpBoundedMeetSemilatticeTerm2 n A))
    simplifyOp (*OL2 1OL2 x) = x 
    simplifyOp (*OL2 x 1OL2) = x 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((BoundedMeetSemilattice A) -> (BoundedMeetSemilatticeTerm -> A))
    evalB Bo (*L x1 x2) = ((* Bo) (evalB Bo x1) (evalB Bo x2)) 
    evalB Bo 1L = (1 Bo) 
    evalCl : {A : Set} -> ((BoundedMeetSemilattice A) -> ((ClBoundedMeetSemilatticeTerm A) -> A))
    evalCl Bo (sing x1) = x1 
    evalCl Bo (*Cl x1 x2) = ((* Bo) (evalCl Bo x1) (evalCl Bo x2)) 
    evalCl Bo 1Cl = (1 Bo) 
    evalOpB : {A : Set} {n : Nat} -> ((BoundedMeetSemilattice A) -> ((Vec A n) -> ((OpBoundedMeetSemilatticeTerm n) -> A)))
    evalOpB Bo vars (v x1) = (lookup _ x1 vars) 
    evalOpB Bo vars (*OL x1 x2) = ((* Bo) (evalOpB Bo vars x1) (evalOpB Bo vars x2)) 
    evalOpB Bo vars 1OL = (1 Bo) 
    evalOp : {A : Set} {n : Nat} -> ((BoundedMeetSemilattice A) -> ((Vec A n) -> ((OpBoundedMeetSemilatticeTerm2 n A) -> A)))
    evalOp Bo vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Bo vars (sing2 x1) = x1 
    evalOp Bo vars (*OL2 x1 x2) = ((* Bo) (evalOp Bo vars x1) (evalOp Bo vars x2)) 
    evalOp Bo vars 1OL2 = (1 Bo) 
    inductionB : {P : (BoundedMeetSemilatticeTerm -> Set)} -> (((x1 x2 : BoundedMeetSemilatticeTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((P 1L) -> ((x : BoundedMeetSemilatticeTerm) -> (P x))))
    inductionB {p} p*l p1l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p1l x1) (inductionB {p} p*l p1l x2)) 
    inductionB {p} p*l p1l 1L = p1l 
    inductionCl : {A : Set} {P : ((ClBoundedMeetSemilatticeTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClBoundedMeetSemilatticeTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((P 1Cl) -> ((x : (ClBoundedMeetSemilatticeTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p*cl p1cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p1cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p1cl x1) (inductionCl {_} {p} psing p*cl p1cl x2)) 
    inductionCl {_} {p} psing p*cl p1cl 1Cl = p1cl 
    inductionOpB : {n : Nat} {P : ((OpBoundedMeetSemilatticeTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpBoundedMeetSemilatticeTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((P 1OL) -> ((x : (OpBoundedMeetSemilatticeTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p*ol p1ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p1ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p1ol x1) (inductionOpB {_} {p} pv p*ol p1ol x2)) 
    inductionOpB {_} {p} pv p*ol p1ol 1OL = p1ol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpBoundedMeetSemilatticeTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpBoundedMeetSemilatticeTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((P 1OL2) -> ((x : (OpBoundedMeetSemilatticeTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 1OL2 = p1ol2 
    *L' : (BoundedMeetSemilatticeTerm -> (BoundedMeetSemilatticeTerm -> BoundedMeetSemilatticeTerm))
    *L' x1 x2 = (*L x1 x2) 
    1L' : BoundedMeetSemilatticeTerm
    1L'  = 1L 
    stageB : (BoundedMeetSemilatticeTerm -> (Staged BoundedMeetSemilatticeTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB 1L = (Now 1L) 
    *Cl' : {A : Set} -> ((ClBoundedMeetSemilatticeTerm A) -> ((ClBoundedMeetSemilatticeTerm A) -> (ClBoundedMeetSemilatticeTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    1Cl' : {A : Set} -> (ClBoundedMeetSemilatticeTerm A)
    1Cl'  = 1Cl 
    stageCl : {A : Set} -> ((ClBoundedMeetSemilatticeTerm A) -> (Staged (ClBoundedMeetSemilatticeTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl 1Cl = (Now 1Cl) 
    *OL' : {n : Nat} -> ((OpBoundedMeetSemilatticeTerm n) -> ((OpBoundedMeetSemilatticeTerm n) -> (OpBoundedMeetSemilatticeTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    1OL' : {n : Nat} -> (OpBoundedMeetSemilatticeTerm n)
    1OL'  = 1OL 
    stageOpB : {n : Nat} -> ((OpBoundedMeetSemilatticeTerm n) -> (Staged (OpBoundedMeetSemilatticeTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 1OL = (Now 1OL) 
    *OL2' : {n : Nat} {A : Set} -> ((OpBoundedMeetSemilatticeTerm2 n A) -> ((OpBoundedMeetSemilatticeTerm2 n A) -> (OpBoundedMeetSemilatticeTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    1OL2' : {n : Nat} {A : Set} -> (OpBoundedMeetSemilatticeTerm2 n A)
    1OL2'  = 1OL2 
    stageOp : {n : Nat} {A : Set} -> ((OpBoundedMeetSemilatticeTerm2 n A) -> (Staged (OpBoundedMeetSemilatticeTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp 1OL2 = (Now 1OL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        1T : (Repr A)
  module BoundedModularLattice  where
    record BoundedModularLattice (A : Set) : Set where
      constructor BoundedModularLatticeC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        commutative_* : {x y : A} -> (* x y) == (* y x)
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        idempotent_* : {x : A} -> (* x x) == x
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        idempotent_+ : {x : A} -> (+ x x) == x
        leftAbsorp_*_+ : {x y : A} -> (* x (+ x y)) == x
        leftAbsorp_+_* : {x y : A} -> (+ x (* x y)) == x
        0 : A
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
        1 : A
        lunit_1 : {x : A} -> (* 1 x) == x
        runit_1 : {x : A} -> (* x 1) == x
        leftModular_*_+ : {x y z : A} -> (+ (* x y) (* x z)) == (* x (+ y (* x z)))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
        0S : AS
        1S : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        0P : (Prod A A)
        1P : (Prod A A)
        commutative_*P : {xP yP : (Prod A A)} -> (*P xP yP) == (*P yP xP)
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        idempotent_*P : {xP : (Prod A A)} -> (*P xP xP) == xP
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        idempotent_+P : {xP : (Prod A A)} -> (+P xP xP) == xP
        leftAbsorp_*_+P : {xP yP : (Prod A A)} -> (*P xP (+P xP yP)) == xP
        leftAbsorp_+_*P : {xP yP : (Prod A A)} -> (+P xP (*P xP yP)) == xP
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
        lunit_1P : {xP : (Prod A A)} -> (*P 1P xP) == xP
        runit_1P : {xP : (Prod A A)} -> (*P xP 1P) == xP
        leftModular_*_+P : {xP yP zP : (Prod A A)} -> (+P (*P xP yP) (*P xP zP)) == (*P xP (+P yP (*P xP zP)))
    record Hom {A1 : Set} {A2 : Set} (Bo1 : (BoundedModularLattice A1)) (Bo2 : (BoundedModularLattice A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Bo1) x1 x2)) == ((* Bo2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Bo1) x1 x2)) == ((+ Bo2) (hom x1) (hom x2))
        pres-0 : (hom (0 Bo1)) == (0 Bo2)
        pres-1 : (hom (1 Bo1)) == (1 Bo2)
    record RelInterp {A1 : Set} {A2 : Set} (Bo1 : (BoundedModularLattice A1)) (Bo2 : (BoundedModularLattice A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Bo1) x1 x2) ((* Bo2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Bo1) x1 x2) ((+ Bo2) y1 y2))))
        interp-0 : (interp (0 Bo1) (0 Bo2))
        interp-1 : (interp (1 Bo1) (1 Bo2))
    data BoundedModularLatticeTerm  : Set where
      *L : (BoundedModularLatticeTerm -> (BoundedModularLatticeTerm -> BoundedModularLatticeTerm))
      +L : (BoundedModularLatticeTerm -> (BoundedModularLatticeTerm -> BoundedModularLatticeTerm))
      0L : BoundedModularLatticeTerm
      1L : BoundedModularLatticeTerm
    data ClBoundedModularLatticeTerm (A : Set) : Set where
      sing : (A -> (ClBoundedModularLatticeTerm A))
      *Cl : ((ClBoundedModularLatticeTerm A) -> ((ClBoundedModularLatticeTerm A) -> (ClBoundedModularLatticeTerm A)))
      +Cl : ((ClBoundedModularLatticeTerm A) -> ((ClBoundedModularLatticeTerm A) -> (ClBoundedModularLatticeTerm A)))
      0Cl : (ClBoundedModularLatticeTerm A)
      1Cl : (ClBoundedModularLatticeTerm A)
    data OpBoundedModularLatticeTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpBoundedModularLatticeTerm n))
      *OL : ((OpBoundedModularLatticeTerm n) -> ((OpBoundedModularLatticeTerm n) -> (OpBoundedModularLatticeTerm n)))
      +OL : ((OpBoundedModularLatticeTerm n) -> ((OpBoundedModularLatticeTerm n) -> (OpBoundedModularLatticeTerm n)))
      0OL : (OpBoundedModularLatticeTerm n)
      1OL : (OpBoundedModularLatticeTerm n)
    data OpBoundedModularLatticeTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpBoundedModularLatticeTerm2 n A))
      sing2 : (A -> (OpBoundedModularLatticeTerm2 n A))
      *OL2 : ((OpBoundedModularLatticeTerm2 n A) -> ((OpBoundedModularLatticeTerm2 n A) -> (OpBoundedModularLatticeTerm2 n A)))
      +OL2 : ((OpBoundedModularLatticeTerm2 n A) -> ((OpBoundedModularLatticeTerm2 n A) -> (OpBoundedModularLatticeTerm2 n A)))
      0OL2 : (OpBoundedModularLatticeTerm2 n A)
      1OL2 : (OpBoundedModularLatticeTerm2 n A)
    simplifyCl : {A : Set} -> ((ClBoundedModularLatticeTerm A) -> (ClBoundedModularLatticeTerm A))
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl (*Cl 1Cl x) = x 
    simplifyCl (*Cl x 1Cl) = x 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 0Cl = 0Cl 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpBoundedModularLatticeTerm n) -> (OpBoundedModularLatticeTerm n))
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB (*OL 1OL x) = x 
    simplifyOpB (*OL x 1OL) = x 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 0OL = 0OL 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpBoundedModularLatticeTerm2 n A) -> (OpBoundedModularLatticeTerm2 n A))
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp (*OL2 1OL2 x) = x 
    simplifyOp (*OL2 x 1OL2) = x 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((BoundedModularLattice A) -> (BoundedModularLatticeTerm -> A))
    evalB Bo (*L x1 x2) = ((* Bo) (evalB Bo x1) (evalB Bo x2)) 
    evalB Bo (+L x1 x2) = ((+ Bo) (evalB Bo x1) (evalB Bo x2)) 
    evalB Bo 0L = (0 Bo) 
    evalB Bo 1L = (1 Bo) 
    evalCl : {A : Set} -> ((BoundedModularLattice A) -> ((ClBoundedModularLatticeTerm A) -> A))
    evalCl Bo (sing x1) = x1 
    evalCl Bo (*Cl x1 x2) = ((* Bo) (evalCl Bo x1) (evalCl Bo x2)) 
    evalCl Bo (+Cl x1 x2) = ((+ Bo) (evalCl Bo x1) (evalCl Bo x2)) 
    evalCl Bo 0Cl = (0 Bo) 
    evalCl Bo 1Cl = (1 Bo) 
    evalOpB : {A : Set} {n : Nat} -> ((BoundedModularLattice A) -> ((Vec A n) -> ((OpBoundedModularLatticeTerm n) -> A)))
    evalOpB Bo vars (v x1) = (lookup _ x1 vars) 
    evalOpB Bo vars (*OL x1 x2) = ((* Bo) (evalOpB Bo vars x1) (evalOpB Bo vars x2)) 
    evalOpB Bo vars (+OL x1 x2) = ((+ Bo) (evalOpB Bo vars x1) (evalOpB Bo vars x2)) 
    evalOpB Bo vars 0OL = (0 Bo) 
    evalOpB Bo vars 1OL = (1 Bo) 
    evalOp : {A : Set} {n : Nat} -> ((BoundedModularLattice A) -> ((Vec A n) -> ((OpBoundedModularLatticeTerm2 n A) -> A)))
    evalOp Bo vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Bo vars (sing2 x1) = x1 
    evalOp Bo vars (*OL2 x1 x2) = ((* Bo) (evalOp Bo vars x1) (evalOp Bo vars x2)) 
    evalOp Bo vars (+OL2 x1 x2) = ((+ Bo) (evalOp Bo vars x1) (evalOp Bo vars x2)) 
    evalOp Bo vars 0OL2 = (0 Bo) 
    evalOp Bo vars 1OL2 = (1 Bo) 
    inductionB : {P : (BoundedModularLatticeTerm -> Set)} -> (((x1 x2 : BoundedModularLatticeTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : BoundedModularLatticeTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((P 0L) -> ((P 1L) -> ((x : BoundedModularLatticeTerm) -> (P x))))))
    inductionB {p} p*l p+l p0l p1l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l p0l p1l x1) (inductionB {p} p*l p+l p0l p1l x2)) 
    inductionB {p} p*l p+l p0l p1l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l p0l p1l x1) (inductionB {p} p*l p+l p0l p1l x2)) 
    inductionB {p} p*l p+l p0l p1l 0L = p0l 
    inductionB {p} p*l p+l p0l p1l 1L = p1l 
    inductionCl : {A : Set} {P : ((ClBoundedModularLatticeTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClBoundedModularLatticeTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClBoundedModularLatticeTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((P 0Cl) -> ((P 1Cl) -> ((x : (ClBoundedModularLatticeTerm A)) -> (P x)))))))
    inductionCl {_} {p} psing p*cl p+cl p0cl p1cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl p0cl p1cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl p0cl p1cl x1) (inductionCl {_} {p} psing p*cl p+cl p0cl p1cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl p0cl p1cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl p0cl p1cl x1) (inductionCl {_} {p} psing p*cl p+cl p0cl p1cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl p0cl p1cl 0Cl = p0cl 
    inductionCl {_} {p} psing p*cl p+cl p0cl p1cl 1Cl = p1cl 
    inductionOpB : {n : Nat} {P : ((OpBoundedModularLatticeTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpBoundedModularLatticeTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpBoundedModularLatticeTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((P 0OL) -> ((P 1OL) -> ((x : (OpBoundedModularLatticeTerm n)) -> (P x)))))))
    inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol x1) (inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol x1) (inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol 0OL = p0ol 
    inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol 1OL = p1ol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpBoundedModularLatticeTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpBoundedModularLatticeTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpBoundedModularLatticeTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((P 0OL2) -> ((P 1OL2) -> ((x : (OpBoundedModularLatticeTerm2 n A)) -> (P x))))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 1OL2 = p1ol2 
    *L' : (BoundedModularLatticeTerm -> (BoundedModularLatticeTerm -> BoundedModularLatticeTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (BoundedModularLatticeTerm -> (BoundedModularLatticeTerm -> BoundedModularLatticeTerm))
    +L' x1 x2 = (+L x1 x2) 
    0L' : BoundedModularLatticeTerm
    0L'  = 0L 
    1L' : BoundedModularLatticeTerm
    1L'  = 1L 
    stageB : (BoundedModularLatticeTerm -> (Staged BoundedModularLatticeTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB 0L = (Now 0L) 
    stageB 1L = (Now 1L) 
    *Cl' : {A : Set} -> ((ClBoundedModularLatticeTerm A) -> ((ClBoundedModularLatticeTerm A) -> (ClBoundedModularLatticeTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClBoundedModularLatticeTerm A) -> ((ClBoundedModularLatticeTerm A) -> (ClBoundedModularLatticeTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    0Cl' : {A : Set} -> (ClBoundedModularLatticeTerm A)
    0Cl'  = 0Cl 
    1Cl' : {A : Set} -> (ClBoundedModularLatticeTerm A)
    1Cl'  = 1Cl 
    stageCl : {A : Set} -> ((ClBoundedModularLatticeTerm A) -> (Staged (ClBoundedModularLatticeTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl 1Cl = (Now 1Cl) 
    *OL' : {n : Nat} -> ((OpBoundedModularLatticeTerm n) -> ((OpBoundedModularLatticeTerm n) -> (OpBoundedModularLatticeTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpBoundedModularLatticeTerm n) -> ((OpBoundedModularLatticeTerm n) -> (OpBoundedModularLatticeTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    0OL' : {n : Nat} -> (OpBoundedModularLatticeTerm n)
    0OL'  = 0OL 
    1OL' : {n : Nat} -> (OpBoundedModularLatticeTerm n)
    1OL'  = 1OL 
    stageOpB : {n : Nat} -> ((OpBoundedModularLatticeTerm n) -> (Staged (OpBoundedModularLatticeTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB 1OL = (Now 1OL) 
    *OL2' : {n : Nat} {A : Set} -> ((OpBoundedModularLatticeTerm2 n A) -> ((OpBoundedModularLatticeTerm2 n A) -> (OpBoundedModularLatticeTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpBoundedModularLatticeTerm2 n A) -> ((OpBoundedModularLatticeTerm2 n A) -> (OpBoundedModularLatticeTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    0OL2' : {n : Nat} {A : Set} -> (OpBoundedModularLatticeTerm2 n A)
    0OL2'  = 0OL2 
    1OL2' : {n : Nat} {A : Set} -> (OpBoundedModularLatticeTerm2 n A)
    1OL2'  = 1OL2 
    stageOp : {n : Nat} {A : Set} -> ((OpBoundedModularLatticeTerm2 n A) -> (Staged (OpBoundedModularLatticeTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp 1OL2 = (Now 1OL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        0T : (Repr A)
        1T : (Repr A)
  module CancellativeCommutativeMonoid  where
    record CancellativeCommutativeMonoid (A : Set) : Set where
      constructor CancellativeCommutativeMonoidC
      field
        op : (A -> (A -> A))
        e : A
        lunit_e : {x : A} -> (op e x) == x
        runit_e : {x : A} -> (op x e) == x
        associative_op : {x y z : A} -> (op (op x y) z) == (op x (op y z))
        leftCancellative : {x y z : A} -> ((op z x) == (op z y) -> x == y)
        rightCancellative : {x y z : A} -> ((op x z) == (op y z) -> x == y)
        commutative_op : {x y : A} -> (op x y) == (op y x)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        eS : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        eP : (Prod A A)
        lunit_eP : {xP : (Prod A A)} -> (opP eP xP) == xP
        runit_eP : {xP : (Prod A A)} -> (opP xP eP) == xP
        associative_opP : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP (opP yP zP))
        leftCancellativeP : {xP yP zP : (Prod A A)} -> ((opP zP xP) == (opP zP yP) -> xP == yP)
        rightCancellativeP : {xP yP zP : (Prod A A)} -> ((opP xP zP) == (opP yP zP) -> xP == yP)
        commutative_opP : {xP yP : (Prod A A)} -> (opP xP yP) == (opP yP xP)
    record Hom {A1 : Set} {A2 : Set} (Ca1 : (CancellativeCommutativeMonoid A1)) (Ca2 : (CancellativeCommutativeMonoid A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Ca1) x1 x2)) == ((op Ca2) (hom x1) (hom x2))
        pres-e : (hom (e Ca1)) == (e Ca2)
    record RelInterp {A1 : Set} {A2 : Set} (Ca1 : (CancellativeCommutativeMonoid A1)) (Ca2 : (CancellativeCommutativeMonoid A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Ca1) x1 x2) ((op Ca2) y1 y2))))
        interp-e : (interp (e Ca1) (e Ca2))
    data CancellativeCommutativeMonoidTerm  : Set where
      opL : (CancellativeCommutativeMonoidTerm -> (CancellativeCommutativeMonoidTerm -> CancellativeCommutativeMonoidTerm))
      eL : CancellativeCommutativeMonoidTerm
    data ClCancellativeCommutativeMonoidTerm (A : Set) : Set where
      sing : (A -> (ClCancellativeCommutativeMonoidTerm A))
      opCl : ((ClCancellativeCommutativeMonoidTerm A) -> ((ClCancellativeCommutativeMonoidTerm A) -> (ClCancellativeCommutativeMonoidTerm A)))
      eCl : (ClCancellativeCommutativeMonoidTerm A)
    data OpCancellativeCommutativeMonoidTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpCancellativeCommutativeMonoidTerm n))
      opOL : ((OpCancellativeCommutativeMonoidTerm n) -> ((OpCancellativeCommutativeMonoidTerm n) -> (OpCancellativeCommutativeMonoidTerm n)))
      eOL : (OpCancellativeCommutativeMonoidTerm n)
    data OpCancellativeCommutativeMonoidTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpCancellativeCommutativeMonoidTerm2 n A))
      sing2 : (A -> (OpCancellativeCommutativeMonoidTerm2 n A))
      opOL2 : ((OpCancellativeCommutativeMonoidTerm2 n A) -> ((OpCancellativeCommutativeMonoidTerm2 n A) -> (OpCancellativeCommutativeMonoidTerm2 n A)))
      eOL2 : (OpCancellativeCommutativeMonoidTerm2 n A)
    simplifyCl : {A : Set} -> ((ClCancellativeCommutativeMonoidTerm A) -> (ClCancellativeCommutativeMonoidTerm A))
    simplifyCl (opCl eCl x) = x 
    simplifyCl (opCl x eCl) = x 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl eCl = eCl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpCancellativeCommutativeMonoidTerm n) -> (OpCancellativeCommutativeMonoidTerm n))
    simplifyOpB (opOL eOL x) = x 
    simplifyOpB (opOL x eOL) = x 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB eOL = eOL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpCancellativeCommutativeMonoidTerm2 n A) -> (OpCancellativeCommutativeMonoidTerm2 n A))
    simplifyOp (opOL2 eOL2 x) = x 
    simplifyOp (opOL2 x eOL2) = x 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp eOL2 = eOL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((CancellativeCommutativeMonoid A) -> (CancellativeCommutativeMonoidTerm -> A))
    evalB Ca (opL x1 x2) = ((op Ca) (evalB Ca x1) (evalB Ca x2)) 
    evalB Ca eL = (e Ca) 
    evalCl : {A : Set} -> ((CancellativeCommutativeMonoid A) -> ((ClCancellativeCommutativeMonoidTerm A) -> A))
    evalCl Ca (sing x1) = x1 
    evalCl Ca (opCl x1 x2) = ((op Ca) (evalCl Ca x1) (evalCl Ca x2)) 
    evalCl Ca eCl = (e Ca) 
    evalOpB : {A : Set} {n : Nat} -> ((CancellativeCommutativeMonoid A) -> ((Vec A n) -> ((OpCancellativeCommutativeMonoidTerm n) -> A)))
    evalOpB Ca vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ca vars (opOL x1 x2) = ((op Ca) (evalOpB Ca vars x1) (evalOpB Ca vars x2)) 
    evalOpB Ca vars eOL = (e Ca) 
    evalOp : {A : Set} {n : Nat} -> ((CancellativeCommutativeMonoid A) -> ((Vec A n) -> ((OpCancellativeCommutativeMonoidTerm2 n A) -> A)))
    evalOp Ca vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ca vars (sing2 x1) = x1 
    evalOp Ca vars (opOL2 x1 x2) = ((op Ca) (evalOp Ca vars x1) (evalOp Ca vars x2)) 
    evalOp Ca vars eOL2 = (e Ca) 
    inductionB : {P : (CancellativeCommutativeMonoidTerm -> Set)} -> (((x1 x2 : CancellativeCommutativeMonoidTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((P eL) -> ((x : CancellativeCommutativeMonoidTerm) -> (P x))))
    inductionB {p} popl pel (opL x1 x2) = (popl _ _ (inductionB {p} popl pel x1) (inductionB {p} popl pel x2)) 
    inductionB {p} popl pel eL = pel 
    inductionCl : {A : Set} {P : ((ClCancellativeCommutativeMonoidTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClCancellativeCommutativeMonoidTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((P eCl) -> ((x : (ClCancellativeCommutativeMonoidTerm A)) -> (P x)))))
    inductionCl {_} {p} psing popcl pecl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl pecl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl pecl x1) (inductionCl {_} {p} psing popcl pecl x2)) 
    inductionCl {_} {p} psing popcl pecl eCl = pecl 
    inductionOpB : {n : Nat} {P : ((OpCancellativeCommutativeMonoidTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpCancellativeCommutativeMonoidTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((P eOL) -> ((x : (OpCancellativeCommutativeMonoidTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv popol peol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol peol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol peol x1) (inductionOpB {_} {p} pv popol peol x2)) 
    inductionOpB {_} {p} pv popol peol eOL = peol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpCancellativeCommutativeMonoidTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpCancellativeCommutativeMonoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((P eOL2) -> ((x : (OpCancellativeCommutativeMonoidTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 eOL2 = peol2 
    opL' : (CancellativeCommutativeMonoidTerm -> (CancellativeCommutativeMonoidTerm -> CancellativeCommutativeMonoidTerm))
    opL' x1 x2 = (opL x1 x2) 
    eL' : CancellativeCommutativeMonoidTerm
    eL'  = eL 
    stageB : (CancellativeCommutativeMonoidTerm -> (Staged CancellativeCommutativeMonoidTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB eL = (Now eL) 
    opCl' : {A : Set} -> ((ClCancellativeCommutativeMonoidTerm A) -> ((ClCancellativeCommutativeMonoidTerm A) -> (ClCancellativeCommutativeMonoidTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    eCl' : {A : Set} -> (ClCancellativeCommutativeMonoidTerm A)
    eCl'  = eCl 
    stageCl : {A : Set} -> ((ClCancellativeCommutativeMonoidTerm A) -> (Staged (ClCancellativeCommutativeMonoidTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl eCl = (Now eCl) 
    opOL' : {n : Nat} -> ((OpCancellativeCommutativeMonoidTerm n) -> ((OpCancellativeCommutativeMonoidTerm n) -> (OpCancellativeCommutativeMonoidTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    eOL' : {n : Nat} -> (OpCancellativeCommutativeMonoidTerm n)
    eOL'  = eOL 
    stageOpB : {n : Nat} -> ((OpCancellativeCommutativeMonoidTerm n) -> (Staged (OpCancellativeCommutativeMonoidTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB eOL = (Now eOL) 
    opOL2' : {n : Nat} {A : Set} -> ((OpCancellativeCommutativeMonoidTerm2 n A) -> ((OpCancellativeCommutativeMonoidTerm2 n A) -> (OpCancellativeCommutativeMonoidTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    eOL2' : {n : Nat} {A : Set} -> (OpCancellativeCommutativeMonoidTerm2 n A)
    eOL2'  = eOL2 
    stageOp : {n : Nat} {A : Set} -> ((OpCancellativeCommutativeMonoidTerm2 n A) -> (Staged (OpCancellativeCommutativeMonoidTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp eOL2 = (Now eOL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        eT : (Repr A)
  module CancellativeCommutativeSemigroup  where
    record CancellativeCommutativeSemigroup (A : Set) : Set where
      constructor CancellativeCommutativeSemigroupC
      field
        op : (A -> (A -> A))
        associative_op : {x y z : A} -> (op (op x y) z) == (op x (op y z))
        commutative_op : {x y : A} -> (op x y) == (op y x)
        leftCancellative : {x y z : A} -> ((op z x) == (op z y) -> x == y)
        rightCancellative : {x y z : A} -> ((op x z) == (op y z) -> x == y)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        associative_opP : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP (opP yP zP))
        commutative_opP : {xP yP : (Prod A A)} -> (opP xP yP) == (opP yP xP)
        leftCancellativeP : {xP yP zP : (Prod A A)} -> ((opP zP xP) == (opP zP yP) -> xP == yP)
        rightCancellativeP : {xP yP zP : (Prod A A)} -> ((opP xP zP) == (opP yP zP) -> xP == yP)
    record Hom {A1 : Set} {A2 : Set} (Ca1 : (CancellativeCommutativeSemigroup A1)) (Ca2 : (CancellativeCommutativeSemigroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Ca1) x1 x2)) == ((op Ca2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ca1 : (CancellativeCommutativeSemigroup A1)) (Ca2 : (CancellativeCommutativeSemigroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Ca1) x1 x2) ((op Ca2) y1 y2))))
    data CancellativeCommutativeSemigroupTerm  : Set where
      opL : (CancellativeCommutativeSemigroupTerm -> (CancellativeCommutativeSemigroupTerm -> CancellativeCommutativeSemigroupTerm))
    data ClCancellativeCommutativeSemigroupTerm (A : Set) : Set where
      sing : (A -> (ClCancellativeCommutativeSemigroupTerm A))
      opCl : ((ClCancellativeCommutativeSemigroupTerm A) -> ((ClCancellativeCommutativeSemigroupTerm A) -> (ClCancellativeCommutativeSemigroupTerm A)))
    data OpCancellativeCommutativeSemigroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpCancellativeCommutativeSemigroupTerm n))
      opOL : ((OpCancellativeCommutativeSemigroupTerm n) -> ((OpCancellativeCommutativeSemigroupTerm n) -> (OpCancellativeCommutativeSemigroupTerm n)))
    data OpCancellativeCommutativeSemigroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpCancellativeCommutativeSemigroupTerm2 n A))
      sing2 : (A -> (OpCancellativeCommutativeSemigroupTerm2 n A))
      opOL2 : ((OpCancellativeCommutativeSemigroupTerm2 n A) -> ((OpCancellativeCommutativeSemigroupTerm2 n A) -> (OpCancellativeCommutativeSemigroupTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClCancellativeCommutativeSemigroupTerm A) -> (ClCancellativeCommutativeSemigroupTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpCancellativeCommutativeSemigroupTerm n) -> (OpCancellativeCommutativeSemigroupTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpCancellativeCommutativeSemigroupTerm2 n A) -> (OpCancellativeCommutativeSemigroupTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((CancellativeCommutativeSemigroup A) -> (CancellativeCommutativeSemigroupTerm -> A))
    evalB Ca (opL x1 x2) = ((op Ca) (evalB Ca x1) (evalB Ca x2)) 
    evalCl : {A : Set} -> ((CancellativeCommutativeSemigroup A) -> ((ClCancellativeCommutativeSemigroupTerm A) -> A))
    evalCl Ca (sing x1) = x1 
    evalCl Ca (opCl x1 x2) = ((op Ca) (evalCl Ca x1) (evalCl Ca x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((CancellativeCommutativeSemigroup A) -> ((Vec A n) -> ((OpCancellativeCommutativeSemigroupTerm n) -> A)))
    evalOpB Ca vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ca vars (opOL x1 x2) = ((op Ca) (evalOpB Ca vars x1) (evalOpB Ca vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((CancellativeCommutativeSemigroup A) -> ((Vec A n) -> ((OpCancellativeCommutativeSemigroupTerm2 n A) -> A)))
    evalOp Ca vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ca vars (sing2 x1) = x1 
    evalOp Ca vars (opOL2 x1 x2) = ((op Ca) (evalOp Ca vars x1) (evalOp Ca vars x2)) 
    inductionB : {P : (CancellativeCommutativeSemigroupTerm -> Set)} -> (((x1 x2 : CancellativeCommutativeSemigroupTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : CancellativeCommutativeSemigroupTerm) -> (P x)))
    inductionB {p} popl (opL x1 x2) = (popl _ _ (inductionB {p} popl x1) (inductionB {p} popl x2)) 
    inductionCl : {A : Set} {P : ((ClCancellativeCommutativeSemigroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClCancellativeCommutativeSemigroupTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClCancellativeCommutativeSemigroupTerm A)) -> (P x))))
    inductionCl {_} {p} psing popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl x1) (inductionCl {_} {p} psing popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpCancellativeCommutativeSemigroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpCancellativeCommutativeSemigroupTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpCancellativeCommutativeSemigroupTerm n)) -> (P x))))
    inductionOpB {_} {p} pv popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol x1) (inductionOpB {_} {p} pv popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpCancellativeCommutativeSemigroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpCancellativeCommutativeSemigroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpCancellativeCommutativeSemigroupTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 x2)) 
    opL' : (CancellativeCommutativeSemigroupTerm -> (CancellativeCommutativeSemigroupTerm -> CancellativeCommutativeSemigroupTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (CancellativeCommutativeSemigroupTerm -> (Staged CancellativeCommutativeSemigroupTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClCancellativeCommutativeSemigroupTerm A) -> ((ClCancellativeCommutativeSemigroupTerm A) -> (ClCancellativeCommutativeSemigroupTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClCancellativeCommutativeSemigroupTerm A) -> (Staged (ClCancellativeCommutativeSemigroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpCancellativeCommutativeSemigroupTerm n) -> ((OpCancellativeCommutativeSemigroupTerm n) -> (OpCancellativeCommutativeSemigroupTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpCancellativeCommutativeSemigroupTerm n) -> (Staged (OpCancellativeCommutativeSemigroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpCancellativeCommutativeSemigroupTerm2 n A) -> ((OpCancellativeCommutativeSemigroupTerm2 n A) -> (OpCancellativeCommutativeSemigroupTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpCancellativeCommutativeSemigroupTerm2 n A) -> (Staged (OpCancellativeCommutativeSemigroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module CancellativeMagma  where
    record CancellativeMagma (A : Set) : Set where
      constructor CancellativeMagmaC
      field
        op : (A -> (A -> A))
        leftCancellative : {x y z : A} -> ((op z x) == (op z y) -> x == y)
        rightCancellative : {x y z : A} -> ((op x z) == (op y z) -> x == y)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftCancellativeP : {xP yP zP : (Prod A A)} -> ((opP zP xP) == (opP zP yP) -> xP == yP)
        rightCancellativeP : {xP yP zP : (Prod A A)} -> ((opP xP zP) == (opP yP zP) -> xP == yP)
    record Hom {A1 : Set} {A2 : Set} (Ca1 : (CancellativeMagma A1)) (Ca2 : (CancellativeMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Ca1) x1 x2)) == ((op Ca2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ca1 : (CancellativeMagma A1)) (Ca2 : (CancellativeMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Ca1) x1 x2) ((op Ca2) y1 y2))))
    data CancellativeMagmaTerm  : Set where
      opL : (CancellativeMagmaTerm -> (CancellativeMagmaTerm -> CancellativeMagmaTerm))
    data ClCancellativeMagmaTerm (A : Set) : Set where
      sing : (A -> (ClCancellativeMagmaTerm A))
      opCl : ((ClCancellativeMagmaTerm A) -> ((ClCancellativeMagmaTerm A) -> (ClCancellativeMagmaTerm A)))
    data OpCancellativeMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpCancellativeMagmaTerm n))
      opOL : ((OpCancellativeMagmaTerm n) -> ((OpCancellativeMagmaTerm n) -> (OpCancellativeMagmaTerm n)))
    data OpCancellativeMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpCancellativeMagmaTerm2 n A))
      sing2 : (A -> (OpCancellativeMagmaTerm2 n A))
      opOL2 : ((OpCancellativeMagmaTerm2 n A) -> ((OpCancellativeMagmaTerm2 n A) -> (OpCancellativeMagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClCancellativeMagmaTerm A) -> (ClCancellativeMagmaTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpCancellativeMagmaTerm n) -> (OpCancellativeMagmaTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpCancellativeMagmaTerm2 n A) -> (OpCancellativeMagmaTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((CancellativeMagma A) -> (CancellativeMagmaTerm -> A))
    evalB Ca (opL x1 x2) = ((op Ca) (evalB Ca x1) (evalB Ca x2)) 
    evalCl : {A : Set} -> ((CancellativeMagma A) -> ((ClCancellativeMagmaTerm A) -> A))
    evalCl Ca (sing x1) = x1 
    evalCl Ca (opCl x1 x2) = ((op Ca) (evalCl Ca x1) (evalCl Ca x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((CancellativeMagma A) -> ((Vec A n) -> ((OpCancellativeMagmaTerm n) -> A)))
    evalOpB Ca vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ca vars (opOL x1 x2) = ((op Ca) (evalOpB Ca vars x1) (evalOpB Ca vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((CancellativeMagma A) -> ((Vec A n) -> ((OpCancellativeMagmaTerm2 n A) -> A)))
    evalOp Ca vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ca vars (sing2 x1) = x1 
    evalOp Ca vars (opOL2 x1 x2) = ((op Ca) (evalOp Ca vars x1) (evalOp Ca vars x2)) 
    inductionB : {P : (CancellativeMagmaTerm -> Set)} -> (((x1 x2 : CancellativeMagmaTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : CancellativeMagmaTerm) -> (P x)))
    inductionB {p} popl (opL x1 x2) = (popl _ _ (inductionB {p} popl x1) (inductionB {p} popl x2)) 
    inductionCl : {A : Set} {P : ((ClCancellativeMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClCancellativeMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClCancellativeMagmaTerm A)) -> (P x))))
    inductionCl {_} {p} psing popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl x1) (inductionCl {_} {p} psing popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpCancellativeMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpCancellativeMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpCancellativeMagmaTerm n)) -> (P x))))
    inductionOpB {_} {p} pv popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol x1) (inductionOpB {_} {p} pv popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpCancellativeMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpCancellativeMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpCancellativeMagmaTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 x2)) 
    opL' : (CancellativeMagmaTerm -> (CancellativeMagmaTerm -> CancellativeMagmaTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (CancellativeMagmaTerm -> (Staged CancellativeMagmaTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClCancellativeMagmaTerm A) -> ((ClCancellativeMagmaTerm A) -> (ClCancellativeMagmaTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClCancellativeMagmaTerm A) -> (Staged (ClCancellativeMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpCancellativeMagmaTerm n) -> ((OpCancellativeMagmaTerm n) -> (OpCancellativeMagmaTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpCancellativeMagmaTerm n) -> (Staged (OpCancellativeMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpCancellativeMagmaTerm2 n A) -> ((OpCancellativeMagmaTerm2 n A) -> (OpCancellativeMagmaTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpCancellativeMagmaTerm2 n A) -> (Staged (OpCancellativeMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module CancellativeMonoid  where
    record CancellativeMonoid (A : Set) : Set where
      constructor CancellativeMonoidC
      field
        op : (A -> (A -> A))
        e : A
        lunit_e : {x : A} -> (op e x) == x
        runit_e : {x : A} -> (op x e) == x
        associative_op : {x y z : A} -> (op (op x y) z) == (op x (op y z))
        leftCancellative : {x y z : A} -> ((op z x) == (op z y) -> x == y)
        rightCancellative : {x y z : A} -> ((op x z) == (op y z) -> x == y)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        eS : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        eP : (Prod A A)
        lunit_eP : {xP : (Prod A A)} -> (opP eP xP) == xP
        runit_eP : {xP : (Prod A A)} -> (opP xP eP) == xP
        associative_opP : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP (opP yP zP))
        leftCancellativeP : {xP yP zP : (Prod A A)} -> ((opP zP xP) == (opP zP yP) -> xP == yP)
        rightCancellativeP : {xP yP zP : (Prod A A)} -> ((opP xP zP) == (opP yP zP) -> xP == yP)
    record Hom {A1 : Set} {A2 : Set} (Ca1 : (CancellativeMonoid A1)) (Ca2 : (CancellativeMonoid A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Ca1) x1 x2)) == ((op Ca2) (hom x1) (hom x2))
        pres-e : (hom (e Ca1)) == (e Ca2)
    record RelInterp {A1 : Set} {A2 : Set} (Ca1 : (CancellativeMonoid A1)) (Ca2 : (CancellativeMonoid A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Ca1) x1 x2) ((op Ca2) y1 y2))))
        interp-e : (interp (e Ca1) (e Ca2))
    data CancellativeMonoidTerm  : Set where
      opL : (CancellativeMonoidTerm -> (CancellativeMonoidTerm -> CancellativeMonoidTerm))
      eL : CancellativeMonoidTerm
    data ClCancellativeMonoidTerm (A : Set) : Set where
      sing : (A -> (ClCancellativeMonoidTerm A))
      opCl : ((ClCancellativeMonoidTerm A) -> ((ClCancellativeMonoidTerm A) -> (ClCancellativeMonoidTerm A)))
      eCl : (ClCancellativeMonoidTerm A)
    data OpCancellativeMonoidTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpCancellativeMonoidTerm n))
      opOL : ((OpCancellativeMonoidTerm n) -> ((OpCancellativeMonoidTerm n) -> (OpCancellativeMonoidTerm n)))
      eOL : (OpCancellativeMonoidTerm n)
    data OpCancellativeMonoidTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpCancellativeMonoidTerm2 n A))
      sing2 : (A -> (OpCancellativeMonoidTerm2 n A))
      opOL2 : ((OpCancellativeMonoidTerm2 n A) -> ((OpCancellativeMonoidTerm2 n A) -> (OpCancellativeMonoidTerm2 n A)))
      eOL2 : (OpCancellativeMonoidTerm2 n A)
    simplifyCl : {A : Set} -> ((ClCancellativeMonoidTerm A) -> (ClCancellativeMonoidTerm A))
    simplifyCl (opCl eCl x) = x 
    simplifyCl (opCl x eCl) = x 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl eCl = eCl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpCancellativeMonoidTerm n) -> (OpCancellativeMonoidTerm n))
    simplifyOpB (opOL eOL x) = x 
    simplifyOpB (opOL x eOL) = x 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB eOL = eOL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpCancellativeMonoidTerm2 n A) -> (OpCancellativeMonoidTerm2 n A))
    simplifyOp (opOL2 eOL2 x) = x 
    simplifyOp (opOL2 x eOL2) = x 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp eOL2 = eOL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((CancellativeMonoid A) -> (CancellativeMonoidTerm -> A))
    evalB Ca (opL x1 x2) = ((op Ca) (evalB Ca x1) (evalB Ca x2)) 
    evalB Ca eL = (e Ca) 
    evalCl : {A : Set} -> ((CancellativeMonoid A) -> ((ClCancellativeMonoidTerm A) -> A))
    evalCl Ca (sing x1) = x1 
    evalCl Ca (opCl x1 x2) = ((op Ca) (evalCl Ca x1) (evalCl Ca x2)) 
    evalCl Ca eCl = (e Ca) 
    evalOpB : {A : Set} {n : Nat} -> ((CancellativeMonoid A) -> ((Vec A n) -> ((OpCancellativeMonoidTerm n) -> A)))
    evalOpB Ca vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ca vars (opOL x1 x2) = ((op Ca) (evalOpB Ca vars x1) (evalOpB Ca vars x2)) 
    evalOpB Ca vars eOL = (e Ca) 
    evalOp : {A : Set} {n : Nat} -> ((CancellativeMonoid A) -> ((Vec A n) -> ((OpCancellativeMonoidTerm2 n A) -> A)))
    evalOp Ca vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ca vars (sing2 x1) = x1 
    evalOp Ca vars (opOL2 x1 x2) = ((op Ca) (evalOp Ca vars x1) (evalOp Ca vars x2)) 
    evalOp Ca vars eOL2 = (e Ca) 
    inductionB : {P : (CancellativeMonoidTerm -> Set)} -> (((x1 x2 : CancellativeMonoidTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((P eL) -> ((x : CancellativeMonoidTerm) -> (P x))))
    inductionB {p} popl pel (opL x1 x2) = (popl _ _ (inductionB {p} popl pel x1) (inductionB {p} popl pel x2)) 
    inductionB {p} popl pel eL = pel 
    inductionCl : {A : Set} {P : ((ClCancellativeMonoidTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClCancellativeMonoidTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((P eCl) -> ((x : (ClCancellativeMonoidTerm A)) -> (P x)))))
    inductionCl {_} {p} psing popcl pecl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl pecl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl pecl x1) (inductionCl {_} {p} psing popcl pecl x2)) 
    inductionCl {_} {p} psing popcl pecl eCl = pecl 
    inductionOpB : {n : Nat} {P : ((OpCancellativeMonoidTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpCancellativeMonoidTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((P eOL) -> ((x : (OpCancellativeMonoidTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv popol peol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol peol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol peol x1) (inductionOpB {_} {p} pv popol peol x2)) 
    inductionOpB {_} {p} pv popol peol eOL = peol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpCancellativeMonoidTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpCancellativeMonoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((P eOL2) -> ((x : (OpCancellativeMonoidTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 eOL2 = peol2 
    opL' : (CancellativeMonoidTerm -> (CancellativeMonoidTerm -> CancellativeMonoidTerm))
    opL' x1 x2 = (opL x1 x2) 
    eL' : CancellativeMonoidTerm
    eL'  = eL 
    stageB : (CancellativeMonoidTerm -> (Staged CancellativeMonoidTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB eL = (Now eL) 
    opCl' : {A : Set} -> ((ClCancellativeMonoidTerm A) -> ((ClCancellativeMonoidTerm A) -> (ClCancellativeMonoidTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    eCl' : {A : Set} -> (ClCancellativeMonoidTerm A)
    eCl'  = eCl 
    stageCl : {A : Set} -> ((ClCancellativeMonoidTerm A) -> (Staged (ClCancellativeMonoidTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl eCl = (Now eCl) 
    opOL' : {n : Nat} -> ((OpCancellativeMonoidTerm n) -> ((OpCancellativeMonoidTerm n) -> (OpCancellativeMonoidTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    eOL' : {n : Nat} -> (OpCancellativeMonoidTerm n)
    eOL'  = eOL 
    stageOpB : {n : Nat} -> ((OpCancellativeMonoidTerm n) -> (Staged (OpCancellativeMonoidTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB eOL = (Now eOL) 
    opOL2' : {n : Nat} {A : Set} -> ((OpCancellativeMonoidTerm2 n A) -> ((OpCancellativeMonoidTerm2 n A) -> (OpCancellativeMonoidTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    eOL2' : {n : Nat} {A : Set} -> (OpCancellativeMonoidTerm2 n A)
    eOL2'  = eOL2 
    stageOp : {n : Nat} {A : Set} -> ((OpCancellativeMonoidTerm2 n A) -> (Staged (OpCancellativeMonoidTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp eOL2 = (Now eOL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        eT : (Repr A)
  module CancellativeSemigroup  where
    record CancellativeSemigroup (A : Set) : Set where
      constructor CancellativeSemigroupC
      field
        op : (A -> (A -> A))
        associative_op : {x y z : A} -> (op (op x y) z) == (op x (op y z))
        leftCancellative : {x y z : A} -> ((op z x) == (op z y) -> x == y)
        rightCancellative : {x y z : A} -> ((op x z) == (op y z) -> x == y)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        associative_opP : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP (opP yP zP))
        leftCancellativeP : {xP yP zP : (Prod A A)} -> ((opP zP xP) == (opP zP yP) -> xP == yP)
        rightCancellativeP : {xP yP zP : (Prod A A)} -> ((opP xP zP) == (opP yP zP) -> xP == yP)
    record Hom {A1 : Set} {A2 : Set} (Ca1 : (CancellativeSemigroup A1)) (Ca2 : (CancellativeSemigroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Ca1) x1 x2)) == ((op Ca2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ca1 : (CancellativeSemigroup A1)) (Ca2 : (CancellativeSemigroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Ca1) x1 x2) ((op Ca2) y1 y2))))
    data CancellativeSemigroupTerm  : Set where
      opL : (CancellativeSemigroupTerm -> (CancellativeSemigroupTerm -> CancellativeSemigroupTerm))
    data ClCancellativeSemigroupTerm (A : Set) : Set where
      sing : (A -> (ClCancellativeSemigroupTerm A))
      opCl : ((ClCancellativeSemigroupTerm A) -> ((ClCancellativeSemigroupTerm A) -> (ClCancellativeSemigroupTerm A)))
    data OpCancellativeSemigroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpCancellativeSemigroupTerm n))
      opOL : ((OpCancellativeSemigroupTerm n) -> ((OpCancellativeSemigroupTerm n) -> (OpCancellativeSemigroupTerm n)))
    data OpCancellativeSemigroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpCancellativeSemigroupTerm2 n A))
      sing2 : (A -> (OpCancellativeSemigroupTerm2 n A))
      opOL2 : ((OpCancellativeSemigroupTerm2 n A) -> ((OpCancellativeSemigroupTerm2 n A) -> (OpCancellativeSemigroupTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClCancellativeSemigroupTerm A) -> (ClCancellativeSemigroupTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpCancellativeSemigroupTerm n) -> (OpCancellativeSemigroupTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpCancellativeSemigroupTerm2 n A) -> (OpCancellativeSemigroupTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((CancellativeSemigroup A) -> (CancellativeSemigroupTerm -> A))
    evalB Ca (opL x1 x2) = ((op Ca) (evalB Ca x1) (evalB Ca x2)) 
    evalCl : {A : Set} -> ((CancellativeSemigroup A) -> ((ClCancellativeSemigroupTerm A) -> A))
    evalCl Ca (sing x1) = x1 
    evalCl Ca (opCl x1 x2) = ((op Ca) (evalCl Ca x1) (evalCl Ca x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((CancellativeSemigroup A) -> ((Vec A n) -> ((OpCancellativeSemigroupTerm n) -> A)))
    evalOpB Ca vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ca vars (opOL x1 x2) = ((op Ca) (evalOpB Ca vars x1) (evalOpB Ca vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((CancellativeSemigroup A) -> ((Vec A n) -> ((OpCancellativeSemigroupTerm2 n A) -> A)))
    evalOp Ca vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ca vars (sing2 x1) = x1 
    evalOp Ca vars (opOL2 x1 x2) = ((op Ca) (evalOp Ca vars x1) (evalOp Ca vars x2)) 
    inductionB : {P : (CancellativeSemigroupTerm -> Set)} -> (((x1 x2 : CancellativeSemigroupTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : CancellativeSemigroupTerm) -> (P x)))
    inductionB {p} popl (opL x1 x2) = (popl _ _ (inductionB {p} popl x1) (inductionB {p} popl x2)) 
    inductionCl : {A : Set} {P : ((ClCancellativeSemigroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClCancellativeSemigroupTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClCancellativeSemigroupTerm A)) -> (P x))))
    inductionCl {_} {p} psing popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl x1) (inductionCl {_} {p} psing popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpCancellativeSemigroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpCancellativeSemigroupTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpCancellativeSemigroupTerm n)) -> (P x))))
    inductionOpB {_} {p} pv popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol x1) (inductionOpB {_} {p} pv popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpCancellativeSemigroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpCancellativeSemigroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpCancellativeSemigroupTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 x2)) 
    opL' : (CancellativeSemigroupTerm -> (CancellativeSemigroupTerm -> CancellativeSemigroupTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (CancellativeSemigroupTerm -> (Staged CancellativeSemigroupTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClCancellativeSemigroupTerm A) -> ((ClCancellativeSemigroupTerm A) -> (ClCancellativeSemigroupTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClCancellativeSemigroupTerm A) -> (Staged (ClCancellativeSemigroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpCancellativeSemigroupTerm n) -> ((OpCancellativeSemigroupTerm n) -> (OpCancellativeSemigroupTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpCancellativeSemigroupTerm n) -> (Staged (OpCancellativeSemigroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpCancellativeSemigroupTerm2 n A) -> ((OpCancellativeSemigroupTerm2 n A) -> (OpCancellativeSemigroupTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpCancellativeSemigroupTerm2 n A) -> (Staged (OpCancellativeSemigroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module Carrier  where
    record Carrier (A : Set) : Set where
      constructor CarrierC
      field
        
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        
    record Product (A : Set) : Set where
      constructor ProductC
      field
        
    record Hom {A1 : Set} {A2 : Set} (Ca1 : (Carrier A1)) (Ca2 : (Carrier A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
    record RelInterp {A1 : Set} {A2 : Set} (Ca1 : (Carrier A1)) (Ca2 : (Carrier A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
    data CarrierTerm  : Set where
      
    data ClCarrierTerm (A : Set) : Set where
      sing : (A -> (ClCarrierTerm A))
    data OpCarrierTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpCarrierTerm n))
    data OpCarrierTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpCarrierTerm2 n A))
      sing2 : (A -> (OpCarrierTerm2 n A))
    simplifyCl : {A : Set} -> ((ClCarrierTerm A) -> (ClCarrierTerm A))
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpCarrierTerm n) -> (OpCarrierTerm n))
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpCarrierTerm2 n A) -> (OpCarrierTerm2 n A))
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalCl : {A : Set} -> ((Carrier A) -> ((ClCarrierTerm A) -> A))
    evalCl Ca (sing x1) = x1 
    evalOpB : {A : Set} {n : Nat} -> ((Carrier A) -> ((Vec A n) -> ((OpCarrierTerm n) -> A)))
    evalOpB Ca vars (v x1) = (lookup _ x1 vars) 
    evalOp : {A : Set} {n : Nat} -> ((Carrier A) -> ((Vec A n) -> ((OpCarrierTerm2 n A) -> A)))
    evalOp Ca vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ca vars (sing2 x1) = x1 
    inductionCl : {A : Set} {P : ((ClCarrierTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((x : (ClCarrierTerm A)) -> (P x)))
    inductionCl {_} {p} psing (sing x1) = (psing x1) 
    inductionOpB : {n : Nat} {P : ((OpCarrierTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((x : (OpCarrierTerm n)) -> (P x)))
    inductionOpB {_} {p} pv (v x1) = (pv x1) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpCarrierTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((x : (OpCarrierTerm2 n A)) -> (P x))))
    inductionOp {_} {_} {p} pv2 psing2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 (sing2 x1) = (psing2 x1) 
    stageCl : {A : Set} -> ((ClCarrierTerm A) -> (Staged (ClCarrierTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageOpB : {n : Nat} -> ((OpCarrierTerm n) -> (Staged (OpCarrierTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOp : {n : Nat} {A : Set} -> ((OpCarrierTerm2 n A) -> (Staged (OpCarrierTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        
  module CommutativeAdditiveMagma  where
    record CommutativeAdditiveMagma (A : Set) : Set where
      constructor CommutativeAdditiveMagmaC
      field
        + : (A -> (A -> A))
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
    record Hom {A1 : Set} {A2 : Set} (Co1 : (CommutativeAdditiveMagma A1)) (Co2 : (CommutativeAdditiveMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Co1) x1 x2)) == ((+ Co2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Co1 : (CommutativeAdditiveMagma A1)) (Co2 : (CommutativeAdditiveMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Co1) x1 x2) ((+ Co2) y1 y2))))
    data CommutativeAdditiveMagmaTerm  : Set where
      +L : (CommutativeAdditiveMagmaTerm -> (CommutativeAdditiveMagmaTerm -> CommutativeAdditiveMagmaTerm))
    data ClCommutativeAdditiveMagmaTerm (A : Set) : Set where
      sing : (A -> (ClCommutativeAdditiveMagmaTerm A))
      +Cl : ((ClCommutativeAdditiveMagmaTerm A) -> ((ClCommutativeAdditiveMagmaTerm A) -> (ClCommutativeAdditiveMagmaTerm A)))
    data OpCommutativeAdditiveMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpCommutativeAdditiveMagmaTerm n))
      +OL : ((OpCommutativeAdditiveMagmaTerm n) -> ((OpCommutativeAdditiveMagmaTerm n) -> (OpCommutativeAdditiveMagmaTerm n)))
    data OpCommutativeAdditiveMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpCommutativeAdditiveMagmaTerm2 n A))
      sing2 : (A -> (OpCommutativeAdditiveMagmaTerm2 n A))
      +OL2 : ((OpCommutativeAdditiveMagmaTerm2 n A) -> ((OpCommutativeAdditiveMagmaTerm2 n A) -> (OpCommutativeAdditiveMagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClCommutativeAdditiveMagmaTerm A) -> (ClCommutativeAdditiveMagmaTerm A))
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpCommutativeAdditiveMagmaTerm n) -> (OpCommutativeAdditiveMagmaTerm n))
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpCommutativeAdditiveMagmaTerm2 n A) -> (OpCommutativeAdditiveMagmaTerm2 n A))
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((CommutativeAdditiveMagma A) -> (CommutativeAdditiveMagmaTerm -> A))
    evalB Co (+L x1 x2) = ((+ Co) (evalB Co x1) (evalB Co x2)) 
    evalCl : {A : Set} -> ((CommutativeAdditiveMagma A) -> ((ClCommutativeAdditiveMagmaTerm A) -> A))
    evalCl Co (sing x1) = x1 
    evalCl Co (+Cl x1 x2) = ((+ Co) (evalCl Co x1) (evalCl Co x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((CommutativeAdditiveMagma A) -> ((Vec A n) -> ((OpCommutativeAdditiveMagmaTerm n) -> A)))
    evalOpB Co vars (v x1) = (lookup _ x1 vars) 
    evalOpB Co vars (+OL x1 x2) = ((+ Co) (evalOpB Co vars x1) (evalOpB Co vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((CommutativeAdditiveMagma A) -> ((Vec A n) -> ((OpCommutativeAdditiveMagmaTerm2 n A) -> A)))
    evalOp Co vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Co vars (sing2 x1) = x1 
    evalOp Co vars (+OL2 x1 x2) = ((+ Co) (evalOp Co vars x1) (evalOp Co vars x2)) 
    inductionB : {P : (CommutativeAdditiveMagmaTerm -> Set)} -> (((x1 x2 : CommutativeAdditiveMagmaTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : CommutativeAdditiveMagmaTerm) -> (P x)))
    inductionB {p} p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p+l x1) (inductionB {p} p+l x2)) 
    inductionCl : {A : Set} {P : ((ClCommutativeAdditiveMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClCommutativeAdditiveMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClCommutativeAdditiveMagmaTerm A)) -> (P x))))
    inductionCl {_} {p} psing p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p+cl x1) (inductionCl {_} {p} psing p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpCommutativeAdditiveMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpCommutativeAdditiveMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpCommutativeAdditiveMagmaTerm n)) -> (P x))))
    inductionOpB {_} {p} pv p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p+ol x1) (inductionOpB {_} {p} pv p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpCommutativeAdditiveMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpCommutativeAdditiveMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpCommutativeAdditiveMagmaTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 x2)) 
    +L' : (CommutativeAdditiveMagmaTerm -> (CommutativeAdditiveMagmaTerm -> CommutativeAdditiveMagmaTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (CommutativeAdditiveMagmaTerm -> (Staged CommutativeAdditiveMagmaTerm))
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    +Cl' : {A : Set} -> ((ClCommutativeAdditiveMagmaTerm A) -> ((ClCommutativeAdditiveMagmaTerm A) -> (ClCommutativeAdditiveMagmaTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClCommutativeAdditiveMagmaTerm A) -> (Staged (ClCommutativeAdditiveMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    +OL' : {n : Nat} -> ((OpCommutativeAdditiveMagmaTerm n) -> ((OpCommutativeAdditiveMagmaTerm n) -> (OpCommutativeAdditiveMagmaTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpCommutativeAdditiveMagmaTerm n) -> (Staged (OpCommutativeAdditiveMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    +OL2' : {n : Nat} {A : Set} -> ((OpCommutativeAdditiveMagmaTerm2 n A) -> ((OpCommutativeAdditiveMagmaTerm2 n A) -> (OpCommutativeAdditiveMagmaTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpCommutativeAdditiveMagmaTerm2 n A) -> (Staged (OpCommutativeAdditiveMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module CommutativeGroup  where
    record CommutativeGroup (A : Set) : Set where
      constructor CommutativeGroupC
      field
        op : (A -> (A -> A))
        e : A
        lunit_e : {x : A} -> (op e x) == x
        runit_e : {x : A} -> (op x e) == x
        associative_op : {x y z : A} -> (op (op x y) z) == (op x (op y z))
        inv : (A -> A)
        leftInverse_inv_op_e : {x : A} -> (op x (inv x)) == e
        rightInverse_inv_op_e : {x : A} -> (op (inv x) x) == e
        commutative_op : {x y : A} -> (op x y) == (op y x)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        eS : AS
        invS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        eP : (Prod A A)
        invP : ((Prod A A) -> (Prod A A))
        lunit_eP : {xP : (Prod A A)} -> (opP eP xP) == xP
        runit_eP : {xP : (Prod A A)} -> (opP xP eP) == xP
        associative_opP : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP (opP yP zP))
        leftInverse_inv_op_eP : {xP : (Prod A A)} -> (opP xP (invP xP)) == eP
        rightInverse_inv_op_eP : {xP : (Prod A A)} -> (opP (invP xP) xP) == eP
        commutative_opP : {xP yP : (Prod A A)} -> (opP xP yP) == (opP yP xP)
    record Hom {A1 : Set} {A2 : Set} (Co1 : (CommutativeGroup A1)) (Co2 : (CommutativeGroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Co1) x1 x2)) == ((op Co2) (hom x1) (hom x2))
        pres-e : (hom (e Co1)) == (e Co2)
        pres-inv : {x1 : A1} -> (hom ((inv Co1) x1)) == ((inv Co2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (Co1 : (CommutativeGroup A1)) (Co2 : (CommutativeGroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Co1) x1 x2) ((op Co2) y1 y2))))
        interp-e : (interp (e Co1) (e Co2))
        interp-inv : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((inv Co1) x1) ((inv Co2) y1)))
    data CommutativeGroupTerm  : Set where
      opL : (CommutativeGroupTerm -> (CommutativeGroupTerm -> CommutativeGroupTerm))
      eL : CommutativeGroupTerm
      invL : (CommutativeGroupTerm -> CommutativeGroupTerm)
    data ClCommutativeGroupTerm (A : Set) : Set where
      sing : (A -> (ClCommutativeGroupTerm A))
      opCl : ((ClCommutativeGroupTerm A) -> ((ClCommutativeGroupTerm A) -> (ClCommutativeGroupTerm A)))
      eCl : (ClCommutativeGroupTerm A)
      invCl : ((ClCommutativeGroupTerm A) -> (ClCommutativeGroupTerm A))
    data OpCommutativeGroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpCommutativeGroupTerm n))
      opOL : ((OpCommutativeGroupTerm n) -> ((OpCommutativeGroupTerm n) -> (OpCommutativeGroupTerm n)))
      eOL : (OpCommutativeGroupTerm n)
      invOL : ((OpCommutativeGroupTerm n) -> (OpCommutativeGroupTerm n))
    data OpCommutativeGroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpCommutativeGroupTerm2 n A))
      sing2 : (A -> (OpCommutativeGroupTerm2 n A))
      opOL2 : ((OpCommutativeGroupTerm2 n A) -> ((OpCommutativeGroupTerm2 n A) -> (OpCommutativeGroupTerm2 n A)))
      eOL2 : (OpCommutativeGroupTerm2 n A)
      invOL2 : ((OpCommutativeGroupTerm2 n A) -> (OpCommutativeGroupTerm2 n A))
    simplifyCl : {A : Set} -> ((ClCommutativeGroupTerm A) -> (ClCommutativeGroupTerm A))
    simplifyCl (opCl eCl x) = x 
    simplifyCl (opCl x eCl) = x 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl eCl = eCl 
    simplifyCl (invCl x1) = (invCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpCommutativeGroupTerm n) -> (OpCommutativeGroupTerm n))
    simplifyOpB (opOL eOL x) = x 
    simplifyOpB (opOL x eOL) = x 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB eOL = eOL 
    simplifyOpB (invOL x1) = (invOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpCommutativeGroupTerm2 n A) -> (OpCommutativeGroupTerm2 n A))
    simplifyOp (opOL2 eOL2 x) = x 
    simplifyOp (opOL2 x eOL2) = x 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp eOL2 = eOL2 
    simplifyOp (invOL2 x1) = (invOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((CommutativeGroup A) -> (CommutativeGroupTerm -> A))
    evalB Co (opL x1 x2) = ((op Co) (evalB Co x1) (evalB Co x2)) 
    evalB Co eL = (e Co) 
    evalB Co (invL x1) = ((inv Co) (evalB Co x1)) 
    evalCl : {A : Set} -> ((CommutativeGroup A) -> ((ClCommutativeGroupTerm A) -> A))
    evalCl Co (sing x1) = x1 
    evalCl Co (opCl x1 x2) = ((op Co) (evalCl Co x1) (evalCl Co x2)) 
    evalCl Co eCl = (e Co) 
    evalCl Co (invCl x1) = ((inv Co) (evalCl Co x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((CommutativeGroup A) -> ((Vec A n) -> ((OpCommutativeGroupTerm n) -> A)))
    evalOpB Co vars (v x1) = (lookup _ x1 vars) 
    evalOpB Co vars (opOL x1 x2) = ((op Co) (evalOpB Co vars x1) (evalOpB Co vars x2)) 
    evalOpB Co vars eOL = (e Co) 
    evalOpB Co vars (invOL x1) = ((inv Co) (evalOpB Co vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((CommutativeGroup A) -> ((Vec A n) -> ((OpCommutativeGroupTerm2 n A) -> A)))
    evalOp Co vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Co vars (sing2 x1) = x1 
    evalOp Co vars (opOL2 x1 x2) = ((op Co) (evalOp Co vars x1) (evalOp Co vars x2)) 
    evalOp Co vars eOL2 = (e Co) 
    evalOp Co vars (invOL2 x1) = ((inv Co) (evalOp Co vars x1)) 
    inductionB : {P : (CommutativeGroupTerm -> Set)} -> (((x1 x2 : CommutativeGroupTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((P eL) -> (((x1 : CommutativeGroupTerm) -> ((P x1) -> (P (invL x1)))) -> ((x : CommutativeGroupTerm) -> (P x)))))
    inductionB {p} popl pel pinvl (opL x1 x2) = (popl _ _ (inductionB {p} popl pel pinvl x1) (inductionB {p} popl pel pinvl x2)) 
    inductionB {p} popl pel pinvl eL = pel 
    inductionB {p} popl pel pinvl (invL x1) = (pinvl _ (inductionB {p} popl pel pinvl x1)) 
    inductionCl : {A : Set} {P : ((ClCommutativeGroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClCommutativeGroupTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((P eCl) -> (((x1 : (ClCommutativeGroupTerm A)) -> ((P x1) -> (P (invCl x1)))) -> ((x : (ClCommutativeGroupTerm A)) -> (P x))))))
    inductionCl {_} {p} psing popcl pecl pinvcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl pecl pinvcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl pecl pinvcl x1) (inductionCl {_} {p} psing popcl pecl pinvcl x2)) 
    inductionCl {_} {p} psing popcl pecl pinvcl eCl = pecl 
    inductionCl {_} {p} psing popcl pecl pinvcl (invCl x1) = (pinvcl _ (inductionCl {_} {p} psing popcl pecl pinvcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpCommutativeGroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpCommutativeGroupTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((P eOL) -> (((x1 : (OpCommutativeGroupTerm n)) -> ((P x1) -> (P (invOL x1)))) -> ((x : (OpCommutativeGroupTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv popol peol pinvol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol peol pinvol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol peol pinvol x1) (inductionOpB {_} {p} pv popol peol pinvol x2)) 
    inductionOpB {_} {p} pv popol peol pinvol eOL = peol 
    inductionOpB {_} {p} pv popol peol pinvol (invOL x1) = (pinvol _ (inductionOpB {_} {p} pv popol peol pinvol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpCommutativeGroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpCommutativeGroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((P eOL2) -> (((x1 : (OpCommutativeGroupTerm2 n A)) -> ((P x1) -> (P (invOL2 x1)))) -> ((x : (OpCommutativeGroupTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 pinvol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 pinvol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 pinvol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 pinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 pinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 pinvol2 eOL2 = peol2 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 pinvol2 (invOL2 x1) = (pinvol2 _ (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 pinvol2 x1)) 
    opL' : (CommutativeGroupTerm -> (CommutativeGroupTerm -> CommutativeGroupTerm))
    opL' x1 x2 = (opL x1 x2) 
    eL' : CommutativeGroupTerm
    eL'  = eL 
    invL' : (CommutativeGroupTerm -> CommutativeGroupTerm)
    invL' x1 = (invL x1) 
    stageB : (CommutativeGroupTerm -> (Staged CommutativeGroupTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB eL = (Now eL) 
    stageB (invL x1) = (stage1 invL' (codeLift1 invL') (stageB x1)) 
    opCl' : {A : Set} -> ((ClCommutativeGroupTerm A) -> ((ClCommutativeGroupTerm A) -> (ClCommutativeGroupTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    eCl' : {A : Set} -> (ClCommutativeGroupTerm A)
    eCl'  = eCl 
    invCl' : {A : Set} -> ((ClCommutativeGroupTerm A) -> (ClCommutativeGroupTerm A))
    invCl' x1 = (invCl x1) 
    stageCl : {A : Set} -> ((ClCommutativeGroupTerm A) -> (Staged (ClCommutativeGroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl eCl = (Now eCl) 
    stageCl (invCl x1) = (stage1 invCl' (codeLift1 invCl') (stageCl x1)) 
    opOL' : {n : Nat} -> ((OpCommutativeGroupTerm n) -> ((OpCommutativeGroupTerm n) -> (OpCommutativeGroupTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    eOL' : {n : Nat} -> (OpCommutativeGroupTerm n)
    eOL'  = eOL 
    invOL' : {n : Nat} -> ((OpCommutativeGroupTerm n) -> (OpCommutativeGroupTerm n))
    invOL' x1 = (invOL x1) 
    stageOpB : {n : Nat} -> ((OpCommutativeGroupTerm n) -> (Staged (OpCommutativeGroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB eOL = (Now eOL) 
    stageOpB (invOL x1) = (stage1 invOL' (codeLift1 invOL') (stageOpB x1)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpCommutativeGroupTerm2 n A) -> ((OpCommutativeGroupTerm2 n A) -> (OpCommutativeGroupTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    eOL2' : {n : Nat} {A : Set} -> (OpCommutativeGroupTerm2 n A)
    eOL2'  = eOL2 
    invOL2' : {n : Nat} {A : Set} -> ((OpCommutativeGroupTerm2 n A) -> (OpCommutativeGroupTerm2 n A))
    invOL2' x1 = (invOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpCommutativeGroupTerm2 n A) -> (Staged (OpCommutativeGroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp eOL2 = (Now eOL2) 
    stageOp (invOL2 x1) = (stage1 invOL2' (codeLift1 invOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        eT : (Repr A)
        invT : ((Repr A) -> (Repr A))
  module CommutativeMagma  where
    record CommutativeMagma (A : Set) : Set where
      constructor CommutativeMagmaC
      field
        op : (A -> (A -> A))
        commutative_op : {x y : A} -> (op x y) == (op y x)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        commutative_opP : {xP yP : (Prod A A)} -> (opP xP yP) == (opP yP xP)
    record Hom {A1 : Set} {A2 : Set} (Co1 : (CommutativeMagma A1)) (Co2 : (CommutativeMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Co1) x1 x2)) == ((op Co2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Co1 : (CommutativeMagma A1)) (Co2 : (CommutativeMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Co1) x1 x2) ((op Co2) y1 y2))))
    data CommutativeMagmaTerm  : Set where
      opL : (CommutativeMagmaTerm -> (CommutativeMagmaTerm -> CommutativeMagmaTerm))
    data ClCommutativeMagmaTerm (A : Set) : Set where
      sing : (A -> (ClCommutativeMagmaTerm A))
      opCl : ((ClCommutativeMagmaTerm A) -> ((ClCommutativeMagmaTerm A) -> (ClCommutativeMagmaTerm A)))
    data OpCommutativeMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpCommutativeMagmaTerm n))
      opOL : ((OpCommutativeMagmaTerm n) -> ((OpCommutativeMagmaTerm n) -> (OpCommutativeMagmaTerm n)))
    data OpCommutativeMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpCommutativeMagmaTerm2 n A))
      sing2 : (A -> (OpCommutativeMagmaTerm2 n A))
      opOL2 : ((OpCommutativeMagmaTerm2 n A) -> ((OpCommutativeMagmaTerm2 n A) -> (OpCommutativeMagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClCommutativeMagmaTerm A) -> (ClCommutativeMagmaTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpCommutativeMagmaTerm n) -> (OpCommutativeMagmaTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpCommutativeMagmaTerm2 n A) -> (OpCommutativeMagmaTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((CommutativeMagma A) -> (CommutativeMagmaTerm -> A))
    evalB Co (opL x1 x2) = ((op Co) (evalB Co x1) (evalB Co x2)) 
    evalCl : {A : Set} -> ((CommutativeMagma A) -> ((ClCommutativeMagmaTerm A) -> A))
    evalCl Co (sing x1) = x1 
    evalCl Co (opCl x1 x2) = ((op Co) (evalCl Co x1) (evalCl Co x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((CommutativeMagma A) -> ((Vec A n) -> ((OpCommutativeMagmaTerm n) -> A)))
    evalOpB Co vars (v x1) = (lookup _ x1 vars) 
    evalOpB Co vars (opOL x1 x2) = ((op Co) (evalOpB Co vars x1) (evalOpB Co vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((CommutativeMagma A) -> ((Vec A n) -> ((OpCommutativeMagmaTerm2 n A) -> A)))
    evalOp Co vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Co vars (sing2 x1) = x1 
    evalOp Co vars (opOL2 x1 x2) = ((op Co) (evalOp Co vars x1) (evalOp Co vars x2)) 
    inductionB : {P : (CommutativeMagmaTerm -> Set)} -> (((x1 x2 : CommutativeMagmaTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : CommutativeMagmaTerm) -> (P x)))
    inductionB {p} popl (opL x1 x2) = (popl _ _ (inductionB {p} popl x1) (inductionB {p} popl x2)) 
    inductionCl : {A : Set} {P : ((ClCommutativeMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClCommutativeMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClCommutativeMagmaTerm A)) -> (P x))))
    inductionCl {_} {p} psing popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl x1) (inductionCl {_} {p} psing popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpCommutativeMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpCommutativeMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpCommutativeMagmaTerm n)) -> (P x))))
    inductionOpB {_} {p} pv popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol x1) (inductionOpB {_} {p} pv popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpCommutativeMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpCommutativeMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpCommutativeMagmaTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 x2)) 
    opL' : (CommutativeMagmaTerm -> (CommutativeMagmaTerm -> CommutativeMagmaTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (CommutativeMagmaTerm -> (Staged CommutativeMagmaTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClCommutativeMagmaTerm A) -> ((ClCommutativeMagmaTerm A) -> (ClCommutativeMagmaTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClCommutativeMagmaTerm A) -> (Staged (ClCommutativeMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpCommutativeMagmaTerm n) -> ((OpCommutativeMagmaTerm n) -> (OpCommutativeMagmaTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpCommutativeMagmaTerm n) -> (Staged (OpCommutativeMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpCommutativeMagmaTerm2 n A) -> ((OpCommutativeMagmaTerm2 n A) -> (OpCommutativeMagmaTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpCommutativeMagmaTerm2 n A) -> (Staged (OpCommutativeMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module CommutativeMonoid  where
    record CommutativeMonoid (A : Set) : Set where
      constructor CommutativeMonoidC
      field
        op : (A -> (A -> A))
        associative_op : {x y z : A} -> (op (op x y) z) == (op x (op y z))
        e : A
        lunit_e : {x : A} -> (op e x) == x
        runit_e : {x : A} -> (op x e) == x
        commutative_op : {x y : A} -> (op x y) == (op y x)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        eS : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        eP : (Prod A A)
        associative_opP : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP (opP yP zP))
        lunit_eP : {xP : (Prod A A)} -> (opP eP xP) == xP
        runit_eP : {xP : (Prod A A)} -> (opP xP eP) == xP
        commutative_opP : {xP yP : (Prod A A)} -> (opP xP yP) == (opP yP xP)
    record Hom {A1 : Set} {A2 : Set} (Co1 : (CommutativeMonoid A1)) (Co2 : (CommutativeMonoid A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Co1) x1 x2)) == ((op Co2) (hom x1) (hom x2))
        pres-e : (hom (e Co1)) == (e Co2)
    record RelInterp {A1 : Set} {A2 : Set} (Co1 : (CommutativeMonoid A1)) (Co2 : (CommutativeMonoid A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Co1) x1 x2) ((op Co2) y1 y2))))
        interp-e : (interp (e Co1) (e Co2))
    data CommutativeMonoidTerm  : Set where
      opL : (CommutativeMonoidTerm -> (CommutativeMonoidTerm -> CommutativeMonoidTerm))
      eL : CommutativeMonoidTerm
    data ClCommutativeMonoidTerm (A : Set) : Set where
      sing : (A -> (ClCommutativeMonoidTerm A))
      opCl : ((ClCommutativeMonoidTerm A) -> ((ClCommutativeMonoidTerm A) -> (ClCommutativeMonoidTerm A)))
      eCl : (ClCommutativeMonoidTerm A)
    data OpCommutativeMonoidTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpCommutativeMonoidTerm n))
      opOL : ((OpCommutativeMonoidTerm n) -> ((OpCommutativeMonoidTerm n) -> (OpCommutativeMonoidTerm n)))
      eOL : (OpCommutativeMonoidTerm n)
    data OpCommutativeMonoidTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpCommutativeMonoidTerm2 n A))
      sing2 : (A -> (OpCommutativeMonoidTerm2 n A))
      opOL2 : ((OpCommutativeMonoidTerm2 n A) -> ((OpCommutativeMonoidTerm2 n A) -> (OpCommutativeMonoidTerm2 n A)))
      eOL2 : (OpCommutativeMonoidTerm2 n A)
    simplifyCl : {A : Set} -> ((ClCommutativeMonoidTerm A) -> (ClCommutativeMonoidTerm A))
    simplifyCl (opCl eCl x) = x 
    simplifyCl (opCl x eCl) = x 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl eCl = eCl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpCommutativeMonoidTerm n) -> (OpCommutativeMonoidTerm n))
    simplifyOpB (opOL eOL x) = x 
    simplifyOpB (opOL x eOL) = x 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB eOL = eOL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpCommutativeMonoidTerm2 n A) -> (OpCommutativeMonoidTerm2 n A))
    simplifyOp (opOL2 eOL2 x) = x 
    simplifyOp (opOL2 x eOL2) = x 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp eOL2 = eOL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((CommutativeMonoid A) -> (CommutativeMonoidTerm -> A))
    evalB Co (opL x1 x2) = ((op Co) (evalB Co x1) (evalB Co x2)) 
    evalB Co eL = (e Co) 
    evalCl : {A : Set} -> ((CommutativeMonoid A) -> ((ClCommutativeMonoidTerm A) -> A))
    evalCl Co (sing x1) = x1 
    evalCl Co (opCl x1 x2) = ((op Co) (evalCl Co x1) (evalCl Co x2)) 
    evalCl Co eCl = (e Co) 
    evalOpB : {A : Set} {n : Nat} -> ((CommutativeMonoid A) -> ((Vec A n) -> ((OpCommutativeMonoidTerm n) -> A)))
    evalOpB Co vars (v x1) = (lookup _ x1 vars) 
    evalOpB Co vars (opOL x1 x2) = ((op Co) (evalOpB Co vars x1) (evalOpB Co vars x2)) 
    evalOpB Co vars eOL = (e Co) 
    evalOp : {A : Set} {n : Nat} -> ((CommutativeMonoid A) -> ((Vec A n) -> ((OpCommutativeMonoidTerm2 n A) -> A)))
    evalOp Co vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Co vars (sing2 x1) = x1 
    evalOp Co vars (opOL2 x1 x2) = ((op Co) (evalOp Co vars x1) (evalOp Co vars x2)) 
    evalOp Co vars eOL2 = (e Co) 
    inductionB : {P : (CommutativeMonoidTerm -> Set)} -> (((x1 x2 : CommutativeMonoidTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((P eL) -> ((x : CommutativeMonoidTerm) -> (P x))))
    inductionB {p} popl pel (opL x1 x2) = (popl _ _ (inductionB {p} popl pel x1) (inductionB {p} popl pel x2)) 
    inductionB {p} popl pel eL = pel 
    inductionCl : {A : Set} {P : ((ClCommutativeMonoidTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClCommutativeMonoidTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((P eCl) -> ((x : (ClCommutativeMonoidTerm A)) -> (P x)))))
    inductionCl {_} {p} psing popcl pecl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl pecl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl pecl x1) (inductionCl {_} {p} psing popcl pecl x2)) 
    inductionCl {_} {p} psing popcl pecl eCl = pecl 
    inductionOpB : {n : Nat} {P : ((OpCommutativeMonoidTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpCommutativeMonoidTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((P eOL) -> ((x : (OpCommutativeMonoidTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv popol peol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol peol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol peol x1) (inductionOpB {_} {p} pv popol peol x2)) 
    inductionOpB {_} {p} pv popol peol eOL = peol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpCommutativeMonoidTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpCommutativeMonoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((P eOL2) -> ((x : (OpCommutativeMonoidTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 eOL2 = peol2 
    opL' : (CommutativeMonoidTerm -> (CommutativeMonoidTerm -> CommutativeMonoidTerm))
    opL' x1 x2 = (opL x1 x2) 
    eL' : CommutativeMonoidTerm
    eL'  = eL 
    stageB : (CommutativeMonoidTerm -> (Staged CommutativeMonoidTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB eL = (Now eL) 
    opCl' : {A : Set} -> ((ClCommutativeMonoidTerm A) -> ((ClCommutativeMonoidTerm A) -> (ClCommutativeMonoidTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    eCl' : {A : Set} -> (ClCommutativeMonoidTerm A)
    eCl'  = eCl 
    stageCl : {A : Set} -> ((ClCommutativeMonoidTerm A) -> (Staged (ClCommutativeMonoidTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl eCl = (Now eCl) 
    opOL' : {n : Nat} -> ((OpCommutativeMonoidTerm n) -> ((OpCommutativeMonoidTerm n) -> (OpCommutativeMonoidTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    eOL' : {n : Nat} -> (OpCommutativeMonoidTerm n)
    eOL'  = eOL 
    stageOpB : {n : Nat} -> ((OpCommutativeMonoidTerm n) -> (Staged (OpCommutativeMonoidTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB eOL = (Now eOL) 
    opOL2' : {n : Nat} {A : Set} -> ((OpCommutativeMonoidTerm2 n A) -> ((OpCommutativeMonoidTerm2 n A) -> (OpCommutativeMonoidTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    eOL2' : {n : Nat} {A : Set} -> (OpCommutativeMonoidTerm2 n A)
    eOL2'  = eOL2 
    stageOp : {n : Nat} {A : Set} -> ((OpCommutativeMonoidTerm2 n A) -> (Staged (OpCommutativeMonoidTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp eOL2 = (Now eOL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        eT : (Repr A)
  module CommutativeMonoid1  where
    record CommutativeMonoid1 (A : Set) : Set where
      constructor CommutativeMonoid1C
      field
        op : (A -> (A -> A))
        1 : A
        lunit_1 : {x : A} -> (op 1 x) == x
        runit_1 : {x : A} -> (op x 1) == x
        associative_op : {x y z : A} -> (op (op x y) z) == (op x (op y z))
        commutative_op : {x y : A} -> (op x y) == (op y x)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        1S : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        1P : (Prod A A)
        lunit_1P : {xP : (Prod A A)} -> (opP 1P xP) == xP
        runit_1P : {xP : (Prod A A)} -> (opP xP 1P) == xP
        associative_opP : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP (opP yP zP))
        commutative_opP : {xP yP : (Prod A A)} -> (opP xP yP) == (opP yP xP)
    record Hom {A1 : Set} {A2 : Set} (Co1 : (CommutativeMonoid1 A1)) (Co2 : (CommutativeMonoid1 A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Co1) x1 x2)) == ((op Co2) (hom x1) (hom x2))
        pres-1 : (hom (1 Co1)) == (1 Co2)
    record RelInterp {A1 : Set} {A2 : Set} (Co1 : (CommutativeMonoid1 A1)) (Co2 : (CommutativeMonoid1 A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Co1) x1 x2) ((op Co2) y1 y2))))
        interp-1 : (interp (1 Co1) (1 Co2))
    data CommutativeMonoid1LTerm  : Set where
      opL : (CommutativeMonoid1LTerm -> (CommutativeMonoid1LTerm -> CommutativeMonoid1LTerm))
      1L : CommutativeMonoid1LTerm
    data ClCommutativeMonoid1ClTerm (A : Set) : Set where
      sing : (A -> (ClCommutativeMonoid1ClTerm A))
      opCl : ((ClCommutativeMonoid1ClTerm A) -> ((ClCommutativeMonoid1ClTerm A) -> (ClCommutativeMonoid1ClTerm A)))
      1Cl : (ClCommutativeMonoid1ClTerm A)
    data OpCommutativeMonoid1OLTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpCommutativeMonoid1OLTerm n))
      opOL : ((OpCommutativeMonoid1OLTerm n) -> ((OpCommutativeMonoid1OLTerm n) -> (OpCommutativeMonoid1OLTerm n)))
      1OL : (OpCommutativeMonoid1OLTerm n)
    data OpCommutativeMonoid1OL2Term2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpCommutativeMonoid1OL2Term2 n A))
      sing2 : (A -> (OpCommutativeMonoid1OL2Term2 n A))
      opOL2 : ((OpCommutativeMonoid1OL2Term2 n A) -> ((OpCommutativeMonoid1OL2Term2 n A) -> (OpCommutativeMonoid1OL2Term2 n A)))
      1OL2 : (OpCommutativeMonoid1OL2Term2 n A)
    simplifyCl : {A : Set} -> ((ClCommutativeMonoid1ClTerm A) -> (ClCommutativeMonoid1ClTerm A))
    simplifyCl (opCl 1Cl x) = x 
    simplifyCl (opCl x 1Cl) = x 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpCommutativeMonoid1OLTerm n) -> (OpCommutativeMonoid1OLTerm n))
    simplifyOpB (opOL 1OL x) = x 
    simplifyOpB (opOL x 1OL) = x 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpCommutativeMonoid1OL2Term2 n A) -> (OpCommutativeMonoid1OL2Term2 n A))
    simplifyOp (opOL2 1OL2 x) = x 
    simplifyOp (opOL2 x 1OL2) = x 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((CommutativeMonoid1 A) -> (CommutativeMonoid1LTerm -> A))
    evalB Co (opL x1 x2) = ((op Co) (evalB Co x1) (evalB Co x2)) 
    evalB Co 1L = (1 Co) 
    evalCl : {A : Set} -> ((CommutativeMonoid1 A) -> ((ClCommutativeMonoid1ClTerm A) -> A))
    evalCl Co (sing x1) = x1 
    evalCl Co (opCl x1 x2) = ((op Co) (evalCl Co x1) (evalCl Co x2)) 
    evalCl Co 1Cl = (1 Co) 
    evalOpB : {A : Set} {n : Nat} -> ((CommutativeMonoid1 A) -> ((Vec A n) -> ((OpCommutativeMonoid1OLTerm n) -> A)))
    evalOpB Co vars (v x1) = (lookup _ x1 vars) 
    evalOpB Co vars (opOL x1 x2) = ((op Co) (evalOpB Co vars x1) (evalOpB Co vars x2)) 
    evalOpB Co vars 1OL = (1 Co) 
    evalOp : {A : Set} {n : Nat} -> ((CommutativeMonoid1 A) -> ((Vec A n) -> ((OpCommutativeMonoid1OL2Term2 n A) -> A)))
    evalOp Co vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Co vars (sing2 x1) = x1 
    evalOp Co vars (opOL2 x1 x2) = ((op Co) (evalOp Co vars x1) (evalOp Co vars x2)) 
    evalOp Co vars 1OL2 = (1 Co) 
    inductionB : {P : (CommutativeMonoid1LTerm -> Set)} -> (((x1 x2 : CommutativeMonoid1LTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((P 1L) -> ((x : CommutativeMonoid1LTerm) -> (P x))))
    inductionB {p} popl p1l (opL x1 x2) = (popl _ _ (inductionB {p} popl p1l x1) (inductionB {p} popl p1l x2)) 
    inductionB {p} popl p1l 1L = p1l 
    inductionCl : {A : Set} {P : ((ClCommutativeMonoid1ClTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClCommutativeMonoid1ClTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((P 1Cl) -> ((x : (ClCommutativeMonoid1ClTerm A)) -> (P x)))))
    inductionCl {_} {p} psing popcl p1cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl p1cl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl p1cl x1) (inductionCl {_} {p} psing popcl p1cl x2)) 
    inductionCl {_} {p} psing popcl p1cl 1Cl = p1cl 
    inductionOpB : {n : Nat} {P : ((OpCommutativeMonoid1OLTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpCommutativeMonoid1OLTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((P 1OL) -> ((x : (OpCommutativeMonoid1OLTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv popol p1ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol p1ol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol p1ol x1) (inductionOpB {_} {p} pv popol p1ol x2)) 
    inductionOpB {_} {p} pv popol p1ol 1OL = p1ol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpCommutativeMonoid1OL2Term2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpCommutativeMonoid1OL2Term2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((P 1OL2) -> ((x : (OpCommutativeMonoid1OL2Term2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 p1ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 p1ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 p1ol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 p1ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 p1ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 p1ol2 1OL2 = p1ol2 
    opL' : (CommutativeMonoid1LTerm -> (CommutativeMonoid1LTerm -> CommutativeMonoid1LTerm))
    opL' x1 x2 = (opL x1 x2) 
    1L' : CommutativeMonoid1LTerm
    1L'  = 1L 
    stageB : (CommutativeMonoid1LTerm -> (Staged CommutativeMonoid1LTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB 1L = (Now 1L) 
    opCl' : {A : Set} -> ((ClCommutativeMonoid1ClTerm A) -> ((ClCommutativeMonoid1ClTerm A) -> (ClCommutativeMonoid1ClTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    1Cl' : {A : Set} -> (ClCommutativeMonoid1ClTerm A)
    1Cl'  = 1Cl 
    stageCl : {A : Set} -> ((ClCommutativeMonoid1ClTerm A) -> (Staged (ClCommutativeMonoid1ClTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl 1Cl = (Now 1Cl) 
    opOL' : {n : Nat} -> ((OpCommutativeMonoid1OLTerm n) -> ((OpCommutativeMonoid1OLTerm n) -> (OpCommutativeMonoid1OLTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    1OL' : {n : Nat} -> (OpCommutativeMonoid1OLTerm n)
    1OL'  = 1OL 
    stageOpB : {n : Nat} -> ((OpCommutativeMonoid1OLTerm n) -> (Staged (OpCommutativeMonoid1OLTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 1OL = (Now 1OL) 
    opOL2' : {n : Nat} {A : Set} -> ((OpCommutativeMonoid1OL2Term2 n A) -> ((OpCommutativeMonoid1OL2Term2 n A) -> (OpCommutativeMonoid1OL2Term2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    1OL2' : {n : Nat} {A : Set} -> (OpCommutativeMonoid1OL2Term2 n A)
    1OL2'  = 1OL2 
    stageOp : {n : Nat} {A : Set} -> ((OpCommutativeMonoid1OL2Term2 n A) -> (Staged (OpCommutativeMonoid1OL2Term2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp 1OL2 = (Now 1OL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        1T : (Repr A)
  module CommutativePointedMagma  where
    record CommutativePointedMagma (A : Set) : Set where
      constructor CommutativePointedMagmaC
      field
        op : (A -> (A -> A))
        e : A
        commutative_op : {x y : A} -> (op x y) == (op y x)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        eS : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        eP : (Prod A A)
        commutative_opP : {xP yP : (Prod A A)} -> (opP xP yP) == (opP yP xP)
    record Hom {A1 : Set} {A2 : Set} (Co1 : (CommutativePointedMagma A1)) (Co2 : (CommutativePointedMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Co1) x1 x2)) == ((op Co2) (hom x1) (hom x2))
        pres-e : (hom (e Co1)) == (e Co2)
    record RelInterp {A1 : Set} {A2 : Set} (Co1 : (CommutativePointedMagma A1)) (Co2 : (CommutativePointedMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Co1) x1 x2) ((op Co2) y1 y2))))
        interp-e : (interp (e Co1) (e Co2))
    data CommutativePointedMagmaTerm  : Set where
      opL : (CommutativePointedMagmaTerm -> (CommutativePointedMagmaTerm -> CommutativePointedMagmaTerm))
      eL : CommutativePointedMagmaTerm
    data ClCommutativePointedMagmaTerm (A : Set) : Set where
      sing : (A -> (ClCommutativePointedMagmaTerm A))
      opCl : ((ClCommutativePointedMagmaTerm A) -> ((ClCommutativePointedMagmaTerm A) -> (ClCommutativePointedMagmaTerm A)))
      eCl : (ClCommutativePointedMagmaTerm A)
    data OpCommutativePointedMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpCommutativePointedMagmaTerm n))
      opOL : ((OpCommutativePointedMagmaTerm n) -> ((OpCommutativePointedMagmaTerm n) -> (OpCommutativePointedMagmaTerm n)))
      eOL : (OpCommutativePointedMagmaTerm n)
    data OpCommutativePointedMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpCommutativePointedMagmaTerm2 n A))
      sing2 : (A -> (OpCommutativePointedMagmaTerm2 n A))
      opOL2 : ((OpCommutativePointedMagmaTerm2 n A) -> ((OpCommutativePointedMagmaTerm2 n A) -> (OpCommutativePointedMagmaTerm2 n A)))
      eOL2 : (OpCommutativePointedMagmaTerm2 n A)
    simplifyCl : {A : Set} -> ((ClCommutativePointedMagmaTerm A) -> (ClCommutativePointedMagmaTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl eCl = eCl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpCommutativePointedMagmaTerm n) -> (OpCommutativePointedMagmaTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB eOL = eOL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpCommutativePointedMagmaTerm2 n A) -> (OpCommutativePointedMagmaTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp eOL2 = eOL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((CommutativePointedMagma A) -> (CommutativePointedMagmaTerm -> A))
    evalB Co (opL x1 x2) = ((op Co) (evalB Co x1) (evalB Co x2)) 
    evalB Co eL = (e Co) 
    evalCl : {A : Set} -> ((CommutativePointedMagma A) -> ((ClCommutativePointedMagmaTerm A) -> A))
    evalCl Co (sing x1) = x1 
    evalCl Co (opCl x1 x2) = ((op Co) (evalCl Co x1) (evalCl Co x2)) 
    evalCl Co eCl = (e Co) 
    evalOpB : {A : Set} {n : Nat} -> ((CommutativePointedMagma A) -> ((Vec A n) -> ((OpCommutativePointedMagmaTerm n) -> A)))
    evalOpB Co vars (v x1) = (lookup _ x1 vars) 
    evalOpB Co vars (opOL x1 x2) = ((op Co) (evalOpB Co vars x1) (evalOpB Co vars x2)) 
    evalOpB Co vars eOL = (e Co) 
    evalOp : {A : Set} {n : Nat} -> ((CommutativePointedMagma A) -> ((Vec A n) -> ((OpCommutativePointedMagmaTerm2 n A) -> A)))
    evalOp Co vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Co vars (sing2 x1) = x1 
    evalOp Co vars (opOL2 x1 x2) = ((op Co) (evalOp Co vars x1) (evalOp Co vars x2)) 
    evalOp Co vars eOL2 = (e Co) 
    inductionB : {P : (CommutativePointedMagmaTerm -> Set)} -> (((x1 x2 : CommutativePointedMagmaTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((P eL) -> ((x : CommutativePointedMagmaTerm) -> (P x))))
    inductionB {p} popl pel (opL x1 x2) = (popl _ _ (inductionB {p} popl pel x1) (inductionB {p} popl pel x2)) 
    inductionB {p} popl pel eL = pel 
    inductionCl : {A : Set} {P : ((ClCommutativePointedMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClCommutativePointedMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((P eCl) -> ((x : (ClCommutativePointedMagmaTerm A)) -> (P x)))))
    inductionCl {_} {p} psing popcl pecl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl pecl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl pecl x1) (inductionCl {_} {p} psing popcl pecl x2)) 
    inductionCl {_} {p} psing popcl pecl eCl = pecl 
    inductionOpB : {n : Nat} {P : ((OpCommutativePointedMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpCommutativePointedMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((P eOL) -> ((x : (OpCommutativePointedMagmaTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv popol peol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol peol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol peol x1) (inductionOpB {_} {p} pv popol peol x2)) 
    inductionOpB {_} {p} pv popol peol eOL = peol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpCommutativePointedMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpCommutativePointedMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((P eOL2) -> ((x : (OpCommutativePointedMagmaTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 eOL2 = peol2 
    opL' : (CommutativePointedMagmaTerm -> (CommutativePointedMagmaTerm -> CommutativePointedMagmaTerm))
    opL' x1 x2 = (opL x1 x2) 
    eL' : CommutativePointedMagmaTerm
    eL'  = eL 
    stageB : (CommutativePointedMagmaTerm -> (Staged CommutativePointedMagmaTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB eL = (Now eL) 
    opCl' : {A : Set} -> ((ClCommutativePointedMagmaTerm A) -> ((ClCommutativePointedMagmaTerm A) -> (ClCommutativePointedMagmaTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    eCl' : {A : Set} -> (ClCommutativePointedMagmaTerm A)
    eCl'  = eCl 
    stageCl : {A : Set} -> ((ClCommutativePointedMagmaTerm A) -> (Staged (ClCommutativePointedMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl eCl = (Now eCl) 
    opOL' : {n : Nat} -> ((OpCommutativePointedMagmaTerm n) -> ((OpCommutativePointedMagmaTerm n) -> (OpCommutativePointedMagmaTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    eOL' : {n : Nat} -> (OpCommutativePointedMagmaTerm n)
    eOL'  = eOL 
    stageOpB : {n : Nat} -> ((OpCommutativePointedMagmaTerm n) -> (Staged (OpCommutativePointedMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB eOL = (Now eOL) 
    opOL2' : {n : Nat} {A : Set} -> ((OpCommutativePointedMagmaTerm2 n A) -> ((OpCommutativePointedMagmaTerm2 n A) -> (OpCommutativePointedMagmaTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    eOL2' : {n : Nat} {A : Set} -> (OpCommutativePointedMagmaTerm2 n A)
    eOL2'  = eOL2 
    stageOp : {n : Nat} {A : Set} -> ((OpCommutativePointedMagmaTerm2 n A) -> (Staged (OpCommutativePointedMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp eOL2 = (Now eOL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        eT : (Repr A)
  module CommutativeRing  where
    record CommutativeRing (A : Set) : Set where
      constructor CommutativeRingC
      field
        1 : A
        * : (A -> (A -> A))
        lunit_1 : {x : A} -> (* 1 x) == x
        runit_1 : {x : A} -> (* x 1) == x
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        commutative_* : {x y : A} -> (* x y) == (* y x)
        + : (A -> (A -> A))
        0 : A
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        leftDistributive_*_+ : {x y z : A} -> (* x (+ y z)) == (+ (* x y) (* x z))
        rightDistributive_*_+ : {x y z : A} -> (* (+ y z) x) == (+ (* y x) (* z x))
        neg : (A -> A)
        leftInverse_inv_op_0 : {x : A} -> (+ x (neg x)) == 0
        rightInverse_inv_op_0 : {x : A} -> (+ (neg x) x) == 0
        leftZero_op_0 : {x : A} -> (* 0 x) == 0
        rightZero_op_0 : {x : A} -> (* x 0) == 0
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        1S : AS
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
        0S : AS
        negS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        1P : (Prod A A)
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        0P : (Prod A A)
        negP : ((Prod A A) -> (Prod A A))
        lunit_1P : {xP : (Prod A A)} -> (*P 1P xP) == xP
        runit_1P : {xP : (Prod A A)} -> (*P xP 1P) == xP
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        commutative_*P : {xP yP : (Prod A A)} -> (*P xP yP) == (*P yP xP)
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        leftDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P xP (+P yP zP)) == (+P (*P xP yP) (*P xP zP))
        rightDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P (+P yP zP) xP) == (+P (*P yP xP) (*P zP xP))
        leftInverse_inv_op_0P : {xP : (Prod A A)} -> (+P xP (negP xP)) == 0P
        rightInverse_inv_op_0P : {xP : (Prod A A)} -> (+P (negP xP) xP) == 0P
        leftZero_op_0P : {xP : (Prod A A)} -> (*P 0P xP) == 0P
        rightZero_op_0P : {xP : (Prod A A)} -> (*P xP 0P) == 0P
    record Hom {A1 : Set} {A2 : Set} (Co1 : (CommutativeRing A1)) (Co2 : (CommutativeRing A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-1 : (hom (1 Co1)) == (1 Co2)
        pres-* : {x1 x2 : A1} -> (hom ((* Co1) x1 x2)) == ((* Co2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Co1) x1 x2)) == ((+ Co2) (hom x1) (hom x2))
        pres-0 : (hom (0 Co1)) == (0 Co2)
        pres-neg : {x1 : A1} -> (hom ((neg Co1) x1)) == ((neg Co2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (Co1 : (CommutativeRing A1)) (Co2 : (CommutativeRing A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-1 : (interp (1 Co1) (1 Co2))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Co1) x1 x2) ((* Co2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Co1) x1 x2) ((+ Co2) y1 y2))))
        interp-0 : (interp (0 Co1) (0 Co2))
        interp-neg : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((neg Co1) x1) ((neg Co2) y1)))
    data CommutativeRingTerm  : Set where
      1L : CommutativeRingTerm
      *L : (CommutativeRingTerm -> (CommutativeRingTerm -> CommutativeRingTerm))
      +L : (CommutativeRingTerm -> (CommutativeRingTerm -> CommutativeRingTerm))
      0L : CommutativeRingTerm
      negL : (CommutativeRingTerm -> CommutativeRingTerm)
    data ClCommutativeRingTerm (A : Set) : Set where
      sing : (A -> (ClCommutativeRingTerm A))
      1Cl : (ClCommutativeRingTerm A)
      *Cl : ((ClCommutativeRingTerm A) -> ((ClCommutativeRingTerm A) -> (ClCommutativeRingTerm A)))
      +Cl : ((ClCommutativeRingTerm A) -> ((ClCommutativeRingTerm A) -> (ClCommutativeRingTerm A)))
      0Cl : (ClCommutativeRingTerm A)
      negCl : ((ClCommutativeRingTerm A) -> (ClCommutativeRingTerm A))
    data OpCommutativeRingTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpCommutativeRingTerm n))
      1OL : (OpCommutativeRingTerm n)
      *OL : ((OpCommutativeRingTerm n) -> ((OpCommutativeRingTerm n) -> (OpCommutativeRingTerm n)))
      +OL : ((OpCommutativeRingTerm n) -> ((OpCommutativeRingTerm n) -> (OpCommutativeRingTerm n)))
      0OL : (OpCommutativeRingTerm n)
      negOL : ((OpCommutativeRingTerm n) -> (OpCommutativeRingTerm n))
    data OpCommutativeRingTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpCommutativeRingTerm2 n A))
      sing2 : (A -> (OpCommutativeRingTerm2 n A))
      1OL2 : (OpCommutativeRingTerm2 n A)
      *OL2 : ((OpCommutativeRingTerm2 n A) -> ((OpCommutativeRingTerm2 n A) -> (OpCommutativeRingTerm2 n A)))
      +OL2 : ((OpCommutativeRingTerm2 n A) -> ((OpCommutativeRingTerm2 n A) -> (OpCommutativeRingTerm2 n A)))
      0OL2 : (OpCommutativeRingTerm2 n A)
      negOL2 : ((OpCommutativeRingTerm2 n A) -> (OpCommutativeRingTerm2 n A))
    simplifyCl : {A : Set} -> ((ClCommutativeRingTerm A) -> (ClCommutativeRingTerm A))
    simplifyCl (*Cl 1Cl x) = x 
    simplifyCl (*Cl x 1Cl) = x 
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 0Cl = 0Cl 
    simplifyCl (negCl x1) = (negCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpCommutativeRingTerm n) -> (OpCommutativeRingTerm n))
    simplifyOpB (*OL 1OL x) = x 
    simplifyOpB (*OL x 1OL) = x 
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 0OL = 0OL 
    simplifyOpB (negOL x1) = (negOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpCommutativeRingTerm2 n A) -> (OpCommutativeRingTerm2 n A))
    simplifyOp (*OL2 1OL2 x) = x 
    simplifyOp (*OL2 x 1OL2) = x 
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (negOL2 x1) = (negOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((CommutativeRing A) -> (CommutativeRingTerm -> A))
    evalB Co 1L = (1 Co) 
    evalB Co (*L x1 x2) = ((* Co) (evalB Co x1) (evalB Co x2)) 
    evalB Co (+L x1 x2) = ((+ Co) (evalB Co x1) (evalB Co x2)) 
    evalB Co 0L = (0 Co) 
    evalB Co (negL x1) = ((neg Co) (evalB Co x1)) 
    evalCl : {A : Set} -> ((CommutativeRing A) -> ((ClCommutativeRingTerm A) -> A))
    evalCl Co (sing x1) = x1 
    evalCl Co 1Cl = (1 Co) 
    evalCl Co (*Cl x1 x2) = ((* Co) (evalCl Co x1) (evalCl Co x2)) 
    evalCl Co (+Cl x1 x2) = ((+ Co) (evalCl Co x1) (evalCl Co x2)) 
    evalCl Co 0Cl = (0 Co) 
    evalCl Co (negCl x1) = ((neg Co) (evalCl Co x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((CommutativeRing A) -> ((Vec A n) -> ((OpCommutativeRingTerm n) -> A)))
    evalOpB Co vars (v x1) = (lookup _ x1 vars) 
    evalOpB Co vars 1OL = (1 Co) 
    evalOpB Co vars (*OL x1 x2) = ((* Co) (evalOpB Co vars x1) (evalOpB Co vars x2)) 
    evalOpB Co vars (+OL x1 x2) = ((+ Co) (evalOpB Co vars x1) (evalOpB Co vars x2)) 
    evalOpB Co vars 0OL = (0 Co) 
    evalOpB Co vars (negOL x1) = ((neg Co) (evalOpB Co vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((CommutativeRing A) -> ((Vec A n) -> ((OpCommutativeRingTerm2 n A) -> A)))
    evalOp Co vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Co vars (sing2 x1) = x1 
    evalOp Co vars 1OL2 = (1 Co) 
    evalOp Co vars (*OL2 x1 x2) = ((* Co) (evalOp Co vars x1) (evalOp Co vars x2)) 
    evalOp Co vars (+OL2 x1 x2) = ((+ Co) (evalOp Co vars x1) (evalOp Co vars x2)) 
    evalOp Co vars 0OL2 = (0 Co) 
    evalOp Co vars (negOL2 x1) = ((neg Co) (evalOp Co vars x1)) 
    inductionB : {P : (CommutativeRingTerm -> Set)} -> ((P 1L) -> (((x1 x2 : CommutativeRingTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : CommutativeRingTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((P 0L) -> (((x1 : CommutativeRingTerm) -> ((P x1) -> (P (negL x1)))) -> ((x : CommutativeRingTerm) -> (P x)))))))
    inductionB {p} p1l p*l p+l p0l pnegl 1L = p1l 
    inductionB {p} p1l p*l p+l p0l pnegl (*L x1 x2) = (p*l _ _ (inductionB {p} p1l p*l p+l p0l pnegl x1) (inductionB {p} p1l p*l p+l p0l pnegl x2)) 
    inductionB {p} p1l p*l p+l p0l pnegl (+L x1 x2) = (p+l _ _ (inductionB {p} p1l p*l p+l p0l pnegl x1) (inductionB {p} p1l p*l p+l p0l pnegl x2)) 
    inductionB {p} p1l p*l p+l p0l pnegl 0L = p0l 
    inductionB {p} p1l p*l p+l p0l pnegl (negL x1) = (pnegl _ (inductionB {p} p1l p*l p+l p0l pnegl x1)) 
    inductionCl : {A : Set} {P : ((ClCommutativeRingTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 1Cl) -> (((x1 x2 : (ClCommutativeRingTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClCommutativeRingTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((P 0Cl) -> (((x1 : (ClCommutativeRingTerm A)) -> ((P x1) -> (P (negCl x1)))) -> ((x : (ClCommutativeRingTerm A)) -> (P x))))))))
    inductionCl {_} {p} psing p1cl p*cl p+cl p0cl pnegcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p1cl p*cl p+cl p0cl pnegcl 1Cl = p1cl 
    inductionCl {_} {p} psing p1cl p*cl p+cl p0cl pnegcl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p1cl p*cl p+cl p0cl pnegcl x1) (inductionCl {_} {p} psing p1cl p*cl p+cl p0cl pnegcl x2)) 
    inductionCl {_} {p} psing p1cl p*cl p+cl p0cl pnegcl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p1cl p*cl p+cl p0cl pnegcl x1) (inductionCl {_} {p} psing p1cl p*cl p+cl p0cl pnegcl x2)) 
    inductionCl {_} {p} psing p1cl p*cl p+cl p0cl pnegcl 0Cl = p0cl 
    inductionCl {_} {p} psing p1cl p*cl p+cl p0cl pnegcl (negCl x1) = (pnegcl _ (inductionCl {_} {p} psing p1cl p*cl p+cl p0cl pnegcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpCommutativeRingTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 1OL) -> (((x1 x2 : (OpCommutativeRingTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpCommutativeRingTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((P 0OL) -> (((x1 : (OpCommutativeRingTerm n)) -> ((P x1) -> (P (negOL x1)))) -> ((x : (OpCommutativeRingTerm n)) -> (P x))))))))
    inductionOpB {_} {p} pv p1ol p*ol p+ol p0ol pnegol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p1ol p*ol p+ol p0ol pnegol 1OL = p1ol 
    inductionOpB {_} {p} pv p1ol p*ol p+ol p0ol pnegol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p1ol p*ol p+ol p0ol pnegol x1) (inductionOpB {_} {p} pv p1ol p*ol p+ol p0ol pnegol x2)) 
    inductionOpB {_} {p} pv p1ol p*ol p+ol p0ol pnegol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p1ol p*ol p+ol p0ol pnegol x1) (inductionOpB {_} {p} pv p1ol p*ol p+ol p0ol pnegol x2)) 
    inductionOpB {_} {p} pv p1ol p*ol p+ol p0ol pnegol 0OL = p0ol 
    inductionOpB {_} {p} pv p1ol p*ol p+ol p0ol pnegol (negOL x1) = (pnegol _ (inductionOpB {_} {p} pv p1ol p*ol p+ol p0ol pnegol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpCommutativeRingTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 1OL2) -> (((x1 x2 : (OpCommutativeRingTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpCommutativeRingTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((P 0OL2) -> (((x1 : (OpCommutativeRingTerm2 n A)) -> ((P x1) -> (P (negOL2 x1)))) -> ((x : (OpCommutativeRingTerm2 n A)) -> (P x)))))))))
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 p+ol2 p0ol2 pnegol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 p+ol2 p0ol2 pnegol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 p+ol2 p0ol2 pnegol2 1OL2 = p1ol2 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 p+ol2 p0ol2 pnegol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 p+ol2 p0ol2 pnegol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 p+ol2 p0ol2 pnegol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 p+ol2 p0ol2 pnegol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 p+ol2 p0ol2 pnegol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 p+ol2 p0ol2 pnegol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 p+ol2 p0ol2 pnegol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 p+ol2 p0ol2 pnegol2 (negOL2 x1) = (pnegol2 _ (inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 p+ol2 p0ol2 pnegol2 x1)) 
    1L' : CommutativeRingTerm
    1L'  = 1L 
    *L' : (CommutativeRingTerm -> (CommutativeRingTerm -> CommutativeRingTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (CommutativeRingTerm -> (CommutativeRingTerm -> CommutativeRingTerm))
    +L' x1 x2 = (+L x1 x2) 
    0L' : CommutativeRingTerm
    0L'  = 0L 
    negL' : (CommutativeRingTerm -> CommutativeRingTerm)
    negL' x1 = (negL x1) 
    stageB : (CommutativeRingTerm -> (Staged CommutativeRingTerm))
    stageB 1L = (Now 1L) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB 0L = (Now 0L) 
    stageB (negL x1) = (stage1 negL' (codeLift1 negL') (stageB x1)) 
    1Cl' : {A : Set} -> (ClCommutativeRingTerm A)
    1Cl'  = 1Cl 
    *Cl' : {A : Set} -> ((ClCommutativeRingTerm A) -> ((ClCommutativeRingTerm A) -> (ClCommutativeRingTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClCommutativeRingTerm A) -> ((ClCommutativeRingTerm A) -> (ClCommutativeRingTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    0Cl' : {A : Set} -> (ClCommutativeRingTerm A)
    0Cl'  = 0Cl 
    negCl' : {A : Set} -> ((ClCommutativeRingTerm A) -> (ClCommutativeRingTerm A))
    negCl' x1 = (negCl x1) 
    stageCl : {A : Set} -> ((ClCommutativeRingTerm A) -> (Staged (ClCommutativeRingTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 1Cl = (Now 1Cl) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (negCl x1) = (stage1 negCl' (codeLift1 negCl') (stageCl x1)) 
    1OL' : {n : Nat} -> (OpCommutativeRingTerm n)
    1OL'  = 1OL 
    *OL' : {n : Nat} -> ((OpCommutativeRingTerm n) -> ((OpCommutativeRingTerm n) -> (OpCommutativeRingTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpCommutativeRingTerm n) -> ((OpCommutativeRingTerm n) -> (OpCommutativeRingTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    0OL' : {n : Nat} -> (OpCommutativeRingTerm n)
    0OL'  = 0OL 
    negOL' : {n : Nat} -> ((OpCommutativeRingTerm n) -> (OpCommutativeRingTerm n))
    negOL' x1 = (negOL x1) 
    stageOpB : {n : Nat} -> ((OpCommutativeRingTerm n) -> (Staged (OpCommutativeRingTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 1OL = (Now 1OL) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (negOL x1) = (stage1 negOL' (codeLift1 negOL') (stageOpB x1)) 
    1OL2' : {n : Nat} {A : Set} -> (OpCommutativeRingTerm2 n A)
    1OL2'  = 1OL2 
    *OL2' : {n : Nat} {A : Set} -> ((OpCommutativeRingTerm2 n A) -> ((OpCommutativeRingTerm2 n A) -> (OpCommutativeRingTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpCommutativeRingTerm2 n A) -> ((OpCommutativeRingTerm2 n A) -> (OpCommutativeRingTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    0OL2' : {n : Nat} {A : Set} -> (OpCommutativeRingTerm2 n A)
    0OL2'  = 0OL2 
    negOL2' : {n : Nat} {A : Set} -> ((OpCommutativeRingTerm2 n A) -> (OpCommutativeRingTerm2 n A))
    negOL2' x1 = (negOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpCommutativeRingTerm2 n A) -> (Staged (OpCommutativeRingTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 1OL2 = (Now 1OL2) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (negOL2 x1) = (stage1 negOL2' (codeLift1 negOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        1T : (Repr A)
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        0T : (Repr A)
        negT : ((Repr A) -> (Repr A))
  module CommutativeSemigroup  where
    record CommutativeSemigroup (A : Set) : Set where
      constructor CommutativeSemigroupC
      field
        op : (A -> (A -> A))
        commutative_op : {x y : A} -> (op x y) == (op y x)
        associative_op : {x y z : A} -> (op (op x y) z) == (op x (op y z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        commutative_opP : {xP yP : (Prod A A)} -> (opP xP yP) == (opP yP xP)
        associative_opP : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP (opP yP zP))
    record Hom {A1 : Set} {A2 : Set} (Co1 : (CommutativeSemigroup A1)) (Co2 : (CommutativeSemigroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Co1) x1 x2)) == ((op Co2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Co1 : (CommutativeSemigroup A1)) (Co2 : (CommutativeSemigroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Co1) x1 x2) ((op Co2) y1 y2))))
    data CommutativeSemigroupTerm  : Set where
      opL : (CommutativeSemigroupTerm -> (CommutativeSemigroupTerm -> CommutativeSemigroupTerm))
    data ClCommutativeSemigroupTerm (A : Set) : Set where
      sing : (A -> (ClCommutativeSemigroupTerm A))
      opCl : ((ClCommutativeSemigroupTerm A) -> ((ClCommutativeSemigroupTerm A) -> (ClCommutativeSemigroupTerm A)))
    data OpCommutativeSemigroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpCommutativeSemigroupTerm n))
      opOL : ((OpCommutativeSemigroupTerm n) -> ((OpCommutativeSemigroupTerm n) -> (OpCommutativeSemigroupTerm n)))
    data OpCommutativeSemigroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpCommutativeSemigroupTerm2 n A))
      sing2 : (A -> (OpCommutativeSemigroupTerm2 n A))
      opOL2 : ((OpCommutativeSemigroupTerm2 n A) -> ((OpCommutativeSemigroupTerm2 n A) -> (OpCommutativeSemigroupTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClCommutativeSemigroupTerm A) -> (ClCommutativeSemigroupTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpCommutativeSemigroupTerm n) -> (OpCommutativeSemigroupTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpCommutativeSemigroupTerm2 n A) -> (OpCommutativeSemigroupTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((CommutativeSemigroup A) -> (CommutativeSemigroupTerm -> A))
    evalB Co (opL x1 x2) = ((op Co) (evalB Co x1) (evalB Co x2)) 
    evalCl : {A : Set} -> ((CommutativeSemigroup A) -> ((ClCommutativeSemigroupTerm A) -> A))
    evalCl Co (sing x1) = x1 
    evalCl Co (opCl x1 x2) = ((op Co) (evalCl Co x1) (evalCl Co x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((CommutativeSemigroup A) -> ((Vec A n) -> ((OpCommutativeSemigroupTerm n) -> A)))
    evalOpB Co vars (v x1) = (lookup _ x1 vars) 
    evalOpB Co vars (opOL x1 x2) = ((op Co) (evalOpB Co vars x1) (evalOpB Co vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((CommutativeSemigroup A) -> ((Vec A n) -> ((OpCommutativeSemigroupTerm2 n A) -> A)))
    evalOp Co vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Co vars (sing2 x1) = x1 
    evalOp Co vars (opOL2 x1 x2) = ((op Co) (evalOp Co vars x1) (evalOp Co vars x2)) 
    inductionB : {P : (CommutativeSemigroupTerm -> Set)} -> (((x1 x2 : CommutativeSemigroupTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : CommutativeSemigroupTerm) -> (P x)))
    inductionB {p} popl (opL x1 x2) = (popl _ _ (inductionB {p} popl x1) (inductionB {p} popl x2)) 
    inductionCl : {A : Set} {P : ((ClCommutativeSemigroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClCommutativeSemigroupTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClCommutativeSemigroupTerm A)) -> (P x))))
    inductionCl {_} {p} psing popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl x1) (inductionCl {_} {p} psing popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpCommutativeSemigroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpCommutativeSemigroupTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpCommutativeSemigroupTerm n)) -> (P x))))
    inductionOpB {_} {p} pv popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol x1) (inductionOpB {_} {p} pv popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpCommutativeSemigroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpCommutativeSemigroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpCommutativeSemigroupTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 x2)) 
    opL' : (CommutativeSemigroupTerm -> (CommutativeSemigroupTerm -> CommutativeSemigroupTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (CommutativeSemigroupTerm -> (Staged CommutativeSemigroupTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClCommutativeSemigroupTerm A) -> ((ClCommutativeSemigroupTerm A) -> (ClCommutativeSemigroupTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClCommutativeSemigroupTerm A) -> (Staged (ClCommutativeSemigroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpCommutativeSemigroupTerm n) -> ((OpCommutativeSemigroupTerm n) -> (OpCommutativeSemigroupTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpCommutativeSemigroupTerm n) -> (Staged (OpCommutativeSemigroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpCommutativeSemigroupTerm2 n A) -> ((OpCommutativeSemigroupTerm2 n A) -> (OpCommutativeSemigroupTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpCommutativeSemigroupTerm2 n A) -> (Staged (OpCommutativeSemigroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module ComplementSig  where
    record ComplementSig (A : Set) : Set where
      constructor ComplementSigC
      field
        compl : (A -> A)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        complS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        complP : ((Prod A A) -> (Prod A A))
    record Hom {A1 : Set} {A2 : Set} (Co1 : (ComplementSig A1)) (Co2 : (ComplementSig A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-compl : {x1 : A1} -> (hom ((compl Co1) x1)) == ((compl Co2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (Co1 : (ComplementSig A1)) (Co2 : (ComplementSig A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-compl : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((compl Co1) x1) ((compl Co2) y1)))
    data ComplementSigTerm  : Set where
      complL : (ComplementSigTerm -> ComplementSigTerm)
    data ClComplementSigTerm (A : Set) : Set where
      sing : (A -> (ClComplementSigTerm A))
      complCl : ((ClComplementSigTerm A) -> (ClComplementSigTerm A))
    data OpComplementSigTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpComplementSigTerm n))
      complOL : ((OpComplementSigTerm n) -> (OpComplementSigTerm n))
    data OpComplementSigTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpComplementSigTerm2 n A))
      sing2 : (A -> (OpComplementSigTerm2 n A))
      complOL2 : ((OpComplementSigTerm2 n A) -> (OpComplementSigTerm2 n A))
    simplifyCl : {A : Set} -> ((ClComplementSigTerm A) -> (ClComplementSigTerm A))
    simplifyCl (complCl x1) = (complCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpComplementSigTerm n) -> (OpComplementSigTerm n))
    simplifyOpB (complOL x1) = (complOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpComplementSigTerm2 n A) -> (OpComplementSigTerm2 n A))
    simplifyOp (complOL2 x1) = (complOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((ComplementSig A) -> (ComplementSigTerm -> A))
    evalB Co (complL x1) = ((compl Co) (evalB Co x1)) 
    evalCl : {A : Set} -> ((ComplementSig A) -> ((ClComplementSigTerm A) -> A))
    evalCl Co (sing x1) = x1 
    evalCl Co (complCl x1) = ((compl Co) (evalCl Co x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((ComplementSig A) -> ((Vec A n) -> ((OpComplementSigTerm n) -> A)))
    evalOpB Co vars (v x1) = (lookup _ x1 vars) 
    evalOpB Co vars (complOL x1) = ((compl Co) (evalOpB Co vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((ComplementSig A) -> ((Vec A n) -> ((OpComplementSigTerm2 n A) -> A)))
    evalOp Co vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Co vars (sing2 x1) = x1 
    evalOp Co vars (complOL2 x1) = ((compl Co) (evalOp Co vars x1)) 
    inductionB : {P : (ComplementSigTerm -> Set)} -> (((x1 : ComplementSigTerm) -> ((P x1) -> (P (complL x1)))) -> ((x : ComplementSigTerm) -> (P x)))
    inductionB {p} pcompll (complL x1) = (pcompll _ (inductionB {p} pcompll x1)) 
    inductionCl : {A : Set} {P : ((ClComplementSigTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 : (ClComplementSigTerm A)) -> ((P x1) -> (P (complCl x1)))) -> ((x : (ClComplementSigTerm A)) -> (P x))))
    inductionCl {_} {p} psing pcomplcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pcomplcl (complCl x1) = (pcomplcl _ (inductionCl {_} {p} psing pcomplcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpComplementSigTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 : (OpComplementSigTerm n)) -> ((P x1) -> (P (complOL x1)))) -> ((x : (OpComplementSigTerm n)) -> (P x))))
    inductionOpB {_} {p} pv pcomplol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pcomplol (complOL x1) = (pcomplol _ (inductionOpB {_} {p} pv pcomplol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpComplementSigTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 : (OpComplementSigTerm2 n A)) -> ((P x1) -> (P (complOL2 x1)))) -> ((x : (OpComplementSigTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 pcomplol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pcomplol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pcomplol2 (complOL2 x1) = (pcomplol2 _ (inductionOp {_} {_} {p} pv2 psing2 pcomplol2 x1)) 
    complL' : (ComplementSigTerm -> ComplementSigTerm)
    complL' x1 = (complL x1) 
    stageB : (ComplementSigTerm -> (Staged ComplementSigTerm))
    stageB (complL x1) = (stage1 complL' (codeLift1 complL') (stageB x1)) 
    complCl' : {A : Set} -> ((ClComplementSigTerm A) -> (ClComplementSigTerm A))
    complCl' x1 = (complCl x1) 
    stageCl : {A : Set} -> ((ClComplementSigTerm A) -> (Staged (ClComplementSigTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (complCl x1) = (stage1 complCl' (codeLift1 complCl') (stageCl x1)) 
    complOL' : {n : Nat} -> ((OpComplementSigTerm n) -> (OpComplementSigTerm n))
    complOL' x1 = (complOL x1) 
    stageOpB : {n : Nat} -> ((OpComplementSigTerm n) -> (Staged (OpComplementSigTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (complOL x1) = (stage1 complOL' (codeLift1 complOL') (stageOpB x1)) 
    complOL2' : {n : Nat} {A : Set} -> ((OpComplementSigTerm2 n A) -> (OpComplementSigTerm2 n A))
    complOL2' x1 = (complOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpComplementSigTerm2 n A) -> (Staged (OpComplementSigTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (complOL2 x1) = (stage1 complOL2' (codeLift1 complOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        complT : ((Repr A) -> (Repr A))
  module DistributiveLattice  where
    record DistributiveLattice (A : Set) : Set where
      constructor DistributiveLatticeC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        commutative_* : {x y : A} -> (* x y) == (* y x)
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        idempotent_* : {x : A} -> (* x x) == x
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        idempotent_+ : {x : A} -> (+ x x) == x
        leftAbsorp_*_+ : {x y : A} -> (* x (+ x y)) == x
        leftAbsorp_+_* : {x y : A} -> (+ x (* x y)) == x
        leftModular_*_+ : {x y z : A} -> (+ (* x y) (* x z)) == (* x (+ y (* x z)))
        leftDistributive_*_+ : {x y z : A} -> (* x (+ y z)) == (+ (* x y) (* x z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        commutative_*P : {xP yP : (Prod A A)} -> (*P xP yP) == (*P yP xP)
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        idempotent_*P : {xP : (Prod A A)} -> (*P xP xP) == xP
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        idempotent_+P : {xP : (Prod A A)} -> (+P xP xP) == xP
        leftAbsorp_*_+P : {xP yP : (Prod A A)} -> (*P xP (+P xP yP)) == xP
        leftAbsorp_+_*P : {xP yP : (Prod A A)} -> (+P xP (*P xP yP)) == xP
        leftModular_*_+P : {xP yP zP : (Prod A A)} -> (+P (*P xP yP) (*P xP zP)) == (*P xP (+P yP (*P xP zP)))
        leftDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P xP (+P yP zP)) == (+P (*P xP yP) (*P xP zP))
    record Hom {A1 : Set} {A2 : Set} (Di1 : (DistributiveLattice A1)) (Di2 : (DistributiveLattice A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Di1) x1 x2)) == ((* Di2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Di1) x1 x2)) == ((+ Di2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Di1 : (DistributiveLattice A1)) (Di2 : (DistributiveLattice A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Di1) x1 x2) ((* Di2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Di1) x1 x2) ((+ Di2) y1 y2))))
    data DistributiveLatticeTerm  : Set where
      *L : (DistributiveLatticeTerm -> (DistributiveLatticeTerm -> DistributiveLatticeTerm))
      +L : (DistributiveLatticeTerm -> (DistributiveLatticeTerm -> DistributiveLatticeTerm))
    data ClDistributiveLatticeTerm (A : Set) : Set where
      sing : (A -> (ClDistributiveLatticeTerm A))
      *Cl : ((ClDistributiveLatticeTerm A) -> ((ClDistributiveLatticeTerm A) -> (ClDistributiveLatticeTerm A)))
      +Cl : ((ClDistributiveLatticeTerm A) -> ((ClDistributiveLatticeTerm A) -> (ClDistributiveLatticeTerm A)))
    data OpDistributiveLatticeTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpDistributiveLatticeTerm n))
      *OL : ((OpDistributiveLatticeTerm n) -> ((OpDistributiveLatticeTerm n) -> (OpDistributiveLatticeTerm n)))
      +OL : ((OpDistributiveLatticeTerm n) -> ((OpDistributiveLatticeTerm n) -> (OpDistributiveLatticeTerm n)))
    data OpDistributiveLatticeTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpDistributiveLatticeTerm2 n A))
      sing2 : (A -> (OpDistributiveLatticeTerm2 n A))
      *OL2 : ((OpDistributiveLatticeTerm2 n A) -> ((OpDistributiveLatticeTerm2 n A) -> (OpDistributiveLatticeTerm2 n A)))
      +OL2 : ((OpDistributiveLatticeTerm2 n A) -> ((OpDistributiveLatticeTerm2 n A) -> (OpDistributiveLatticeTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClDistributiveLatticeTerm A) -> (ClDistributiveLatticeTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpDistributiveLatticeTerm n) -> (OpDistributiveLatticeTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpDistributiveLatticeTerm2 n A) -> (OpDistributiveLatticeTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((DistributiveLattice A) -> (DistributiveLatticeTerm -> A))
    evalB Di (*L x1 x2) = ((* Di) (evalB Di x1) (evalB Di x2)) 
    evalB Di (+L x1 x2) = ((+ Di) (evalB Di x1) (evalB Di x2)) 
    evalCl : {A : Set} -> ((DistributiveLattice A) -> ((ClDistributiveLatticeTerm A) -> A))
    evalCl Di (sing x1) = x1 
    evalCl Di (*Cl x1 x2) = ((* Di) (evalCl Di x1) (evalCl Di x2)) 
    evalCl Di (+Cl x1 x2) = ((+ Di) (evalCl Di x1) (evalCl Di x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((DistributiveLattice A) -> ((Vec A n) -> ((OpDistributiveLatticeTerm n) -> A)))
    evalOpB Di vars (v x1) = (lookup _ x1 vars) 
    evalOpB Di vars (*OL x1 x2) = ((* Di) (evalOpB Di vars x1) (evalOpB Di vars x2)) 
    evalOpB Di vars (+OL x1 x2) = ((+ Di) (evalOpB Di vars x1) (evalOpB Di vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((DistributiveLattice A) -> ((Vec A n) -> ((OpDistributiveLatticeTerm2 n A) -> A)))
    evalOp Di vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Di vars (sing2 x1) = x1 
    evalOp Di vars (*OL2 x1 x2) = ((* Di) (evalOp Di vars x1) (evalOp Di vars x2)) 
    evalOp Di vars (+OL2 x1 x2) = ((+ Di) (evalOp Di vars x1) (evalOp Di vars x2)) 
    inductionB : {P : (DistributiveLatticeTerm -> Set)} -> (((x1 x2 : DistributiveLatticeTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : DistributiveLatticeTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : DistributiveLatticeTerm) -> (P x))))
    inductionB {p} p*l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionB {p} p*l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClDistributiveLatticeTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClDistributiveLatticeTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClDistributiveLatticeTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClDistributiveLatticeTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p*cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpDistributiveLatticeTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpDistributiveLatticeTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpDistributiveLatticeTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpDistributiveLatticeTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p*ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpDistributiveLatticeTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpDistributiveLatticeTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpDistributiveLatticeTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpDistributiveLatticeTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    *L' : (DistributiveLatticeTerm -> (DistributiveLatticeTerm -> DistributiveLatticeTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (DistributiveLatticeTerm -> (DistributiveLatticeTerm -> DistributiveLatticeTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (DistributiveLatticeTerm -> (Staged DistributiveLatticeTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClDistributiveLatticeTerm A) -> ((ClDistributiveLatticeTerm A) -> (ClDistributiveLatticeTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClDistributiveLatticeTerm A) -> ((ClDistributiveLatticeTerm A) -> (ClDistributiveLatticeTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClDistributiveLatticeTerm A) -> (Staged (ClDistributiveLatticeTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpDistributiveLatticeTerm n) -> ((OpDistributiveLatticeTerm n) -> (OpDistributiveLatticeTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpDistributiveLatticeTerm n) -> ((OpDistributiveLatticeTerm n) -> (OpDistributiveLatticeTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpDistributiveLatticeTerm n) -> (Staged (OpDistributiveLatticeTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpDistributiveLatticeTerm2 n A) -> ((OpDistributiveLatticeTerm2 n A) -> (OpDistributiveLatticeTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpDistributiveLatticeTerm2 n A) -> ((OpDistributiveLatticeTerm2 n A) -> (OpDistributiveLatticeTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpDistributiveLatticeTerm2 n A) -> (Staged (OpDistributiveLatticeTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module DoubleMonoid  where
    record DoubleMonoid (A : Set) : Set where
      constructor DoubleMonoidC
      field
        0 : A
        + : (A -> (A -> A))
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        1 : A
        * : (A -> (A -> A))
        lunit_1 : {x : A} -> (* 1 x) == x
        runit_1 : {x : A} -> (* x 1) == x
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        0S : AS
        +S : (AS -> (AS -> AS))
        1S : AS
        *S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        0P : (Prod A A)
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        1P : (Prod A A)
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        lunit_1P : {xP : (Prod A A)} -> (*P 1P xP) == xP
        runit_1P : {xP : (Prod A A)} -> (*P xP 1P) == xP
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
    record Hom {A1 : Set} {A2 : Set} (Do1 : (DoubleMonoid A1)) (Do2 : (DoubleMonoid A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-0 : (hom (0 Do1)) == (0 Do2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Do1) x1 x2)) == ((+ Do2) (hom x1) (hom x2))
        pres-1 : (hom (1 Do1)) == (1 Do2)
        pres-* : {x1 x2 : A1} -> (hom ((* Do1) x1 x2)) == ((* Do2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Do1 : (DoubleMonoid A1)) (Do2 : (DoubleMonoid A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-0 : (interp (0 Do1) (0 Do2))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Do1) x1 x2) ((+ Do2) y1 y2))))
        interp-1 : (interp (1 Do1) (1 Do2))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Do1) x1 x2) ((* Do2) y1 y2))))
    data DoubleMonoidTerm  : Set where
      0L : DoubleMonoidTerm
      +L : (DoubleMonoidTerm -> (DoubleMonoidTerm -> DoubleMonoidTerm))
      1L : DoubleMonoidTerm
      *L : (DoubleMonoidTerm -> (DoubleMonoidTerm -> DoubleMonoidTerm))
    data ClDoubleMonoidTerm (A : Set) : Set where
      sing : (A -> (ClDoubleMonoidTerm A))
      0Cl : (ClDoubleMonoidTerm A)
      +Cl : ((ClDoubleMonoidTerm A) -> ((ClDoubleMonoidTerm A) -> (ClDoubleMonoidTerm A)))
      1Cl : (ClDoubleMonoidTerm A)
      *Cl : ((ClDoubleMonoidTerm A) -> ((ClDoubleMonoidTerm A) -> (ClDoubleMonoidTerm A)))
    data OpDoubleMonoidTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpDoubleMonoidTerm n))
      0OL : (OpDoubleMonoidTerm n)
      +OL : ((OpDoubleMonoidTerm n) -> ((OpDoubleMonoidTerm n) -> (OpDoubleMonoidTerm n)))
      1OL : (OpDoubleMonoidTerm n)
      *OL : ((OpDoubleMonoidTerm n) -> ((OpDoubleMonoidTerm n) -> (OpDoubleMonoidTerm n)))
    data OpDoubleMonoidTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpDoubleMonoidTerm2 n A))
      sing2 : (A -> (OpDoubleMonoidTerm2 n A))
      0OL2 : (OpDoubleMonoidTerm2 n A)
      +OL2 : ((OpDoubleMonoidTerm2 n A) -> ((OpDoubleMonoidTerm2 n A) -> (OpDoubleMonoidTerm2 n A)))
      1OL2 : (OpDoubleMonoidTerm2 n A)
      *OL2 : ((OpDoubleMonoidTerm2 n A) -> ((OpDoubleMonoidTerm2 n A) -> (OpDoubleMonoidTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClDoubleMonoidTerm A) -> (ClDoubleMonoidTerm A))
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl (*Cl 1Cl x) = x 
    simplifyCl (*Cl x 1Cl) = x 
    simplifyCl 0Cl = 0Cl 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpDoubleMonoidTerm n) -> (OpDoubleMonoidTerm n))
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB (*OL 1OL x) = x 
    simplifyOpB (*OL x 1OL) = x 
    simplifyOpB 0OL = 0OL 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpDoubleMonoidTerm2 n A) -> (OpDoubleMonoidTerm2 n A))
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp (*OL2 1OL2 x) = x 
    simplifyOp (*OL2 x 1OL2) = x 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((DoubleMonoid A) -> (DoubleMonoidTerm -> A))
    evalB Do 0L = (0 Do) 
    evalB Do (+L x1 x2) = ((+ Do) (evalB Do x1) (evalB Do x2)) 
    evalB Do 1L = (1 Do) 
    evalB Do (*L x1 x2) = ((* Do) (evalB Do x1) (evalB Do x2)) 
    evalCl : {A : Set} -> ((DoubleMonoid A) -> ((ClDoubleMonoidTerm A) -> A))
    evalCl Do (sing x1) = x1 
    evalCl Do 0Cl = (0 Do) 
    evalCl Do (+Cl x1 x2) = ((+ Do) (evalCl Do x1) (evalCl Do x2)) 
    evalCl Do 1Cl = (1 Do) 
    evalCl Do (*Cl x1 x2) = ((* Do) (evalCl Do x1) (evalCl Do x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((DoubleMonoid A) -> ((Vec A n) -> ((OpDoubleMonoidTerm n) -> A)))
    evalOpB Do vars (v x1) = (lookup _ x1 vars) 
    evalOpB Do vars 0OL = (0 Do) 
    evalOpB Do vars (+OL x1 x2) = ((+ Do) (evalOpB Do vars x1) (evalOpB Do vars x2)) 
    evalOpB Do vars 1OL = (1 Do) 
    evalOpB Do vars (*OL x1 x2) = ((* Do) (evalOpB Do vars x1) (evalOpB Do vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((DoubleMonoid A) -> ((Vec A n) -> ((OpDoubleMonoidTerm2 n A) -> A)))
    evalOp Do vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Do vars (sing2 x1) = x1 
    evalOp Do vars 0OL2 = (0 Do) 
    evalOp Do vars (+OL2 x1 x2) = ((+ Do) (evalOp Do vars x1) (evalOp Do vars x2)) 
    evalOp Do vars 1OL2 = (1 Do) 
    evalOp Do vars (*OL2 x1 x2) = ((* Do) (evalOp Do vars x1) (evalOp Do vars x2)) 
    inductionB : {P : (DoubleMonoidTerm -> Set)} -> ((P 0L) -> (((x1 x2 : DoubleMonoidTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((P 1L) -> (((x1 x2 : DoubleMonoidTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((x : DoubleMonoidTerm) -> (P x))))))
    inductionB {p} p0l p+l p1l p*l 0L = p0l 
    inductionB {p} p0l p+l p1l p*l (+L x1 x2) = (p+l _ _ (inductionB {p} p0l p+l p1l p*l x1) (inductionB {p} p0l p+l p1l p*l x2)) 
    inductionB {p} p0l p+l p1l p*l 1L = p1l 
    inductionB {p} p0l p+l p1l p*l (*L x1 x2) = (p*l _ _ (inductionB {p} p0l p+l p1l p*l x1) (inductionB {p} p0l p+l p1l p*l x2)) 
    inductionCl : {A : Set} {P : ((ClDoubleMonoidTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 0Cl) -> (((x1 x2 : (ClDoubleMonoidTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((P 1Cl) -> (((x1 x2 : (ClDoubleMonoidTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((x : (ClDoubleMonoidTerm A)) -> (P x)))))))
    inductionCl {_} {p} psing p0cl p+cl p1cl p*cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p0cl p+cl p1cl p*cl 0Cl = p0cl 
    inductionCl {_} {p} psing p0cl p+cl p1cl p*cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p0cl p+cl p1cl p*cl x1) (inductionCl {_} {p} psing p0cl p+cl p1cl p*cl x2)) 
    inductionCl {_} {p} psing p0cl p+cl p1cl p*cl 1Cl = p1cl 
    inductionCl {_} {p} psing p0cl p+cl p1cl p*cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p0cl p+cl p1cl p*cl x1) (inductionCl {_} {p} psing p0cl p+cl p1cl p*cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpDoubleMonoidTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 0OL) -> (((x1 x2 : (OpDoubleMonoidTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((P 1OL) -> (((x1 x2 : (OpDoubleMonoidTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((x : (OpDoubleMonoidTerm n)) -> (P x)))))))
    inductionOpB {_} {p} pv p0ol p+ol p1ol p*ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p0ol p+ol p1ol p*ol 0OL = p0ol 
    inductionOpB {_} {p} pv p0ol p+ol p1ol p*ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p0ol p+ol p1ol p*ol x1) (inductionOpB {_} {p} pv p0ol p+ol p1ol p*ol x2)) 
    inductionOpB {_} {p} pv p0ol p+ol p1ol p*ol 1OL = p1ol 
    inductionOpB {_} {p} pv p0ol p+ol p1ol p*ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p0ol p+ol p1ol p*ol x1) (inductionOpB {_} {p} pv p0ol p+ol p1ol p*ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpDoubleMonoidTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 0OL2) -> (((x1 x2 : (OpDoubleMonoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((P 1OL2) -> (((x1 x2 : (OpDoubleMonoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((x : (OpDoubleMonoidTerm2 n A)) -> (P x))))))))
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p1ol2 p*ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p1ol2 p*ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p1ol2 p*ol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p1ol2 p*ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p1ol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p1ol2 p*ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p1ol2 p*ol2 1OL2 = p1ol2 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p1ol2 p*ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p1ol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p1ol2 p*ol2 x2)) 
    0L' : DoubleMonoidTerm
    0L'  = 0L 
    +L' : (DoubleMonoidTerm -> (DoubleMonoidTerm -> DoubleMonoidTerm))
    +L' x1 x2 = (+L x1 x2) 
    1L' : DoubleMonoidTerm
    1L'  = 1L 
    *L' : (DoubleMonoidTerm -> (DoubleMonoidTerm -> DoubleMonoidTerm))
    *L' x1 x2 = (*L x1 x2) 
    stageB : (DoubleMonoidTerm -> (Staged DoubleMonoidTerm))
    stageB 0L = (Now 0L) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB 1L = (Now 1L) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    0Cl' : {A : Set} -> (ClDoubleMonoidTerm A)
    0Cl'  = 0Cl 
    +Cl' : {A : Set} -> ((ClDoubleMonoidTerm A) -> ((ClDoubleMonoidTerm A) -> (ClDoubleMonoidTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    1Cl' : {A : Set} -> (ClDoubleMonoidTerm A)
    1Cl'  = 1Cl 
    *Cl' : {A : Set} -> ((ClDoubleMonoidTerm A) -> ((ClDoubleMonoidTerm A) -> (ClDoubleMonoidTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    stageCl : {A : Set} -> ((ClDoubleMonoidTerm A) -> (Staged (ClDoubleMonoidTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl 1Cl = (Now 1Cl) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    0OL' : {n : Nat} -> (OpDoubleMonoidTerm n)
    0OL'  = 0OL 
    +OL' : {n : Nat} -> ((OpDoubleMonoidTerm n) -> ((OpDoubleMonoidTerm n) -> (OpDoubleMonoidTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    1OL' : {n : Nat} -> (OpDoubleMonoidTerm n)
    1OL'  = 1OL 
    *OL' : {n : Nat} -> ((OpDoubleMonoidTerm n) -> ((OpDoubleMonoidTerm n) -> (OpDoubleMonoidTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpDoubleMonoidTerm n) -> (Staged (OpDoubleMonoidTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 1OL = (Now 1OL) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    0OL2' : {n : Nat} {A : Set} -> (OpDoubleMonoidTerm2 n A)
    0OL2'  = 0OL2 
    +OL2' : {n : Nat} {A : Set} -> ((OpDoubleMonoidTerm2 n A) -> ((OpDoubleMonoidTerm2 n A) -> (OpDoubleMonoidTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    1OL2' : {n : Nat} {A : Set} -> (OpDoubleMonoidTerm2 n A)
    1OL2'  = 1OL2 
    *OL2' : {n : Nat} {A : Set} -> ((OpDoubleMonoidTerm2 n A) -> ((OpDoubleMonoidTerm2 n A) -> (OpDoubleMonoidTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpDoubleMonoidTerm2 n A) -> (Staged (OpDoubleMonoidTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp 1OL2 = (Now 1OL2) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        0T : (Repr A)
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        1T : (Repr A)
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module DualDeMorgan  where
    record DualDeMorgan (A : Set) : Set where
      constructor DualDeMorganC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        prim : (A -> A)
        andDeMorgan_*_+_prim : {x y z : A} -> (prim (* x y)) == (+ (prim x) (prim y))
        orDeMorgan_+_*_prim : {x y z : A} -> (prim (+ x y)) == (* (prim x) (prim y))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
        primS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        primP : ((Prod A A) -> (Prod A A))
        andDeMorgan_*_+_primP : {xP yP zP : (Prod A A)} -> (primP (*P xP yP)) == (+P (primP xP) (primP yP))
        orDeMorgan_+_*_primP : {xP yP zP : (Prod A A)} -> (primP (+P xP yP)) == (*P (primP xP) (primP yP))
    record Hom {A1 : Set} {A2 : Set} (Du1 : (DualDeMorgan A1)) (Du2 : (DualDeMorgan A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Du1) x1 x2)) == ((* Du2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Du1) x1 x2)) == ((+ Du2) (hom x1) (hom x2))
        pres-prim : {x1 : A1} -> (hom ((prim Du1) x1)) == ((prim Du2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (Du1 : (DualDeMorgan A1)) (Du2 : (DualDeMorgan A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Du1) x1 x2) ((* Du2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Du1) x1 x2) ((+ Du2) y1 y2))))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim Du1) x1) ((prim Du2) y1)))
    data DualDeMorganTerm  : Set where
      *L : (DualDeMorganTerm -> (DualDeMorganTerm -> DualDeMorganTerm))
      +L : (DualDeMorganTerm -> (DualDeMorganTerm -> DualDeMorganTerm))
      primL : (DualDeMorganTerm -> DualDeMorganTerm)
    data ClDualDeMorganTerm (A : Set) : Set where
      sing : (A -> (ClDualDeMorganTerm A))
      *Cl : ((ClDualDeMorganTerm A) -> ((ClDualDeMorganTerm A) -> (ClDualDeMorganTerm A)))
      +Cl : ((ClDualDeMorganTerm A) -> ((ClDualDeMorganTerm A) -> (ClDualDeMorganTerm A)))
      primCl : ((ClDualDeMorganTerm A) -> (ClDualDeMorganTerm A))
    data OpDualDeMorganTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpDualDeMorganTerm n))
      *OL : ((OpDualDeMorganTerm n) -> ((OpDualDeMorganTerm n) -> (OpDualDeMorganTerm n)))
      +OL : ((OpDualDeMorganTerm n) -> ((OpDualDeMorganTerm n) -> (OpDualDeMorganTerm n)))
      primOL : ((OpDualDeMorganTerm n) -> (OpDualDeMorganTerm n))
    data OpDualDeMorganTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpDualDeMorganTerm2 n A))
      sing2 : (A -> (OpDualDeMorganTerm2 n A))
      *OL2 : ((OpDualDeMorganTerm2 n A) -> ((OpDualDeMorganTerm2 n A) -> (OpDualDeMorganTerm2 n A)))
      +OL2 : ((OpDualDeMorganTerm2 n A) -> ((OpDualDeMorganTerm2 n A) -> (OpDualDeMorganTerm2 n A)))
      primOL2 : ((OpDualDeMorganTerm2 n A) -> (OpDualDeMorganTerm2 n A))
    simplifyCl : {A : Set} -> ((ClDualDeMorganTerm A) -> (ClDualDeMorganTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpDualDeMorganTerm n) -> (OpDualDeMorganTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpDualDeMorganTerm2 n A) -> (OpDualDeMorganTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((DualDeMorgan A) -> (DualDeMorganTerm -> A))
    evalB Du (*L x1 x2) = ((* Du) (evalB Du x1) (evalB Du x2)) 
    evalB Du (+L x1 x2) = ((+ Du) (evalB Du x1) (evalB Du x2)) 
    evalB Du (primL x1) = ((prim Du) (evalB Du x1)) 
    evalCl : {A : Set} -> ((DualDeMorgan A) -> ((ClDualDeMorganTerm A) -> A))
    evalCl Du (sing x1) = x1 
    evalCl Du (*Cl x1 x2) = ((* Du) (evalCl Du x1) (evalCl Du x2)) 
    evalCl Du (+Cl x1 x2) = ((+ Du) (evalCl Du x1) (evalCl Du x2)) 
    evalCl Du (primCl x1) = ((prim Du) (evalCl Du x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((DualDeMorgan A) -> ((Vec A n) -> ((OpDualDeMorganTerm n) -> A)))
    evalOpB Du vars (v x1) = (lookup _ x1 vars) 
    evalOpB Du vars (*OL x1 x2) = ((* Du) (evalOpB Du vars x1) (evalOpB Du vars x2)) 
    evalOpB Du vars (+OL x1 x2) = ((+ Du) (evalOpB Du vars x1) (evalOpB Du vars x2)) 
    evalOpB Du vars (primOL x1) = ((prim Du) (evalOpB Du vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((DualDeMorgan A) -> ((Vec A n) -> ((OpDualDeMorganTerm2 n A) -> A)))
    evalOp Du vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Du vars (sing2 x1) = x1 
    evalOp Du vars (*OL2 x1 x2) = ((* Du) (evalOp Du vars x1) (evalOp Du vars x2)) 
    evalOp Du vars (+OL2 x1 x2) = ((+ Du) (evalOp Du vars x1) (evalOp Du vars x2)) 
    evalOp Du vars (primOL2 x1) = ((prim Du) (evalOp Du vars x1)) 
    inductionB : {P : (DualDeMorganTerm -> Set)} -> (((x1 x2 : DualDeMorganTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : DualDeMorganTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> (((x1 : DualDeMorganTerm) -> ((P x1) -> (P (primL x1)))) -> ((x : DualDeMorganTerm) -> (P x)))))
    inductionB {p} p*l p+l ppriml (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l ppriml x1) (inductionB {p} p*l p+l ppriml x2)) 
    inductionB {p} p*l p+l ppriml (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l ppriml x1) (inductionB {p} p*l p+l ppriml x2)) 
    inductionB {p} p*l p+l ppriml (primL x1) = (ppriml _ (inductionB {p} p*l p+l ppriml x1)) 
    inductionCl : {A : Set} {P : ((ClDualDeMorganTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClDualDeMorganTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClDualDeMorganTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> (((x1 : (ClDualDeMorganTerm A)) -> ((P x1) -> (P (primCl x1)))) -> ((x : (ClDualDeMorganTerm A)) -> (P x))))))
    inductionCl {_} {p} psing p*cl p+cl pprimcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl pprimcl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl pprimcl x1) (inductionCl {_} {p} psing p*cl p+cl pprimcl x2)) 
    inductionCl {_} {p} psing p*cl p+cl pprimcl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl pprimcl x1) (inductionCl {_} {p} psing p*cl p+cl pprimcl x2)) 
    inductionCl {_} {p} psing p*cl p+cl pprimcl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing p*cl p+cl pprimcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpDualDeMorganTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpDualDeMorganTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpDualDeMorganTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> (((x1 : (OpDualDeMorganTerm n)) -> ((P x1) -> (P (primOL x1)))) -> ((x : (OpDualDeMorganTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv p*ol p+ol pprimol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol pprimol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol pprimol x1) (inductionOpB {_} {p} pv p*ol p+ol pprimol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol pprimol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol pprimol x1) (inductionOpB {_} {p} pv p*ol p+ol pprimol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol pprimol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv p*ol p+ol pprimol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpDualDeMorganTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpDualDeMorganTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpDualDeMorganTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> (((x1 : (OpDualDeMorganTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> ((x : (OpDualDeMorganTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x1)) 
    *L' : (DualDeMorganTerm -> (DualDeMorganTerm -> DualDeMorganTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (DualDeMorganTerm -> (DualDeMorganTerm -> DualDeMorganTerm))
    +L' x1 x2 = (+L x1 x2) 
    primL' : (DualDeMorganTerm -> DualDeMorganTerm)
    primL' x1 = (primL x1) 
    stageB : (DualDeMorganTerm -> (Staged DualDeMorganTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    *Cl' : {A : Set} -> ((ClDualDeMorganTerm A) -> ((ClDualDeMorganTerm A) -> (ClDualDeMorganTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClDualDeMorganTerm A) -> ((ClDualDeMorganTerm A) -> (ClDualDeMorganTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    primCl' : {A : Set} -> ((ClDualDeMorganTerm A) -> (ClDualDeMorganTerm A))
    primCl' x1 = (primCl x1) 
    stageCl : {A : Set} -> ((ClDualDeMorganTerm A) -> (Staged (ClDualDeMorganTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    *OL' : {n : Nat} -> ((OpDualDeMorganTerm n) -> ((OpDualDeMorganTerm n) -> (OpDualDeMorganTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpDualDeMorganTerm n) -> ((OpDualDeMorganTerm n) -> (OpDualDeMorganTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    primOL' : {n : Nat} -> ((OpDualDeMorganTerm n) -> (OpDualDeMorganTerm n))
    primOL' x1 = (primOL x1) 
    stageOpB : {n : Nat} -> ((OpDualDeMorganTerm n) -> (Staged (OpDualDeMorganTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpDualDeMorganTerm2 n A) -> ((OpDualDeMorganTerm2 n A) -> (OpDualDeMorganTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpDualDeMorganTerm2 n A) -> ((OpDualDeMorganTerm2 n A) -> (OpDualDeMorganTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    primOL2' : {n : Nat} {A : Set} -> ((OpDualDeMorganTerm2 n A) -> (OpDualDeMorganTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpDualDeMorganTerm2 n A) -> (Staged (OpDualDeMorganTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        primT : ((Repr A) -> (Repr A))
  module DualSemilattices  where
    record DualSemilattices (A : Set) : Set where
      constructor DualSemilatticesC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        commutative_* : {x y : A} -> (* x y) == (* y x)
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        idempotent_* : {x : A} -> (* x x) == x
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        idempotent_+ : {x : A} -> (+ x x) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        commutative_*P : {xP yP : (Prod A A)} -> (*P xP yP) == (*P yP xP)
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        idempotent_*P : {xP : (Prod A A)} -> (*P xP xP) == xP
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        idempotent_+P : {xP : (Prod A A)} -> (+P xP xP) == xP
    record Hom {A1 : Set} {A2 : Set} (Du1 : (DualSemilattices A1)) (Du2 : (DualSemilattices A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Du1) x1 x2)) == ((* Du2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Du1) x1 x2)) == ((+ Du2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Du1 : (DualSemilattices A1)) (Du2 : (DualSemilattices A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Du1) x1 x2) ((* Du2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Du1) x1 x2) ((+ Du2) y1 y2))))
    data DualSemilatticesTerm  : Set where
      *L : (DualSemilatticesTerm -> (DualSemilatticesTerm -> DualSemilatticesTerm))
      +L : (DualSemilatticesTerm -> (DualSemilatticesTerm -> DualSemilatticesTerm))
    data ClDualSemilatticesTerm (A : Set) : Set where
      sing : (A -> (ClDualSemilatticesTerm A))
      *Cl : ((ClDualSemilatticesTerm A) -> ((ClDualSemilatticesTerm A) -> (ClDualSemilatticesTerm A)))
      +Cl : ((ClDualSemilatticesTerm A) -> ((ClDualSemilatticesTerm A) -> (ClDualSemilatticesTerm A)))
    data OpDualSemilatticesTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpDualSemilatticesTerm n))
      *OL : ((OpDualSemilatticesTerm n) -> ((OpDualSemilatticesTerm n) -> (OpDualSemilatticesTerm n)))
      +OL : ((OpDualSemilatticesTerm n) -> ((OpDualSemilatticesTerm n) -> (OpDualSemilatticesTerm n)))
    data OpDualSemilatticesTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpDualSemilatticesTerm2 n A))
      sing2 : (A -> (OpDualSemilatticesTerm2 n A))
      *OL2 : ((OpDualSemilatticesTerm2 n A) -> ((OpDualSemilatticesTerm2 n A) -> (OpDualSemilatticesTerm2 n A)))
      +OL2 : ((OpDualSemilatticesTerm2 n A) -> ((OpDualSemilatticesTerm2 n A) -> (OpDualSemilatticesTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClDualSemilatticesTerm A) -> (ClDualSemilatticesTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpDualSemilatticesTerm n) -> (OpDualSemilatticesTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpDualSemilatticesTerm2 n A) -> (OpDualSemilatticesTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((DualSemilattices A) -> (DualSemilatticesTerm -> A))
    evalB Du (*L x1 x2) = ((* Du) (evalB Du x1) (evalB Du x2)) 
    evalB Du (+L x1 x2) = ((+ Du) (evalB Du x1) (evalB Du x2)) 
    evalCl : {A : Set} -> ((DualSemilattices A) -> ((ClDualSemilatticesTerm A) -> A))
    evalCl Du (sing x1) = x1 
    evalCl Du (*Cl x1 x2) = ((* Du) (evalCl Du x1) (evalCl Du x2)) 
    evalCl Du (+Cl x1 x2) = ((+ Du) (evalCl Du x1) (evalCl Du x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((DualSemilattices A) -> ((Vec A n) -> ((OpDualSemilatticesTerm n) -> A)))
    evalOpB Du vars (v x1) = (lookup _ x1 vars) 
    evalOpB Du vars (*OL x1 x2) = ((* Du) (evalOpB Du vars x1) (evalOpB Du vars x2)) 
    evalOpB Du vars (+OL x1 x2) = ((+ Du) (evalOpB Du vars x1) (evalOpB Du vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((DualSemilattices A) -> ((Vec A n) -> ((OpDualSemilatticesTerm2 n A) -> A)))
    evalOp Du vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Du vars (sing2 x1) = x1 
    evalOp Du vars (*OL2 x1 x2) = ((* Du) (evalOp Du vars x1) (evalOp Du vars x2)) 
    evalOp Du vars (+OL2 x1 x2) = ((+ Du) (evalOp Du vars x1) (evalOp Du vars x2)) 
    inductionB : {P : (DualSemilatticesTerm -> Set)} -> (((x1 x2 : DualSemilatticesTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : DualSemilatticesTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : DualSemilatticesTerm) -> (P x))))
    inductionB {p} p*l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionB {p} p*l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClDualSemilatticesTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClDualSemilatticesTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClDualSemilatticesTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClDualSemilatticesTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p*cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpDualSemilatticesTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpDualSemilatticesTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpDualSemilatticesTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpDualSemilatticesTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p*ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpDualSemilatticesTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpDualSemilatticesTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpDualSemilatticesTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpDualSemilatticesTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    *L' : (DualSemilatticesTerm -> (DualSemilatticesTerm -> DualSemilatticesTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (DualSemilatticesTerm -> (DualSemilatticesTerm -> DualSemilatticesTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (DualSemilatticesTerm -> (Staged DualSemilatticesTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClDualSemilatticesTerm A) -> ((ClDualSemilatticesTerm A) -> (ClDualSemilatticesTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClDualSemilatticesTerm A) -> ((ClDualSemilatticesTerm A) -> (ClDualSemilatticesTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClDualSemilatticesTerm A) -> (Staged (ClDualSemilatticesTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpDualSemilatticesTerm n) -> ((OpDualSemilatticesTerm n) -> (OpDualSemilatticesTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpDualSemilatticesTerm n) -> ((OpDualSemilatticesTerm n) -> (OpDualSemilatticesTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpDualSemilatticesTerm n) -> (Staged (OpDualSemilatticesTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpDualSemilatticesTerm2 n A) -> ((OpDualSemilatticesTerm2 n A) -> (OpDualSemilatticesTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpDualSemilatticesTerm2 n A) -> ((OpDualSemilatticesTerm2 n A) -> (OpDualSemilatticesTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpDualSemilatticesTerm2 n A) -> (Staged (OpDualSemilatticesTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module Empty  where
    record Empty  : Set where
      constructor EmptyC
      field
        
  module FixedPoint  where
    record FixedPoint (A : Set) : Set where
      constructor FixedPointC
      field
        prim : (A -> A)
        e : A
        fixes_prim_e : (prim e) == e
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        primS : (AS -> AS)
        eS : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        primP : ((Prod A A) -> (Prod A A))
        eP : (Prod A A)
        fixes_prim_eP : (primP eP) == eP
    record Hom {A1 : Set} {A2 : Set} (Fi1 : (FixedPoint A1)) (Fi2 : (FixedPoint A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-prim : {x1 : A1} -> (hom ((prim Fi1) x1)) == ((prim Fi2) (hom x1))
        pres-e : (hom (e Fi1)) == (e Fi2)
    record RelInterp {A1 : Set} {A2 : Set} (Fi1 : (FixedPoint A1)) (Fi2 : (FixedPoint A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim Fi1) x1) ((prim Fi2) y1)))
        interp-e : (interp (e Fi1) (e Fi2))
    data FixedPointTerm  : Set where
      primL : (FixedPointTerm -> FixedPointTerm)
      eL : FixedPointTerm
    data ClFixedPointTerm (A : Set) : Set where
      sing : (A -> (ClFixedPointTerm A))
      primCl : ((ClFixedPointTerm A) -> (ClFixedPointTerm A))
      eCl : (ClFixedPointTerm A)
    data OpFixedPointTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpFixedPointTerm n))
      primOL : ((OpFixedPointTerm n) -> (OpFixedPointTerm n))
      eOL : (OpFixedPointTerm n)
    data OpFixedPointTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpFixedPointTerm2 n A))
      sing2 : (A -> (OpFixedPointTerm2 n A))
      primOL2 : ((OpFixedPointTerm2 n A) -> (OpFixedPointTerm2 n A))
      eOL2 : (OpFixedPointTerm2 n A)
    simplifyCl : {A : Set} -> ((ClFixedPointTerm A) -> (ClFixedPointTerm A))
    simplifyCl (primCl eCl) = eCl 
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl eCl = eCl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpFixedPointTerm n) -> (OpFixedPointTerm n))
    simplifyOpB (primOL eOL) = eOL 
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB eOL = eOL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpFixedPointTerm2 n A) -> (OpFixedPointTerm2 n A))
    simplifyOp (primOL2 eOL2) = eOL2 
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp eOL2 = eOL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((FixedPoint A) -> (FixedPointTerm -> A))
    evalB Fi (primL x1) = ((prim Fi) (evalB Fi x1)) 
    evalB Fi eL = (e Fi) 
    evalCl : {A : Set} -> ((FixedPoint A) -> ((ClFixedPointTerm A) -> A))
    evalCl Fi (sing x1) = x1 
    evalCl Fi (primCl x1) = ((prim Fi) (evalCl Fi x1)) 
    evalCl Fi eCl = (e Fi) 
    evalOpB : {A : Set} {n : Nat} -> ((FixedPoint A) -> ((Vec A n) -> ((OpFixedPointTerm n) -> A)))
    evalOpB Fi vars (v x1) = (lookup _ x1 vars) 
    evalOpB Fi vars (primOL x1) = ((prim Fi) (evalOpB Fi vars x1)) 
    evalOpB Fi vars eOL = (e Fi) 
    evalOp : {A : Set} {n : Nat} -> ((FixedPoint A) -> ((Vec A n) -> ((OpFixedPointTerm2 n A) -> A)))
    evalOp Fi vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Fi vars (sing2 x1) = x1 
    evalOp Fi vars (primOL2 x1) = ((prim Fi) (evalOp Fi vars x1)) 
    evalOp Fi vars eOL2 = (e Fi) 
    inductionB : {P : (FixedPointTerm -> Set)} -> (((x1 : FixedPointTerm) -> ((P x1) -> (P (primL x1)))) -> ((P eL) -> ((x : FixedPointTerm) -> (P x))))
    inductionB {p} ppriml pel (primL x1) = (ppriml _ (inductionB {p} ppriml pel x1)) 
    inductionB {p} ppriml pel eL = pel 
    inductionCl : {A : Set} {P : ((ClFixedPointTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 : (ClFixedPointTerm A)) -> ((P x1) -> (P (primCl x1)))) -> ((P eCl) -> ((x : (ClFixedPointTerm A)) -> (P x)))))
    inductionCl {_} {p} psing pprimcl pecl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pprimcl pecl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing pprimcl pecl x1)) 
    inductionCl {_} {p} psing pprimcl pecl eCl = pecl 
    inductionOpB : {n : Nat} {P : ((OpFixedPointTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 : (OpFixedPointTerm n)) -> ((P x1) -> (P (primOL x1)))) -> ((P eOL) -> ((x : (OpFixedPointTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv pprimol peol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pprimol peol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv pprimol peol x1)) 
    inductionOpB {_} {p} pv pprimol peol eOL = peol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpFixedPointTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 : (OpFixedPointTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> ((P eOL2) -> ((x : (OpFixedPointTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 peol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 peol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 peol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 pprimol2 peol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 peol2 eOL2 = peol2 
    primL' : (FixedPointTerm -> FixedPointTerm)
    primL' x1 = (primL x1) 
    eL' : FixedPointTerm
    eL'  = eL 
    stageB : (FixedPointTerm -> (Staged FixedPointTerm))
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    stageB eL = (Now eL) 
    primCl' : {A : Set} -> ((ClFixedPointTerm A) -> (ClFixedPointTerm A))
    primCl' x1 = (primCl x1) 
    eCl' : {A : Set} -> (ClFixedPointTerm A)
    eCl'  = eCl 
    stageCl : {A : Set} -> ((ClFixedPointTerm A) -> (Staged (ClFixedPointTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    stageCl eCl = (Now eCl) 
    primOL' : {n : Nat} -> ((OpFixedPointTerm n) -> (OpFixedPointTerm n))
    primOL' x1 = (primOL x1) 
    eOL' : {n : Nat} -> (OpFixedPointTerm n)
    eOL'  = eOL 
    stageOpB : {n : Nat} -> ((OpFixedPointTerm n) -> (Staged (OpFixedPointTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    stageOpB eOL = (Now eOL) 
    primOL2' : {n : Nat} {A : Set} -> ((OpFixedPointTerm2 n A) -> (OpFixedPointTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    eOL2' : {n : Nat} {A : Set} -> (OpFixedPointTerm2 n A)
    eOL2'  = eOL2 
    stageOp : {n : Nat} {A : Set} -> ((OpFixedPointTerm2 n A) -> (Staged (OpFixedPointTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    stageOp eOL2 = (Now eOL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        primT : ((Repr A) -> (Repr A))
        eT : (Repr A)
  module Group  where
    record Group (A : Set) : Set where
      constructor GroupC
      field
        e : A
        op : (A -> (A -> A))
        lunit_e : {x : A} -> (op e x) == x
        runit_e : {x : A} -> (op x e) == x
        associative_op : {x y z : A} -> (op (op x y) z) == (op x (op y z))
        inv : (A -> A)
        leftInverse_inv_op_e : {x : A} -> (op x (inv x)) == e
        rightInverse_inv_op_e : {x : A} -> (op (inv x) x) == e
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        eS : AS
        opS : (AS -> (AS -> AS))
        invS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        eP : (Prod A A)
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        invP : ((Prod A A) -> (Prod A A))
        lunit_eP : {xP : (Prod A A)} -> (opP eP xP) == xP
        runit_eP : {xP : (Prod A A)} -> (opP xP eP) == xP
        associative_opP : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP (opP yP zP))
        leftInverse_inv_op_eP : {xP : (Prod A A)} -> (opP xP (invP xP)) == eP
        rightInverse_inv_op_eP : {xP : (Prod A A)} -> (opP (invP xP) xP) == eP
    record Hom {A1 : Set} {A2 : Set} (Gr1 : (Group A1)) (Gr2 : (Group A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-e : (hom (e Gr1)) == (e Gr2)
        pres-op : {x1 x2 : A1} -> (hom ((op Gr1) x1 x2)) == ((op Gr2) (hom x1) (hom x2))
        pres-inv : {x1 : A1} -> (hom ((inv Gr1) x1)) == ((inv Gr2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (Gr1 : (Group A1)) (Gr2 : (Group A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-e : (interp (e Gr1) (e Gr2))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Gr1) x1 x2) ((op Gr2) y1 y2))))
        interp-inv : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((inv Gr1) x1) ((inv Gr2) y1)))
    data GroupTerm  : Set where
      eL : GroupTerm
      opL : (GroupTerm -> (GroupTerm -> GroupTerm))
      invL : (GroupTerm -> GroupTerm)
    data ClGroupTerm (A : Set) : Set where
      sing : (A -> (ClGroupTerm A))
      eCl : (ClGroupTerm A)
      opCl : ((ClGroupTerm A) -> ((ClGroupTerm A) -> (ClGroupTerm A)))
      invCl : ((ClGroupTerm A) -> (ClGroupTerm A))
    data OpGroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpGroupTerm n))
      eOL : (OpGroupTerm n)
      opOL : ((OpGroupTerm n) -> ((OpGroupTerm n) -> (OpGroupTerm n)))
      invOL : ((OpGroupTerm n) -> (OpGroupTerm n))
    data OpGroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpGroupTerm2 n A))
      sing2 : (A -> (OpGroupTerm2 n A))
      eOL2 : (OpGroupTerm2 n A)
      opOL2 : ((OpGroupTerm2 n A) -> ((OpGroupTerm2 n A) -> (OpGroupTerm2 n A)))
      invOL2 : ((OpGroupTerm2 n A) -> (OpGroupTerm2 n A))
    simplifyCl : {A : Set} -> ((ClGroupTerm A) -> (ClGroupTerm A))
    simplifyCl (opCl eCl x) = x 
    simplifyCl (opCl x eCl) = x 
    simplifyCl eCl = eCl 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (invCl x1) = (invCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpGroupTerm n) -> (OpGroupTerm n))
    simplifyOpB (opOL eOL x) = x 
    simplifyOpB (opOL x eOL) = x 
    simplifyOpB eOL = eOL 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (invOL x1) = (invOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpGroupTerm2 n A) -> (OpGroupTerm2 n A))
    simplifyOp (opOL2 eOL2 x) = x 
    simplifyOp (opOL2 x eOL2) = x 
    simplifyOp eOL2 = eOL2 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (invOL2 x1) = (invOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Group A) -> (GroupTerm -> A))
    evalB Gr eL = (e Gr) 
    evalB Gr (opL x1 x2) = ((op Gr) (evalB Gr x1) (evalB Gr x2)) 
    evalB Gr (invL x1) = ((inv Gr) (evalB Gr x1)) 
    evalCl : {A : Set} -> ((Group A) -> ((ClGroupTerm A) -> A))
    evalCl Gr (sing x1) = x1 
    evalCl Gr eCl = (e Gr) 
    evalCl Gr (opCl x1 x2) = ((op Gr) (evalCl Gr x1) (evalCl Gr x2)) 
    evalCl Gr (invCl x1) = ((inv Gr) (evalCl Gr x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((Group A) -> ((Vec A n) -> ((OpGroupTerm n) -> A)))
    evalOpB Gr vars (v x1) = (lookup _ x1 vars) 
    evalOpB Gr vars eOL = (e Gr) 
    evalOpB Gr vars (opOL x1 x2) = ((op Gr) (evalOpB Gr vars x1) (evalOpB Gr vars x2)) 
    evalOpB Gr vars (invOL x1) = ((inv Gr) (evalOpB Gr vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((Group A) -> ((Vec A n) -> ((OpGroupTerm2 n A) -> A)))
    evalOp Gr vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Gr vars (sing2 x1) = x1 
    evalOp Gr vars eOL2 = (e Gr) 
    evalOp Gr vars (opOL2 x1 x2) = ((op Gr) (evalOp Gr vars x1) (evalOp Gr vars x2)) 
    evalOp Gr vars (invOL2 x1) = ((inv Gr) (evalOp Gr vars x1)) 
    inductionB : {P : (GroupTerm -> Set)} -> ((P eL) -> (((x1 x2 : GroupTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> (((x1 : GroupTerm) -> ((P x1) -> (P (invL x1)))) -> ((x : GroupTerm) -> (P x)))))
    inductionB {p} pel popl pinvl eL = pel 
    inductionB {p} pel popl pinvl (opL x1 x2) = (popl _ _ (inductionB {p} pel popl pinvl x1) (inductionB {p} pel popl pinvl x2)) 
    inductionB {p} pel popl pinvl (invL x1) = (pinvl _ (inductionB {p} pel popl pinvl x1)) 
    inductionCl : {A : Set} {P : ((ClGroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P eCl) -> (((x1 x2 : (ClGroupTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> (((x1 : (ClGroupTerm A)) -> ((P x1) -> (P (invCl x1)))) -> ((x : (ClGroupTerm A)) -> (P x))))))
    inductionCl {_} {p} psing pecl popcl pinvcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pecl popcl pinvcl eCl = pecl 
    inductionCl {_} {p} psing pecl popcl pinvcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing pecl popcl pinvcl x1) (inductionCl {_} {p} psing pecl popcl pinvcl x2)) 
    inductionCl {_} {p} psing pecl popcl pinvcl (invCl x1) = (pinvcl _ (inductionCl {_} {p} psing pecl popcl pinvcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpGroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P eOL) -> (((x1 x2 : (OpGroupTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> (((x1 : (OpGroupTerm n)) -> ((P x1) -> (P (invOL x1)))) -> ((x : (OpGroupTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv peol popol pinvol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv peol popol pinvol eOL = peol 
    inductionOpB {_} {p} pv peol popol pinvol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv peol popol pinvol x1) (inductionOpB {_} {p} pv peol popol pinvol x2)) 
    inductionOpB {_} {p} pv peol popol pinvol (invOL x1) = (pinvol _ (inductionOpB {_} {p} pv peol popol pinvol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpGroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P eOL2) -> (((x1 x2 : (OpGroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> (((x1 : (OpGroupTerm2 n A)) -> ((P x1) -> (P (invOL2 x1)))) -> ((x : (OpGroupTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 pinvol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 pinvol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 pinvol2 eOL2 = peol2 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 pinvol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 pinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 pinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 pinvol2 (invOL2 x1) = (pinvol2 _ (inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 pinvol2 x1)) 
    eL' : GroupTerm
    eL'  = eL 
    opL' : (GroupTerm -> (GroupTerm -> GroupTerm))
    opL' x1 x2 = (opL x1 x2) 
    invL' : (GroupTerm -> GroupTerm)
    invL' x1 = (invL x1) 
    stageB : (GroupTerm -> (Staged GroupTerm))
    stageB eL = (Now eL) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB (invL x1) = (stage1 invL' (codeLift1 invL') (stageB x1)) 
    eCl' : {A : Set} -> (ClGroupTerm A)
    eCl'  = eCl 
    opCl' : {A : Set} -> ((ClGroupTerm A) -> ((ClGroupTerm A) -> (ClGroupTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    invCl' : {A : Set} -> ((ClGroupTerm A) -> (ClGroupTerm A))
    invCl' x1 = (invCl x1) 
    stageCl : {A : Set} -> ((ClGroupTerm A) -> (Staged (ClGroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl eCl = (Now eCl) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl (invCl x1) = (stage1 invCl' (codeLift1 invCl') (stageCl x1)) 
    eOL' : {n : Nat} -> (OpGroupTerm n)
    eOL'  = eOL 
    opOL' : {n : Nat} -> ((OpGroupTerm n) -> ((OpGroupTerm n) -> (OpGroupTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    invOL' : {n : Nat} -> ((OpGroupTerm n) -> (OpGroupTerm n))
    invOL' x1 = (invOL x1) 
    stageOpB : {n : Nat} -> ((OpGroupTerm n) -> (Staged (OpGroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB eOL = (Now eOL) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (invOL x1) = (stage1 invOL' (codeLift1 invOL') (stageOpB x1)) 
    eOL2' : {n : Nat} {A : Set} -> (OpGroupTerm2 n A)
    eOL2'  = eOL2 
    opOL2' : {n : Nat} {A : Set} -> ((OpGroupTerm2 n A) -> ((OpGroupTerm2 n A) -> (OpGroupTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    invOL2' : {n : Nat} {A : Set} -> ((OpGroupTerm2 n A) -> (OpGroupTerm2 n A))
    invOL2' x1 = (invOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpGroupTerm2 n A) -> (Staged (OpGroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp eOL2 = (Now eOL2) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp (invOL2 x1) = (stage1 invOL2' (codeLift1 invOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        eT : (Repr A)
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        invT : ((Repr A) -> (Repr A))
  module Group1  where
    record Group1 (A : Set) : Set where
      constructor Group1C
      field
        op : (A -> (A -> A))
        1 : A
        lunit_1 : {x : A} -> (op 1 x) == x
        runit_1 : {x : A} -> (op x 1) == x
        associative_op : {x y z : A} -> (op (op x y) z) == (op x (op y z))
        inv : (A -> A)
        leftInverse_inv_op_1 : {x : A} -> (op x (inv x)) == 1
        rightInverse_inv_op_1 : {x : A} -> (op (inv x) x) == 1
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        1S : AS
        invS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        1P : (Prod A A)
        invP : ((Prod A A) -> (Prod A A))
        lunit_1P : {xP : (Prod A A)} -> (opP 1P xP) == xP
        runit_1P : {xP : (Prod A A)} -> (opP xP 1P) == xP
        associative_opP : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP (opP yP zP))
        leftInverse_inv_op_1P : {xP : (Prod A A)} -> (opP xP (invP xP)) == 1P
        rightInverse_inv_op_1P : {xP : (Prod A A)} -> (opP (invP xP) xP) == 1P
    record Hom {A1 : Set} {A2 : Set} (Gr1 : (Group1 A1)) (Gr2 : (Group1 A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Gr1) x1 x2)) == ((op Gr2) (hom x1) (hom x2))
        pres-1 : (hom (1 Gr1)) == (1 Gr2)
        pres-inv : {x1 : A1} -> (hom ((inv Gr1) x1)) == ((inv Gr2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (Gr1 : (Group1 A1)) (Gr2 : (Group1 A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Gr1) x1 x2) ((op Gr2) y1 y2))))
        interp-1 : (interp (1 Gr1) (1 Gr2))
        interp-inv : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((inv Gr1) x1) ((inv Gr2) y1)))
    data Group1LTerm  : Set where
      opL : (Group1LTerm -> (Group1LTerm -> Group1LTerm))
      1L : Group1LTerm
      invL : (Group1LTerm -> Group1LTerm)
    data ClGroup1ClTerm (A : Set) : Set where
      sing : (A -> (ClGroup1ClTerm A))
      opCl : ((ClGroup1ClTerm A) -> ((ClGroup1ClTerm A) -> (ClGroup1ClTerm A)))
      1Cl : (ClGroup1ClTerm A)
      invCl : ((ClGroup1ClTerm A) -> (ClGroup1ClTerm A))
    data OpGroup1OLTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpGroup1OLTerm n))
      opOL : ((OpGroup1OLTerm n) -> ((OpGroup1OLTerm n) -> (OpGroup1OLTerm n)))
      1OL : (OpGroup1OLTerm n)
      invOL : ((OpGroup1OLTerm n) -> (OpGroup1OLTerm n))
    data OpGroup1OL2Term2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpGroup1OL2Term2 n A))
      sing2 : (A -> (OpGroup1OL2Term2 n A))
      opOL2 : ((OpGroup1OL2Term2 n A) -> ((OpGroup1OL2Term2 n A) -> (OpGroup1OL2Term2 n A)))
      1OL2 : (OpGroup1OL2Term2 n A)
      invOL2 : ((OpGroup1OL2Term2 n A) -> (OpGroup1OL2Term2 n A))
    simplifyCl : {A : Set} -> ((ClGroup1ClTerm A) -> (ClGroup1ClTerm A))
    simplifyCl (opCl 1Cl x) = x 
    simplifyCl (opCl x 1Cl) = x 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (invCl x1) = (invCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpGroup1OLTerm n) -> (OpGroup1OLTerm n))
    simplifyOpB (opOL 1OL x) = x 
    simplifyOpB (opOL x 1OL) = x 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (invOL x1) = (invOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpGroup1OL2Term2 n A) -> (OpGroup1OL2Term2 n A))
    simplifyOp (opOL2 1OL2 x) = x 
    simplifyOp (opOL2 x 1OL2) = x 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (invOL2 x1) = (invOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Group1 A) -> (Group1LTerm -> A))
    evalB Gr (opL x1 x2) = ((op Gr) (evalB Gr x1) (evalB Gr x2)) 
    evalB Gr 1L = (1 Gr) 
    evalB Gr (invL x1) = ((inv Gr) (evalB Gr x1)) 
    evalCl : {A : Set} -> ((Group1 A) -> ((ClGroup1ClTerm A) -> A))
    evalCl Gr (sing x1) = x1 
    evalCl Gr (opCl x1 x2) = ((op Gr) (evalCl Gr x1) (evalCl Gr x2)) 
    evalCl Gr 1Cl = (1 Gr) 
    evalCl Gr (invCl x1) = ((inv Gr) (evalCl Gr x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((Group1 A) -> ((Vec A n) -> ((OpGroup1OLTerm n) -> A)))
    evalOpB Gr vars (v x1) = (lookup _ x1 vars) 
    evalOpB Gr vars (opOL x1 x2) = ((op Gr) (evalOpB Gr vars x1) (evalOpB Gr vars x2)) 
    evalOpB Gr vars 1OL = (1 Gr) 
    evalOpB Gr vars (invOL x1) = ((inv Gr) (evalOpB Gr vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((Group1 A) -> ((Vec A n) -> ((OpGroup1OL2Term2 n A) -> A)))
    evalOp Gr vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Gr vars (sing2 x1) = x1 
    evalOp Gr vars (opOL2 x1 x2) = ((op Gr) (evalOp Gr vars x1) (evalOp Gr vars x2)) 
    evalOp Gr vars 1OL2 = (1 Gr) 
    evalOp Gr vars (invOL2 x1) = ((inv Gr) (evalOp Gr vars x1)) 
    inductionB : {P : (Group1LTerm -> Set)} -> (((x1 x2 : Group1LTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((P 1L) -> (((x1 : Group1LTerm) -> ((P x1) -> (P (invL x1)))) -> ((x : Group1LTerm) -> (P x)))))
    inductionB {p} popl p1l pinvl (opL x1 x2) = (popl _ _ (inductionB {p} popl p1l pinvl x1) (inductionB {p} popl p1l pinvl x2)) 
    inductionB {p} popl p1l pinvl 1L = p1l 
    inductionB {p} popl p1l pinvl (invL x1) = (pinvl _ (inductionB {p} popl p1l pinvl x1)) 
    inductionCl : {A : Set} {P : ((ClGroup1ClTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClGroup1ClTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((P 1Cl) -> (((x1 : (ClGroup1ClTerm A)) -> ((P x1) -> (P (invCl x1)))) -> ((x : (ClGroup1ClTerm A)) -> (P x))))))
    inductionCl {_} {p} psing popcl p1cl pinvcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl p1cl pinvcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl p1cl pinvcl x1) (inductionCl {_} {p} psing popcl p1cl pinvcl x2)) 
    inductionCl {_} {p} psing popcl p1cl pinvcl 1Cl = p1cl 
    inductionCl {_} {p} psing popcl p1cl pinvcl (invCl x1) = (pinvcl _ (inductionCl {_} {p} psing popcl p1cl pinvcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpGroup1OLTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpGroup1OLTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((P 1OL) -> (((x1 : (OpGroup1OLTerm n)) -> ((P x1) -> (P (invOL x1)))) -> ((x : (OpGroup1OLTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv popol p1ol pinvol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol p1ol pinvol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol p1ol pinvol x1) (inductionOpB {_} {p} pv popol p1ol pinvol x2)) 
    inductionOpB {_} {p} pv popol p1ol pinvol 1OL = p1ol 
    inductionOpB {_} {p} pv popol p1ol pinvol (invOL x1) = (pinvol _ (inductionOpB {_} {p} pv popol p1ol pinvol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpGroup1OL2Term2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpGroup1OL2Term2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((P 1OL2) -> (((x1 : (OpGroup1OL2Term2 n A)) -> ((P x1) -> (P (invOL2 x1)))) -> ((x : (OpGroup1OL2Term2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 p1ol2 pinvol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 p1ol2 pinvol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 p1ol2 pinvol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 p1ol2 pinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 p1ol2 pinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 p1ol2 pinvol2 1OL2 = p1ol2 
    inductionOp {_} {_} {p} pv2 psing2 popol2 p1ol2 pinvol2 (invOL2 x1) = (pinvol2 _ (inductionOp {_} {_} {p} pv2 psing2 popol2 p1ol2 pinvol2 x1)) 
    opL' : (Group1LTerm -> (Group1LTerm -> Group1LTerm))
    opL' x1 x2 = (opL x1 x2) 
    1L' : Group1LTerm
    1L'  = 1L 
    invL' : (Group1LTerm -> Group1LTerm)
    invL' x1 = (invL x1) 
    stageB : (Group1LTerm -> (Staged Group1LTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB 1L = (Now 1L) 
    stageB (invL x1) = (stage1 invL' (codeLift1 invL') (stageB x1)) 
    opCl' : {A : Set} -> ((ClGroup1ClTerm A) -> ((ClGroup1ClTerm A) -> (ClGroup1ClTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    1Cl' : {A : Set} -> (ClGroup1ClTerm A)
    1Cl'  = 1Cl 
    invCl' : {A : Set} -> ((ClGroup1ClTerm A) -> (ClGroup1ClTerm A))
    invCl' x1 = (invCl x1) 
    stageCl : {A : Set} -> ((ClGroup1ClTerm A) -> (Staged (ClGroup1ClTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl 1Cl = (Now 1Cl) 
    stageCl (invCl x1) = (stage1 invCl' (codeLift1 invCl') (stageCl x1)) 
    opOL' : {n : Nat} -> ((OpGroup1OLTerm n) -> ((OpGroup1OLTerm n) -> (OpGroup1OLTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    1OL' : {n : Nat} -> (OpGroup1OLTerm n)
    1OL'  = 1OL 
    invOL' : {n : Nat} -> ((OpGroup1OLTerm n) -> (OpGroup1OLTerm n))
    invOL' x1 = (invOL x1) 
    stageOpB : {n : Nat} -> ((OpGroup1OLTerm n) -> (Staged (OpGroup1OLTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 1OL = (Now 1OL) 
    stageOpB (invOL x1) = (stage1 invOL' (codeLift1 invOL') (stageOpB x1)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpGroup1OL2Term2 n A) -> ((OpGroup1OL2Term2 n A) -> (OpGroup1OL2Term2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    1OL2' : {n : Nat} {A : Set} -> (OpGroup1OL2Term2 n A)
    1OL2'  = 1OL2 
    invOL2' : {n : Nat} {A : Set} -> ((OpGroup1OL2Term2 n A) -> (OpGroup1OL2Term2 n A))
    invOL2' x1 = (invOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpGroup1OL2Term2 n A) -> (Staged (OpGroup1OL2Term2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp 1OL2 = (Now 1OL2) 
    stageOp (invOL2 x1) = (stage1 invOL2' (codeLift1 invOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        1T : (Repr A)
        invT : ((Repr A) -> (Repr A))
  module IdempotentAdditiveMagma  where
    record IdempotentAdditiveMagma (A : Set) : Set where
      constructor IdempotentAdditiveMagmaC
      field
        + : (A -> (A -> A))
        idempotent_+ : {x : A} -> (+ x x) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        idempotent_+P : {xP : (Prod A A)} -> (+P xP xP) == xP
    record Hom {A1 : Set} {A2 : Set} (Id1 : (IdempotentAdditiveMagma A1)) (Id2 : (IdempotentAdditiveMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Id1) x1 x2)) == ((+ Id2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Id1 : (IdempotentAdditiveMagma A1)) (Id2 : (IdempotentAdditiveMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Id1) x1 x2) ((+ Id2) y1 y2))))
    data IdempotentAdditiveMagmaTerm  : Set where
      +L : (IdempotentAdditiveMagmaTerm -> (IdempotentAdditiveMagmaTerm -> IdempotentAdditiveMagmaTerm))
    data ClIdempotentAdditiveMagmaTerm (A : Set) : Set where
      sing : (A -> (ClIdempotentAdditiveMagmaTerm A))
      +Cl : ((ClIdempotentAdditiveMagmaTerm A) -> ((ClIdempotentAdditiveMagmaTerm A) -> (ClIdempotentAdditiveMagmaTerm A)))
    data OpIdempotentAdditiveMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpIdempotentAdditiveMagmaTerm n))
      +OL : ((OpIdempotentAdditiveMagmaTerm n) -> ((OpIdempotentAdditiveMagmaTerm n) -> (OpIdempotentAdditiveMagmaTerm n)))
    data OpIdempotentAdditiveMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpIdempotentAdditiveMagmaTerm2 n A))
      sing2 : (A -> (OpIdempotentAdditiveMagmaTerm2 n A))
      +OL2 : ((OpIdempotentAdditiveMagmaTerm2 n A) -> ((OpIdempotentAdditiveMagmaTerm2 n A) -> (OpIdempotentAdditiveMagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClIdempotentAdditiveMagmaTerm A) -> (ClIdempotentAdditiveMagmaTerm A))
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpIdempotentAdditiveMagmaTerm n) -> (OpIdempotentAdditiveMagmaTerm n))
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpIdempotentAdditiveMagmaTerm2 n A) -> (OpIdempotentAdditiveMagmaTerm2 n A))
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((IdempotentAdditiveMagma A) -> (IdempotentAdditiveMagmaTerm -> A))
    evalB Id (+L x1 x2) = ((+ Id) (evalB Id x1) (evalB Id x2)) 
    evalCl : {A : Set} -> ((IdempotentAdditiveMagma A) -> ((ClIdempotentAdditiveMagmaTerm A) -> A))
    evalCl Id (sing x1) = x1 
    evalCl Id (+Cl x1 x2) = ((+ Id) (evalCl Id x1) (evalCl Id x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((IdempotentAdditiveMagma A) -> ((Vec A n) -> ((OpIdempotentAdditiveMagmaTerm n) -> A)))
    evalOpB Id vars (v x1) = (lookup _ x1 vars) 
    evalOpB Id vars (+OL x1 x2) = ((+ Id) (evalOpB Id vars x1) (evalOpB Id vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((IdempotentAdditiveMagma A) -> ((Vec A n) -> ((OpIdempotentAdditiveMagmaTerm2 n A) -> A)))
    evalOp Id vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Id vars (sing2 x1) = x1 
    evalOp Id vars (+OL2 x1 x2) = ((+ Id) (evalOp Id vars x1) (evalOp Id vars x2)) 
    inductionB : {P : (IdempotentAdditiveMagmaTerm -> Set)} -> (((x1 x2 : IdempotentAdditiveMagmaTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : IdempotentAdditiveMagmaTerm) -> (P x)))
    inductionB {p} p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p+l x1) (inductionB {p} p+l x2)) 
    inductionCl : {A : Set} {P : ((ClIdempotentAdditiveMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClIdempotentAdditiveMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClIdempotentAdditiveMagmaTerm A)) -> (P x))))
    inductionCl {_} {p} psing p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p+cl x1) (inductionCl {_} {p} psing p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpIdempotentAdditiveMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpIdempotentAdditiveMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpIdempotentAdditiveMagmaTerm n)) -> (P x))))
    inductionOpB {_} {p} pv p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p+ol x1) (inductionOpB {_} {p} pv p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpIdempotentAdditiveMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpIdempotentAdditiveMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpIdempotentAdditiveMagmaTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 x2)) 
    +L' : (IdempotentAdditiveMagmaTerm -> (IdempotentAdditiveMagmaTerm -> IdempotentAdditiveMagmaTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (IdempotentAdditiveMagmaTerm -> (Staged IdempotentAdditiveMagmaTerm))
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    +Cl' : {A : Set} -> ((ClIdempotentAdditiveMagmaTerm A) -> ((ClIdempotentAdditiveMagmaTerm A) -> (ClIdempotentAdditiveMagmaTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClIdempotentAdditiveMagmaTerm A) -> (Staged (ClIdempotentAdditiveMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    +OL' : {n : Nat} -> ((OpIdempotentAdditiveMagmaTerm n) -> ((OpIdempotentAdditiveMagmaTerm n) -> (OpIdempotentAdditiveMagmaTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpIdempotentAdditiveMagmaTerm n) -> (Staged (OpIdempotentAdditiveMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    +OL2' : {n : Nat} {A : Set} -> ((OpIdempotentAdditiveMagmaTerm2 n A) -> ((OpIdempotentAdditiveMagmaTerm2 n A) -> (OpIdempotentAdditiveMagmaTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpIdempotentAdditiveMagmaTerm2 n A) -> (Staged (OpIdempotentAdditiveMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module IdempotentMagma  where
    record IdempotentMagma (A : Set) : Set where
      constructor IdempotentMagmaC
      field
        op : (A -> (A -> A))
        idempotent_op : {x : A} -> (op x x) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        idempotent_opP : {xP : (Prod A A)} -> (opP xP xP) == xP
    record Hom {A1 : Set} {A2 : Set} (Id1 : (IdempotentMagma A1)) (Id2 : (IdempotentMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Id1) x1 x2)) == ((op Id2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Id1 : (IdempotentMagma A1)) (Id2 : (IdempotentMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Id1) x1 x2) ((op Id2) y1 y2))))
    data IdempotentMagmaTerm  : Set where
      opL : (IdempotentMagmaTerm -> (IdempotentMagmaTerm -> IdempotentMagmaTerm))
    data ClIdempotentMagmaTerm (A : Set) : Set where
      sing : (A -> (ClIdempotentMagmaTerm A))
      opCl : ((ClIdempotentMagmaTerm A) -> ((ClIdempotentMagmaTerm A) -> (ClIdempotentMagmaTerm A)))
    data OpIdempotentMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpIdempotentMagmaTerm n))
      opOL : ((OpIdempotentMagmaTerm n) -> ((OpIdempotentMagmaTerm n) -> (OpIdempotentMagmaTerm n)))
    data OpIdempotentMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpIdempotentMagmaTerm2 n A))
      sing2 : (A -> (OpIdempotentMagmaTerm2 n A))
      opOL2 : ((OpIdempotentMagmaTerm2 n A) -> ((OpIdempotentMagmaTerm2 n A) -> (OpIdempotentMagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClIdempotentMagmaTerm A) -> (ClIdempotentMagmaTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpIdempotentMagmaTerm n) -> (OpIdempotentMagmaTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpIdempotentMagmaTerm2 n A) -> (OpIdempotentMagmaTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((IdempotentMagma A) -> (IdempotentMagmaTerm -> A))
    evalB Id (opL x1 x2) = ((op Id) (evalB Id x1) (evalB Id x2)) 
    evalCl : {A : Set} -> ((IdempotentMagma A) -> ((ClIdempotentMagmaTerm A) -> A))
    evalCl Id (sing x1) = x1 
    evalCl Id (opCl x1 x2) = ((op Id) (evalCl Id x1) (evalCl Id x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((IdempotentMagma A) -> ((Vec A n) -> ((OpIdempotentMagmaTerm n) -> A)))
    evalOpB Id vars (v x1) = (lookup _ x1 vars) 
    evalOpB Id vars (opOL x1 x2) = ((op Id) (evalOpB Id vars x1) (evalOpB Id vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((IdempotentMagma A) -> ((Vec A n) -> ((OpIdempotentMagmaTerm2 n A) -> A)))
    evalOp Id vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Id vars (sing2 x1) = x1 
    evalOp Id vars (opOL2 x1 x2) = ((op Id) (evalOp Id vars x1) (evalOp Id vars x2)) 
    inductionB : {P : (IdempotentMagmaTerm -> Set)} -> (((x1 x2 : IdempotentMagmaTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : IdempotentMagmaTerm) -> (P x)))
    inductionB {p} popl (opL x1 x2) = (popl _ _ (inductionB {p} popl x1) (inductionB {p} popl x2)) 
    inductionCl : {A : Set} {P : ((ClIdempotentMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClIdempotentMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClIdempotentMagmaTerm A)) -> (P x))))
    inductionCl {_} {p} psing popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl x1) (inductionCl {_} {p} psing popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpIdempotentMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpIdempotentMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpIdempotentMagmaTerm n)) -> (P x))))
    inductionOpB {_} {p} pv popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol x1) (inductionOpB {_} {p} pv popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpIdempotentMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpIdempotentMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpIdempotentMagmaTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 x2)) 
    opL' : (IdempotentMagmaTerm -> (IdempotentMagmaTerm -> IdempotentMagmaTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (IdempotentMagmaTerm -> (Staged IdempotentMagmaTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClIdempotentMagmaTerm A) -> ((ClIdempotentMagmaTerm A) -> (ClIdempotentMagmaTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClIdempotentMagmaTerm A) -> (Staged (ClIdempotentMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpIdempotentMagmaTerm n) -> ((OpIdempotentMagmaTerm n) -> (OpIdempotentMagmaTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpIdempotentMagmaTerm n) -> (Staged (OpIdempotentMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpIdempotentMagmaTerm2 n A) -> ((OpIdempotentMagmaTerm2 n A) -> (OpIdempotentMagmaTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpIdempotentMagmaTerm2 n A) -> (Staged (OpIdempotentMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module IdempotentMultMagma  where
    record IdempotentMultMagma (A : Set) : Set where
      constructor IdempotentMultMagmaC
      field
        * : (A -> (A -> A))
        idempotent_* : {x : A} -> (* x x) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        idempotent_*P : {xP : (Prod A A)} -> (*P xP xP) == xP
    record Hom {A1 : Set} {A2 : Set} (Id1 : (IdempotentMultMagma A1)) (Id2 : (IdempotentMultMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Id1) x1 x2)) == ((* Id2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Id1 : (IdempotentMultMagma A1)) (Id2 : (IdempotentMultMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Id1) x1 x2) ((* Id2) y1 y2))))
    data IdempotentMultMagmaTerm  : Set where
      *L : (IdempotentMultMagmaTerm -> (IdempotentMultMagmaTerm -> IdempotentMultMagmaTerm))
    data ClIdempotentMultMagmaTerm (A : Set) : Set where
      sing : (A -> (ClIdempotentMultMagmaTerm A))
      *Cl : ((ClIdempotentMultMagmaTerm A) -> ((ClIdempotentMultMagmaTerm A) -> (ClIdempotentMultMagmaTerm A)))
    data OpIdempotentMultMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpIdempotentMultMagmaTerm n))
      *OL : ((OpIdempotentMultMagmaTerm n) -> ((OpIdempotentMultMagmaTerm n) -> (OpIdempotentMultMagmaTerm n)))
    data OpIdempotentMultMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpIdempotentMultMagmaTerm2 n A))
      sing2 : (A -> (OpIdempotentMultMagmaTerm2 n A))
      *OL2 : ((OpIdempotentMultMagmaTerm2 n A) -> ((OpIdempotentMultMagmaTerm2 n A) -> (OpIdempotentMultMagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClIdempotentMultMagmaTerm A) -> (ClIdempotentMultMagmaTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpIdempotentMultMagmaTerm n) -> (OpIdempotentMultMagmaTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpIdempotentMultMagmaTerm2 n A) -> (OpIdempotentMultMagmaTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((IdempotentMultMagma A) -> (IdempotentMultMagmaTerm -> A))
    evalB Id (*L x1 x2) = ((* Id) (evalB Id x1) (evalB Id x2)) 
    evalCl : {A : Set} -> ((IdempotentMultMagma A) -> ((ClIdempotentMultMagmaTerm A) -> A))
    evalCl Id (sing x1) = x1 
    evalCl Id (*Cl x1 x2) = ((* Id) (evalCl Id x1) (evalCl Id x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((IdempotentMultMagma A) -> ((Vec A n) -> ((OpIdempotentMultMagmaTerm n) -> A)))
    evalOpB Id vars (v x1) = (lookup _ x1 vars) 
    evalOpB Id vars (*OL x1 x2) = ((* Id) (evalOpB Id vars x1) (evalOpB Id vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((IdempotentMultMagma A) -> ((Vec A n) -> ((OpIdempotentMultMagmaTerm2 n A) -> A)))
    evalOp Id vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Id vars (sing2 x1) = x1 
    evalOp Id vars (*OL2 x1 x2) = ((* Id) (evalOp Id vars x1) (evalOp Id vars x2)) 
    inductionB : {P : (IdempotentMultMagmaTerm -> Set)} -> (((x1 x2 : IdempotentMultMagmaTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((x : IdempotentMultMagmaTerm) -> (P x)))
    inductionB {p} p*l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l x1) (inductionB {p} p*l x2)) 
    inductionCl : {A : Set} {P : ((ClIdempotentMultMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClIdempotentMultMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((x : (ClIdempotentMultMagmaTerm A)) -> (P x))))
    inductionCl {_} {p} psing p*cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl x1) (inductionCl {_} {p} psing p*cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpIdempotentMultMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpIdempotentMultMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((x : (OpIdempotentMultMagmaTerm n)) -> (P x))))
    inductionOpB {_} {p} pv p*ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol x1) (inductionOpB {_} {p} pv p*ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpIdempotentMultMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpIdempotentMultMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((x : (OpIdempotentMultMagmaTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 x2)) 
    *L' : (IdempotentMultMagmaTerm -> (IdempotentMultMagmaTerm -> IdempotentMultMagmaTerm))
    *L' x1 x2 = (*L x1 x2) 
    stageB : (IdempotentMultMagmaTerm -> (Staged IdempotentMultMagmaTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClIdempotentMultMagmaTerm A) -> ((ClIdempotentMultMagmaTerm A) -> (ClIdempotentMultMagmaTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    stageCl : {A : Set} -> ((ClIdempotentMultMagmaTerm A) -> (Staged (ClIdempotentMultMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpIdempotentMultMagmaTerm n) -> ((OpIdempotentMultMagmaTerm n) -> (OpIdempotentMultMagmaTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpIdempotentMultMagmaTerm n) -> (Staged (OpIdempotentMultMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpIdempotentMultMagmaTerm2 n A) -> ((OpIdempotentMultMagmaTerm2 n A) -> (OpIdempotentMultMagmaTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpIdempotentMultMagmaTerm2 n A) -> (Staged (OpIdempotentMultMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module IdempotentSemiRng  where
    record IdempotentSemiRng (A : Set) : Set where
      constructor IdempotentSemiRngC
      field
        + : (A -> (A -> A))
        * : (A -> (A -> A))
        0 : A
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        leftDistributive_*_+ : {x y z : A} -> (* x (+ y z)) == (+ (* x y) (* x z))
        rightDistributive_*_+ : {x y z : A} -> (* (+ y z) x) == (+ (* y x) (* z x))
        idempotent_+ : {x : A} -> (+ x x) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        +S : (AS -> (AS -> AS))
        *S : (AS -> (AS -> AS))
        0S : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        0P : (Prod A A)
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        leftDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P xP (+P yP zP)) == (+P (*P xP yP) (*P xP zP))
        rightDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P (+P yP zP) xP) == (+P (*P yP xP) (*P zP xP))
        idempotent_+P : {xP : (Prod A A)} -> (+P xP xP) == xP
    record Hom {A1 : Set} {A2 : Set} (Id1 : (IdempotentSemiRng A1)) (Id2 : (IdempotentSemiRng A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Id1) x1 x2)) == ((+ Id2) (hom x1) (hom x2))
        pres-* : {x1 x2 : A1} -> (hom ((* Id1) x1 x2)) == ((* Id2) (hom x1) (hom x2))
        pres-0 : (hom (0 Id1)) == (0 Id2)
    record RelInterp {A1 : Set} {A2 : Set} (Id1 : (IdempotentSemiRng A1)) (Id2 : (IdempotentSemiRng A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Id1) x1 x2) ((+ Id2) y1 y2))))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Id1) x1 x2) ((* Id2) y1 y2))))
        interp-0 : (interp (0 Id1) (0 Id2))
    data IdempotentSemiRngTerm  : Set where
      +L : (IdempotentSemiRngTerm -> (IdempotentSemiRngTerm -> IdempotentSemiRngTerm))
      *L : (IdempotentSemiRngTerm -> (IdempotentSemiRngTerm -> IdempotentSemiRngTerm))
      0L : IdempotentSemiRngTerm
    data ClIdempotentSemiRngTerm (A : Set) : Set where
      sing : (A -> (ClIdempotentSemiRngTerm A))
      +Cl : ((ClIdempotentSemiRngTerm A) -> ((ClIdempotentSemiRngTerm A) -> (ClIdempotentSemiRngTerm A)))
      *Cl : ((ClIdempotentSemiRngTerm A) -> ((ClIdempotentSemiRngTerm A) -> (ClIdempotentSemiRngTerm A)))
      0Cl : (ClIdempotentSemiRngTerm A)
    data OpIdempotentSemiRngTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpIdempotentSemiRngTerm n))
      +OL : ((OpIdempotentSemiRngTerm n) -> ((OpIdempotentSemiRngTerm n) -> (OpIdempotentSemiRngTerm n)))
      *OL : ((OpIdempotentSemiRngTerm n) -> ((OpIdempotentSemiRngTerm n) -> (OpIdempotentSemiRngTerm n)))
      0OL : (OpIdempotentSemiRngTerm n)
    data OpIdempotentSemiRngTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpIdempotentSemiRngTerm2 n A))
      sing2 : (A -> (OpIdempotentSemiRngTerm2 n A))
      +OL2 : ((OpIdempotentSemiRngTerm2 n A) -> ((OpIdempotentSemiRngTerm2 n A) -> (OpIdempotentSemiRngTerm2 n A)))
      *OL2 : ((OpIdempotentSemiRngTerm2 n A) -> ((OpIdempotentSemiRngTerm2 n A) -> (OpIdempotentSemiRngTerm2 n A)))
      0OL2 : (OpIdempotentSemiRngTerm2 n A)
    simplifyCl : {A : Set} -> ((ClIdempotentSemiRngTerm A) -> (ClIdempotentSemiRngTerm A))
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 0Cl = 0Cl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpIdempotentSemiRngTerm n) -> (OpIdempotentSemiRngTerm n))
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 0OL = 0OL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpIdempotentSemiRngTerm2 n A) -> (OpIdempotentSemiRngTerm2 n A))
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((IdempotentSemiRng A) -> (IdempotentSemiRngTerm -> A))
    evalB Id (+L x1 x2) = ((+ Id) (evalB Id x1) (evalB Id x2)) 
    evalB Id (*L x1 x2) = ((* Id) (evalB Id x1) (evalB Id x2)) 
    evalB Id 0L = (0 Id) 
    evalCl : {A : Set} -> ((IdempotentSemiRng A) -> ((ClIdempotentSemiRngTerm A) -> A))
    evalCl Id (sing x1) = x1 
    evalCl Id (+Cl x1 x2) = ((+ Id) (evalCl Id x1) (evalCl Id x2)) 
    evalCl Id (*Cl x1 x2) = ((* Id) (evalCl Id x1) (evalCl Id x2)) 
    evalCl Id 0Cl = (0 Id) 
    evalOpB : {A : Set} {n : Nat} -> ((IdempotentSemiRng A) -> ((Vec A n) -> ((OpIdempotentSemiRngTerm n) -> A)))
    evalOpB Id vars (v x1) = (lookup _ x1 vars) 
    evalOpB Id vars (+OL x1 x2) = ((+ Id) (evalOpB Id vars x1) (evalOpB Id vars x2)) 
    evalOpB Id vars (*OL x1 x2) = ((* Id) (evalOpB Id vars x1) (evalOpB Id vars x2)) 
    evalOpB Id vars 0OL = (0 Id) 
    evalOp : {A : Set} {n : Nat} -> ((IdempotentSemiRng A) -> ((Vec A n) -> ((OpIdempotentSemiRngTerm2 n A) -> A)))
    evalOp Id vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Id vars (sing2 x1) = x1 
    evalOp Id vars (+OL2 x1 x2) = ((+ Id) (evalOp Id vars x1) (evalOp Id vars x2)) 
    evalOp Id vars (*OL2 x1 x2) = ((* Id) (evalOp Id vars x1) (evalOp Id vars x2)) 
    evalOp Id vars 0OL2 = (0 Id) 
    inductionB : {P : (IdempotentSemiRngTerm -> Set)} -> (((x1 x2 : IdempotentSemiRngTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> (((x1 x2 : IdempotentSemiRngTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((P 0L) -> ((x : IdempotentSemiRngTerm) -> (P x)))))
    inductionB {p} p+l p*l p0l (+L x1 x2) = (p+l _ _ (inductionB {p} p+l p*l p0l x1) (inductionB {p} p+l p*l p0l x2)) 
    inductionB {p} p+l p*l p0l (*L x1 x2) = (p*l _ _ (inductionB {p} p+l p*l p0l x1) (inductionB {p} p+l p*l p0l x2)) 
    inductionB {p} p+l p*l p0l 0L = p0l 
    inductionCl : {A : Set} {P : ((ClIdempotentSemiRngTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClIdempotentSemiRngTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> (((x1 x2 : (ClIdempotentSemiRngTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((P 0Cl) -> ((x : (ClIdempotentSemiRngTerm A)) -> (P x))))))
    inductionCl {_} {p} psing p+cl p*cl p0cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p+cl p*cl p0cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p+cl p*cl p0cl x1) (inductionCl {_} {p} psing p+cl p*cl p0cl x2)) 
    inductionCl {_} {p} psing p+cl p*cl p0cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p+cl p*cl p0cl x1) (inductionCl {_} {p} psing p+cl p*cl p0cl x2)) 
    inductionCl {_} {p} psing p+cl p*cl p0cl 0Cl = p0cl 
    inductionOpB : {n : Nat} {P : ((OpIdempotentSemiRngTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpIdempotentSemiRngTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> (((x1 x2 : (OpIdempotentSemiRngTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((P 0OL) -> ((x : (OpIdempotentSemiRngTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv p+ol p*ol p0ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p+ol p*ol p0ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p+ol p*ol p0ol x1) (inductionOpB {_} {p} pv p+ol p*ol p0ol x2)) 
    inductionOpB {_} {p} pv p+ol p*ol p0ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p+ol p*ol p0ol x1) (inductionOpB {_} {p} pv p+ol p*ol p0ol x2)) 
    inductionOpB {_} {p} pv p+ol p*ol p0ol 0OL = p0ol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpIdempotentSemiRngTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpIdempotentSemiRngTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> (((x1 x2 : (OpIdempotentSemiRngTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((P 0OL2) -> ((x : (OpIdempotentSemiRngTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 p0ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 p0ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 p0ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 p0ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 p0ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 p0ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 p0ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 p0ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 p0ol2 0OL2 = p0ol2 
    +L' : (IdempotentSemiRngTerm -> (IdempotentSemiRngTerm -> IdempotentSemiRngTerm))
    +L' x1 x2 = (+L x1 x2) 
    *L' : (IdempotentSemiRngTerm -> (IdempotentSemiRngTerm -> IdempotentSemiRngTerm))
    *L' x1 x2 = (*L x1 x2) 
    0L' : IdempotentSemiRngTerm
    0L'  = 0L 
    stageB : (IdempotentSemiRngTerm -> (Staged IdempotentSemiRngTerm))
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB 0L = (Now 0L) 
    +Cl' : {A : Set} -> ((ClIdempotentSemiRngTerm A) -> ((ClIdempotentSemiRngTerm A) -> (ClIdempotentSemiRngTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    *Cl' : {A : Set} -> ((ClIdempotentSemiRngTerm A) -> ((ClIdempotentSemiRngTerm A) -> (ClIdempotentSemiRngTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    0Cl' : {A : Set} -> (ClIdempotentSemiRngTerm A)
    0Cl'  = 0Cl 
    stageCl : {A : Set} -> ((ClIdempotentSemiRngTerm A) -> (Staged (ClIdempotentSemiRngTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl 0Cl = (Now 0Cl) 
    +OL' : {n : Nat} -> ((OpIdempotentSemiRngTerm n) -> ((OpIdempotentSemiRngTerm n) -> (OpIdempotentSemiRngTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    *OL' : {n : Nat} -> ((OpIdempotentSemiRngTerm n) -> ((OpIdempotentSemiRngTerm n) -> (OpIdempotentSemiRngTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    0OL' : {n : Nat} -> (OpIdempotentSemiRngTerm n)
    0OL'  = 0OL 
    stageOpB : {n : Nat} -> ((OpIdempotentSemiRngTerm n) -> (Staged (OpIdempotentSemiRngTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 0OL = (Now 0OL) 
    +OL2' : {n : Nat} {A : Set} -> ((OpIdempotentSemiRngTerm2 n A) -> ((OpIdempotentSemiRngTerm2 n A) -> (OpIdempotentSemiRngTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    *OL2' : {n : Nat} {A : Set} -> ((OpIdempotentSemiRngTerm2 n A) -> ((OpIdempotentSemiRngTerm2 n A) -> (OpIdempotentSemiRngTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    0OL2' : {n : Nat} {A : Set} -> (OpIdempotentSemiRngTerm2 n A)
    0OL2'  = 0OL2 
    stageOp : {n : Nat} {A : Set} -> ((OpIdempotentSemiRngTerm2 n A) -> (Staged (OpIdempotentSemiRngTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp 0OL2 = (Now 0OL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        0T : (Repr A)
  module IdempotentSemiring  where
    record IdempotentSemiring (A : Set) : Set where
      constructor IdempotentSemiringC
      field
        + : (A -> (A -> A))
        0 : A
        * : (A -> (A -> A))
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        1 : A
        lunit_1 : {x : A} -> (* 1 x) == x
        runit_1 : {x : A} -> (* x 1) == x
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        leftDistributive_*_+ : {x y z : A} -> (* x (+ y z)) == (+ (* x y) (* x z))
        rightDistributive_*_+ : {x y z : A} -> (* (+ y z) x) == (+ (* y x) (* z x))
        leftZero_op_0 : {x : A} -> (* 0 x) == 0
        rightZero_op_0 : {x : A} -> (* x 0) == 0
        idempotent_+ : {x : A} -> (+ x x) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        +S : (AS -> (AS -> AS))
        0S : AS
        *S : (AS -> (AS -> AS))
        1S : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        0P : (Prod A A)
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        1P : (Prod A A)
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        lunit_1P : {xP : (Prod A A)} -> (*P 1P xP) == xP
        runit_1P : {xP : (Prod A A)} -> (*P xP 1P) == xP
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        leftDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P xP (+P yP zP)) == (+P (*P xP yP) (*P xP zP))
        rightDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P (+P yP zP) xP) == (+P (*P yP xP) (*P zP xP))
        leftZero_op_0P : {xP : (Prod A A)} -> (*P 0P xP) == 0P
        rightZero_op_0P : {xP : (Prod A A)} -> (*P xP 0P) == 0P
        idempotent_+P : {xP : (Prod A A)} -> (+P xP xP) == xP
    record Hom {A1 : Set} {A2 : Set} (Id1 : (IdempotentSemiring A1)) (Id2 : (IdempotentSemiring A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Id1) x1 x2)) == ((+ Id2) (hom x1) (hom x2))
        pres-0 : (hom (0 Id1)) == (0 Id2)
        pres-* : {x1 x2 : A1} -> (hom ((* Id1) x1 x2)) == ((* Id2) (hom x1) (hom x2))
        pres-1 : (hom (1 Id1)) == (1 Id2)
    record RelInterp {A1 : Set} {A2 : Set} (Id1 : (IdempotentSemiring A1)) (Id2 : (IdempotentSemiring A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Id1) x1 x2) ((+ Id2) y1 y2))))
        interp-0 : (interp (0 Id1) (0 Id2))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Id1) x1 x2) ((* Id2) y1 y2))))
        interp-1 : (interp (1 Id1) (1 Id2))
    data IdempotentSemiringTerm  : Set where
      +L : (IdempotentSemiringTerm -> (IdempotentSemiringTerm -> IdempotentSemiringTerm))
      0L : IdempotentSemiringTerm
      *L : (IdempotentSemiringTerm -> (IdempotentSemiringTerm -> IdempotentSemiringTerm))
      1L : IdempotentSemiringTerm
    data ClIdempotentSemiringTerm (A : Set) : Set where
      sing : (A -> (ClIdempotentSemiringTerm A))
      +Cl : ((ClIdempotentSemiringTerm A) -> ((ClIdempotentSemiringTerm A) -> (ClIdempotentSemiringTerm A)))
      0Cl : (ClIdempotentSemiringTerm A)
      *Cl : ((ClIdempotentSemiringTerm A) -> ((ClIdempotentSemiringTerm A) -> (ClIdempotentSemiringTerm A)))
      1Cl : (ClIdempotentSemiringTerm A)
    data OpIdempotentSemiringTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpIdempotentSemiringTerm n))
      +OL : ((OpIdempotentSemiringTerm n) -> ((OpIdempotentSemiringTerm n) -> (OpIdempotentSemiringTerm n)))
      0OL : (OpIdempotentSemiringTerm n)
      *OL : ((OpIdempotentSemiringTerm n) -> ((OpIdempotentSemiringTerm n) -> (OpIdempotentSemiringTerm n)))
      1OL : (OpIdempotentSemiringTerm n)
    data OpIdempotentSemiringTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpIdempotentSemiringTerm2 n A))
      sing2 : (A -> (OpIdempotentSemiringTerm2 n A))
      +OL2 : ((OpIdempotentSemiringTerm2 n A) -> ((OpIdempotentSemiringTerm2 n A) -> (OpIdempotentSemiringTerm2 n A)))
      0OL2 : (OpIdempotentSemiringTerm2 n A)
      *OL2 : ((OpIdempotentSemiringTerm2 n A) -> ((OpIdempotentSemiringTerm2 n A) -> (OpIdempotentSemiringTerm2 n A)))
      1OL2 : (OpIdempotentSemiringTerm2 n A)
    simplifyCl : {A : Set} -> ((ClIdempotentSemiringTerm A) -> (ClIdempotentSemiringTerm A))
    simplifyCl (*Cl 1Cl x) = x 
    simplifyCl (*Cl x 1Cl) = x 
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 0Cl = 0Cl 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpIdempotentSemiringTerm n) -> (OpIdempotentSemiringTerm n))
    simplifyOpB (*OL 1OL x) = x 
    simplifyOpB (*OL x 1OL) = x 
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 0OL = 0OL 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpIdempotentSemiringTerm2 n A) -> (OpIdempotentSemiringTerm2 n A))
    simplifyOp (*OL2 1OL2 x) = x 
    simplifyOp (*OL2 x 1OL2) = x 
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((IdempotentSemiring A) -> (IdempotentSemiringTerm -> A))
    evalB Id (+L x1 x2) = ((+ Id) (evalB Id x1) (evalB Id x2)) 
    evalB Id 0L = (0 Id) 
    evalB Id (*L x1 x2) = ((* Id) (evalB Id x1) (evalB Id x2)) 
    evalB Id 1L = (1 Id) 
    evalCl : {A : Set} -> ((IdempotentSemiring A) -> ((ClIdempotentSemiringTerm A) -> A))
    evalCl Id (sing x1) = x1 
    evalCl Id (+Cl x1 x2) = ((+ Id) (evalCl Id x1) (evalCl Id x2)) 
    evalCl Id 0Cl = (0 Id) 
    evalCl Id (*Cl x1 x2) = ((* Id) (evalCl Id x1) (evalCl Id x2)) 
    evalCl Id 1Cl = (1 Id) 
    evalOpB : {A : Set} {n : Nat} -> ((IdempotentSemiring A) -> ((Vec A n) -> ((OpIdempotentSemiringTerm n) -> A)))
    evalOpB Id vars (v x1) = (lookup _ x1 vars) 
    evalOpB Id vars (+OL x1 x2) = ((+ Id) (evalOpB Id vars x1) (evalOpB Id vars x2)) 
    evalOpB Id vars 0OL = (0 Id) 
    evalOpB Id vars (*OL x1 x2) = ((* Id) (evalOpB Id vars x1) (evalOpB Id vars x2)) 
    evalOpB Id vars 1OL = (1 Id) 
    evalOp : {A : Set} {n : Nat} -> ((IdempotentSemiring A) -> ((Vec A n) -> ((OpIdempotentSemiringTerm2 n A) -> A)))
    evalOp Id vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Id vars (sing2 x1) = x1 
    evalOp Id vars (+OL2 x1 x2) = ((+ Id) (evalOp Id vars x1) (evalOp Id vars x2)) 
    evalOp Id vars 0OL2 = (0 Id) 
    evalOp Id vars (*OL2 x1 x2) = ((* Id) (evalOp Id vars x1) (evalOp Id vars x2)) 
    evalOp Id vars 1OL2 = (1 Id) 
    inductionB : {P : (IdempotentSemiringTerm -> Set)} -> (((x1 x2 : IdempotentSemiringTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((P 0L) -> (((x1 x2 : IdempotentSemiringTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((P 1L) -> ((x : IdempotentSemiringTerm) -> (P x))))))
    inductionB {p} p+l p0l p*l p1l (+L x1 x2) = (p+l _ _ (inductionB {p} p+l p0l p*l p1l x1) (inductionB {p} p+l p0l p*l p1l x2)) 
    inductionB {p} p+l p0l p*l p1l 0L = p0l 
    inductionB {p} p+l p0l p*l p1l (*L x1 x2) = (p*l _ _ (inductionB {p} p+l p0l p*l p1l x1) (inductionB {p} p+l p0l p*l p1l x2)) 
    inductionB {p} p+l p0l p*l p1l 1L = p1l 
    inductionCl : {A : Set} {P : ((ClIdempotentSemiringTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClIdempotentSemiringTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((P 0Cl) -> (((x1 x2 : (ClIdempotentSemiringTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((P 1Cl) -> ((x : (ClIdempotentSemiringTerm A)) -> (P x)))))))
    inductionCl {_} {p} psing p+cl p0cl p*cl p1cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p+cl p0cl p*cl p1cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p+cl p0cl p*cl p1cl x1) (inductionCl {_} {p} psing p+cl p0cl p*cl p1cl x2)) 
    inductionCl {_} {p} psing p+cl p0cl p*cl p1cl 0Cl = p0cl 
    inductionCl {_} {p} psing p+cl p0cl p*cl p1cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p+cl p0cl p*cl p1cl x1) (inductionCl {_} {p} psing p+cl p0cl p*cl p1cl x2)) 
    inductionCl {_} {p} psing p+cl p0cl p*cl p1cl 1Cl = p1cl 
    inductionOpB : {n : Nat} {P : ((OpIdempotentSemiringTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpIdempotentSemiringTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((P 0OL) -> (((x1 x2 : (OpIdempotentSemiringTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((P 1OL) -> ((x : (OpIdempotentSemiringTerm n)) -> (P x)))))))
    inductionOpB {_} {p} pv p+ol p0ol p*ol p1ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p+ol p0ol p*ol p1ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p+ol p0ol p*ol p1ol x1) (inductionOpB {_} {p} pv p+ol p0ol p*ol p1ol x2)) 
    inductionOpB {_} {p} pv p+ol p0ol p*ol p1ol 0OL = p0ol 
    inductionOpB {_} {p} pv p+ol p0ol p*ol p1ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p+ol p0ol p*ol p1ol x1) (inductionOpB {_} {p} pv p+ol p0ol p*ol p1ol x2)) 
    inductionOpB {_} {p} pv p+ol p0ol p*ol p1ol 1OL = p1ol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpIdempotentSemiringTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpIdempotentSemiringTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((P 0OL2) -> (((x1 x2 : (OpIdempotentSemiringTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((P 1OL2) -> ((x : (OpIdempotentSemiringTerm2 n A)) -> (P x))))))))
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 p*ol2 p1ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 p*ol2 p1ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 p*ol2 p1ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 p*ol2 p1ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 p*ol2 p1ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 p*ol2 p1ol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 p*ol2 p1ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 p*ol2 p1ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 p*ol2 p1ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 p*ol2 p1ol2 1OL2 = p1ol2 
    +L' : (IdempotentSemiringTerm -> (IdempotentSemiringTerm -> IdempotentSemiringTerm))
    +L' x1 x2 = (+L x1 x2) 
    0L' : IdempotentSemiringTerm
    0L'  = 0L 
    *L' : (IdempotentSemiringTerm -> (IdempotentSemiringTerm -> IdempotentSemiringTerm))
    *L' x1 x2 = (*L x1 x2) 
    1L' : IdempotentSemiringTerm
    1L'  = 1L 
    stageB : (IdempotentSemiringTerm -> (Staged IdempotentSemiringTerm))
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB 0L = (Now 0L) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB 1L = (Now 1L) 
    +Cl' : {A : Set} -> ((ClIdempotentSemiringTerm A) -> ((ClIdempotentSemiringTerm A) -> (ClIdempotentSemiringTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    0Cl' : {A : Set} -> (ClIdempotentSemiringTerm A)
    0Cl'  = 0Cl 
    *Cl' : {A : Set} -> ((ClIdempotentSemiringTerm A) -> ((ClIdempotentSemiringTerm A) -> (ClIdempotentSemiringTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    1Cl' : {A : Set} -> (ClIdempotentSemiringTerm A)
    1Cl'  = 1Cl 
    stageCl : {A : Set} -> ((ClIdempotentSemiringTerm A) -> (Staged (ClIdempotentSemiringTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl 1Cl = (Now 1Cl) 
    +OL' : {n : Nat} -> ((OpIdempotentSemiringTerm n) -> ((OpIdempotentSemiringTerm n) -> (OpIdempotentSemiringTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    0OL' : {n : Nat} -> (OpIdempotentSemiringTerm n)
    0OL'  = 0OL 
    *OL' : {n : Nat} -> ((OpIdempotentSemiringTerm n) -> ((OpIdempotentSemiringTerm n) -> (OpIdempotentSemiringTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    1OL' : {n : Nat} -> (OpIdempotentSemiringTerm n)
    1OL'  = 1OL 
    stageOpB : {n : Nat} -> ((OpIdempotentSemiringTerm n) -> (Staged (OpIdempotentSemiringTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 1OL = (Now 1OL) 
    +OL2' : {n : Nat} {A : Set} -> ((OpIdempotentSemiringTerm2 n A) -> ((OpIdempotentSemiringTerm2 n A) -> (OpIdempotentSemiringTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    0OL2' : {n : Nat} {A : Set} -> (OpIdempotentSemiringTerm2 n A)
    0OL2'  = 0OL2 
    *OL2' : {n : Nat} {A : Set} -> ((OpIdempotentSemiringTerm2 n A) -> ((OpIdempotentSemiringTerm2 n A) -> (OpIdempotentSemiringTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    1OL2' : {n : Nat} {A : Set} -> (OpIdempotentSemiringTerm2 n A)
    1OL2'  = 1OL2 
    stageOp : {n : Nat} {A : Set} -> ((OpIdempotentSemiringTerm2 n A) -> (Staged (OpIdempotentSemiringTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp 1OL2 = (Now 1OL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        0T : (Repr A)
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        1T : (Repr A)
  module IdempotentUnary  where
    record IdempotentUnary (A : Set) : Set where
      constructor IdempotentUnaryC
      field
        prim : (A -> A)
        idempotent_prim : {x : A} -> (prim (prim x)) == (prim x)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        primS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        primP : ((Prod A A) -> (Prod A A))
        idempotent_primP : {xP : (Prod A A)} -> (primP (primP xP)) == (primP xP)
    record Hom {A1 : Set} {A2 : Set} (Id1 : (IdempotentUnary A1)) (Id2 : (IdempotentUnary A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-prim : {x1 : A1} -> (hom ((prim Id1) x1)) == ((prim Id2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (Id1 : (IdempotentUnary A1)) (Id2 : (IdempotentUnary A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim Id1) x1) ((prim Id2) y1)))
    data IdempotentUnaryTerm  : Set where
      primL : (IdempotentUnaryTerm -> IdempotentUnaryTerm)
    data ClIdempotentUnaryTerm (A : Set) : Set where
      sing : (A -> (ClIdempotentUnaryTerm A))
      primCl : ((ClIdempotentUnaryTerm A) -> (ClIdempotentUnaryTerm A))
    data OpIdempotentUnaryTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpIdempotentUnaryTerm n))
      primOL : ((OpIdempotentUnaryTerm n) -> (OpIdempotentUnaryTerm n))
    data OpIdempotentUnaryTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpIdempotentUnaryTerm2 n A))
      sing2 : (A -> (OpIdempotentUnaryTerm2 n A))
      primOL2 : ((OpIdempotentUnaryTerm2 n A) -> (OpIdempotentUnaryTerm2 n A))
    simplifyCl : {A : Set} -> ((ClIdempotentUnaryTerm A) -> (ClIdempotentUnaryTerm A))
    simplifyCl (primCl (primCl x)) = (primCl x) 
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpIdempotentUnaryTerm n) -> (OpIdempotentUnaryTerm n))
    simplifyOpB (primOL (primOL x)) = (primOL x) 
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpIdempotentUnaryTerm2 n A) -> (OpIdempotentUnaryTerm2 n A))
    simplifyOp (primOL2 (primOL2 x)) = (primOL2 x) 
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((IdempotentUnary A) -> (IdempotentUnaryTerm -> A))
    evalB Id (primL x1) = ((prim Id) (evalB Id x1)) 
    evalCl : {A : Set} -> ((IdempotentUnary A) -> ((ClIdempotentUnaryTerm A) -> A))
    evalCl Id (sing x1) = x1 
    evalCl Id (primCl x1) = ((prim Id) (evalCl Id x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((IdempotentUnary A) -> ((Vec A n) -> ((OpIdempotentUnaryTerm n) -> A)))
    evalOpB Id vars (v x1) = (lookup _ x1 vars) 
    evalOpB Id vars (primOL x1) = ((prim Id) (evalOpB Id vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((IdempotentUnary A) -> ((Vec A n) -> ((OpIdempotentUnaryTerm2 n A) -> A)))
    evalOp Id vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Id vars (sing2 x1) = x1 
    evalOp Id vars (primOL2 x1) = ((prim Id) (evalOp Id vars x1)) 
    inductionB : {P : (IdempotentUnaryTerm -> Set)} -> (((x1 : IdempotentUnaryTerm) -> ((P x1) -> (P (primL x1)))) -> ((x : IdempotentUnaryTerm) -> (P x)))
    inductionB {p} ppriml (primL x1) = (ppriml _ (inductionB {p} ppriml x1)) 
    inductionCl : {A : Set} {P : ((ClIdempotentUnaryTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 : (ClIdempotentUnaryTerm A)) -> ((P x1) -> (P (primCl x1)))) -> ((x : (ClIdempotentUnaryTerm A)) -> (P x))))
    inductionCl {_} {p} psing pprimcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pprimcl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing pprimcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpIdempotentUnaryTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 : (OpIdempotentUnaryTerm n)) -> ((P x1) -> (P (primOL x1)))) -> ((x : (OpIdempotentUnaryTerm n)) -> (P x))))
    inductionOpB {_} {p} pv pprimol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pprimol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv pprimol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpIdempotentUnaryTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 : (OpIdempotentUnaryTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> ((x : (OpIdempotentUnaryTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 pprimol2 x1)) 
    primL' : (IdempotentUnaryTerm -> IdempotentUnaryTerm)
    primL' x1 = (primL x1) 
    stageB : (IdempotentUnaryTerm -> (Staged IdempotentUnaryTerm))
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    primCl' : {A : Set} -> ((ClIdempotentUnaryTerm A) -> (ClIdempotentUnaryTerm A))
    primCl' x1 = (primCl x1) 
    stageCl : {A : Set} -> ((ClIdempotentUnaryTerm A) -> (Staged (ClIdempotentUnaryTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    primOL' : {n : Nat} -> ((OpIdempotentUnaryTerm n) -> (OpIdempotentUnaryTerm n))
    primOL' x1 = (primOL x1) 
    stageOpB : {n : Nat} -> ((OpIdempotentUnaryTerm n) -> (Staged (OpIdempotentUnaryTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    primOL2' : {n : Nat} {A : Set} -> ((OpIdempotentUnaryTerm2 n A) -> (OpIdempotentUnaryTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpIdempotentUnaryTerm2 n A) -> (Staged (OpIdempotentUnaryTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        primT : ((Repr A) -> (Repr A))
  module Inverse  where
    record Inverse (A : Set) : Set where
      constructor InverseC
      field
        inv : (A -> A)
        e : A
        op : (A -> (A -> A))
        leftInverse_inv_op_e : {x : A} -> (op x (inv x)) == e
        rightInverse_inv_op_e : {x : A} -> (op (inv x) x) == e
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        invS : (AS -> AS)
        eS : AS
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        invP : ((Prod A A) -> (Prod A A))
        eP : (Prod A A)
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftInverse_inv_op_eP : {xP : (Prod A A)} -> (opP xP (invP xP)) == eP
        rightInverse_inv_op_eP : {xP : (Prod A A)} -> (opP (invP xP) xP) == eP
    record Hom {A1 : Set} {A2 : Set} (In1 : (Inverse A1)) (In2 : (Inverse A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-inv : {x1 : A1} -> (hom ((inv In1) x1)) == ((inv In2) (hom x1))
        pres-e : (hom (e In1)) == (e In2)
        pres-op : {x1 x2 : A1} -> (hom ((op In1) x1 x2)) == ((op In2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (In1 : (Inverse A1)) (In2 : (Inverse A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-inv : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((inv In1) x1) ((inv In2) y1)))
        interp-e : (interp (e In1) (e In2))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op In1) x1 x2) ((op In2) y1 y2))))
    data InverseLTerm  : Set where
      invL : (InverseLTerm -> InverseLTerm)
      eL : InverseLTerm
      opL : (InverseLTerm -> (InverseLTerm -> InverseLTerm))
    data ClInverseClTerm (A : Set) : Set where
      sing : (A -> (ClInverseClTerm A))
      invCl : ((ClInverseClTerm A) -> (ClInverseClTerm A))
      eCl : (ClInverseClTerm A)
      opCl : ((ClInverseClTerm A) -> ((ClInverseClTerm A) -> (ClInverseClTerm A)))
    data OpInverseOLTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpInverseOLTerm n))
      invOL : ((OpInverseOLTerm n) -> (OpInverseOLTerm n))
      eOL : (OpInverseOLTerm n)
      opOL : ((OpInverseOLTerm n) -> ((OpInverseOLTerm n) -> (OpInverseOLTerm n)))
    data OpInverseOL2Term2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpInverseOL2Term2 n A))
      sing2 : (A -> (OpInverseOL2Term2 n A))
      invOL2 : ((OpInverseOL2Term2 n A) -> (OpInverseOL2Term2 n A))
      eOL2 : (OpInverseOL2Term2 n A)
      opOL2 : ((OpInverseOL2Term2 n A) -> ((OpInverseOL2Term2 n A) -> (OpInverseOL2Term2 n A)))
    simplifyCl : {A : Set} -> ((ClInverseClTerm A) -> (ClInverseClTerm A))
    simplifyCl (invCl x1) = (invCl (simplifyCl x1)) 
    simplifyCl eCl = eCl 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpInverseOLTerm n) -> (OpInverseOLTerm n))
    simplifyOpB (invOL x1) = (invOL (simplifyOpB x1)) 
    simplifyOpB eOL = eOL 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpInverseOL2Term2 n A) -> (OpInverseOL2Term2 n A))
    simplifyOp (invOL2 x1) = (invOL2 (simplifyOp x1)) 
    simplifyOp eOL2 = eOL2 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Inverse A) -> (InverseLTerm -> A))
    evalB In (invL x1) = ((inv In) (evalB In x1)) 
    evalB In eL = (e In) 
    evalB In (opL x1 x2) = ((op In) (evalB In x1) (evalB In x2)) 
    evalCl : {A : Set} -> ((Inverse A) -> ((ClInverseClTerm A) -> A))
    evalCl In (sing x1) = x1 
    evalCl In (invCl x1) = ((inv In) (evalCl In x1)) 
    evalCl In eCl = (e In) 
    evalCl In (opCl x1 x2) = ((op In) (evalCl In x1) (evalCl In x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Inverse A) -> ((Vec A n) -> ((OpInverseOLTerm n) -> A)))
    evalOpB In vars (v x1) = (lookup _ x1 vars) 
    evalOpB In vars (invOL x1) = ((inv In) (evalOpB In vars x1)) 
    evalOpB In vars eOL = (e In) 
    evalOpB In vars (opOL x1 x2) = ((op In) (evalOpB In vars x1) (evalOpB In vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Inverse A) -> ((Vec A n) -> ((OpInverseOL2Term2 n A) -> A)))
    evalOp In vars (v2 x1) = (lookup _ x1 vars) 
    evalOp In vars (sing2 x1) = x1 
    evalOp In vars (invOL2 x1) = ((inv In) (evalOp In vars x1)) 
    evalOp In vars eOL2 = (e In) 
    evalOp In vars (opOL2 x1 x2) = ((op In) (evalOp In vars x1) (evalOp In vars x2)) 
    inductionB : {P : (InverseLTerm -> Set)} -> (((x1 : InverseLTerm) -> ((P x1) -> (P (invL x1)))) -> ((P eL) -> (((x1 x2 : InverseLTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : InverseLTerm) -> (P x)))))
    inductionB {p} pinvl pel popl (invL x1) = (pinvl _ (inductionB {p} pinvl pel popl x1)) 
    inductionB {p} pinvl pel popl eL = pel 
    inductionB {p} pinvl pel popl (opL x1 x2) = (popl _ _ (inductionB {p} pinvl pel popl x1) (inductionB {p} pinvl pel popl x2)) 
    inductionCl : {A : Set} {P : ((ClInverseClTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 : (ClInverseClTerm A)) -> ((P x1) -> (P (invCl x1)))) -> ((P eCl) -> (((x1 x2 : (ClInverseClTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClInverseClTerm A)) -> (P x))))))
    inductionCl {_} {p} psing pinvcl pecl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pinvcl pecl popcl (invCl x1) = (pinvcl _ (inductionCl {_} {p} psing pinvcl pecl popcl x1)) 
    inductionCl {_} {p} psing pinvcl pecl popcl eCl = pecl 
    inductionCl {_} {p} psing pinvcl pecl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing pinvcl pecl popcl x1) (inductionCl {_} {p} psing pinvcl pecl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpInverseOLTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 : (OpInverseOLTerm n)) -> ((P x1) -> (P (invOL x1)))) -> ((P eOL) -> (((x1 x2 : (OpInverseOLTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpInverseOLTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv pinvol peol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pinvol peol popol (invOL x1) = (pinvol _ (inductionOpB {_} {p} pv pinvol peol popol x1)) 
    inductionOpB {_} {p} pv pinvol peol popol eOL = peol 
    inductionOpB {_} {p} pv pinvol peol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv pinvol peol popol x1) (inductionOpB {_} {p} pv pinvol peol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpInverseOL2Term2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 : (OpInverseOL2Term2 n A)) -> ((P x1) -> (P (invOL2 x1)))) -> ((P eOL2) -> (((x1 x2 : (OpInverseOL2Term2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpInverseOL2Term2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 (invOL2 x1) = (pinvol2 _ (inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 eOL2 = peol2 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 x2)) 
    invL' : (InverseLTerm -> InverseLTerm)
    invL' x1 = (invL x1) 
    eL' : InverseLTerm
    eL'  = eL 
    opL' : (InverseLTerm -> (InverseLTerm -> InverseLTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (InverseLTerm -> (Staged InverseLTerm))
    stageB (invL x1) = (stage1 invL' (codeLift1 invL') (stageB x1)) 
    stageB eL = (Now eL) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    invCl' : {A : Set} -> ((ClInverseClTerm A) -> (ClInverseClTerm A))
    invCl' x1 = (invCl x1) 
    eCl' : {A : Set} -> (ClInverseClTerm A)
    eCl'  = eCl 
    opCl' : {A : Set} -> ((ClInverseClTerm A) -> ((ClInverseClTerm A) -> (ClInverseClTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClInverseClTerm A) -> (Staged (ClInverseClTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (invCl x1) = (stage1 invCl' (codeLift1 invCl') (stageCl x1)) 
    stageCl eCl = (Now eCl) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    invOL' : {n : Nat} -> ((OpInverseOLTerm n) -> (OpInverseOLTerm n))
    invOL' x1 = (invOL x1) 
    eOL' : {n : Nat} -> (OpInverseOLTerm n)
    eOL'  = eOL 
    opOL' : {n : Nat} -> ((OpInverseOLTerm n) -> ((OpInverseOLTerm n) -> (OpInverseOLTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpInverseOLTerm n) -> (Staged (OpInverseOLTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (invOL x1) = (stage1 invOL' (codeLift1 invOL') (stageOpB x1)) 
    stageOpB eOL = (Now eOL) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    invOL2' : {n : Nat} {A : Set} -> ((OpInverseOL2Term2 n A) -> (OpInverseOL2Term2 n A))
    invOL2' x1 = (invOL2 x1) 
    eOL2' : {n : Nat} {A : Set} -> (OpInverseOL2Term2 n A)
    eOL2'  = eOL2 
    opOL2' : {n : Nat} {A : Set} -> ((OpInverseOL2Term2 n A) -> ((OpInverseOL2Term2 n A) -> (OpInverseOL2Term2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpInverseOL2Term2 n A) -> (Staged (OpInverseOL2Term2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (invOL2 x1) = (stage1 invOL2' (codeLift1 invOL2') (stageOp x1)) 
    stageOp eOL2 = (Now eOL2) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        invT : ((Repr A) -> (Repr A))
        eT : (Repr A)
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module InverseSig  where
    record InverseSig (A : Set) : Set where
      constructor InverseSigC
      field
        inv : (A -> A)
        e : A
        op : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        invS : (AS -> AS)
        eS : AS
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        invP : ((Prod A A) -> (Prod A A))
        eP : (Prod A A)
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
    record Hom {A1 : Set} {A2 : Set} (In1 : (InverseSig A1)) (In2 : (InverseSig A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-inv : {x1 : A1} -> (hom ((inv In1) x1)) == ((inv In2) (hom x1))
        pres-e : (hom (e In1)) == (e In2)
        pres-op : {x1 x2 : A1} -> (hom ((op In1) x1 x2)) == ((op In2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (In1 : (InverseSig A1)) (In2 : (InverseSig A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-inv : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((inv In1) x1) ((inv In2) y1)))
        interp-e : (interp (e In1) (e In2))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op In1) x1 x2) ((op In2) y1 y2))))
    data InverseSigTerm  : Set where
      invL : (InverseSigTerm -> InverseSigTerm)
      eL : InverseSigTerm
      opL : (InverseSigTerm -> (InverseSigTerm -> InverseSigTerm))
    data ClInverseSigTerm (A : Set) : Set where
      sing : (A -> (ClInverseSigTerm A))
      invCl : ((ClInverseSigTerm A) -> (ClInverseSigTerm A))
      eCl : (ClInverseSigTerm A)
      opCl : ((ClInverseSigTerm A) -> ((ClInverseSigTerm A) -> (ClInverseSigTerm A)))
    data OpInverseSigTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpInverseSigTerm n))
      invOL : ((OpInverseSigTerm n) -> (OpInverseSigTerm n))
      eOL : (OpInverseSigTerm n)
      opOL : ((OpInverseSigTerm n) -> ((OpInverseSigTerm n) -> (OpInverseSigTerm n)))
    data OpInverseSigTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpInverseSigTerm2 n A))
      sing2 : (A -> (OpInverseSigTerm2 n A))
      invOL2 : ((OpInverseSigTerm2 n A) -> (OpInverseSigTerm2 n A))
      eOL2 : (OpInverseSigTerm2 n A)
      opOL2 : ((OpInverseSigTerm2 n A) -> ((OpInverseSigTerm2 n A) -> (OpInverseSigTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClInverseSigTerm A) -> (ClInverseSigTerm A))
    simplifyCl (invCl x1) = (invCl (simplifyCl x1)) 
    simplifyCl eCl = eCl 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpInverseSigTerm n) -> (OpInverseSigTerm n))
    simplifyOpB (invOL x1) = (invOL (simplifyOpB x1)) 
    simplifyOpB eOL = eOL 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpInverseSigTerm2 n A) -> (OpInverseSigTerm2 n A))
    simplifyOp (invOL2 x1) = (invOL2 (simplifyOp x1)) 
    simplifyOp eOL2 = eOL2 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((InverseSig A) -> (InverseSigTerm -> A))
    evalB In (invL x1) = ((inv In) (evalB In x1)) 
    evalB In eL = (e In) 
    evalB In (opL x1 x2) = ((op In) (evalB In x1) (evalB In x2)) 
    evalCl : {A : Set} -> ((InverseSig A) -> ((ClInverseSigTerm A) -> A))
    evalCl In (sing x1) = x1 
    evalCl In (invCl x1) = ((inv In) (evalCl In x1)) 
    evalCl In eCl = (e In) 
    evalCl In (opCl x1 x2) = ((op In) (evalCl In x1) (evalCl In x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((InverseSig A) -> ((Vec A n) -> ((OpInverseSigTerm n) -> A)))
    evalOpB In vars (v x1) = (lookup _ x1 vars) 
    evalOpB In vars (invOL x1) = ((inv In) (evalOpB In vars x1)) 
    evalOpB In vars eOL = (e In) 
    evalOpB In vars (opOL x1 x2) = ((op In) (evalOpB In vars x1) (evalOpB In vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((InverseSig A) -> ((Vec A n) -> ((OpInverseSigTerm2 n A) -> A)))
    evalOp In vars (v2 x1) = (lookup _ x1 vars) 
    evalOp In vars (sing2 x1) = x1 
    evalOp In vars (invOL2 x1) = ((inv In) (evalOp In vars x1)) 
    evalOp In vars eOL2 = (e In) 
    evalOp In vars (opOL2 x1 x2) = ((op In) (evalOp In vars x1) (evalOp In vars x2)) 
    inductionB : {P : (InverseSigTerm -> Set)} -> (((x1 : InverseSigTerm) -> ((P x1) -> (P (invL x1)))) -> ((P eL) -> (((x1 x2 : InverseSigTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : InverseSigTerm) -> (P x)))))
    inductionB {p} pinvl pel popl (invL x1) = (pinvl _ (inductionB {p} pinvl pel popl x1)) 
    inductionB {p} pinvl pel popl eL = pel 
    inductionB {p} pinvl pel popl (opL x1 x2) = (popl _ _ (inductionB {p} pinvl pel popl x1) (inductionB {p} pinvl pel popl x2)) 
    inductionCl : {A : Set} {P : ((ClInverseSigTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 : (ClInverseSigTerm A)) -> ((P x1) -> (P (invCl x1)))) -> ((P eCl) -> (((x1 x2 : (ClInverseSigTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClInverseSigTerm A)) -> (P x))))))
    inductionCl {_} {p} psing pinvcl pecl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pinvcl pecl popcl (invCl x1) = (pinvcl _ (inductionCl {_} {p} psing pinvcl pecl popcl x1)) 
    inductionCl {_} {p} psing pinvcl pecl popcl eCl = pecl 
    inductionCl {_} {p} psing pinvcl pecl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing pinvcl pecl popcl x1) (inductionCl {_} {p} psing pinvcl pecl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpInverseSigTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 : (OpInverseSigTerm n)) -> ((P x1) -> (P (invOL x1)))) -> ((P eOL) -> (((x1 x2 : (OpInverseSigTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpInverseSigTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv pinvol peol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pinvol peol popol (invOL x1) = (pinvol _ (inductionOpB {_} {p} pv pinvol peol popol x1)) 
    inductionOpB {_} {p} pv pinvol peol popol eOL = peol 
    inductionOpB {_} {p} pv pinvol peol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv pinvol peol popol x1) (inductionOpB {_} {p} pv pinvol peol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpInverseSigTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 : (OpInverseSigTerm2 n A)) -> ((P x1) -> (P (invOL2 x1)))) -> ((P eOL2) -> (((x1 x2 : (OpInverseSigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpInverseSigTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 (invOL2 x1) = (pinvol2 _ (inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 eOL2 = peol2 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 x2)) 
    invL' : (InverseSigTerm -> InverseSigTerm)
    invL' x1 = (invL x1) 
    eL' : InverseSigTerm
    eL'  = eL 
    opL' : (InverseSigTerm -> (InverseSigTerm -> InverseSigTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (InverseSigTerm -> (Staged InverseSigTerm))
    stageB (invL x1) = (stage1 invL' (codeLift1 invL') (stageB x1)) 
    stageB eL = (Now eL) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    invCl' : {A : Set} -> ((ClInverseSigTerm A) -> (ClInverseSigTerm A))
    invCl' x1 = (invCl x1) 
    eCl' : {A : Set} -> (ClInverseSigTerm A)
    eCl'  = eCl 
    opCl' : {A : Set} -> ((ClInverseSigTerm A) -> ((ClInverseSigTerm A) -> (ClInverseSigTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClInverseSigTerm A) -> (Staged (ClInverseSigTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (invCl x1) = (stage1 invCl' (codeLift1 invCl') (stageCl x1)) 
    stageCl eCl = (Now eCl) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    invOL' : {n : Nat} -> ((OpInverseSigTerm n) -> (OpInverseSigTerm n))
    invOL' x1 = (invOL x1) 
    eOL' : {n : Nat} -> (OpInverseSigTerm n)
    eOL'  = eOL 
    opOL' : {n : Nat} -> ((OpInverseSigTerm n) -> ((OpInverseSigTerm n) -> (OpInverseSigTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpInverseSigTerm n) -> (Staged (OpInverseSigTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (invOL x1) = (stage1 invOL' (codeLift1 invOL') (stageOpB x1)) 
    stageOpB eOL = (Now eOL) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    invOL2' : {n : Nat} {A : Set} -> ((OpInverseSigTerm2 n A) -> (OpInverseSigTerm2 n A))
    invOL2' x1 = (invOL2 x1) 
    eOL2' : {n : Nat} {A : Set} -> (OpInverseSigTerm2 n A)
    eOL2'  = eOL2 
    opOL2' : {n : Nat} {A : Set} -> ((OpInverseSigTerm2 n A) -> ((OpInverseSigTerm2 n A) -> (OpInverseSigTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpInverseSigTerm2 n A) -> (Staged (OpInverseSigTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (invOL2 x1) = (stage1 invOL2' (codeLift1 invOL2') (stageOp x1)) 
    stageOp eOL2 = (Now eOL2) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        invT : ((Repr A) -> (Repr A))
        eT : (Repr A)
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module InverseUnaryOperation  where
    record InverseUnaryOperation (A : Set) : Set where
      constructor InverseUnaryOperationC
      field
        inv : (A -> A)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        invS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        invP : ((Prod A A) -> (Prod A A))
    record Hom {A1 : Set} {A2 : Set} (In1 : (InverseUnaryOperation A1)) (In2 : (InverseUnaryOperation A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-inv : {x1 : A1} -> (hom ((inv In1) x1)) == ((inv In2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (In1 : (InverseUnaryOperation A1)) (In2 : (InverseUnaryOperation A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-inv : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((inv In1) x1) ((inv In2) y1)))
    data InverseUnaryOperationTerm  : Set where
      invL : (InverseUnaryOperationTerm -> InverseUnaryOperationTerm)
    data ClInverseUnaryOperationTerm (A : Set) : Set where
      sing : (A -> (ClInverseUnaryOperationTerm A))
      invCl : ((ClInverseUnaryOperationTerm A) -> (ClInverseUnaryOperationTerm A))
    data OpInverseUnaryOperationTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpInverseUnaryOperationTerm n))
      invOL : ((OpInverseUnaryOperationTerm n) -> (OpInverseUnaryOperationTerm n))
    data OpInverseUnaryOperationTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpInverseUnaryOperationTerm2 n A))
      sing2 : (A -> (OpInverseUnaryOperationTerm2 n A))
      invOL2 : ((OpInverseUnaryOperationTerm2 n A) -> (OpInverseUnaryOperationTerm2 n A))
    simplifyCl : {A : Set} -> ((ClInverseUnaryOperationTerm A) -> (ClInverseUnaryOperationTerm A))
    simplifyCl (invCl x1) = (invCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpInverseUnaryOperationTerm n) -> (OpInverseUnaryOperationTerm n))
    simplifyOpB (invOL x1) = (invOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpInverseUnaryOperationTerm2 n A) -> (OpInverseUnaryOperationTerm2 n A))
    simplifyOp (invOL2 x1) = (invOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((InverseUnaryOperation A) -> (InverseUnaryOperationTerm -> A))
    evalB In (invL x1) = ((inv In) (evalB In x1)) 
    evalCl : {A : Set} -> ((InverseUnaryOperation A) -> ((ClInverseUnaryOperationTerm A) -> A))
    evalCl In (sing x1) = x1 
    evalCl In (invCl x1) = ((inv In) (evalCl In x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((InverseUnaryOperation A) -> ((Vec A n) -> ((OpInverseUnaryOperationTerm n) -> A)))
    evalOpB In vars (v x1) = (lookup _ x1 vars) 
    evalOpB In vars (invOL x1) = ((inv In) (evalOpB In vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((InverseUnaryOperation A) -> ((Vec A n) -> ((OpInverseUnaryOperationTerm2 n A) -> A)))
    evalOp In vars (v2 x1) = (lookup _ x1 vars) 
    evalOp In vars (sing2 x1) = x1 
    evalOp In vars (invOL2 x1) = ((inv In) (evalOp In vars x1)) 
    inductionB : {P : (InverseUnaryOperationTerm -> Set)} -> (((x1 : InverseUnaryOperationTerm) -> ((P x1) -> (P (invL x1)))) -> ((x : InverseUnaryOperationTerm) -> (P x)))
    inductionB {p} pinvl (invL x1) = (pinvl _ (inductionB {p} pinvl x1)) 
    inductionCl : {A : Set} {P : ((ClInverseUnaryOperationTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 : (ClInverseUnaryOperationTerm A)) -> ((P x1) -> (P (invCl x1)))) -> ((x : (ClInverseUnaryOperationTerm A)) -> (P x))))
    inductionCl {_} {p} psing pinvcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pinvcl (invCl x1) = (pinvcl _ (inductionCl {_} {p} psing pinvcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpInverseUnaryOperationTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 : (OpInverseUnaryOperationTerm n)) -> ((P x1) -> (P (invOL x1)))) -> ((x : (OpInverseUnaryOperationTerm n)) -> (P x))))
    inductionOpB {_} {p} pv pinvol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pinvol (invOL x1) = (pinvol _ (inductionOpB {_} {p} pv pinvol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpInverseUnaryOperationTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 : (OpInverseUnaryOperationTerm2 n A)) -> ((P x1) -> (P (invOL2 x1)))) -> ((x : (OpInverseUnaryOperationTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 (invOL2 x1) = (pinvol2 _ (inductionOp {_} {_} {p} pv2 psing2 pinvol2 x1)) 
    invL' : (InverseUnaryOperationTerm -> InverseUnaryOperationTerm)
    invL' x1 = (invL x1) 
    stageB : (InverseUnaryOperationTerm -> (Staged InverseUnaryOperationTerm))
    stageB (invL x1) = (stage1 invL' (codeLift1 invL') (stageB x1)) 
    invCl' : {A : Set} -> ((ClInverseUnaryOperationTerm A) -> (ClInverseUnaryOperationTerm A))
    invCl' x1 = (invCl x1) 
    stageCl : {A : Set} -> ((ClInverseUnaryOperationTerm A) -> (Staged (ClInverseUnaryOperationTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (invCl x1) = (stage1 invCl' (codeLift1 invCl') (stageCl x1)) 
    invOL' : {n : Nat} -> ((OpInverseUnaryOperationTerm n) -> (OpInverseUnaryOperationTerm n))
    invOL' x1 = (invOL x1) 
    stageOpB : {n : Nat} -> ((OpInverseUnaryOperationTerm n) -> (Staged (OpInverseUnaryOperationTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (invOL x1) = (stage1 invOL' (codeLift1 invOL') (stageOpB x1)) 
    invOL2' : {n : Nat} {A : Set} -> ((OpInverseUnaryOperationTerm2 n A) -> (OpInverseUnaryOperationTerm2 n A))
    invOL2' x1 = (invOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpInverseUnaryOperationTerm2 n A) -> (Staged (OpInverseUnaryOperationTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (invOL2 x1) = (stage1 invOL2' (codeLift1 invOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        invT : ((Repr A) -> (Repr A))
  module Involution  where
    record Involution (A : Set) : Set where
      constructor InvolutionC
      field
        prim : (A -> A)
        involutive_prim : {x : A} -> (prim (prim x)) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        primS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        primP : ((Prod A A) -> (Prod A A))
        involutive_primP : {xP : (Prod A A)} -> (primP (primP xP)) == xP
    record Hom {A1 : Set} {A2 : Set} (In1 : (Involution A1)) (In2 : (Involution A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-prim : {x1 : A1} -> (hom ((prim In1) x1)) == ((prim In2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (In1 : (Involution A1)) (In2 : (Involution A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim In1) x1) ((prim In2) y1)))
    data InvolutionTerm  : Set where
      primL : (InvolutionTerm -> InvolutionTerm)
    data ClInvolutionTerm (A : Set) : Set where
      sing : (A -> (ClInvolutionTerm A))
      primCl : ((ClInvolutionTerm A) -> (ClInvolutionTerm A))
    data OpInvolutionTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpInvolutionTerm n))
      primOL : ((OpInvolutionTerm n) -> (OpInvolutionTerm n))
    data OpInvolutionTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpInvolutionTerm2 n A))
      sing2 : (A -> (OpInvolutionTerm2 n A))
      primOL2 : ((OpInvolutionTerm2 n A) -> (OpInvolutionTerm2 n A))
    simplifyCl : {A : Set} -> ((ClInvolutionTerm A) -> (ClInvolutionTerm A))
    simplifyCl (primCl (primCl x)) = x 
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpInvolutionTerm n) -> (OpInvolutionTerm n))
    simplifyOpB (primOL (primOL x)) = x 
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpInvolutionTerm2 n A) -> (OpInvolutionTerm2 n A))
    simplifyOp (primOL2 (primOL2 x)) = x 
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Involution A) -> (InvolutionTerm -> A))
    evalB In (primL x1) = ((prim In) (evalB In x1)) 
    evalCl : {A : Set} -> ((Involution A) -> ((ClInvolutionTerm A) -> A))
    evalCl In (sing x1) = x1 
    evalCl In (primCl x1) = ((prim In) (evalCl In x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((Involution A) -> ((Vec A n) -> ((OpInvolutionTerm n) -> A)))
    evalOpB In vars (v x1) = (lookup _ x1 vars) 
    evalOpB In vars (primOL x1) = ((prim In) (evalOpB In vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((Involution A) -> ((Vec A n) -> ((OpInvolutionTerm2 n A) -> A)))
    evalOp In vars (v2 x1) = (lookup _ x1 vars) 
    evalOp In vars (sing2 x1) = x1 
    evalOp In vars (primOL2 x1) = ((prim In) (evalOp In vars x1)) 
    inductionB : {P : (InvolutionTerm -> Set)} -> (((x1 : InvolutionTerm) -> ((P x1) -> (P (primL x1)))) -> ((x : InvolutionTerm) -> (P x)))
    inductionB {p} ppriml (primL x1) = (ppriml _ (inductionB {p} ppriml x1)) 
    inductionCl : {A : Set} {P : ((ClInvolutionTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 : (ClInvolutionTerm A)) -> ((P x1) -> (P (primCl x1)))) -> ((x : (ClInvolutionTerm A)) -> (P x))))
    inductionCl {_} {p} psing pprimcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pprimcl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing pprimcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpInvolutionTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 : (OpInvolutionTerm n)) -> ((P x1) -> (P (primOL x1)))) -> ((x : (OpInvolutionTerm n)) -> (P x))))
    inductionOpB {_} {p} pv pprimol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pprimol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv pprimol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpInvolutionTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 : (OpInvolutionTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> ((x : (OpInvolutionTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 pprimol2 x1)) 
    primL' : (InvolutionTerm -> InvolutionTerm)
    primL' x1 = (primL x1) 
    stageB : (InvolutionTerm -> (Staged InvolutionTerm))
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    primCl' : {A : Set} -> ((ClInvolutionTerm A) -> (ClInvolutionTerm A))
    primCl' x1 = (primCl x1) 
    stageCl : {A : Set} -> ((ClInvolutionTerm A) -> (Staged (ClInvolutionTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    primOL' : {n : Nat} -> ((OpInvolutionTerm n) -> (OpInvolutionTerm n))
    primOL' x1 = (primOL x1) 
    stageOpB : {n : Nat} -> ((OpInvolutionTerm n) -> (Staged (OpInvolutionTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    primOL2' : {n : Nat} {A : Set} -> ((OpInvolutionTerm2 n A) -> (OpInvolutionTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpInvolutionTerm2 n A) -> (Staged (OpInvolutionTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        primT : ((Repr A) -> (Repr A))
  module InvolutiveAddMagmaSig  where
    record InvolutiveAddMagmaSig (A : Set) : Set where
      constructor InvolutiveAddMagmaSigC
      field
        + : (A -> (A -> A))
        prim : (A -> A)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        +S : (AS -> (AS -> AS))
        primS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        primP : ((Prod A A) -> (Prod A A))
    record Hom {A1 : Set} {A2 : Set} (In1 : (InvolutiveAddMagmaSig A1)) (In2 : (InvolutiveAddMagmaSig A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ In1) x1 x2)) == ((+ In2) (hom x1) (hom x2))
        pres-prim : {x1 : A1} -> (hom ((prim In1) x1)) == ((prim In2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (In1 : (InvolutiveAddMagmaSig A1)) (In2 : (InvolutiveAddMagmaSig A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ In1) x1 x2) ((+ In2) y1 y2))))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim In1) x1) ((prim In2) y1)))
    data InvolutiveAddMagmaSigTerm  : Set where
      +L : (InvolutiveAddMagmaSigTerm -> (InvolutiveAddMagmaSigTerm -> InvolutiveAddMagmaSigTerm))
      primL : (InvolutiveAddMagmaSigTerm -> InvolutiveAddMagmaSigTerm)
    data ClInvolutiveAddMagmaSigTerm (A : Set) : Set where
      sing : (A -> (ClInvolutiveAddMagmaSigTerm A))
      +Cl : ((ClInvolutiveAddMagmaSigTerm A) -> ((ClInvolutiveAddMagmaSigTerm A) -> (ClInvolutiveAddMagmaSigTerm A)))
      primCl : ((ClInvolutiveAddMagmaSigTerm A) -> (ClInvolutiveAddMagmaSigTerm A))
    data OpInvolutiveAddMagmaSigTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpInvolutiveAddMagmaSigTerm n))
      +OL : ((OpInvolutiveAddMagmaSigTerm n) -> ((OpInvolutiveAddMagmaSigTerm n) -> (OpInvolutiveAddMagmaSigTerm n)))
      primOL : ((OpInvolutiveAddMagmaSigTerm n) -> (OpInvolutiveAddMagmaSigTerm n))
    data OpInvolutiveAddMagmaSigTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpInvolutiveAddMagmaSigTerm2 n A))
      sing2 : (A -> (OpInvolutiveAddMagmaSigTerm2 n A))
      +OL2 : ((OpInvolutiveAddMagmaSigTerm2 n A) -> ((OpInvolutiveAddMagmaSigTerm2 n A) -> (OpInvolutiveAddMagmaSigTerm2 n A)))
      primOL2 : ((OpInvolutiveAddMagmaSigTerm2 n A) -> (OpInvolutiveAddMagmaSigTerm2 n A))
    simplifyCl : {A : Set} -> ((ClInvolutiveAddMagmaSigTerm A) -> (ClInvolutiveAddMagmaSigTerm A))
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpInvolutiveAddMagmaSigTerm n) -> (OpInvolutiveAddMagmaSigTerm n))
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpInvolutiveAddMagmaSigTerm2 n A) -> (OpInvolutiveAddMagmaSigTerm2 n A))
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((InvolutiveAddMagmaSig A) -> (InvolutiveAddMagmaSigTerm -> A))
    evalB In (+L x1 x2) = ((+ In) (evalB In x1) (evalB In x2)) 
    evalB In (primL x1) = ((prim In) (evalB In x1)) 
    evalCl : {A : Set} -> ((InvolutiveAddMagmaSig A) -> ((ClInvolutiveAddMagmaSigTerm A) -> A))
    evalCl In (sing x1) = x1 
    evalCl In (+Cl x1 x2) = ((+ In) (evalCl In x1) (evalCl In x2)) 
    evalCl In (primCl x1) = ((prim In) (evalCl In x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((InvolutiveAddMagmaSig A) -> ((Vec A n) -> ((OpInvolutiveAddMagmaSigTerm n) -> A)))
    evalOpB In vars (v x1) = (lookup _ x1 vars) 
    evalOpB In vars (+OL x1 x2) = ((+ In) (evalOpB In vars x1) (evalOpB In vars x2)) 
    evalOpB In vars (primOL x1) = ((prim In) (evalOpB In vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((InvolutiveAddMagmaSig A) -> ((Vec A n) -> ((OpInvolutiveAddMagmaSigTerm2 n A) -> A)))
    evalOp In vars (v2 x1) = (lookup _ x1 vars) 
    evalOp In vars (sing2 x1) = x1 
    evalOp In vars (+OL2 x1 x2) = ((+ In) (evalOp In vars x1) (evalOp In vars x2)) 
    evalOp In vars (primOL2 x1) = ((prim In) (evalOp In vars x1)) 
    inductionB : {P : (InvolutiveAddMagmaSigTerm -> Set)} -> (((x1 x2 : InvolutiveAddMagmaSigTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> (((x1 : InvolutiveAddMagmaSigTerm) -> ((P x1) -> (P (primL x1)))) -> ((x : InvolutiveAddMagmaSigTerm) -> (P x))))
    inductionB {p} p+l ppriml (+L x1 x2) = (p+l _ _ (inductionB {p} p+l ppriml x1) (inductionB {p} p+l ppriml x2)) 
    inductionB {p} p+l ppriml (primL x1) = (ppriml _ (inductionB {p} p+l ppriml x1)) 
    inductionCl : {A : Set} {P : ((ClInvolutiveAddMagmaSigTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClInvolutiveAddMagmaSigTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> (((x1 : (ClInvolutiveAddMagmaSigTerm A)) -> ((P x1) -> (P (primCl x1)))) -> ((x : (ClInvolutiveAddMagmaSigTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p+cl pprimcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p+cl pprimcl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p+cl pprimcl x1) (inductionCl {_} {p} psing p+cl pprimcl x2)) 
    inductionCl {_} {p} psing p+cl pprimcl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing p+cl pprimcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpInvolutiveAddMagmaSigTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpInvolutiveAddMagmaSigTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> (((x1 : (OpInvolutiveAddMagmaSigTerm n)) -> ((P x1) -> (P (primOL x1)))) -> ((x : (OpInvolutiveAddMagmaSigTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p+ol pprimol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p+ol pprimol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p+ol pprimol x1) (inductionOpB {_} {p} pv p+ol pprimol x2)) 
    inductionOpB {_} {p} pv p+ol pprimol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv p+ol pprimol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpInvolutiveAddMagmaSigTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpInvolutiveAddMagmaSigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> (((x1 : (OpInvolutiveAddMagmaSigTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> ((x : (OpInvolutiveAddMagmaSigTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 pprimol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 pprimol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 pprimol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 pprimol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 pprimol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 pprimol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 pprimol2 x1)) 
    +L' : (InvolutiveAddMagmaSigTerm -> (InvolutiveAddMagmaSigTerm -> InvolutiveAddMagmaSigTerm))
    +L' x1 x2 = (+L x1 x2) 
    primL' : (InvolutiveAddMagmaSigTerm -> InvolutiveAddMagmaSigTerm)
    primL' x1 = (primL x1) 
    stageB : (InvolutiveAddMagmaSigTerm -> (Staged InvolutiveAddMagmaSigTerm))
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    +Cl' : {A : Set} -> ((ClInvolutiveAddMagmaSigTerm A) -> ((ClInvolutiveAddMagmaSigTerm A) -> (ClInvolutiveAddMagmaSigTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    primCl' : {A : Set} -> ((ClInvolutiveAddMagmaSigTerm A) -> (ClInvolutiveAddMagmaSigTerm A))
    primCl' x1 = (primCl x1) 
    stageCl : {A : Set} -> ((ClInvolutiveAddMagmaSigTerm A) -> (Staged (ClInvolutiveAddMagmaSigTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    +OL' : {n : Nat} -> ((OpInvolutiveAddMagmaSigTerm n) -> ((OpInvolutiveAddMagmaSigTerm n) -> (OpInvolutiveAddMagmaSigTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    primOL' : {n : Nat} -> ((OpInvolutiveAddMagmaSigTerm n) -> (OpInvolutiveAddMagmaSigTerm n))
    primOL' x1 = (primOL x1) 
    stageOpB : {n : Nat} -> ((OpInvolutiveAddMagmaSigTerm n) -> (Staged (OpInvolutiveAddMagmaSigTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    +OL2' : {n : Nat} {A : Set} -> ((OpInvolutiveAddMagmaSigTerm2 n A) -> ((OpInvolutiveAddMagmaSigTerm2 n A) -> (OpInvolutiveAddMagmaSigTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    primOL2' : {n : Nat} {A : Set} -> ((OpInvolutiveAddMagmaSigTerm2 n A) -> (OpInvolutiveAddMagmaSigTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpInvolutiveAddMagmaSigTerm2 n A) -> (Staged (OpInvolutiveAddMagmaSigTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        primT : ((Repr A) -> (Repr A))
  module InvolutiveFixedPoint  where
    record InvolutiveFixedPoint (A : Set) : Set where
      constructor InvolutiveFixedPointC
      field
        prim : (A -> A)
        1 : A
        fixes_prim_1 : (prim 1) == 1
        involutive_prim : {x : A} -> (prim (prim x)) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        primS : (AS -> AS)
        1S : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        primP : ((Prod A A) -> (Prod A A))
        1P : (Prod A A)
        fixes_prim_1P : (primP 1P) == 1P
        involutive_primP : {xP : (Prod A A)} -> (primP (primP xP)) == xP
    record Hom {A1 : Set} {A2 : Set} (In1 : (InvolutiveFixedPoint A1)) (In2 : (InvolutiveFixedPoint A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-prim : {x1 : A1} -> (hom ((prim In1) x1)) == ((prim In2) (hom x1))
        pres-1 : (hom (1 In1)) == (1 In2)
    record RelInterp {A1 : Set} {A2 : Set} (In1 : (InvolutiveFixedPoint A1)) (In2 : (InvolutiveFixedPoint A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim In1) x1) ((prim In2) y1)))
        interp-1 : (interp (1 In1) (1 In2))
    data InvolutiveFixedPointTerm  : Set where
      primL : (InvolutiveFixedPointTerm -> InvolutiveFixedPointTerm)
      1L : InvolutiveFixedPointTerm
    data ClInvolutiveFixedPointTerm (A : Set) : Set where
      sing : (A -> (ClInvolutiveFixedPointTerm A))
      primCl : ((ClInvolutiveFixedPointTerm A) -> (ClInvolutiveFixedPointTerm A))
      1Cl : (ClInvolutiveFixedPointTerm A)
    data OpInvolutiveFixedPointTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpInvolutiveFixedPointTerm n))
      primOL : ((OpInvolutiveFixedPointTerm n) -> (OpInvolutiveFixedPointTerm n))
      1OL : (OpInvolutiveFixedPointTerm n)
    data OpInvolutiveFixedPointTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpInvolutiveFixedPointTerm2 n A))
      sing2 : (A -> (OpInvolutiveFixedPointTerm2 n A))
      primOL2 : ((OpInvolutiveFixedPointTerm2 n A) -> (OpInvolutiveFixedPointTerm2 n A))
      1OL2 : (OpInvolutiveFixedPointTerm2 n A)
    simplifyCl : {A : Set} -> ((ClInvolutiveFixedPointTerm A) -> (ClInvolutiveFixedPointTerm A))
    simplifyCl (primCl 1Cl) = 1Cl 
    simplifyCl (primCl (primCl x)) = x 
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpInvolutiveFixedPointTerm n) -> (OpInvolutiveFixedPointTerm n))
    simplifyOpB (primOL 1OL) = 1OL 
    simplifyOpB (primOL (primOL x)) = x 
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpInvolutiveFixedPointTerm2 n A) -> (OpInvolutiveFixedPointTerm2 n A))
    simplifyOp (primOL2 1OL2) = 1OL2 
    simplifyOp (primOL2 (primOL2 x)) = x 
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((InvolutiveFixedPoint A) -> (InvolutiveFixedPointTerm -> A))
    evalB In (primL x1) = ((prim In) (evalB In x1)) 
    evalB In 1L = (1 In) 
    evalCl : {A : Set} -> ((InvolutiveFixedPoint A) -> ((ClInvolutiveFixedPointTerm A) -> A))
    evalCl In (sing x1) = x1 
    evalCl In (primCl x1) = ((prim In) (evalCl In x1)) 
    evalCl In 1Cl = (1 In) 
    evalOpB : {A : Set} {n : Nat} -> ((InvolutiveFixedPoint A) -> ((Vec A n) -> ((OpInvolutiveFixedPointTerm n) -> A)))
    evalOpB In vars (v x1) = (lookup _ x1 vars) 
    evalOpB In vars (primOL x1) = ((prim In) (evalOpB In vars x1)) 
    evalOpB In vars 1OL = (1 In) 
    evalOp : {A : Set} {n : Nat} -> ((InvolutiveFixedPoint A) -> ((Vec A n) -> ((OpInvolutiveFixedPointTerm2 n A) -> A)))
    evalOp In vars (v2 x1) = (lookup _ x1 vars) 
    evalOp In vars (sing2 x1) = x1 
    evalOp In vars (primOL2 x1) = ((prim In) (evalOp In vars x1)) 
    evalOp In vars 1OL2 = (1 In) 
    inductionB : {P : (InvolutiveFixedPointTerm -> Set)} -> (((x1 : InvolutiveFixedPointTerm) -> ((P x1) -> (P (primL x1)))) -> ((P 1L) -> ((x : InvolutiveFixedPointTerm) -> (P x))))
    inductionB {p} ppriml p1l (primL x1) = (ppriml _ (inductionB {p} ppriml p1l x1)) 
    inductionB {p} ppriml p1l 1L = p1l 
    inductionCl : {A : Set} {P : ((ClInvolutiveFixedPointTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 : (ClInvolutiveFixedPointTerm A)) -> ((P x1) -> (P (primCl x1)))) -> ((P 1Cl) -> ((x : (ClInvolutiveFixedPointTerm A)) -> (P x)))))
    inductionCl {_} {p} psing pprimcl p1cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pprimcl p1cl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing pprimcl p1cl x1)) 
    inductionCl {_} {p} psing pprimcl p1cl 1Cl = p1cl 
    inductionOpB : {n : Nat} {P : ((OpInvolutiveFixedPointTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 : (OpInvolutiveFixedPointTerm n)) -> ((P x1) -> (P (primOL x1)))) -> ((P 1OL) -> ((x : (OpInvolutiveFixedPointTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv pprimol p1ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pprimol p1ol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv pprimol p1ol x1)) 
    inductionOpB {_} {p} pv pprimol p1ol 1OL = p1ol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpInvolutiveFixedPointTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 : (OpInvolutiveFixedPointTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> ((P 1OL2) -> ((x : (OpInvolutiveFixedPointTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 p1ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 p1ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 p1ol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 pprimol2 p1ol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 p1ol2 1OL2 = p1ol2 
    primL' : (InvolutiveFixedPointTerm -> InvolutiveFixedPointTerm)
    primL' x1 = (primL x1) 
    1L' : InvolutiveFixedPointTerm
    1L'  = 1L 
    stageB : (InvolutiveFixedPointTerm -> (Staged InvolutiveFixedPointTerm))
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    stageB 1L = (Now 1L) 
    primCl' : {A : Set} -> ((ClInvolutiveFixedPointTerm A) -> (ClInvolutiveFixedPointTerm A))
    primCl' x1 = (primCl x1) 
    1Cl' : {A : Set} -> (ClInvolutiveFixedPointTerm A)
    1Cl'  = 1Cl 
    stageCl : {A : Set} -> ((ClInvolutiveFixedPointTerm A) -> (Staged (ClInvolutiveFixedPointTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    stageCl 1Cl = (Now 1Cl) 
    primOL' : {n : Nat} -> ((OpInvolutiveFixedPointTerm n) -> (OpInvolutiveFixedPointTerm n))
    primOL' x1 = (primOL x1) 
    1OL' : {n : Nat} -> (OpInvolutiveFixedPointTerm n)
    1OL'  = 1OL 
    stageOpB : {n : Nat} -> ((OpInvolutiveFixedPointTerm n) -> (Staged (OpInvolutiveFixedPointTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    stageOpB 1OL = (Now 1OL) 
    primOL2' : {n : Nat} {A : Set} -> ((OpInvolutiveFixedPointTerm2 n A) -> (OpInvolutiveFixedPointTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    1OL2' : {n : Nat} {A : Set} -> (OpInvolutiveFixedPointTerm2 n A)
    1OL2'  = 1OL2 
    stageOp : {n : Nat} {A : Set} -> ((OpInvolutiveFixedPointTerm2 n A) -> (Staged (OpInvolutiveFixedPointTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    stageOp 1OL2 = (Now 1OL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        primT : ((Repr A) -> (Repr A))
        1T : (Repr A)
  module InvolutiveFixes  where
    record InvolutiveFixes (A : Set) : Set where
      constructor InvolutiveFixesC
      field
        1 : A
        prim : (A -> A)
        fixes_prim_1 : (prim 1) == 1
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        1S : AS
        primS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        1P : (Prod A A)
        primP : ((Prod A A) -> (Prod A A))
        fixes_prim_1P : (primP 1P) == 1P
    record Hom {A1 : Set} {A2 : Set} (In1 : (InvolutiveFixes A1)) (In2 : (InvolutiveFixes A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-1 : (hom (1 In1)) == (1 In2)
        pres-prim : {x1 : A1} -> (hom ((prim In1) x1)) == ((prim In2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (In1 : (InvolutiveFixes A1)) (In2 : (InvolutiveFixes A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-1 : (interp (1 In1) (1 In2))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim In1) x1) ((prim In2) y1)))
    data InvolutiveFixesTerm  : Set where
      1L : InvolutiveFixesTerm
      primL : (InvolutiveFixesTerm -> InvolutiveFixesTerm)
    data ClInvolutiveFixesTerm (A : Set) : Set where
      sing : (A -> (ClInvolutiveFixesTerm A))
      1Cl : (ClInvolutiveFixesTerm A)
      primCl : ((ClInvolutiveFixesTerm A) -> (ClInvolutiveFixesTerm A))
    data OpInvolutiveFixesTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpInvolutiveFixesTerm n))
      1OL : (OpInvolutiveFixesTerm n)
      primOL : ((OpInvolutiveFixesTerm n) -> (OpInvolutiveFixesTerm n))
    data OpInvolutiveFixesTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpInvolutiveFixesTerm2 n A))
      sing2 : (A -> (OpInvolutiveFixesTerm2 n A))
      1OL2 : (OpInvolutiveFixesTerm2 n A)
      primOL2 : ((OpInvolutiveFixesTerm2 n A) -> (OpInvolutiveFixesTerm2 n A))
    simplifyCl : {A : Set} -> ((ClInvolutiveFixesTerm A) -> (ClInvolutiveFixesTerm A))
    simplifyCl (primCl 1Cl) = 1Cl 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpInvolutiveFixesTerm n) -> (OpInvolutiveFixesTerm n))
    simplifyOpB (primOL 1OL) = 1OL 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpInvolutiveFixesTerm2 n A) -> (OpInvolutiveFixesTerm2 n A))
    simplifyOp (primOL2 1OL2) = 1OL2 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((InvolutiveFixes A) -> (InvolutiveFixesTerm -> A))
    evalB In 1L = (1 In) 
    evalB In (primL x1) = ((prim In) (evalB In x1)) 
    evalCl : {A : Set} -> ((InvolutiveFixes A) -> ((ClInvolutiveFixesTerm A) -> A))
    evalCl In (sing x1) = x1 
    evalCl In 1Cl = (1 In) 
    evalCl In (primCl x1) = ((prim In) (evalCl In x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((InvolutiveFixes A) -> ((Vec A n) -> ((OpInvolutiveFixesTerm n) -> A)))
    evalOpB In vars (v x1) = (lookup _ x1 vars) 
    evalOpB In vars 1OL = (1 In) 
    evalOpB In vars (primOL x1) = ((prim In) (evalOpB In vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((InvolutiveFixes A) -> ((Vec A n) -> ((OpInvolutiveFixesTerm2 n A) -> A)))
    evalOp In vars (v2 x1) = (lookup _ x1 vars) 
    evalOp In vars (sing2 x1) = x1 
    evalOp In vars 1OL2 = (1 In) 
    evalOp In vars (primOL2 x1) = ((prim In) (evalOp In vars x1)) 
    inductionB : {P : (InvolutiveFixesTerm -> Set)} -> ((P 1L) -> (((x1 : InvolutiveFixesTerm) -> ((P x1) -> (P (primL x1)))) -> ((x : InvolutiveFixesTerm) -> (P x))))
    inductionB {p} p1l ppriml 1L = p1l 
    inductionB {p} p1l ppriml (primL x1) = (ppriml _ (inductionB {p} p1l ppriml x1)) 
    inductionCl : {A : Set} {P : ((ClInvolutiveFixesTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 1Cl) -> (((x1 : (ClInvolutiveFixesTerm A)) -> ((P x1) -> (P (primCl x1)))) -> ((x : (ClInvolutiveFixesTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p1cl pprimcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p1cl pprimcl 1Cl = p1cl 
    inductionCl {_} {p} psing p1cl pprimcl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing p1cl pprimcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpInvolutiveFixesTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 1OL) -> (((x1 : (OpInvolutiveFixesTerm n)) -> ((P x1) -> (P (primOL x1)))) -> ((x : (OpInvolutiveFixesTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p1ol pprimol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p1ol pprimol 1OL = p1ol 
    inductionOpB {_} {p} pv p1ol pprimol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv p1ol pprimol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpInvolutiveFixesTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 1OL2) -> (((x1 : (OpInvolutiveFixesTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> ((x : (OpInvolutiveFixesTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 pprimol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 pprimol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 pprimol2 1OL2 = p1ol2 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 pprimol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 p1ol2 pprimol2 x1)) 
    1L' : InvolutiveFixesTerm
    1L'  = 1L 
    primL' : (InvolutiveFixesTerm -> InvolutiveFixesTerm)
    primL' x1 = (primL x1) 
    stageB : (InvolutiveFixesTerm -> (Staged InvolutiveFixesTerm))
    stageB 1L = (Now 1L) 
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    1Cl' : {A : Set} -> (ClInvolutiveFixesTerm A)
    1Cl'  = 1Cl 
    primCl' : {A : Set} -> ((ClInvolutiveFixesTerm A) -> (ClInvolutiveFixesTerm A))
    primCl' x1 = (primCl x1) 
    stageCl : {A : Set} -> ((ClInvolutiveFixesTerm A) -> (Staged (ClInvolutiveFixesTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 1Cl = (Now 1Cl) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    1OL' : {n : Nat} -> (OpInvolutiveFixesTerm n)
    1OL'  = 1OL 
    primOL' : {n : Nat} -> ((OpInvolutiveFixesTerm n) -> (OpInvolutiveFixesTerm n))
    primOL' x1 = (primOL x1) 
    stageOpB : {n : Nat} -> ((OpInvolutiveFixesTerm n) -> (Staged (OpInvolutiveFixesTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 1OL = (Now 1OL) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    1OL2' : {n : Nat} {A : Set} -> (OpInvolutiveFixesTerm2 n A)
    1OL2'  = 1OL2 
    primOL2' : {n : Nat} {A : Set} -> ((OpInvolutiveFixesTerm2 n A) -> (OpInvolutiveFixesTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpInvolutiveFixesTerm2 n A) -> (Staged (OpInvolutiveFixesTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 1OL2 = (Now 1OL2) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        1T : (Repr A)
        primT : ((Repr A) -> (Repr A))
  module InvolutiveMagma  where
    record InvolutiveMagma (A : Set) : Set where
      constructor InvolutiveMagmaC
      field
        prim : (A -> A)
        involutive_prim : {x : A} -> (prim (prim x)) == x
        op : (A -> (A -> A))
        antidis_prim_op : {x y : A} -> (prim (op x y)) == (op (prim y) (prim x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        primS : (AS -> AS)
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        primP : ((Prod A A) -> (Prod A A))
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        involutive_primP : {xP : (Prod A A)} -> (primP (primP xP)) == xP
        antidis_prim_opP : {xP yP : (Prod A A)} -> (primP (opP xP yP)) == (opP (primP yP) (primP xP))
    record Hom {A1 : Set} {A2 : Set} (In1 : (InvolutiveMagma A1)) (In2 : (InvolutiveMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-prim : {x1 : A1} -> (hom ((prim In1) x1)) == ((prim In2) (hom x1))
        pres-op : {x1 x2 : A1} -> (hom ((op In1) x1 x2)) == ((op In2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (In1 : (InvolutiveMagma A1)) (In2 : (InvolutiveMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim In1) x1) ((prim In2) y1)))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op In1) x1 x2) ((op In2) y1 y2))))
    data InvolutiveMagmaTerm  : Set where
      primL : (InvolutiveMagmaTerm -> InvolutiveMagmaTerm)
      opL : (InvolutiveMagmaTerm -> (InvolutiveMagmaTerm -> InvolutiveMagmaTerm))
    data ClInvolutiveMagmaTerm (A : Set) : Set where
      sing : (A -> (ClInvolutiveMagmaTerm A))
      primCl : ((ClInvolutiveMagmaTerm A) -> (ClInvolutiveMagmaTerm A))
      opCl : ((ClInvolutiveMagmaTerm A) -> ((ClInvolutiveMagmaTerm A) -> (ClInvolutiveMagmaTerm A)))
    data OpInvolutiveMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpInvolutiveMagmaTerm n))
      primOL : ((OpInvolutiveMagmaTerm n) -> (OpInvolutiveMagmaTerm n))
      opOL : ((OpInvolutiveMagmaTerm n) -> ((OpInvolutiveMagmaTerm n) -> (OpInvolutiveMagmaTerm n)))
    data OpInvolutiveMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpInvolutiveMagmaTerm2 n A))
      sing2 : (A -> (OpInvolutiveMagmaTerm2 n A))
      primOL2 : ((OpInvolutiveMagmaTerm2 n A) -> (OpInvolutiveMagmaTerm2 n A))
      opOL2 : ((OpInvolutiveMagmaTerm2 n A) -> ((OpInvolutiveMagmaTerm2 n A) -> (OpInvolutiveMagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClInvolutiveMagmaTerm A) -> (ClInvolutiveMagmaTerm A))
    simplifyCl (primCl (primCl x)) = x 
    simplifyCl (opCl (primCl y) (primCl x)) = (primCl (opCl x y)) 
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpInvolutiveMagmaTerm n) -> (OpInvolutiveMagmaTerm n))
    simplifyOpB (primOL (primOL x)) = x 
    simplifyOpB (opOL (primOL y) (primOL x)) = (primOL (opOL x y)) 
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpInvolutiveMagmaTerm2 n A) -> (OpInvolutiveMagmaTerm2 n A))
    simplifyOp (primOL2 (primOL2 x)) = x 
    simplifyOp (opOL2 (primOL2 y) (primOL2 x)) = (primOL2 (opOL2 x y)) 
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((InvolutiveMagma A) -> (InvolutiveMagmaTerm -> A))
    evalB In (primL x1) = ((prim In) (evalB In x1)) 
    evalB In (opL x1 x2) = ((op In) (evalB In x1) (evalB In x2)) 
    evalCl : {A : Set} -> ((InvolutiveMagma A) -> ((ClInvolutiveMagmaTerm A) -> A))
    evalCl In (sing x1) = x1 
    evalCl In (primCl x1) = ((prim In) (evalCl In x1)) 
    evalCl In (opCl x1 x2) = ((op In) (evalCl In x1) (evalCl In x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((InvolutiveMagma A) -> ((Vec A n) -> ((OpInvolutiveMagmaTerm n) -> A)))
    evalOpB In vars (v x1) = (lookup _ x1 vars) 
    evalOpB In vars (primOL x1) = ((prim In) (evalOpB In vars x1)) 
    evalOpB In vars (opOL x1 x2) = ((op In) (evalOpB In vars x1) (evalOpB In vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((InvolutiveMagma A) -> ((Vec A n) -> ((OpInvolutiveMagmaTerm2 n A) -> A)))
    evalOp In vars (v2 x1) = (lookup _ x1 vars) 
    evalOp In vars (sing2 x1) = x1 
    evalOp In vars (primOL2 x1) = ((prim In) (evalOp In vars x1)) 
    evalOp In vars (opOL2 x1 x2) = ((op In) (evalOp In vars x1) (evalOp In vars x2)) 
    inductionB : {P : (InvolutiveMagmaTerm -> Set)} -> (((x1 : InvolutiveMagmaTerm) -> ((P x1) -> (P (primL x1)))) -> (((x1 x2 : InvolutiveMagmaTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : InvolutiveMagmaTerm) -> (P x))))
    inductionB {p} ppriml popl (primL x1) = (ppriml _ (inductionB {p} ppriml popl x1)) 
    inductionB {p} ppriml popl (opL x1 x2) = (popl _ _ (inductionB {p} ppriml popl x1) (inductionB {p} ppriml popl x2)) 
    inductionCl : {A : Set} {P : ((ClInvolutiveMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 : (ClInvolutiveMagmaTerm A)) -> ((P x1) -> (P (primCl x1)))) -> (((x1 x2 : (ClInvolutiveMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClInvolutiveMagmaTerm A)) -> (P x)))))
    inductionCl {_} {p} psing pprimcl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pprimcl popcl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing pprimcl popcl x1)) 
    inductionCl {_} {p} psing pprimcl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing pprimcl popcl x1) (inductionCl {_} {p} psing pprimcl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpInvolutiveMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 : (OpInvolutiveMagmaTerm n)) -> ((P x1) -> (P (primOL x1)))) -> (((x1 x2 : (OpInvolutiveMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpInvolutiveMagmaTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv pprimol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pprimol popol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv pprimol popol x1)) 
    inductionOpB {_} {p} pv pprimol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv pprimol popol x1) (inductionOpB {_} {p} pv pprimol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpInvolutiveMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 : (OpInvolutiveMagmaTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> (((x1 x2 : (OpInvolutiveMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpInvolutiveMagmaTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 x2)) 
    primL' : (InvolutiveMagmaTerm -> InvolutiveMagmaTerm)
    primL' x1 = (primL x1) 
    opL' : (InvolutiveMagmaTerm -> (InvolutiveMagmaTerm -> InvolutiveMagmaTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (InvolutiveMagmaTerm -> (Staged InvolutiveMagmaTerm))
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    primCl' : {A : Set} -> ((ClInvolutiveMagmaTerm A) -> (ClInvolutiveMagmaTerm A))
    primCl' x1 = (primCl x1) 
    opCl' : {A : Set} -> ((ClInvolutiveMagmaTerm A) -> ((ClInvolutiveMagmaTerm A) -> (ClInvolutiveMagmaTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClInvolutiveMagmaTerm A) -> (Staged (ClInvolutiveMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    primOL' : {n : Nat} -> ((OpInvolutiveMagmaTerm n) -> (OpInvolutiveMagmaTerm n))
    primOL' x1 = (primOL x1) 
    opOL' : {n : Nat} -> ((OpInvolutiveMagmaTerm n) -> ((OpInvolutiveMagmaTerm n) -> (OpInvolutiveMagmaTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpInvolutiveMagmaTerm n) -> (Staged (OpInvolutiveMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    primOL2' : {n : Nat} {A : Set} -> ((OpInvolutiveMagmaTerm2 n A) -> (OpInvolutiveMagmaTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    opOL2' : {n : Nat} {A : Set} -> ((OpInvolutiveMagmaTerm2 n A) -> ((OpInvolutiveMagmaTerm2 n A) -> (OpInvolutiveMagmaTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpInvolutiveMagmaTerm2 n A) -> (Staged (OpInvolutiveMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        primT : ((Repr A) -> (Repr A))
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module InvolutiveMagmaSig  where
    record InvolutiveMagmaSig (A : Set) : Set where
      constructor InvolutiveMagmaSigC
      field
        prim : (A -> A)
        op : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        primS : (AS -> AS)
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        primP : ((Prod A A) -> (Prod A A))
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
    record Hom {A1 : Set} {A2 : Set} (In1 : (InvolutiveMagmaSig A1)) (In2 : (InvolutiveMagmaSig A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-prim : {x1 : A1} -> (hom ((prim In1) x1)) == ((prim In2) (hom x1))
        pres-op : {x1 x2 : A1} -> (hom ((op In1) x1 x2)) == ((op In2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (In1 : (InvolutiveMagmaSig A1)) (In2 : (InvolutiveMagmaSig A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim In1) x1) ((prim In2) y1)))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op In1) x1 x2) ((op In2) y1 y2))))
    data InvolutiveMagmaSigTerm  : Set where
      primL : (InvolutiveMagmaSigTerm -> InvolutiveMagmaSigTerm)
      opL : (InvolutiveMagmaSigTerm -> (InvolutiveMagmaSigTerm -> InvolutiveMagmaSigTerm))
    data ClInvolutiveMagmaSigTerm (A : Set) : Set where
      sing : (A -> (ClInvolutiveMagmaSigTerm A))
      primCl : ((ClInvolutiveMagmaSigTerm A) -> (ClInvolutiveMagmaSigTerm A))
      opCl : ((ClInvolutiveMagmaSigTerm A) -> ((ClInvolutiveMagmaSigTerm A) -> (ClInvolutiveMagmaSigTerm A)))
    data OpInvolutiveMagmaSigTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpInvolutiveMagmaSigTerm n))
      primOL : ((OpInvolutiveMagmaSigTerm n) -> (OpInvolutiveMagmaSigTerm n))
      opOL : ((OpInvolutiveMagmaSigTerm n) -> ((OpInvolutiveMagmaSigTerm n) -> (OpInvolutiveMagmaSigTerm n)))
    data OpInvolutiveMagmaSigTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpInvolutiveMagmaSigTerm2 n A))
      sing2 : (A -> (OpInvolutiveMagmaSigTerm2 n A))
      primOL2 : ((OpInvolutiveMagmaSigTerm2 n A) -> (OpInvolutiveMagmaSigTerm2 n A))
      opOL2 : ((OpInvolutiveMagmaSigTerm2 n A) -> ((OpInvolutiveMagmaSigTerm2 n A) -> (OpInvolutiveMagmaSigTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClInvolutiveMagmaSigTerm A) -> (ClInvolutiveMagmaSigTerm A))
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpInvolutiveMagmaSigTerm n) -> (OpInvolutiveMagmaSigTerm n))
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpInvolutiveMagmaSigTerm2 n A) -> (OpInvolutiveMagmaSigTerm2 n A))
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((InvolutiveMagmaSig A) -> (InvolutiveMagmaSigTerm -> A))
    evalB In (primL x1) = ((prim In) (evalB In x1)) 
    evalB In (opL x1 x2) = ((op In) (evalB In x1) (evalB In x2)) 
    evalCl : {A : Set} -> ((InvolutiveMagmaSig A) -> ((ClInvolutiveMagmaSigTerm A) -> A))
    evalCl In (sing x1) = x1 
    evalCl In (primCl x1) = ((prim In) (evalCl In x1)) 
    evalCl In (opCl x1 x2) = ((op In) (evalCl In x1) (evalCl In x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((InvolutiveMagmaSig A) -> ((Vec A n) -> ((OpInvolutiveMagmaSigTerm n) -> A)))
    evalOpB In vars (v x1) = (lookup _ x1 vars) 
    evalOpB In vars (primOL x1) = ((prim In) (evalOpB In vars x1)) 
    evalOpB In vars (opOL x1 x2) = ((op In) (evalOpB In vars x1) (evalOpB In vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((InvolutiveMagmaSig A) -> ((Vec A n) -> ((OpInvolutiveMagmaSigTerm2 n A) -> A)))
    evalOp In vars (v2 x1) = (lookup _ x1 vars) 
    evalOp In vars (sing2 x1) = x1 
    evalOp In vars (primOL2 x1) = ((prim In) (evalOp In vars x1)) 
    evalOp In vars (opOL2 x1 x2) = ((op In) (evalOp In vars x1) (evalOp In vars x2)) 
    inductionB : {P : (InvolutiveMagmaSigTerm -> Set)} -> (((x1 : InvolutiveMagmaSigTerm) -> ((P x1) -> (P (primL x1)))) -> (((x1 x2 : InvolutiveMagmaSigTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : InvolutiveMagmaSigTerm) -> (P x))))
    inductionB {p} ppriml popl (primL x1) = (ppriml _ (inductionB {p} ppriml popl x1)) 
    inductionB {p} ppriml popl (opL x1 x2) = (popl _ _ (inductionB {p} ppriml popl x1) (inductionB {p} ppriml popl x2)) 
    inductionCl : {A : Set} {P : ((ClInvolutiveMagmaSigTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 : (ClInvolutiveMagmaSigTerm A)) -> ((P x1) -> (P (primCl x1)))) -> (((x1 x2 : (ClInvolutiveMagmaSigTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClInvolutiveMagmaSigTerm A)) -> (P x)))))
    inductionCl {_} {p} psing pprimcl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pprimcl popcl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing pprimcl popcl x1)) 
    inductionCl {_} {p} psing pprimcl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing pprimcl popcl x1) (inductionCl {_} {p} psing pprimcl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpInvolutiveMagmaSigTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 : (OpInvolutiveMagmaSigTerm n)) -> ((P x1) -> (P (primOL x1)))) -> (((x1 x2 : (OpInvolutiveMagmaSigTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpInvolutiveMagmaSigTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv pprimol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pprimol popol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv pprimol popol x1)) 
    inductionOpB {_} {p} pv pprimol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv pprimol popol x1) (inductionOpB {_} {p} pv pprimol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpInvolutiveMagmaSigTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 : (OpInvolutiveMagmaSigTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> (((x1 x2 : (OpInvolutiveMagmaSigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpInvolutiveMagmaSigTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 x2)) 
    primL' : (InvolutiveMagmaSigTerm -> InvolutiveMagmaSigTerm)
    primL' x1 = (primL x1) 
    opL' : (InvolutiveMagmaSigTerm -> (InvolutiveMagmaSigTerm -> InvolutiveMagmaSigTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (InvolutiveMagmaSigTerm -> (Staged InvolutiveMagmaSigTerm))
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    primCl' : {A : Set} -> ((ClInvolutiveMagmaSigTerm A) -> (ClInvolutiveMagmaSigTerm A))
    primCl' x1 = (primCl x1) 
    opCl' : {A : Set} -> ((ClInvolutiveMagmaSigTerm A) -> ((ClInvolutiveMagmaSigTerm A) -> (ClInvolutiveMagmaSigTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClInvolutiveMagmaSigTerm A) -> (Staged (ClInvolutiveMagmaSigTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    primOL' : {n : Nat} -> ((OpInvolutiveMagmaSigTerm n) -> (OpInvolutiveMagmaSigTerm n))
    primOL' x1 = (primOL x1) 
    opOL' : {n : Nat} -> ((OpInvolutiveMagmaSigTerm n) -> ((OpInvolutiveMagmaSigTerm n) -> (OpInvolutiveMagmaSigTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpInvolutiveMagmaSigTerm n) -> (Staged (OpInvolutiveMagmaSigTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    primOL2' : {n : Nat} {A : Set} -> ((OpInvolutiveMagmaSigTerm2 n A) -> (OpInvolutiveMagmaSigTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    opOL2' : {n : Nat} {A : Set} -> ((OpInvolutiveMagmaSigTerm2 n A) -> ((OpInvolutiveMagmaSigTerm2 n A) -> (OpInvolutiveMagmaSigTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpInvolutiveMagmaSigTerm2 n A) -> (Staged (OpInvolutiveMagmaSigTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        primT : ((Repr A) -> (Repr A))
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module InvolutiveMultMagmaSig  where
    record InvolutiveMultMagmaSig (A : Set) : Set where
      constructor InvolutiveMultMagmaSigC
      field
        * : (A -> (A -> A))
        prim : (A -> A)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        primS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        primP : ((Prod A A) -> (Prod A A))
    record Hom {A1 : Set} {A2 : Set} (In1 : (InvolutiveMultMagmaSig A1)) (In2 : (InvolutiveMultMagmaSig A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* In1) x1 x2)) == ((* In2) (hom x1) (hom x2))
        pres-prim : {x1 : A1} -> (hom ((prim In1) x1)) == ((prim In2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (In1 : (InvolutiveMultMagmaSig A1)) (In2 : (InvolutiveMultMagmaSig A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* In1) x1 x2) ((* In2) y1 y2))))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim In1) x1) ((prim In2) y1)))
    data InvolutiveMultMagmaSigTerm  : Set where
      *L : (InvolutiveMultMagmaSigTerm -> (InvolutiveMultMagmaSigTerm -> InvolutiveMultMagmaSigTerm))
      primL : (InvolutiveMultMagmaSigTerm -> InvolutiveMultMagmaSigTerm)
    data ClInvolutiveMultMagmaSigTerm (A : Set) : Set where
      sing : (A -> (ClInvolutiveMultMagmaSigTerm A))
      *Cl : ((ClInvolutiveMultMagmaSigTerm A) -> ((ClInvolutiveMultMagmaSigTerm A) -> (ClInvolutiveMultMagmaSigTerm A)))
      primCl : ((ClInvolutiveMultMagmaSigTerm A) -> (ClInvolutiveMultMagmaSigTerm A))
    data OpInvolutiveMultMagmaSigTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpInvolutiveMultMagmaSigTerm n))
      *OL : ((OpInvolutiveMultMagmaSigTerm n) -> ((OpInvolutiveMultMagmaSigTerm n) -> (OpInvolutiveMultMagmaSigTerm n)))
      primOL : ((OpInvolutiveMultMagmaSigTerm n) -> (OpInvolutiveMultMagmaSigTerm n))
    data OpInvolutiveMultMagmaSigTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpInvolutiveMultMagmaSigTerm2 n A))
      sing2 : (A -> (OpInvolutiveMultMagmaSigTerm2 n A))
      *OL2 : ((OpInvolutiveMultMagmaSigTerm2 n A) -> ((OpInvolutiveMultMagmaSigTerm2 n A) -> (OpInvolutiveMultMagmaSigTerm2 n A)))
      primOL2 : ((OpInvolutiveMultMagmaSigTerm2 n A) -> (OpInvolutiveMultMagmaSigTerm2 n A))
    simplifyCl : {A : Set} -> ((ClInvolutiveMultMagmaSigTerm A) -> (ClInvolutiveMultMagmaSigTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpInvolutiveMultMagmaSigTerm n) -> (OpInvolutiveMultMagmaSigTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpInvolutiveMultMagmaSigTerm2 n A) -> (OpInvolutiveMultMagmaSigTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((InvolutiveMultMagmaSig A) -> (InvolutiveMultMagmaSigTerm -> A))
    evalB In (*L x1 x2) = ((* In) (evalB In x1) (evalB In x2)) 
    evalB In (primL x1) = ((prim In) (evalB In x1)) 
    evalCl : {A : Set} -> ((InvolutiveMultMagmaSig A) -> ((ClInvolutiveMultMagmaSigTerm A) -> A))
    evalCl In (sing x1) = x1 
    evalCl In (*Cl x1 x2) = ((* In) (evalCl In x1) (evalCl In x2)) 
    evalCl In (primCl x1) = ((prim In) (evalCl In x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((InvolutiveMultMagmaSig A) -> ((Vec A n) -> ((OpInvolutiveMultMagmaSigTerm n) -> A)))
    evalOpB In vars (v x1) = (lookup _ x1 vars) 
    evalOpB In vars (*OL x1 x2) = ((* In) (evalOpB In vars x1) (evalOpB In vars x2)) 
    evalOpB In vars (primOL x1) = ((prim In) (evalOpB In vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((InvolutiveMultMagmaSig A) -> ((Vec A n) -> ((OpInvolutiveMultMagmaSigTerm2 n A) -> A)))
    evalOp In vars (v2 x1) = (lookup _ x1 vars) 
    evalOp In vars (sing2 x1) = x1 
    evalOp In vars (*OL2 x1 x2) = ((* In) (evalOp In vars x1) (evalOp In vars x2)) 
    evalOp In vars (primOL2 x1) = ((prim In) (evalOp In vars x1)) 
    inductionB : {P : (InvolutiveMultMagmaSigTerm -> Set)} -> (((x1 x2 : InvolutiveMultMagmaSigTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 : InvolutiveMultMagmaSigTerm) -> ((P x1) -> (P (primL x1)))) -> ((x : InvolutiveMultMagmaSigTerm) -> (P x))))
    inductionB {p} p*l ppriml (*L x1 x2) = (p*l _ _ (inductionB {p} p*l ppriml x1) (inductionB {p} p*l ppriml x2)) 
    inductionB {p} p*l ppriml (primL x1) = (ppriml _ (inductionB {p} p*l ppriml x1)) 
    inductionCl : {A : Set} {P : ((ClInvolutiveMultMagmaSigTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClInvolutiveMultMagmaSigTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 : (ClInvolutiveMultMagmaSigTerm A)) -> ((P x1) -> (P (primCl x1)))) -> ((x : (ClInvolutiveMultMagmaSigTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p*cl pprimcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl pprimcl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl pprimcl x1) (inductionCl {_} {p} psing p*cl pprimcl x2)) 
    inductionCl {_} {p} psing p*cl pprimcl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing p*cl pprimcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpInvolutiveMultMagmaSigTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpInvolutiveMultMagmaSigTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 : (OpInvolutiveMultMagmaSigTerm n)) -> ((P x1) -> (P (primOL x1)))) -> ((x : (OpInvolutiveMultMagmaSigTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p*ol pprimol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol pprimol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol pprimol x1) (inductionOpB {_} {p} pv p*ol pprimol x2)) 
    inductionOpB {_} {p} pv p*ol pprimol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv p*ol pprimol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpInvolutiveMultMagmaSigTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpInvolutiveMultMagmaSigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 : (OpInvolutiveMultMagmaSigTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> ((x : (OpInvolutiveMultMagmaSigTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 pprimol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 pprimol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 pprimol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 pprimol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 pprimol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 pprimol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 pprimol2 x1)) 
    *L' : (InvolutiveMultMagmaSigTerm -> (InvolutiveMultMagmaSigTerm -> InvolutiveMultMagmaSigTerm))
    *L' x1 x2 = (*L x1 x2) 
    primL' : (InvolutiveMultMagmaSigTerm -> InvolutiveMultMagmaSigTerm)
    primL' x1 = (primL x1) 
    stageB : (InvolutiveMultMagmaSigTerm -> (Staged InvolutiveMultMagmaSigTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    *Cl' : {A : Set} -> ((ClInvolutiveMultMagmaSigTerm A) -> ((ClInvolutiveMultMagmaSigTerm A) -> (ClInvolutiveMultMagmaSigTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    primCl' : {A : Set} -> ((ClInvolutiveMultMagmaSigTerm A) -> (ClInvolutiveMultMagmaSigTerm A))
    primCl' x1 = (primCl x1) 
    stageCl : {A : Set} -> ((ClInvolutiveMultMagmaSigTerm A) -> (Staged (ClInvolutiveMultMagmaSigTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    *OL' : {n : Nat} -> ((OpInvolutiveMultMagmaSigTerm n) -> ((OpInvolutiveMultMagmaSigTerm n) -> (OpInvolutiveMultMagmaSigTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    primOL' : {n : Nat} -> ((OpInvolutiveMultMagmaSigTerm n) -> (OpInvolutiveMultMagmaSigTerm n))
    primOL' x1 = (primOL x1) 
    stageOpB : {n : Nat} -> ((OpInvolutiveMultMagmaSigTerm n) -> (Staged (OpInvolutiveMultMagmaSigTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpInvolutiveMultMagmaSigTerm2 n A) -> ((OpInvolutiveMultMagmaSigTerm2 n A) -> (OpInvolutiveMultMagmaSigTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    primOL2' : {n : Nat} {A : Set} -> ((OpInvolutiveMultMagmaSigTerm2 n A) -> (OpInvolutiveMultMagmaSigTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpInvolutiveMultMagmaSigTerm2 n A) -> (Staged (OpInvolutiveMultMagmaSigTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        primT : ((Repr A) -> (Repr A))
  module InvolutivePointedMagmaSig  where
    record InvolutivePointedMagmaSig (A : Set) : Set where
      constructor InvolutivePointedMagmaSigC
      field
        prim : (A -> A)
        e : A
        op : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        primS : (AS -> AS)
        eS : AS
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        primP : ((Prod A A) -> (Prod A A))
        eP : (Prod A A)
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
    record Hom {A1 : Set} {A2 : Set} (In1 : (InvolutivePointedMagmaSig A1)) (In2 : (InvolutivePointedMagmaSig A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-prim : {x1 : A1} -> (hom ((prim In1) x1)) == ((prim In2) (hom x1))
        pres-e : (hom (e In1)) == (e In2)
        pres-op : {x1 x2 : A1} -> (hom ((op In1) x1 x2)) == ((op In2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (In1 : (InvolutivePointedMagmaSig A1)) (In2 : (InvolutivePointedMagmaSig A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim In1) x1) ((prim In2) y1)))
        interp-e : (interp (e In1) (e In2))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op In1) x1 x2) ((op In2) y1 y2))))
    data InvolutivePointedMagmaSigTerm  : Set where
      primL : (InvolutivePointedMagmaSigTerm -> InvolutivePointedMagmaSigTerm)
      eL : InvolutivePointedMagmaSigTerm
      opL : (InvolutivePointedMagmaSigTerm -> (InvolutivePointedMagmaSigTerm -> InvolutivePointedMagmaSigTerm))
    data ClInvolutivePointedMagmaSigTerm (A : Set) : Set where
      sing : (A -> (ClInvolutivePointedMagmaSigTerm A))
      primCl : ((ClInvolutivePointedMagmaSigTerm A) -> (ClInvolutivePointedMagmaSigTerm A))
      eCl : (ClInvolutivePointedMagmaSigTerm A)
      opCl : ((ClInvolutivePointedMagmaSigTerm A) -> ((ClInvolutivePointedMagmaSigTerm A) -> (ClInvolutivePointedMagmaSigTerm A)))
    data OpInvolutivePointedMagmaSigTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpInvolutivePointedMagmaSigTerm n))
      primOL : ((OpInvolutivePointedMagmaSigTerm n) -> (OpInvolutivePointedMagmaSigTerm n))
      eOL : (OpInvolutivePointedMagmaSigTerm n)
      opOL : ((OpInvolutivePointedMagmaSigTerm n) -> ((OpInvolutivePointedMagmaSigTerm n) -> (OpInvolutivePointedMagmaSigTerm n)))
    data OpInvolutivePointedMagmaSigTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpInvolutivePointedMagmaSigTerm2 n A))
      sing2 : (A -> (OpInvolutivePointedMagmaSigTerm2 n A))
      primOL2 : ((OpInvolutivePointedMagmaSigTerm2 n A) -> (OpInvolutivePointedMagmaSigTerm2 n A))
      eOL2 : (OpInvolutivePointedMagmaSigTerm2 n A)
      opOL2 : ((OpInvolutivePointedMagmaSigTerm2 n A) -> ((OpInvolutivePointedMagmaSigTerm2 n A) -> (OpInvolutivePointedMagmaSigTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClInvolutivePointedMagmaSigTerm A) -> (ClInvolutivePointedMagmaSigTerm A))
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl eCl = eCl 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpInvolutivePointedMagmaSigTerm n) -> (OpInvolutivePointedMagmaSigTerm n))
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB eOL = eOL 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpInvolutivePointedMagmaSigTerm2 n A) -> (OpInvolutivePointedMagmaSigTerm2 n A))
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp eOL2 = eOL2 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((InvolutivePointedMagmaSig A) -> (InvolutivePointedMagmaSigTerm -> A))
    evalB In (primL x1) = ((prim In) (evalB In x1)) 
    evalB In eL = (e In) 
    evalB In (opL x1 x2) = ((op In) (evalB In x1) (evalB In x2)) 
    evalCl : {A : Set} -> ((InvolutivePointedMagmaSig A) -> ((ClInvolutivePointedMagmaSigTerm A) -> A))
    evalCl In (sing x1) = x1 
    evalCl In (primCl x1) = ((prim In) (evalCl In x1)) 
    evalCl In eCl = (e In) 
    evalCl In (opCl x1 x2) = ((op In) (evalCl In x1) (evalCl In x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((InvolutivePointedMagmaSig A) -> ((Vec A n) -> ((OpInvolutivePointedMagmaSigTerm n) -> A)))
    evalOpB In vars (v x1) = (lookup _ x1 vars) 
    evalOpB In vars (primOL x1) = ((prim In) (evalOpB In vars x1)) 
    evalOpB In vars eOL = (e In) 
    evalOpB In vars (opOL x1 x2) = ((op In) (evalOpB In vars x1) (evalOpB In vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((InvolutivePointedMagmaSig A) -> ((Vec A n) -> ((OpInvolutivePointedMagmaSigTerm2 n A) -> A)))
    evalOp In vars (v2 x1) = (lookup _ x1 vars) 
    evalOp In vars (sing2 x1) = x1 
    evalOp In vars (primOL2 x1) = ((prim In) (evalOp In vars x1)) 
    evalOp In vars eOL2 = (e In) 
    evalOp In vars (opOL2 x1 x2) = ((op In) (evalOp In vars x1) (evalOp In vars x2)) 
    inductionB : {P : (InvolutivePointedMagmaSigTerm -> Set)} -> (((x1 : InvolutivePointedMagmaSigTerm) -> ((P x1) -> (P (primL x1)))) -> ((P eL) -> (((x1 x2 : InvolutivePointedMagmaSigTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : InvolutivePointedMagmaSigTerm) -> (P x)))))
    inductionB {p} ppriml pel popl (primL x1) = (ppriml _ (inductionB {p} ppriml pel popl x1)) 
    inductionB {p} ppriml pel popl eL = pel 
    inductionB {p} ppriml pel popl (opL x1 x2) = (popl _ _ (inductionB {p} ppriml pel popl x1) (inductionB {p} ppriml pel popl x2)) 
    inductionCl : {A : Set} {P : ((ClInvolutivePointedMagmaSigTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 : (ClInvolutivePointedMagmaSigTerm A)) -> ((P x1) -> (P (primCl x1)))) -> ((P eCl) -> (((x1 x2 : (ClInvolutivePointedMagmaSigTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClInvolutivePointedMagmaSigTerm A)) -> (P x))))))
    inductionCl {_} {p} psing pprimcl pecl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pprimcl pecl popcl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing pprimcl pecl popcl x1)) 
    inductionCl {_} {p} psing pprimcl pecl popcl eCl = pecl 
    inductionCl {_} {p} psing pprimcl pecl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing pprimcl pecl popcl x1) (inductionCl {_} {p} psing pprimcl pecl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpInvolutivePointedMagmaSigTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 : (OpInvolutivePointedMagmaSigTerm n)) -> ((P x1) -> (P (primOL x1)))) -> ((P eOL) -> (((x1 x2 : (OpInvolutivePointedMagmaSigTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpInvolutivePointedMagmaSigTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv pprimol peol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pprimol peol popol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv pprimol peol popol x1)) 
    inductionOpB {_} {p} pv pprimol peol popol eOL = peol 
    inductionOpB {_} {p} pv pprimol peol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv pprimol peol popol x1) (inductionOpB {_} {p} pv pprimol peol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpInvolutivePointedMagmaSigTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 : (OpInvolutivePointedMagmaSigTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> ((P eOL2) -> (((x1 x2 : (OpInvolutivePointedMagmaSigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpInvolutivePointedMagmaSigTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 peol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 peol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 peol2 popol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 pprimol2 peol2 popol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 peol2 popol2 eOL2 = peol2 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 peol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 pprimol2 peol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 pprimol2 peol2 popol2 x2)) 
    primL' : (InvolutivePointedMagmaSigTerm -> InvolutivePointedMagmaSigTerm)
    primL' x1 = (primL x1) 
    eL' : InvolutivePointedMagmaSigTerm
    eL'  = eL 
    opL' : (InvolutivePointedMagmaSigTerm -> (InvolutivePointedMagmaSigTerm -> InvolutivePointedMagmaSigTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (InvolutivePointedMagmaSigTerm -> (Staged InvolutivePointedMagmaSigTerm))
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    stageB eL = (Now eL) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    primCl' : {A : Set} -> ((ClInvolutivePointedMagmaSigTerm A) -> (ClInvolutivePointedMagmaSigTerm A))
    primCl' x1 = (primCl x1) 
    eCl' : {A : Set} -> (ClInvolutivePointedMagmaSigTerm A)
    eCl'  = eCl 
    opCl' : {A : Set} -> ((ClInvolutivePointedMagmaSigTerm A) -> ((ClInvolutivePointedMagmaSigTerm A) -> (ClInvolutivePointedMagmaSigTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClInvolutivePointedMagmaSigTerm A) -> (Staged (ClInvolutivePointedMagmaSigTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    stageCl eCl = (Now eCl) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    primOL' : {n : Nat} -> ((OpInvolutivePointedMagmaSigTerm n) -> (OpInvolutivePointedMagmaSigTerm n))
    primOL' x1 = (primOL x1) 
    eOL' : {n : Nat} -> (OpInvolutivePointedMagmaSigTerm n)
    eOL'  = eOL 
    opOL' : {n : Nat} -> ((OpInvolutivePointedMagmaSigTerm n) -> ((OpInvolutivePointedMagmaSigTerm n) -> (OpInvolutivePointedMagmaSigTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpInvolutivePointedMagmaSigTerm n) -> (Staged (OpInvolutivePointedMagmaSigTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    stageOpB eOL = (Now eOL) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    primOL2' : {n : Nat} {A : Set} -> ((OpInvolutivePointedMagmaSigTerm2 n A) -> (OpInvolutivePointedMagmaSigTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    eOL2' : {n : Nat} {A : Set} -> (OpInvolutivePointedMagmaSigTerm2 n A)
    eOL2'  = eOL2 
    opOL2' : {n : Nat} {A : Set} -> ((OpInvolutivePointedMagmaSigTerm2 n A) -> ((OpInvolutivePointedMagmaSigTerm2 n A) -> (OpInvolutivePointedMagmaSigTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpInvolutivePointedMagmaSigTerm2 n A) -> (Staged (OpInvolutivePointedMagmaSigTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    stageOp eOL2 = (Now eOL2) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        primT : ((Repr A) -> (Repr A))
        eT : (Repr A)
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module InvolutivePointedSemigroup  where
    record InvolutivePointedSemigroup (A : Set) : Set where
      constructor InvolutivePointedSemigroupC
      field
        op : (A -> (A -> A))
        e : A
        associative_op : {x y z : A} -> (op (op x y) z) == (op x (op y z))
        prim : (A -> A)
        involutive_prim : {x : A} -> (prim (prim x)) == x
        antidis_prim_op : {x y : A} -> (prim (op x y)) == (op (prim y) (prim x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        eS : AS
        primS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        eP : (Prod A A)
        primP : ((Prod A A) -> (Prod A A))
        associative_opP : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP (opP yP zP))
        involutive_primP : {xP : (Prod A A)} -> (primP (primP xP)) == xP
        antidis_prim_opP : {xP yP : (Prod A A)} -> (primP (opP xP yP)) == (opP (primP yP) (primP xP))
    record Hom {A1 : Set} {A2 : Set} (In1 : (InvolutivePointedSemigroup A1)) (In2 : (InvolutivePointedSemigroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op In1) x1 x2)) == ((op In2) (hom x1) (hom x2))
        pres-e : (hom (e In1)) == (e In2)
        pres-prim : {x1 : A1} -> (hom ((prim In1) x1)) == ((prim In2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (In1 : (InvolutivePointedSemigroup A1)) (In2 : (InvolutivePointedSemigroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op In1) x1 x2) ((op In2) y1 y2))))
        interp-e : (interp (e In1) (e In2))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim In1) x1) ((prim In2) y1)))
    data InvolutivePointedSemigroupTerm  : Set where
      opL : (InvolutivePointedSemigroupTerm -> (InvolutivePointedSemigroupTerm -> InvolutivePointedSemigroupTerm))
      eL : InvolutivePointedSemigroupTerm
      primL : (InvolutivePointedSemigroupTerm -> InvolutivePointedSemigroupTerm)
    data ClInvolutivePointedSemigroupTerm (A : Set) : Set where
      sing : (A -> (ClInvolutivePointedSemigroupTerm A))
      opCl : ((ClInvolutivePointedSemigroupTerm A) -> ((ClInvolutivePointedSemigroupTerm A) -> (ClInvolutivePointedSemigroupTerm A)))
      eCl : (ClInvolutivePointedSemigroupTerm A)
      primCl : ((ClInvolutivePointedSemigroupTerm A) -> (ClInvolutivePointedSemigroupTerm A))
    data OpInvolutivePointedSemigroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpInvolutivePointedSemigroupTerm n))
      opOL : ((OpInvolutivePointedSemigroupTerm n) -> ((OpInvolutivePointedSemigroupTerm n) -> (OpInvolutivePointedSemigroupTerm n)))
      eOL : (OpInvolutivePointedSemigroupTerm n)
      primOL : ((OpInvolutivePointedSemigroupTerm n) -> (OpInvolutivePointedSemigroupTerm n))
    data OpInvolutivePointedSemigroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpInvolutivePointedSemigroupTerm2 n A))
      sing2 : (A -> (OpInvolutivePointedSemigroupTerm2 n A))
      opOL2 : ((OpInvolutivePointedSemigroupTerm2 n A) -> ((OpInvolutivePointedSemigroupTerm2 n A) -> (OpInvolutivePointedSemigroupTerm2 n A)))
      eOL2 : (OpInvolutivePointedSemigroupTerm2 n A)
      primOL2 : ((OpInvolutivePointedSemigroupTerm2 n A) -> (OpInvolutivePointedSemigroupTerm2 n A))
    simplifyCl : {A : Set} -> ((ClInvolutivePointedSemigroupTerm A) -> (ClInvolutivePointedSemigroupTerm A))
    simplifyCl (primCl (primCl x)) = x 
    simplifyCl (opCl (primCl y) (primCl x)) = (primCl (opCl x y)) 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl eCl = eCl 
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpInvolutivePointedSemigroupTerm n) -> (OpInvolutivePointedSemigroupTerm n))
    simplifyOpB (primOL (primOL x)) = x 
    simplifyOpB (opOL (primOL y) (primOL x)) = (primOL (opOL x y)) 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB eOL = eOL 
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpInvolutivePointedSemigroupTerm2 n A) -> (OpInvolutivePointedSemigroupTerm2 n A))
    simplifyOp (primOL2 (primOL2 x)) = x 
    simplifyOp (opOL2 (primOL2 y) (primOL2 x)) = (primOL2 (opOL2 x y)) 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp eOL2 = eOL2 
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((InvolutivePointedSemigroup A) -> (InvolutivePointedSemigroupTerm -> A))
    evalB In (opL x1 x2) = ((op In) (evalB In x1) (evalB In x2)) 
    evalB In eL = (e In) 
    evalB In (primL x1) = ((prim In) (evalB In x1)) 
    evalCl : {A : Set} -> ((InvolutivePointedSemigroup A) -> ((ClInvolutivePointedSemigroupTerm A) -> A))
    evalCl In (sing x1) = x1 
    evalCl In (opCl x1 x2) = ((op In) (evalCl In x1) (evalCl In x2)) 
    evalCl In eCl = (e In) 
    evalCl In (primCl x1) = ((prim In) (evalCl In x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((InvolutivePointedSemigroup A) -> ((Vec A n) -> ((OpInvolutivePointedSemigroupTerm n) -> A)))
    evalOpB In vars (v x1) = (lookup _ x1 vars) 
    evalOpB In vars (opOL x1 x2) = ((op In) (evalOpB In vars x1) (evalOpB In vars x2)) 
    evalOpB In vars eOL = (e In) 
    evalOpB In vars (primOL x1) = ((prim In) (evalOpB In vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((InvolutivePointedSemigroup A) -> ((Vec A n) -> ((OpInvolutivePointedSemigroupTerm2 n A) -> A)))
    evalOp In vars (v2 x1) = (lookup _ x1 vars) 
    evalOp In vars (sing2 x1) = x1 
    evalOp In vars (opOL2 x1 x2) = ((op In) (evalOp In vars x1) (evalOp In vars x2)) 
    evalOp In vars eOL2 = (e In) 
    evalOp In vars (primOL2 x1) = ((prim In) (evalOp In vars x1)) 
    inductionB : {P : (InvolutivePointedSemigroupTerm -> Set)} -> (((x1 x2 : InvolutivePointedSemigroupTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((P eL) -> (((x1 : InvolutivePointedSemigroupTerm) -> ((P x1) -> (P (primL x1)))) -> ((x : InvolutivePointedSemigroupTerm) -> (P x)))))
    inductionB {p} popl pel ppriml (opL x1 x2) = (popl _ _ (inductionB {p} popl pel ppriml x1) (inductionB {p} popl pel ppriml x2)) 
    inductionB {p} popl pel ppriml eL = pel 
    inductionB {p} popl pel ppriml (primL x1) = (ppriml _ (inductionB {p} popl pel ppriml x1)) 
    inductionCl : {A : Set} {P : ((ClInvolutivePointedSemigroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClInvolutivePointedSemigroupTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((P eCl) -> (((x1 : (ClInvolutivePointedSemigroupTerm A)) -> ((P x1) -> (P (primCl x1)))) -> ((x : (ClInvolutivePointedSemigroupTerm A)) -> (P x))))))
    inductionCl {_} {p} psing popcl pecl pprimcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl pecl pprimcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl pecl pprimcl x1) (inductionCl {_} {p} psing popcl pecl pprimcl x2)) 
    inductionCl {_} {p} psing popcl pecl pprimcl eCl = pecl 
    inductionCl {_} {p} psing popcl pecl pprimcl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing popcl pecl pprimcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpInvolutivePointedSemigroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpInvolutivePointedSemigroupTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((P eOL) -> (((x1 : (OpInvolutivePointedSemigroupTerm n)) -> ((P x1) -> (P (primOL x1)))) -> ((x : (OpInvolutivePointedSemigroupTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv popol peol pprimol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol peol pprimol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol peol pprimol x1) (inductionOpB {_} {p} pv popol peol pprimol x2)) 
    inductionOpB {_} {p} pv popol peol pprimol eOL = peol 
    inductionOpB {_} {p} pv popol peol pprimol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv popol peol pprimol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpInvolutivePointedSemigroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpInvolutivePointedSemigroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((P eOL2) -> (((x1 : (OpInvolutivePointedSemigroupTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> ((x : (OpInvolutivePointedSemigroupTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 pprimol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 pprimol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 pprimol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 pprimol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 pprimol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 pprimol2 eOL2 = peol2 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 pprimol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 pprimol2 x1)) 
    opL' : (InvolutivePointedSemigroupTerm -> (InvolutivePointedSemigroupTerm -> InvolutivePointedSemigroupTerm))
    opL' x1 x2 = (opL x1 x2) 
    eL' : InvolutivePointedSemigroupTerm
    eL'  = eL 
    primL' : (InvolutivePointedSemigroupTerm -> InvolutivePointedSemigroupTerm)
    primL' x1 = (primL x1) 
    stageB : (InvolutivePointedSemigroupTerm -> (Staged InvolutivePointedSemigroupTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB eL = (Now eL) 
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    opCl' : {A : Set} -> ((ClInvolutivePointedSemigroupTerm A) -> ((ClInvolutivePointedSemigroupTerm A) -> (ClInvolutivePointedSemigroupTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    eCl' : {A : Set} -> (ClInvolutivePointedSemigroupTerm A)
    eCl'  = eCl 
    primCl' : {A : Set} -> ((ClInvolutivePointedSemigroupTerm A) -> (ClInvolutivePointedSemigroupTerm A))
    primCl' x1 = (primCl x1) 
    stageCl : {A : Set} -> ((ClInvolutivePointedSemigroupTerm A) -> (Staged (ClInvolutivePointedSemigroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl eCl = (Now eCl) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    opOL' : {n : Nat} -> ((OpInvolutivePointedSemigroupTerm n) -> ((OpInvolutivePointedSemigroupTerm n) -> (OpInvolutivePointedSemigroupTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    eOL' : {n : Nat} -> (OpInvolutivePointedSemigroupTerm n)
    eOL'  = eOL 
    primOL' : {n : Nat} -> ((OpInvolutivePointedSemigroupTerm n) -> (OpInvolutivePointedSemigroupTerm n))
    primOL' x1 = (primOL x1) 
    stageOpB : {n : Nat} -> ((OpInvolutivePointedSemigroupTerm n) -> (Staged (OpInvolutivePointedSemigroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB eOL = (Now eOL) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpInvolutivePointedSemigroupTerm2 n A) -> ((OpInvolutivePointedSemigroupTerm2 n A) -> (OpInvolutivePointedSemigroupTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    eOL2' : {n : Nat} {A : Set} -> (OpInvolutivePointedSemigroupTerm2 n A)
    eOL2'  = eOL2 
    primOL2' : {n : Nat} {A : Set} -> ((OpInvolutivePointedSemigroupTerm2 n A) -> (OpInvolutivePointedSemigroupTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpInvolutivePointedSemigroupTerm2 n A) -> (Staged (OpInvolutivePointedSemigroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp eOL2 = (Now eOL2) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        eT : (Repr A)
        primT : ((Repr A) -> (Repr A))
  module InvolutiveRing  where
    record InvolutiveRing (A : Set) : Set where
      constructor InvolutiveRingC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        1 : A
        leftDistributive_*_+ : {x y z : A} -> (* x (+ y z)) == (+ (* x y) (* x z))
        rightDistributive_*_+ : {x y z : A} -> (* (+ y z) x) == (+ (* y x) (* z x))
        prim : (A -> A)
        fixes_prim_1 : (prim 1) == 1
        involutive_prim : {x : A} -> (prim (prim x)) == x
        antidis_prim_+ : {x y : A} -> (prim (+ x y)) == (+ (prim y) (prim x))
        antidis_prim_* : {x y : A} -> (prim (* x y)) == (* (prim y) (prim x))
        0 : A
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        neg : (A -> A)
        leftInverse_inv_op_0 : {x : A} -> (+ x (neg x)) == 0
        rightInverse_inv_op_0 : {x : A} -> (+ (neg x) x) == 0
        lunit_1 : {x : A} -> (* 1 x) == x
        runit_1 : {x : A} -> (* x 1) == x
        leftZero_op_0 : {x : A} -> (* 0 x) == 0
        rightZero_op_0 : {x : A} -> (* x 0) == 0
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
        1S : AS
        primS : (AS -> AS)
        0S : AS
        negS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        1P : (Prod A A)
        primP : ((Prod A A) -> (Prod A A))
        0P : (Prod A A)
        negP : ((Prod A A) -> (Prod A A))
        leftDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P xP (+P yP zP)) == (+P (*P xP yP) (*P xP zP))
        rightDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P (+P yP zP) xP) == (+P (*P yP xP) (*P zP xP))
        fixes_prim_1P : (primP 1P) == 1P
        involutive_primP : {xP : (Prod A A)} -> (primP (primP xP)) == xP
        antidis_prim_+P : {xP yP : (Prod A A)} -> (primP (+P xP yP)) == (+P (primP yP) (primP xP))
        antidis_prim_*P : {xP yP : (Prod A A)} -> (primP (*P xP yP)) == (*P (primP yP) (primP xP))
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        leftInverse_inv_op_0P : {xP : (Prod A A)} -> (+P xP (negP xP)) == 0P
        rightInverse_inv_op_0P : {xP : (Prod A A)} -> (+P (negP xP) xP) == 0P
        lunit_1P : {xP : (Prod A A)} -> (*P 1P xP) == xP
        runit_1P : {xP : (Prod A A)} -> (*P xP 1P) == xP
        leftZero_op_0P : {xP : (Prod A A)} -> (*P 0P xP) == 0P
        rightZero_op_0P : {xP : (Prod A A)} -> (*P xP 0P) == 0P
    record Hom {A1 : Set} {A2 : Set} (In1 : (InvolutiveRing A1)) (In2 : (InvolutiveRing A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* In1) x1 x2)) == ((* In2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ In1) x1 x2)) == ((+ In2) (hom x1) (hom x2))
        pres-1 : (hom (1 In1)) == (1 In2)
        pres-prim : {x1 : A1} -> (hom ((prim In1) x1)) == ((prim In2) (hom x1))
        pres-0 : (hom (0 In1)) == (0 In2)
        pres-neg : {x1 : A1} -> (hom ((neg In1) x1)) == ((neg In2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (In1 : (InvolutiveRing A1)) (In2 : (InvolutiveRing A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* In1) x1 x2) ((* In2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ In1) x1 x2) ((+ In2) y1 y2))))
        interp-1 : (interp (1 In1) (1 In2))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim In1) x1) ((prim In2) y1)))
        interp-0 : (interp (0 In1) (0 In2))
        interp-neg : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((neg In1) x1) ((neg In2) y1)))
    data InvolutiveRingTerm  : Set where
      *L : (InvolutiveRingTerm -> (InvolutiveRingTerm -> InvolutiveRingTerm))
      +L : (InvolutiveRingTerm -> (InvolutiveRingTerm -> InvolutiveRingTerm))
      1L : InvolutiveRingTerm
      primL : (InvolutiveRingTerm -> InvolutiveRingTerm)
      0L : InvolutiveRingTerm
      negL : (InvolutiveRingTerm -> InvolutiveRingTerm)
    data ClInvolutiveRingTerm (A : Set) : Set where
      sing : (A -> (ClInvolutiveRingTerm A))
      *Cl : ((ClInvolutiveRingTerm A) -> ((ClInvolutiveRingTerm A) -> (ClInvolutiveRingTerm A)))
      +Cl : ((ClInvolutiveRingTerm A) -> ((ClInvolutiveRingTerm A) -> (ClInvolutiveRingTerm A)))
      1Cl : (ClInvolutiveRingTerm A)
      primCl : ((ClInvolutiveRingTerm A) -> (ClInvolutiveRingTerm A))
      0Cl : (ClInvolutiveRingTerm A)
      negCl : ((ClInvolutiveRingTerm A) -> (ClInvolutiveRingTerm A))
    data OpInvolutiveRingTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpInvolutiveRingTerm n))
      *OL : ((OpInvolutiveRingTerm n) -> ((OpInvolutiveRingTerm n) -> (OpInvolutiveRingTerm n)))
      +OL : ((OpInvolutiveRingTerm n) -> ((OpInvolutiveRingTerm n) -> (OpInvolutiveRingTerm n)))
      1OL : (OpInvolutiveRingTerm n)
      primOL : ((OpInvolutiveRingTerm n) -> (OpInvolutiveRingTerm n))
      0OL : (OpInvolutiveRingTerm n)
      negOL : ((OpInvolutiveRingTerm n) -> (OpInvolutiveRingTerm n))
    data OpInvolutiveRingTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpInvolutiveRingTerm2 n A))
      sing2 : (A -> (OpInvolutiveRingTerm2 n A))
      *OL2 : ((OpInvolutiveRingTerm2 n A) -> ((OpInvolutiveRingTerm2 n A) -> (OpInvolutiveRingTerm2 n A)))
      +OL2 : ((OpInvolutiveRingTerm2 n A) -> ((OpInvolutiveRingTerm2 n A) -> (OpInvolutiveRingTerm2 n A)))
      1OL2 : (OpInvolutiveRingTerm2 n A)
      primOL2 : ((OpInvolutiveRingTerm2 n A) -> (OpInvolutiveRingTerm2 n A))
      0OL2 : (OpInvolutiveRingTerm2 n A)
      negOL2 : ((OpInvolutiveRingTerm2 n A) -> (OpInvolutiveRingTerm2 n A))
    simplifyCl : {A : Set} -> ((ClInvolutiveRingTerm A) -> (ClInvolutiveRingTerm A))
    simplifyCl (primCl 1Cl) = 1Cl 
    simplifyCl (primCl (primCl x)) = x 
    simplifyCl (+Cl (primCl y) (primCl x)) = (primCl (+Cl x y)) 
    simplifyCl (*Cl (primCl y) (primCl x)) = (primCl (*Cl x y)) 
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl (*Cl 1Cl x) = x 
    simplifyCl (*Cl x 1Cl) = x 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl 0Cl = 0Cl 
    simplifyCl (negCl x1) = (negCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpInvolutiveRingTerm n) -> (OpInvolutiveRingTerm n))
    simplifyOpB (primOL 1OL) = 1OL 
    simplifyOpB (primOL (primOL x)) = x 
    simplifyOpB (+OL (primOL y) (primOL x)) = (primOL (+OL x y)) 
    simplifyOpB (*OL (primOL y) (primOL x)) = (primOL (*OL x y)) 
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB (*OL 1OL x) = x 
    simplifyOpB (*OL x 1OL) = x 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB 0OL = 0OL 
    simplifyOpB (negOL x1) = (negOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpInvolutiveRingTerm2 n A) -> (OpInvolutiveRingTerm2 n A))
    simplifyOp (primOL2 1OL2) = 1OL2 
    simplifyOp (primOL2 (primOL2 x)) = x 
    simplifyOp (+OL2 (primOL2 y) (primOL2 x)) = (primOL2 (+OL2 x y)) 
    simplifyOp (*OL2 (primOL2 y) (primOL2 x)) = (primOL2 (*OL2 x y)) 
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp (*OL2 1OL2 x) = x 
    simplifyOp (*OL2 x 1OL2) = x 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (negOL2 x1) = (negOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((InvolutiveRing A) -> (InvolutiveRingTerm -> A))
    evalB In (*L x1 x2) = ((* In) (evalB In x1) (evalB In x2)) 
    evalB In (+L x1 x2) = ((+ In) (evalB In x1) (evalB In x2)) 
    evalB In 1L = (1 In) 
    evalB In (primL x1) = ((prim In) (evalB In x1)) 
    evalB In 0L = (0 In) 
    evalB In (negL x1) = ((neg In) (evalB In x1)) 
    evalCl : {A : Set} -> ((InvolutiveRing A) -> ((ClInvolutiveRingTerm A) -> A))
    evalCl In (sing x1) = x1 
    evalCl In (*Cl x1 x2) = ((* In) (evalCl In x1) (evalCl In x2)) 
    evalCl In (+Cl x1 x2) = ((+ In) (evalCl In x1) (evalCl In x2)) 
    evalCl In 1Cl = (1 In) 
    evalCl In (primCl x1) = ((prim In) (evalCl In x1)) 
    evalCl In 0Cl = (0 In) 
    evalCl In (negCl x1) = ((neg In) (evalCl In x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((InvolutiveRing A) -> ((Vec A n) -> ((OpInvolutiveRingTerm n) -> A)))
    evalOpB In vars (v x1) = (lookup _ x1 vars) 
    evalOpB In vars (*OL x1 x2) = ((* In) (evalOpB In vars x1) (evalOpB In vars x2)) 
    evalOpB In vars (+OL x1 x2) = ((+ In) (evalOpB In vars x1) (evalOpB In vars x2)) 
    evalOpB In vars 1OL = (1 In) 
    evalOpB In vars (primOL x1) = ((prim In) (evalOpB In vars x1)) 
    evalOpB In vars 0OL = (0 In) 
    evalOpB In vars (negOL x1) = ((neg In) (evalOpB In vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((InvolutiveRing A) -> ((Vec A n) -> ((OpInvolutiveRingTerm2 n A) -> A)))
    evalOp In vars (v2 x1) = (lookup _ x1 vars) 
    evalOp In vars (sing2 x1) = x1 
    evalOp In vars (*OL2 x1 x2) = ((* In) (evalOp In vars x1) (evalOp In vars x2)) 
    evalOp In vars (+OL2 x1 x2) = ((+ In) (evalOp In vars x1) (evalOp In vars x2)) 
    evalOp In vars 1OL2 = (1 In) 
    evalOp In vars (primOL2 x1) = ((prim In) (evalOp In vars x1)) 
    evalOp In vars 0OL2 = (0 In) 
    evalOp In vars (negOL2 x1) = ((neg In) (evalOp In vars x1)) 
    inductionB : {P : (InvolutiveRingTerm -> Set)} -> (((x1 x2 : InvolutiveRingTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : InvolutiveRingTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((P 1L) -> (((x1 : InvolutiveRingTerm) -> ((P x1) -> (P (primL x1)))) -> ((P 0L) -> (((x1 : InvolutiveRingTerm) -> ((P x1) -> (P (negL x1)))) -> ((x : InvolutiveRingTerm) -> (P x))))))))
    inductionB {p} p*l p+l p1l ppriml p0l pnegl (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l p1l ppriml p0l pnegl x1) (inductionB {p} p*l p+l p1l ppriml p0l pnegl x2)) 
    inductionB {p} p*l p+l p1l ppriml p0l pnegl (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l p1l ppriml p0l pnegl x1) (inductionB {p} p*l p+l p1l ppriml p0l pnegl x2)) 
    inductionB {p} p*l p+l p1l ppriml p0l pnegl 1L = p1l 
    inductionB {p} p*l p+l p1l ppriml p0l pnegl (primL x1) = (ppriml _ (inductionB {p} p*l p+l p1l ppriml p0l pnegl x1)) 
    inductionB {p} p*l p+l p1l ppriml p0l pnegl 0L = p0l 
    inductionB {p} p*l p+l p1l ppriml p0l pnegl (negL x1) = (pnegl _ (inductionB {p} p*l p+l p1l ppriml p0l pnegl x1)) 
    inductionCl : {A : Set} {P : ((ClInvolutiveRingTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClInvolutiveRingTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClInvolutiveRingTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((P 1Cl) -> (((x1 : (ClInvolutiveRingTerm A)) -> ((P x1) -> (P (primCl x1)))) -> ((P 0Cl) -> (((x1 : (ClInvolutiveRingTerm A)) -> ((P x1) -> (P (negCl x1)))) -> ((x : (ClInvolutiveRingTerm A)) -> (P x)))))))))
    inductionCl {_} {p} psing p*cl p+cl p1cl pprimcl p0cl pnegcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl p1cl pprimcl p0cl pnegcl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl p1cl pprimcl p0cl pnegcl x1) (inductionCl {_} {p} psing p*cl p+cl p1cl pprimcl p0cl pnegcl x2)) 
    inductionCl {_} {p} psing p*cl p+cl p1cl pprimcl p0cl pnegcl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl p1cl pprimcl p0cl pnegcl x1) (inductionCl {_} {p} psing p*cl p+cl p1cl pprimcl p0cl pnegcl x2)) 
    inductionCl {_} {p} psing p*cl p+cl p1cl pprimcl p0cl pnegcl 1Cl = p1cl 
    inductionCl {_} {p} psing p*cl p+cl p1cl pprimcl p0cl pnegcl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing p*cl p+cl p1cl pprimcl p0cl pnegcl x1)) 
    inductionCl {_} {p} psing p*cl p+cl p1cl pprimcl p0cl pnegcl 0Cl = p0cl 
    inductionCl {_} {p} psing p*cl p+cl p1cl pprimcl p0cl pnegcl (negCl x1) = (pnegcl _ (inductionCl {_} {p} psing p*cl p+cl p1cl pprimcl p0cl pnegcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpInvolutiveRingTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpInvolutiveRingTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpInvolutiveRingTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((P 1OL) -> (((x1 : (OpInvolutiveRingTerm n)) -> ((P x1) -> (P (primOL x1)))) -> ((P 0OL) -> (((x1 : (OpInvolutiveRingTerm n)) -> ((P x1) -> (P (negOL x1)))) -> ((x : (OpInvolutiveRingTerm n)) -> (P x)))))))))
    inductionOpB {_} {p} pv p*ol p+ol p1ol pprimol p0ol pnegol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol p1ol pprimol p0ol pnegol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol p1ol pprimol p0ol pnegol x1) (inductionOpB {_} {p} pv p*ol p+ol p1ol pprimol p0ol pnegol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol p1ol pprimol p0ol pnegol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol p1ol pprimol p0ol pnegol x1) (inductionOpB {_} {p} pv p*ol p+ol p1ol pprimol p0ol pnegol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol p1ol pprimol p0ol pnegol 1OL = p1ol 
    inductionOpB {_} {p} pv p*ol p+ol p1ol pprimol p0ol pnegol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv p*ol p+ol p1ol pprimol p0ol pnegol x1)) 
    inductionOpB {_} {p} pv p*ol p+ol p1ol pprimol p0ol pnegol 0OL = p0ol 
    inductionOpB {_} {p} pv p*ol p+ol p1ol pprimol p0ol pnegol (negOL x1) = (pnegol _ (inductionOpB {_} {p} pv p*ol p+ol p1ol pprimol p0ol pnegol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpInvolutiveRingTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpInvolutiveRingTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpInvolutiveRingTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((P 1OL2) -> (((x1 : (OpInvolutiveRingTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> ((P 0OL2) -> (((x1 : (OpInvolutiveRingTerm2 n A)) -> ((P x1) -> (P (negOL2 x1)))) -> ((x : (OpInvolutiveRingTerm2 n A)) -> (P x))))))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 pprimol2 p0ol2 pnegol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 pprimol2 p0ol2 pnegol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 pprimol2 p0ol2 pnegol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 pprimol2 p0ol2 pnegol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 pprimol2 p0ol2 pnegol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 pprimol2 p0ol2 pnegol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 pprimol2 p0ol2 pnegol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 pprimol2 p0ol2 pnegol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 pprimol2 p0ol2 pnegol2 1OL2 = p1ol2 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 pprimol2 p0ol2 pnegol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 pprimol2 p0ol2 pnegol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 pprimol2 p0ol2 pnegol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 pprimol2 p0ol2 pnegol2 (negOL2 x1) = (pnegol2 _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 pprimol2 p0ol2 pnegol2 x1)) 
    *L' : (InvolutiveRingTerm -> (InvolutiveRingTerm -> InvolutiveRingTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (InvolutiveRingTerm -> (InvolutiveRingTerm -> InvolutiveRingTerm))
    +L' x1 x2 = (+L x1 x2) 
    1L' : InvolutiveRingTerm
    1L'  = 1L 
    primL' : (InvolutiveRingTerm -> InvolutiveRingTerm)
    primL' x1 = (primL x1) 
    0L' : InvolutiveRingTerm
    0L'  = 0L 
    negL' : (InvolutiveRingTerm -> InvolutiveRingTerm)
    negL' x1 = (negL x1) 
    stageB : (InvolutiveRingTerm -> (Staged InvolutiveRingTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB 1L = (Now 1L) 
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    stageB 0L = (Now 0L) 
    stageB (negL x1) = (stage1 negL' (codeLift1 negL') (stageB x1)) 
    *Cl' : {A : Set} -> ((ClInvolutiveRingTerm A) -> ((ClInvolutiveRingTerm A) -> (ClInvolutiveRingTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClInvolutiveRingTerm A) -> ((ClInvolutiveRingTerm A) -> (ClInvolutiveRingTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    1Cl' : {A : Set} -> (ClInvolutiveRingTerm A)
    1Cl'  = 1Cl 
    primCl' : {A : Set} -> ((ClInvolutiveRingTerm A) -> (ClInvolutiveRingTerm A))
    primCl' x1 = (primCl x1) 
    0Cl' : {A : Set} -> (ClInvolutiveRingTerm A)
    0Cl'  = 0Cl 
    negCl' : {A : Set} -> ((ClInvolutiveRingTerm A) -> (ClInvolutiveRingTerm A))
    negCl' x1 = (negCl x1) 
    stageCl : {A : Set} -> ((ClInvolutiveRingTerm A) -> (Staged (ClInvolutiveRingTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl 1Cl = (Now 1Cl) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (negCl x1) = (stage1 negCl' (codeLift1 negCl') (stageCl x1)) 
    *OL' : {n : Nat} -> ((OpInvolutiveRingTerm n) -> ((OpInvolutiveRingTerm n) -> (OpInvolutiveRingTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpInvolutiveRingTerm n) -> ((OpInvolutiveRingTerm n) -> (OpInvolutiveRingTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    1OL' : {n : Nat} -> (OpInvolutiveRingTerm n)
    1OL'  = 1OL 
    primOL' : {n : Nat} -> ((OpInvolutiveRingTerm n) -> (OpInvolutiveRingTerm n))
    primOL' x1 = (primOL x1) 
    0OL' : {n : Nat} -> (OpInvolutiveRingTerm n)
    0OL'  = 0OL 
    negOL' : {n : Nat} -> ((OpInvolutiveRingTerm n) -> (OpInvolutiveRingTerm n))
    negOL' x1 = (negOL x1) 
    stageOpB : {n : Nat} -> ((OpInvolutiveRingTerm n) -> (Staged (OpInvolutiveRingTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 1OL = (Now 1OL) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (negOL x1) = (stage1 negOL' (codeLift1 negOL') (stageOpB x1)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpInvolutiveRingTerm2 n A) -> ((OpInvolutiveRingTerm2 n A) -> (OpInvolutiveRingTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpInvolutiveRingTerm2 n A) -> ((OpInvolutiveRingTerm2 n A) -> (OpInvolutiveRingTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    1OL2' : {n : Nat} {A : Set} -> (OpInvolutiveRingTerm2 n A)
    1OL2'  = 1OL2 
    primOL2' : {n : Nat} {A : Set} -> ((OpInvolutiveRingTerm2 n A) -> (OpInvolutiveRingTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    0OL2' : {n : Nat} {A : Set} -> (OpInvolutiveRingTerm2 n A)
    0OL2'  = 0OL2 
    negOL2' : {n : Nat} {A : Set} -> ((OpInvolutiveRingTerm2 n A) -> (OpInvolutiveRingTerm2 n A))
    negOL2' x1 = (negOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpInvolutiveRingTerm2 n A) -> (Staged (OpInvolutiveRingTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp 1OL2 = (Now 1OL2) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (negOL2 x1) = (stage1 negOL2' (codeLift1 negOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        1T : (Repr A)
        primT : ((Repr A) -> (Repr A))
        0T : (Repr A)
        negT : ((Repr A) -> (Repr A))
  module InvolutiveRingoid  where
    record InvolutiveRingoid (A : Set) : Set where
      constructor InvolutiveRingoidC
      field
        prim : (A -> A)
        1 : A
        fixes_prim_1 : (prim 1) == 1
        involutive_prim : {x : A} -> (prim (prim x)) == x
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        leftDistributive_*_+ : {x y z : A} -> (* x (+ y z)) == (+ (* x y) (* x z))
        rightDistributive_*_+ : {x y z : A} -> (* (+ y z) x) == (+ (* y x) (* z x))
        antidis_prim_+ : {x y : A} -> (prim (+ x y)) == (+ (prim y) (prim x))
        antidis_prim_* : {x y : A} -> (prim (* x y)) == (* (prim y) (prim x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        primS : (AS -> AS)
        1S : AS
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        primP : ((Prod A A) -> (Prod A A))
        1P : (Prod A A)
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        fixes_prim_1P : (primP 1P) == 1P
        involutive_primP : {xP : (Prod A A)} -> (primP (primP xP)) == xP
        leftDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P xP (+P yP zP)) == (+P (*P xP yP) (*P xP zP))
        rightDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P (+P yP zP) xP) == (+P (*P yP xP) (*P zP xP))
        antidis_prim_+P : {xP yP : (Prod A A)} -> (primP (+P xP yP)) == (+P (primP yP) (primP xP))
        antidis_prim_*P : {xP yP : (Prod A A)} -> (primP (*P xP yP)) == (*P (primP yP) (primP xP))
    record Hom {A1 : Set} {A2 : Set} (In1 : (InvolutiveRingoid A1)) (In2 : (InvolutiveRingoid A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-prim : {x1 : A1} -> (hom ((prim In1) x1)) == ((prim In2) (hom x1))
        pres-1 : (hom (1 In1)) == (1 In2)
        pres-* : {x1 x2 : A1} -> (hom ((* In1) x1 x2)) == ((* In2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ In1) x1 x2)) == ((+ In2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (In1 : (InvolutiveRingoid A1)) (In2 : (InvolutiveRingoid A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim In1) x1) ((prim In2) y1)))
        interp-1 : (interp (1 In1) (1 In2))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* In1) x1 x2) ((* In2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ In1) x1 x2) ((+ In2) y1 y2))))
    data InvolutiveRingoidTerm  : Set where
      primL : (InvolutiveRingoidTerm -> InvolutiveRingoidTerm)
      1L : InvolutiveRingoidTerm
      *L : (InvolutiveRingoidTerm -> (InvolutiveRingoidTerm -> InvolutiveRingoidTerm))
      +L : (InvolutiveRingoidTerm -> (InvolutiveRingoidTerm -> InvolutiveRingoidTerm))
    data ClInvolutiveRingoidTerm (A : Set) : Set where
      sing : (A -> (ClInvolutiveRingoidTerm A))
      primCl : ((ClInvolutiveRingoidTerm A) -> (ClInvolutiveRingoidTerm A))
      1Cl : (ClInvolutiveRingoidTerm A)
      *Cl : ((ClInvolutiveRingoidTerm A) -> ((ClInvolutiveRingoidTerm A) -> (ClInvolutiveRingoidTerm A)))
      +Cl : ((ClInvolutiveRingoidTerm A) -> ((ClInvolutiveRingoidTerm A) -> (ClInvolutiveRingoidTerm A)))
    data OpInvolutiveRingoidTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpInvolutiveRingoidTerm n))
      primOL : ((OpInvolutiveRingoidTerm n) -> (OpInvolutiveRingoidTerm n))
      1OL : (OpInvolutiveRingoidTerm n)
      *OL : ((OpInvolutiveRingoidTerm n) -> ((OpInvolutiveRingoidTerm n) -> (OpInvolutiveRingoidTerm n)))
      +OL : ((OpInvolutiveRingoidTerm n) -> ((OpInvolutiveRingoidTerm n) -> (OpInvolutiveRingoidTerm n)))
    data OpInvolutiveRingoidTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpInvolutiveRingoidTerm2 n A))
      sing2 : (A -> (OpInvolutiveRingoidTerm2 n A))
      primOL2 : ((OpInvolutiveRingoidTerm2 n A) -> (OpInvolutiveRingoidTerm2 n A))
      1OL2 : (OpInvolutiveRingoidTerm2 n A)
      *OL2 : ((OpInvolutiveRingoidTerm2 n A) -> ((OpInvolutiveRingoidTerm2 n A) -> (OpInvolutiveRingoidTerm2 n A)))
      +OL2 : ((OpInvolutiveRingoidTerm2 n A) -> ((OpInvolutiveRingoidTerm2 n A) -> (OpInvolutiveRingoidTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClInvolutiveRingoidTerm A) -> (ClInvolutiveRingoidTerm A))
    simplifyCl (primCl 1Cl) = 1Cl 
    simplifyCl (primCl (primCl x)) = x 
    simplifyCl (+Cl (primCl y) (primCl x)) = (primCl (+Cl x y)) 
    simplifyCl (*Cl (primCl y) (primCl x)) = (primCl (*Cl x y)) 
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpInvolutiveRingoidTerm n) -> (OpInvolutiveRingoidTerm n))
    simplifyOpB (primOL 1OL) = 1OL 
    simplifyOpB (primOL (primOL x)) = x 
    simplifyOpB (+OL (primOL y) (primOL x)) = (primOL (+OL x y)) 
    simplifyOpB (*OL (primOL y) (primOL x)) = (primOL (*OL x y)) 
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpInvolutiveRingoidTerm2 n A) -> (OpInvolutiveRingoidTerm2 n A))
    simplifyOp (primOL2 1OL2) = 1OL2 
    simplifyOp (primOL2 (primOL2 x)) = x 
    simplifyOp (+OL2 (primOL2 y) (primOL2 x)) = (primOL2 (+OL2 x y)) 
    simplifyOp (*OL2 (primOL2 y) (primOL2 x)) = (primOL2 (*OL2 x y)) 
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((InvolutiveRingoid A) -> (InvolutiveRingoidTerm -> A))
    evalB In (primL x1) = ((prim In) (evalB In x1)) 
    evalB In 1L = (1 In) 
    evalB In (*L x1 x2) = ((* In) (evalB In x1) (evalB In x2)) 
    evalB In (+L x1 x2) = ((+ In) (evalB In x1) (evalB In x2)) 
    evalCl : {A : Set} -> ((InvolutiveRingoid A) -> ((ClInvolutiveRingoidTerm A) -> A))
    evalCl In (sing x1) = x1 
    evalCl In (primCl x1) = ((prim In) (evalCl In x1)) 
    evalCl In 1Cl = (1 In) 
    evalCl In (*Cl x1 x2) = ((* In) (evalCl In x1) (evalCl In x2)) 
    evalCl In (+Cl x1 x2) = ((+ In) (evalCl In x1) (evalCl In x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((InvolutiveRingoid A) -> ((Vec A n) -> ((OpInvolutiveRingoidTerm n) -> A)))
    evalOpB In vars (v x1) = (lookup _ x1 vars) 
    evalOpB In vars (primOL x1) = ((prim In) (evalOpB In vars x1)) 
    evalOpB In vars 1OL = (1 In) 
    evalOpB In vars (*OL x1 x2) = ((* In) (evalOpB In vars x1) (evalOpB In vars x2)) 
    evalOpB In vars (+OL x1 x2) = ((+ In) (evalOpB In vars x1) (evalOpB In vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((InvolutiveRingoid A) -> ((Vec A n) -> ((OpInvolutiveRingoidTerm2 n A) -> A)))
    evalOp In vars (v2 x1) = (lookup _ x1 vars) 
    evalOp In vars (sing2 x1) = x1 
    evalOp In vars (primOL2 x1) = ((prim In) (evalOp In vars x1)) 
    evalOp In vars 1OL2 = (1 In) 
    evalOp In vars (*OL2 x1 x2) = ((* In) (evalOp In vars x1) (evalOp In vars x2)) 
    evalOp In vars (+OL2 x1 x2) = ((+ In) (evalOp In vars x1) (evalOp In vars x2)) 
    inductionB : {P : (InvolutiveRingoidTerm -> Set)} -> (((x1 : InvolutiveRingoidTerm) -> ((P x1) -> (P (primL x1)))) -> ((P 1L) -> (((x1 x2 : InvolutiveRingoidTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : InvolutiveRingoidTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : InvolutiveRingoidTerm) -> (P x))))))
    inductionB {p} ppriml p1l p*l p+l (primL x1) = (ppriml _ (inductionB {p} ppriml p1l p*l p+l x1)) 
    inductionB {p} ppriml p1l p*l p+l 1L = p1l 
    inductionB {p} ppriml p1l p*l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} ppriml p1l p*l p+l x1) (inductionB {p} ppriml p1l p*l p+l x2)) 
    inductionB {p} ppriml p1l p*l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} ppriml p1l p*l p+l x1) (inductionB {p} ppriml p1l p*l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClInvolutiveRingoidTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 : (ClInvolutiveRingoidTerm A)) -> ((P x1) -> (P (primCl x1)))) -> ((P 1Cl) -> (((x1 x2 : (ClInvolutiveRingoidTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClInvolutiveRingoidTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClInvolutiveRingoidTerm A)) -> (P x)))))))
    inductionCl {_} {p} psing pprimcl p1cl p*cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pprimcl p1cl p*cl p+cl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing pprimcl p1cl p*cl p+cl x1)) 
    inductionCl {_} {p} psing pprimcl p1cl p*cl p+cl 1Cl = p1cl 
    inductionCl {_} {p} psing pprimcl p1cl p*cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing pprimcl p1cl p*cl p+cl x1) (inductionCl {_} {p} psing pprimcl p1cl p*cl p+cl x2)) 
    inductionCl {_} {p} psing pprimcl p1cl p*cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing pprimcl p1cl p*cl p+cl x1) (inductionCl {_} {p} psing pprimcl p1cl p*cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpInvolutiveRingoidTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 : (OpInvolutiveRingoidTerm n)) -> ((P x1) -> (P (primOL x1)))) -> ((P 1OL) -> (((x1 x2 : (OpInvolutiveRingoidTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpInvolutiveRingoidTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpInvolutiveRingoidTerm n)) -> (P x)))))))
    inductionOpB {_} {p} pv pprimol p1ol p*ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pprimol p1ol p*ol p+ol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv pprimol p1ol p*ol p+ol x1)) 
    inductionOpB {_} {p} pv pprimol p1ol p*ol p+ol 1OL = p1ol 
    inductionOpB {_} {p} pv pprimol p1ol p*ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv pprimol p1ol p*ol p+ol x1) (inductionOpB {_} {p} pv pprimol p1ol p*ol p+ol x2)) 
    inductionOpB {_} {p} pv pprimol p1ol p*ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv pprimol p1ol p*ol p+ol x1) (inductionOpB {_} {p} pv pprimol p1ol p*ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpInvolutiveRingoidTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 : (OpInvolutiveRingoidTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> ((P 1OL2) -> (((x1 x2 : (OpInvolutiveRingoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpInvolutiveRingoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpInvolutiveRingoidTerm2 n A)) -> (P x))))))))
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 p1ol2 p*ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 p1ol2 p*ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 p1ol2 p*ol2 p+ol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 pprimol2 p1ol2 p*ol2 p+ol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 p1ol2 p*ol2 p+ol2 1OL2 = p1ol2 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 p1ol2 p*ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 pprimol2 p1ol2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 pprimol2 p1ol2 p*ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 p1ol2 p*ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 pprimol2 p1ol2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 pprimol2 p1ol2 p*ol2 p+ol2 x2)) 
    primL' : (InvolutiveRingoidTerm -> InvolutiveRingoidTerm)
    primL' x1 = (primL x1) 
    1L' : InvolutiveRingoidTerm
    1L'  = 1L 
    *L' : (InvolutiveRingoidTerm -> (InvolutiveRingoidTerm -> InvolutiveRingoidTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (InvolutiveRingoidTerm -> (InvolutiveRingoidTerm -> InvolutiveRingoidTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (InvolutiveRingoidTerm -> (Staged InvolutiveRingoidTerm))
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    stageB 1L = (Now 1L) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    primCl' : {A : Set} -> ((ClInvolutiveRingoidTerm A) -> (ClInvolutiveRingoidTerm A))
    primCl' x1 = (primCl x1) 
    1Cl' : {A : Set} -> (ClInvolutiveRingoidTerm A)
    1Cl'  = 1Cl 
    *Cl' : {A : Set} -> ((ClInvolutiveRingoidTerm A) -> ((ClInvolutiveRingoidTerm A) -> (ClInvolutiveRingoidTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClInvolutiveRingoidTerm A) -> ((ClInvolutiveRingoidTerm A) -> (ClInvolutiveRingoidTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClInvolutiveRingoidTerm A) -> (Staged (ClInvolutiveRingoidTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    stageCl 1Cl = (Now 1Cl) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    primOL' : {n : Nat} -> ((OpInvolutiveRingoidTerm n) -> (OpInvolutiveRingoidTerm n))
    primOL' x1 = (primOL x1) 
    1OL' : {n : Nat} -> (OpInvolutiveRingoidTerm n)
    1OL'  = 1OL 
    *OL' : {n : Nat} -> ((OpInvolutiveRingoidTerm n) -> ((OpInvolutiveRingoidTerm n) -> (OpInvolutiveRingoidTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpInvolutiveRingoidTerm n) -> ((OpInvolutiveRingoidTerm n) -> (OpInvolutiveRingoidTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpInvolutiveRingoidTerm n) -> (Staged (OpInvolutiveRingoidTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    stageOpB 1OL = (Now 1OL) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    primOL2' : {n : Nat} {A : Set} -> ((OpInvolutiveRingoidTerm2 n A) -> (OpInvolutiveRingoidTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    1OL2' : {n : Nat} {A : Set} -> (OpInvolutiveRingoidTerm2 n A)
    1OL2'  = 1OL2 
    *OL2' : {n : Nat} {A : Set} -> ((OpInvolutiveRingoidTerm2 n A) -> ((OpInvolutiveRingoidTerm2 n A) -> (OpInvolutiveRingoidTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpInvolutiveRingoidTerm2 n A) -> ((OpInvolutiveRingoidTerm2 n A) -> (OpInvolutiveRingoidTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpInvolutiveRingoidTerm2 n A) -> (Staged (OpInvolutiveRingoidTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    stageOp 1OL2 = (Now 1OL2) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        primT : ((Repr A) -> (Repr A))
        1T : (Repr A)
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module InvolutiveRingoidSig  where
    record InvolutiveRingoidSig (A : Set) : Set where
      constructor InvolutiveRingoidSigC
      field
        prim : (A -> A)
        * : (A -> (A -> A))
        + : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        primS : (AS -> AS)
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        primP : ((Prod A A) -> (Prod A A))
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
    record Hom {A1 : Set} {A2 : Set} (In1 : (InvolutiveRingoidSig A1)) (In2 : (InvolutiveRingoidSig A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-prim : {x1 : A1} -> (hom ((prim In1) x1)) == ((prim In2) (hom x1))
        pres-* : {x1 x2 : A1} -> (hom ((* In1) x1 x2)) == ((* In2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ In1) x1 x2)) == ((+ In2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (In1 : (InvolutiveRingoidSig A1)) (In2 : (InvolutiveRingoidSig A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim In1) x1) ((prim In2) y1)))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* In1) x1 x2) ((* In2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ In1) x1 x2) ((+ In2) y1 y2))))
    data InvolutiveRingoidSigTerm  : Set where
      primL : (InvolutiveRingoidSigTerm -> InvolutiveRingoidSigTerm)
      *L : (InvolutiveRingoidSigTerm -> (InvolutiveRingoidSigTerm -> InvolutiveRingoidSigTerm))
      +L : (InvolutiveRingoidSigTerm -> (InvolutiveRingoidSigTerm -> InvolutiveRingoidSigTerm))
    data ClInvolutiveRingoidSigTerm (A : Set) : Set where
      sing : (A -> (ClInvolutiveRingoidSigTerm A))
      primCl : ((ClInvolutiveRingoidSigTerm A) -> (ClInvolutiveRingoidSigTerm A))
      *Cl : ((ClInvolutiveRingoidSigTerm A) -> ((ClInvolutiveRingoidSigTerm A) -> (ClInvolutiveRingoidSigTerm A)))
      +Cl : ((ClInvolutiveRingoidSigTerm A) -> ((ClInvolutiveRingoidSigTerm A) -> (ClInvolutiveRingoidSigTerm A)))
    data OpInvolutiveRingoidSigTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpInvolutiveRingoidSigTerm n))
      primOL : ((OpInvolutiveRingoidSigTerm n) -> (OpInvolutiveRingoidSigTerm n))
      *OL : ((OpInvolutiveRingoidSigTerm n) -> ((OpInvolutiveRingoidSigTerm n) -> (OpInvolutiveRingoidSigTerm n)))
      +OL : ((OpInvolutiveRingoidSigTerm n) -> ((OpInvolutiveRingoidSigTerm n) -> (OpInvolutiveRingoidSigTerm n)))
    data OpInvolutiveRingoidSigTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpInvolutiveRingoidSigTerm2 n A))
      sing2 : (A -> (OpInvolutiveRingoidSigTerm2 n A))
      primOL2 : ((OpInvolutiveRingoidSigTerm2 n A) -> (OpInvolutiveRingoidSigTerm2 n A))
      *OL2 : ((OpInvolutiveRingoidSigTerm2 n A) -> ((OpInvolutiveRingoidSigTerm2 n A) -> (OpInvolutiveRingoidSigTerm2 n A)))
      +OL2 : ((OpInvolutiveRingoidSigTerm2 n A) -> ((OpInvolutiveRingoidSigTerm2 n A) -> (OpInvolutiveRingoidSigTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClInvolutiveRingoidSigTerm A) -> (ClInvolutiveRingoidSigTerm A))
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpInvolutiveRingoidSigTerm n) -> (OpInvolutiveRingoidSigTerm n))
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpInvolutiveRingoidSigTerm2 n A) -> (OpInvolutiveRingoidSigTerm2 n A))
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((InvolutiveRingoidSig A) -> (InvolutiveRingoidSigTerm -> A))
    evalB In (primL x1) = ((prim In) (evalB In x1)) 
    evalB In (*L x1 x2) = ((* In) (evalB In x1) (evalB In x2)) 
    evalB In (+L x1 x2) = ((+ In) (evalB In x1) (evalB In x2)) 
    evalCl : {A : Set} -> ((InvolutiveRingoidSig A) -> ((ClInvolutiveRingoidSigTerm A) -> A))
    evalCl In (sing x1) = x1 
    evalCl In (primCl x1) = ((prim In) (evalCl In x1)) 
    evalCl In (*Cl x1 x2) = ((* In) (evalCl In x1) (evalCl In x2)) 
    evalCl In (+Cl x1 x2) = ((+ In) (evalCl In x1) (evalCl In x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((InvolutiveRingoidSig A) -> ((Vec A n) -> ((OpInvolutiveRingoidSigTerm n) -> A)))
    evalOpB In vars (v x1) = (lookup _ x1 vars) 
    evalOpB In vars (primOL x1) = ((prim In) (evalOpB In vars x1)) 
    evalOpB In vars (*OL x1 x2) = ((* In) (evalOpB In vars x1) (evalOpB In vars x2)) 
    evalOpB In vars (+OL x1 x2) = ((+ In) (evalOpB In vars x1) (evalOpB In vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((InvolutiveRingoidSig A) -> ((Vec A n) -> ((OpInvolutiveRingoidSigTerm2 n A) -> A)))
    evalOp In vars (v2 x1) = (lookup _ x1 vars) 
    evalOp In vars (sing2 x1) = x1 
    evalOp In vars (primOL2 x1) = ((prim In) (evalOp In vars x1)) 
    evalOp In vars (*OL2 x1 x2) = ((* In) (evalOp In vars x1) (evalOp In vars x2)) 
    evalOp In vars (+OL2 x1 x2) = ((+ In) (evalOp In vars x1) (evalOp In vars x2)) 
    inductionB : {P : (InvolutiveRingoidSigTerm -> Set)} -> (((x1 : InvolutiveRingoidSigTerm) -> ((P x1) -> (P (primL x1)))) -> (((x1 x2 : InvolutiveRingoidSigTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : InvolutiveRingoidSigTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : InvolutiveRingoidSigTerm) -> (P x)))))
    inductionB {p} ppriml p*l p+l (primL x1) = (ppriml _ (inductionB {p} ppriml p*l p+l x1)) 
    inductionB {p} ppriml p*l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} ppriml p*l p+l x1) (inductionB {p} ppriml p*l p+l x2)) 
    inductionB {p} ppriml p*l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} ppriml p*l p+l x1) (inductionB {p} ppriml p*l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClInvolutiveRingoidSigTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 : (ClInvolutiveRingoidSigTerm A)) -> ((P x1) -> (P (primCl x1)))) -> (((x1 x2 : (ClInvolutiveRingoidSigTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClInvolutiveRingoidSigTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClInvolutiveRingoidSigTerm A)) -> (P x))))))
    inductionCl {_} {p} psing pprimcl p*cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pprimcl p*cl p+cl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing pprimcl p*cl p+cl x1)) 
    inductionCl {_} {p} psing pprimcl p*cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing pprimcl p*cl p+cl x1) (inductionCl {_} {p} psing pprimcl p*cl p+cl x2)) 
    inductionCl {_} {p} psing pprimcl p*cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing pprimcl p*cl p+cl x1) (inductionCl {_} {p} psing pprimcl p*cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpInvolutiveRingoidSigTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 : (OpInvolutiveRingoidSigTerm n)) -> ((P x1) -> (P (primOL x1)))) -> (((x1 x2 : (OpInvolutiveRingoidSigTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpInvolutiveRingoidSigTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpInvolutiveRingoidSigTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv pprimol p*ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pprimol p*ol p+ol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv pprimol p*ol p+ol x1)) 
    inductionOpB {_} {p} pv pprimol p*ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv pprimol p*ol p+ol x1) (inductionOpB {_} {p} pv pprimol p*ol p+ol x2)) 
    inductionOpB {_} {p} pv pprimol p*ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv pprimol p*ol p+ol x1) (inductionOpB {_} {p} pv pprimol p*ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpInvolutiveRingoidSigTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 : (OpInvolutiveRingoidSigTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> (((x1 x2 : (OpInvolutiveRingoidSigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpInvolutiveRingoidSigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpInvolutiveRingoidSigTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 p*ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 p*ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 p*ol2 p+ol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 pprimol2 p*ol2 p+ol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 p*ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 pprimol2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 pprimol2 p*ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 p*ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 pprimol2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 pprimol2 p*ol2 p+ol2 x2)) 
    primL' : (InvolutiveRingoidSigTerm -> InvolutiveRingoidSigTerm)
    primL' x1 = (primL x1) 
    *L' : (InvolutiveRingoidSigTerm -> (InvolutiveRingoidSigTerm -> InvolutiveRingoidSigTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (InvolutiveRingoidSigTerm -> (InvolutiveRingoidSigTerm -> InvolutiveRingoidSigTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (InvolutiveRingoidSigTerm -> (Staged InvolutiveRingoidSigTerm))
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    primCl' : {A : Set} -> ((ClInvolutiveRingoidSigTerm A) -> (ClInvolutiveRingoidSigTerm A))
    primCl' x1 = (primCl x1) 
    *Cl' : {A : Set} -> ((ClInvolutiveRingoidSigTerm A) -> ((ClInvolutiveRingoidSigTerm A) -> (ClInvolutiveRingoidSigTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClInvolutiveRingoidSigTerm A) -> ((ClInvolutiveRingoidSigTerm A) -> (ClInvolutiveRingoidSigTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClInvolutiveRingoidSigTerm A) -> (Staged (ClInvolutiveRingoidSigTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    primOL' : {n : Nat} -> ((OpInvolutiveRingoidSigTerm n) -> (OpInvolutiveRingoidSigTerm n))
    primOL' x1 = (primOL x1) 
    *OL' : {n : Nat} -> ((OpInvolutiveRingoidSigTerm n) -> ((OpInvolutiveRingoidSigTerm n) -> (OpInvolutiveRingoidSigTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpInvolutiveRingoidSigTerm n) -> ((OpInvolutiveRingoidSigTerm n) -> (OpInvolutiveRingoidSigTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpInvolutiveRingoidSigTerm n) -> (Staged (OpInvolutiveRingoidSigTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    primOL2' : {n : Nat} {A : Set} -> ((OpInvolutiveRingoidSigTerm2 n A) -> (OpInvolutiveRingoidSigTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    *OL2' : {n : Nat} {A : Set} -> ((OpInvolutiveRingoidSigTerm2 n A) -> ((OpInvolutiveRingoidSigTerm2 n A) -> (OpInvolutiveRingoidSigTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpInvolutiveRingoidSigTerm2 n A) -> ((OpInvolutiveRingoidSigTerm2 n A) -> (OpInvolutiveRingoidSigTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpInvolutiveRingoidSigTerm2 n A) -> (Staged (OpInvolutiveRingoidSigTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        primT : ((Repr A) -> (Repr A))
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module InvolutiveRingoidWithAntiDistrib  where
    record InvolutiveRingoidWithAntiDistrib (A : Set) : Set where
      constructor InvolutiveRingoidWithAntiDistribC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        leftDistributive_*_+ : {x y z : A} -> (* x (+ y z)) == (+ (* x y) (* x z))
        rightDistributive_*_+ : {x y z : A} -> (* (+ y z) x) == (+ (* y x) (* z x))
        prim : (A -> A)
        antidis_prim_+ : {x y : A} -> (prim (+ x y)) == (+ (prim y) (prim x))
        antidis_prim_* : {x y : A} -> (prim (* x y)) == (* (prim y) (prim x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
        primS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        primP : ((Prod A A) -> (Prod A A))
        leftDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P xP (+P yP zP)) == (+P (*P xP yP) (*P xP zP))
        rightDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P (+P yP zP) xP) == (+P (*P yP xP) (*P zP xP))
        antidis_prim_+P : {xP yP : (Prod A A)} -> (primP (+P xP yP)) == (+P (primP yP) (primP xP))
        antidis_prim_*P : {xP yP : (Prod A A)} -> (primP (*P xP yP)) == (*P (primP yP) (primP xP))
    record Hom {A1 : Set} {A2 : Set} (In1 : (InvolutiveRingoidWithAntiDistrib A1)) (In2 : (InvolutiveRingoidWithAntiDistrib A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* In1) x1 x2)) == ((* In2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ In1) x1 x2)) == ((+ In2) (hom x1) (hom x2))
        pres-prim : {x1 : A1} -> (hom ((prim In1) x1)) == ((prim In2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (In1 : (InvolutiveRingoidWithAntiDistrib A1)) (In2 : (InvolutiveRingoidWithAntiDistrib A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* In1) x1 x2) ((* In2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ In1) x1 x2) ((+ In2) y1 y2))))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim In1) x1) ((prim In2) y1)))
    data InvolutiveRingoidWithAntiDistribTerm  : Set where
      *L : (InvolutiveRingoidWithAntiDistribTerm -> (InvolutiveRingoidWithAntiDistribTerm -> InvolutiveRingoidWithAntiDistribTerm))
      +L : (InvolutiveRingoidWithAntiDistribTerm -> (InvolutiveRingoidWithAntiDistribTerm -> InvolutiveRingoidWithAntiDistribTerm))
      primL : (InvolutiveRingoidWithAntiDistribTerm -> InvolutiveRingoidWithAntiDistribTerm)
    data ClInvolutiveRingoidWithAntiDistribTerm (A : Set) : Set where
      sing : (A -> (ClInvolutiveRingoidWithAntiDistribTerm A))
      *Cl : ((ClInvolutiveRingoidWithAntiDistribTerm A) -> ((ClInvolutiveRingoidWithAntiDistribTerm A) -> (ClInvolutiveRingoidWithAntiDistribTerm A)))
      +Cl : ((ClInvolutiveRingoidWithAntiDistribTerm A) -> ((ClInvolutiveRingoidWithAntiDistribTerm A) -> (ClInvolutiveRingoidWithAntiDistribTerm A)))
      primCl : ((ClInvolutiveRingoidWithAntiDistribTerm A) -> (ClInvolutiveRingoidWithAntiDistribTerm A))
    data OpInvolutiveRingoidWithAntiDistribTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpInvolutiveRingoidWithAntiDistribTerm n))
      *OL : ((OpInvolutiveRingoidWithAntiDistribTerm n) -> ((OpInvolutiveRingoidWithAntiDistribTerm n) -> (OpInvolutiveRingoidWithAntiDistribTerm n)))
      +OL : ((OpInvolutiveRingoidWithAntiDistribTerm n) -> ((OpInvolutiveRingoidWithAntiDistribTerm n) -> (OpInvolutiveRingoidWithAntiDistribTerm n)))
      primOL : ((OpInvolutiveRingoidWithAntiDistribTerm n) -> (OpInvolutiveRingoidWithAntiDistribTerm n))
    data OpInvolutiveRingoidWithAntiDistribTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpInvolutiveRingoidWithAntiDistribTerm2 n A))
      sing2 : (A -> (OpInvolutiveRingoidWithAntiDistribTerm2 n A))
      *OL2 : ((OpInvolutiveRingoidWithAntiDistribTerm2 n A) -> ((OpInvolutiveRingoidWithAntiDistribTerm2 n A) -> (OpInvolutiveRingoidWithAntiDistribTerm2 n A)))
      +OL2 : ((OpInvolutiveRingoidWithAntiDistribTerm2 n A) -> ((OpInvolutiveRingoidWithAntiDistribTerm2 n A) -> (OpInvolutiveRingoidWithAntiDistribTerm2 n A)))
      primOL2 : ((OpInvolutiveRingoidWithAntiDistribTerm2 n A) -> (OpInvolutiveRingoidWithAntiDistribTerm2 n A))
    simplifyCl : {A : Set} -> ((ClInvolutiveRingoidWithAntiDistribTerm A) -> (ClInvolutiveRingoidWithAntiDistribTerm A))
    simplifyCl (+Cl (primCl y) (primCl x)) = (primCl (+Cl x y)) 
    simplifyCl (*Cl (primCl y) (primCl x)) = (primCl (*Cl x y)) 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpInvolutiveRingoidWithAntiDistribTerm n) -> (OpInvolutiveRingoidWithAntiDistribTerm n))
    simplifyOpB (+OL (primOL y) (primOL x)) = (primOL (+OL x y)) 
    simplifyOpB (*OL (primOL y) (primOL x)) = (primOL (*OL x y)) 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpInvolutiveRingoidWithAntiDistribTerm2 n A) -> (OpInvolutiveRingoidWithAntiDistribTerm2 n A))
    simplifyOp (+OL2 (primOL2 y) (primOL2 x)) = (primOL2 (+OL2 x y)) 
    simplifyOp (*OL2 (primOL2 y) (primOL2 x)) = (primOL2 (*OL2 x y)) 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((InvolutiveRingoidWithAntiDistrib A) -> (InvolutiveRingoidWithAntiDistribTerm -> A))
    evalB In (*L x1 x2) = ((* In) (evalB In x1) (evalB In x2)) 
    evalB In (+L x1 x2) = ((+ In) (evalB In x1) (evalB In x2)) 
    evalB In (primL x1) = ((prim In) (evalB In x1)) 
    evalCl : {A : Set} -> ((InvolutiveRingoidWithAntiDistrib A) -> ((ClInvolutiveRingoidWithAntiDistribTerm A) -> A))
    evalCl In (sing x1) = x1 
    evalCl In (*Cl x1 x2) = ((* In) (evalCl In x1) (evalCl In x2)) 
    evalCl In (+Cl x1 x2) = ((+ In) (evalCl In x1) (evalCl In x2)) 
    evalCl In (primCl x1) = ((prim In) (evalCl In x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((InvolutiveRingoidWithAntiDistrib A) -> ((Vec A n) -> ((OpInvolutiveRingoidWithAntiDistribTerm n) -> A)))
    evalOpB In vars (v x1) = (lookup _ x1 vars) 
    evalOpB In vars (*OL x1 x2) = ((* In) (evalOpB In vars x1) (evalOpB In vars x2)) 
    evalOpB In vars (+OL x1 x2) = ((+ In) (evalOpB In vars x1) (evalOpB In vars x2)) 
    evalOpB In vars (primOL x1) = ((prim In) (evalOpB In vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((InvolutiveRingoidWithAntiDistrib A) -> ((Vec A n) -> ((OpInvolutiveRingoidWithAntiDistribTerm2 n A) -> A)))
    evalOp In vars (v2 x1) = (lookup _ x1 vars) 
    evalOp In vars (sing2 x1) = x1 
    evalOp In vars (*OL2 x1 x2) = ((* In) (evalOp In vars x1) (evalOp In vars x2)) 
    evalOp In vars (+OL2 x1 x2) = ((+ In) (evalOp In vars x1) (evalOp In vars x2)) 
    evalOp In vars (primOL2 x1) = ((prim In) (evalOp In vars x1)) 
    inductionB : {P : (InvolutiveRingoidWithAntiDistribTerm -> Set)} -> (((x1 x2 : InvolutiveRingoidWithAntiDistribTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : InvolutiveRingoidWithAntiDistribTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> (((x1 : InvolutiveRingoidWithAntiDistribTerm) -> ((P x1) -> (P (primL x1)))) -> ((x : InvolutiveRingoidWithAntiDistribTerm) -> (P x)))))
    inductionB {p} p*l p+l ppriml (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l ppriml x1) (inductionB {p} p*l p+l ppriml x2)) 
    inductionB {p} p*l p+l ppriml (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l ppriml x1) (inductionB {p} p*l p+l ppriml x2)) 
    inductionB {p} p*l p+l ppriml (primL x1) = (ppriml _ (inductionB {p} p*l p+l ppriml x1)) 
    inductionCl : {A : Set} {P : ((ClInvolutiveRingoidWithAntiDistribTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClInvolutiveRingoidWithAntiDistribTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClInvolutiveRingoidWithAntiDistribTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> (((x1 : (ClInvolutiveRingoidWithAntiDistribTerm A)) -> ((P x1) -> (P (primCl x1)))) -> ((x : (ClInvolutiveRingoidWithAntiDistribTerm A)) -> (P x))))))
    inductionCl {_} {p} psing p*cl p+cl pprimcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl pprimcl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl pprimcl x1) (inductionCl {_} {p} psing p*cl p+cl pprimcl x2)) 
    inductionCl {_} {p} psing p*cl p+cl pprimcl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl pprimcl x1) (inductionCl {_} {p} psing p*cl p+cl pprimcl x2)) 
    inductionCl {_} {p} psing p*cl p+cl pprimcl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing p*cl p+cl pprimcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpInvolutiveRingoidWithAntiDistribTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpInvolutiveRingoidWithAntiDistribTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpInvolutiveRingoidWithAntiDistribTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> (((x1 : (OpInvolutiveRingoidWithAntiDistribTerm n)) -> ((P x1) -> (P (primOL x1)))) -> ((x : (OpInvolutiveRingoidWithAntiDistribTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv p*ol p+ol pprimol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol pprimol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol pprimol x1) (inductionOpB {_} {p} pv p*ol p+ol pprimol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol pprimol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol pprimol x1) (inductionOpB {_} {p} pv p*ol p+ol pprimol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol pprimol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv p*ol p+ol pprimol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpInvolutiveRingoidWithAntiDistribTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpInvolutiveRingoidWithAntiDistribTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpInvolutiveRingoidWithAntiDistribTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> (((x1 : (OpInvolutiveRingoidWithAntiDistribTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> ((x : (OpInvolutiveRingoidWithAntiDistribTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x1)) 
    *L' : (InvolutiveRingoidWithAntiDistribTerm -> (InvolutiveRingoidWithAntiDistribTerm -> InvolutiveRingoidWithAntiDistribTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (InvolutiveRingoidWithAntiDistribTerm -> (InvolutiveRingoidWithAntiDistribTerm -> InvolutiveRingoidWithAntiDistribTerm))
    +L' x1 x2 = (+L x1 x2) 
    primL' : (InvolutiveRingoidWithAntiDistribTerm -> InvolutiveRingoidWithAntiDistribTerm)
    primL' x1 = (primL x1) 
    stageB : (InvolutiveRingoidWithAntiDistribTerm -> (Staged InvolutiveRingoidWithAntiDistribTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    *Cl' : {A : Set} -> ((ClInvolutiveRingoidWithAntiDistribTerm A) -> ((ClInvolutiveRingoidWithAntiDistribTerm A) -> (ClInvolutiveRingoidWithAntiDistribTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClInvolutiveRingoidWithAntiDistribTerm A) -> ((ClInvolutiveRingoidWithAntiDistribTerm A) -> (ClInvolutiveRingoidWithAntiDistribTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    primCl' : {A : Set} -> ((ClInvolutiveRingoidWithAntiDistribTerm A) -> (ClInvolutiveRingoidWithAntiDistribTerm A))
    primCl' x1 = (primCl x1) 
    stageCl : {A : Set} -> ((ClInvolutiveRingoidWithAntiDistribTerm A) -> (Staged (ClInvolutiveRingoidWithAntiDistribTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    *OL' : {n : Nat} -> ((OpInvolutiveRingoidWithAntiDistribTerm n) -> ((OpInvolutiveRingoidWithAntiDistribTerm n) -> (OpInvolutiveRingoidWithAntiDistribTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpInvolutiveRingoidWithAntiDistribTerm n) -> ((OpInvolutiveRingoidWithAntiDistribTerm n) -> (OpInvolutiveRingoidWithAntiDistribTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    primOL' : {n : Nat} -> ((OpInvolutiveRingoidWithAntiDistribTerm n) -> (OpInvolutiveRingoidWithAntiDistribTerm n))
    primOL' x1 = (primOL x1) 
    stageOpB : {n : Nat} -> ((OpInvolutiveRingoidWithAntiDistribTerm n) -> (Staged (OpInvolutiveRingoidWithAntiDistribTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpInvolutiveRingoidWithAntiDistribTerm2 n A) -> ((OpInvolutiveRingoidWithAntiDistribTerm2 n A) -> (OpInvolutiveRingoidWithAntiDistribTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpInvolutiveRingoidWithAntiDistribTerm2 n A) -> ((OpInvolutiveRingoidWithAntiDistribTerm2 n A) -> (OpInvolutiveRingoidWithAntiDistribTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    primOL2' : {n : Nat} {A : Set} -> ((OpInvolutiveRingoidWithAntiDistribTerm2 n A) -> (OpInvolutiveRingoidWithAntiDistribTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpInvolutiveRingoidWithAntiDistribTerm2 n A) -> (Staged (OpInvolutiveRingoidWithAntiDistribTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        primT : ((Repr A) -> (Repr A))
  module InvolutiveSemigroup  where
    record InvolutiveSemigroup (A : Set) : Set where
      constructor InvolutiveSemigroupC
      field
        op : (A -> (A -> A))
        associative_op : {x y z : A} -> (op (op x y) z) == (op x (op y z))
        prim : (A -> A)
        involutive_prim : {x : A} -> (prim (prim x)) == x
        antidis_prim_op : {x y : A} -> (prim (op x y)) == (op (prim y) (prim x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        primS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        primP : ((Prod A A) -> (Prod A A))
        associative_opP : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP (opP yP zP))
        involutive_primP : {xP : (Prod A A)} -> (primP (primP xP)) == xP
        antidis_prim_opP : {xP yP : (Prod A A)} -> (primP (opP xP yP)) == (opP (primP yP) (primP xP))
    record Hom {A1 : Set} {A2 : Set} (In1 : (InvolutiveSemigroup A1)) (In2 : (InvolutiveSemigroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op In1) x1 x2)) == ((op In2) (hom x1) (hom x2))
        pres-prim : {x1 : A1} -> (hom ((prim In1) x1)) == ((prim In2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (In1 : (InvolutiveSemigroup A1)) (In2 : (InvolutiveSemigroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op In1) x1 x2) ((op In2) y1 y2))))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim In1) x1) ((prim In2) y1)))
    data InvolutiveSemigroupTerm  : Set where
      opL : (InvolutiveSemigroupTerm -> (InvolutiveSemigroupTerm -> InvolutiveSemigroupTerm))
      primL : (InvolutiveSemigroupTerm -> InvolutiveSemigroupTerm)
    data ClInvolutiveSemigroupTerm (A : Set) : Set where
      sing : (A -> (ClInvolutiveSemigroupTerm A))
      opCl : ((ClInvolutiveSemigroupTerm A) -> ((ClInvolutiveSemigroupTerm A) -> (ClInvolutiveSemigroupTerm A)))
      primCl : ((ClInvolutiveSemigroupTerm A) -> (ClInvolutiveSemigroupTerm A))
    data OpInvolutiveSemigroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpInvolutiveSemigroupTerm n))
      opOL : ((OpInvolutiveSemigroupTerm n) -> ((OpInvolutiveSemigroupTerm n) -> (OpInvolutiveSemigroupTerm n)))
      primOL : ((OpInvolutiveSemigroupTerm n) -> (OpInvolutiveSemigroupTerm n))
    data OpInvolutiveSemigroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpInvolutiveSemigroupTerm2 n A))
      sing2 : (A -> (OpInvolutiveSemigroupTerm2 n A))
      opOL2 : ((OpInvolutiveSemigroupTerm2 n A) -> ((OpInvolutiveSemigroupTerm2 n A) -> (OpInvolutiveSemigroupTerm2 n A)))
      primOL2 : ((OpInvolutiveSemigroupTerm2 n A) -> (OpInvolutiveSemigroupTerm2 n A))
    simplifyCl : {A : Set} -> ((ClInvolutiveSemigroupTerm A) -> (ClInvolutiveSemigroupTerm A))
    simplifyCl (primCl (primCl x)) = x 
    simplifyCl (opCl (primCl y) (primCl x)) = (primCl (opCl x y)) 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpInvolutiveSemigroupTerm n) -> (OpInvolutiveSemigroupTerm n))
    simplifyOpB (primOL (primOL x)) = x 
    simplifyOpB (opOL (primOL y) (primOL x)) = (primOL (opOL x y)) 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpInvolutiveSemigroupTerm2 n A) -> (OpInvolutiveSemigroupTerm2 n A))
    simplifyOp (primOL2 (primOL2 x)) = x 
    simplifyOp (opOL2 (primOL2 y) (primOL2 x)) = (primOL2 (opOL2 x y)) 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((InvolutiveSemigroup A) -> (InvolutiveSemigroupTerm -> A))
    evalB In (opL x1 x2) = ((op In) (evalB In x1) (evalB In x2)) 
    evalB In (primL x1) = ((prim In) (evalB In x1)) 
    evalCl : {A : Set} -> ((InvolutiveSemigroup A) -> ((ClInvolutiveSemigroupTerm A) -> A))
    evalCl In (sing x1) = x1 
    evalCl In (opCl x1 x2) = ((op In) (evalCl In x1) (evalCl In x2)) 
    evalCl In (primCl x1) = ((prim In) (evalCl In x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((InvolutiveSemigroup A) -> ((Vec A n) -> ((OpInvolutiveSemigroupTerm n) -> A)))
    evalOpB In vars (v x1) = (lookup _ x1 vars) 
    evalOpB In vars (opOL x1 x2) = ((op In) (evalOpB In vars x1) (evalOpB In vars x2)) 
    evalOpB In vars (primOL x1) = ((prim In) (evalOpB In vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((InvolutiveSemigroup A) -> ((Vec A n) -> ((OpInvolutiveSemigroupTerm2 n A) -> A)))
    evalOp In vars (v2 x1) = (lookup _ x1 vars) 
    evalOp In vars (sing2 x1) = x1 
    evalOp In vars (opOL2 x1 x2) = ((op In) (evalOp In vars x1) (evalOp In vars x2)) 
    evalOp In vars (primOL2 x1) = ((prim In) (evalOp In vars x1)) 
    inductionB : {P : (InvolutiveSemigroupTerm -> Set)} -> (((x1 x2 : InvolutiveSemigroupTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> (((x1 : InvolutiveSemigroupTerm) -> ((P x1) -> (P (primL x1)))) -> ((x : InvolutiveSemigroupTerm) -> (P x))))
    inductionB {p} popl ppriml (opL x1 x2) = (popl _ _ (inductionB {p} popl ppriml x1) (inductionB {p} popl ppriml x2)) 
    inductionB {p} popl ppriml (primL x1) = (ppriml _ (inductionB {p} popl ppriml x1)) 
    inductionCl : {A : Set} {P : ((ClInvolutiveSemigroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClInvolutiveSemigroupTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> (((x1 : (ClInvolutiveSemigroupTerm A)) -> ((P x1) -> (P (primCl x1)))) -> ((x : (ClInvolutiveSemigroupTerm A)) -> (P x)))))
    inductionCl {_} {p} psing popcl pprimcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl pprimcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl pprimcl x1) (inductionCl {_} {p} psing popcl pprimcl x2)) 
    inductionCl {_} {p} psing popcl pprimcl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing popcl pprimcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpInvolutiveSemigroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpInvolutiveSemigroupTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> (((x1 : (OpInvolutiveSemigroupTerm n)) -> ((P x1) -> (P (primOL x1)))) -> ((x : (OpInvolutiveSemigroupTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv popol pprimol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol pprimol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol pprimol x1) (inductionOpB {_} {p} pv popol pprimol x2)) 
    inductionOpB {_} {p} pv popol pprimol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv popol pprimol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpInvolutiveSemigroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpInvolutiveSemigroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> (((x1 : (OpInvolutiveSemigroupTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> ((x : (OpInvolutiveSemigroupTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 pprimol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 pprimol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 pprimol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 pprimol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 pprimol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 pprimol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 popol2 pprimol2 x1)) 
    opL' : (InvolutiveSemigroupTerm -> (InvolutiveSemigroupTerm -> InvolutiveSemigroupTerm))
    opL' x1 x2 = (opL x1 x2) 
    primL' : (InvolutiveSemigroupTerm -> InvolutiveSemigroupTerm)
    primL' x1 = (primL x1) 
    stageB : (InvolutiveSemigroupTerm -> (Staged InvolutiveSemigroupTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    opCl' : {A : Set} -> ((ClInvolutiveSemigroupTerm A) -> ((ClInvolutiveSemigroupTerm A) -> (ClInvolutiveSemigroupTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    primCl' : {A : Set} -> ((ClInvolutiveSemigroupTerm A) -> (ClInvolutiveSemigroupTerm A))
    primCl' x1 = (primCl x1) 
    stageCl : {A : Set} -> ((ClInvolutiveSemigroupTerm A) -> (Staged (ClInvolutiveSemigroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    opOL' : {n : Nat} -> ((OpInvolutiveSemigroupTerm n) -> ((OpInvolutiveSemigroupTerm n) -> (OpInvolutiveSemigroupTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    primOL' : {n : Nat} -> ((OpInvolutiveSemigroupTerm n) -> (OpInvolutiveSemigroupTerm n))
    primOL' x1 = (primOL x1) 
    stageOpB : {n : Nat} -> ((OpInvolutiveSemigroupTerm n) -> (Staged (OpInvolutiveSemigroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpInvolutiveSemigroupTerm2 n A) -> ((OpInvolutiveSemigroupTerm2 n A) -> (OpInvolutiveSemigroupTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    primOL2' : {n : Nat} {A : Set} -> ((OpInvolutiveSemigroupTerm2 n A) -> (OpInvolutiveSemigroupTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpInvolutiveSemigroupTerm2 n A) -> (Staged (OpInvolutiveSemigroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        primT : ((Repr A) -> (Repr A))
  module JacobianIdentity  where
    record JacobianIdentity (A : Set) : Set where
      constructor JacobianIdentityC
      field
        0 : A
        + : (A -> (A -> A))
        * : (A -> (A -> A))
        jacobian_*_+ : {x y z : A} -> (+ (+ (* x (* y z)) (* y (* z x))) (* z (* x y))) == 0
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        0S : AS
        +S : (AS -> (AS -> AS))
        *S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        0P : (Prod A A)
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        jacobian_*_+P : {xP yP zP : (Prod A A)} -> (+P (+P (*P xP (*P yP zP)) (*P yP (*P zP xP))) (*P zP (*P xP yP))) == 0P
    record Hom {A1 : Set} {A2 : Set} (Ja1 : (JacobianIdentity A1)) (Ja2 : (JacobianIdentity A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-0 : (hom (0 Ja1)) == (0 Ja2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ja1) x1 x2)) == ((+ Ja2) (hom x1) (hom x2))
        pres-* : {x1 x2 : A1} -> (hom ((* Ja1) x1 x2)) == ((* Ja2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ja1 : (JacobianIdentity A1)) (Ja2 : (JacobianIdentity A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-0 : (interp (0 Ja1) (0 Ja2))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ja1) x1 x2) ((+ Ja2) y1 y2))))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Ja1) x1 x2) ((* Ja2) y1 y2))))
    data JacobianIdentityTerm  : Set where
      0L : JacobianIdentityTerm
      +L : (JacobianIdentityTerm -> (JacobianIdentityTerm -> JacobianIdentityTerm))
      *L : (JacobianIdentityTerm -> (JacobianIdentityTerm -> JacobianIdentityTerm))
    data ClJacobianIdentityTerm (A : Set) : Set where
      sing : (A -> (ClJacobianIdentityTerm A))
      0Cl : (ClJacobianIdentityTerm A)
      +Cl : ((ClJacobianIdentityTerm A) -> ((ClJacobianIdentityTerm A) -> (ClJacobianIdentityTerm A)))
      *Cl : ((ClJacobianIdentityTerm A) -> ((ClJacobianIdentityTerm A) -> (ClJacobianIdentityTerm A)))
    data OpJacobianIdentityTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpJacobianIdentityTerm n))
      0OL : (OpJacobianIdentityTerm n)
      +OL : ((OpJacobianIdentityTerm n) -> ((OpJacobianIdentityTerm n) -> (OpJacobianIdentityTerm n)))
      *OL : ((OpJacobianIdentityTerm n) -> ((OpJacobianIdentityTerm n) -> (OpJacobianIdentityTerm n)))
    data OpJacobianIdentityTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpJacobianIdentityTerm2 n A))
      sing2 : (A -> (OpJacobianIdentityTerm2 n A))
      0OL2 : (OpJacobianIdentityTerm2 n A)
      +OL2 : ((OpJacobianIdentityTerm2 n A) -> ((OpJacobianIdentityTerm2 n A) -> (OpJacobianIdentityTerm2 n A)))
      *OL2 : ((OpJacobianIdentityTerm2 n A) -> ((OpJacobianIdentityTerm2 n A) -> (OpJacobianIdentityTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClJacobianIdentityTerm A) -> (ClJacobianIdentityTerm A))
    simplifyCl 0Cl = 0Cl 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpJacobianIdentityTerm n) -> (OpJacobianIdentityTerm n))
    simplifyOpB 0OL = 0OL 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpJacobianIdentityTerm2 n A) -> (OpJacobianIdentityTerm2 n A))
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((JacobianIdentity A) -> (JacobianIdentityTerm -> A))
    evalB Ja 0L = (0 Ja) 
    evalB Ja (+L x1 x2) = ((+ Ja) (evalB Ja x1) (evalB Ja x2)) 
    evalB Ja (*L x1 x2) = ((* Ja) (evalB Ja x1) (evalB Ja x2)) 
    evalCl : {A : Set} -> ((JacobianIdentity A) -> ((ClJacobianIdentityTerm A) -> A))
    evalCl Ja (sing x1) = x1 
    evalCl Ja 0Cl = (0 Ja) 
    evalCl Ja (+Cl x1 x2) = ((+ Ja) (evalCl Ja x1) (evalCl Ja x2)) 
    evalCl Ja (*Cl x1 x2) = ((* Ja) (evalCl Ja x1) (evalCl Ja x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((JacobianIdentity A) -> ((Vec A n) -> ((OpJacobianIdentityTerm n) -> A)))
    evalOpB Ja vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ja vars 0OL = (0 Ja) 
    evalOpB Ja vars (+OL x1 x2) = ((+ Ja) (evalOpB Ja vars x1) (evalOpB Ja vars x2)) 
    evalOpB Ja vars (*OL x1 x2) = ((* Ja) (evalOpB Ja vars x1) (evalOpB Ja vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((JacobianIdentity A) -> ((Vec A n) -> ((OpJacobianIdentityTerm2 n A) -> A)))
    evalOp Ja vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ja vars (sing2 x1) = x1 
    evalOp Ja vars 0OL2 = (0 Ja) 
    evalOp Ja vars (+OL2 x1 x2) = ((+ Ja) (evalOp Ja vars x1) (evalOp Ja vars x2)) 
    evalOp Ja vars (*OL2 x1 x2) = ((* Ja) (evalOp Ja vars x1) (evalOp Ja vars x2)) 
    inductionB : {P : (JacobianIdentityTerm -> Set)} -> ((P 0L) -> (((x1 x2 : JacobianIdentityTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> (((x1 x2 : JacobianIdentityTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((x : JacobianIdentityTerm) -> (P x)))))
    inductionB {p} p0l p+l p*l 0L = p0l 
    inductionB {p} p0l p+l p*l (+L x1 x2) = (p+l _ _ (inductionB {p} p0l p+l p*l x1) (inductionB {p} p0l p+l p*l x2)) 
    inductionB {p} p0l p+l p*l (*L x1 x2) = (p*l _ _ (inductionB {p} p0l p+l p*l x1) (inductionB {p} p0l p+l p*l x2)) 
    inductionCl : {A : Set} {P : ((ClJacobianIdentityTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 0Cl) -> (((x1 x2 : (ClJacobianIdentityTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> (((x1 x2 : (ClJacobianIdentityTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((x : (ClJacobianIdentityTerm A)) -> (P x))))))
    inductionCl {_} {p} psing p0cl p+cl p*cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p0cl p+cl p*cl 0Cl = p0cl 
    inductionCl {_} {p} psing p0cl p+cl p*cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p0cl p+cl p*cl x1) (inductionCl {_} {p} psing p0cl p+cl p*cl x2)) 
    inductionCl {_} {p} psing p0cl p+cl p*cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p0cl p+cl p*cl x1) (inductionCl {_} {p} psing p0cl p+cl p*cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpJacobianIdentityTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 0OL) -> (((x1 x2 : (OpJacobianIdentityTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> (((x1 x2 : (OpJacobianIdentityTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((x : (OpJacobianIdentityTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv p0ol p+ol p*ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p0ol p+ol p*ol 0OL = p0ol 
    inductionOpB {_} {p} pv p0ol p+ol p*ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p0ol p+ol p*ol x1) (inductionOpB {_} {p} pv p0ol p+ol p*ol x2)) 
    inductionOpB {_} {p} pv p0ol p+ol p*ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p0ol p+ol p*ol x1) (inductionOpB {_} {p} pv p0ol p+ol p*ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpJacobianIdentityTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 0OL2) -> (((x1 x2 : (OpJacobianIdentityTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> (((x1 x2 : (OpJacobianIdentityTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((x : (OpJacobianIdentityTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 x2)) 
    0L' : JacobianIdentityTerm
    0L'  = 0L 
    +L' : (JacobianIdentityTerm -> (JacobianIdentityTerm -> JacobianIdentityTerm))
    +L' x1 x2 = (+L x1 x2) 
    *L' : (JacobianIdentityTerm -> (JacobianIdentityTerm -> JacobianIdentityTerm))
    *L' x1 x2 = (*L x1 x2) 
    stageB : (JacobianIdentityTerm -> (Staged JacobianIdentityTerm))
    stageB 0L = (Now 0L) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    0Cl' : {A : Set} -> (ClJacobianIdentityTerm A)
    0Cl'  = 0Cl 
    +Cl' : {A : Set} -> ((ClJacobianIdentityTerm A) -> ((ClJacobianIdentityTerm A) -> (ClJacobianIdentityTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    *Cl' : {A : Set} -> ((ClJacobianIdentityTerm A) -> ((ClJacobianIdentityTerm A) -> (ClJacobianIdentityTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    stageCl : {A : Set} -> ((ClJacobianIdentityTerm A) -> (Staged (ClJacobianIdentityTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    0OL' : {n : Nat} -> (OpJacobianIdentityTerm n)
    0OL'  = 0OL 
    +OL' : {n : Nat} -> ((OpJacobianIdentityTerm n) -> ((OpJacobianIdentityTerm n) -> (OpJacobianIdentityTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    *OL' : {n : Nat} -> ((OpJacobianIdentityTerm n) -> ((OpJacobianIdentityTerm n) -> (OpJacobianIdentityTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpJacobianIdentityTerm n) -> (Staged (OpJacobianIdentityTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    0OL2' : {n : Nat} {A : Set} -> (OpJacobianIdentityTerm2 n A)
    0OL2'  = 0OL2 
    +OL2' : {n : Nat} {A : Set} -> ((OpJacobianIdentityTerm2 n A) -> ((OpJacobianIdentityTerm2 n A) -> (OpJacobianIdentityTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    *OL2' : {n : Nat} {A : Set} -> ((OpJacobianIdentityTerm2 n A) -> ((OpJacobianIdentityTerm2 n A) -> (OpJacobianIdentityTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpJacobianIdentityTerm2 n A) -> (Staged (OpJacobianIdentityTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        0T : (Repr A)
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module JoinSemilattice  where
    record JoinSemilattice (A : Set) : Set where
      constructor JoinSemilatticeC
      field
        + : (A -> (A -> A))
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        idempotent_+ : {x : A} -> (+ x x) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        idempotent_+P : {xP : (Prod A A)} -> (+P xP xP) == xP
    record Hom {A1 : Set} {A2 : Set} (Jo1 : (JoinSemilattice A1)) (Jo2 : (JoinSemilattice A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Jo1) x1 x2)) == ((+ Jo2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Jo1 : (JoinSemilattice A1)) (Jo2 : (JoinSemilattice A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Jo1) x1 x2) ((+ Jo2) y1 y2))))
    data JoinSemilatticeTerm  : Set where
      +L : (JoinSemilatticeTerm -> (JoinSemilatticeTerm -> JoinSemilatticeTerm))
    data ClJoinSemilatticeTerm (A : Set) : Set where
      sing : (A -> (ClJoinSemilatticeTerm A))
      +Cl : ((ClJoinSemilatticeTerm A) -> ((ClJoinSemilatticeTerm A) -> (ClJoinSemilatticeTerm A)))
    data OpJoinSemilatticeTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpJoinSemilatticeTerm n))
      +OL : ((OpJoinSemilatticeTerm n) -> ((OpJoinSemilatticeTerm n) -> (OpJoinSemilatticeTerm n)))
    data OpJoinSemilatticeTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpJoinSemilatticeTerm2 n A))
      sing2 : (A -> (OpJoinSemilatticeTerm2 n A))
      +OL2 : ((OpJoinSemilatticeTerm2 n A) -> ((OpJoinSemilatticeTerm2 n A) -> (OpJoinSemilatticeTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClJoinSemilatticeTerm A) -> (ClJoinSemilatticeTerm A))
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpJoinSemilatticeTerm n) -> (OpJoinSemilatticeTerm n))
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpJoinSemilatticeTerm2 n A) -> (OpJoinSemilatticeTerm2 n A))
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((JoinSemilattice A) -> (JoinSemilatticeTerm -> A))
    evalB Jo (+L x1 x2) = ((+ Jo) (evalB Jo x1) (evalB Jo x2)) 
    evalCl : {A : Set} -> ((JoinSemilattice A) -> ((ClJoinSemilatticeTerm A) -> A))
    evalCl Jo (sing x1) = x1 
    evalCl Jo (+Cl x1 x2) = ((+ Jo) (evalCl Jo x1) (evalCl Jo x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((JoinSemilattice A) -> ((Vec A n) -> ((OpJoinSemilatticeTerm n) -> A)))
    evalOpB Jo vars (v x1) = (lookup _ x1 vars) 
    evalOpB Jo vars (+OL x1 x2) = ((+ Jo) (evalOpB Jo vars x1) (evalOpB Jo vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((JoinSemilattice A) -> ((Vec A n) -> ((OpJoinSemilatticeTerm2 n A) -> A)))
    evalOp Jo vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Jo vars (sing2 x1) = x1 
    evalOp Jo vars (+OL2 x1 x2) = ((+ Jo) (evalOp Jo vars x1) (evalOp Jo vars x2)) 
    inductionB : {P : (JoinSemilatticeTerm -> Set)} -> (((x1 x2 : JoinSemilatticeTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : JoinSemilatticeTerm) -> (P x)))
    inductionB {p} p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p+l x1) (inductionB {p} p+l x2)) 
    inductionCl : {A : Set} {P : ((ClJoinSemilatticeTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClJoinSemilatticeTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClJoinSemilatticeTerm A)) -> (P x))))
    inductionCl {_} {p} psing p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p+cl x1) (inductionCl {_} {p} psing p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpJoinSemilatticeTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpJoinSemilatticeTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpJoinSemilatticeTerm n)) -> (P x))))
    inductionOpB {_} {p} pv p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p+ol x1) (inductionOpB {_} {p} pv p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpJoinSemilatticeTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpJoinSemilatticeTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpJoinSemilatticeTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 x2)) 
    +L' : (JoinSemilatticeTerm -> (JoinSemilatticeTerm -> JoinSemilatticeTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (JoinSemilatticeTerm -> (Staged JoinSemilatticeTerm))
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    +Cl' : {A : Set} -> ((ClJoinSemilatticeTerm A) -> ((ClJoinSemilatticeTerm A) -> (ClJoinSemilatticeTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClJoinSemilatticeTerm A) -> (Staged (ClJoinSemilatticeTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    +OL' : {n : Nat} -> ((OpJoinSemilatticeTerm n) -> ((OpJoinSemilatticeTerm n) -> (OpJoinSemilatticeTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpJoinSemilatticeTerm n) -> (Staged (OpJoinSemilatticeTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    +OL2' : {n : Nat} {A : Set} -> ((OpJoinSemilatticeTerm2 n A) -> ((OpJoinSemilatticeTerm2 n A) -> (OpJoinSemilatticeTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpJoinSemilatticeTerm2 n A) -> (Staged (OpJoinSemilatticeTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module JoinSemilattice_RingoidSig  where
    record JoinSemilattice_RingoidSig (A : Set) : Set where
      constructor JoinSemilattice_RingoidSigC
      field
        + : (A -> (A -> A))
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        idempotent_+ : {x : A} -> (+ x x) == x
        * : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        +S : (AS -> (AS -> AS))
        *S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        idempotent_+P : {xP : (Prod A A)} -> (+P xP xP) == xP
    record Hom {A1 : Set} {A2 : Set} (Jo1 : (JoinSemilattice_RingoidSig A1)) (Jo2 : (JoinSemilattice_RingoidSig A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Jo1) x1 x2)) == ((+ Jo2) (hom x1) (hom x2))
        pres-* : {x1 x2 : A1} -> (hom ((* Jo1) x1 x2)) == ((* Jo2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Jo1 : (JoinSemilattice_RingoidSig A1)) (Jo2 : (JoinSemilattice_RingoidSig A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Jo1) x1 x2) ((+ Jo2) y1 y2))))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Jo1) x1 x2) ((* Jo2) y1 y2))))
    data JoinSemilattice_RingoidSigTerm  : Set where
      +L : (JoinSemilattice_RingoidSigTerm -> (JoinSemilattice_RingoidSigTerm -> JoinSemilattice_RingoidSigTerm))
      *L : (JoinSemilattice_RingoidSigTerm -> (JoinSemilattice_RingoidSigTerm -> JoinSemilattice_RingoidSigTerm))
    data ClJoinSemilattice_RingoidSigTerm (A : Set) : Set where
      sing : (A -> (ClJoinSemilattice_RingoidSigTerm A))
      +Cl : ((ClJoinSemilattice_RingoidSigTerm A) -> ((ClJoinSemilattice_RingoidSigTerm A) -> (ClJoinSemilattice_RingoidSigTerm A)))
      *Cl : ((ClJoinSemilattice_RingoidSigTerm A) -> ((ClJoinSemilattice_RingoidSigTerm A) -> (ClJoinSemilattice_RingoidSigTerm A)))
    data OpJoinSemilattice_RingoidSigTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpJoinSemilattice_RingoidSigTerm n))
      +OL : ((OpJoinSemilattice_RingoidSigTerm n) -> ((OpJoinSemilattice_RingoidSigTerm n) -> (OpJoinSemilattice_RingoidSigTerm n)))
      *OL : ((OpJoinSemilattice_RingoidSigTerm n) -> ((OpJoinSemilattice_RingoidSigTerm n) -> (OpJoinSemilattice_RingoidSigTerm n)))
    data OpJoinSemilattice_RingoidSigTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpJoinSemilattice_RingoidSigTerm2 n A))
      sing2 : (A -> (OpJoinSemilattice_RingoidSigTerm2 n A))
      +OL2 : ((OpJoinSemilattice_RingoidSigTerm2 n A) -> ((OpJoinSemilattice_RingoidSigTerm2 n A) -> (OpJoinSemilattice_RingoidSigTerm2 n A)))
      *OL2 : ((OpJoinSemilattice_RingoidSigTerm2 n A) -> ((OpJoinSemilattice_RingoidSigTerm2 n A) -> (OpJoinSemilattice_RingoidSigTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClJoinSemilattice_RingoidSigTerm A) -> (ClJoinSemilattice_RingoidSigTerm A))
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpJoinSemilattice_RingoidSigTerm n) -> (OpJoinSemilattice_RingoidSigTerm n))
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpJoinSemilattice_RingoidSigTerm2 n A) -> (OpJoinSemilattice_RingoidSigTerm2 n A))
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((JoinSemilattice_RingoidSig A) -> (JoinSemilattice_RingoidSigTerm -> A))
    evalB Jo (+L x1 x2) = ((+ Jo) (evalB Jo x1) (evalB Jo x2)) 
    evalB Jo (*L x1 x2) = ((* Jo) (evalB Jo x1) (evalB Jo x2)) 
    evalCl : {A : Set} -> ((JoinSemilattice_RingoidSig A) -> ((ClJoinSemilattice_RingoidSigTerm A) -> A))
    evalCl Jo (sing x1) = x1 
    evalCl Jo (+Cl x1 x2) = ((+ Jo) (evalCl Jo x1) (evalCl Jo x2)) 
    evalCl Jo (*Cl x1 x2) = ((* Jo) (evalCl Jo x1) (evalCl Jo x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((JoinSemilattice_RingoidSig A) -> ((Vec A n) -> ((OpJoinSemilattice_RingoidSigTerm n) -> A)))
    evalOpB Jo vars (v x1) = (lookup _ x1 vars) 
    evalOpB Jo vars (+OL x1 x2) = ((+ Jo) (evalOpB Jo vars x1) (evalOpB Jo vars x2)) 
    evalOpB Jo vars (*OL x1 x2) = ((* Jo) (evalOpB Jo vars x1) (evalOpB Jo vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((JoinSemilattice_RingoidSig A) -> ((Vec A n) -> ((OpJoinSemilattice_RingoidSigTerm2 n A) -> A)))
    evalOp Jo vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Jo vars (sing2 x1) = x1 
    evalOp Jo vars (+OL2 x1 x2) = ((+ Jo) (evalOp Jo vars x1) (evalOp Jo vars x2)) 
    evalOp Jo vars (*OL2 x1 x2) = ((* Jo) (evalOp Jo vars x1) (evalOp Jo vars x2)) 
    inductionB : {P : (JoinSemilattice_RingoidSigTerm -> Set)} -> (((x1 x2 : JoinSemilattice_RingoidSigTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> (((x1 x2 : JoinSemilattice_RingoidSigTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((x : JoinSemilattice_RingoidSigTerm) -> (P x))))
    inductionB {p} p+l p*l (+L x1 x2) = (p+l _ _ (inductionB {p} p+l p*l x1) (inductionB {p} p+l p*l x2)) 
    inductionB {p} p+l p*l (*L x1 x2) = (p*l _ _ (inductionB {p} p+l p*l x1) (inductionB {p} p+l p*l x2)) 
    inductionCl : {A : Set} {P : ((ClJoinSemilattice_RingoidSigTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClJoinSemilattice_RingoidSigTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> (((x1 x2 : (ClJoinSemilattice_RingoidSigTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((x : (ClJoinSemilattice_RingoidSigTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p+cl p*cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p+cl p*cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p+cl p*cl x1) (inductionCl {_} {p} psing p+cl p*cl x2)) 
    inductionCl {_} {p} psing p+cl p*cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p+cl p*cl x1) (inductionCl {_} {p} psing p+cl p*cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpJoinSemilattice_RingoidSigTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpJoinSemilattice_RingoidSigTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> (((x1 x2 : (OpJoinSemilattice_RingoidSigTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((x : (OpJoinSemilattice_RingoidSigTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p+ol p*ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p+ol p*ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p+ol p*ol x1) (inductionOpB {_} {p} pv p+ol p*ol x2)) 
    inductionOpB {_} {p} pv p+ol p*ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p+ol p*ol x1) (inductionOpB {_} {p} pv p+ol p*ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpJoinSemilattice_RingoidSigTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpJoinSemilattice_RingoidSigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> (((x1 x2 : (OpJoinSemilattice_RingoidSigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((x : (OpJoinSemilattice_RingoidSigTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 x2)) 
    +L' : (JoinSemilattice_RingoidSigTerm -> (JoinSemilattice_RingoidSigTerm -> JoinSemilattice_RingoidSigTerm))
    +L' x1 x2 = (+L x1 x2) 
    *L' : (JoinSemilattice_RingoidSigTerm -> (JoinSemilattice_RingoidSigTerm -> JoinSemilattice_RingoidSigTerm))
    *L' x1 x2 = (*L x1 x2) 
    stageB : (JoinSemilattice_RingoidSigTerm -> (Staged JoinSemilattice_RingoidSigTerm))
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    +Cl' : {A : Set} -> ((ClJoinSemilattice_RingoidSigTerm A) -> ((ClJoinSemilattice_RingoidSigTerm A) -> (ClJoinSemilattice_RingoidSigTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    *Cl' : {A : Set} -> ((ClJoinSemilattice_RingoidSigTerm A) -> ((ClJoinSemilattice_RingoidSigTerm A) -> (ClJoinSemilattice_RingoidSigTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    stageCl : {A : Set} -> ((ClJoinSemilattice_RingoidSigTerm A) -> (Staged (ClJoinSemilattice_RingoidSigTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    +OL' : {n : Nat} -> ((OpJoinSemilattice_RingoidSigTerm n) -> ((OpJoinSemilattice_RingoidSigTerm n) -> (OpJoinSemilattice_RingoidSigTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    *OL' : {n : Nat} -> ((OpJoinSemilattice_RingoidSigTerm n) -> ((OpJoinSemilattice_RingoidSigTerm n) -> (OpJoinSemilattice_RingoidSigTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpJoinSemilattice_RingoidSigTerm n) -> (Staged (OpJoinSemilattice_RingoidSigTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    +OL2' : {n : Nat} {A : Set} -> ((OpJoinSemilattice_RingoidSigTerm2 n A) -> ((OpJoinSemilattice_RingoidSigTerm2 n A) -> (OpJoinSemilattice_RingoidSigTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    *OL2' : {n : Nat} {A : Set} -> ((OpJoinSemilattice_RingoidSigTerm2 n A) -> ((OpJoinSemilattice_RingoidSigTerm2 n A) -> (OpJoinSemilattice_RingoidSigTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpJoinSemilattice_RingoidSigTerm2 n A) -> (Staged (OpJoinSemilattice_RingoidSigTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module Kei  where
    record Kei (A : Set) : Set where
      constructor KeiC
      field
        |> : (A -> (A -> A))
        leftDistributive : {x y z : A} -> (|> x (|> y z)) == (|> (|> x y) (|> x z))
        idempotent_|> : {x : A} -> (|> x x) == x
        rightSelfInverse_|> : {x y : A} -> (|> (|> x y) y) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        |>S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        |>P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftDistributiveP : {xP yP zP : (Prod A A)} -> (|>P xP (|>P yP zP)) == (|>P (|>P xP yP) (|>P xP zP))
        idempotent_|>P : {xP : (Prod A A)} -> (|>P xP xP) == xP
        rightSelfInverse_|>P : {xP yP : (Prod A A)} -> (|>P (|>P xP yP) yP) == xP
    record Hom {A1 : Set} {A2 : Set} (Ke1 : (Kei A1)) (Ke2 : (Kei A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-|> : {x1 x2 : A1} -> (hom ((|> Ke1) x1 x2)) == ((|> Ke2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ke1 : (Kei A1)) (Ke2 : (Kei A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-|> : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((|> Ke1) x1 x2) ((|> Ke2) y1 y2))))
    data KeiTerm  : Set where
      |>L : (KeiTerm -> (KeiTerm -> KeiTerm))
    data ClKeiTerm (A : Set) : Set where
      sing : (A -> (ClKeiTerm A))
      |>Cl : ((ClKeiTerm A) -> ((ClKeiTerm A) -> (ClKeiTerm A)))
    data OpKeiTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpKeiTerm n))
      |>OL : ((OpKeiTerm n) -> ((OpKeiTerm n) -> (OpKeiTerm n)))
    data OpKeiTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpKeiTerm2 n A))
      sing2 : (A -> (OpKeiTerm2 n A))
      |>OL2 : ((OpKeiTerm2 n A) -> ((OpKeiTerm2 n A) -> (OpKeiTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClKeiTerm A) -> (ClKeiTerm A))
    simplifyCl (|>Cl x1 x2) = (|>Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpKeiTerm n) -> (OpKeiTerm n))
    simplifyOpB (|>OL x1 x2) = (|>OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpKeiTerm2 n A) -> (OpKeiTerm2 n A))
    simplifyOp (|>OL2 x1 x2) = (|>OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Kei A) -> (KeiTerm -> A))
    evalB Ke (|>L x1 x2) = ((|> Ke) (evalB Ke x1) (evalB Ke x2)) 
    evalCl : {A : Set} -> ((Kei A) -> ((ClKeiTerm A) -> A))
    evalCl Ke (sing x1) = x1 
    evalCl Ke (|>Cl x1 x2) = ((|> Ke) (evalCl Ke x1) (evalCl Ke x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Kei A) -> ((Vec A n) -> ((OpKeiTerm n) -> A)))
    evalOpB Ke vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ke vars (|>OL x1 x2) = ((|> Ke) (evalOpB Ke vars x1) (evalOpB Ke vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Kei A) -> ((Vec A n) -> ((OpKeiTerm2 n A) -> A)))
    evalOp Ke vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ke vars (sing2 x1) = x1 
    evalOp Ke vars (|>OL2 x1 x2) = ((|> Ke) (evalOp Ke vars x1) (evalOp Ke vars x2)) 
    inductionB : {P : (KeiTerm -> Set)} -> (((x1 x2 : KeiTerm) -> ((P x1) -> ((P x2) -> (P (|>L x1 x2))))) -> ((x : KeiTerm) -> (P x)))
    inductionB {p} p|>l (|>L x1 x2) = (p|>l _ _ (inductionB {p} p|>l x1) (inductionB {p} p|>l x2)) 
    inductionCl : {A : Set} {P : ((ClKeiTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClKeiTerm A)) -> ((P x1) -> ((P x2) -> (P (|>Cl x1 x2))))) -> ((x : (ClKeiTerm A)) -> (P x))))
    inductionCl {_} {p} psing p|>cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p|>cl (|>Cl x1 x2) = (p|>cl _ _ (inductionCl {_} {p} psing p|>cl x1) (inductionCl {_} {p} psing p|>cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpKeiTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpKeiTerm n)) -> ((P x1) -> ((P x2) -> (P (|>OL x1 x2))))) -> ((x : (OpKeiTerm n)) -> (P x))))
    inductionOpB {_} {p} pv p|>ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p|>ol (|>OL x1 x2) = (p|>ol _ _ (inductionOpB {_} {p} pv p|>ol x1) (inductionOpB {_} {p} pv p|>ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpKeiTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpKeiTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (|>OL2 x1 x2))))) -> ((x : (OpKeiTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 (|>OL2 x1 x2) = (p|>ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 x2)) 
    |>L' : (KeiTerm -> (KeiTerm -> KeiTerm))
    |>L' x1 x2 = (|>L x1 x2) 
    stageB : (KeiTerm -> (Staged KeiTerm))
    stageB (|>L x1 x2) = (stage2 |>L' (codeLift2 |>L') (stageB x1) (stageB x2)) 
    |>Cl' : {A : Set} -> ((ClKeiTerm A) -> ((ClKeiTerm A) -> (ClKeiTerm A)))
    |>Cl' x1 x2 = (|>Cl x1 x2) 
    stageCl : {A : Set} -> ((ClKeiTerm A) -> (Staged (ClKeiTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (|>Cl x1 x2) = (stage2 |>Cl' (codeLift2 |>Cl') (stageCl x1) (stageCl x2)) 
    |>OL' : {n : Nat} -> ((OpKeiTerm n) -> ((OpKeiTerm n) -> (OpKeiTerm n)))
    |>OL' x1 x2 = (|>OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpKeiTerm n) -> (Staged (OpKeiTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (|>OL x1 x2) = (stage2 |>OL' (codeLift2 |>OL') (stageOpB x1) (stageOpB x2)) 
    |>OL2' : {n : Nat} {A : Set} -> ((OpKeiTerm2 n A) -> ((OpKeiTerm2 n A) -> (OpKeiTerm2 n A)))
    |>OL2' x1 x2 = (|>OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpKeiTerm2 n A) -> (Staged (OpKeiTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (|>OL2 x1 x2) = (stage2 |>OL2' (codeLift2 |>OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        |>T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module Lattice  where
    record Lattice (A : Set) : Set where
      constructor LatticeC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        commutative_* : {x y : A} -> (* x y) == (* y x)
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        idempotent_* : {x : A} -> (* x x) == x
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        idempotent_+ : {x : A} -> (+ x x) == x
        leftAbsorp_*_+ : {x y : A} -> (* x (+ x y)) == x
        leftAbsorp_+_* : {x y : A} -> (+ x (* x y)) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        commutative_*P : {xP yP : (Prod A A)} -> (*P xP yP) == (*P yP xP)
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        idempotent_*P : {xP : (Prod A A)} -> (*P xP xP) == xP
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        idempotent_+P : {xP : (Prod A A)} -> (+P xP xP) == xP
        leftAbsorp_*_+P : {xP yP : (Prod A A)} -> (*P xP (+P xP yP)) == xP
        leftAbsorp_+_*P : {xP yP : (Prod A A)} -> (+P xP (*P xP yP)) == xP
    record Hom {A1 : Set} {A2 : Set} (La1 : (Lattice A1)) (La2 : (Lattice A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* La1) x1 x2)) == ((* La2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ La1) x1 x2)) == ((+ La2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (La1 : (Lattice A1)) (La2 : (Lattice A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* La1) x1 x2) ((* La2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ La1) x1 x2) ((+ La2) y1 y2))))
    data LatticeTerm  : Set where
      *L : (LatticeTerm -> (LatticeTerm -> LatticeTerm))
      +L : (LatticeTerm -> (LatticeTerm -> LatticeTerm))
    data ClLatticeTerm (A : Set) : Set where
      sing : (A -> (ClLatticeTerm A))
      *Cl : ((ClLatticeTerm A) -> ((ClLatticeTerm A) -> (ClLatticeTerm A)))
      +Cl : ((ClLatticeTerm A) -> ((ClLatticeTerm A) -> (ClLatticeTerm A)))
    data OpLatticeTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLatticeTerm n))
      *OL : ((OpLatticeTerm n) -> ((OpLatticeTerm n) -> (OpLatticeTerm n)))
      +OL : ((OpLatticeTerm n) -> ((OpLatticeTerm n) -> (OpLatticeTerm n)))
    data OpLatticeTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLatticeTerm2 n A))
      sing2 : (A -> (OpLatticeTerm2 n A))
      *OL2 : ((OpLatticeTerm2 n A) -> ((OpLatticeTerm2 n A) -> (OpLatticeTerm2 n A)))
      +OL2 : ((OpLatticeTerm2 n A) -> ((OpLatticeTerm2 n A) -> (OpLatticeTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClLatticeTerm A) -> (ClLatticeTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLatticeTerm n) -> (OpLatticeTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLatticeTerm2 n A) -> (OpLatticeTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Lattice A) -> (LatticeTerm -> A))
    evalB La (*L x1 x2) = ((* La) (evalB La x1) (evalB La x2)) 
    evalB La (+L x1 x2) = ((+ La) (evalB La x1) (evalB La x2)) 
    evalCl : {A : Set} -> ((Lattice A) -> ((ClLatticeTerm A) -> A))
    evalCl La (sing x1) = x1 
    evalCl La (*Cl x1 x2) = ((* La) (evalCl La x1) (evalCl La x2)) 
    evalCl La (+Cl x1 x2) = ((+ La) (evalCl La x1) (evalCl La x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Lattice A) -> ((Vec A n) -> ((OpLatticeTerm n) -> A)))
    evalOpB La vars (v x1) = (lookup _ x1 vars) 
    evalOpB La vars (*OL x1 x2) = ((* La) (evalOpB La vars x1) (evalOpB La vars x2)) 
    evalOpB La vars (+OL x1 x2) = ((+ La) (evalOpB La vars x1) (evalOpB La vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Lattice A) -> ((Vec A n) -> ((OpLatticeTerm2 n A) -> A)))
    evalOp La vars (v2 x1) = (lookup _ x1 vars) 
    evalOp La vars (sing2 x1) = x1 
    evalOp La vars (*OL2 x1 x2) = ((* La) (evalOp La vars x1) (evalOp La vars x2)) 
    evalOp La vars (+OL2 x1 x2) = ((+ La) (evalOp La vars x1) (evalOp La vars x2)) 
    inductionB : {P : (LatticeTerm -> Set)} -> (((x1 x2 : LatticeTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : LatticeTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : LatticeTerm) -> (P x))))
    inductionB {p} p*l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionB {p} p*l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClLatticeTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClLatticeTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClLatticeTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClLatticeTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p*cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLatticeTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpLatticeTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpLatticeTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpLatticeTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p*ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLatticeTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpLatticeTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpLatticeTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpLatticeTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    *L' : (LatticeTerm -> (LatticeTerm -> LatticeTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (LatticeTerm -> (LatticeTerm -> LatticeTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (LatticeTerm -> (Staged LatticeTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClLatticeTerm A) -> ((ClLatticeTerm A) -> (ClLatticeTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClLatticeTerm A) -> ((ClLatticeTerm A) -> (ClLatticeTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClLatticeTerm A) -> (Staged (ClLatticeTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpLatticeTerm n) -> ((OpLatticeTerm n) -> (OpLatticeTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpLatticeTerm n) -> ((OpLatticeTerm n) -> (OpLatticeTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLatticeTerm n) -> (Staged (OpLatticeTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpLatticeTerm2 n A) -> ((OpLatticeTerm2 n A) -> (OpLatticeTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpLatticeTerm2 n A) -> ((OpLatticeTerm2 n A) -> (OpLatticeTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLatticeTerm2 n A) -> (Staged (OpLatticeTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module Left0  where
    record Left0 (A : Set) : Set where
      constructor Left0C
      field
        0 : A
        op : (A -> (A -> A))
        leftZero_op_0 : {x : A} -> (op 0 x) == 0
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        0S : AS
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        0P : (Prod A A)
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftZero_op_0P : {xP : (Prod A A)} -> (opP 0P xP) == 0P
    record Hom {A1 : Set} {A2 : Set} (Le1 : (Left0 A1)) (Le2 : (Left0 A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-0 : (hom (0 Le1)) == (0 Le2)
        pres-op : {x1 x2 : A1} -> (hom ((op Le1) x1 x2)) == ((op Le2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Le1 : (Left0 A1)) (Le2 : (Left0 A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-0 : (interp (0 Le1) (0 Le2))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Le1) x1 x2) ((op Le2) y1 y2))))
    data Left0LTerm  : Set where
      0L : Left0LTerm
      opL : (Left0LTerm -> (Left0LTerm -> Left0LTerm))
    data ClLeft0ClTerm (A : Set) : Set where
      sing : (A -> (ClLeft0ClTerm A))
      0Cl : (ClLeft0ClTerm A)
      opCl : ((ClLeft0ClTerm A) -> ((ClLeft0ClTerm A) -> (ClLeft0ClTerm A)))
    data OpLeft0OLTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLeft0OLTerm n))
      0OL : (OpLeft0OLTerm n)
      opOL : ((OpLeft0OLTerm n) -> ((OpLeft0OLTerm n) -> (OpLeft0OLTerm n)))
    data OpLeft0OL2Term2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLeft0OL2Term2 n A))
      sing2 : (A -> (OpLeft0OL2Term2 n A))
      0OL2 : (OpLeft0OL2Term2 n A)
      opOL2 : ((OpLeft0OL2Term2 n A) -> ((OpLeft0OL2Term2 n A) -> (OpLeft0OL2Term2 n A)))
    simplifyCl : {A : Set} -> ((ClLeft0ClTerm A) -> (ClLeft0ClTerm A))
    simplifyCl 0Cl = 0Cl 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLeft0OLTerm n) -> (OpLeft0OLTerm n))
    simplifyOpB 0OL = 0OL 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLeft0OL2Term2 n A) -> (OpLeft0OL2Term2 n A))
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Left0 A) -> (Left0LTerm -> A))
    evalB Le 0L = (0 Le) 
    evalB Le (opL x1 x2) = ((op Le) (evalB Le x1) (evalB Le x2)) 
    evalCl : {A : Set} -> ((Left0 A) -> ((ClLeft0ClTerm A) -> A))
    evalCl Le (sing x1) = x1 
    evalCl Le 0Cl = (0 Le) 
    evalCl Le (opCl x1 x2) = ((op Le) (evalCl Le x1) (evalCl Le x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Left0 A) -> ((Vec A n) -> ((OpLeft0OLTerm n) -> A)))
    evalOpB Le vars (v x1) = (lookup _ x1 vars) 
    evalOpB Le vars 0OL = (0 Le) 
    evalOpB Le vars (opOL x1 x2) = ((op Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Left0 A) -> ((Vec A n) -> ((OpLeft0OL2Term2 n A) -> A)))
    evalOp Le vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Le vars (sing2 x1) = x1 
    evalOp Le vars 0OL2 = (0 Le) 
    evalOp Le vars (opOL2 x1 x2) = ((op Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    inductionB : {P : (Left0LTerm -> Set)} -> ((P 0L) -> (((x1 x2 : Left0LTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : Left0LTerm) -> (P x))))
    inductionB {p} p0l popl 0L = p0l 
    inductionB {p} p0l popl (opL x1 x2) = (popl _ _ (inductionB {p} p0l popl x1) (inductionB {p} p0l popl x2)) 
    inductionCl : {A : Set} {P : ((ClLeft0ClTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 0Cl) -> (((x1 x2 : (ClLeft0ClTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClLeft0ClTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p0cl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p0cl popcl 0Cl = p0cl 
    inductionCl {_} {p} psing p0cl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing p0cl popcl x1) (inductionCl {_} {p} psing p0cl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLeft0OLTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 0OL) -> (((x1 x2 : (OpLeft0OLTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpLeft0OLTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p0ol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p0ol popol 0OL = p0ol 
    inductionOpB {_} {p} pv p0ol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv p0ol popol x1) (inductionOpB {_} {p} pv p0ol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLeft0OL2Term2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 0OL2) -> (((x1 x2 : (OpLeft0OL2Term2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpLeft0OL2Term2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 popol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p0ol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p0ol2 popol2 x2)) 
    0L' : Left0LTerm
    0L'  = 0L 
    opL' : (Left0LTerm -> (Left0LTerm -> Left0LTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (Left0LTerm -> (Staged Left0LTerm))
    stageB 0L = (Now 0L) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    0Cl' : {A : Set} -> (ClLeft0ClTerm A)
    0Cl'  = 0Cl 
    opCl' : {A : Set} -> ((ClLeft0ClTerm A) -> ((ClLeft0ClTerm A) -> (ClLeft0ClTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClLeft0ClTerm A) -> (Staged (ClLeft0ClTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    0OL' : {n : Nat} -> (OpLeft0OLTerm n)
    0OL'  = 0OL 
    opOL' : {n : Nat} -> ((OpLeft0OLTerm n) -> ((OpLeft0OLTerm n) -> (OpLeft0OLTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLeft0OLTerm n) -> (Staged (OpLeft0OLTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    0OL2' : {n : Nat} {A : Set} -> (OpLeft0OL2Term2 n A)
    0OL2'  = 0OL2 
    opOL2' : {n : Nat} {A : Set} -> ((OpLeft0OL2Term2 n A) -> ((OpLeft0OL2Term2 n A) -> (OpLeft0OL2Term2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLeft0OL2Term2 n A) -> (Staged (OpLeft0OL2Term2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        0T : (Repr A)
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module LeftAbsorption  where
    record LeftAbsorption (A : Set) : Set where
      constructor LeftAbsorptionC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        leftAbsorp_*_+ : {x y : A} -> (* x (+ x y)) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftAbsorp_*_+P : {xP yP : (Prod A A)} -> (*P xP (+P xP yP)) == xP
    record Hom {A1 : Set} {A2 : Set} (Le1 : (LeftAbsorption A1)) (Le2 : (LeftAbsorption A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Le1) x1 x2)) == ((* Le2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Le1) x1 x2)) == ((+ Le2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Le1 : (LeftAbsorption A1)) (Le2 : (LeftAbsorption A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Le1) x1 x2) ((* Le2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Le1) x1 x2) ((+ Le2) y1 y2))))
    data LeftAbsorptionTerm  : Set where
      *L : (LeftAbsorptionTerm -> (LeftAbsorptionTerm -> LeftAbsorptionTerm))
      +L : (LeftAbsorptionTerm -> (LeftAbsorptionTerm -> LeftAbsorptionTerm))
    data ClLeftAbsorptionTerm (A : Set) : Set where
      sing : (A -> (ClLeftAbsorptionTerm A))
      *Cl : ((ClLeftAbsorptionTerm A) -> ((ClLeftAbsorptionTerm A) -> (ClLeftAbsorptionTerm A)))
      +Cl : ((ClLeftAbsorptionTerm A) -> ((ClLeftAbsorptionTerm A) -> (ClLeftAbsorptionTerm A)))
    data OpLeftAbsorptionTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLeftAbsorptionTerm n))
      *OL : ((OpLeftAbsorptionTerm n) -> ((OpLeftAbsorptionTerm n) -> (OpLeftAbsorptionTerm n)))
      +OL : ((OpLeftAbsorptionTerm n) -> ((OpLeftAbsorptionTerm n) -> (OpLeftAbsorptionTerm n)))
    data OpLeftAbsorptionTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLeftAbsorptionTerm2 n A))
      sing2 : (A -> (OpLeftAbsorptionTerm2 n A))
      *OL2 : ((OpLeftAbsorptionTerm2 n A) -> ((OpLeftAbsorptionTerm2 n A) -> (OpLeftAbsorptionTerm2 n A)))
      +OL2 : ((OpLeftAbsorptionTerm2 n A) -> ((OpLeftAbsorptionTerm2 n A) -> (OpLeftAbsorptionTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClLeftAbsorptionTerm A) -> (ClLeftAbsorptionTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLeftAbsorptionTerm n) -> (OpLeftAbsorptionTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLeftAbsorptionTerm2 n A) -> (OpLeftAbsorptionTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((LeftAbsorption A) -> (LeftAbsorptionTerm -> A))
    evalB Le (*L x1 x2) = ((* Le) (evalB Le x1) (evalB Le x2)) 
    evalB Le (+L x1 x2) = ((+ Le) (evalB Le x1) (evalB Le x2)) 
    evalCl : {A : Set} -> ((LeftAbsorption A) -> ((ClLeftAbsorptionTerm A) -> A))
    evalCl Le (sing x1) = x1 
    evalCl Le (*Cl x1 x2) = ((* Le) (evalCl Le x1) (evalCl Le x2)) 
    evalCl Le (+Cl x1 x2) = ((+ Le) (evalCl Le x1) (evalCl Le x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((LeftAbsorption A) -> ((Vec A n) -> ((OpLeftAbsorptionTerm n) -> A)))
    evalOpB Le vars (v x1) = (lookup _ x1 vars) 
    evalOpB Le vars (*OL x1 x2) = ((* Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOpB Le vars (+OL x1 x2) = ((+ Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((LeftAbsorption A) -> ((Vec A n) -> ((OpLeftAbsorptionTerm2 n A) -> A)))
    evalOp Le vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Le vars (sing2 x1) = x1 
    evalOp Le vars (*OL2 x1 x2) = ((* Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    evalOp Le vars (+OL2 x1 x2) = ((+ Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    inductionB : {P : (LeftAbsorptionTerm -> Set)} -> (((x1 x2 : LeftAbsorptionTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : LeftAbsorptionTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : LeftAbsorptionTerm) -> (P x))))
    inductionB {p} p*l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionB {p} p*l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClLeftAbsorptionTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClLeftAbsorptionTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClLeftAbsorptionTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClLeftAbsorptionTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p*cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLeftAbsorptionTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpLeftAbsorptionTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpLeftAbsorptionTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpLeftAbsorptionTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p*ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLeftAbsorptionTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpLeftAbsorptionTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpLeftAbsorptionTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpLeftAbsorptionTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    *L' : (LeftAbsorptionTerm -> (LeftAbsorptionTerm -> LeftAbsorptionTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (LeftAbsorptionTerm -> (LeftAbsorptionTerm -> LeftAbsorptionTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (LeftAbsorptionTerm -> (Staged LeftAbsorptionTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClLeftAbsorptionTerm A) -> ((ClLeftAbsorptionTerm A) -> (ClLeftAbsorptionTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClLeftAbsorptionTerm A) -> ((ClLeftAbsorptionTerm A) -> (ClLeftAbsorptionTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClLeftAbsorptionTerm A) -> (Staged (ClLeftAbsorptionTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpLeftAbsorptionTerm n) -> ((OpLeftAbsorptionTerm n) -> (OpLeftAbsorptionTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpLeftAbsorptionTerm n) -> ((OpLeftAbsorptionTerm n) -> (OpLeftAbsorptionTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLeftAbsorptionTerm n) -> (Staged (OpLeftAbsorptionTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpLeftAbsorptionTerm2 n A) -> ((OpLeftAbsorptionTerm2 n A) -> (OpLeftAbsorptionTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpLeftAbsorptionTerm2 n A) -> ((OpLeftAbsorptionTerm2 n A) -> (OpLeftAbsorptionTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLeftAbsorptionTerm2 n A) -> (Staged (OpLeftAbsorptionTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module LeftAbsorptionOp  where
    record LeftAbsorptionOp (A : Set) : Set where
      constructor LeftAbsorptionOpC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        leftAbsorp_+_* : {x y : A} -> (+ x (* x y)) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftAbsorp_+_*P : {xP yP : (Prod A A)} -> (+P xP (*P xP yP)) == xP
    record Hom {A1 : Set} {A2 : Set} (Le1 : (LeftAbsorptionOp A1)) (Le2 : (LeftAbsorptionOp A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Le1) x1 x2)) == ((* Le2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Le1) x1 x2)) == ((+ Le2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Le1 : (LeftAbsorptionOp A1)) (Le2 : (LeftAbsorptionOp A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Le1) x1 x2) ((* Le2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Le1) x1 x2) ((+ Le2) y1 y2))))
    data LeftAbsorptionOpTerm  : Set where
      *L : (LeftAbsorptionOpTerm -> (LeftAbsorptionOpTerm -> LeftAbsorptionOpTerm))
      +L : (LeftAbsorptionOpTerm -> (LeftAbsorptionOpTerm -> LeftAbsorptionOpTerm))
    data ClLeftAbsorptionOpTerm (A : Set) : Set where
      sing : (A -> (ClLeftAbsorptionOpTerm A))
      *Cl : ((ClLeftAbsorptionOpTerm A) -> ((ClLeftAbsorptionOpTerm A) -> (ClLeftAbsorptionOpTerm A)))
      +Cl : ((ClLeftAbsorptionOpTerm A) -> ((ClLeftAbsorptionOpTerm A) -> (ClLeftAbsorptionOpTerm A)))
    data OpLeftAbsorptionOpTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLeftAbsorptionOpTerm n))
      *OL : ((OpLeftAbsorptionOpTerm n) -> ((OpLeftAbsorptionOpTerm n) -> (OpLeftAbsorptionOpTerm n)))
      +OL : ((OpLeftAbsorptionOpTerm n) -> ((OpLeftAbsorptionOpTerm n) -> (OpLeftAbsorptionOpTerm n)))
    data OpLeftAbsorptionOpTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLeftAbsorptionOpTerm2 n A))
      sing2 : (A -> (OpLeftAbsorptionOpTerm2 n A))
      *OL2 : ((OpLeftAbsorptionOpTerm2 n A) -> ((OpLeftAbsorptionOpTerm2 n A) -> (OpLeftAbsorptionOpTerm2 n A)))
      +OL2 : ((OpLeftAbsorptionOpTerm2 n A) -> ((OpLeftAbsorptionOpTerm2 n A) -> (OpLeftAbsorptionOpTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClLeftAbsorptionOpTerm A) -> (ClLeftAbsorptionOpTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLeftAbsorptionOpTerm n) -> (OpLeftAbsorptionOpTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLeftAbsorptionOpTerm2 n A) -> (OpLeftAbsorptionOpTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((LeftAbsorptionOp A) -> (LeftAbsorptionOpTerm -> A))
    evalB Le (*L x1 x2) = ((* Le) (evalB Le x1) (evalB Le x2)) 
    evalB Le (+L x1 x2) = ((+ Le) (evalB Le x1) (evalB Le x2)) 
    evalCl : {A : Set} -> ((LeftAbsorptionOp A) -> ((ClLeftAbsorptionOpTerm A) -> A))
    evalCl Le (sing x1) = x1 
    evalCl Le (*Cl x1 x2) = ((* Le) (evalCl Le x1) (evalCl Le x2)) 
    evalCl Le (+Cl x1 x2) = ((+ Le) (evalCl Le x1) (evalCl Le x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((LeftAbsorptionOp A) -> ((Vec A n) -> ((OpLeftAbsorptionOpTerm n) -> A)))
    evalOpB Le vars (v x1) = (lookup _ x1 vars) 
    evalOpB Le vars (*OL x1 x2) = ((* Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOpB Le vars (+OL x1 x2) = ((+ Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((LeftAbsorptionOp A) -> ((Vec A n) -> ((OpLeftAbsorptionOpTerm2 n A) -> A)))
    evalOp Le vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Le vars (sing2 x1) = x1 
    evalOp Le vars (*OL2 x1 x2) = ((* Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    evalOp Le vars (+OL2 x1 x2) = ((+ Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    inductionB : {P : (LeftAbsorptionOpTerm -> Set)} -> (((x1 x2 : LeftAbsorptionOpTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : LeftAbsorptionOpTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : LeftAbsorptionOpTerm) -> (P x))))
    inductionB {p} p*l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionB {p} p*l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClLeftAbsorptionOpTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClLeftAbsorptionOpTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClLeftAbsorptionOpTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClLeftAbsorptionOpTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p*cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLeftAbsorptionOpTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpLeftAbsorptionOpTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpLeftAbsorptionOpTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpLeftAbsorptionOpTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p*ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLeftAbsorptionOpTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpLeftAbsorptionOpTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpLeftAbsorptionOpTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpLeftAbsorptionOpTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    *L' : (LeftAbsorptionOpTerm -> (LeftAbsorptionOpTerm -> LeftAbsorptionOpTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (LeftAbsorptionOpTerm -> (LeftAbsorptionOpTerm -> LeftAbsorptionOpTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (LeftAbsorptionOpTerm -> (Staged LeftAbsorptionOpTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClLeftAbsorptionOpTerm A) -> ((ClLeftAbsorptionOpTerm A) -> (ClLeftAbsorptionOpTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClLeftAbsorptionOpTerm A) -> ((ClLeftAbsorptionOpTerm A) -> (ClLeftAbsorptionOpTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClLeftAbsorptionOpTerm A) -> (Staged (ClLeftAbsorptionOpTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpLeftAbsorptionOpTerm n) -> ((OpLeftAbsorptionOpTerm n) -> (OpLeftAbsorptionOpTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpLeftAbsorptionOpTerm n) -> ((OpLeftAbsorptionOpTerm n) -> (OpLeftAbsorptionOpTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLeftAbsorptionOpTerm n) -> (Staged (OpLeftAbsorptionOpTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpLeftAbsorptionOpTerm2 n A) -> ((OpLeftAbsorptionOpTerm2 n A) -> (OpLeftAbsorptionOpTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpLeftAbsorptionOpTerm2 n A) -> ((OpLeftAbsorptionOpTerm2 n A) -> (OpLeftAbsorptionOpTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLeftAbsorptionOpTerm2 n A) -> (Staged (OpLeftAbsorptionOpTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module LeftBiMagma  where
    record LeftBiMagma (A : Set) : Set where
      constructor LeftBiMagmaC
      field
        op : (A -> (A -> A))
        linv : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        linvS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        linvP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
    record Hom {A1 : Set} {A2 : Set} (Le1 : (LeftBiMagma A1)) (Le2 : (LeftBiMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Le1) x1 x2)) == ((op Le2) (hom x1) (hom x2))
        pres-linv : {x1 x2 : A1} -> (hom ((linv Le1) x1 x2)) == ((linv Le2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Le1 : (LeftBiMagma A1)) (Le2 : (LeftBiMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Le1) x1 x2) ((op Le2) y1 y2))))
        interp-linv : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((linv Le1) x1 x2) ((linv Le2) y1 y2))))
    data LeftBiMagmaTerm  : Set where
      opL : (LeftBiMagmaTerm -> (LeftBiMagmaTerm -> LeftBiMagmaTerm))
      linvL : (LeftBiMagmaTerm -> (LeftBiMagmaTerm -> LeftBiMagmaTerm))
    data ClLeftBiMagmaTerm (A : Set) : Set where
      sing : (A -> (ClLeftBiMagmaTerm A))
      opCl : ((ClLeftBiMagmaTerm A) -> ((ClLeftBiMagmaTerm A) -> (ClLeftBiMagmaTerm A)))
      linvCl : ((ClLeftBiMagmaTerm A) -> ((ClLeftBiMagmaTerm A) -> (ClLeftBiMagmaTerm A)))
    data OpLeftBiMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLeftBiMagmaTerm n))
      opOL : ((OpLeftBiMagmaTerm n) -> ((OpLeftBiMagmaTerm n) -> (OpLeftBiMagmaTerm n)))
      linvOL : ((OpLeftBiMagmaTerm n) -> ((OpLeftBiMagmaTerm n) -> (OpLeftBiMagmaTerm n)))
    data OpLeftBiMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLeftBiMagmaTerm2 n A))
      sing2 : (A -> (OpLeftBiMagmaTerm2 n A))
      opOL2 : ((OpLeftBiMagmaTerm2 n A) -> ((OpLeftBiMagmaTerm2 n A) -> (OpLeftBiMagmaTerm2 n A)))
      linvOL2 : ((OpLeftBiMagmaTerm2 n A) -> ((OpLeftBiMagmaTerm2 n A) -> (OpLeftBiMagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClLeftBiMagmaTerm A) -> (ClLeftBiMagmaTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (linvCl x1 x2) = (linvCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLeftBiMagmaTerm n) -> (OpLeftBiMagmaTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (linvOL x1 x2) = (linvOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLeftBiMagmaTerm2 n A) -> (OpLeftBiMagmaTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (linvOL2 x1 x2) = (linvOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((LeftBiMagma A) -> (LeftBiMagmaTerm -> A))
    evalB Le (opL x1 x2) = ((op Le) (evalB Le x1) (evalB Le x2)) 
    evalB Le (linvL x1 x2) = ((linv Le) (evalB Le x1) (evalB Le x2)) 
    evalCl : {A : Set} -> ((LeftBiMagma A) -> ((ClLeftBiMagmaTerm A) -> A))
    evalCl Le (sing x1) = x1 
    evalCl Le (opCl x1 x2) = ((op Le) (evalCl Le x1) (evalCl Le x2)) 
    evalCl Le (linvCl x1 x2) = ((linv Le) (evalCl Le x1) (evalCl Le x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((LeftBiMagma A) -> ((Vec A n) -> ((OpLeftBiMagmaTerm n) -> A)))
    evalOpB Le vars (v x1) = (lookup _ x1 vars) 
    evalOpB Le vars (opOL x1 x2) = ((op Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOpB Le vars (linvOL x1 x2) = ((linv Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((LeftBiMagma A) -> ((Vec A n) -> ((OpLeftBiMagmaTerm2 n A) -> A)))
    evalOp Le vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Le vars (sing2 x1) = x1 
    evalOp Le vars (opOL2 x1 x2) = ((op Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    evalOp Le vars (linvOL2 x1 x2) = ((linv Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    inductionB : {P : (LeftBiMagmaTerm -> Set)} -> (((x1 x2 : LeftBiMagmaTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> (((x1 x2 : LeftBiMagmaTerm) -> ((P x1) -> ((P x2) -> (P (linvL x1 x2))))) -> ((x : LeftBiMagmaTerm) -> (P x))))
    inductionB {p} popl plinvl (opL x1 x2) = (popl _ _ (inductionB {p} popl plinvl x1) (inductionB {p} popl plinvl x2)) 
    inductionB {p} popl plinvl (linvL x1 x2) = (plinvl _ _ (inductionB {p} popl plinvl x1) (inductionB {p} popl plinvl x2)) 
    inductionCl : {A : Set} {P : ((ClLeftBiMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClLeftBiMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> (((x1 x2 : (ClLeftBiMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (linvCl x1 x2))))) -> ((x : (ClLeftBiMagmaTerm A)) -> (P x)))))
    inductionCl {_} {p} psing popcl plinvcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl plinvcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl plinvcl x1) (inductionCl {_} {p} psing popcl plinvcl x2)) 
    inductionCl {_} {p} psing popcl plinvcl (linvCl x1 x2) = (plinvcl _ _ (inductionCl {_} {p} psing popcl plinvcl x1) (inductionCl {_} {p} psing popcl plinvcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLeftBiMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpLeftBiMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> (((x1 x2 : (OpLeftBiMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (linvOL x1 x2))))) -> ((x : (OpLeftBiMagmaTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv popol plinvol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol plinvol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol plinvol x1) (inductionOpB {_} {p} pv popol plinvol x2)) 
    inductionOpB {_} {p} pv popol plinvol (linvOL x1 x2) = (plinvol _ _ (inductionOpB {_} {p} pv popol plinvol x1) (inductionOpB {_} {p} pv popol plinvol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLeftBiMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpLeftBiMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> (((x1 x2 : (OpLeftBiMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (linvOL2 x1 x2))))) -> ((x : (OpLeftBiMagmaTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 (linvOL2 x1 x2) = (plinvol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 x2)) 
    opL' : (LeftBiMagmaTerm -> (LeftBiMagmaTerm -> LeftBiMagmaTerm))
    opL' x1 x2 = (opL x1 x2) 
    linvL' : (LeftBiMagmaTerm -> (LeftBiMagmaTerm -> LeftBiMagmaTerm))
    linvL' x1 x2 = (linvL x1 x2) 
    stageB : (LeftBiMagmaTerm -> (Staged LeftBiMagmaTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB (linvL x1 x2) = (stage2 linvL' (codeLift2 linvL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClLeftBiMagmaTerm A) -> ((ClLeftBiMagmaTerm A) -> (ClLeftBiMagmaTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    linvCl' : {A : Set} -> ((ClLeftBiMagmaTerm A) -> ((ClLeftBiMagmaTerm A) -> (ClLeftBiMagmaTerm A)))
    linvCl' x1 x2 = (linvCl x1 x2) 
    stageCl : {A : Set} -> ((ClLeftBiMagmaTerm A) -> (Staged (ClLeftBiMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl (linvCl x1 x2) = (stage2 linvCl' (codeLift2 linvCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpLeftBiMagmaTerm n) -> ((OpLeftBiMagmaTerm n) -> (OpLeftBiMagmaTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    linvOL' : {n : Nat} -> ((OpLeftBiMagmaTerm n) -> ((OpLeftBiMagmaTerm n) -> (OpLeftBiMagmaTerm n)))
    linvOL' x1 x2 = (linvOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLeftBiMagmaTerm n) -> (Staged (OpLeftBiMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (linvOL x1 x2) = (stage2 linvOL' (codeLift2 linvOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpLeftBiMagmaTerm2 n A) -> ((OpLeftBiMagmaTerm2 n A) -> (OpLeftBiMagmaTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    linvOL2' : {n : Nat} {A : Set} -> ((OpLeftBiMagmaTerm2 n A) -> ((OpLeftBiMagmaTerm2 n A) -> (OpLeftBiMagmaTerm2 n A)))
    linvOL2' x1 x2 = (linvOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLeftBiMagmaTerm2 n A) -> (Staged (OpLeftBiMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp (linvOL2 x1 x2) = (stage2 linvOL2' (codeLift2 linvOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        linvT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module LeftBinaryInverse  where
    record LeftBinaryInverse (A : Set) : Set where
      constructor LeftBinaryInverseC
      field
        |> : (A -> (A -> A))
        <| : (A -> (A -> A))
        leftInverse : {x y : A} -> (<| (|> x y) x) == y
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        |>S : (AS -> (AS -> AS))
        <|S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        |>P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        <|P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftInverseP : {xP yP : (Prod A A)} -> (<|P (|>P xP yP) xP) == yP
    record Hom {A1 : Set} {A2 : Set} (Le1 : (LeftBinaryInverse A1)) (Le2 : (LeftBinaryInverse A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-|> : {x1 x2 : A1} -> (hom ((|> Le1) x1 x2)) == ((|> Le2) (hom x1) (hom x2))
        pres-<| : {x1 x2 : A1} -> (hom ((<| Le1) x1 x2)) == ((<| Le2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Le1 : (LeftBinaryInverse A1)) (Le2 : (LeftBinaryInverse A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-|> : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((|> Le1) x1 x2) ((|> Le2) y1 y2))))
        interp-<| : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((<| Le1) x1 x2) ((<| Le2) y1 y2))))
    data LeftBinaryInverseTerm  : Set where
      |>L : (LeftBinaryInverseTerm -> (LeftBinaryInverseTerm -> LeftBinaryInverseTerm))
      <|L : (LeftBinaryInverseTerm -> (LeftBinaryInverseTerm -> LeftBinaryInverseTerm))
    data ClLeftBinaryInverseTerm (A : Set) : Set where
      sing : (A -> (ClLeftBinaryInverseTerm A))
      |>Cl : ((ClLeftBinaryInverseTerm A) -> ((ClLeftBinaryInverseTerm A) -> (ClLeftBinaryInverseTerm A)))
      <|Cl : ((ClLeftBinaryInverseTerm A) -> ((ClLeftBinaryInverseTerm A) -> (ClLeftBinaryInverseTerm A)))
    data OpLeftBinaryInverseTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLeftBinaryInverseTerm n))
      |>OL : ((OpLeftBinaryInverseTerm n) -> ((OpLeftBinaryInverseTerm n) -> (OpLeftBinaryInverseTerm n)))
      <|OL : ((OpLeftBinaryInverseTerm n) -> ((OpLeftBinaryInverseTerm n) -> (OpLeftBinaryInverseTerm n)))
    data OpLeftBinaryInverseTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLeftBinaryInverseTerm2 n A))
      sing2 : (A -> (OpLeftBinaryInverseTerm2 n A))
      |>OL2 : ((OpLeftBinaryInverseTerm2 n A) -> ((OpLeftBinaryInverseTerm2 n A) -> (OpLeftBinaryInverseTerm2 n A)))
      <|OL2 : ((OpLeftBinaryInverseTerm2 n A) -> ((OpLeftBinaryInverseTerm2 n A) -> (OpLeftBinaryInverseTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClLeftBinaryInverseTerm A) -> (ClLeftBinaryInverseTerm A))
    simplifyCl (|>Cl x1 x2) = (|>Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (<|Cl x1 x2) = (<|Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLeftBinaryInverseTerm n) -> (OpLeftBinaryInverseTerm n))
    simplifyOpB (|>OL x1 x2) = (|>OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (<|OL x1 x2) = (<|OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLeftBinaryInverseTerm2 n A) -> (OpLeftBinaryInverseTerm2 n A))
    simplifyOp (|>OL2 x1 x2) = (|>OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (<|OL2 x1 x2) = (<|OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((LeftBinaryInverse A) -> (LeftBinaryInverseTerm -> A))
    evalB Le (|>L x1 x2) = ((|> Le) (evalB Le x1) (evalB Le x2)) 
    evalB Le (<|L x1 x2) = ((<| Le) (evalB Le x1) (evalB Le x2)) 
    evalCl : {A : Set} -> ((LeftBinaryInverse A) -> ((ClLeftBinaryInverseTerm A) -> A))
    evalCl Le (sing x1) = x1 
    evalCl Le (|>Cl x1 x2) = ((|> Le) (evalCl Le x1) (evalCl Le x2)) 
    evalCl Le (<|Cl x1 x2) = ((<| Le) (evalCl Le x1) (evalCl Le x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((LeftBinaryInverse A) -> ((Vec A n) -> ((OpLeftBinaryInverseTerm n) -> A)))
    evalOpB Le vars (v x1) = (lookup _ x1 vars) 
    evalOpB Le vars (|>OL x1 x2) = ((|> Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOpB Le vars (<|OL x1 x2) = ((<| Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((LeftBinaryInverse A) -> ((Vec A n) -> ((OpLeftBinaryInverseTerm2 n A) -> A)))
    evalOp Le vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Le vars (sing2 x1) = x1 
    evalOp Le vars (|>OL2 x1 x2) = ((|> Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    evalOp Le vars (<|OL2 x1 x2) = ((<| Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    inductionB : {P : (LeftBinaryInverseTerm -> Set)} -> (((x1 x2 : LeftBinaryInverseTerm) -> ((P x1) -> ((P x2) -> (P (|>L x1 x2))))) -> (((x1 x2 : LeftBinaryInverseTerm) -> ((P x1) -> ((P x2) -> (P (<|L x1 x2))))) -> ((x : LeftBinaryInverseTerm) -> (P x))))
    inductionB {p} p|>l p<|l (|>L x1 x2) = (p|>l _ _ (inductionB {p} p|>l p<|l x1) (inductionB {p} p|>l p<|l x2)) 
    inductionB {p} p|>l p<|l (<|L x1 x2) = (p<|l _ _ (inductionB {p} p|>l p<|l x1) (inductionB {p} p|>l p<|l x2)) 
    inductionCl : {A : Set} {P : ((ClLeftBinaryInverseTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClLeftBinaryInverseTerm A)) -> ((P x1) -> ((P x2) -> (P (|>Cl x1 x2))))) -> (((x1 x2 : (ClLeftBinaryInverseTerm A)) -> ((P x1) -> ((P x2) -> (P (<|Cl x1 x2))))) -> ((x : (ClLeftBinaryInverseTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p|>cl p<|cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p|>cl p<|cl (|>Cl x1 x2) = (p|>cl _ _ (inductionCl {_} {p} psing p|>cl p<|cl x1) (inductionCl {_} {p} psing p|>cl p<|cl x2)) 
    inductionCl {_} {p} psing p|>cl p<|cl (<|Cl x1 x2) = (p<|cl _ _ (inductionCl {_} {p} psing p|>cl p<|cl x1) (inductionCl {_} {p} psing p|>cl p<|cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLeftBinaryInverseTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpLeftBinaryInverseTerm n)) -> ((P x1) -> ((P x2) -> (P (|>OL x1 x2))))) -> (((x1 x2 : (OpLeftBinaryInverseTerm n)) -> ((P x1) -> ((P x2) -> (P (<|OL x1 x2))))) -> ((x : (OpLeftBinaryInverseTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p|>ol p<|ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p|>ol p<|ol (|>OL x1 x2) = (p|>ol _ _ (inductionOpB {_} {p} pv p|>ol p<|ol x1) (inductionOpB {_} {p} pv p|>ol p<|ol x2)) 
    inductionOpB {_} {p} pv p|>ol p<|ol (<|OL x1 x2) = (p<|ol _ _ (inductionOpB {_} {p} pv p|>ol p<|ol x1) (inductionOpB {_} {p} pv p|>ol p<|ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLeftBinaryInverseTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpLeftBinaryInverseTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (|>OL2 x1 x2))))) -> (((x1 x2 : (OpLeftBinaryInverseTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (<|OL2 x1 x2))))) -> ((x : (OpLeftBinaryInverseTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (|>OL2 x1 x2) = (p|>ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (<|OL2 x1 x2) = (p<|ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x2)) 
    |>L' : (LeftBinaryInverseTerm -> (LeftBinaryInverseTerm -> LeftBinaryInverseTerm))
    |>L' x1 x2 = (|>L x1 x2) 
    <|L' : (LeftBinaryInverseTerm -> (LeftBinaryInverseTerm -> LeftBinaryInverseTerm))
    <|L' x1 x2 = (<|L x1 x2) 
    stageB : (LeftBinaryInverseTerm -> (Staged LeftBinaryInverseTerm))
    stageB (|>L x1 x2) = (stage2 |>L' (codeLift2 |>L') (stageB x1) (stageB x2)) 
    stageB (<|L x1 x2) = (stage2 <|L' (codeLift2 <|L') (stageB x1) (stageB x2)) 
    |>Cl' : {A : Set} -> ((ClLeftBinaryInverseTerm A) -> ((ClLeftBinaryInverseTerm A) -> (ClLeftBinaryInverseTerm A)))
    |>Cl' x1 x2 = (|>Cl x1 x2) 
    <|Cl' : {A : Set} -> ((ClLeftBinaryInverseTerm A) -> ((ClLeftBinaryInverseTerm A) -> (ClLeftBinaryInverseTerm A)))
    <|Cl' x1 x2 = (<|Cl x1 x2) 
    stageCl : {A : Set} -> ((ClLeftBinaryInverseTerm A) -> (Staged (ClLeftBinaryInverseTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (|>Cl x1 x2) = (stage2 |>Cl' (codeLift2 |>Cl') (stageCl x1) (stageCl x2)) 
    stageCl (<|Cl x1 x2) = (stage2 <|Cl' (codeLift2 <|Cl') (stageCl x1) (stageCl x2)) 
    |>OL' : {n : Nat} -> ((OpLeftBinaryInverseTerm n) -> ((OpLeftBinaryInverseTerm n) -> (OpLeftBinaryInverseTerm n)))
    |>OL' x1 x2 = (|>OL x1 x2) 
    <|OL' : {n : Nat} -> ((OpLeftBinaryInverseTerm n) -> ((OpLeftBinaryInverseTerm n) -> (OpLeftBinaryInverseTerm n)))
    <|OL' x1 x2 = (<|OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLeftBinaryInverseTerm n) -> (Staged (OpLeftBinaryInverseTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (|>OL x1 x2) = (stage2 |>OL' (codeLift2 |>OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (<|OL x1 x2) = (stage2 <|OL' (codeLift2 <|OL') (stageOpB x1) (stageOpB x2)) 
    |>OL2' : {n : Nat} {A : Set} -> ((OpLeftBinaryInverseTerm2 n A) -> ((OpLeftBinaryInverseTerm2 n A) -> (OpLeftBinaryInverseTerm2 n A)))
    |>OL2' x1 x2 = (|>OL2 x1 x2) 
    <|OL2' : {n : Nat} {A : Set} -> ((OpLeftBinaryInverseTerm2 n A) -> ((OpLeftBinaryInverseTerm2 n A) -> (OpLeftBinaryInverseTerm2 n A)))
    <|OL2' x1 x2 = (<|OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLeftBinaryInverseTerm2 n A) -> (Staged (OpLeftBinaryInverseTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (|>OL2 x1 x2) = (stage2 |>OL2' (codeLift2 |>OL2') (stageOp x1) (stageOp x2)) 
    stageOp (<|OL2 x1 x2) = (stage2 <|OL2' (codeLift2 <|OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        |>T : ((Repr A) -> ((Repr A) -> (Repr A)))
        <|T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module LeftCancellative  where
    record LeftCancellative (A : Set) : Set where
      constructor LeftCancellativeC
      field
        op : (A -> (A -> A))
        linv : (A -> (A -> A))
        leftCancel : {x y : A} -> (op x (linv x y)) == y
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        linvS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        linvP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftCancelP : {xP yP : (Prod A A)} -> (opP xP (linvP xP yP)) == yP
    record Hom {A1 : Set} {A2 : Set} (Le1 : (LeftCancellative A1)) (Le2 : (LeftCancellative A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Le1) x1 x2)) == ((op Le2) (hom x1) (hom x2))
        pres-linv : {x1 x2 : A1} -> (hom ((linv Le1) x1 x2)) == ((linv Le2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Le1 : (LeftCancellative A1)) (Le2 : (LeftCancellative A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Le1) x1 x2) ((op Le2) y1 y2))))
        interp-linv : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((linv Le1) x1 x2) ((linv Le2) y1 y2))))
    data LeftCancellativeTerm  : Set where
      opL : (LeftCancellativeTerm -> (LeftCancellativeTerm -> LeftCancellativeTerm))
      linvL : (LeftCancellativeTerm -> (LeftCancellativeTerm -> LeftCancellativeTerm))
    data ClLeftCancellativeTerm (A : Set) : Set where
      sing : (A -> (ClLeftCancellativeTerm A))
      opCl : ((ClLeftCancellativeTerm A) -> ((ClLeftCancellativeTerm A) -> (ClLeftCancellativeTerm A)))
      linvCl : ((ClLeftCancellativeTerm A) -> ((ClLeftCancellativeTerm A) -> (ClLeftCancellativeTerm A)))
    data OpLeftCancellativeTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLeftCancellativeTerm n))
      opOL : ((OpLeftCancellativeTerm n) -> ((OpLeftCancellativeTerm n) -> (OpLeftCancellativeTerm n)))
      linvOL : ((OpLeftCancellativeTerm n) -> ((OpLeftCancellativeTerm n) -> (OpLeftCancellativeTerm n)))
    data OpLeftCancellativeTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLeftCancellativeTerm2 n A))
      sing2 : (A -> (OpLeftCancellativeTerm2 n A))
      opOL2 : ((OpLeftCancellativeTerm2 n A) -> ((OpLeftCancellativeTerm2 n A) -> (OpLeftCancellativeTerm2 n A)))
      linvOL2 : ((OpLeftCancellativeTerm2 n A) -> ((OpLeftCancellativeTerm2 n A) -> (OpLeftCancellativeTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClLeftCancellativeTerm A) -> (ClLeftCancellativeTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (linvCl x1 x2) = (linvCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLeftCancellativeTerm n) -> (OpLeftCancellativeTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (linvOL x1 x2) = (linvOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLeftCancellativeTerm2 n A) -> (OpLeftCancellativeTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (linvOL2 x1 x2) = (linvOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((LeftCancellative A) -> (LeftCancellativeTerm -> A))
    evalB Le (opL x1 x2) = ((op Le) (evalB Le x1) (evalB Le x2)) 
    evalB Le (linvL x1 x2) = ((linv Le) (evalB Le x1) (evalB Le x2)) 
    evalCl : {A : Set} -> ((LeftCancellative A) -> ((ClLeftCancellativeTerm A) -> A))
    evalCl Le (sing x1) = x1 
    evalCl Le (opCl x1 x2) = ((op Le) (evalCl Le x1) (evalCl Le x2)) 
    evalCl Le (linvCl x1 x2) = ((linv Le) (evalCl Le x1) (evalCl Le x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((LeftCancellative A) -> ((Vec A n) -> ((OpLeftCancellativeTerm n) -> A)))
    evalOpB Le vars (v x1) = (lookup _ x1 vars) 
    evalOpB Le vars (opOL x1 x2) = ((op Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOpB Le vars (linvOL x1 x2) = ((linv Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((LeftCancellative A) -> ((Vec A n) -> ((OpLeftCancellativeTerm2 n A) -> A)))
    evalOp Le vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Le vars (sing2 x1) = x1 
    evalOp Le vars (opOL2 x1 x2) = ((op Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    evalOp Le vars (linvOL2 x1 x2) = ((linv Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    inductionB : {P : (LeftCancellativeTerm -> Set)} -> (((x1 x2 : LeftCancellativeTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> (((x1 x2 : LeftCancellativeTerm) -> ((P x1) -> ((P x2) -> (P (linvL x1 x2))))) -> ((x : LeftCancellativeTerm) -> (P x))))
    inductionB {p} popl plinvl (opL x1 x2) = (popl _ _ (inductionB {p} popl plinvl x1) (inductionB {p} popl plinvl x2)) 
    inductionB {p} popl plinvl (linvL x1 x2) = (plinvl _ _ (inductionB {p} popl plinvl x1) (inductionB {p} popl plinvl x2)) 
    inductionCl : {A : Set} {P : ((ClLeftCancellativeTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClLeftCancellativeTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> (((x1 x2 : (ClLeftCancellativeTerm A)) -> ((P x1) -> ((P x2) -> (P (linvCl x1 x2))))) -> ((x : (ClLeftCancellativeTerm A)) -> (P x)))))
    inductionCl {_} {p} psing popcl plinvcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl plinvcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl plinvcl x1) (inductionCl {_} {p} psing popcl plinvcl x2)) 
    inductionCl {_} {p} psing popcl plinvcl (linvCl x1 x2) = (plinvcl _ _ (inductionCl {_} {p} psing popcl plinvcl x1) (inductionCl {_} {p} psing popcl plinvcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLeftCancellativeTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpLeftCancellativeTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> (((x1 x2 : (OpLeftCancellativeTerm n)) -> ((P x1) -> ((P x2) -> (P (linvOL x1 x2))))) -> ((x : (OpLeftCancellativeTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv popol plinvol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol plinvol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol plinvol x1) (inductionOpB {_} {p} pv popol plinvol x2)) 
    inductionOpB {_} {p} pv popol plinvol (linvOL x1 x2) = (plinvol _ _ (inductionOpB {_} {p} pv popol plinvol x1) (inductionOpB {_} {p} pv popol plinvol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLeftCancellativeTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpLeftCancellativeTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> (((x1 x2 : (OpLeftCancellativeTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (linvOL2 x1 x2))))) -> ((x : (OpLeftCancellativeTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 (linvOL2 x1 x2) = (plinvol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 x2)) 
    opL' : (LeftCancellativeTerm -> (LeftCancellativeTerm -> LeftCancellativeTerm))
    opL' x1 x2 = (opL x1 x2) 
    linvL' : (LeftCancellativeTerm -> (LeftCancellativeTerm -> LeftCancellativeTerm))
    linvL' x1 x2 = (linvL x1 x2) 
    stageB : (LeftCancellativeTerm -> (Staged LeftCancellativeTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB (linvL x1 x2) = (stage2 linvL' (codeLift2 linvL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClLeftCancellativeTerm A) -> ((ClLeftCancellativeTerm A) -> (ClLeftCancellativeTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    linvCl' : {A : Set} -> ((ClLeftCancellativeTerm A) -> ((ClLeftCancellativeTerm A) -> (ClLeftCancellativeTerm A)))
    linvCl' x1 x2 = (linvCl x1 x2) 
    stageCl : {A : Set} -> ((ClLeftCancellativeTerm A) -> (Staged (ClLeftCancellativeTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl (linvCl x1 x2) = (stage2 linvCl' (codeLift2 linvCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpLeftCancellativeTerm n) -> ((OpLeftCancellativeTerm n) -> (OpLeftCancellativeTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    linvOL' : {n : Nat} -> ((OpLeftCancellativeTerm n) -> ((OpLeftCancellativeTerm n) -> (OpLeftCancellativeTerm n)))
    linvOL' x1 x2 = (linvOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLeftCancellativeTerm n) -> (Staged (OpLeftCancellativeTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (linvOL x1 x2) = (stage2 linvOL' (codeLift2 linvOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpLeftCancellativeTerm2 n A) -> ((OpLeftCancellativeTerm2 n A) -> (OpLeftCancellativeTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    linvOL2' : {n : Nat} {A : Set} -> ((OpLeftCancellativeTerm2 n A) -> ((OpLeftCancellativeTerm2 n A) -> (OpLeftCancellativeTerm2 n A)))
    linvOL2' x1 x2 = (linvOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLeftCancellativeTerm2 n A) -> (Staged (OpLeftCancellativeTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp (linvOL2 x1 x2) = (stage2 linvOL2' (codeLift2 linvOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        linvT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module LeftCancellativeMagma  where
    record LeftCancellativeMagma (A : Set) : Set where
      constructor LeftCancellativeMagmaC
      field
        op : (A -> (A -> A))
        leftCancellative : {x y z : A} -> ((op z x) == (op z y) -> x == y)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftCancellativeP : {xP yP zP : (Prod A A)} -> ((opP zP xP) == (opP zP yP) -> xP == yP)
    record Hom {A1 : Set} {A2 : Set} (Le1 : (LeftCancellativeMagma A1)) (Le2 : (LeftCancellativeMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Le1) x1 x2)) == ((op Le2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Le1 : (LeftCancellativeMagma A1)) (Le2 : (LeftCancellativeMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Le1) x1 x2) ((op Le2) y1 y2))))
    data LeftCancellativeMagmaTerm  : Set where
      opL : (LeftCancellativeMagmaTerm -> (LeftCancellativeMagmaTerm -> LeftCancellativeMagmaTerm))
    data ClLeftCancellativeMagmaTerm (A : Set) : Set where
      sing : (A -> (ClLeftCancellativeMagmaTerm A))
      opCl : ((ClLeftCancellativeMagmaTerm A) -> ((ClLeftCancellativeMagmaTerm A) -> (ClLeftCancellativeMagmaTerm A)))
    data OpLeftCancellativeMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLeftCancellativeMagmaTerm n))
      opOL : ((OpLeftCancellativeMagmaTerm n) -> ((OpLeftCancellativeMagmaTerm n) -> (OpLeftCancellativeMagmaTerm n)))
    data OpLeftCancellativeMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLeftCancellativeMagmaTerm2 n A))
      sing2 : (A -> (OpLeftCancellativeMagmaTerm2 n A))
      opOL2 : ((OpLeftCancellativeMagmaTerm2 n A) -> ((OpLeftCancellativeMagmaTerm2 n A) -> (OpLeftCancellativeMagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClLeftCancellativeMagmaTerm A) -> (ClLeftCancellativeMagmaTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLeftCancellativeMagmaTerm n) -> (OpLeftCancellativeMagmaTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLeftCancellativeMagmaTerm2 n A) -> (OpLeftCancellativeMagmaTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((LeftCancellativeMagma A) -> (LeftCancellativeMagmaTerm -> A))
    evalB Le (opL x1 x2) = ((op Le) (evalB Le x1) (evalB Le x2)) 
    evalCl : {A : Set} -> ((LeftCancellativeMagma A) -> ((ClLeftCancellativeMagmaTerm A) -> A))
    evalCl Le (sing x1) = x1 
    evalCl Le (opCl x1 x2) = ((op Le) (evalCl Le x1) (evalCl Le x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((LeftCancellativeMagma A) -> ((Vec A n) -> ((OpLeftCancellativeMagmaTerm n) -> A)))
    evalOpB Le vars (v x1) = (lookup _ x1 vars) 
    evalOpB Le vars (opOL x1 x2) = ((op Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((LeftCancellativeMagma A) -> ((Vec A n) -> ((OpLeftCancellativeMagmaTerm2 n A) -> A)))
    evalOp Le vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Le vars (sing2 x1) = x1 
    evalOp Le vars (opOL2 x1 x2) = ((op Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    inductionB : {P : (LeftCancellativeMagmaTerm -> Set)} -> (((x1 x2 : LeftCancellativeMagmaTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : LeftCancellativeMagmaTerm) -> (P x)))
    inductionB {p} popl (opL x1 x2) = (popl _ _ (inductionB {p} popl x1) (inductionB {p} popl x2)) 
    inductionCl : {A : Set} {P : ((ClLeftCancellativeMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClLeftCancellativeMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClLeftCancellativeMagmaTerm A)) -> (P x))))
    inductionCl {_} {p} psing popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl x1) (inductionCl {_} {p} psing popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLeftCancellativeMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpLeftCancellativeMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpLeftCancellativeMagmaTerm n)) -> (P x))))
    inductionOpB {_} {p} pv popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol x1) (inductionOpB {_} {p} pv popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLeftCancellativeMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpLeftCancellativeMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpLeftCancellativeMagmaTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 x2)) 
    opL' : (LeftCancellativeMagmaTerm -> (LeftCancellativeMagmaTerm -> LeftCancellativeMagmaTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (LeftCancellativeMagmaTerm -> (Staged LeftCancellativeMagmaTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClLeftCancellativeMagmaTerm A) -> ((ClLeftCancellativeMagmaTerm A) -> (ClLeftCancellativeMagmaTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClLeftCancellativeMagmaTerm A) -> (Staged (ClLeftCancellativeMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpLeftCancellativeMagmaTerm n) -> ((OpLeftCancellativeMagmaTerm n) -> (OpLeftCancellativeMagmaTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLeftCancellativeMagmaTerm n) -> (Staged (OpLeftCancellativeMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpLeftCancellativeMagmaTerm2 n A) -> ((OpLeftCancellativeMagmaTerm2 n A) -> (OpLeftCancellativeMagmaTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLeftCancellativeMagmaTerm2 n A) -> (Staged (OpLeftCancellativeMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module LeftCancellativeOp  where
    record LeftCancellativeOp (A : Set) : Set where
      constructor LeftCancellativeOpC
      field
        op : (A -> (A -> A))
        linv : (A -> (A -> A))
        lefCancelOp : {x y : A} -> (linv x (op x y)) == y
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        linvS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        linvP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        lefCancelOpP : {xP yP : (Prod A A)} -> (linvP xP (opP xP yP)) == yP
    record Hom {A1 : Set} {A2 : Set} (Le1 : (LeftCancellativeOp A1)) (Le2 : (LeftCancellativeOp A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Le1) x1 x2)) == ((op Le2) (hom x1) (hom x2))
        pres-linv : {x1 x2 : A1} -> (hom ((linv Le1) x1 x2)) == ((linv Le2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Le1 : (LeftCancellativeOp A1)) (Le2 : (LeftCancellativeOp A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Le1) x1 x2) ((op Le2) y1 y2))))
        interp-linv : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((linv Le1) x1 x2) ((linv Le2) y1 y2))))
    data LeftCancellativeOpTerm  : Set where
      opL : (LeftCancellativeOpTerm -> (LeftCancellativeOpTerm -> LeftCancellativeOpTerm))
      linvL : (LeftCancellativeOpTerm -> (LeftCancellativeOpTerm -> LeftCancellativeOpTerm))
    data ClLeftCancellativeOpTerm (A : Set) : Set where
      sing : (A -> (ClLeftCancellativeOpTerm A))
      opCl : ((ClLeftCancellativeOpTerm A) -> ((ClLeftCancellativeOpTerm A) -> (ClLeftCancellativeOpTerm A)))
      linvCl : ((ClLeftCancellativeOpTerm A) -> ((ClLeftCancellativeOpTerm A) -> (ClLeftCancellativeOpTerm A)))
    data OpLeftCancellativeOpTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLeftCancellativeOpTerm n))
      opOL : ((OpLeftCancellativeOpTerm n) -> ((OpLeftCancellativeOpTerm n) -> (OpLeftCancellativeOpTerm n)))
      linvOL : ((OpLeftCancellativeOpTerm n) -> ((OpLeftCancellativeOpTerm n) -> (OpLeftCancellativeOpTerm n)))
    data OpLeftCancellativeOpTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLeftCancellativeOpTerm2 n A))
      sing2 : (A -> (OpLeftCancellativeOpTerm2 n A))
      opOL2 : ((OpLeftCancellativeOpTerm2 n A) -> ((OpLeftCancellativeOpTerm2 n A) -> (OpLeftCancellativeOpTerm2 n A)))
      linvOL2 : ((OpLeftCancellativeOpTerm2 n A) -> ((OpLeftCancellativeOpTerm2 n A) -> (OpLeftCancellativeOpTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClLeftCancellativeOpTerm A) -> (ClLeftCancellativeOpTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (linvCl x1 x2) = (linvCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLeftCancellativeOpTerm n) -> (OpLeftCancellativeOpTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (linvOL x1 x2) = (linvOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLeftCancellativeOpTerm2 n A) -> (OpLeftCancellativeOpTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (linvOL2 x1 x2) = (linvOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((LeftCancellativeOp A) -> (LeftCancellativeOpTerm -> A))
    evalB Le (opL x1 x2) = ((op Le) (evalB Le x1) (evalB Le x2)) 
    evalB Le (linvL x1 x2) = ((linv Le) (evalB Le x1) (evalB Le x2)) 
    evalCl : {A : Set} -> ((LeftCancellativeOp A) -> ((ClLeftCancellativeOpTerm A) -> A))
    evalCl Le (sing x1) = x1 
    evalCl Le (opCl x1 x2) = ((op Le) (evalCl Le x1) (evalCl Le x2)) 
    evalCl Le (linvCl x1 x2) = ((linv Le) (evalCl Le x1) (evalCl Le x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((LeftCancellativeOp A) -> ((Vec A n) -> ((OpLeftCancellativeOpTerm n) -> A)))
    evalOpB Le vars (v x1) = (lookup _ x1 vars) 
    evalOpB Le vars (opOL x1 x2) = ((op Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOpB Le vars (linvOL x1 x2) = ((linv Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((LeftCancellativeOp A) -> ((Vec A n) -> ((OpLeftCancellativeOpTerm2 n A) -> A)))
    evalOp Le vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Le vars (sing2 x1) = x1 
    evalOp Le vars (opOL2 x1 x2) = ((op Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    evalOp Le vars (linvOL2 x1 x2) = ((linv Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    inductionB : {P : (LeftCancellativeOpTerm -> Set)} -> (((x1 x2 : LeftCancellativeOpTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> (((x1 x2 : LeftCancellativeOpTerm) -> ((P x1) -> ((P x2) -> (P (linvL x1 x2))))) -> ((x : LeftCancellativeOpTerm) -> (P x))))
    inductionB {p} popl plinvl (opL x1 x2) = (popl _ _ (inductionB {p} popl plinvl x1) (inductionB {p} popl plinvl x2)) 
    inductionB {p} popl plinvl (linvL x1 x2) = (plinvl _ _ (inductionB {p} popl plinvl x1) (inductionB {p} popl plinvl x2)) 
    inductionCl : {A : Set} {P : ((ClLeftCancellativeOpTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClLeftCancellativeOpTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> (((x1 x2 : (ClLeftCancellativeOpTerm A)) -> ((P x1) -> ((P x2) -> (P (linvCl x1 x2))))) -> ((x : (ClLeftCancellativeOpTerm A)) -> (P x)))))
    inductionCl {_} {p} psing popcl plinvcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl plinvcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl plinvcl x1) (inductionCl {_} {p} psing popcl plinvcl x2)) 
    inductionCl {_} {p} psing popcl plinvcl (linvCl x1 x2) = (plinvcl _ _ (inductionCl {_} {p} psing popcl plinvcl x1) (inductionCl {_} {p} psing popcl plinvcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLeftCancellativeOpTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpLeftCancellativeOpTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> (((x1 x2 : (OpLeftCancellativeOpTerm n)) -> ((P x1) -> ((P x2) -> (P (linvOL x1 x2))))) -> ((x : (OpLeftCancellativeOpTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv popol plinvol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol plinvol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol plinvol x1) (inductionOpB {_} {p} pv popol plinvol x2)) 
    inductionOpB {_} {p} pv popol plinvol (linvOL x1 x2) = (plinvol _ _ (inductionOpB {_} {p} pv popol plinvol x1) (inductionOpB {_} {p} pv popol plinvol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLeftCancellativeOpTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpLeftCancellativeOpTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> (((x1 x2 : (OpLeftCancellativeOpTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (linvOL2 x1 x2))))) -> ((x : (OpLeftCancellativeOpTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 (linvOL2 x1 x2) = (plinvol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 x2)) 
    opL' : (LeftCancellativeOpTerm -> (LeftCancellativeOpTerm -> LeftCancellativeOpTerm))
    opL' x1 x2 = (opL x1 x2) 
    linvL' : (LeftCancellativeOpTerm -> (LeftCancellativeOpTerm -> LeftCancellativeOpTerm))
    linvL' x1 x2 = (linvL x1 x2) 
    stageB : (LeftCancellativeOpTerm -> (Staged LeftCancellativeOpTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB (linvL x1 x2) = (stage2 linvL' (codeLift2 linvL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClLeftCancellativeOpTerm A) -> ((ClLeftCancellativeOpTerm A) -> (ClLeftCancellativeOpTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    linvCl' : {A : Set} -> ((ClLeftCancellativeOpTerm A) -> ((ClLeftCancellativeOpTerm A) -> (ClLeftCancellativeOpTerm A)))
    linvCl' x1 x2 = (linvCl x1 x2) 
    stageCl : {A : Set} -> ((ClLeftCancellativeOpTerm A) -> (Staged (ClLeftCancellativeOpTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl (linvCl x1 x2) = (stage2 linvCl' (codeLift2 linvCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpLeftCancellativeOpTerm n) -> ((OpLeftCancellativeOpTerm n) -> (OpLeftCancellativeOpTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    linvOL' : {n : Nat} -> ((OpLeftCancellativeOpTerm n) -> ((OpLeftCancellativeOpTerm n) -> (OpLeftCancellativeOpTerm n)))
    linvOL' x1 x2 = (linvOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLeftCancellativeOpTerm n) -> (Staged (OpLeftCancellativeOpTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (linvOL x1 x2) = (stage2 linvOL' (codeLift2 linvOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpLeftCancellativeOpTerm2 n A) -> ((OpLeftCancellativeOpTerm2 n A) -> (OpLeftCancellativeOpTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    linvOL2' : {n : Nat} {A : Set} -> ((OpLeftCancellativeOpTerm2 n A) -> ((OpLeftCancellativeOpTerm2 n A) -> (OpLeftCancellativeOpTerm2 n A)))
    linvOL2' x1 x2 = (linvOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLeftCancellativeOpTerm2 n A) -> (Staged (OpLeftCancellativeOpTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp (linvOL2 x1 x2) = (stage2 linvOL2' (codeLift2 linvOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        linvT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module LeftCancellativeSemigroup  where
    record LeftCancellativeSemigroup (A : Set) : Set where
      constructor LeftCancellativeSemigroupC
      field
        op : (A -> (A -> A))
        associative_op : {x y z : A} -> (op (op x y) z) == (op x (op y z))
        leftCancellative : {x y z : A} -> ((op z x) == (op z y) -> x == y)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        associative_opP : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP (opP yP zP))
        leftCancellativeP : {xP yP zP : (Prod A A)} -> ((opP zP xP) == (opP zP yP) -> xP == yP)
    record Hom {A1 : Set} {A2 : Set} (Le1 : (LeftCancellativeSemigroup A1)) (Le2 : (LeftCancellativeSemigroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Le1) x1 x2)) == ((op Le2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Le1 : (LeftCancellativeSemigroup A1)) (Le2 : (LeftCancellativeSemigroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Le1) x1 x2) ((op Le2) y1 y2))))
    data LeftCancellativeSemigroupTerm  : Set where
      opL : (LeftCancellativeSemigroupTerm -> (LeftCancellativeSemigroupTerm -> LeftCancellativeSemigroupTerm))
    data ClLeftCancellativeSemigroupTerm (A : Set) : Set where
      sing : (A -> (ClLeftCancellativeSemigroupTerm A))
      opCl : ((ClLeftCancellativeSemigroupTerm A) -> ((ClLeftCancellativeSemigroupTerm A) -> (ClLeftCancellativeSemigroupTerm A)))
    data OpLeftCancellativeSemigroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLeftCancellativeSemigroupTerm n))
      opOL : ((OpLeftCancellativeSemigroupTerm n) -> ((OpLeftCancellativeSemigroupTerm n) -> (OpLeftCancellativeSemigroupTerm n)))
    data OpLeftCancellativeSemigroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLeftCancellativeSemigroupTerm2 n A))
      sing2 : (A -> (OpLeftCancellativeSemigroupTerm2 n A))
      opOL2 : ((OpLeftCancellativeSemigroupTerm2 n A) -> ((OpLeftCancellativeSemigroupTerm2 n A) -> (OpLeftCancellativeSemigroupTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClLeftCancellativeSemigroupTerm A) -> (ClLeftCancellativeSemigroupTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLeftCancellativeSemigroupTerm n) -> (OpLeftCancellativeSemigroupTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLeftCancellativeSemigroupTerm2 n A) -> (OpLeftCancellativeSemigroupTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((LeftCancellativeSemigroup A) -> (LeftCancellativeSemigroupTerm -> A))
    evalB Le (opL x1 x2) = ((op Le) (evalB Le x1) (evalB Le x2)) 
    evalCl : {A : Set} -> ((LeftCancellativeSemigroup A) -> ((ClLeftCancellativeSemigroupTerm A) -> A))
    evalCl Le (sing x1) = x1 
    evalCl Le (opCl x1 x2) = ((op Le) (evalCl Le x1) (evalCl Le x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((LeftCancellativeSemigroup A) -> ((Vec A n) -> ((OpLeftCancellativeSemigroupTerm n) -> A)))
    evalOpB Le vars (v x1) = (lookup _ x1 vars) 
    evalOpB Le vars (opOL x1 x2) = ((op Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((LeftCancellativeSemigroup A) -> ((Vec A n) -> ((OpLeftCancellativeSemigroupTerm2 n A) -> A)))
    evalOp Le vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Le vars (sing2 x1) = x1 
    evalOp Le vars (opOL2 x1 x2) = ((op Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    inductionB : {P : (LeftCancellativeSemigroupTerm -> Set)} -> (((x1 x2 : LeftCancellativeSemigroupTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : LeftCancellativeSemigroupTerm) -> (P x)))
    inductionB {p} popl (opL x1 x2) = (popl _ _ (inductionB {p} popl x1) (inductionB {p} popl x2)) 
    inductionCl : {A : Set} {P : ((ClLeftCancellativeSemigroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClLeftCancellativeSemigroupTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClLeftCancellativeSemigroupTerm A)) -> (P x))))
    inductionCl {_} {p} psing popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl x1) (inductionCl {_} {p} psing popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLeftCancellativeSemigroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpLeftCancellativeSemigroupTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpLeftCancellativeSemigroupTerm n)) -> (P x))))
    inductionOpB {_} {p} pv popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol x1) (inductionOpB {_} {p} pv popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLeftCancellativeSemigroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpLeftCancellativeSemigroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpLeftCancellativeSemigroupTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 x2)) 
    opL' : (LeftCancellativeSemigroupTerm -> (LeftCancellativeSemigroupTerm -> LeftCancellativeSemigroupTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (LeftCancellativeSemigroupTerm -> (Staged LeftCancellativeSemigroupTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClLeftCancellativeSemigroupTerm A) -> ((ClLeftCancellativeSemigroupTerm A) -> (ClLeftCancellativeSemigroupTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClLeftCancellativeSemigroupTerm A) -> (Staged (ClLeftCancellativeSemigroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpLeftCancellativeSemigroupTerm n) -> ((OpLeftCancellativeSemigroupTerm n) -> (OpLeftCancellativeSemigroupTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLeftCancellativeSemigroupTerm n) -> (Staged (OpLeftCancellativeSemigroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpLeftCancellativeSemigroupTerm2 n A) -> ((OpLeftCancellativeSemigroupTerm2 n A) -> (OpLeftCancellativeSemigroupTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLeftCancellativeSemigroupTerm2 n A) -> (Staged (OpLeftCancellativeSemigroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module LeftDistributiveMagma  where
    record LeftDistributiveMagma (A : Set) : Set where
      constructor LeftDistributiveMagmaC
      field
        op : (A -> (A -> A))
        leftDistributive : {x y z : A} -> (op x (op y z)) == (op (op x y) (op x z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftDistributiveP : {xP yP zP : (Prod A A)} -> (opP xP (opP yP zP)) == (opP (opP xP yP) (opP xP zP))
    record Hom {A1 : Set} {A2 : Set} (Le1 : (LeftDistributiveMagma A1)) (Le2 : (LeftDistributiveMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Le1) x1 x2)) == ((op Le2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Le1 : (LeftDistributiveMagma A1)) (Le2 : (LeftDistributiveMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Le1) x1 x2) ((op Le2) y1 y2))))
    data LeftDistributiveMagmaTerm  : Set where
      opL : (LeftDistributiveMagmaTerm -> (LeftDistributiveMagmaTerm -> LeftDistributiveMagmaTerm))
    data ClLeftDistributiveMagmaTerm (A : Set) : Set where
      sing : (A -> (ClLeftDistributiveMagmaTerm A))
      opCl : ((ClLeftDistributiveMagmaTerm A) -> ((ClLeftDistributiveMagmaTerm A) -> (ClLeftDistributiveMagmaTerm A)))
    data OpLeftDistributiveMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLeftDistributiveMagmaTerm n))
      opOL : ((OpLeftDistributiveMagmaTerm n) -> ((OpLeftDistributiveMagmaTerm n) -> (OpLeftDistributiveMagmaTerm n)))
    data OpLeftDistributiveMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLeftDistributiveMagmaTerm2 n A))
      sing2 : (A -> (OpLeftDistributiveMagmaTerm2 n A))
      opOL2 : ((OpLeftDistributiveMagmaTerm2 n A) -> ((OpLeftDistributiveMagmaTerm2 n A) -> (OpLeftDistributiveMagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClLeftDistributiveMagmaTerm A) -> (ClLeftDistributiveMagmaTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLeftDistributiveMagmaTerm n) -> (OpLeftDistributiveMagmaTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLeftDistributiveMagmaTerm2 n A) -> (OpLeftDistributiveMagmaTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((LeftDistributiveMagma A) -> (LeftDistributiveMagmaTerm -> A))
    evalB Le (opL x1 x2) = ((op Le) (evalB Le x1) (evalB Le x2)) 
    evalCl : {A : Set} -> ((LeftDistributiveMagma A) -> ((ClLeftDistributiveMagmaTerm A) -> A))
    evalCl Le (sing x1) = x1 
    evalCl Le (opCl x1 x2) = ((op Le) (evalCl Le x1) (evalCl Le x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((LeftDistributiveMagma A) -> ((Vec A n) -> ((OpLeftDistributiveMagmaTerm n) -> A)))
    evalOpB Le vars (v x1) = (lookup _ x1 vars) 
    evalOpB Le vars (opOL x1 x2) = ((op Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((LeftDistributiveMagma A) -> ((Vec A n) -> ((OpLeftDistributiveMagmaTerm2 n A) -> A)))
    evalOp Le vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Le vars (sing2 x1) = x1 
    evalOp Le vars (opOL2 x1 x2) = ((op Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    inductionB : {P : (LeftDistributiveMagmaTerm -> Set)} -> (((x1 x2 : LeftDistributiveMagmaTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : LeftDistributiveMagmaTerm) -> (P x)))
    inductionB {p} popl (opL x1 x2) = (popl _ _ (inductionB {p} popl x1) (inductionB {p} popl x2)) 
    inductionCl : {A : Set} {P : ((ClLeftDistributiveMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClLeftDistributiveMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClLeftDistributiveMagmaTerm A)) -> (P x))))
    inductionCl {_} {p} psing popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl x1) (inductionCl {_} {p} psing popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLeftDistributiveMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpLeftDistributiveMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpLeftDistributiveMagmaTerm n)) -> (P x))))
    inductionOpB {_} {p} pv popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol x1) (inductionOpB {_} {p} pv popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLeftDistributiveMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpLeftDistributiveMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpLeftDistributiveMagmaTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 x2)) 
    opL' : (LeftDistributiveMagmaTerm -> (LeftDistributiveMagmaTerm -> LeftDistributiveMagmaTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (LeftDistributiveMagmaTerm -> (Staged LeftDistributiveMagmaTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClLeftDistributiveMagmaTerm A) -> ((ClLeftDistributiveMagmaTerm A) -> (ClLeftDistributiveMagmaTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClLeftDistributiveMagmaTerm A) -> (Staged (ClLeftDistributiveMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpLeftDistributiveMagmaTerm n) -> ((OpLeftDistributiveMagmaTerm n) -> (OpLeftDistributiveMagmaTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLeftDistributiveMagmaTerm n) -> (Staged (OpLeftDistributiveMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpLeftDistributiveMagmaTerm2 n A) -> ((OpLeftDistributiveMagmaTerm2 n A) -> (OpLeftDistributiveMagmaTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLeftDistributiveMagmaTerm2 n A) -> (Staged (OpLeftDistributiveMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module LeftIdempotence  where
    record LeftIdempotence (A : Set) : Set where
      constructor LeftIdempotenceC
      field
        |> : (A -> (A -> A))
        idempotent_|> : {x : A} -> (|> x x) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        |>S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        |>P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        idempotent_|>P : {xP : (Prod A A)} -> (|>P xP xP) == xP
    record Hom {A1 : Set} {A2 : Set} (Le1 : (LeftIdempotence A1)) (Le2 : (LeftIdempotence A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-|> : {x1 x2 : A1} -> (hom ((|> Le1) x1 x2)) == ((|> Le2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Le1 : (LeftIdempotence A1)) (Le2 : (LeftIdempotence A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-|> : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((|> Le1) x1 x2) ((|> Le2) y1 y2))))
    data LeftIdempotenceTerm  : Set where
      |>L : (LeftIdempotenceTerm -> (LeftIdempotenceTerm -> LeftIdempotenceTerm))
    data ClLeftIdempotenceTerm (A : Set) : Set where
      sing : (A -> (ClLeftIdempotenceTerm A))
      |>Cl : ((ClLeftIdempotenceTerm A) -> ((ClLeftIdempotenceTerm A) -> (ClLeftIdempotenceTerm A)))
    data OpLeftIdempotenceTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLeftIdempotenceTerm n))
      |>OL : ((OpLeftIdempotenceTerm n) -> ((OpLeftIdempotenceTerm n) -> (OpLeftIdempotenceTerm n)))
    data OpLeftIdempotenceTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLeftIdempotenceTerm2 n A))
      sing2 : (A -> (OpLeftIdempotenceTerm2 n A))
      |>OL2 : ((OpLeftIdempotenceTerm2 n A) -> ((OpLeftIdempotenceTerm2 n A) -> (OpLeftIdempotenceTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClLeftIdempotenceTerm A) -> (ClLeftIdempotenceTerm A))
    simplifyCl (|>Cl x1 x2) = (|>Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLeftIdempotenceTerm n) -> (OpLeftIdempotenceTerm n))
    simplifyOpB (|>OL x1 x2) = (|>OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLeftIdempotenceTerm2 n A) -> (OpLeftIdempotenceTerm2 n A))
    simplifyOp (|>OL2 x1 x2) = (|>OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((LeftIdempotence A) -> (LeftIdempotenceTerm -> A))
    evalB Le (|>L x1 x2) = ((|> Le) (evalB Le x1) (evalB Le x2)) 
    evalCl : {A : Set} -> ((LeftIdempotence A) -> ((ClLeftIdempotenceTerm A) -> A))
    evalCl Le (sing x1) = x1 
    evalCl Le (|>Cl x1 x2) = ((|> Le) (evalCl Le x1) (evalCl Le x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((LeftIdempotence A) -> ((Vec A n) -> ((OpLeftIdempotenceTerm n) -> A)))
    evalOpB Le vars (v x1) = (lookup _ x1 vars) 
    evalOpB Le vars (|>OL x1 x2) = ((|> Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((LeftIdempotence A) -> ((Vec A n) -> ((OpLeftIdempotenceTerm2 n A) -> A)))
    evalOp Le vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Le vars (sing2 x1) = x1 
    evalOp Le vars (|>OL2 x1 x2) = ((|> Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    inductionB : {P : (LeftIdempotenceTerm -> Set)} -> (((x1 x2 : LeftIdempotenceTerm) -> ((P x1) -> ((P x2) -> (P (|>L x1 x2))))) -> ((x : LeftIdempotenceTerm) -> (P x)))
    inductionB {p} p|>l (|>L x1 x2) = (p|>l _ _ (inductionB {p} p|>l x1) (inductionB {p} p|>l x2)) 
    inductionCl : {A : Set} {P : ((ClLeftIdempotenceTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClLeftIdempotenceTerm A)) -> ((P x1) -> ((P x2) -> (P (|>Cl x1 x2))))) -> ((x : (ClLeftIdempotenceTerm A)) -> (P x))))
    inductionCl {_} {p} psing p|>cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p|>cl (|>Cl x1 x2) = (p|>cl _ _ (inductionCl {_} {p} psing p|>cl x1) (inductionCl {_} {p} psing p|>cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLeftIdempotenceTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpLeftIdempotenceTerm n)) -> ((P x1) -> ((P x2) -> (P (|>OL x1 x2))))) -> ((x : (OpLeftIdempotenceTerm n)) -> (P x))))
    inductionOpB {_} {p} pv p|>ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p|>ol (|>OL x1 x2) = (p|>ol _ _ (inductionOpB {_} {p} pv p|>ol x1) (inductionOpB {_} {p} pv p|>ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLeftIdempotenceTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpLeftIdempotenceTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (|>OL2 x1 x2))))) -> ((x : (OpLeftIdempotenceTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 (|>OL2 x1 x2) = (p|>ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 x2)) 
    |>L' : (LeftIdempotenceTerm -> (LeftIdempotenceTerm -> LeftIdempotenceTerm))
    |>L' x1 x2 = (|>L x1 x2) 
    stageB : (LeftIdempotenceTerm -> (Staged LeftIdempotenceTerm))
    stageB (|>L x1 x2) = (stage2 |>L' (codeLift2 |>L') (stageB x1) (stageB x2)) 
    |>Cl' : {A : Set} -> ((ClLeftIdempotenceTerm A) -> ((ClLeftIdempotenceTerm A) -> (ClLeftIdempotenceTerm A)))
    |>Cl' x1 x2 = (|>Cl x1 x2) 
    stageCl : {A : Set} -> ((ClLeftIdempotenceTerm A) -> (Staged (ClLeftIdempotenceTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (|>Cl x1 x2) = (stage2 |>Cl' (codeLift2 |>Cl') (stageCl x1) (stageCl x2)) 
    |>OL' : {n : Nat} -> ((OpLeftIdempotenceTerm n) -> ((OpLeftIdempotenceTerm n) -> (OpLeftIdempotenceTerm n)))
    |>OL' x1 x2 = (|>OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLeftIdempotenceTerm n) -> (Staged (OpLeftIdempotenceTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (|>OL x1 x2) = (stage2 |>OL' (codeLift2 |>OL') (stageOpB x1) (stageOpB x2)) 
    |>OL2' : {n : Nat} {A : Set} -> ((OpLeftIdempotenceTerm2 n A) -> ((OpLeftIdempotenceTerm2 n A) -> (OpLeftIdempotenceTerm2 n A)))
    |>OL2' x1 x2 = (|>OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLeftIdempotenceTerm2 n A) -> (Staged (OpLeftIdempotenceTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (|>OL2 x1 x2) = (stage2 |>OL2' (codeLift2 |>OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        |>T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module LeftInverse  where
    record LeftInverse (A : Set) : Set where
      constructor LeftInverseC
      field
        inv : (A -> A)
        e : A
        op : (A -> (A -> A))
        leftInverse_inv_op_e : {x : A} -> (op x (inv x)) == e
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        invS : (AS -> AS)
        eS : AS
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        invP : ((Prod A A) -> (Prod A A))
        eP : (Prod A A)
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftInverse_inv_op_eP : {xP : (Prod A A)} -> (opP xP (invP xP)) == eP
    record Hom {A1 : Set} {A2 : Set} (Le1 : (LeftInverse A1)) (Le2 : (LeftInverse A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-inv : {x1 : A1} -> (hom ((inv Le1) x1)) == ((inv Le2) (hom x1))
        pres-e : (hom (e Le1)) == (e Le2)
        pres-op : {x1 x2 : A1} -> (hom ((op Le1) x1 x2)) == ((op Le2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Le1 : (LeftInverse A1)) (Le2 : (LeftInverse A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-inv : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((inv Le1) x1) ((inv Le2) y1)))
        interp-e : (interp (e Le1) (e Le2))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Le1) x1 x2) ((op Le2) y1 y2))))
    data LeftInverseLTerm  : Set where
      invL : (LeftInverseLTerm -> LeftInverseLTerm)
      eL : LeftInverseLTerm
      opL : (LeftInverseLTerm -> (LeftInverseLTerm -> LeftInverseLTerm))
    data ClLeftInverseClTerm (A : Set) : Set where
      sing : (A -> (ClLeftInverseClTerm A))
      invCl : ((ClLeftInverseClTerm A) -> (ClLeftInverseClTerm A))
      eCl : (ClLeftInverseClTerm A)
      opCl : ((ClLeftInverseClTerm A) -> ((ClLeftInverseClTerm A) -> (ClLeftInverseClTerm A)))
    data OpLeftInverseOLTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLeftInverseOLTerm n))
      invOL : ((OpLeftInverseOLTerm n) -> (OpLeftInverseOLTerm n))
      eOL : (OpLeftInverseOLTerm n)
      opOL : ((OpLeftInverseOLTerm n) -> ((OpLeftInverseOLTerm n) -> (OpLeftInverseOLTerm n)))
    data OpLeftInverseOL2Term2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLeftInverseOL2Term2 n A))
      sing2 : (A -> (OpLeftInverseOL2Term2 n A))
      invOL2 : ((OpLeftInverseOL2Term2 n A) -> (OpLeftInverseOL2Term2 n A))
      eOL2 : (OpLeftInverseOL2Term2 n A)
      opOL2 : ((OpLeftInverseOL2Term2 n A) -> ((OpLeftInverseOL2Term2 n A) -> (OpLeftInverseOL2Term2 n A)))
    simplifyCl : {A : Set} -> ((ClLeftInverseClTerm A) -> (ClLeftInverseClTerm A))
    simplifyCl (invCl x1) = (invCl (simplifyCl x1)) 
    simplifyCl eCl = eCl 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLeftInverseOLTerm n) -> (OpLeftInverseOLTerm n))
    simplifyOpB (invOL x1) = (invOL (simplifyOpB x1)) 
    simplifyOpB eOL = eOL 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLeftInverseOL2Term2 n A) -> (OpLeftInverseOL2Term2 n A))
    simplifyOp (invOL2 x1) = (invOL2 (simplifyOp x1)) 
    simplifyOp eOL2 = eOL2 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((LeftInverse A) -> (LeftInverseLTerm -> A))
    evalB Le (invL x1) = ((inv Le) (evalB Le x1)) 
    evalB Le eL = (e Le) 
    evalB Le (opL x1 x2) = ((op Le) (evalB Le x1) (evalB Le x2)) 
    evalCl : {A : Set} -> ((LeftInverse A) -> ((ClLeftInverseClTerm A) -> A))
    evalCl Le (sing x1) = x1 
    evalCl Le (invCl x1) = ((inv Le) (evalCl Le x1)) 
    evalCl Le eCl = (e Le) 
    evalCl Le (opCl x1 x2) = ((op Le) (evalCl Le x1) (evalCl Le x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((LeftInverse A) -> ((Vec A n) -> ((OpLeftInverseOLTerm n) -> A)))
    evalOpB Le vars (v x1) = (lookup _ x1 vars) 
    evalOpB Le vars (invOL x1) = ((inv Le) (evalOpB Le vars x1)) 
    evalOpB Le vars eOL = (e Le) 
    evalOpB Le vars (opOL x1 x2) = ((op Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((LeftInverse A) -> ((Vec A n) -> ((OpLeftInverseOL2Term2 n A) -> A)))
    evalOp Le vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Le vars (sing2 x1) = x1 
    evalOp Le vars (invOL2 x1) = ((inv Le) (evalOp Le vars x1)) 
    evalOp Le vars eOL2 = (e Le) 
    evalOp Le vars (opOL2 x1 x2) = ((op Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    inductionB : {P : (LeftInverseLTerm -> Set)} -> (((x1 : LeftInverseLTerm) -> ((P x1) -> (P (invL x1)))) -> ((P eL) -> (((x1 x2 : LeftInverseLTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : LeftInverseLTerm) -> (P x)))))
    inductionB {p} pinvl pel popl (invL x1) = (pinvl _ (inductionB {p} pinvl pel popl x1)) 
    inductionB {p} pinvl pel popl eL = pel 
    inductionB {p} pinvl pel popl (opL x1 x2) = (popl _ _ (inductionB {p} pinvl pel popl x1) (inductionB {p} pinvl pel popl x2)) 
    inductionCl : {A : Set} {P : ((ClLeftInverseClTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 : (ClLeftInverseClTerm A)) -> ((P x1) -> (P (invCl x1)))) -> ((P eCl) -> (((x1 x2 : (ClLeftInverseClTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClLeftInverseClTerm A)) -> (P x))))))
    inductionCl {_} {p} psing pinvcl pecl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pinvcl pecl popcl (invCl x1) = (pinvcl _ (inductionCl {_} {p} psing pinvcl pecl popcl x1)) 
    inductionCl {_} {p} psing pinvcl pecl popcl eCl = pecl 
    inductionCl {_} {p} psing pinvcl pecl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing pinvcl pecl popcl x1) (inductionCl {_} {p} psing pinvcl pecl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLeftInverseOLTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 : (OpLeftInverseOLTerm n)) -> ((P x1) -> (P (invOL x1)))) -> ((P eOL) -> (((x1 x2 : (OpLeftInverseOLTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpLeftInverseOLTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv pinvol peol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pinvol peol popol (invOL x1) = (pinvol _ (inductionOpB {_} {p} pv pinvol peol popol x1)) 
    inductionOpB {_} {p} pv pinvol peol popol eOL = peol 
    inductionOpB {_} {p} pv pinvol peol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv pinvol peol popol x1) (inductionOpB {_} {p} pv pinvol peol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLeftInverseOL2Term2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 : (OpLeftInverseOL2Term2 n A)) -> ((P x1) -> (P (invOL2 x1)))) -> ((P eOL2) -> (((x1 x2 : (OpLeftInverseOL2Term2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpLeftInverseOL2Term2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 (invOL2 x1) = (pinvol2 _ (inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 eOL2 = peol2 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 x2)) 
    invL' : (LeftInverseLTerm -> LeftInverseLTerm)
    invL' x1 = (invL x1) 
    eL' : LeftInverseLTerm
    eL'  = eL 
    opL' : (LeftInverseLTerm -> (LeftInverseLTerm -> LeftInverseLTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (LeftInverseLTerm -> (Staged LeftInverseLTerm))
    stageB (invL x1) = (stage1 invL' (codeLift1 invL') (stageB x1)) 
    stageB eL = (Now eL) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    invCl' : {A : Set} -> ((ClLeftInverseClTerm A) -> (ClLeftInverseClTerm A))
    invCl' x1 = (invCl x1) 
    eCl' : {A : Set} -> (ClLeftInverseClTerm A)
    eCl'  = eCl 
    opCl' : {A : Set} -> ((ClLeftInverseClTerm A) -> ((ClLeftInverseClTerm A) -> (ClLeftInverseClTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClLeftInverseClTerm A) -> (Staged (ClLeftInverseClTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (invCl x1) = (stage1 invCl' (codeLift1 invCl') (stageCl x1)) 
    stageCl eCl = (Now eCl) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    invOL' : {n : Nat} -> ((OpLeftInverseOLTerm n) -> (OpLeftInverseOLTerm n))
    invOL' x1 = (invOL x1) 
    eOL' : {n : Nat} -> (OpLeftInverseOLTerm n)
    eOL'  = eOL 
    opOL' : {n : Nat} -> ((OpLeftInverseOLTerm n) -> ((OpLeftInverseOLTerm n) -> (OpLeftInverseOLTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLeftInverseOLTerm n) -> (Staged (OpLeftInverseOLTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (invOL x1) = (stage1 invOL' (codeLift1 invOL') (stageOpB x1)) 
    stageOpB eOL = (Now eOL) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    invOL2' : {n : Nat} {A : Set} -> ((OpLeftInverseOL2Term2 n A) -> (OpLeftInverseOL2Term2 n A))
    invOL2' x1 = (invOL2 x1) 
    eOL2' : {n : Nat} {A : Set} -> (OpLeftInverseOL2Term2 n A)
    eOL2'  = eOL2 
    opOL2' : {n : Nat} {A : Set} -> ((OpLeftInverseOL2Term2 n A) -> ((OpLeftInverseOL2Term2 n A) -> (OpLeftInverseOL2Term2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLeftInverseOL2Term2 n A) -> (Staged (OpLeftInverseOL2Term2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (invOL2 x1) = (stage1 invOL2' (codeLift1 invOL2') (stageOp x1)) 
    stageOp eOL2 = (Now eOL2) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        invT : ((Repr A) -> (Repr A))
        eT : (Repr A)
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module LeftInverseMagma  where
    record LeftInverseMagma (A : Set) : Set where
      constructor LeftInverseMagmaC
      field
        linv : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        linvS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        linvP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
    record Hom {A1 : Set} {A2 : Set} (Le1 : (LeftInverseMagma A1)) (Le2 : (LeftInverseMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-linv : {x1 x2 : A1} -> (hom ((linv Le1) x1 x2)) == ((linv Le2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Le1 : (LeftInverseMagma A1)) (Le2 : (LeftInverseMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-linv : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((linv Le1) x1 x2) ((linv Le2) y1 y2))))
    data LeftInverseMagmaTerm  : Set where
      linvL : (LeftInverseMagmaTerm -> (LeftInverseMagmaTerm -> LeftInverseMagmaTerm))
    data ClLeftInverseMagmaTerm (A : Set) : Set where
      sing : (A -> (ClLeftInverseMagmaTerm A))
      linvCl : ((ClLeftInverseMagmaTerm A) -> ((ClLeftInverseMagmaTerm A) -> (ClLeftInverseMagmaTerm A)))
    data OpLeftInverseMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLeftInverseMagmaTerm n))
      linvOL : ((OpLeftInverseMagmaTerm n) -> ((OpLeftInverseMagmaTerm n) -> (OpLeftInverseMagmaTerm n)))
    data OpLeftInverseMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLeftInverseMagmaTerm2 n A))
      sing2 : (A -> (OpLeftInverseMagmaTerm2 n A))
      linvOL2 : ((OpLeftInverseMagmaTerm2 n A) -> ((OpLeftInverseMagmaTerm2 n A) -> (OpLeftInverseMagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClLeftInverseMagmaTerm A) -> (ClLeftInverseMagmaTerm A))
    simplifyCl (linvCl x1 x2) = (linvCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLeftInverseMagmaTerm n) -> (OpLeftInverseMagmaTerm n))
    simplifyOpB (linvOL x1 x2) = (linvOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLeftInverseMagmaTerm2 n A) -> (OpLeftInverseMagmaTerm2 n A))
    simplifyOp (linvOL2 x1 x2) = (linvOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((LeftInverseMagma A) -> (LeftInverseMagmaTerm -> A))
    evalB Le (linvL x1 x2) = ((linv Le) (evalB Le x1) (evalB Le x2)) 
    evalCl : {A : Set} -> ((LeftInverseMagma A) -> ((ClLeftInverseMagmaTerm A) -> A))
    evalCl Le (sing x1) = x1 
    evalCl Le (linvCl x1 x2) = ((linv Le) (evalCl Le x1) (evalCl Le x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((LeftInverseMagma A) -> ((Vec A n) -> ((OpLeftInverseMagmaTerm n) -> A)))
    evalOpB Le vars (v x1) = (lookup _ x1 vars) 
    evalOpB Le vars (linvOL x1 x2) = ((linv Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((LeftInverseMagma A) -> ((Vec A n) -> ((OpLeftInverseMagmaTerm2 n A) -> A)))
    evalOp Le vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Le vars (sing2 x1) = x1 
    evalOp Le vars (linvOL2 x1 x2) = ((linv Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    inductionB : {P : (LeftInverseMagmaTerm -> Set)} -> (((x1 x2 : LeftInverseMagmaTerm) -> ((P x1) -> ((P x2) -> (P (linvL x1 x2))))) -> ((x : LeftInverseMagmaTerm) -> (P x)))
    inductionB {p} plinvl (linvL x1 x2) = (plinvl _ _ (inductionB {p} plinvl x1) (inductionB {p} plinvl x2)) 
    inductionCl : {A : Set} {P : ((ClLeftInverseMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClLeftInverseMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (linvCl x1 x2))))) -> ((x : (ClLeftInverseMagmaTerm A)) -> (P x))))
    inductionCl {_} {p} psing plinvcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing plinvcl (linvCl x1 x2) = (plinvcl _ _ (inductionCl {_} {p} psing plinvcl x1) (inductionCl {_} {p} psing plinvcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLeftInverseMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpLeftInverseMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (linvOL x1 x2))))) -> ((x : (OpLeftInverseMagmaTerm n)) -> (P x))))
    inductionOpB {_} {p} pv plinvol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv plinvol (linvOL x1 x2) = (plinvol _ _ (inductionOpB {_} {p} pv plinvol x1) (inductionOpB {_} {p} pv plinvol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLeftInverseMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpLeftInverseMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (linvOL2 x1 x2))))) -> ((x : (OpLeftInverseMagmaTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 plinvol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 plinvol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 plinvol2 (linvOL2 x1 x2) = (plinvol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 plinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 plinvol2 x2)) 
    linvL' : (LeftInverseMagmaTerm -> (LeftInverseMagmaTerm -> LeftInverseMagmaTerm))
    linvL' x1 x2 = (linvL x1 x2) 
    stageB : (LeftInverseMagmaTerm -> (Staged LeftInverseMagmaTerm))
    stageB (linvL x1 x2) = (stage2 linvL' (codeLift2 linvL') (stageB x1) (stageB x2)) 
    linvCl' : {A : Set} -> ((ClLeftInverseMagmaTerm A) -> ((ClLeftInverseMagmaTerm A) -> (ClLeftInverseMagmaTerm A)))
    linvCl' x1 x2 = (linvCl x1 x2) 
    stageCl : {A : Set} -> ((ClLeftInverseMagmaTerm A) -> (Staged (ClLeftInverseMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (linvCl x1 x2) = (stage2 linvCl' (codeLift2 linvCl') (stageCl x1) (stageCl x2)) 
    linvOL' : {n : Nat} -> ((OpLeftInverseMagmaTerm n) -> ((OpLeftInverseMagmaTerm n) -> (OpLeftInverseMagmaTerm n)))
    linvOL' x1 x2 = (linvOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLeftInverseMagmaTerm n) -> (Staged (OpLeftInverseMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (linvOL x1 x2) = (stage2 linvOL' (codeLift2 linvOL') (stageOpB x1) (stageOpB x2)) 
    linvOL2' : {n : Nat} {A : Set} -> ((OpLeftInverseMagmaTerm2 n A) -> ((OpLeftInverseMagmaTerm2 n A) -> (OpLeftInverseMagmaTerm2 n A)))
    linvOL2' x1 x2 = (linvOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLeftInverseMagmaTerm2 n A) -> (Staged (OpLeftInverseMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (linvOL2 x1 x2) = (stage2 linvOL2' (codeLift2 linvOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        linvT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module LeftLoop  where
    record LeftLoop (A : Set) : Set where
      constructor LeftLoopC
      field
        op : (A -> (A -> A))
        e : A
        runit_e : {x : A} -> (op x e) == x
        linv : (A -> (A -> A))
        leftCancel : {x y : A} -> (op x (linv x y)) == y
        lefCancelOp : {x y : A} -> (linv x (op x y)) == y
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        eS : AS
        linvS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        eP : (Prod A A)
        linvP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        runit_eP : {xP : (Prod A A)} -> (opP xP eP) == xP
        leftCancelP : {xP yP : (Prod A A)} -> (opP xP (linvP xP yP)) == yP
        lefCancelOpP : {xP yP : (Prod A A)} -> (linvP xP (opP xP yP)) == yP
    record Hom {A1 : Set} {A2 : Set} (Le1 : (LeftLoop A1)) (Le2 : (LeftLoop A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Le1) x1 x2)) == ((op Le2) (hom x1) (hom x2))
        pres-e : (hom (e Le1)) == (e Le2)
        pres-linv : {x1 x2 : A1} -> (hom ((linv Le1) x1 x2)) == ((linv Le2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Le1 : (LeftLoop A1)) (Le2 : (LeftLoop A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Le1) x1 x2) ((op Le2) y1 y2))))
        interp-e : (interp (e Le1) (e Le2))
        interp-linv : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((linv Le1) x1 x2) ((linv Le2) y1 y2))))
    data LeftLoopLTerm  : Set where
      opL : (LeftLoopLTerm -> (LeftLoopLTerm -> LeftLoopLTerm))
      eL : LeftLoopLTerm
      linvL : (LeftLoopLTerm -> (LeftLoopLTerm -> LeftLoopLTerm))
    data ClLeftLoopClTerm (A : Set) : Set where
      sing : (A -> (ClLeftLoopClTerm A))
      opCl : ((ClLeftLoopClTerm A) -> ((ClLeftLoopClTerm A) -> (ClLeftLoopClTerm A)))
      eCl : (ClLeftLoopClTerm A)
      linvCl : ((ClLeftLoopClTerm A) -> ((ClLeftLoopClTerm A) -> (ClLeftLoopClTerm A)))
    data OpLeftLoopOLTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLeftLoopOLTerm n))
      opOL : ((OpLeftLoopOLTerm n) -> ((OpLeftLoopOLTerm n) -> (OpLeftLoopOLTerm n)))
      eOL : (OpLeftLoopOLTerm n)
      linvOL : ((OpLeftLoopOLTerm n) -> ((OpLeftLoopOLTerm n) -> (OpLeftLoopOLTerm n)))
    data OpLeftLoopOL2Term2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLeftLoopOL2Term2 n A))
      sing2 : (A -> (OpLeftLoopOL2Term2 n A))
      opOL2 : ((OpLeftLoopOL2Term2 n A) -> ((OpLeftLoopOL2Term2 n A) -> (OpLeftLoopOL2Term2 n A)))
      eOL2 : (OpLeftLoopOL2Term2 n A)
      linvOL2 : ((OpLeftLoopOL2Term2 n A) -> ((OpLeftLoopOL2Term2 n A) -> (OpLeftLoopOL2Term2 n A)))
    simplifyCl : {A : Set} -> ((ClLeftLoopClTerm A) -> (ClLeftLoopClTerm A))
    simplifyCl (opCl x eCl) = x 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl eCl = eCl 
    simplifyCl (linvCl x1 x2) = (linvCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLeftLoopOLTerm n) -> (OpLeftLoopOLTerm n))
    simplifyOpB (opOL x eOL) = x 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB eOL = eOL 
    simplifyOpB (linvOL x1 x2) = (linvOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLeftLoopOL2Term2 n A) -> (OpLeftLoopOL2Term2 n A))
    simplifyOp (opOL2 x eOL2) = x 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp eOL2 = eOL2 
    simplifyOp (linvOL2 x1 x2) = (linvOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((LeftLoop A) -> (LeftLoopLTerm -> A))
    evalB Le (opL x1 x2) = ((op Le) (evalB Le x1) (evalB Le x2)) 
    evalB Le eL = (e Le) 
    evalB Le (linvL x1 x2) = ((linv Le) (evalB Le x1) (evalB Le x2)) 
    evalCl : {A : Set} -> ((LeftLoop A) -> ((ClLeftLoopClTerm A) -> A))
    evalCl Le (sing x1) = x1 
    evalCl Le (opCl x1 x2) = ((op Le) (evalCl Le x1) (evalCl Le x2)) 
    evalCl Le eCl = (e Le) 
    evalCl Le (linvCl x1 x2) = ((linv Le) (evalCl Le x1) (evalCl Le x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((LeftLoop A) -> ((Vec A n) -> ((OpLeftLoopOLTerm n) -> A)))
    evalOpB Le vars (v x1) = (lookup _ x1 vars) 
    evalOpB Le vars (opOL x1 x2) = ((op Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOpB Le vars eOL = (e Le) 
    evalOpB Le vars (linvOL x1 x2) = ((linv Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((LeftLoop A) -> ((Vec A n) -> ((OpLeftLoopOL2Term2 n A) -> A)))
    evalOp Le vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Le vars (sing2 x1) = x1 
    evalOp Le vars (opOL2 x1 x2) = ((op Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    evalOp Le vars eOL2 = (e Le) 
    evalOp Le vars (linvOL2 x1 x2) = ((linv Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    inductionB : {P : (LeftLoopLTerm -> Set)} -> (((x1 x2 : LeftLoopLTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((P eL) -> (((x1 x2 : LeftLoopLTerm) -> ((P x1) -> ((P x2) -> (P (linvL x1 x2))))) -> ((x : LeftLoopLTerm) -> (P x)))))
    inductionB {p} popl pel plinvl (opL x1 x2) = (popl _ _ (inductionB {p} popl pel plinvl x1) (inductionB {p} popl pel plinvl x2)) 
    inductionB {p} popl pel plinvl eL = pel 
    inductionB {p} popl pel plinvl (linvL x1 x2) = (plinvl _ _ (inductionB {p} popl pel plinvl x1) (inductionB {p} popl pel plinvl x2)) 
    inductionCl : {A : Set} {P : ((ClLeftLoopClTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClLeftLoopClTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((P eCl) -> (((x1 x2 : (ClLeftLoopClTerm A)) -> ((P x1) -> ((P x2) -> (P (linvCl x1 x2))))) -> ((x : (ClLeftLoopClTerm A)) -> (P x))))))
    inductionCl {_} {p} psing popcl pecl plinvcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl pecl plinvcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl pecl plinvcl x1) (inductionCl {_} {p} psing popcl pecl plinvcl x2)) 
    inductionCl {_} {p} psing popcl pecl plinvcl eCl = pecl 
    inductionCl {_} {p} psing popcl pecl plinvcl (linvCl x1 x2) = (plinvcl _ _ (inductionCl {_} {p} psing popcl pecl plinvcl x1) (inductionCl {_} {p} psing popcl pecl plinvcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLeftLoopOLTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpLeftLoopOLTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((P eOL) -> (((x1 x2 : (OpLeftLoopOLTerm n)) -> ((P x1) -> ((P x2) -> (P (linvOL x1 x2))))) -> ((x : (OpLeftLoopOLTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv popol peol plinvol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol peol plinvol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol peol plinvol x1) (inductionOpB {_} {p} pv popol peol plinvol x2)) 
    inductionOpB {_} {p} pv popol peol plinvol eOL = peol 
    inductionOpB {_} {p} pv popol peol plinvol (linvOL x1 x2) = (plinvol _ _ (inductionOpB {_} {p} pv popol peol plinvol x1) (inductionOpB {_} {p} pv popol peol plinvol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLeftLoopOL2Term2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpLeftLoopOL2Term2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((P eOL2) -> (((x1 x2 : (OpLeftLoopOL2Term2 n A)) -> ((P x1) -> ((P x2) -> (P (linvOL2 x1 x2))))) -> ((x : (OpLeftLoopOL2Term2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 eOL2 = peol2 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 (linvOL2 x1 x2) = (plinvol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 x2)) 
    opL' : (LeftLoopLTerm -> (LeftLoopLTerm -> LeftLoopLTerm))
    opL' x1 x2 = (opL x1 x2) 
    eL' : LeftLoopLTerm
    eL'  = eL 
    linvL' : (LeftLoopLTerm -> (LeftLoopLTerm -> LeftLoopLTerm))
    linvL' x1 x2 = (linvL x1 x2) 
    stageB : (LeftLoopLTerm -> (Staged LeftLoopLTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB eL = (Now eL) 
    stageB (linvL x1 x2) = (stage2 linvL' (codeLift2 linvL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClLeftLoopClTerm A) -> ((ClLeftLoopClTerm A) -> (ClLeftLoopClTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    eCl' : {A : Set} -> (ClLeftLoopClTerm A)
    eCl'  = eCl 
    linvCl' : {A : Set} -> ((ClLeftLoopClTerm A) -> ((ClLeftLoopClTerm A) -> (ClLeftLoopClTerm A)))
    linvCl' x1 x2 = (linvCl x1 x2) 
    stageCl : {A : Set} -> ((ClLeftLoopClTerm A) -> (Staged (ClLeftLoopClTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl eCl = (Now eCl) 
    stageCl (linvCl x1 x2) = (stage2 linvCl' (codeLift2 linvCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpLeftLoopOLTerm n) -> ((OpLeftLoopOLTerm n) -> (OpLeftLoopOLTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    eOL' : {n : Nat} -> (OpLeftLoopOLTerm n)
    eOL'  = eOL 
    linvOL' : {n : Nat} -> ((OpLeftLoopOLTerm n) -> ((OpLeftLoopOLTerm n) -> (OpLeftLoopOLTerm n)))
    linvOL' x1 x2 = (linvOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLeftLoopOLTerm n) -> (Staged (OpLeftLoopOLTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB eOL = (Now eOL) 
    stageOpB (linvOL x1 x2) = (stage2 linvOL' (codeLift2 linvOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpLeftLoopOL2Term2 n A) -> ((OpLeftLoopOL2Term2 n A) -> (OpLeftLoopOL2Term2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    eOL2' : {n : Nat} {A : Set} -> (OpLeftLoopOL2Term2 n A)
    eOL2'  = eOL2 
    linvOL2' : {n : Nat} {A : Set} -> ((OpLeftLoopOL2Term2 n A) -> ((OpLeftLoopOL2Term2 n A) -> (OpLeftLoopOL2Term2 n A)))
    linvOL2' x1 x2 = (linvOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLeftLoopOL2Term2 n A) -> (Staged (OpLeftLoopOL2Term2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp eOL2 = (Now eOL2) 
    stageOp (linvOL2 x1 x2) = (stage2 linvOL2' (codeLift2 linvOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        eT : (Repr A)
        linvT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module LeftMonoid  where
    record LeftMonoid (A : Set) : Set where
      constructor LeftMonoidC
      field
        op : (A -> (A -> A))
        e : A
        lunit_e : {x : A} -> (op e x) == x
        associative_op : {x y z : A} -> (op (op x y) z) == (op x (op y z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        eS : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        eP : (Prod A A)
        lunit_eP : {xP : (Prod A A)} -> (opP eP xP) == xP
        associative_opP : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP (opP yP zP))
    record Hom {A1 : Set} {A2 : Set} (Le1 : (LeftMonoid A1)) (Le2 : (LeftMonoid A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Le1) x1 x2)) == ((op Le2) (hom x1) (hom x2))
        pres-e : (hom (e Le1)) == (e Le2)
    record RelInterp {A1 : Set} {A2 : Set} (Le1 : (LeftMonoid A1)) (Le2 : (LeftMonoid A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Le1) x1 x2) ((op Le2) y1 y2))))
        interp-e : (interp (e Le1) (e Le2))
    data LeftMonoidTerm  : Set where
      opL : (LeftMonoidTerm -> (LeftMonoidTerm -> LeftMonoidTerm))
      eL : LeftMonoidTerm
    data ClLeftMonoidTerm (A : Set) : Set where
      sing : (A -> (ClLeftMonoidTerm A))
      opCl : ((ClLeftMonoidTerm A) -> ((ClLeftMonoidTerm A) -> (ClLeftMonoidTerm A)))
      eCl : (ClLeftMonoidTerm A)
    data OpLeftMonoidTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLeftMonoidTerm n))
      opOL : ((OpLeftMonoidTerm n) -> ((OpLeftMonoidTerm n) -> (OpLeftMonoidTerm n)))
      eOL : (OpLeftMonoidTerm n)
    data OpLeftMonoidTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLeftMonoidTerm2 n A))
      sing2 : (A -> (OpLeftMonoidTerm2 n A))
      opOL2 : ((OpLeftMonoidTerm2 n A) -> ((OpLeftMonoidTerm2 n A) -> (OpLeftMonoidTerm2 n A)))
      eOL2 : (OpLeftMonoidTerm2 n A)
    simplifyCl : {A : Set} -> ((ClLeftMonoidTerm A) -> (ClLeftMonoidTerm A))
    simplifyCl (opCl eCl x) = x 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl eCl = eCl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLeftMonoidTerm n) -> (OpLeftMonoidTerm n))
    simplifyOpB (opOL eOL x) = x 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB eOL = eOL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLeftMonoidTerm2 n A) -> (OpLeftMonoidTerm2 n A))
    simplifyOp (opOL2 eOL2 x) = x 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp eOL2 = eOL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((LeftMonoid A) -> (LeftMonoidTerm -> A))
    evalB Le (opL x1 x2) = ((op Le) (evalB Le x1) (evalB Le x2)) 
    evalB Le eL = (e Le) 
    evalCl : {A : Set} -> ((LeftMonoid A) -> ((ClLeftMonoidTerm A) -> A))
    evalCl Le (sing x1) = x1 
    evalCl Le (opCl x1 x2) = ((op Le) (evalCl Le x1) (evalCl Le x2)) 
    evalCl Le eCl = (e Le) 
    evalOpB : {A : Set} {n : Nat} -> ((LeftMonoid A) -> ((Vec A n) -> ((OpLeftMonoidTerm n) -> A)))
    evalOpB Le vars (v x1) = (lookup _ x1 vars) 
    evalOpB Le vars (opOL x1 x2) = ((op Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOpB Le vars eOL = (e Le) 
    evalOp : {A : Set} {n : Nat} -> ((LeftMonoid A) -> ((Vec A n) -> ((OpLeftMonoidTerm2 n A) -> A)))
    evalOp Le vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Le vars (sing2 x1) = x1 
    evalOp Le vars (opOL2 x1 x2) = ((op Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    evalOp Le vars eOL2 = (e Le) 
    inductionB : {P : (LeftMonoidTerm -> Set)} -> (((x1 x2 : LeftMonoidTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((P eL) -> ((x : LeftMonoidTerm) -> (P x))))
    inductionB {p} popl pel (opL x1 x2) = (popl _ _ (inductionB {p} popl pel x1) (inductionB {p} popl pel x2)) 
    inductionB {p} popl pel eL = pel 
    inductionCl : {A : Set} {P : ((ClLeftMonoidTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClLeftMonoidTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((P eCl) -> ((x : (ClLeftMonoidTerm A)) -> (P x)))))
    inductionCl {_} {p} psing popcl pecl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl pecl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl pecl x1) (inductionCl {_} {p} psing popcl pecl x2)) 
    inductionCl {_} {p} psing popcl pecl eCl = pecl 
    inductionOpB : {n : Nat} {P : ((OpLeftMonoidTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpLeftMonoidTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((P eOL) -> ((x : (OpLeftMonoidTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv popol peol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol peol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol peol x1) (inductionOpB {_} {p} pv popol peol x2)) 
    inductionOpB {_} {p} pv popol peol eOL = peol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLeftMonoidTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpLeftMonoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((P eOL2) -> ((x : (OpLeftMonoidTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 eOL2 = peol2 
    opL' : (LeftMonoidTerm -> (LeftMonoidTerm -> LeftMonoidTerm))
    opL' x1 x2 = (opL x1 x2) 
    eL' : LeftMonoidTerm
    eL'  = eL 
    stageB : (LeftMonoidTerm -> (Staged LeftMonoidTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB eL = (Now eL) 
    opCl' : {A : Set} -> ((ClLeftMonoidTerm A) -> ((ClLeftMonoidTerm A) -> (ClLeftMonoidTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    eCl' : {A : Set} -> (ClLeftMonoidTerm A)
    eCl'  = eCl 
    stageCl : {A : Set} -> ((ClLeftMonoidTerm A) -> (Staged (ClLeftMonoidTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl eCl = (Now eCl) 
    opOL' : {n : Nat} -> ((OpLeftMonoidTerm n) -> ((OpLeftMonoidTerm n) -> (OpLeftMonoidTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    eOL' : {n : Nat} -> (OpLeftMonoidTerm n)
    eOL'  = eOL 
    stageOpB : {n : Nat} -> ((OpLeftMonoidTerm n) -> (Staged (OpLeftMonoidTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB eOL = (Now eOL) 
    opOL2' : {n : Nat} {A : Set} -> ((OpLeftMonoidTerm2 n A) -> ((OpLeftMonoidTerm2 n A) -> (OpLeftMonoidTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    eOL2' : {n : Nat} {A : Set} -> (OpLeftMonoidTerm2 n A)
    eOL2'  = eOL2 
    stageOp : {n : Nat} {A : Set} -> ((OpLeftMonoidTerm2 n A) -> (Staged (OpLeftMonoidTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp eOL2 = (Now eOL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        eT : (Repr A)
  module LeftPreSemiring  where
    record LeftPreSemiring (A : Set) : Set where
      constructor LeftPreSemiringC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        leftDistributive_*_+ : {x y z : A} -> (* x (+ y z)) == (+ (* x y) (* x z))
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        leftDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P xP (+P yP zP)) == (+P (*P xP yP) (*P xP zP))
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
    record Hom {A1 : Set} {A2 : Set} (Le1 : (LeftPreSemiring A1)) (Le2 : (LeftPreSemiring A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Le1) x1 x2)) == ((* Le2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Le1) x1 x2)) == ((+ Le2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Le1 : (LeftPreSemiring A1)) (Le2 : (LeftPreSemiring A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Le1) x1 x2) ((* Le2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Le1) x1 x2) ((+ Le2) y1 y2))))
    data LeftPreSemiringTerm  : Set where
      *L : (LeftPreSemiringTerm -> (LeftPreSemiringTerm -> LeftPreSemiringTerm))
      +L : (LeftPreSemiringTerm -> (LeftPreSemiringTerm -> LeftPreSemiringTerm))
    data ClLeftPreSemiringTerm (A : Set) : Set where
      sing : (A -> (ClLeftPreSemiringTerm A))
      *Cl : ((ClLeftPreSemiringTerm A) -> ((ClLeftPreSemiringTerm A) -> (ClLeftPreSemiringTerm A)))
      +Cl : ((ClLeftPreSemiringTerm A) -> ((ClLeftPreSemiringTerm A) -> (ClLeftPreSemiringTerm A)))
    data OpLeftPreSemiringTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLeftPreSemiringTerm n))
      *OL : ((OpLeftPreSemiringTerm n) -> ((OpLeftPreSemiringTerm n) -> (OpLeftPreSemiringTerm n)))
      +OL : ((OpLeftPreSemiringTerm n) -> ((OpLeftPreSemiringTerm n) -> (OpLeftPreSemiringTerm n)))
    data OpLeftPreSemiringTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLeftPreSemiringTerm2 n A))
      sing2 : (A -> (OpLeftPreSemiringTerm2 n A))
      *OL2 : ((OpLeftPreSemiringTerm2 n A) -> ((OpLeftPreSemiringTerm2 n A) -> (OpLeftPreSemiringTerm2 n A)))
      +OL2 : ((OpLeftPreSemiringTerm2 n A) -> ((OpLeftPreSemiringTerm2 n A) -> (OpLeftPreSemiringTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClLeftPreSemiringTerm A) -> (ClLeftPreSemiringTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLeftPreSemiringTerm n) -> (OpLeftPreSemiringTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLeftPreSemiringTerm2 n A) -> (OpLeftPreSemiringTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((LeftPreSemiring A) -> (LeftPreSemiringTerm -> A))
    evalB Le (*L x1 x2) = ((* Le) (evalB Le x1) (evalB Le x2)) 
    evalB Le (+L x1 x2) = ((+ Le) (evalB Le x1) (evalB Le x2)) 
    evalCl : {A : Set} -> ((LeftPreSemiring A) -> ((ClLeftPreSemiringTerm A) -> A))
    evalCl Le (sing x1) = x1 
    evalCl Le (*Cl x1 x2) = ((* Le) (evalCl Le x1) (evalCl Le x2)) 
    evalCl Le (+Cl x1 x2) = ((+ Le) (evalCl Le x1) (evalCl Le x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((LeftPreSemiring A) -> ((Vec A n) -> ((OpLeftPreSemiringTerm n) -> A)))
    evalOpB Le vars (v x1) = (lookup _ x1 vars) 
    evalOpB Le vars (*OL x1 x2) = ((* Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOpB Le vars (+OL x1 x2) = ((+ Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((LeftPreSemiring A) -> ((Vec A n) -> ((OpLeftPreSemiringTerm2 n A) -> A)))
    evalOp Le vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Le vars (sing2 x1) = x1 
    evalOp Le vars (*OL2 x1 x2) = ((* Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    evalOp Le vars (+OL2 x1 x2) = ((+ Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    inductionB : {P : (LeftPreSemiringTerm -> Set)} -> (((x1 x2 : LeftPreSemiringTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : LeftPreSemiringTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : LeftPreSemiringTerm) -> (P x))))
    inductionB {p} p*l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionB {p} p*l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClLeftPreSemiringTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClLeftPreSemiringTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClLeftPreSemiringTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClLeftPreSemiringTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p*cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLeftPreSemiringTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpLeftPreSemiringTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpLeftPreSemiringTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpLeftPreSemiringTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p*ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLeftPreSemiringTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpLeftPreSemiringTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpLeftPreSemiringTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpLeftPreSemiringTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    *L' : (LeftPreSemiringTerm -> (LeftPreSemiringTerm -> LeftPreSemiringTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (LeftPreSemiringTerm -> (LeftPreSemiringTerm -> LeftPreSemiringTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (LeftPreSemiringTerm -> (Staged LeftPreSemiringTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClLeftPreSemiringTerm A) -> ((ClLeftPreSemiringTerm A) -> (ClLeftPreSemiringTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClLeftPreSemiringTerm A) -> ((ClLeftPreSemiringTerm A) -> (ClLeftPreSemiringTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClLeftPreSemiringTerm A) -> (Staged (ClLeftPreSemiringTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpLeftPreSemiringTerm n) -> ((OpLeftPreSemiringTerm n) -> (OpLeftPreSemiringTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpLeftPreSemiringTerm n) -> ((OpLeftPreSemiringTerm n) -> (OpLeftPreSemiringTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLeftPreSemiringTerm n) -> (Staged (OpLeftPreSemiringTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpLeftPreSemiringTerm2 n A) -> ((OpLeftPreSemiringTerm2 n A) -> (OpLeftPreSemiringTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpLeftPreSemiringTerm2 n A) -> ((OpLeftPreSemiringTerm2 n A) -> (OpLeftPreSemiringTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLeftPreSemiringTerm2 n A) -> (Staged (OpLeftPreSemiringTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module LeftQuasiGroup  where
    record LeftQuasiGroup (A : Set) : Set where
      constructor LeftQuasiGroupC
      field
        op : (A -> (A -> A))
        linv : (A -> (A -> A))
        leftCancel : {x y : A} -> (op x (linv x y)) == y
        lefCancelOp : {x y : A} -> (linv x (op x y)) == y
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        linvS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        linvP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftCancelP : {xP yP : (Prod A A)} -> (opP xP (linvP xP yP)) == yP
        lefCancelOpP : {xP yP : (Prod A A)} -> (linvP xP (opP xP yP)) == yP
    record Hom {A1 : Set} {A2 : Set} (Le1 : (LeftQuasiGroup A1)) (Le2 : (LeftQuasiGroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Le1) x1 x2)) == ((op Le2) (hom x1) (hom x2))
        pres-linv : {x1 x2 : A1} -> (hom ((linv Le1) x1 x2)) == ((linv Le2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Le1 : (LeftQuasiGroup A1)) (Le2 : (LeftQuasiGroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Le1) x1 x2) ((op Le2) y1 y2))))
        interp-linv : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((linv Le1) x1 x2) ((linv Le2) y1 y2))))
    data LeftQuasiGroupTerm  : Set where
      opL : (LeftQuasiGroupTerm -> (LeftQuasiGroupTerm -> LeftQuasiGroupTerm))
      linvL : (LeftQuasiGroupTerm -> (LeftQuasiGroupTerm -> LeftQuasiGroupTerm))
    data ClLeftQuasiGroupTerm (A : Set) : Set where
      sing : (A -> (ClLeftQuasiGroupTerm A))
      opCl : ((ClLeftQuasiGroupTerm A) -> ((ClLeftQuasiGroupTerm A) -> (ClLeftQuasiGroupTerm A)))
      linvCl : ((ClLeftQuasiGroupTerm A) -> ((ClLeftQuasiGroupTerm A) -> (ClLeftQuasiGroupTerm A)))
    data OpLeftQuasiGroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLeftQuasiGroupTerm n))
      opOL : ((OpLeftQuasiGroupTerm n) -> ((OpLeftQuasiGroupTerm n) -> (OpLeftQuasiGroupTerm n)))
      linvOL : ((OpLeftQuasiGroupTerm n) -> ((OpLeftQuasiGroupTerm n) -> (OpLeftQuasiGroupTerm n)))
    data OpLeftQuasiGroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLeftQuasiGroupTerm2 n A))
      sing2 : (A -> (OpLeftQuasiGroupTerm2 n A))
      opOL2 : ((OpLeftQuasiGroupTerm2 n A) -> ((OpLeftQuasiGroupTerm2 n A) -> (OpLeftQuasiGroupTerm2 n A)))
      linvOL2 : ((OpLeftQuasiGroupTerm2 n A) -> ((OpLeftQuasiGroupTerm2 n A) -> (OpLeftQuasiGroupTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClLeftQuasiGroupTerm A) -> (ClLeftQuasiGroupTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (linvCl x1 x2) = (linvCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLeftQuasiGroupTerm n) -> (OpLeftQuasiGroupTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (linvOL x1 x2) = (linvOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLeftQuasiGroupTerm2 n A) -> (OpLeftQuasiGroupTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (linvOL2 x1 x2) = (linvOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((LeftQuasiGroup A) -> (LeftQuasiGroupTerm -> A))
    evalB Le (opL x1 x2) = ((op Le) (evalB Le x1) (evalB Le x2)) 
    evalB Le (linvL x1 x2) = ((linv Le) (evalB Le x1) (evalB Le x2)) 
    evalCl : {A : Set} -> ((LeftQuasiGroup A) -> ((ClLeftQuasiGroupTerm A) -> A))
    evalCl Le (sing x1) = x1 
    evalCl Le (opCl x1 x2) = ((op Le) (evalCl Le x1) (evalCl Le x2)) 
    evalCl Le (linvCl x1 x2) = ((linv Le) (evalCl Le x1) (evalCl Le x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((LeftQuasiGroup A) -> ((Vec A n) -> ((OpLeftQuasiGroupTerm n) -> A)))
    evalOpB Le vars (v x1) = (lookup _ x1 vars) 
    evalOpB Le vars (opOL x1 x2) = ((op Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOpB Le vars (linvOL x1 x2) = ((linv Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((LeftQuasiGroup A) -> ((Vec A n) -> ((OpLeftQuasiGroupTerm2 n A) -> A)))
    evalOp Le vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Le vars (sing2 x1) = x1 
    evalOp Le vars (opOL2 x1 x2) = ((op Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    evalOp Le vars (linvOL2 x1 x2) = ((linv Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    inductionB : {P : (LeftQuasiGroupTerm -> Set)} -> (((x1 x2 : LeftQuasiGroupTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> (((x1 x2 : LeftQuasiGroupTerm) -> ((P x1) -> ((P x2) -> (P (linvL x1 x2))))) -> ((x : LeftQuasiGroupTerm) -> (P x))))
    inductionB {p} popl plinvl (opL x1 x2) = (popl _ _ (inductionB {p} popl plinvl x1) (inductionB {p} popl plinvl x2)) 
    inductionB {p} popl plinvl (linvL x1 x2) = (plinvl _ _ (inductionB {p} popl plinvl x1) (inductionB {p} popl plinvl x2)) 
    inductionCl : {A : Set} {P : ((ClLeftQuasiGroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClLeftQuasiGroupTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> (((x1 x2 : (ClLeftQuasiGroupTerm A)) -> ((P x1) -> ((P x2) -> (P (linvCl x1 x2))))) -> ((x : (ClLeftQuasiGroupTerm A)) -> (P x)))))
    inductionCl {_} {p} psing popcl plinvcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl plinvcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl plinvcl x1) (inductionCl {_} {p} psing popcl plinvcl x2)) 
    inductionCl {_} {p} psing popcl plinvcl (linvCl x1 x2) = (plinvcl _ _ (inductionCl {_} {p} psing popcl plinvcl x1) (inductionCl {_} {p} psing popcl plinvcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLeftQuasiGroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpLeftQuasiGroupTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> (((x1 x2 : (OpLeftQuasiGroupTerm n)) -> ((P x1) -> ((P x2) -> (P (linvOL x1 x2))))) -> ((x : (OpLeftQuasiGroupTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv popol plinvol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol plinvol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol plinvol x1) (inductionOpB {_} {p} pv popol plinvol x2)) 
    inductionOpB {_} {p} pv popol plinvol (linvOL x1 x2) = (plinvol _ _ (inductionOpB {_} {p} pv popol plinvol x1) (inductionOpB {_} {p} pv popol plinvol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLeftQuasiGroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpLeftQuasiGroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> (((x1 x2 : (OpLeftQuasiGroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (linvOL2 x1 x2))))) -> ((x : (OpLeftQuasiGroupTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 (linvOL2 x1 x2) = (plinvol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 x2)) 
    opL' : (LeftQuasiGroupTerm -> (LeftQuasiGroupTerm -> LeftQuasiGroupTerm))
    opL' x1 x2 = (opL x1 x2) 
    linvL' : (LeftQuasiGroupTerm -> (LeftQuasiGroupTerm -> LeftQuasiGroupTerm))
    linvL' x1 x2 = (linvL x1 x2) 
    stageB : (LeftQuasiGroupTerm -> (Staged LeftQuasiGroupTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB (linvL x1 x2) = (stage2 linvL' (codeLift2 linvL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClLeftQuasiGroupTerm A) -> ((ClLeftQuasiGroupTerm A) -> (ClLeftQuasiGroupTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    linvCl' : {A : Set} -> ((ClLeftQuasiGroupTerm A) -> ((ClLeftQuasiGroupTerm A) -> (ClLeftQuasiGroupTerm A)))
    linvCl' x1 x2 = (linvCl x1 x2) 
    stageCl : {A : Set} -> ((ClLeftQuasiGroupTerm A) -> (Staged (ClLeftQuasiGroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl (linvCl x1 x2) = (stage2 linvCl' (codeLift2 linvCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpLeftQuasiGroupTerm n) -> ((OpLeftQuasiGroupTerm n) -> (OpLeftQuasiGroupTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    linvOL' : {n : Nat} -> ((OpLeftQuasiGroupTerm n) -> ((OpLeftQuasiGroupTerm n) -> (OpLeftQuasiGroupTerm n)))
    linvOL' x1 x2 = (linvOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLeftQuasiGroupTerm n) -> (Staged (OpLeftQuasiGroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (linvOL x1 x2) = (stage2 linvOL' (codeLift2 linvOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpLeftQuasiGroupTerm2 n A) -> ((OpLeftQuasiGroupTerm2 n A) -> (OpLeftQuasiGroupTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    linvOL2' : {n : Nat} {A : Set} -> ((OpLeftQuasiGroupTerm2 n A) -> ((OpLeftQuasiGroupTerm2 n A) -> (OpLeftQuasiGroupTerm2 n A)))
    linvOL2' x1 x2 = (linvOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLeftQuasiGroupTerm2 n A) -> (Staged (OpLeftQuasiGroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp (linvOL2 x1 x2) = (stage2 linvOL2' (codeLift2 linvOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        linvT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module LeftRack  where
    record LeftRack (A : Set) : Set where
      constructor LeftRackC
      field
        |> : (A -> (A -> A))
        <| : (A -> (A -> A))
        leftDistributive : {x y z : A} -> (|> x (|> y z)) == (|> (|> x y) (|> x z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        |>S : (AS -> (AS -> AS))
        <|S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        |>P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        <|P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftDistributiveP : {xP yP zP : (Prod A A)} -> (|>P xP (|>P yP zP)) == (|>P (|>P xP yP) (|>P xP zP))
    record Hom {A1 : Set} {A2 : Set} (Le1 : (LeftRack A1)) (Le2 : (LeftRack A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-|> : {x1 x2 : A1} -> (hom ((|> Le1) x1 x2)) == ((|> Le2) (hom x1) (hom x2))
        pres-<| : {x1 x2 : A1} -> (hom ((<| Le1) x1 x2)) == ((<| Le2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Le1 : (LeftRack A1)) (Le2 : (LeftRack A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-|> : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((|> Le1) x1 x2) ((|> Le2) y1 y2))))
        interp-<| : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((<| Le1) x1 x2) ((<| Le2) y1 y2))))
    data LeftRackTerm  : Set where
      |>L : (LeftRackTerm -> (LeftRackTerm -> LeftRackTerm))
      <|L : (LeftRackTerm -> (LeftRackTerm -> LeftRackTerm))
    data ClLeftRackTerm (A : Set) : Set where
      sing : (A -> (ClLeftRackTerm A))
      |>Cl : ((ClLeftRackTerm A) -> ((ClLeftRackTerm A) -> (ClLeftRackTerm A)))
      <|Cl : ((ClLeftRackTerm A) -> ((ClLeftRackTerm A) -> (ClLeftRackTerm A)))
    data OpLeftRackTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLeftRackTerm n))
      |>OL : ((OpLeftRackTerm n) -> ((OpLeftRackTerm n) -> (OpLeftRackTerm n)))
      <|OL : ((OpLeftRackTerm n) -> ((OpLeftRackTerm n) -> (OpLeftRackTerm n)))
    data OpLeftRackTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLeftRackTerm2 n A))
      sing2 : (A -> (OpLeftRackTerm2 n A))
      |>OL2 : ((OpLeftRackTerm2 n A) -> ((OpLeftRackTerm2 n A) -> (OpLeftRackTerm2 n A)))
      <|OL2 : ((OpLeftRackTerm2 n A) -> ((OpLeftRackTerm2 n A) -> (OpLeftRackTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClLeftRackTerm A) -> (ClLeftRackTerm A))
    simplifyCl (|>Cl x1 x2) = (|>Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (<|Cl x1 x2) = (<|Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLeftRackTerm n) -> (OpLeftRackTerm n))
    simplifyOpB (|>OL x1 x2) = (|>OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (<|OL x1 x2) = (<|OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLeftRackTerm2 n A) -> (OpLeftRackTerm2 n A))
    simplifyOp (|>OL2 x1 x2) = (|>OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (<|OL2 x1 x2) = (<|OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((LeftRack A) -> (LeftRackTerm -> A))
    evalB Le (|>L x1 x2) = ((|> Le) (evalB Le x1) (evalB Le x2)) 
    evalB Le (<|L x1 x2) = ((<| Le) (evalB Le x1) (evalB Le x2)) 
    evalCl : {A : Set} -> ((LeftRack A) -> ((ClLeftRackTerm A) -> A))
    evalCl Le (sing x1) = x1 
    evalCl Le (|>Cl x1 x2) = ((|> Le) (evalCl Le x1) (evalCl Le x2)) 
    evalCl Le (<|Cl x1 x2) = ((<| Le) (evalCl Le x1) (evalCl Le x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((LeftRack A) -> ((Vec A n) -> ((OpLeftRackTerm n) -> A)))
    evalOpB Le vars (v x1) = (lookup _ x1 vars) 
    evalOpB Le vars (|>OL x1 x2) = ((|> Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOpB Le vars (<|OL x1 x2) = ((<| Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((LeftRack A) -> ((Vec A n) -> ((OpLeftRackTerm2 n A) -> A)))
    evalOp Le vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Le vars (sing2 x1) = x1 
    evalOp Le vars (|>OL2 x1 x2) = ((|> Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    evalOp Le vars (<|OL2 x1 x2) = ((<| Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    inductionB : {P : (LeftRackTerm -> Set)} -> (((x1 x2 : LeftRackTerm) -> ((P x1) -> ((P x2) -> (P (|>L x1 x2))))) -> (((x1 x2 : LeftRackTerm) -> ((P x1) -> ((P x2) -> (P (<|L x1 x2))))) -> ((x : LeftRackTerm) -> (P x))))
    inductionB {p} p|>l p<|l (|>L x1 x2) = (p|>l _ _ (inductionB {p} p|>l p<|l x1) (inductionB {p} p|>l p<|l x2)) 
    inductionB {p} p|>l p<|l (<|L x1 x2) = (p<|l _ _ (inductionB {p} p|>l p<|l x1) (inductionB {p} p|>l p<|l x2)) 
    inductionCl : {A : Set} {P : ((ClLeftRackTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClLeftRackTerm A)) -> ((P x1) -> ((P x2) -> (P (|>Cl x1 x2))))) -> (((x1 x2 : (ClLeftRackTerm A)) -> ((P x1) -> ((P x2) -> (P (<|Cl x1 x2))))) -> ((x : (ClLeftRackTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p|>cl p<|cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p|>cl p<|cl (|>Cl x1 x2) = (p|>cl _ _ (inductionCl {_} {p} psing p|>cl p<|cl x1) (inductionCl {_} {p} psing p|>cl p<|cl x2)) 
    inductionCl {_} {p} psing p|>cl p<|cl (<|Cl x1 x2) = (p<|cl _ _ (inductionCl {_} {p} psing p|>cl p<|cl x1) (inductionCl {_} {p} psing p|>cl p<|cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLeftRackTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpLeftRackTerm n)) -> ((P x1) -> ((P x2) -> (P (|>OL x1 x2))))) -> (((x1 x2 : (OpLeftRackTerm n)) -> ((P x1) -> ((P x2) -> (P (<|OL x1 x2))))) -> ((x : (OpLeftRackTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p|>ol p<|ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p|>ol p<|ol (|>OL x1 x2) = (p|>ol _ _ (inductionOpB {_} {p} pv p|>ol p<|ol x1) (inductionOpB {_} {p} pv p|>ol p<|ol x2)) 
    inductionOpB {_} {p} pv p|>ol p<|ol (<|OL x1 x2) = (p<|ol _ _ (inductionOpB {_} {p} pv p|>ol p<|ol x1) (inductionOpB {_} {p} pv p|>ol p<|ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLeftRackTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpLeftRackTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (|>OL2 x1 x2))))) -> (((x1 x2 : (OpLeftRackTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (<|OL2 x1 x2))))) -> ((x : (OpLeftRackTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (|>OL2 x1 x2) = (p|>ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (<|OL2 x1 x2) = (p<|ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x2)) 
    |>L' : (LeftRackTerm -> (LeftRackTerm -> LeftRackTerm))
    |>L' x1 x2 = (|>L x1 x2) 
    <|L' : (LeftRackTerm -> (LeftRackTerm -> LeftRackTerm))
    <|L' x1 x2 = (<|L x1 x2) 
    stageB : (LeftRackTerm -> (Staged LeftRackTerm))
    stageB (|>L x1 x2) = (stage2 |>L' (codeLift2 |>L') (stageB x1) (stageB x2)) 
    stageB (<|L x1 x2) = (stage2 <|L' (codeLift2 <|L') (stageB x1) (stageB x2)) 
    |>Cl' : {A : Set} -> ((ClLeftRackTerm A) -> ((ClLeftRackTerm A) -> (ClLeftRackTerm A)))
    |>Cl' x1 x2 = (|>Cl x1 x2) 
    <|Cl' : {A : Set} -> ((ClLeftRackTerm A) -> ((ClLeftRackTerm A) -> (ClLeftRackTerm A)))
    <|Cl' x1 x2 = (<|Cl x1 x2) 
    stageCl : {A : Set} -> ((ClLeftRackTerm A) -> (Staged (ClLeftRackTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (|>Cl x1 x2) = (stage2 |>Cl' (codeLift2 |>Cl') (stageCl x1) (stageCl x2)) 
    stageCl (<|Cl x1 x2) = (stage2 <|Cl' (codeLift2 <|Cl') (stageCl x1) (stageCl x2)) 
    |>OL' : {n : Nat} -> ((OpLeftRackTerm n) -> ((OpLeftRackTerm n) -> (OpLeftRackTerm n)))
    |>OL' x1 x2 = (|>OL x1 x2) 
    <|OL' : {n : Nat} -> ((OpLeftRackTerm n) -> ((OpLeftRackTerm n) -> (OpLeftRackTerm n)))
    <|OL' x1 x2 = (<|OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLeftRackTerm n) -> (Staged (OpLeftRackTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (|>OL x1 x2) = (stage2 |>OL' (codeLift2 |>OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (<|OL x1 x2) = (stage2 <|OL' (codeLift2 <|OL') (stageOpB x1) (stageOpB x2)) 
    |>OL2' : {n : Nat} {A : Set} -> ((OpLeftRackTerm2 n A) -> ((OpLeftRackTerm2 n A) -> (OpLeftRackTerm2 n A)))
    |>OL2' x1 x2 = (|>OL2 x1 x2) 
    <|OL2' : {n : Nat} {A : Set} -> ((OpLeftRackTerm2 n A) -> ((OpLeftRackTerm2 n A) -> (OpLeftRackTerm2 n A)))
    <|OL2' x1 x2 = (<|OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLeftRackTerm2 n A) -> (Staged (OpLeftRackTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (|>OL2 x1 x2) = (stage2 |>OL2' (codeLift2 |>OL2') (stageOp x1) (stageOp x2)) 
    stageOp (<|OL2 x1 x2) = (stage2 <|OL2' (codeLift2 <|OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        |>T : ((Repr A) -> ((Repr A) -> (Repr A)))
        <|T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module LeftRingoid  where
    record LeftRingoid (A : Set) : Set where
      constructor LeftRingoidC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        leftDistributive_*_+ : {x y z : A} -> (* x (+ y z)) == (+ (* x y) (* x z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P xP (+P yP zP)) == (+P (*P xP yP) (*P xP zP))
    record Hom {A1 : Set} {A2 : Set} (Le1 : (LeftRingoid A1)) (Le2 : (LeftRingoid A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Le1) x1 x2)) == ((* Le2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Le1) x1 x2)) == ((+ Le2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Le1 : (LeftRingoid A1)) (Le2 : (LeftRingoid A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Le1) x1 x2) ((* Le2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Le1) x1 x2) ((+ Le2) y1 y2))))
    data LeftRingoidTerm  : Set where
      *L : (LeftRingoidTerm -> (LeftRingoidTerm -> LeftRingoidTerm))
      +L : (LeftRingoidTerm -> (LeftRingoidTerm -> LeftRingoidTerm))
    data ClLeftRingoidTerm (A : Set) : Set where
      sing : (A -> (ClLeftRingoidTerm A))
      *Cl : ((ClLeftRingoidTerm A) -> ((ClLeftRingoidTerm A) -> (ClLeftRingoidTerm A)))
      +Cl : ((ClLeftRingoidTerm A) -> ((ClLeftRingoidTerm A) -> (ClLeftRingoidTerm A)))
    data OpLeftRingoidTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLeftRingoidTerm n))
      *OL : ((OpLeftRingoidTerm n) -> ((OpLeftRingoidTerm n) -> (OpLeftRingoidTerm n)))
      +OL : ((OpLeftRingoidTerm n) -> ((OpLeftRingoidTerm n) -> (OpLeftRingoidTerm n)))
    data OpLeftRingoidTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLeftRingoidTerm2 n A))
      sing2 : (A -> (OpLeftRingoidTerm2 n A))
      *OL2 : ((OpLeftRingoidTerm2 n A) -> ((OpLeftRingoidTerm2 n A) -> (OpLeftRingoidTerm2 n A)))
      +OL2 : ((OpLeftRingoidTerm2 n A) -> ((OpLeftRingoidTerm2 n A) -> (OpLeftRingoidTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClLeftRingoidTerm A) -> (ClLeftRingoidTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLeftRingoidTerm n) -> (OpLeftRingoidTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLeftRingoidTerm2 n A) -> (OpLeftRingoidTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((LeftRingoid A) -> (LeftRingoidTerm -> A))
    evalB Le (*L x1 x2) = ((* Le) (evalB Le x1) (evalB Le x2)) 
    evalB Le (+L x1 x2) = ((+ Le) (evalB Le x1) (evalB Le x2)) 
    evalCl : {A : Set} -> ((LeftRingoid A) -> ((ClLeftRingoidTerm A) -> A))
    evalCl Le (sing x1) = x1 
    evalCl Le (*Cl x1 x2) = ((* Le) (evalCl Le x1) (evalCl Le x2)) 
    evalCl Le (+Cl x1 x2) = ((+ Le) (evalCl Le x1) (evalCl Le x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((LeftRingoid A) -> ((Vec A n) -> ((OpLeftRingoidTerm n) -> A)))
    evalOpB Le vars (v x1) = (lookup _ x1 vars) 
    evalOpB Le vars (*OL x1 x2) = ((* Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOpB Le vars (+OL x1 x2) = ((+ Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((LeftRingoid A) -> ((Vec A n) -> ((OpLeftRingoidTerm2 n A) -> A)))
    evalOp Le vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Le vars (sing2 x1) = x1 
    evalOp Le vars (*OL2 x1 x2) = ((* Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    evalOp Le vars (+OL2 x1 x2) = ((+ Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    inductionB : {P : (LeftRingoidTerm -> Set)} -> (((x1 x2 : LeftRingoidTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : LeftRingoidTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : LeftRingoidTerm) -> (P x))))
    inductionB {p} p*l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionB {p} p*l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClLeftRingoidTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClLeftRingoidTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClLeftRingoidTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClLeftRingoidTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p*cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLeftRingoidTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpLeftRingoidTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpLeftRingoidTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpLeftRingoidTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p*ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLeftRingoidTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpLeftRingoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpLeftRingoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpLeftRingoidTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    *L' : (LeftRingoidTerm -> (LeftRingoidTerm -> LeftRingoidTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (LeftRingoidTerm -> (LeftRingoidTerm -> LeftRingoidTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (LeftRingoidTerm -> (Staged LeftRingoidTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClLeftRingoidTerm A) -> ((ClLeftRingoidTerm A) -> (ClLeftRingoidTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClLeftRingoidTerm A) -> ((ClLeftRingoidTerm A) -> (ClLeftRingoidTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClLeftRingoidTerm A) -> (Staged (ClLeftRingoidTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpLeftRingoidTerm n) -> ((OpLeftRingoidTerm n) -> (OpLeftRingoidTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpLeftRingoidTerm n) -> ((OpLeftRingoidTerm n) -> (OpLeftRingoidTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLeftRingoidTerm n) -> (Staged (OpLeftRingoidTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpLeftRingoidTerm2 n A) -> ((OpLeftRingoidTerm2 n A) -> (OpLeftRingoidTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpLeftRingoidTerm2 n A) -> ((OpLeftRingoidTerm2 n A) -> (OpLeftRingoidTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLeftRingoidTerm2 n A) -> (Staged (OpLeftRingoidTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module LeftShelf  where
    record LeftShelf (A : Set) : Set where
      constructor LeftShelfC
      field
        |> : (A -> (A -> A))
        leftDistributive : {x y z : A} -> (|> x (|> y z)) == (|> (|> x y) (|> x z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        |>S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        |>P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftDistributiveP : {xP yP zP : (Prod A A)} -> (|>P xP (|>P yP zP)) == (|>P (|>P xP yP) (|>P xP zP))
    record Hom {A1 : Set} {A2 : Set} (Le1 : (LeftShelf A1)) (Le2 : (LeftShelf A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-|> : {x1 x2 : A1} -> (hom ((|> Le1) x1 x2)) == ((|> Le2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Le1 : (LeftShelf A1)) (Le2 : (LeftShelf A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-|> : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((|> Le1) x1 x2) ((|> Le2) y1 y2))))
    data LeftShelfTerm  : Set where
      |>L : (LeftShelfTerm -> (LeftShelfTerm -> LeftShelfTerm))
    data ClLeftShelfTerm (A : Set) : Set where
      sing : (A -> (ClLeftShelfTerm A))
      |>Cl : ((ClLeftShelfTerm A) -> ((ClLeftShelfTerm A) -> (ClLeftShelfTerm A)))
    data OpLeftShelfTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLeftShelfTerm n))
      |>OL : ((OpLeftShelfTerm n) -> ((OpLeftShelfTerm n) -> (OpLeftShelfTerm n)))
    data OpLeftShelfTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLeftShelfTerm2 n A))
      sing2 : (A -> (OpLeftShelfTerm2 n A))
      |>OL2 : ((OpLeftShelfTerm2 n A) -> ((OpLeftShelfTerm2 n A) -> (OpLeftShelfTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClLeftShelfTerm A) -> (ClLeftShelfTerm A))
    simplifyCl (|>Cl x1 x2) = (|>Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLeftShelfTerm n) -> (OpLeftShelfTerm n))
    simplifyOpB (|>OL x1 x2) = (|>OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLeftShelfTerm2 n A) -> (OpLeftShelfTerm2 n A))
    simplifyOp (|>OL2 x1 x2) = (|>OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((LeftShelf A) -> (LeftShelfTerm -> A))
    evalB Le (|>L x1 x2) = ((|> Le) (evalB Le x1) (evalB Le x2)) 
    evalCl : {A : Set} -> ((LeftShelf A) -> ((ClLeftShelfTerm A) -> A))
    evalCl Le (sing x1) = x1 
    evalCl Le (|>Cl x1 x2) = ((|> Le) (evalCl Le x1) (evalCl Le x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((LeftShelf A) -> ((Vec A n) -> ((OpLeftShelfTerm n) -> A)))
    evalOpB Le vars (v x1) = (lookup _ x1 vars) 
    evalOpB Le vars (|>OL x1 x2) = ((|> Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((LeftShelf A) -> ((Vec A n) -> ((OpLeftShelfTerm2 n A) -> A)))
    evalOp Le vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Le vars (sing2 x1) = x1 
    evalOp Le vars (|>OL2 x1 x2) = ((|> Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    inductionB : {P : (LeftShelfTerm -> Set)} -> (((x1 x2 : LeftShelfTerm) -> ((P x1) -> ((P x2) -> (P (|>L x1 x2))))) -> ((x : LeftShelfTerm) -> (P x)))
    inductionB {p} p|>l (|>L x1 x2) = (p|>l _ _ (inductionB {p} p|>l x1) (inductionB {p} p|>l x2)) 
    inductionCl : {A : Set} {P : ((ClLeftShelfTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClLeftShelfTerm A)) -> ((P x1) -> ((P x2) -> (P (|>Cl x1 x2))))) -> ((x : (ClLeftShelfTerm A)) -> (P x))))
    inductionCl {_} {p} psing p|>cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p|>cl (|>Cl x1 x2) = (p|>cl _ _ (inductionCl {_} {p} psing p|>cl x1) (inductionCl {_} {p} psing p|>cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLeftShelfTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpLeftShelfTerm n)) -> ((P x1) -> ((P x2) -> (P (|>OL x1 x2))))) -> ((x : (OpLeftShelfTerm n)) -> (P x))))
    inductionOpB {_} {p} pv p|>ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p|>ol (|>OL x1 x2) = (p|>ol _ _ (inductionOpB {_} {p} pv p|>ol x1) (inductionOpB {_} {p} pv p|>ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLeftShelfTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpLeftShelfTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (|>OL2 x1 x2))))) -> ((x : (OpLeftShelfTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 (|>OL2 x1 x2) = (p|>ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 x2)) 
    |>L' : (LeftShelfTerm -> (LeftShelfTerm -> LeftShelfTerm))
    |>L' x1 x2 = (|>L x1 x2) 
    stageB : (LeftShelfTerm -> (Staged LeftShelfTerm))
    stageB (|>L x1 x2) = (stage2 |>L' (codeLift2 |>L') (stageB x1) (stageB x2)) 
    |>Cl' : {A : Set} -> ((ClLeftShelfTerm A) -> ((ClLeftShelfTerm A) -> (ClLeftShelfTerm A)))
    |>Cl' x1 x2 = (|>Cl x1 x2) 
    stageCl : {A : Set} -> ((ClLeftShelfTerm A) -> (Staged (ClLeftShelfTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (|>Cl x1 x2) = (stage2 |>Cl' (codeLift2 |>Cl') (stageCl x1) (stageCl x2)) 
    |>OL' : {n : Nat} -> ((OpLeftShelfTerm n) -> ((OpLeftShelfTerm n) -> (OpLeftShelfTerm n)))
    |>OL' x1 x2 = (|>OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLeftShelfTerm n) -> (Staged (OpLeftShelfTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (|>OL x1 x2) = (stage2 |>OL' (codeLift2 |>OL') (stageOpB x1) (stageOpB x2)) 
    |>OL2' : {n : Nat} {A : Set} -> ((OpLeftShelfTerm2 n A) -> ((OpLeftShelfTerm2 n A) -> (OpLeftShelfTerm2 n A)))
    |>OL2' x1 x2 = (|>OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLeftShelfTerm2 n A) -> (Staged (OpLeftShelfTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (|>OL2 x1 x2) = (stage2 |>OL2' (codeLift2 |>OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        |>T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module LeftShelfSig  where
    record LeftShelfSig (A : Set) : Set where
      constructor LeftShelfSigC
      field
        |> : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        |>S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        |>P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
    record Hom {A1 : Set} {A2 : Set} (Le1 : (LeftShelfSig A1)) (Le2 : (LeftShelfSig A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-|> : {x1 x2 : A1} -> (hom ((|> Le1) x1 x2)) == ((|> Le2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Le1 : (LeftShelfSig A1)) (Le2 : (LeftShelfSig A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-|> : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((|> Le1) x1 x2) ((|> Le2) y1 y2))))
    data LeftShelfSigTerm  : Set where
      |>L : (LeftShelfSigTerm -> (LeftShelfSigTerm -> LeftShelfSigTerm))
    data ClLeftShelfSigTerm (A : Set) : Set where
      sing : (A -> (ClLeftShelfSigTerm A))
      |>Cl : ((ClLeftShelfSigTerm A) -> ((ClLeftShelfSigTerm A) -> (ClLeftShelfSigTerm A)))
    data OpLeftShelfSigTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLeftShelfSigTerm n))
      |>OL : ((OpLeftShelfSigTerm n) -> ((OpLeftShelfSigTerm n) -> (OpLeftShelfSigTerm n)))
    data OpLeftShelfSigTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLeftShelfSigTerm2 n A))
      sing2 : (A -> (OpLeftShelfSigTerm2 n A))
      |>OL2 : ((OpLeftShelfSigTerm2 n A) -> ((OpLeftShelfSigTerm2 n A) -> (OpLeftShelfSigTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClLeftShelfSigTerm A) -> (ClLeftShelfSigTerm A))
    simplifyCl (|>Cl x1 x2) = (|>Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLeftShelfSigTerm n) -> (OpLeftShelfSigTerm n))
    simplifyOpB (|>OL x1 x2) = (|>OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLeftShelfSigTerm2 n A) -> (OpLeftShelfSigTerm2 n A))
    simplifyOp (|>OL2 x1 x2) = (|>OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((LeftShelfSig A) -> (LeftShelfSigTerm -> A))
    evalB Le (|>L x1 x2) = ((|> Le) (evalB Le x1) (evalB Le x2)) 
    evalCl : {A : Set} -> ((LeftShelfSig A) -> ((ClLeftShelfSigTerm A) -> A))
    evalCl Le (sing x1) = x1 
    evalCl Le (|>Cl x1 x2) = ((|> Le) (evalCl Le x1) (evalCl Le x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((LeftShelfSig A) -> ((Vec A n) -> ((OpLeftShelfSigTerm n) -> A)))
    evalOpB Le vars (v x1) = (lookup _ x1 vars) 
    evalOpB Le vars (|>OL x1 x2) = ((|> Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((LeftShelfSig A) -> ((Vec A n) -> ((OpLeftShelfSigTerm2 n A) -> A)))
    evalOp Le vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Le vars (sing2 x1) = x1 
    evalOp Le vars (|>OL2 x1 x2) = ((|> Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    inductionB : {P : (LeftShelfSigTerm -> Set)} -> (((x1 x2 : LeftShelfSigTerm) -> ((P x1) -> ((P x2) -> (P (|>L x1 x2))))) -> ((x : LeftShelfSigTerm) -> (P x)))
    inductionB {p} p|>l (|>L x1 x2) = (p|>l _ _ (inductionB {p} p|>l x1) (inductionB {p} p|>l x2)) 
    inductionCl : {A : Set} {P : ((ClLeftShelfSigTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClLeftShelfSigTerm A)) -> ((P x1) -> ((P x2) -> (P (|>Cl x1 x2))))) -> ((x : (ClLeftShelfSigTerm A)) -> (P x))))
    inductionCl {_} {p} psing p|>cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p|>cl (|>Cl x1 x2) = (p|>cl _ _ (inductionCl {_} {p} psing p|>cl x1) (inductionCl {_} {p} psing p|>cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLeftShelfSigTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpLeftShelfSigTerm n)) -> ((P x1) -> ((P x2) -> (P (|>OL x1 x2))))) -> ((x : (OpLeftShelfSigTerm n)) -> (P x))))
    inductionOpB {_} {p} pv p|>ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p|>ol (|>OL x1 x2) = (p|>ol _ _ (inductionOpB {_} {p} pv p|>ol x1) (inductionOpB {_} {p} pv p|>ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLeftShelfSigTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpLeftShelfSigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (|>OL2 x1 x2))))) -> ((x : (OpLeftShelfSigTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 (|>OL2 x1 x2) = (p|>ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 x2)) 
    |>L' : (LeftShelfSigTerm -> (LeftShelfSigTerm -> LeftShelfSigTerm))
    |>L' x1 x2 = (|>L x1 x2) 
    stageB : (LeftShelfSigTerm -> (Staged LeftShelfSigTerm))
    stageB (|>L x1 x2) = (stage2 |>L' (codeLift2 |>L') (stageB x1) (stageB x2)) 
    |>Cl' : {A : Set} -> ((ClLeftShelfSigTerm A) -> ((ClLeftShelfSigTerm A) -> (ClLeftShelfSigTerm A)))
    |>Cl' x1 x2 = (|>Cl x1 x2) 
    stageCl : {A : Set} -> ((ClLeftShelfSigTerm A) -> (Staged (ClLeftShelfSigTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (|>Cl x1 x2) = (stage2 |>Cl' (codeLift2 |>Cl') (stageCl x1) (stageCl x2)) 
    |>OL' : {n : Nat} -> ((OpLeftShelfSigTerm n) -> ((OpLeftShelfSigTerm n) -> (OpLeftShelfSigTerm n)))
    |>OL' x1 x2 = (|>OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLeftShelfSigTerm n) -> (Staged (OpLeftShelfSigTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (|>OL x1 x2) = (stage2 |>OL' (codeLift2 |>OL') (stageOpB x1) (stageOpB x2)) 
    |>OL2' : {n : Nat} {A : Set} -> ((OpLeftShelfSigTerm2 n A) -> ((OpLeftShelfSigTerm2 n A) -> (OpLeftShelfSigTerm2 n A)))
    |>OL2' x1 x2 = (|>OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLeftShelfSigTerm2 n A) -> (Staged (OpLeftShelfSigTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (|>OL2 x1 x2) = (stage2 |>OL2' (codeLift2 |>OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        |>T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module LeftSpindle  where
    record LeftSpindle (A : Set) : Set where
      constructor LeftSpindleC
      field
        |> : (A -> (A -> A))
        leftDistributive : {x y z : A} -> (|> x (|> y z)) == (|> (|> x y) (|> x z))
        idempotent_|> : {x : A} -> (|> x x) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        |>S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        |>P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftDistributiveP : {xP yP zP : (Prod A A)} -> (|>P xP (|>P yP zP)) == (|>P (|>P xP yP) (|>P xP zP))
        idempotent_|>P : {xP : (Prod A A)} -> (|>P xP xP) == xP
    record Hom {A1 : Set} {A2 : Set} (Le1 : (LeftSpindle A1)) (Le2 : (LeftSpindle A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-|> : {x1 x2 : A1} -> (hom ((|> Le1) x1 x2)) == ((|> Le2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Le1 : (LeftSpindle A1)) (Le2 : (LeftSpindle A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-|> : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((|> Le1) x1 x2) ((|> Le2) y1 y2))))
    data LeftSpindleTerm  : Set where
      |>L : (LeftSpindleTerm -> (LeftSpindleTerm -> LeftSpindleTerm))
    data ClLeftSpindleTerm (A : Set) : Set where
      sing : (A -> (ClLeftSpindleTerm A))
      |>Cl : ((ClLeftSpindleTerm A) -> ((ClLeftSpindleTerm A) -> (ClLeftSpindleTerm A)))
    data OpLeftSpindleTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLeftSpindleTerm n))
      |>OL : ((OpLeftSpindleTerm n) -> ((OpLeftSpindleTerm n) -> (OpLeftSpindleTerm n)))
    data OpLeftSpindleTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLeftSpindleTerm2 n A))
      sing2 : (A -> (OpLeftSpindleTerm2 n A))
      |>OL2 : ((OpLeftSpindleTerm2 n A) -> ((OpLeftSpindleTerm2 n A) -> (OpLeftSpindleTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClLeftSpindleTerm A) -> (ClLeftSpindleTerm A))
    simplifyCl (|>Cl x1 x2) = (|>Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLeftSpindleTerm n) -> (OpLeftSpindleTerm n))
    simplifyOpB (|>OL x1 x2) = (|>OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLeftSpindleTerm2 n A) -> (OpLeftSpindleTerm2 n A))
    simplifyOp (|>OL2 x1 x2) = (|>OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((LeftSpindle A) -> (LeftSpindleTerm -> A))
    evalB Le (|>L x1 x2) = ((|> Le) (evalB Le x1) (evalB Le x2)) 
    evalCl : {A : Set} -> ((LeftSpindle A) -> ((ClLeftSpindleTerm A) -> A))
    evalCl Le (sing x1) = x1 
    evalCl Le (|>Cl x1 x2) = ((|> Le) (evalCl Le x1) (evalCl Le x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((LeftSpindle A) -> ((Vec A n) -> ((OpLeftSpindleTerm n) -> A)))
    evalOpB Le vars (v x1) = (lookup _ x1 vars) 
    evalOpB Le vars (|>OL x1 x2) = ((|> Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((LeftSpindle A) -> ((Vec A n) -> ((OpLeftSpindleTerm2 n A) -> A)))
    evalOp Le vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Le vars (sing2 x1) = x1 
    evalOp Le vars (|>OL2 x1 x2) = ((|> Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    inductionB : {P : (LeftSpindleTerm -> Set)} -> (((x1 x2 : LeftSpindleTerm) -> ((P x1) -> ((P x2) -> (P (|>L x1 x2))))) -> ((x : LeftSpindleTerm) -> (P x)))
    inductionB {p} p|>l (|>L x1 x2) = (p|>l _ _ (inductionB {p} p|>l x1) (inductionB {p} p|>l x2)) 
    inductionCl : {A : Set} {P : ((ClLeftSpindleTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClLeftSpindleTerm A)) -> ((P x1) -> ((P x2) -> (P (|>Cl x1 x2))))) -> ((x : (ClLeftSpindleTerm A)) -> (P x))))
    inductionCl {_} {p} psing p|>cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p|>cl (|>Cl x1 x2) = (p|>cl _ _ (inductionCl {_} {p} psing p|>cl x1) (inductionCl {_} {p} psing p|>cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLeftSpindleTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpLeftSpindleTerm n)) -> ((P x1) -> ((P x2) -> (P (|>OL x1 x2))))) -> ((x : (OpLeftSpindleTerm n)) -> (P x))))
    inductionOpB {_} {p} pv p|>ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p|>ol (|>OL x1 x2) = (p|>ol _ _ (inductionOpB {_} {p} pv p|>ol x1) (inductionOpB {_} {p} pv p|>ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLeftSpindleTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpLeftSpindleTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (|>OL2 x1 x2))))) -> ((x : (OpLeftSpindleTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 (|>OL2 x1 x2) = (p|>ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 x2)) 
    |>L' : (LeftSpindleTerm -> (LeftSpindleTerm -> LeftSpindleTerm))
    |>L' x1 x2 = (|>L x1 x2) 
    stageB : (LeftSpindleTerm -> (Staged LeftSpindleTerm))
    stageB (|>L x1 x2) = (stage2 |>L' (codeLift2 |>L') (stageB x1) (stageB x2)) 
    |>Cl' : {A : Set} -> ((ClLeftSpindleTerm A) -> ((ClLeftSpindleTerm A) -> (ClLeftSpindleTerm A)))
    |>Cl' x1 x2 = (|>Cl x1 x2) 
    stageCl : {A : Set} -> ((ClLeftSpindleTerm A) -> (Staged (ClLeftSpindleTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (|>Cl x1 x2) = (stage2 |>Cl' (codeLift2 |>Cl') (stageCl x1) (stageCl x2)) 
    |>OL' : {n : Nat} -> ((OpLeftSpindleTerm n) -> ((OpLeftSpindleTerm n) -> (OpLeftSpindleTerm n)))
    |>OL' x1 x2 = (|>OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLeftSpindleTerm n) -> (Staged (OpLeftSpindleTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (|>OL x1 x2) = (stage2 |>OL' (codeLift2 |>OL') (stageOpB x1) (stageOpB x2)) 
    |>OL2' : {n : Nat} {A : Set} -> ((OpLeftSpindleTerm2 n A) -> ((OpLeftSpindleTerm2 n A) -> (OpLeftSpindleTerm2 n A)))
    |>OL2' x1 x2 = (|>OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLeftSpindleTerm2 n A) -> (Staged (OpLeftSpindleTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (|>OL2 x1 x2) = (stage2 |>OL2' (codeLift2 |>OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        |>T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module LeftSpindle_Shelf  where
    record LeftSpindle_Shelf (A : Set) : Set where
      constructor LeftSpindle_ShelfC
      field
        |> : (A -> (A -> A))
        leftDistributive : {x y z : A} -> (|> x (|> y z)) == (|> (|> x y) (|> x z))
        idempotent_|> : {x : A} -> (|> x x) == x
        <| : (A -> (A -> A))
        rightDistributive : {x y z : A} -> (<| (<| y z) x) == (<| (<| y x) (<| z x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        |>S : (AS -> (AS -> AS))
        <|S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        |>P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        <|P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftDistributiveP : {xP yP zP : (Prod A A)} -> (|>P xP (|>P yP zP)) == (|>P (|>P xP yP) (|>P xP zP))
        idempotent_|>P : {xP : (Prod A A)} -> (|>P xP xP) == xP
        rightDistributiveP : {xP yP zP : (Prod A A)} -> (<|P (<|P yP zP) xP) == (<|P (<|P yP xP) (<|P zP xP))
    record Hom {A1 : Set} {A2 : Set} (Le1 : (LeftSpindle_Shelf A1)) (Le2 : (LeftSpindle_Shelf A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-|> : {x1 x2 : A1} -> (hom ((|> Le1) x1 x2)) == ((|> Le2) (hom x1) (hom x2))
        pres-<| : {x1 x2 : A1} -> (hom ((<| Le1) x1 x2)) == ((<| Le2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Le1 : (LeftSpindle_Shelf A1)) (Le2 : (LeftSpindle_Shelf A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-|> : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((|> Le1) x1 x2) ((|> Le2) y1 y2))))
        interp-<| : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((<| Le1) x1 x2) ((<| Le2) y1 y2))))
    data LeftSpindle_ShelfTerm  : Set where
      |>L : (LeftSpindle_ShelfTerm -> (LeftSpindle_ShelfTerm -> LeftSpindle_ShelfTerm))
      <|L : (LeftSpindle_ShelfTerm -> (LeftSpindle_ShelfTerm -> LeftSpindle_ShelfTerm))
    data ClLeftSpindle_ShelfTerm (A : Set) : Set where
      sing : (A -> (ClLeftSpindle_ShelfTerm A))
      |>Cl : ((ClLeftSpindle_ShelfTerm A) -> ((ClLeftSpindle_ShelfTerm A) -> (ClLeftSpindle_ShelfTerm A)))
      <|Cl : ((ClLeftSpindle_ShelfTerm A) -> ((ClLeftSpindle_ShelfTerm A) -> (ClLeftSpindle_ShelfTerm A)))
    data OpLeftSpindle_ShelfTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLeftSpindle_ShelfTerm n))
      |>OL : ((OpLeftSpindle_ShelfTerm n) -> ((OpLeftSpindle_ShelfTerm n) -> (OpLeftSpindle_ShelfTerm n)))
      <|OL : ((OpLeftSpindle_ShelfTerm n) -> ((OpLeftSpindle_ShelfTerm n) -> (OpLeftSpindle_ShelfTerm n)))
    data OpLeftSpindle_ShelfTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLeftSpindle_ShelfTerm2 n A))
      sing2 : (A -> (OpLeftSpindle_ShelfTerm2 n A))
      |>OL2 : ((OpLeftSpindle_ShelfTerm2 n A) -> ((OpLeftSpindle_ShelfTerm2 n A) -> (OpLeftSpindle_ShelfTerm2 n A)))
      <|OL2 : ((OpLeftSpindle_ShelfTerm2 n A) -> ((OpLeftSpindle_ShelfTerm2 n A) -> (OpLeftSpindle_ShelfTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClLeftSpindle_ShelfTerm A) -> (ClLeftSpindle_ShelfTerm A))
    simplifyCl (|>Cl x1 x2) = (|>Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (<|Cl x1 x2) = (<|Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLeftSpindle_ShelfTerm n) -> (OpLeftSpindle_ShelfTerm n))
    simplifyOpB (|>OL x1 x2) = (|>OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (<|OL x1 x2) = (<|OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLeftSpindle_ShelfTerm2 n A) -> (OpLeftSpindle_ShelfTerm2 n A))
    simplifyOp (|>OL2 x1 x2) = (|>OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (<|OL2 x1 x2) = (<|OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((LeftSpindle_Shelf A) -> (LeftSpindle_ShelfTerm -> A))
    evalB Le (|>L x1 x2) = ((|> Le) (evalB Le x1) (evalB Le x2)) 
    evalB Le (<|L x1 x2) = ((<| Le) (evalB Le x1) (evalB Le x2)) 
    evalCl : {A : Set} -> ((LeftSpindle_Shelf A) -> ((ClLeftSpindle_ShelfTerm A) -> A))
    evalCl Le (sing x1) = x1 
    evalCl Le (|>Cl x1 x2) = ((|> Le) (evalCl Le x1) (evalCl Le x2)) 
    evalCl Le (<|Cl x1 x2) = ((<| Le) (evalCl Le x1) (evalCl Le x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((LeftSpindle_Shelf A) -> ((Vec A n) -> ((OpLeftSpindle_ShelfTerm n) -> A)))
    evalOpB Le vars (v x1) = (lookup _ x1 vars) 
    evalOpB Le vars (|>OL x1 x2) = ((|> Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOpB Le vars (<|OL x1 x2) = ((<| Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((LeftSpindle_Shelf A) -> ((Vec A n) -> ((OpLeftSpindle_ShelfTerm2 n A) -> A)))
    evalOp Le vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Le vars (sing2 x1) = x1 
    evalOp Le vars (|>OL2 x1 x2) = ((|> Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    evalOp Le vars (<|OL2 x1 x2) = ((<| Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    inductionB : {P : (LeftSpindle_ShelfTerm -> Set)} -> (((x1 x2 : LeftSpindle_ShelfTerm) -> ((P x1) -> ((P x2) -> (P (|>L x1 x2))))) -> (((x1 x2 : LeftSpindle_ShelfTerm) -> ((P x1) -> ((P x2) -> (P (<|L x1 x2))))) -> ((x : LeftSpindle_ShelfTerm) -> (P x))))
    inductionB {p} p|>l p<|l (|>L x1 x2) = (p|>l _ _ (inductionB {p} p|>l p<|l x1) (inductionB {p} p|>l p<|l x2)) 
    inductionB {p} p|>l p<|l (<|L x1 x2) = (p<|l _ _ (inductionB {p} p|>l p<|l x1) (inductionB {p} p|>l p<|l x2)) 
    inductionCl : {A : Set} {P : ((ClLeftSpindle_ShelfTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClLeftSpindle_ShelfTerm A)) -> ((P x1) -> ((P x2) -> (P (|>Cl x1 x2))))) -> (((x1 x2 : (ClLeftSpindle_ShelfTerm A)) -> ((P x1) -> ((P x2) -> (P (<|Cl x1 x2))))) -> ((x : (ClLeftSpindle_ShelfTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p|>cl p<|cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p|>cl p<|cl (|>Cl x1 x2) = (p|>cl _ _ (inductionCl {_} {p} psing p|>cl p<|cl x1) (inductionCl {_} {p} psing p|>cl p<|cl x2)) 
    inductionCl {_} {p} psing p|>cl p<|cl (<|Cl x1 x2) = (p<|cl _ _ (inductionCl {_} {p} psing p|>cl p<|cl x1) (inductionCl {_} {p} psing p|>cl p<|cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLeftSpindle_ShelfTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpLeftSpindle_ShelfTerm n)) -> ((P x1) -> ((P x2) -> (P (|>OL x1 x2))))) -> (((x1 x2 : (OpLeftSpindle_ShelfTerm n)) -> ((P x1) -> ((P x2) -> (P (<|OL x1 x2))))) -> ((x : (OpLeftSpindle_ShelfTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p|>ol p<|ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p|>ol p<|ol (|>OL x1 x2) = (p|>ol _ _ (inductionOpB {_} {p} pv p|>ol p<|ol x1) (inductionOpB {_} {p} pv p|>ol p<|ol x2)) 
    inductionOpB {_} {p} pv p|>ol p<|ol (<|OL x1 x2) = (p<|ol _ _ (inductionOpB {_} {p} pv p|>ol p<|ol x1) (inductionOpB {_} {p} pv p|>ol p<|ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLeftSpindle_ShelfTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpLeftSpindle_ShelfTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (|>OL2 x1 x2))))) -> (((x1 x2 : (OpLeftSpindle_ShelfTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (<|OL2 x1 x2))))) -> ((x : (OpLeftSpindle_ShelfTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (|>OL2 x1 x2) = (p|>ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (<|OL2 x1 x2) = (p<|ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x2)) 
    |>L' : (LeftSpindle_ShelfTerm -> (LeftSpindle_ShelfTerm -> LeftSpindle_ShelfTerm))
    |>L' x1 x2 = (|>L x1 x2) 
    <|L' : (LeftSpindle_ShelfTerm -> (LeftSpindle_ShelfTerm -> LeftSpindle_ShelfTerm))
    <|L' x1 x2 = (<|L x1 x2) 
    stageB : (LeftSpindle_ShelfTerm -> (Staged LeftSpindle_ShelfTerm))
    stageB (|>L x1 x2) = (stage2 |>L' (codeLift2 |>L') (stageB x1) (stageB x2)) 
    stageB (<|L x1 x2) = (stage2 <|L' (codeLift2 <|L') (stageB x1) (stageB x2)) 
    |>Cl' : {A : Set} -> ((ClLeftSpindle_ShelfTerm A) -> ((ClLeftSpindle_ShelfTerm A) -> (ClLeftSpindle_ShelfTerm A)))
    |>Cl' x1 x2 = (|>Cl x1 x2) 
    <|Cl' : {A : Set} -> ((ClLeftSpindle_ShelfTerm A) -> ((ClLeftSpindle_ShelfTerm A) -> (ClLeftSpindle_ShelfTerm A)))
    <|Cl' x1 x2 = (<|Cl x1 x2) 
    stageCl : {A : Set} -> ((ClLeftSpindle_ShelfTerm A) -> (Staged (ClLeftSpindle_ShelfTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (|>Cl x1 x2) = (stage2 |>Cl' (codeLift2 |>Cl') (stageCl x1) (stageCl x2)) 
    stageCl (<|Cl x1 x2) = (stage2 <|Cl' (codeLift2 <|Cl') (stageCl x1) (stageCl x2)) 
    |>OL' : {n : Nat} -> ((OpLeftSpindle_ShelfTerm n) -> ((OpLeftSpindle_ShelfTerm n) -> (OpLeftSpindle_ShelfTerm n)))
    |>OL' x1 x2 = (|>OL x1 x2) 
    <|OL' : {n : Nat} -> ((OpLeftSpindle_ShelfTerm n) -> ((OpLeftSpindle_ShelfTerm n) -> (OpLeftSpindle_ShelfTerm n)))
    <|OL' x1 x2 = (<|OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLeftSpindle_ShelfTerm n) -> (Staged (OpLeftSpindle_ShelfTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (|>OL x1 x2) = (stage2 |>OL' (codeLift2 |>OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (<|OL x1 x2) = (stage2 <|OL' (codeLift2 <|OL') (stageOpB x1) (stageOpB x2)) 
    |>OL2' : {n : Nat} {A : Set} -> ((OpLeftSpindle_ShelfTerm2 n A) -> ((OpLeftSpindle_ShelfTerm2 n A) -> (OpLeftSpindle_ShelfTerm2 n A)))
    |>OL2' x1 x2 = (|>OL2 x1 x2) 
    <|OL2' : {n : Nat} {A : Set} -> ((OpLeftSpindle_ShelfTerm2 n A) -> ((OpLeftSpindle_ShelfTerm2 n A) -> (OpLeftSpindle_ShelfTerm2 n A)))
    <|OL2' x1 x2 = (<|OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLeftSpindle_ShelfTerm2 n A) -> (Staged (OpLeftSpindle_ShelfTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (|>OL2 x1 x2) = (stage2 |>OL2' (codeLift2 |>OL2') (stageOp x1) (stageOp x2)) 
    stageOp (<|OL2 x1 x2) = (stage2 <|OL2' (codeLift2 <|OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        |>T : ((Repr A) -> ((Repr A) -> (Repr A)))
        <|T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module LeftSpindle_ShelfSig  where
    record LeftSpindle_ShelfSig (A : Set) : Set where
      constructor LeftSpindle_ShelfSigC
      field
        |> : (A -> (A -> A))
        leftDistributive : {x y z : A} -> (|> x (|> y z)) == (|> (|> x y) (|> x z))
        idempotent_|> : {x : A} -> (|> x x) == x
        <| : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        |>S : (AS -> (AS -> AS))
        <|S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        |>P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        <|P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftDistributiveP : {xP yP zP : (Prod A A)} -> (|>P xP (|>P yP zP)) == (|>P (|>P xP yP) (|>P xP zP))
        idempotent_|>P : {xP : (Prod A A)} -> (|>P xP xP) == xP
    record Hom {A1 : Set} {A2 : Set} (Le1 : (LeftSpindle_ShelfSig A1)) (Le2 : (LeftSpindle_ShelfSig A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-|> : {x1 x2 : A1} -> (hom ((|> Le1) x1 x2)) == ((|> Le2) (hom x1) (hom x2))
        pres-<| : {x1 x2 : A1} -> (hom ((<| Le1) x1 x2)) == ((<| Le2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Le1 : (LeftSpindle_ShelfSig A1)) (Le2 : (LeftSpindle_ShelfSig A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-|> : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((|> Le1) x1 x2) ((|> Le2) y1 y2))))
        interp-<| : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((<| Le1) x1 x2) ((<| Le2) y1 y2))))
    data LeftSpindle_ShelfSigTerm  : Set where
      |>L : (LeftSpindle_ShelfSigTerm -> (LeftSpindle_ShelfSigTerm -> LeftSpindle_ShelfSigTerm))
      <|L : (LeftSpindle_ShelfSigTerm -> (LeftSpindle_ShelfSigTerm -> LeftSpindle_ShelfSigTerm))
    data ClLeftSpindle_ShelfSigTerm (A : Set) : Set where
      sing : (A -> (ClLeftSpindle_ShelfSigTerm A))
      |>Cl : ((ClLeftSpindle_ShelfSigTerm A) -> ((ClLeftSpindle_ShelfSigTerm A) -> (ClLeftSpindle_ShelfSigTerm A)))
      <|Cl : ((ClLeftSpindle_ShelfSigTerm A) -> ((ClLeftSpindle_ShelfSigTerm A) -> (ClLeftSpindle_ShelfSigTerm A)))
    data OpLeftSpindle_ShelfSigTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLeftSpindle_ShelfSigTerm n))
      |>OL : ((OpLeftSpindle_ShelfSigTerm n) -> ((OpLeftSpindle_ShelfSigTerm n) -> (OpLeftSpindle_ShelfSigTerm n)))
      <|OL : ((OpLeftSpindle_ShelfSigTerm n) -> ((OpLeftSpindle_ShelfSigTerm n) -> (OpLeftSpindle_ShelfSigTerm n)))
    data OpLeftSpindle_ShelfSigTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLeftSpindle_ShelfSigTerm2 n A))
      sing2 : (A -> (OpLeftSpindle_ShelfSigTerm2 n A))
      |>OL2 : ((OpLeftSpindle_ShelfSigTerm2 n A) -> ((OpLeftSpindle_ShelfSigTerm2 n A) -> (OpLeftSpindle_ShelfSigTerm2 n A)))
      <|OL2 : ((OpLeftSpindle_ShelfSigTerm2 n A) -> ((OpLeftSpindle_ShelfSigTerm2 n A) -> (OpLeftSpindle_ShelfSigTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClLeftSpindle_ShelfSigTerm A) -> (ClLeftSpindle_ShelfSigTerm A))
    simplifyCl (|>Cl x1 x2) = (|>Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (<|Cl x1 x2) = (<|Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLeftSpindle_ShelfSigTerm n) -> (OpLeftSpindle_ShelfSigTerm n))
    simplifyOpB (|>OL x1 x2) = (|>OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (<|OL x1 x2) = (<|OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLeftSpindle_ShelfSigTerm2 n A) -> (OpLeftSpindle_ShelfSigTerm2 n A))
    simplifyOp (|>OL2 x1 x2) = (|>OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (<|OL2 x1 x2) = (<|OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((LeftSpindle_ShelfSig A) -> (LeftSpindle_ShelfSigTerm -> A))
    evalB Le (|>L x1 x2) = ((|> Le) (evalB Le x1) (evalB Le x2)) 
    evalB Le (<|L x1 x2) = ((<| Le) (evalB Le x1) (evalB Le x2)) 
    evalCl : {A : Set} -> ((LeftSpindle_ShelfSig A) -> ((ClLeftSpindle_ShelfSigTerm A) -> A))
    evalCl Le (sing x1) = x1 
    evalCl Le (|>Cl x1 x2) = ((|> Le) (evalCl Le x1) (evalCl Le x2)) 
    evalCl Le (<|Cl x1 x2) = ((<| Le) (evalCl Le x1) (evalCl Le x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((LeftSpindle_ShelfSig A) -> ((Vec A n) -> ((OpLeftSpindle_ShelfSigTerm n) -> A)))
    evalOpB Le vars (v x1) = (lookup _ x1 vars) 
    evalOpB Le vars (|>OL x1 x2) = ((|> Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOpB Le vars (<|OL x1 x2) = ((<| Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((LeftSpindle_ShelfSig A) -> ((Vec A n) -> ((OpLeftSpindle_ShelfSigTerm2 n A) -> A)))
    evalOp Le vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Le vars (sing2 x1) = x1 
    evalOp Le vars (|>OL2 x1 x2) = ((|> Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    evalOp Le vars (<|OL2 x1 x2) = ((<| Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    inductionB : {P : (LeftSpindle_ShelfSigTerm -> Set)} -> (((x1 x2 : LeftSpindle_ShelfSigTerm) -> ((P x1) -> ((P x2) -> (P (|>L x1 x2))))) -> (((x1 x2 : LeftSpindle_ShelfSigTerm) -> ((P x1) -> ((P x2) -> (P (<|L x1 x2))))) -> ((x : LeftSpindle_ShelfSigTerm) -> (P x))))
    inductionB {p} p|>l p<|l (|>L x1 x2) = (p|>l _ _ (inductionB {p} p|>l p<|l x1) (inductionB {p} p|>l p<|l x2)) 
    inductionB {p} p|>l p<|l (<|L x1 x2) = (p<|l _ _ (inductionB {p} p|>l p<|l x1) (inductionB {p} p|>l p<|l x2)) 
    inductionCl : {A : Set} {P : ((ClLeftSpindle_ShelfSigTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClLeftSpindle_ShelfSigTerm A)) -> ((P x1) -> ((P x2) -> (P (|>Cl x1 x2))))) -> (((x1 x2 : (ClLeftSpindle_ShelfSigTerm A)) -> ((P x1) -> ((P x2) -> (P (<|Cl x1 x2))))) -> ((x : (ClLeftSpindle_ShelfSigTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p|>cl p<|cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p|>cl p<|cl (|>Cl x1 x2) = (p|>cl _ _ (inductionCl {_} {p} psing p|>cl p<|cl x1) (inductionCl {_} {p} psing p|>cl p<|cl x2)) 
    inductionCl {_} {p} psing p|>cl p<|cl (<|Cl x1 x2) = (p<|cl _ _ (inductionCl {_} {p} psing p|>cl p<|cl x1) (inductionCl {_} {p} psing p|>cl p<|cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLeftSpindle_ShelfSigTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpLeftSpindle_ShelfSigTerm n)) -> ((P x1) -> ((P x2) -> (P (|>OL x1 x2))))) -> (((x1 x2 : (OpLeftSpindle_ShelfSigTerm n)) -> ((P x1) -> ((P x2) -> (P (<|OL x1 x2))))) -> ((x : (OpLeftSpindle_ShelfSigTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p|>ol p<|ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p|>ol p<|ol (|>OL x1 x2) = (p|>ol _ _ (inductionOpB {_} {p} pv p|>ol p<|ol x1) (inductionOpB {_} {p} pv p|>ol p<|ol x2)) 
    inductionOpB {_} {p} pv p|>ol p<|ol (<|OL x1 x2) = (p<|ol _ _ (inductionOpB {_} {p} pv p|>ol p<|ol x1) (inductionOpB {_} {p} pv p|>ol p<|ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLeftSpindle_ShelfSigTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpLeftSpindle_ShelfSigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (|>OL2 x1 x2))))) -> (((x1 x2 : (OpLeftSpindle_ShelfSigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (<|OL2 x1 x2))))) -> ((x : (OpLeftSpindle_ShelfSigTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (|>OL2 x1 x2) = (p|>ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (<|OL2 x1 x2) = (p<|ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x2)) 
    |>L' : (LeftSpindle_ShelfSigTerm -> (LeftSpindle_ShelfSigTerm -> LeftSpindle_ShelfSigTerm))
    |>L' x1 x2 = (|>L x1 x2) 
    <|L' : (LeftSpindle_ShelfSigTerm -> (LeftSpindle_ShelfSigTerm -> LeftSpindle_ShelfSigTerm))
    <|L' x1 x2 = (<|L x1 x2) 
    stageB : (LeftSpindle_ShelfSigTerm -> (Staged LeftSpindle_ShelfSigTerm))
    stageB (|>L x1 x2) = (stage2 |>L' (codeLift2 |>L') (stageB x1) (stageB x2)) 
    stageB (<|L x1 x2) = (stage2 <|L' (codeLift2 <|L') (stageB x1) (stageB x2)) 
    |>Cl' : {A : Set} -> ((ClLeftSpindle_ShelfSigTerm A) -> ((ClLeftSpindle_ShelfSigTerm A) -> (ClLeftSpindle_ShelfSigTerm A)))
    |>Cl' x1 x2 = (|>Cl x1 x2) 
    <|Cl' : {A : Set} -> ((ClLeftSpindle_ShelfSigTerm A) -> ((ClLeftSpindle_ShelfSigTerm A) -> (ClLeftSpindle_ShelfSigTerm A)))
    <|Cl' x1 x2 = (<|Cl x1 x2) 
    stageCl : {A : Set} -> ((ClLeftSpindle_ShelfSigTerm A) -> (Staged (ClLeftSpindle_ShelfSigTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (|>Cl x1 x2) = (stage2 |>Cl' (codeLift2 |>Cl') (stageCl x1) (stageCl x2)) 
    stageCl (<|Cl x1 x2) = (stage2 <|Cl' (codeLift2 <|Cl') (stageCl x1) (stageCl x2)) 
    |>OL' : {n : Nat} -> ((OpLeftSpindle_ShelfSigTerm n) -> ((OpLeftSpindle_ShelfSigTerm n) -> (OpLeftSpindle_ShelfSigTerm n)))
    |>OL' x1 x2 = (|>OL x1 x2) 
    <|OL' : {n : Nat} -> ((OpLeftSpindle_ShelfSigTerm n) -> ((OpLeftSpindle_ShelfSigTerm n) -> (OpLeftSpindle_ShelfSigTerm n)))
    <|OL' x1 x2 = (<|OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLeftSpindle_ShelfSigTerm n) -> (Staged (OpLeftSpindle_ShelfSigTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (|>OL x1 x2) = (stage2 |>OL' (codeLift2 |>OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (<|OL x1 x2) = (stage2 <|OL' (codeLift2 <|OL') (stageOpB x1) (stageOpB x2)) 
    |>OL2' : {n : Nat} {A : Set} -> ((OpLeftSpindle_ShelfSigTerm2 n A) -> ((OpLeftSpindle_ShelfSigTerm2 n A) -> (OpLeftSpindle_ShelfSigTerm2 n A)))
    |>OL2' x1 x2 = (|>OL2 x1 x2) 
    <|OL2' : {n : Nat} {A : Set} -> ((OpLeftSpindle_ShelfSigTerm2 n A) -> ((OpLeftSpindle_ShelfSigTerm2 n A) -> (OpLeftSpindle_ShelfSigTerm2 n A)))
    <|OL2' x1 x2 = (<|OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLeftSpindle_ShelfSigTerm2 n A) -> (Staged (OpLeftSpindle_ShelfSigTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (|>OL2 x1 x2) = (stage2 |>OL2' (codeLift2 |>OL2') (stageOp x1) (stageOp x2)) 
    stageOp (<|OL2 x1 x2) = (stage2 <|OL2' (codeLift2 <|OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        |>T : ((Repr A) -> ((Repr A) -> (Repr A)))
        <|T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module LeftUnital  where
    record LeftUnital (A : Set) : Set where
      constructor LeftUnitalC
      field
        e : A
        op : (A -> (A -> A))
        lunit_e : {x : A} -> (op e x) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        eS : AS
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        eP : (Prod A A)
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        lunit_eP : {xP : (Prod A A)} -> (opP eP xP) == xP
    record Hom {A1 : Set} {A2 : Set} (Le1 : (LeftUnital A1)) (Le2 : (LeftUnital A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-e : (hom (e Le1)) == (e Le2)
        pres-op : {x1 x2 : A1} -> (hom ((op Le1) x1 x2)) == ((op Le2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Le1 : (LeftUnital A1)) (Le2 : (LeftUnital A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-e : (interp (e Le1) (e Le2))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Le1) x1 x2) ((op Le2) y1 y2))))
    data LeftUnitalTerm  : Set where
      eL : LeftUnitalTerm
      opL : (LeftUnitalTerm -> (LeftUnitalTerm -> LeftUnitalTerm))
    data ClLeftUnitalTerm (A : Set) : Set where
      sing : (A -> (ClLeftUnitalTerm A))
      eCl : (ClLeftUnitalTerm A)
      opCl : ((ClLeftUnitalTerm A) -> ((ClLeftUnitalTerm A) -> (ClLeftUnitalTerm A)))
    data OpLeftUnitalTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLeftUnitalTerm n))
      eOL : (OpLeftUnitalTerm n)
      opOL : ((OpLeftUnitalTerm n) -> ((OpLeftUnitalTerm n) -> (OpLeftUnitalTerm n)))
    data OpLeftUnitalTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLeftUnitalTerm2 n A))
      sing2 : (A -> (OpLeftUnitalTerm2 n A))
      eOL2 : (OpLeftUnitalTerm2 n A)
      opOL2 : ((OpLeftUnitalTerm2 n A) -> ((OpLeftUnitalTerm2 n A) -> (OpLeftUnitalTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClLeftUnitalTerm A) -> (ClLeftUnitalTerm A))
    simplifyCl (opCl eCl x) = x 
    simplifyCl eCl = eCl 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLeftUnitalTerm n) -> (OpLeftUnitalTerm n))
    simplifyOpB (opOL eOL x) = x 
    simplifyOpB eOL = eOL 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLeftUnitalTerm2 n A) -> (OpLeftUnitalTerm2 n A))
    simplifyOp (opOL2 eOL2 x) = x 
    simplifyOp eOL2 = eOL2 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((LeftUnital A) -> (LeftUnitalTerm -> A))
    evalB Le eL = (e Le) 
    evalB Le (opL x1 x2) = ((op Le) (evalB Le x1) (evalB Le x2)) 
    evalCl : {A : Set} -> ((LeftUnital A) -> ((ClLeftUnitalTerm A) -> A))
    evalCl Le (sing x1) = x1 
    evalCl Le eCl = (e Le) 
    evalCl Le (opCl x1 x2) = ((op Le) (evalCl Le x1) (evalCl Le x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((LeftUnital A) -> ((Vec A n) -> ((OpLeftUnitalTerm n) -> A)))
    evalOpB Le vars (v x1) = (lookup _ x1 vars) 
    evalOpB Le vars eOL = (e Le) 
    evalOpB Le vars (opOL x1 x2) = ((op Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((LeftUnital A) -> ((Vec A n) -> ((OpLeftUnitalTerm2 n A) -> A)))
    evalOp Le vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Le vars (sing2 x1) = x1 
    evalOp Le vars eOL2 = (e Le) 
    evalOp Le vars (opOL2 x1 x2) = ((op Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    inductionB : {P : (LeftUnitalTerm -> Set)} -> ((P eL) -> (((x1 x2 : LeftUnitalTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : LeftUnitalTerm) -> (P x))))
    inductionB {p} pel popl eL = pel 
    inductionB {p} pel popl (opL x1 x2) = (popl _ _ (inductionB {p} pel popl x1) (inductionB {p} pel popl x2)) 
    inductionCl : {A : Set} {P : ((ClLeftUnitalTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P eCl) -> (((x1 x2 : (ClLeftUnitalTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClLeftUnitalTerm A)) -> (P x)))))
    inductionCl {_} {p} psing pecl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pecl popcl eCl = pecl 
    inductionCl {_} {p} psing pecl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing pecl popcl x1) (inductionCl {_} {p} psing pecl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLeftUnitalTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P eOL) -> (((x1 x2 : (OpLeftUnitalTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpLeftUnitalTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv peol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv peol popol eOL = peol 
    inductionOpB {_} {p} pv peol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv peol popol x1) (inductionOpB {_} {p} pv peol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLeftUnitalTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P eOL2) -> (((x1 x2 : (OpLeftUnitalTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpLeftUnitalTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 eOL2 = peol2 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 x2)) 
    eL' : LeftUnitalTerm
    eL'  = eL 
    opL' : (LeftUnitalTerm -> (LeftUnitalTerm -> LeftUnitalTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (LeftUnitalTerm -> (Staged LeftUnitalTerm))
    stageB eL = (Now eL) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    eCl' : {A : Set} -> (ClLeftUnitalTerm A)
    eCl'  = eCl 
    opCl' : {A : Set} -> ((ClLeftUnitalTerm A) -> ((ClLeftUnitalTerm A) -> (ClLeftUnitalTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClLeftUnitalTerm A) -> (Staged (ClLeftUnitalTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl eCl = (Now eCl) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    eOL' : {n : Nat} -> (OpLeftUnitalTerm n)
    eOL'  = eOL 
    opOL' : {n : Nat} -> ((OpLeftUnitalTerm n) -> ((OpLeftUnitalTerm n) -> (OpLeftUnitalTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLeftUnitalTerm n) -> (Staged (OpLeftUnitalTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB eOL = (Now eOL) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    eOL2' : {n : Nat} {A : Set} -> (OpLeftUnitalTerm2 n A)
    eOL2'  = eOL2 
    opOL2' : {n : Nat} {A : Set} -> ((OpLeftUnitalTerm2 n A) -> ((OpLeftUnitalTerm2 n A) -> (OpLeftUnitalTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLeftUnitalTerm2 n A) -> (Staged (OpLeftUnitalTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp eOL2 = (Now eOL2) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        eT : (Repr A)
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module LeftZero  where
    record LeftZero (A : Set) : Set where
      constructor LeftZeroC
      field
        e : A
        op : (A -> (A -> A))
        leftZero_op_e : {x : A} -> (op e x) == e
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        eS : AS
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        eP : (Prod A A)
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftZero_op_eP : {xP : (Prod A A)} -> (opP eP xP) == eP
    record Hom {A1 : Set} {A2 : Set} (Le1 : (LeftZero A1)) (Le2 : (LeftZero A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-e : (hom (e Le1)) == (e Le2)
        pres-op : {x1 x2 : A1} -> (hom ((op Le1) x1 x2)) == ((op Le2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Le1 : (LeftZero A1)) (Le2 : (LeftZero A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-e : (interp (e Le1) (e Le2))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Le1) x1 x2) ((op Le2) y1 y2))))
    data LeftZeroTerm  : Set where
      eL : LeftZeroTerm
      opL : (LeftZeroTerm -> (LeftZeroTerm -> LeftZeroTerm))
    data ClLeftZeroTerm (A : Set) : Set where
      sing : (A -> (ClLeftZeroTerm A))
      eCl : (ClLeftZeroTerm A)
      opCl : ((ClLeftZeroTerm A) -> ((ClLeftZeroTerm A) -> (ClLeftZeroTerm A)))
    data OpLeftZeroTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLeftZeroTerm n))
      eOL : (OpLeftZeroTerm n)
      opOL : ((OpLeftZeroTerm n) -> ((OpLeftZeroTerm n) -> (OpLeftZeroTerm n)))
    data OpLeftZeroTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLeftZeroTerm2 n A))
      sing2 : (A -> (OpLeftZeroTerm2 n A))
      eOL2 : (OpLeftZeroTerm2 n A)
      opOL2 : ((OpLeftZeroTerm2 n A) -> ((OpLeftZeroTerm2 n A) -> (OpLeftZeroTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClLeftZeroTerm A) -> (ClLeftZeroTerm A))
    simplifyCl eCl = eCl 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLeftZeroTerm n) -> (OpLeftZeroTerm n))
    simplifyOpB eOL = eOL 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLeftZeroTerm2 n A) -> (OpLeftZeroTerm2 n A))
    simplifyOp eOL2 = eOL2 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((LeftZero A) -> (LeftZeroTerm -> A))
    evalB Le eL = (e Le) 
    evalB Le (opL x1 x2) = ((op Le) (evalB Le x1) (evalB Le x2)) 
    evalCl : {A : Set} -> ((LeftZero A) -> ((ClLeftZeroTerm A) -> A))
    evalCl Le (sing x1) = x1 
    evalCl Le eCl = (e Le) 
    evalCl Le (opCl x1 x2) = ((op Le) (evalCl Le x1) (evalCl Le x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((LeftZero A) -> ((Vec A n) -> ((OpLeftZeroTerm n) -> A)))
    evalOpB Le vars (v x1) = (lookup _ x1 vars) 
    evalOpB Le vars eOL = (e Le) 
    evalOpB Le vars (opOL x1 x2) = ((op Le) (evalOpB Le vars x1) (evalOpB Le vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((LeftZero A) -> ((Vec A n) -> ((OpLeftZeroTerm2 n A) -> A)))
    evalOp Le vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Le vars (sing2 x1) = x1 
    evalOp Le vars eOL2 = (e Le) 
    evalOp Le vars (opOL2 x1 x2) = ((op Le) (evalOp Le vars x1) (evalOp Le vars x2)) 
    inductionB : {P : (LeftZeroTerm -> Set)} -> ((P eL) -> (((x1 x2 : LeftZeroTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : LeftZeroTerm) -> (P x))))
    inductionB {p} pel popl eL = pel 
    inductionB {p} pel popl (opL x1 x2) = (popl _ _ (inductionB {p} pel popl x1) (inductionB {p} pel popl x2)) 
    inductionCl : {A : Set} {P : ((ClLeftZeroTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P eCl) -> (((x1 x2 : (ClLeftZeroTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClLeftZeroTerm A)) -> (P x)))))
    inductionCl {_} {p} psing pecl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pecl popcl eCl = pecl 
    inductionCl {_} {p} psing pecl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing pecl popcl x1) (inductionCl {_} {p} psing pecl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLeftZeroTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P eOL) -> (((x1 x2 : (OpLeftZeroTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpLeftZeroTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv peol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv peol popol eOL = peol 
    inductionOpB {_} {p} pv peol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv peol popol x1) (inductionOpB {_} {p} pv peol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLeftZeroTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P eOL2) -> (((x1 x2 : (OpLeftZeroTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpLeftZeroTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 eOL2 = peol2 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 x2)) 
    eL' : LeftZeroTerm
    eL'  = eL 
    opL' : (LeftZeroTerm -> (LeftZeroTerm -> LeftZeroTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (LeftZeroTerm -> (Staged LeftZeroTerm))
    stageB eL = (Now eL) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    eCl' : {A : Set} -> (ClLeftZeroTerm A)
    eCl'  = eCl 
    opCl' : {A : Set} -> ((ClLeftZeroTerm A) -> ((ClLeftZeroTerm A) -> (ClLeftZeroTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClLeftZeroTerm A) -> (Staged (ClLeftZeroTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl eCl = (Now eCl) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    eOL' : {n : Nat} -> (OpLeftZeroTerm n)
    eOL'  = eOL 
    opOL' : {n : Nat} -> ((OpLeftZeroTerm n) -> ((OpLeftZeroTerm n) -> (OpLeftZeroTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLeftZeroTerm n) -> (Staged (OpLeftZeroTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB eOL = (Now eOL) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    eOL2' : {n : Nat} {A : Set} -> (OpLeftZeroTerm2 n A)
    eOL2'  = eOL2 
    opOL2' : {n : Nat} {A : Set} -> ((OpLeftZeroTerm2 n A) -> ((OpLeftZeroTerm2 n A) -> (OpLeftZeroTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLeftZeroTerm2 n A) -> (Staged (OpLeftZeroTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp eOL2 = (Now eOL2) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        eT : (Repr A)
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module LieRing  where
    record LieRing (A : Set) : Set where
      constructor LieRingC
      field
        0 : A
        + : (A -> (A -> A))
        * : (A -> (A -> A))
        jacobian_*_+ : {x y z : A} -> (+ (+ (* x (* y z)) (* y (* z x))) (* z (* x y))) == 0
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        leftDistributive_*_+ : {x y z : A} -> (* x (+ y z)) == (+ (* x y) (* x z))
        rightDistributive_*_+ : {x y z : A} -> (* (+ y z) x) == (+ (* y x) (* z x))
        neg : (A -> A)
        leftInverse_inv_op_0 : {x : A} -> (+ x (neg x)) == 0
        rightInverse_inv_op_0 : {x : A} -> (+ (neg x) x) == 0
        1 : A
        lunit_1 : {x : A} -> (* 1 x) == x
        runit_1 : {x : A} -> (* x 1) == x
        leftZero_op_0 : {x : A} -> (* 0 x) == 0
        rightZero_op_0 : {x : A} -> (* x 0) == 0
        antiCommutative : {x y : A} -> (* x y) == (neg (* y x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        0S : AS
        +S : (AS -> (AS -> AS))
        *S : (AS -> (AS -> AS))
        negS : (AS -> AS)
        1S : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        0P : (Prod A A)
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        negP : ((Prod A A) -> (Prod A A))
        1P : (Prod A A)
        jacobian_*_+P : {xP yP zP : (Prod A A)} -> (+P (+P (*P xP (*P yP zP)) (*P yP (*P zP xP))) (*P zP (*P xP yP))) == 0P
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        leftDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P xP (+P yP zP)) == (+P (*P xP yP) (*P xP zP))
        rightDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P (+P yP zP) xP) == (+P (*P yP xP) (*P zP xP))
        leftInverse_inv_op_0P : {xP : (Prod A A)} -> (+P xP (negP xP)) == 0P
        rightInverse_inv_op_0P : {xP : (Prod A A)} -> (+P (negP xP) xP) == 0P
        lunit_1P : {xP : (Prod A A)} -> (*P 1P xP) == xP
        runit_1P : {xP : (Prod A A)} -> (*P xP 1P) == xP
        leftZero_op_0P : {xP : (Prod A A)} -> (*P 0P xP) == 0P
        rightZero_op_0P : {xP : (Prod A A)} -> (*P xP 0P) == 0P
        antiCommutativeP : {xP yP : (Prod A A)} -> (*P xP yP) == (negP (*P yP xP))
    record Hom {A1 : Set} {A2 : Set} (Li1 : (LieRing A1)) (Li2 : (LieRing A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-0 : (hom (0 Li1)) == (0 Li2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Li1) x1 x2)) == ((+ Li2) (hom x1) (hom x2))
        pres-* : {x1 x2 : A1} -> (hom ((* Li1) x1 x2)) == ((* Li2) (hom x1) (hom x2))
        pres-neg : {x1 : A1} -> (hom ((neg Li1) x1)) == ((neg Li2) (hom x1))
        pres-1 : (hom (1 Li1)) == (1 Li2)
    record RelInterp {A1 : Set} {A2 : Set} (Li1 : (LieRing A1)) (Li2 : (LieRing A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-0 : (interp (0 Li1) (0 Li2))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Li1) x1 x2) ((+ Li2) y1 y2))))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Li1) x1 x2) ((* Li2) y1 y2))))
        interp-neg : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((neg Li1) x1) ((neg Li2) y1)))
        interp-1 : (interp (1 Li1) (1 Li2))
    data LieRingTerm  : Set where
      0L : LieRingTerm
      +L : (LieRingTerm -> (LieRingTerm -> LieRingTerm))
      *L : (LieRingTerm -> (LieRingTerm -> LieRingTerm))
      negL : (LieRingTerm -> LieRingTerm)
      1L : LieRingTerm
    data ClLieRingTerm (A : Set) : Set where
      sing : (A -> (ClLieRingTerm A))
      0Cl : (ClLieRingTerm A)
      +Cl : ((ClLieRingTerm A) -> ((ClLieRingTerm A) -> (ClLieRingTerm A)))
      *Cl : ((ClLieRingTerm A) -> ((ClLieRingTerm A) -> (ClLieRingTerm A)))
      negCl : ((ClLieRingTerm A) -> (ClLieRingTerm A))
      1Cl : (ClLieRingTerm A)
    data OpLieRingTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLieRingTerm n))
      0OL : (OpLieRingTerm n)
      +OL : ((OpLieRingTerm n) -> ((OpLieRingTerm n) -> (OpLieRingTerm n)))
      *OL : ((OpLieRingTerm n) -> ((OpLieRingTerm n) -> (OpLieRingTerm n)))
      negOL : ((OpLieRingTerm n) -> (OpLieRingTerm n))
      1OL : (OpLieRingTerm n)
    data OpLieRingTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLieRingTerm2 n A))
      sing2 : (A -> (OpLieRingTerm2 n A))
      0OL2 : (OpLieRingTerm2 n A)
      +OL2 : ((OpLieRingTerm2 n A) -> ((OpLieRingTerm2 n A) -> (OpLieRingTerm2 n A)))
      *OL2 : ((OpLieRingTerm2 n A) -> ((OpLieRingTerm2 n A) -> (OpLieRingTerm2 n A)))
      negOL2 : ((OpLieRingTerm2 n A) -> (OpLieRingTerm2 n A))
      1OL2 : (OpLieRingTerm2 n A)
    simplifyCl : {A : Set} -> ((ClLieRingTerm A) -> (ClLieRingTerm A))
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl (*Cl 1Cl x) = x 
    simplifyCl (*Cl x 1Cl) = x 
    simplifyCl (negCl (*Cl y x)) = (*Cl x y) 
    simplifyCl 0Cl = 0Cl 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (negCl x1) = (negCl (simplifyCl x1)) 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLieRingTerm n) -> (OpLieRingTerm n))
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB (*OL 1OL x) = x 
    simplifyOpB (*OL x 1OL) = x 
    simplifyOpB (negOL (*OL y x)) = (*OL x y) 
    simplifyOpB 0OL = 0OL 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (negOL x1) = (negOL (simplifyOpB x1)) 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLieRingTerm2 n A) -> (OpLieRingTerm2 n A))
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp (*OL2 1OL2 x) = x 
    simplifyOp (*OL2 x 1OL2) = x 
    simplifyOp (negOL2 (*OL2 y x)) = (*OL2 x y) 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (negOL2 x1) = (negOL2 (simplifyOp x1)) 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((LieRing A) -> (LieRingTerm -> A))
    evalB Li 0L = (0 Li) 
    evalB Li (+L x1 x2) = ((+ Li) (evalB Li x1) (evalB Li x2)) 
    evalB Li (*L x1 x2) = ((* Li) (evalB Li x1) (evalB Li x2)) 
    evalB Li (negL x1) = ((neg Li) (evalB Li x1)) 
    evalB Li 1L = (1 Li) 
    evalCl : {A : Set} -> ((LieRing A) -> ((ClLieRingTerm A) -> A))
    evalCl Li (sing x1) = x1 
    evalCl Li 0Cl = (0 Li) 
    evalCl Li (+Cl x1 x2) = ((+ Li) (evalCl Li x1) (evalCl Li x2)) 
    evalCl Li (*Cl x1 x2) = ((* Li) (evalCl Li x1) (evalCl Li x2)) 
    evalCl Li (negCl x1) = ((neg Li) (evalCl Li x1)) 
    evalCl Li 1Cl = (1 Li) 
    evalOpB : {A : Set} {n : Nat} -> ((LieRing A) -> ((Vec A n) -> ((OpLieRingTerm n) -> A)))
    evalOpB Li vars (v x1) = (lookup _ x1 vars) 
    evalOpB Li vars 0OL = (0 Li) 
    evalOpB Li vars (+OL x1 x2) = ((+ Li) (evalOpB Li vars x1) (evalOpB Li vars x2)) 
    evalOpB Li vars (*OL x1 x2) = ((* Li) (evalOpB Li vars x1) (evalOpB Li vars x2)) 
    evalOpB Li vars (negOL x1) = ((neg Li) (evalOpB Li vars x1)) 
    evalOpB Li vars 1OL = (1 Li) 
    evalOp : {A : Set} {n : Nat} -> ((LieRing A) -> ((Vec A n) -> ((OpLieRingTerm2 n A) -> A)))
    evalOp Li vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Li vars (sing2 x1) = x1 
    evalOp Li vars 0OL2 = (0 Li) 
    evalOp Li vars (+OL2 x1 x2) = ((+ Li) (evalOp Li vars x1) (evalOp Li vars x2)) 
    evalOp Li vars (*OL2 x1 x2) = ((* Li) (evalOp Li vars x1) (evalOp Li vars x2)) 
    evalOp Li vars (negOL2 x1) = ((neg Li) (evalOp Li vars x1)) 
    evalOp Li vars 1OL2 = (1 Li) 
    inductionB : {P : (LieRingTerm -> Set)} -> ((P 0L) -> (((x1 x2 : LieRingTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> (((x1 x2 : LieRingTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 : LieRingTerm) -> ((P x1) -> (P (negL x1)))) -> ((P 1L) -> ((x : LieRingTerm) -> (P x)))))))
    inductionB {p} p0l p+l p*l pnegl p1l 0L = p0l 
    inductionB {p} p0l p+l p*l pnegl p1l (+L x1 x2) = (p+l _ _ (inductionB {p} p0l p+l p*l pnegl p1l x1) (inductionB {p} p0l p+l p*l pnegl p1l x2)) 
    inductionB {p} p0l p+l p*l pnegl p1l (*L x1 x2) = (p*l _ _ (inductionB {p} p0l p+l p*l pnegl p1l x1) (inductionB {p} p0l p+l p*l pnegl p1l x2)) 
    inductionB {p} p0l p+l p*l pnegl p1l (negL x1) = (pnegl _ (inductionB {p} p0l p+l p*l pnegl p1l x1)) 
    inductionB {p} p0l p+l p*l pnegl p1l 1L = p1l 
    inductionCl : {A : Set} {P : ((ClLieRingTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 0Cl) -> (((x1 x2 : (ClLieRingTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> (((x1 x2 : (ClLieRingTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 : (ClLieRingTerm A)) -> ((P x1) -> (P (negCl x1)))) -> ((P 1Cl) -> ((x : (ClLieRingTerm A)) -> (P x))))))))
    inductionCl {_} {p} psing p0cl p+cl p*cl pnegcl p1cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p0cl p+cl p*cl pnegcl p1cl 0Cl = p0cl 
    inductionCl {_} {p} psing p0cl p+cl p*cl pnegcl p1cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p0cl p+cl p*cl pnegcl p1cl x1) (inductionCl {_} {p} psing p0cl p+cl p*cl pnegcl p1cl x2)) 
    inductionCl {_} {p} psing p0cl p+cl p*cl pnegcl p1cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p0cl p+cl p*cl pnegcl p1cl x1) (inductionCl {_} {p} psing p0cl p+cl p*cl pnegcl p1cl x2)) 
    inductionCl {_} {p} psing p0cl p+cl p*cl pnegcl p1cl (negCl x1) = (pnegcl _ (inductionCl {_} {p} psing p0cl p+cl p*cl pnegcl p1cl x1)) 
    inductionCl {_} {p} psing p0cl p+cl p*cl pnegcl p1cl 1Cl = p1cl 
    inductionOpB : {n : Nat} {P : ((OpLieRingTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 0OL) -> (((x1 x2 : (OpLieRingTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> (((x1 x2 : (OpLieRingTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 : (OpLieRingTerm n)) -> ((P x1) -> (P (negOL x1)))) -> ((P 1OL) -> ((x : (OpLieRingTerm n)) -> (P x))))))))
    inductionOpB {_} {p} pv p0ol p+ol p*ol pnegol p1ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p0ol p+ol p*ol pnegol p1ol 0OL = p0ol 
    inductionOpB {_} {p} pv p0ol p+ol p*ol pnegol p1ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p0ol p+ol p*ol pnegol p1ol x1) (inductionOpB {_} {p} pv p0ol p+ol p*ol pnegol p1ol x2)) 
    inductionOpB {_} {p} pv p0ol p+ol p*ol pnegol p1ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p0ol p+ol p*ol pnegol p1ol x1) (inductionOpB {_} {p} pv p0ol p+ol p*ol pnegol p1ol x2)) 
    inductionOpB {_} {p} pv p0ol p+ol p*ol pnegol p1ol (negOL x1) = (pnegol _ (inductionOpB {_} {p} pv p0ol p+ol p*ol pnegol p1ol x1)) 
    inductionOpB {_} {p} pv p0ol p+ol p*ol pnegol p1ol 1OL = p1ol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLieRingTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 0OL2) -> (((x1 x2 : (OpLieRingTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> (((x1 x2 : (OpLieRingTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 : (OpLieRingTerm2 n A)) -> ((P x1) -> (P (negOL2 x1)))) -> ((P 1OL2) -> ((x : (OpLieRingTerm2 n A)) -> (P x)))))))))
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 pnegol2 p1ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 pnegol2 p1ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 pnegol2 p1ol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 pnegol2 p1ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 pnegol2 p1ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 pnegol2 p1ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 pnegol2 p1ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 pnegol2 p1ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 pnegol2 p1ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 pnegol2 p1ol2 (negOL2 x1) = (pnegol2 _ (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 pnegol2 p1ol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 pnegol2 p1ol2 1OL2 = p1ol2 
    0L' : LieRingTerm
    0L'  = 0L 
    +L' : (LieRingTerm -> (LieRingTerm -> LieRingTerm))
    +L' x1 x2 = (+L x1 x2) 
    *L' : (LieRingTerm -> (LieRingTerm -> LieRingTerm))
    *L' x1 x2 = (*L x1 x2) 
    negL' : (LieRingTerm -> LieRingTerm)
    negL' x1 = (negL x1) 
    1L' : LieRingTerm
    1L'  = 1L 
    stageB : (LieRingTerm -> (Staged LieRingTerm))
    stageB 0L = (Now 0L) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (negL x1) = (stage1 negL' (codeLift1 negL') (stageB x1)) 
    stageB 1L = (Now 1L) 
    0Cl' : {A : Set} -> (ClLieRingTerm A)
    0Cl'  = 0Cl 
    +Cl' : {A : Set} -> ((ClLieRingTerm A) -> ((ClLieRingTerm A) -> (ClLieRingTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    *Cl' : {A : Set} -> ((ClLieRingTerm A) -> ((ClLieRingTerm A) -> (ClLieRingTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    negCl' : {A : Set} -> ((ClLieRingTerm A) -> (ClLieRingTerm A))
    negCl' x1 = (negCl x1) 
    1Cl' : {A : Set} -> (ClLieRingTerm A)
    1Cl'  = 1Cl 
    stageCl : {A : Set} -> ((ClLieRingTerm A) -> (Staged (ClLieRingTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (negCl x1) = (stage1 negCl' (codeLift1 negCl') (stageCl x1)) 
    stageCl 1Cl = (Now 1Cl) 
    0OL' : {n : Nat} -> (OpLieRingTerm n)
    0OL'  = 0OL 
    +OL' : {n : Nat} -> ((OpLieRingTerm n) -> ((OpLieRingTerm n) -> (OpLieRingTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    *OL' : {n : Nat} -> ((OpLieRingTerm n) -> ((OpLieRingTerm n) -> (OpLieRingTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    negOL' : {n : Nat} -> ((OpLieRingTerm n) -> (OpLieRingTerm n))
    negOL' x1 = (negOL x1) 
    1OL' : {n : Nat} -> (OpLieRingTerm n)
    1OL'  = 1OL 
    stageOpB : {n : Nat} -> ((OpLieRingTerm n) -> (Staged (OpLieRingTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (negOL x1) = (stage1 negOL' (codeLift1 negOL') (stageOpB x1)) 
    stageOpB 1OL = (Now 1OL) 
    0OL2' : {n : Nat} {A : Set} -> (OpLieRingTerm2 n A)
    0OL2'  = 0OL2 
    +OL2' : {n : Nat} {A : Set} -> ((OpLieRingTerm2 n A) -> ((OpLieRingTerm2 n A) -> (OpLieRingTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    *OL2' : {n : Nat} {A : Set} -> ((OpLieRingTerm2 n A) -> ((OpLieRingTerm2 n A) -> (OpLieRingTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    negOL2' : {n : Nat} {A : Set} -> ((OpLieRingTerm2 n A) -> (OpLieRingTerm2 n A))
    negOL2' x1 = (negOL2 x1) 
    1OL2' : {n : Nat} {A : Set} -> (OpLieRingTerm2 n A)
    1OL2'  = 1OL2 
    stageOp : {n : Nat} {A : Set} -> ((OpLieRingTerm2 n A) -> (Staged (OpLieRingTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (negOL2 x1) = (stage1 negOL2' (codeLift1 negOL2') (stageOp x1)) 
    stageOp 1OL2 = (Now 1OL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        0T : (Repr A)
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        negT : ((Repr A) -> (Repr A))
        1T : (Repr A)
  module Loop  where
    record Loop (A : Set) : Set where
      constructor LoopC
      field
        op : (A -> (A -> A))
        e : A
        lunit_e : {x : A} -> (op e x) == x
        runit_e : {x : A} -> (op x e) == x
        linv : (A -> (A -> A))
        leftCancel : {x y : A} -> (op x (linv x y)) == y
        lefCancelOp : {x y : A} -> (linv x (op x y)) == y
        rinv : (A -> (A -> A))
        rightCancel : {x y : A} -> (op (rinv y x) x) == y
        rightCancelOp : {x y : A} -> (rinv (op y x) x) == y
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        eS : AS
        linvS : (AS -> (AS -> AS))
        rinvS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        eP : (Prod A A)
        linvP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        rinvP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        lunit_eP : {xP : (Prod A A)} -> (opP eP xP) == xP
        runit_eP : {xP : (Prod A A)} -> (opP xP eP) == xP
        leftCancelP : {xP yP : (Prod A A)} -> (opP xP (linvP xP yP)) == yP
        lefCancelOpP : {xP yP : (Prod A A)} -> (linvP xP (opP xP yP)) == yP
        rightCancelP : {xP yP : (Prod A A)} -> (opP (rinvP yP xP) xP) == yP
        rightCancelOpP : {xP yP : (Prod A A)} -> (rinvP (opP yP xP) xP) == yP
    record Hom {A1 : Set} {A2 : Set} (Lo1 : (Loop A1)) (Lo2 : (Loop A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Lo1) x1 x2)) == ((op Lo2) (hom x1) (hom x2))
        pres-e : (hom (e Lo1)) == (e Lo2)
        pres-linv : {x1 x2 : A1} -> (hom ((linv Lo1) x1 x2)) == ((linv Lo2) (hom x1) (hom x2))
        pres-rinv : {x1 x2 : A1} -> (hom ((rinv Lo1) x1 x2)) == ((rinv Lo2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Lo1 : (Loop A1)) (Lo2 : (Loop A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Lo1) x1 x2) ((op Lo2) y1 y2))))
        interp-e : (interp (e Lo1) (e Lo2))
        interp-linv : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((linv Lo1) x1 x2) ((linv Lo2) y1 y2))))
        interp-rinv : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((rinv Lo1) x1 x2) ((rinv Lo2) y1 y2))))
    data LoopLTerm  : Set where
      opL : (LoopLTerm -> (LoopLTerm -> LoopLTerm))
      eL : LoopLTerm
      linvL : (LoopLTerm -> (LoopLTerm -> LoopLTerm))
      rinvL : (LoopLTerm -> (LoopLTerm -> LoopLTerm))
    data ClLoopClTerm (A : Set) : Set where
      sing : (A -> (ClLoopClTerm A))
      opCl : ((ClLoopClTerm A) -> ((ClLoopClTerm A) -> (ClLoopClTerm A)))
      eCl : (ClLoopClTerm A)
      linvCl : ((ClLoopClTerm A) -> ((ClLoopClTerm A) -> (ClLoopClTerm A)))
      rinvCl : ((ClLoopClTerm A) -> ((ClLoopClTerm A) -> (ClLoopClTerm A)))
    data OpLoopOLTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpLoopOLTerm n))
      opOL : ((OpLoopOLTerm n) -> ((OpLoopOLTerm n) -> (OpLoopOLTerm n)))
      eOL : (OpLoopOLTerm n)
      linvOL : ((OpLoopOLTerm n) -> ((OpLoopOLTerm n) -> (OpLoopOLTerm n)))
      rinvOL : ((OpLoopOLTerm n) -> ((OpLoopOLTerm n) -> (OpLoopOLTerm n)))
    data OpLoopOL2Term2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpLoopOL2Term2 n A))
      sing2 : (A -> (OpLoopOL2Term2 n A))
      opOL2 : ((OpLoopOL2Term2 n A) -> ((OpLoopOL2Term2 n A) -> (OpLoopOL2Term2 n A)))
      eOL2 : (OpLoopOL2Term2 n A)
      linvOL2 : ((OpLoopOL2Term2 n A) -> ((OpLoopOL2Term2 n A) -> (OpLoopOL2Term2 n A)))
      rinvOL2 : ((OpLoopOL2Term2 n A) -> ((OpLoopOL2Term2 n A) -> (OpLoopOL2Term2 n A)))
    simplifyCl : {A : Set} -> ((ClLoopClTerm A) -> (ClLoopClTerm A))
    simplifyCl (opCl eCl x) = x 
    simplifyCl (opCl x eCl) = x 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl eCl = eCl 
    simplifyCl (linvCl x1 x2) = (linvCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (rinvCl x1 x2) = (rinvCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpLoopOLTerm n) -> (OpLoopOLTerm n))
    simplifyOpB (opOL eOL x) = x 
    simplifyOpB (opOL x eOL) = x 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB eOL = eOL 
    simplifyOpB (linvOL x1 x2) = (linvOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (rinvOL x1 x2) = (rinvOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpLoopOL2Term2 n A) -> (OpLoopOL2Term2 n A))
    simplifyOp (opOL2 eOL2 x) = x 
    simplifyOp (opOL2 x eOL2) = x 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp eOL2 = eOL2 
    simplifyOp (linvOL2 x1 x2) = (linvOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (rinvOL2 x1 x2) = (rinvOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Loop A) -> (LoopLTerm -> A))
    evalB Lo (opL x1 x2) = ((op Lo) (evalB Lo x1) (evalB Lo x2)) 
    evalB Lo eL = (e Lo) 
    evalB Lo (linvL x1 x2) = ((linv Lo) (evalB Lo x1) (evalB Lo x2)) 
    evalB Lo (rinvL x1 x2) = ((rinv Lo) (evalB Lo x1) (evalB Lo x2)) 
    evalCl : {A : Set} -> ((Loop A) -> ((ClLoopClTerm A) -> A))
    evalCl Lo (sing x1) = x1 
    evalCl Lo (opCl x1 x2) = ((op Lo) (evalCl Lo x1) (evalCl Lo x2)) 
    evalCl Lo eCl = (e Lo) 
    evalCl Lo (linvCl x1 x2) = ((linv Lo) (evalCl Lo x1) (evalCl Lo x2)) 
    evalCl Lo (rinvCl x1 x2) = ((rinv Lo) (evalCl Lo x1) (evalCl Lo x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Loop A) -> ((Vec A n) -> ((OpLoopOLTerm n) -> A)))
    evalOpB Lo vars (v x1) = (lookup _ x1 vars) 
    evalOpB Lo vars (opOL x1 x2) = ((op Lo) (evalOpB Lo vars x1) (evalOpB Lo vars x2)) 
    evalOpB Lo vars eOL = (e Lo) 
    evalOpB Lo vars (linvOL x1 x2) = ((linv Lo) (evalOpB Lo vars x1) (evalOpB Lo vars x2)) 
    evalOpB Lo vars (rinvOL x1 x2) = ((rinv Lo) (evalOpB Lo vars x1) (evalOpB Lo vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Loop A) -> ((Vec A n) -> ((OpLoopOL2Term2 n A) -> A)))
    evalOp Lo vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Lo vars (sing2 x1) = x1 
    evalOp Lo vars (opOL2 x1 x2) = ((op Lo) (evalOp Lo vars x1) (evalOp Lo vars x2)) 
    evalOp Lo vars eOL2 = (e Lo) 
    evalOp Lo vars (linvOL2 x1 x2) = ((linv Lo) (evalOp Lo vars x1) (evalOp Lo vars x2)) 
    evalOp Lo vars (rinvOL2 x1 x2) = ((rinv Lo) (evalOp Lo vars x1) (evalOp Lo vars x2)) 
    inductionB : {P : (LoopLTerm -> Set)} -> (((x1 x2 : LoopLTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((P eL) -> (((x1 x2 : LoopLTerm) -> ((P x1) -> ((P x2) -> (P (linvL x1 x2))))) -> (((x1 x2 : LoopLTerm) -> ((P x1) -> ((P x2) -> (P (rinvL x1 x2))))) -> ((x : LoopLTerm) -> (P x))))))
    inductionB {p} popl pel plinvl prinvl (opL x1 x2) = (popl _ _ (inductionB {p} popl pel plinvl prinvl x1) (inductionB {p} popl pel plinvl prinvl x2)) 
    inductionB {p} popl pel plinvl prinvl eL = pel 
    inductionB {p} popl pel plinvl prinvl (linvL x1 x2) = (plinvl _ _ (inductionB {p} popl pel plinvl prinvl x1) (inductionB {p} popl pel plinvl prinvl x2)) 
    inductionB {p} popl pel plinvl prinvl (rinvL x1 x2) = (prinvl _ _ (inductionB {p} popl pel plinvl prinvl x1) (inductionB {p} popl pel plinvl prinvl x2)) 
    inductionCl : {A : Set} {P : ((ClLoopClTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClLoopClTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((P eCl) -> (((x1 x2 : (ClLoopClTerm A)) -> ((P x1) -> ((P x2) -> (P (linvCl x1 x2))))) -> (((x1 x2 : (ClLoopClTerm A)) -> ((P x1) -> ((P x2) -> (P (rinvCl x1 x2))))) -> ((x : (ClLoopClTerm A)) -> (P x)))))))
    inductionCl {_} {p} psing popcl pecl plinvcl prinvcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl pecl plinvcl prinvcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl pecl plinvcl prinvcl x1) (inductionCl {_} {p} psing popcl pecl plinvcl prinvcl x2)) 
    inductionCl {_} {p} psing popcl pecl plinvcl prinvcl eCl = pecl 
    inductionCl {_} {p} psing popcl pecl plinvcl prinvcl (linvCl x1 x2) = (plinvcl _ _ (inductionCl {_} {p} psing popcl pecl plinvcl prinvcl x1) (inductionCl {_} {p} psing popcl pecl plinvcl prinvcl x2)) 
    inductionCl {_} {p} psing popcl pecl plinvcl prinvcl (rinvCl x1 x2) = (prinvcl _ _ (inductionCl {_} {p} psing popcl pecl plinvcl prinvcl x1) (inductionCl {_} {p} psing popcl pecl plinvcl prinvcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpLoopOLTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpLoopOLTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((P eOL) -> (((x1 x2 : (OpLoopOLTerm n)) -> ((P x1) -> ((P x2) -> (P (linvOL x1 x2))))) -> (((x1 x2 : (OpLoopOLTerm n)) -> ((P x1) -> ((P x2) -> (P (rinvOL x1 x2))))) -> ((x : (OpLoopOLTerm n)) -> (P x)))))))
    inductionOpB {_} {p} pv popol peol plinvol prinvol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol peol plinvol prinvol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol peol plinvol prinvol x1) (inductionOpB {_} {p} pv popol peol plinvol prinvol x2)) 
    inductionOpB {_} {p} pv popol peol plinvol prinvol eOL = peol 
    inductionOpB {_} {p} pv popol peol plinvol prinvol (linvOL x1 x2) = (plinvol _ _ (inductionOpB {_} {p} pv popol peol plinvol prinvol x1) (inductionOpB {_} {p} pv popol peol plinvol prinvol x2)) 
    inductionOpB {_} {p} pv popol peol plinvol prinvol (rinvOL x1 x2) = (prinvol _ _ (inductionOpB {_} {p} pv popol peol plinvol prinvol x1) (inductionOpB {_} {p} pv popol peol plinvol prinvol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpLoopOL2Term2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpLoopOL2Term2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((P eOL2) -> (((x1 x2 : (OpLoopOL2Term2 n A)) -> ((P x1) -> ((P x2) -> (P (linvOL2 x1 x2))))) -> (((x1 x2 : (OpLoopOL2Term2 n A)) -> ((P x1) -> ((P x2) -> (P (rinvOL2 x1 x2))))) -> ((x : (OpLoopOL2Term2 n A)) -> (P x))))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 prinvol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 prinvol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 prinvol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 prinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 prinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 prinvol2 eOL2 = peol2 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 prinvol2 (linvOL2 x1 x2) = (plinvol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 prinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 prinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 prinvol2 (rinvOL2 x1 x2) = (prinvol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 prinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 prinvol2 x2)) 
    opL' : (LoopLTerm -> (LoopLTerm -> LoopLTerm))
    opL' x1 x2 = (opL x1 x2) 
    eL' : LoopLTerm
    eL'  = eL 
    linvL' : (LoopLTerm -> (LoopLTerm -> LoopLTerm))
    linvL' x1 x2 = (linvL x1 x2) 
    rinvL' : (LoopLTerm -> (LoopLTerm -> LoopLTerm))
    rinvL' x1 x2 = (rinvL x1 x2) 
    stageB : (LoopLTerm -> (Staged LoopLTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB eL = (Now eL) 
    stageB (linvL x1 x2) = (stage2 linvL' (codeLift2 linvL') (stageB x1) (stageB x2)) 
    stageB (rinvL x1 x2) = (stage2 rinvL' (codeLift2 rinvL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClLoopClTerm A) -> ((ClLoopClTerm A) -> (ClLoopClTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    eCl' : {A : Set} -> (ClLoopClTerm A)
    eCl'  = eCl 
    linvCl' : {A : Set} -> ((ClLoopClTerm A) -> ((ClLoopClTerm A) -> (ClLoopClTerm A)))
    linvCl' x1 x2 = (linvCl x1 x2) 
    rinvCl' : {A : Set} -> ((ClLoopClTerm A) -> ((ClLoopClTerm A) -> (ClLoopClTerm A)))
    rinvCl' x1 x2 = (rinvCl x1 x2) 
    stageCl : {A : Set} -> ((ClLoopClTerm A) -> (Staged (ClLoopClTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl eCl = (Now eCl) 
    stageCl (linvCl x1 x2) = (stage2 linvCl' (codeLift2 linvCl') (stageCl x1) (stageCl x2)) 
    stageCl (rinvCl x1 x2) = (stage2 rinvCl' (codeLift2 rinvCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpLoopOLTerm n) -> ((OpLoopOLTerm n) -> (OpLoopOLTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    eOL' : {n : Nat} -> (OpLoopOLTerm n)
    eOL'  = eOL 
    linvOL' : {n : Nat} -> ((OpLoopOLTerm n) -> ((OpLoopOLTerm n) -> (OpLoopOLTerm n)))
    linvOL' x1 x2 = (linvOL x1 x2) 
    rinvOL' : {n : Nat} -> ((OpLoopOLTerm n) -> ((OpLoopOLTerm n) -> (OpLoopOLTerm n)))
    rinvOL' x1 x2 = (rinvOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpLoopOLTerm n) -> (Staged (OpLoopOLTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB eOL = (Now eOL) 
    stageOpB (linvOL x1 x2) = (stage2 linvOL' (codeLift2 linvOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (rinvOL x1 x2) = (stage2 rinvOL' (codeLift2 rinvOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpLoopOL2Term2 n A) -> ((OpLoopOL2Term2 n A) -> (OpLoopOL2Term2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    eOL2' : {n : Nat} {A : Set} -> (OpLoopOL2Term2 n A)
    eOL2'  = eOL2 
    linvOL2' : {n : Nat} {A : Set} -> ((OpLoopOL2Term2 n A) -> ((OpLoopOL2Term2 n A) -> (OpLoopOL2Term2 n A)))
    linvOL2' x1 x2 = (linvOL2 x1 x2) 
    rinvOL2' : {n : Nat} {A : Set} -> ((OpLoopOL2Term2 n A) -> ((OpLoopOL2Term2 n A) -> (OpLoopOL2Term2 n A)))
    rinvOL2' x1 x2 = (rinvOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpLoopOL2Term2 n A) -> (Staged (OpLoopOL2Term2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp eOL2 = (Now eOL2) 
    stageOp (linvOL2 x1 x2) = (stage2 linvOL2' (codeLift2 linvOL2') (stageOp x1) (stageOp x2)) 
    stageOp (rinvOL2 x1 x2) = (stage2 rinvOL2' (codeLift2 rinvOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        eT : (Repr A)
        linvT : ((Repr A) -> ((Repr A) -> (Repr A)))
        rinvT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module Magma  where
    record Magma (A : Set) : Set where
      constructor MagmaC
      field
        op : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
    record Hom {A1 : Set} {A2 : Set} (Ma1 : (Magma A1)) (Ma2 : (Magma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Ma1) x1 x2)) == ((op Ma2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ma1 : (Magma A1)) (Ma2 : (Magma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Ma1) x1 x2) ((op Ma2) y1 y2))))
    data MagmaTerm  : Set where
      opL : (MagmaTerm -> (MagmaTerm -> MagmaTerm))
    data ClMagmaTerm (A : Set) : Set where
      sing : (A -> (ClMagmaTerm A))
      opCl : ((ClMagmaTerm A) -> ((ClMagmaTerm A) -> (ClMagmaTerm A)))
    data OpMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpMagmaTerm n))
      opOL : ((OpMagmaTerm n) -> ((OpMagmaTerm n) -> (OpMagmaTerm n)))
    data OpMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpMagmaTerm2 n A))
      sing2 : (A -> (OpMagmaTerm2 n A))
      opOL2 : ((OpMagmaTerm2 n A) -> ((OpMagmaTerm2 n A) -> (OpMagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClMagmaTerm A) -> (ClMagmaTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpMagmaTerm n) -> (OpMagmaTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpMagmaTerm2 n A) -> (OpMagmaTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Magma A) -> (MagmaTerm -> A))
    evalB Ma (opL x1 x2) = ((op Ma) (evalB Ma x1) (evalB Ma x2)) 
    evalCl : {A : Set} -> ((Magma A) -> ((ClMagmaTerm A) -> A))
    evalCl Ma (sing x1) = x1 
    evalCl Ma (opCl x1 x2) = ((op Ma) (evalCl Ma x1) (evalCl Ma x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Magma A) -> ((Vec A n) -> ((OpMagmaTerm n) -> A)))
    evalOpB Ma vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ma vars (opOL x1 x2) = ((op Ma) (evalOpB Ma vars x1) (evalOpB Ma vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Magma A) -> ((Vec A n) -> ((OpMagmaTerm2 n A) -> A)))
    evalOp Ma vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ma vars (sing2 x1) = x1 
    evalOp Ma vars (opOL2 x1 x2) = ((op Ma) (evalOp Ma vars x1) (evalOp Ma vars x2)) 
    inductionB : {P : (MagmaTerm -> Set)} -> (((x1 x2 : MagmaTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : MagmaTerm) -> (P x)))
    inductionB {p} popl (opL x1 x2) = (popl _ _ (inductionB {p} popl x1) (inductionB {p} popl x2)) 
    inductionCl : {A : Set} {P : ((ClMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClMagmaTerm A)) -> (P x))))
    inductionCl {_} {p} psing popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl x1) (inductionCl {_} {p} psing popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpMagmaTerm n)) -> (P x))))
    inductionOpB {_} {p} pv popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol x1) (inductionOpB {_} {p} pv popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpMagmaTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 x2)) 
    opL' : (MagmaTerm -> (MagmaTerm -> MagmaTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (MagmaTerm -> (Staged MagmaTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClMagmaTerm A) -> ((ClMagmaTerm A) -> (ClMagmaTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClMagmaTerm A) -> (Staged (ClMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpMagmaTerm n) -> ((OpMagmaTerm n) -> (OpMagmaTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpMagmaTerm n) -> (Staged (OpMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpMagmaTerm2 n A) -> ((OpMagmaTerm2 n A) -> (OpMagmaTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpMagmaTerm2 n A) -> (Staged (OpMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module MedialMagma  where
    record MedialMagma (A : Set) : Set where
      constructor MedialMagmaC
      field
        op : (A -> (A -> A))
        mediates : {w x y z : A} -> (op (op x y) (op z w)) == (op (op x z) (op y w))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        mediatesP : {wP xP yP zP : (Prod A A)} -> (opP (opP xP yP) (opP zP wP)) == (opP (opP xP zP) (opP yP wP))
    record Hom {A1 : Set} {A2 : Set} (Me1 : (MedialMagma A1)) (Me2 : (MedialMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Me1) x1 x2)) == ((op Me2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Me1 : (MedialMagma A1)) (Me2 : (MedialMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Me1) x1 x2) ((op Me2) y1 y2))))
    data MedialMagmaTerm  : Set where
      opL : (MedialMagmaTerm -> (MedialMagmaTerm -> MedialMagmaTerm))
    data ClMedialMagmaTerm (A : Set) : Set where
      sing : (A -> (ClMedialMagmaTerm A))
      opCl : ((ClMedialMagmaTerm A) -> ((ClMedialMagmaTerm A) -> (ClMedialMagmaTerm A)))
    data OpMedialMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpMedialMagmaTerm n))
      opOL : ((OpMedialMagmaTerm n) -> ((OpMedialMagmaTerm n) -> (OpMedialMagmaTerm n)))
    data OpMedialMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpMedialMagmaTerm2 n A))
      sing2 : (A -> (OpMedialMagmaTerm2 n A))
      opOL2 : ((OpMedialMagmaTerm2 n A) -> ((OpMedialMagmaTerm2 n A) -> (OpMedialMagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClMedialMagmaTerm A) -> (ClMedialMagmaTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpMedialMagmaTerm n) -> (OpMedialMagmaTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpMedialMagmaTerm2 n A) -> (OpMedialMagmaTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((MedialMagma A) -> (MedialMagmaTerm -> A))
    evalB Me (opL x1 x2) = ((op Me) (evalB Me x1) (evalB Me x2)) 
    evalCl : {A : Set} -> ((MedialMagma A) -> ((ClMedialMagmaTerm A) -> A))
    evalCl Me (sing x1) = x1 
    evalCl Me (opCl x1 x2) = ((op Me) (evalCl Me x1) (evalCl Me x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((MedialMagma A) -> ((Vec A n) -> ((OpMedialMagmaTerm n) -> A)))
    evalOpB Me vars (v x1) = (lookup _ x1 vars) 
    evalOpB Me vars (opOL x1 x2) = ((op Me) (evalOpB Me vars x1) (evalOpB Me vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((MedialMagma A) -> ((Vec A n) -> ((OpMedialMagmaTerm2 n A) -> A)))
    evalOp Me vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Me vars (sing2 x1) = x1 
    evalOp Me vars (opOL2 x1 x2) = ((op Me) (evalOp Me vars x1) (evalOp Me vars x2)) 
    inductionB : {P : (MedialMagmaTerm -> Set)} -> (((x1 x2 : MedialMagmaTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : MedialMagmaTerm) -> (P x)))
    inductionB {p} popl (opL x1 x2) = (popl _ _ (inductionB {p} popl x1) (inductionB {p} popl x2)) 
    inductionCl : {A : Set} {P : ((ClMedialMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClMedialMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClMedialMagmaTerm A)) -> (P x))))
    inductionCl {_} {p} psing popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl x1) (inductionCl {_} {p} psing popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpMedialMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpMedialMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpMedialMagmaTerm n)) -> (P x))))
    inductionOpB {_} {p} pv popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol x1) (inductionOpB {_} {p} pv popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpMedialMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpMedialMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpMedialMagmaTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 x2)) 
    opL' : (MedialMagmaTerm -> (MedialMagmaTerm -> MedialMagmaTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (MedialMagmaTerm -> (Staged MedialMagmaTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClMedialMagmaTerm A) -> ((ClMedialMagmaTerm A) -> (ClMedialMagmaTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClMedialMagmaTerm A) -> (Staged (ClMedialMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpMedialMagmaTerm n) -> ((OpMedialMagmaTerm n) -> (OpMedialMagmaTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpMedialMagmaTerm n) -> (Staged (OpMedialMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpMedialMagmaTerm2 n A) -> ((OpMedialMagmaTerm2 n A) -> (OpMedialMagmaTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpMedialMagmaTerm2 n A) -> (Staged (OpMedialMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module MedialQuasiGroup  where
    record MedialQuasiGroup (A : Set) : Set where
      constructor MedialQuasiGroupC
      field
        op : (A -> (A -> A))
        linv : (A -> (A -> A))
        leftCancel : {x y : A} -> (op x (linv x y)) == y
        lefCancelOp : {x y : A} -> (linv x (op x y)) == y
        rinv : (A -> (A -> A))
        rightCancel : {x y : A} -> (op (rinv y x) x) == y
        rightCancelOp : {x y : A} -> (rinv (op y x) x) == y
        mediates : {w x y z : A} -> (op (op x y) (op z w)) == (op (op x z) (op y w))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        linvS : (AS -> (AS -> AS))
        rinvS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        linvP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        rinvP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftCancelP : {xP yP : (Prod A A)} -> (opP xP (linvP xP yP)) == yP
        lefCancelOpP : {xP yP : (Prod A A)} -> (linvP xP (opP xP yP)) == yP
        rightCancelP : {xP yP : (Prod A A)} -> (opP (rinvP yP xP) xP) == yP
        rightCancelOpP : {xP yP : (Prod A A)} -> (rinvP (opP yP xP) xP) == yP
        mediatesP : {wP xP yP zP : (Prod A A)} -> (opP (opP xP yP) (opP zP wP)) == (opP (opP xP zP) (opP yP wP))
    record Hom {A1 : Set} {A2 : Set} (Me1 : (MedialQuasiGroup A1)) (Me2 : (MedialQuasiGroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Me1) x1 x2)) == ((op Me2) (hom x1) (hom x2))
        pres-linv : {x1 x2 : A1} -> (hom ((linv Me1) x1 x2)) == ((linv Me2) (hom x1) (hom x2))
        pres-rinv : {x1 x2 : A1} -> (hom ((rinv Me1) x1 x2)) == ((rinv Me2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Me1 : (MedialQuasiGroup A1)) (Me2 : (MedialQuasiGroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Me1) x1 x2) ((op Me2) y1 y2))))
        interp-linv : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((linv Me1) x1 x2) ((linv Me2) y1 y2))))
        interp-rinv : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((rinv Me1) x1 x2) ((rinv Me2) y1 y2))))
    data MedialQuasiGroupTerm  : Set where
      opL : (MedialQuasiGroupTerm -> (MedialQuasiGroupTerm -> MedialQuasiGroupTerm))
      linvL : (MedialQuasiGroupTerm -> (MedialQuasiGroupTerm -> MedialQuasiGroupTerm))
      rinvL : (MedialQuasiGroupTerm -> (MedialQuasiGroupTerm -> MedialQuasiGroupTerm))
    data ClMedialQuasiGroupTerm (A : Set) : Set where
      sing : (A -> (ClMedialQuasiGroupTerm A))
      opCl : ((ClMedialQuasiGroupTerm A) -> ((ClMedialQuasiGroupTerm A) -> (ClMedialQuasiGroupTerm A)))
      linvCl : ((ClMedialQuasiGroupTerm A) -> ((ClMedialQuasiGroupTerm A) -> (ClMedialQuasiGroupTerm A)))
      rinvCl : ((ClMedialQuasiGroupTerm A) -> ((ClMedialQuasiGroupTerm A) -> (ClMedialQuasiGroupTerm A)))
    data OpMedialQuasiGroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpMedialQuasiGroupTerm n))
      opOL : ((OpMedialQuasiGroupTerm n) -> ((OpMedialQuasiGroupTerm n) -> (OpMedialQuasiGroupTerm n)))
      linvOL : ((OpMedialQuasiGroupTerm n) -> ((OpMedialQuasiGroupTerm n) -> (OpMedialQuasiGroupTerm n)))
      rinvOL : ((OpMedialQuasiGroupTerm n) -> ((OpMedialQuasiGroupTerm n) -> (OpMedialQuasiGroupTerm n)))
    data OpMedialQuasiGroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpMedialQuasiGroupTerm2 n A))
      sing2 : (A -> (OpMedialQuasiGroupTerm2 n A))
      opOL2 : ((OpMedialQuasiGroupTerm2 n A) -> ((OpMedialQuasiGroupTerm2 n A) -> (OpMedialQuasiGroupTerm2 n A)))
      linvOL2 : ((OpMedialQuasiGroupTerm2 n A) -> ((OpMedialQuasiGroupTerm2 n A) -> (OpMedialQuasiGroupTerm2 n A)))
      rinvOL2 : ((OpMedialQuasiGroupTerm2 n A) -> ((OpMedialQuasiGroupTerm2 n A) -> (OpMedialQuasiGroupTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClMedialQuasiGroupTerm A) -> (ClMedialQuasiGroupTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (linvCl x1 x2) = (linvCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (rinvCl x1 x2) = (rinvCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpMedialQuasiGroupTerm n) -> (OpMedialQuasiGroupTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (linvOL x1 x2) = (linvOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (rinvOL x1 x2) = (rinvOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpMedialQuasiGroupTerm2 n A) -> (OpMedialQuasiGroupTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (linvOL2 x1 x2) = (linvOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (rinvOL2 x1 x2) = (rinvOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((MedialQuasiGroup A) -> (MedialQuasiGroupTerm -> A))
    evalB Me (opL x1 x2) = ((op Me) (evalB Me x1) (evalB Me x2)) 
    evalB Me (linvL x1 x2) = ((linv Me) (evalB Me x1) (evalB Me x2)) 
    evalB Me (rinvL x1 x2) = ((rinv Me) (evalB Me x1) (evalB Me x2)) 
    evalCl : {A : Set} -> ((MedialQuasiGroup A) -> ((ClMedialQuasiGroupTerm A) -> A))
    evalCl Me (sing x1) = x1 
    evalCl Me (opCl x1 x2) = ((op Me) (evalCl Me x1) (evalCl Me x2)) 
    evalCl Me (linvCl x1 x2) = ((linv Me) (evalCl Me x1) (evalCl Me x2)) 
    evalCl Me (rinvCl x1 x2) = ((rinv Me) (evalCl Me x1) (evalCl Me x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((MedialQuasiGroup A) -> ((Vec A n) -> ((OpMedialQuasiGroupTerm n) -> A)))
    evalOpB Me vars (v x1) = (lookup _ x1 vars) 
    evalOpB Me vars (opOL x1 x2) = ((op Me) (evalOpB Me vars x1) (evalOpB Me vars x2)) 
    evalOpB Me vars (linvOL x1 x2) = ((linv Me) (evalOpB Me vars x1) (evalOpB Me vars x2)) 
    evalOpB Me vars (rinvOL x1 x2) = ((rinv Me) (evalOpB Me vars x1) (evalOpB Me vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((MedialQuasiGroup A) -> ((Vec A n) -> ((OpMedialQuasiGroupTerm2 n A) -> A)))
    evalOp Me vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Me vars (sing2 x1) = x1 
    evalOp Me vars (opOL2 x1 x2) = ((op Me) (evalOp Me vars x1) (evalOp Me vars x2)) 
    evalOp Me vars (linvOL2 x1 x2) = ((linv Me) (evalOp Me vars x1) (evalOp Me vars x2)) 
    evalOp Me vars (rinvOL2 x1 x2) = ((rinv Me) (evalOp Me vars x1) (evalOp Me vars x2)) 
    inductionB : {P : (MedialQuasiGroupTerm -> Set)} -> (((x1 x2 : MedialQuasiGroupTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> (((x1 x2 : MedialQuasiGroupTerm) -> ((P x1) -> ((P x2) -> (P (linvL x1 x2))))) -> (((x1 x2 : MedialQuasiGroupTerm) -> ((P x1) -> ((P x2) -> (P (rinvL x1 x2))))) -> ((x : MedialQuasiGroupTerm) -> (P x)))))
    inductionB {p} popl plinvl prinvl (opL x1 x2) = (popl _ _ (inductionB {p} popl plinvl prinvl x1) (inductionB {p} popl plinvl prinvl x2)) 
    inductionB {p} popl plinvl prinvl (linvL x1 x2) = (plinvl _ _ (inductionB {p} popl plinvl prinvl x1) (inductionB {p} popl plinvl prinvl x2)) 
    inductionB {p} popl plinvl prinvl (rinvL x1 x2) = (prinvl _ _ (inductionB {p} popl plinvl prinvl x1) (inductionB {p} popl plinvl prinvl x2)) 
    inductionCl : {A : Set} {P : ((ClMedialQuasiGroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClMedialQuasiGroupTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> (((x1 x2 : (ClMedialQuasiGroupTerm A)) -> ((P x1) -> ((P x2) -> (P (linvCl x1 x2))))) -> (((x1 x2 : (ClMedialQuasiGroupTerm A)) -> ((P x1) -> ((P x2) -> (P (rinvCl x1 x2))))) -> ((x : (ClMedialQuasiGroupTerm A)) -> (P x))))))
    inductionCl {_} {p} psing popcl plinvcl prinvcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl plinvcl prinvcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl plinvcl prinvcl x1) (inductionCl {_} {p} psing popcl plinvcl prinvcl x2)) 
    inductionCl {_} {p} psing popcl plinvcl prinvcl (linvCl x1 x2) = (plinvcl _ _ (inductionCl {_} {p} psing popcl plinvcl prinvcl x1) (inductionCl {_} {p} psing popcl plinvcl prinvcl x2)) 
    inductionCl {_} {p} psing popcl plinvcl prinvcl (rinvCl x1 x2) = (prinvcl _ _ (inductionCl {_} {p} psing popcl plinvcl prinvcl x1) (inductionCl {_} {p} psing popcl plinvcl prinvcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpMedialQuasiGroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpMedialQuasiGroupTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> (((x1 x2 : (OpMedialQuasiGroupTerm n)) -> ((P x1) -> ((P x2) -> (P (linvOL x1 x2))))) -> (((x1 x2 : (OpMedialQuasiGroupTerm n)) -> ((P x1) -> ((P x2) -> (P (rinvOL x1 x2))))) -> ((x : (OpMedialQuasiGroupTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv popol plinvol prinvol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol plinvol prinvol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol plinvol prinvol x1) (inductionOpB {_} {p} pv popol plinvol prinvol x2)) 
    inductionOpB {_} {p} pv popol plinvol prinvol (linvOL x1 x2) = (plinvol _ _ (inductionOpB {_} {p} pv popol plinvol prinvol x1) (inductionOpB {_} {p} pv popol plinvol prinvol x2)) 
    inductionOpB {_} {p} pv popol plinvol prinvol (rinvOL x1 x2) = (prinvol _ _ (inductionOpB {_} {p} pv popol plinvol prinvol x1) (inductionOpB {_} {p} pv popol plinvol prinvol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpMedialQuasiGroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpMedialQuasiGroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> (((x1 x2 : (OpMedialQuasiGroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (linvOL2 x1 x2))))) -> (((x1 x2 : (OpMedialQuasiGroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (rinvOL2 x1 x2))))) -> ((x : (OpMedialQuasiGroupTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 (linvOL2 x1 x2) = (plinvol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 (rinvOL2 x1 x2) = (prinvol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 x2)) 
    opL' : (MedialQuasiGroupTerm -> (MedialQuasiGroupTerm -> MedialQuasiGroupTerm))
    opL' x1 x2 = (opL x1 x2) 
    linvL' : (MedialQuasiGroupTerm -> (MedialQuasiGroupTerm -> MedialQuasiGroupTerm))
    linvL' x1 x2 = (linvL x1 x2) 
    rinvL' : (MedialQuasiGroupTerm -> (MedialQuasiGroupTerm -> MedialQuasiGroupTerm))
    rinvL' x1 x2 = (rinvL x1 x2) 
    stageB : (MedialQuasiGroupTerm -> (Staged MedialQuasiGroupTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB (linvL x1 x2) = (stage2 linvL' (codeLift2 linvL') (stageB x1) (stageB x2)) 
    stageB (rinvL x1 x2) = (stage2 rinvL' (codeLift2 rinvL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClMedialQuasiGroupTerm A) -> ((ClMedialQuasiGroupTerm A) -> (ClMedialQuasiGroupTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    linvCl' : {A : Set} -> ((ClMedialQuasiGroupTerm A) -> ((ClMedialQuasiGroupTerm A) -> (ClMedialQuasiGroupTerm A)))
    linvCl' x1 x2 = (linvCl x1 x2) 
    rinvCl' : {A : Set} -> ((ClMedialQuasiGroupTerm A) -> ((ClMedialQuasiGroupTerm A) -> (ClMedialQuasiGroupTerm A)))
    rinvCl' x1 x2 = (rinvCl x1 x2) 
    stageCl : {A : Set} -> ((ClMedialQuasiGroupTerm A) -> (Staged (ClMedialQuasiGroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl (linvCl x1 x2) = (stage2 linvCl' (codeLift2 linvCl') (stageCl x1) (stageCl x2)) 
    stageCl (rinvCl x1 x2) = (stage2 rinvCl' (codeLift2 rinvCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpMedialQuasiGroupTerm n) -> ((OpMedialQuasiGroupTerm n) -> (OpMedialQuasiGroupTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    linvOL' : {n : Nat} -> ((OpMedialQuasiGroupTerm n) -> ((OpMedialQuasiGroupTerm n) -> (OpMedialQuasiGroupTerm n)))
    linvOL' x1 x2 = (linvOL x1 x2) 
    rinvOL' : {n : Nat} -> ((OpMedialQuasiGroupTerm n) -> ((OpMedialQuasiGroupTerm n) -> (OpMedialQuasiGroupTerm n)))
    rinvOL' x1 x2 = (rinvOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpMedialQuasiGroupTerm n) -> (Staged (OpMedialQuasiGroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (linvOL x1 x2) = (stage2 linvOL' (codeLift2 linvOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (rinvOL x1 x2) = (stage2 rinvOL' (codeLift2 rinvOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpMedialQuasiGroupTerm2 n A) -> ((OpMedialQuasiGroupTerm2 n A) -> (OpMedialQuasiGroupTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    linvOL2' : {n : Nat} {A : Set} -> ((OpMedialQuasiGroupTerm2 n A) -> ((OpMedialQuasiGroupTerm2 n A) -> (OpMedialQuasiGroupTerm2 n A)))
    linvOL2' x1 x2 = (linvOL2 x1 x2) 
    rinvOL2' : {n : Nat} {A : Set} -> ((OpMedialQuasiGroupTerm2 n A) -> ((OpMedialQuasiGroupTerm2 n A) -> (OpMedialQuasiGroupTerm2 n A)))
    rinvOL2' x1 x2 = (rinvOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpMedialQuasiGroupTerm2 n A) -> (Staged (OpMedialQuasiGroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp (linvOL2 x1 x2) = (stage2 linvOL2' (codeLift2 linvOL2') (stageOp x1) (stageOp x2)) 
    stageOp (rinvOL2 x1 x2) = (stage2 rinvOL2' (codeLift2 rinvOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        linvT : ((Repr A) -> ((Repr A) -> (Repr A)))
        rinvT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module MeetSemilattice  where
    record MeetSemilattice (A : Set) : Set where
      constructor MeetSemilatticeC
      field
        op : (A -> (A -> A))
        associative_op : {x y z : A} -> (op (op x y) z) == (op x (op y z))
        idempotent_op : {x : A} -> (op x x) == x
        commutative_op : {x y : A} -> (op x y) == (op y x)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        associative_opP : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP (opP yP zP))
        idempotent_opP : {xP : (Prod A A)} -> (opP xP xP) == xP
        commutative_opP : {xP yP : (Prod A A)} -> (opP xP yP) == (opP yP xP)
    record Hom {A1 : Set} {A2 : Set} (Me1 : (MeetSemilattice A1)) (Me2 : (MeetSemilattice A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Me1) x1 x2)) == ((op Me2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Me1 : (MeetSemilattice A1)) (Me2 : (MeetSemilattice A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Me1) x1 x2) ((op Me2) y1 y2))))
    data MeetSemilatticeTerm  : Set where
      opL : (MeetSemilatticeTerm -> (MeetSemilatticeTerm -> MeetSemilatticeTerm))
    data ClMeetSemilatticeTerm (A : Set) : Set where
      sing : (A -> (ClMeetSemilatticeTerm A))
      opCl : ((ClMeetSemilatticeTerm A) -> ((ClMeetSemilatticeTerm A) -> (ClMeetSemilatticeTerm A)))
    data OpMeetSemilatticeTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpMeetSemilatticeTerm n))
      opOL : ((OpMeetSemilatticeTerm n) -> ((OpMeetSemilatticeTerm n) -> (OpMeetSemilatticeTerm n)))
    data OpMeetSemilatticeTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpMeetSemilatticeTerm2 n A))
      sing2 : (A -> (OpMeetSemilatticeTerm2 n A))
      opOL2 : ((OpMeetSemilatticeTerm2 n A) -> ((OpMeetSemilatticeTerm2 n A) -> (OpMeetSemilatticeTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClMeetSemilatticeTerm A) -> (ClMeetSemilatticeTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpMeetSemilatticeTerm n) -> (OpMeetSemilatticeTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpMeetSemilatticeTerm2 n A) -> (OpMeetSemilatticeTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((MeetSemilattice A) -> (MeetSemilatticeTerm -> A))
    evalB Me (opL x1 x2) = ((op Me) (evalB Me x1) (evalB Me x2)) 
    evalCl : {A : Set} -> ((MeetSemilattice A) -> ((ClMeetSemilatticeTerm A) -> A))
    evalCl Me (sing x1) = x1 
    evalCl Me (opCl x1 x2) = ((op Me) (evalCl Me x1) (evalCl Me x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((MeetSemilattice A) -> ((Vec A n) -> ((OpMeetSemilatticeTerm n) -> A)))
    evalOpB Me vars (v x1) = (lookup _ x1 vars) 
    evalOpB Me vars (opOL x1 x2) = ((op Me) (evalOpB Me vars x1) (evalOpB Me vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((MeetSemilattice A) -> ((Vec A n) -> ((OpMeetSemilatticeTerm2 n A) -> A)))
    evalOp Me vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Me vars (sing2 x1) = x1 
    evalOp Me vars (opOL2 x1 x2) = ((op Me) (evalOp Me vars x1) (evalOp Me vars x2)) 
    inductionB : {P : (MeetSemilatticeTerm -> Set)} -> (((x1 x2 : MeetSemilatticeTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : MeetSemilatticeTerm) -> (P x)))
    inductionB {p} popl (opL x1 x2) = (popl _ _ (inductionB {p} popl x1) (inductionB {p} popl x2)) 
    inductionCl : {A : Set} {P : ((ClMeetSemilatticeTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClMeetSemilatticeTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClMeetSemilatticeTerm A)) -> (P x))))
    inductionCl {_} {p} psing popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl x1) (inductionCl {_} {p} psing popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpMeetSemilatticeTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpMeetSemilatticeTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpMeetSemilatticeTerm n)) -> (P x))))
    inductionOpB {_} {p} pv popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol x1) (inductionOpB {_} {p} pv popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpMeetSemilatticeTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpMeetSemilatticeTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpMeetSemilatticeTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 x2)) 
    opL' : (MeetSemilatticeTerm -> (MeetSemilatticeTerm -> MeetSemilatticeTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (MeetSemilatticeTerm -> (Staged MeetSemilatticeTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClMeetSemilatticeTerm A) -> ((ClMeetSemilatticeTerm A) -> (ClMeetSemilatticeTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClMeetSemilatticeTerm A) -> (Staged (ClMeetSemilatticeTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpMeetSemilatticeTerm n) -> ((OpMeetSemilatticeTerm n) -> (OpMeetSemilatticeTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpMeetSemilatticeTerm n) -> (Staged (OpMeetSemilatticeTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpMeetSemilatticeTerm2 n A) -> ((OpMeetSemilatticeTerm2 n A) -> (OpMeetSemilatticeTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpMeetSemilatticeTerm2 n A) -> (Staged (OpMeetSemilatticeTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module MiddleAbsorption  where
    record MiddleAbsorption (A : Set) : Set where
      constructor MiddleAbsorptionC
      field
        op : (A -> (A -> A))
        middleAbsorb_* : {x y z : A} -> (op (op x y) z) == (op x z)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        middleAbsorb_*P : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP zP)
    record Hom {A1 : Set} {A2 : Set} (Mi1 : (MiddleAbsorption A1)) (Mi2 : (MiddleAbsorption A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Mi1) x1 x2)) == ((op Mi2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Mi1 : (MiddleAbsorption A1)) (Mi2 : (MiddleAbsorption A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Mi1) x1 x2) ((op Mi2) y1 y2))))
    data MiddleAbsorptionTerm  : Set where
      opL : (MiddleAbsorptionTerm -> (MiddleAbsorptionTerm -> MiddleAbsorptionTerm))
    data ClMiddleAbsorptionTerm (A : Set) : Set where
      sing : (A -> (ClMiddleAbsorptionTerm A))
      opCl : ((ClMiddleAbsorptionTerm A) -> ((ClMiddleAbsorptionTerm A) -> (ClMiddleAbsorptionTerm A)))
    data OpMiddleAbsorptionTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpMiddleAbsorptionTerm n))
      opOL : ((OpMiddleAbsorptionTerm n) -> ((OpMiddleAbsorptionTerm n) -> (OpMiddleAbsorptionTerm n)))
    data OpMiddleAbsorptionTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpMiddleAbsorptionTerm2 n A))
      sing2 : (A -> (OpMiddleAbsorptionTerm2 n A))
      opOL2 : ((OpMiddleAbsorptionTerm2 n A) -> ((OpMiddleAbsorptionTerm2 n A) -> (OpMiddleAbsorptionTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClMiddleAbsorptionTerm A) -> (ClMiddleAbsorptionTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpMiddleAbsorptionTerm n) -> (OpMiddleAbsorptionTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpMiddleAbsorptionTerm2 n A) -> (OpMiddleAbsorptionTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((MiddleAbsorption A) -> (MiddleAbsorptionTerm -> A))
    evalB Mi (opL x1 x2) = ((op Mi) (evalB Mi x1) (evalB Mi x2)) 
    evalCl : {A : Set} -> ((MiddleAbsorption A) -> ((ClMiddleAbsorptionTerm A) -> A))
    evalCl Mi (sing x1) = x1 
    evalCl Mi (opCl x1 x2) = ((op Mi) (evalCl Mi x1) (evalCl Mi x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((MiddleAbsorption A) -> ((Vec A n) -> ((OpMiddleAbsorptionTerm n) -> A)))
    evalOpB Mi vars (v x1) = (lookup _ x1 vars) 
    evalOpB Mi vars (opOL x1 x2) = ((op Mi) (evalOpB Mi vars x1) (evalOpB Mi vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((MiddleAbsorption A) -> ((Vec A n) -> ((OpMiddleAbsorptionTerm2 n A) -> A)))
    evalOp Mi vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Mi vars (sing2 x1) = x1 
    evalOp Mi vars (opOL2 x1 x2) = ((op Mi) (evalOp Mi vars x1) (evalOp Mi vars x2)) 
    inductionB : {P : (MiddleAbsorptionTerm -> Set)} -> (((x1 x2 : MiddleAbsorptionTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : MiddleAbsorptionTerm) -> (P x)))
    inductionB {p} popl (opL x1 x2) = (popl _ _ (inductionB {p} popl x1) (inductionB {p} popl x2)) 
    inductionCl : {A : Set} {P : ((ClMiddleAbsorptionTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClMiddleAbsorptionTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClMiddleAbsorptionTerm A)) -> (P x))))
    inductionCl {_} {p} psing popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl x1) (inductionCl {_} {p} psing popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpMiddleAbsorptionTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpMiddleAbsorptionTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpMiddleAbsorptionTerm n)) -> (P x))))
    inductionOpB {_} {p} pv popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol x1) (inductionOpB {_} {p} pv popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpMiddleAbsorptionTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpMiddleAbsorptionTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpMiddleAbsorptionTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 x2)) 
    opL' : (MiddleAbsorptionTerm -> (MiddleAbsorptionTerm -> MiddleAbsorptionTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (MiddleAbsorptionTerm -> (Staged MiddleAbsorptionTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClMiddleAbsorptionTerm A) -> ((ClMiddleAbsorptionTerm A) -> (ClMiddleAbsorptionTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClMiddleAbsorptionTerm A) -> (Staged (ClMiddleAbsorptionTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpMiddleAbsorptionTerm n) -> ((OpMiddleAbsorptionTerm n) -> (OpMiddleAbsorptionTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpMiddleAbsorptionTerm n) -> (Staged (OpMiddleAbsorptionTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpMiddleAbsorptionTerm2 n A) -> ((OpMiddleAbsorptionTerm2 n A) -> (OpMiddleAbsorptionTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpMiddleAbsorptionTerm2 n A) -> (Staged (OpMiddleAbsorptionTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module MiddleCommute  where
    record MiddleCommute (A : Set) : Set where
      constructor MiddleCommuteC
      field
        op : (A -> (A -> A))
        middleCommute_* : {x y z : A} -> (op (op (op x y) z) x) == (op (op (op x z) y) x)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        middleCommute_*P : {xP yP zP : (Prod A A)} -> (opP (opP (opP xP yP) zP) xP) == (opP (opP (opP xP zP) yP) xP)
    record Hom {A1 : Set} {A2 : Set} (Mi1 : (MiddleCommute A1)) (Mi2 : (MiddleCommute A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Mi1) x1 x2)) == ((op Mi2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Mi1 : (MiddleCommute A1)) (Mi2 : (MiddleCommute A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Mi1) x1 x2) ((op Mi2) y1 y2))))
    data MiddleCommuteTerm  : Set where
      opL : (MiddleCommuteTerm -> (MiddleCommuteTerm -> MiddleCommuteTerm))
    data ClMiddleCommuteTerm (A : Set) : Set where
      sing : (A -> (ClMiddleCommuteTerm A))
      opCl : ((ClMiddleCommuteTerm A) -> ((ClMiddleCommuteTerm A) -> (ClMiddleCommuteTerm A)))
    data OpMiddleCommuteTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpMiddleCommuteTerm n))
      opOL : ((OpMiddleCommuteTerm n) -> ((OpMiddleCommuteTerm n) -> (OpMiddleCommuteTerm n)))
    data OpMiddleCommuteTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpMiddleCommuteTerm2 n A))
      sing2 : (A -> (OpMiddleCommuteTerm2 n A))
      opOL2 : ((OpMiddleCommuteTerm2 n A) -> ((OpMiddleCommuteTerm2 n A) -> (OpMiddleCommuteTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClMiddleCommuteTerm A) -> (ClMiddleCommuteTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpMiddleCommuteTerm n) -> (OpMiddleCommuteTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpMiddleCommuteTerm2 n A) -> (OpMiddleCommuteTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((MiddleCommute A) -> (MiddleCommuteTerm -> A))
    evalB Mi (opL x1 x2) = ((op Mi) (evalB Mi x1) (evalB Mi x2)) 
    evalCl : {A : Set} -> ((MiddleCommute A) -> ((ClMiddleCommuteTerm A) -> A))
    evalCl Mi (sing x1) = x1 
    evalCl Mi (opCl x1 x2) = ((op Mi) (evalCl Mi x1) (evalCl Mi x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((MiddleCommute A) -> ((Vec A n) -> ((OpMiddleCommuteTerm n) -> A)))
    evalOpB Mi vars (v x1) = (lookup _ x1 vars) 
    evalOpB Mi vars (opOL x1 x2) = ((op Mi) (evalOpB Mi vars x1) (evalOpB Mi vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((MiddleCommute A) -> ((Vec A n) -> ((OpMiddleCommuteTerm2 n A) -> A)))
    evalOp Mi vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Mi vars (sing2 x1) = x1 
    evalOp Mi vars (opOL2 x1 x2) = ((op Mi) (evalOp Mi vars x1) (evalOp Mi vars x2)) 
    inductionB : {P : (MiddleCommuteTerm -> Set)} -> (((x1 x2 : MiddleCommuteTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : MiddleCommuteTerm) -> (P x)))
    inductionB {p} popl (opL x1 x2) = (popl _ _ (inductionB {p} popl x1) (inductionB {p} popl x2)) 
    inductionCl : {A : Set} {P : ((ClMiddleCommuteTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClMiddleCommuteTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClMiddleCommuteTerm A)) -> (P x))))
    inductionCl {_} {p} psing popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl x1) (inductionCl {_} {p} psing popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpMiddleCommuteTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpMiddleCommuteTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpMiddleCommuteTerm n)) -> (P x))))
    inductionOpB {_} {p} pv popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol x1) (inductionOpB {_} {p} pv popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpMiddleCommuteTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpMiddleCommuteTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpMiddleCommuteTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 x2)) 
    opL' : (MiddleCommuteTerm -> (MiddleCommuteTerm -> MiddleCommuteTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (MiddleCommuteTerm -> (Staged MiddleCommuteTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClMiddleCommuteTerm A) -> ((ClMiddleCommuteTerm A) -> (ClMiddleCommuteTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClMiddleCommuteTerm A) -> (Staged (ClMiddleCommuteTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpMiddleCommuteTerm n) -> ((OpMiddleCommuteTerm n) -> (OpMiddleCommuteTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpMiddleCommuteTerm n) -> (Staged (OpMiddleCommuteTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpMiddleCommuteTerm2 n A) -> ((OpMiddleCommuteTerm2 n A) -> (OpMiddleCommuteTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpMiddleCommuteTerm2 n A) -> (Staged (OpMiddleCommuteTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module ModularLattice  where
    record ModularLattice (A : Set) : Set where
      constructor ModularLatticeC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        commutative_* : {x y : A} -> (* x y) == (* y x)
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        idempotent_* : {x : A} -> (* x x) == x
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        idempotent_+ : {x : A} -> (+ x x) == x
        leftAbsorp_*_+ : {x y : A} -> (* x (+ x y)) == x
        leftAbsorp_+_* : {x y : A} -> (+ x (* x y)) == x
        leftModular_*_+ : {x y z : A} -> (+ (* x y) (* x z)) == (* x (+ y (* x z)))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        commutative_*P : {xP yP : (Prod A A)} -> (*P xP yP) == (*P yP xP)
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        idempotent_*P : {xP : (Prod A A)} -> (*P xP xP) == xP
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        idempotent_+P : {xP : (Prod A A)} -> (+P xP xP) == xP
        leftAbsorp_*_+P : {xP yP : (Prod A A)} -> (*P xP (+P xP yP)) == xP
        leftAbsorp_+_*P : {xP yP : (Prod A A)} -> (+P xP (*P xP yP)) == xP
        leftModular_*_+P : {xP yP zP : (Prod A A)} -> (+P (*P xP yP) (*P xP zP)) == (*P xP (+P yP (*P xP zP)))
    record Hom {A1 : Set} {A2 : Set} (Mo1 : (ModularLattice A1)) (Mo2 : (ModularLattice A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Mo1) x1 x2)) == ((* Mo2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Mo1) x1 x2)) == ((+ Mo2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Mo1 : (ModularLattice A1)) (Mo2 : (ModularLattice A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Mo1) x1 x2) ((* Mo2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Mo1) x1 x2) ((+ Mo2) y1 y2))))
    data ModularLatticeTerm  : Set where
      *L : (ModularLatticeTerm -> (ModularLatticeTerm -> ModularLatticeTerm))
      +L : (ModularLatticeTerm -> (ModularLatticeTerm -> ModularLatticeTerm))
    data ClModularLatticeTerm (A : Set) : Set where
      sing : (A -> (ClModularLatticeTerm A))
      *Cl : ((ClModularLatticeTerm A) -> ((ClModularLatticeTerm A) -> (ClModularLatticeTerm A)))
      +Cl : ((ClModularLatticeTerm A) -> ((ClModularLatticeTerm A) -> (ClModularLatticeTerm A)))
    data OpModularLatticeTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpModularLatticeTerm n))
      *OL : ((OpModularLatticeTerm n) -> ((OpModularLatticeTerm n) -> (OpModularLatticeTerm n)))
      +OL : ((OpModularLatticeTerm n) -> ((OpModularLatticeTerm n) -> (OpModularLatticeTerm n)))
    data OpModularLatticeTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpModularLatticeTerm2 n A))
      sing2 : (A -> (OpModularLatticeTerm2 n A))
      *OL2 : ((OpModularLatticeTerm2 n A) -> ((OpModularLatticeTerm2 n A) -> (OpModularLatticeTerm2 n A)))
      +OL2 : ((OpModularLatticeTerm2 n A) -> ((OpModularLatticeTerm2 n A) -> (OpModularLatticeTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClModularLatticeTerm A) -> (ClModularLatticeTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpModularLatticeTerm n) -> (OpModularLatticeTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpModularLatticeTerm2 n A) -> (OpModularLatticeTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((ModularLattice A) -> (ModularLatticeTerm -> A))
    evalB Mo (*L x1 x2) = ((* Mo) (evalB Mo x1) (evalB Mo x2)) 
    evalB Mo (+L x1 x2) = ((+ Mo) (evalB Mo x1) (evalB Mo x2)) 
    evalCl : {A : Set} -> ((ModularLattice A) -> ((ClModularLatticeTerm A) -> A))
    evalCl Mo (sing x1) = x1 
    evalCl Mo (*Cl x1 x2) = ((* Mo) (evalCl Mo x1) (evalCl Mo x2)) 
    evalCl Mo (+Cl x1 x2) = ((+ Mo) (evalCl Mo x1) (evalCl Mo x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((ModularLattice A) -> ((Vec A n) -> ((OpModularLatticeTerm n) -> A)))
    evalOpB Mo vars (v x1) = (lookup _ x1 vars) 
    evalOpB Mo vars (*OL x1 x2) = ((* Mo) (evalOpB Mo vars x1) (evalOpB Mo vars x2)) 
    evalOpB Mo vars (+OL x1 x2) = ((+ Mo) (evalOpB Mo vars x1) (evalOpB Mo vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((ModularLattice A) -> ((Vec A n) -> ((OpModularLatticeTerm2 n A) -> A)))
    evalOp Mo vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Mo vars (sing2 x1) = x1 
    evalOp Mo vars (*OL2 x1 x2) = ((* Mo) (evalOp Mo vars x1) (evalOp Mo vars x2)) 
    evalOp Mo vars (+OL2 x1 x2) = ((+ Mo) (evalOp Mo vars x1) (evalOp Mo vars x2)) 
    inductionB : {P : (ModularLatticeTerm -> Set)} -> (((x1 x2 : ModularLatticeTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : ModularLatticeTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : ModularLatticeTerm) -> (P x))))
    inductionB {p} p*l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionB {p} p*l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClModularLatticeTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClModularLatticeTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClModularLatticeTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClModularLatticeTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p*cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpModularLatticeTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpModularLatticeTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpModularLatticeTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpModularLatticeTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p*ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpModularLatticeTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpModularLatticeTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpModularLatticeTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpModularLatticeTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    *L' : (ModularLatticeTerm -> (ModularLatticeTerm -> ModularLatticeTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (ModularLatticeTerm -> (ModularLatticeTerm -> ModularLatticeTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (ModularLatticeTerm -> (Staged ModularLatticeTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClModularLatticeTerm A) -> ((ClModularLatticeTerm A) -> (ClModularLatticeTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClModularLatticeTerm A) -> ((ClModularLatticeTerm A) -> (ClModularLatticeTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClModularLatticeTerm A) -> (Staged (ClModularLatticeTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpModularLatticeTerm n) -> ((OpModularLatticeTerm n) -> (OpModularLatticeTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpModularLatticeTerm n) -> ((OpModularLatticeTerm n) -> (OpModularLatticeTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpModularLatticeTerm n) -> (Staged (OpModularLatticeTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpModularLatticeTerm2 n A) -> ((OpModularLatticeTerm2 n A) -> (OpModularLatticeTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpModularLatticeTerm2 n A) -> ((OpModularLatticeTerm2 n A) -> (OpModularLatticeTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpModularLatticeTerm2 n A) -> (Staged (OpModularLatticeTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module Modularity  where
    record Modularity (A : Set) : Set where
      constructor ModularityC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        leftModular_*_+ : {x y z : A} -> (+ (* x y) (* x z)) == (* x (+ y (* x z)))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftModular_*_+P : {xP yP zP : (Prod A A)} -> (+P (*P xP yP) (*P xP zP)) == (*P xP (+P yP (*P xP zP)))
    record Hom {A1 : Set} {A2 : Set} (Mo1 : (Modularity A1)) (Mo2 : (Modularity A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Mo1) x1 x2)) == ((* Mo2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Mo1) x1 x2)) == ((+ Mo2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Mo1 : (Modularity A1)) (Mo2 : (Modularity A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Mo1) x1 x2) ((* Mo2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Mo1) x1 x2) ((+ Mo2) y1 y2))))
    data ModularityTerm  : Set where
      *L : (ModularityTerm -> (ModularityTerm -> ModularityTerm))
      +L : (ModularityTerm -> (ModularityTerm -> ModularityTerm))
    data ClModularityTerm (A : Set) : Set where
      sing : (A -> (ClModularityTerm A))
      *Cl : ((ClModularityTerm A) -> ((ClModularityTerm A) -> (ClModularityTerm A)))
      +Cl : ((ClModularityTerm A) -> ((ClModularityTerm A) -> (ClModularityTerm A)))
    data OpModularityTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpModularityTerm n))
      *OL : ((OpModularityTerm n) -> ((OpModularityTerm n) -> (OpModularityTerm n)))
      +OL : ((OpModularityTerm n) -> ((OpModularityTerm n) -> (OpModularityTerm n)))
    data OpModularityTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpModularityTerm2 n A))
      sing2 : (A -> (OpModularityTerm2 n A))
      *OL2 : ((OpModularityTerm2 n A) -> ((OpModularityTerm2 n A) -> (OpModularityTerm2 n A)))
      +OL2 : ((OpModularityTerm2 n A) -> ((OpModularityTerm2 n A) -> (OpModularityTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClModularityTerm A) -> (ClModularityTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpModularityTerm n) -> (OpModularityTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpModularityTerm2 n A) -> (OpModularityTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Modularity A) -> (ModularityTerm -> A))
    evalB Mo (*L x1 x2) = ((* Mo) (evalB Mo x1) (evalB Mo x2)) 
    evalB Mo (+L x1 x2) = ((+ Mo) (evalB Mo x1) (evalB Mo x2)) 
    evalCl : {A : Set} -> ((Modularity A) -> ((ClModularityTerm A) -> A))
    evalCl Mo (sing x1) = x1 
    evalCl Mo (*Cl x1 x2) = ((* Mo) (evalCl Mo x1) (evalCl Mo x2)) 
    evalCl Mo (+Cl x1 x2) = ((+ Mo) (evalCl Mo x1) (evalCl Mo x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Modularity A) -> ((Vec A n) -> ((OpModularityTerm n) -> A)))
    evalOpB Mo vars (v x1) = (lookup _ x1 vars) 
    evalOpB Mo vars (*OL x1 x2) = ((* Mo) (evalOpB Mo vars x1) (evalOpB Mo vars x2)) 
    evalOpB Mo vars (+OL x1 x2) = ((+ Mo) (evalOpB Mo vars x1) (evalOpB Mo vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Modularity A) -> ((Vec A n) -> ((OpModularityTerm2 n A) -> A)))
    evalOp Mo vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Mo vars (sing2 x1) = x1 
    evalOp Mo vars (*OL2 x1 x2) = ((* Mo) (evalOp Mo vars x1) (evalOp Mo vars x2)) 
    evalOp Mo vars (+OL2 x1 x2) = ((+ Mo) (evalOp Mo vars x1) (evalOp Mo vars x2)) 
    inductionB : {P : (ModularityTerm -> Set)} -> (((x1 x2 : ModularityTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : ModularityTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : ModularityTerm) -> (P x))))
    inductionB {p} p*l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionB {p} p*l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClModularityTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClModularityTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClModularityTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClModularityTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p*cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpModularityTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpModularityTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpModularityTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpModularityTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p*ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpModularityTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpModularityTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpModularityTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpModularityTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    *L' : (ModularityTerm -> (ModularityTerm -> ModularityTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (ModularityTerm -> (ModularityTerm -> ModularityTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (ModularityTerm -> (Staged ModularityTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClModularityTerm A) -> ((ClModularityTerm A) -> (ClModularityTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClModularityTerm A) -> ((ClModularityTerm A) -> (ClModularityTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClModularityTerm A) -> (Staged (ClModularityTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpModularityTerm n) -> ((OpModularityTerm n) -> (OpModularityTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpModularityTerm n) -> ((OpModularityTerm n) -> (OpModularityTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpModularityTerm n) -> (Staged (OpModularityTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpModularityTerm2 n A) -> ((OpModularityTerm2 n A) -> (OpModularityTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpModularityTerm2 n A) -> ((OpModularityTerm2 n A) -> (OpModularityTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpModularityTerm2 n A) -> (Staged (OpModularityTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module Monoid  where
    record Monoid (A : Set) : Set where
      constructor MonoidC
      field
        op : (A -> (A -> A))
        e : A
        lunit_e : {x : A} -> (op e x) == x
        runit_e : {x : A} -> (op x e) == x
        associative_op : {x y z : A} -> (op (op x y) z) == (op x (op y z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        eS : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        eP : (Prod A A)
        lunit_eP : {xP : (Prod A A)} -> (opP eP xP) == xP
        runit_eP : {xP : (Prod A A)} -> (opP xP eP) == xP
        associative_opP : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP (opP yP zP))
    record Hom {A1 : Set} {A2 : Set} (Mo1 : (Monoid A1)) (Mo2 : (Monoid A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Mo1) x1 x2)) == ((op Mo2) (hom x1) (hom x2))
        pres-e : (hom (e Mo1)) == (e Mo2)
    record RelInterp {A1 : Set} {A2 : Set} (Mo1 : (Monoid A1)) (Mo2 : (Monoid A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Mo1) x1 x2) ((op Mo2) y1 y2))))
        interp-e : (interp (e Mo1) (e Mo2))
    data MonoidTerm  : Set where
      opL : (MonoidTerm -> (MonoidTerm -> MonoidTerm))
      eL : MonoidTerm
    data ClMonoidTerm (A : Set) : Set where
      sing : (A -> (ClMonoidTerm A))
      opCl : ((ClMonoidTerm A) -> ((ClMonoidTerm A) -> (ClMonoidTerm A)))
      eCl : (ClMonoidTerm A)
    data OpMonoidTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpMonoidTerm n))
      opOL : ((OpMonoidTerm n) -> ((OpMonoidTerm n) -> (OpMonoidTerm n)))
      eOL : (OpMonoidTerm n)
    data OpMonoidTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpMonoidTerm2 n A))
      sing2 : (A -> (OpMonoidTerm2 n A))
      opOL2 : ((OpMonoidTerm2 n A) -> ((OpMonoidTerm2 n A) -> (OpMonoidTerm2 n A)))
      eOL2 : (OpMonoidTerm2 n A)
    simplifyCl : {A : Set} -> ((ClMonoidTerm A) -> (ClMonoidTerm A))
    simplifyCl (opCl eCl x) = x 
    simplifyCl (opCl x eCl) = x 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl eCl = eCl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpMonoidTerm n) -> (OpMonoidTerm n))
    simplifyOpB (opOL eOL x) = x 
    simplifyOpB (opOL x eOL) = x 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB eOL = eOL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpMonoidTerm2 n A) -> (OpMonoidTerm2 n A))
    simplifyOp (opOL2 eOL2 x) = x 
    simplifyOp (opOL2 x eOL2) = x 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp eOL2 = eOL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Monoid A) -> (MonoidTerm -> A))
    evalB Mo (opL x1 x2) = ((op Mo) (evalB Mo x1) (evalB Mo x2)) 
    evalB Mo eL = (e Mo) 
    evalCl : {A : Set} -> ((Monoid A) -> ((ClMonoidTerm A) -> A))
    evalCl Mo (sing x1) = x1 
    evalCl Mo (opCl x1 x2) = ((op Mo) (evalCl Mo x1) (evalCl Mo x2)) 
    evalCl Mo eCl = (e Mo) 
    evalOpB : {A : Set} {n : Nat} -> ((Monoid A) -> ((Vec A n) -> ((OpMonoidTerm n) -> A)))
    evalOpB Mo vars (v x1) = (lookup _ x1 vars) 
    evalOpB Mo vars (opOL x1 x2) = ((op Mo) (evalOpB Mo vars x1) (evalOpB Mo vars x2)) 
    evalOpB Mo vars eOL = (e Mo) 
    evalOp : {A : Set} {n : Nat} -> ((Monoid A) -> ((Vec A n) -> ((OpMonoidTerm2 n A) -> A)))
    evalOp Mo vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Mo vars (sing2 x1) = x1 
    evalOp Mo vars (opOL2 x1 x2) = ((op Mo) (evalOp Mo vars x1) (evalOp Mo vars x2)) 
    evalOp Mo vars eOL2 = (e Mo) 
    inductionB : {P : (MonoidTerm -> Set)} -> (((x1 x2 : MonoidTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((P eL) -> ((x : MonoidTerm) -> (P x))))
    inductionB {p} popl pel (opL x1 x2) = (popl _ _ (inductionB {p} popl pel x1) (inductionB {p} popl pel x2)) 
    inductionB {p} popl pel eL = pel 
    inductionCl : {A : Set} {P : ((ClMonoidTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClMonoidTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((P eCl) -> ((x : (ClMonoidTerm A)) -> (P x)))))
    inductionCl {_} {p} psing popcl pecl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl pecl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl pecl x1) (inductionCl {_} {p} psing popcl pecl x2)) 
    inductionCl {_} {p} psing popcl pecl eCl = pecl 
    inductionOpB : {n : Nat} {P : ((OpMonoidTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpMonoidTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((P eOL) -> ((x : (OpMonoidTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv popol peol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol peol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol peol x1) (inductionOpB {_} {p} pv popol peol x2)) 
    inductionOpB {_} {p} pv popol peol eOL = peol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpMonoidTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpMonoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((P eOL2) -> ((x : (OpMonoidTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 eOL2 = peol2 
    opL' : (MonoidTerm -> (MonoidTerm -> MonoidTerm))
    opL' x1 x2 = (opL x1 x2) 
    eL' : MonoidTerm
    eL'  = eL 
    stageB : (MonoidTerm -> (Staged MonoidTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB eL = (Now eL) 
    opCl' : {A : Set} -> ((ClMonoidTerm A) -> ((ClMonoidTerm A) -> (ClMonoidTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    eCl' : {A : Set} -> (ClMonoidTerm A)
    eCl'  = eCl 
    stageCl : {A : Set} -> ((ClMonoidTerm A) -> (Staged (ClMonoidTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl eCl = (Now eCl) 
    opOL' : {n : Nat} -> ((OpMonoidTerm n) -> ((OpMonoidTerm n) -> (OpMonoidTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    eOL' : {n : Nat} -> (OpMonoidTerm n)
    eOL'  = eOL 
    stageOpB : {n : Nat} -> ((OpMonoidTerm n) -> (Staged (OpMonoidTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB eOL = (Now eOL) 
    opOL2' : {n : Nat} {A : Set} -> ((OpMonoidTerm2 n A) -> ((OpMonoidTerm2 n A) -> (OpMonoidTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    eOL2' : {n : Nat} {A : Set} -> (OpMonoidTerm2 n A)
    eOL2'  = eOL2 
    stageOp : {n : Nat} {A : Set} -> ((OpMonoidTerm2 n A) -> (Staged (OpMonoidTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp eOL2 = (Now eOL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        eT : (Repr A)
  module Monoid1  where
    record Monoid1 (A : Set) : Set where
      constructor Monoid1C
      field
        1 : A
        op : (A -> (A -> A))
        lunit_1 : {x : A} -> (op 1 x) == x
        runit_1 : {x : A} -> (op x 1) == x
        associative_op : {x y z : A} -> (op (op x y) z) == (op x (op y z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        1S : AS
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        1P : (Prod A A)
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        lunit_1P : {xP : (Prod A A)} -> (opP 1P xP) == xP
        runit_1P : {xP : (Prod A A)} -> (opP xP 1P) == xP
        associative_opP : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP (opP yP zP))
    record Hom {A1 : Set} {A2 : Set} (Mo1 : (Monoid1 A1)) (Mo2 : (Monoid1 A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-1 : (hom (1 Mo1)) == (1 Mo2)
        pres-op : {x1 x2 : A1} -> (hom ((op Mo1) x1 x2)) == ((op Mo2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Mo1 : (Monoid1 A1)) (Mo2 : (Monoid1 A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-1 : (interp (1 Mo1) (1 Mo2))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Mo1) x1 x2) ((op Mo2) y1 y2))))
    data Monoid1LTerm  : Set where
      1L : Monoid1LTerm
      opL : (Monoid1LTerm -> (Monoid1LTerm -> Monoid1LTerm))
    data ClMonoid1ClTerm (A : Set) : Set where
      sing : (A -> (ClMonoid1ClTerm A))
      1Cl : (ClMonoid1ClTerm A)
      opCl : ((ClMonoid1ClTerm A) -> ((ClMonoid1ClTerm A) -> (ClMonoid1ClTerm A)))
    data OpMonoid1OLTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpMonoid1OLTerm n))
      1OL : (OpMonoid1OLTerm n)
      opOL : ((OpMonoid1OLTerm n) -> ((OpMonoid1OLTerm n) -> (OpMonoid1OLTerm n)))
    data OpMonoid1OL2Term2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpMonoid1OL2Term2 n A))
      sing2 : (A -> (OpMonoid1OL2Term2 n A))
      1OL2 : (OpMonoid1OL2Term2 n A)
      opOL2 : ((OpMonoid1OL2Term2 n A) -> ((OpMonoid1OL2Term2 n A) -> (OpMonoid1OL2Term2 n A)))
    simplifyCl : {A : Set} -> ((ClMonoid1ClTerm A) -> (ClMonoid1ClTerm A))
    simplifyCl (opCl 1Cl x) = x 
    simplifyCl (opCl x 1Cl) = x 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpMonoid1OLTerm n) -> (OpMonoid1OLTerm n))
    simplifyOpB (opOL 1OL x) = x 
    simplifyOpB (opOL x 1OL) = x 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpMonoid1OL2Term2 n A) -> (OpMonoid1OL2Term2 n A))
    simplifyOp (opOL2 1OL2 x) = x 
    simplifyOp (opOL2 x 1OL2) = x 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Monoid1 A) -> (Monoid1LTerm -> A))
    evalB Mo 1L = (1 Mo) 
    evalB Mo (opL x1 x2) = ((op Mo) (evalB Mo x1) (evalB Mo x2)) 
    evalCl : {A : Set} -> ((Monoid1 A) -> ((ClMonoid1ClTerm A) -> A))
    evalCl Mo (sing x1) = x1 
    evalCl Mo 1Cl = (1 Mo) 
    evalCl Mo (opCl x1 x2) = ((op Mo) (evalCl Mo x1) (evalCl Mo x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Monoid1 A) -> ((Vec A n) -> ((OpMonoid1OLTerm n) -> A)))
    evalOpB Mo vars (v x1) = (lookup _ x1 vars) 
    evalOpB Mo vars 1OL = (1 Mo) 
    evalOpB Mo vars (opOL x1 x2) = ((op Mo) (evalOpB Mo vars x1) (evalOpB Mo vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Monoid1 A) -> ((Vec A n) -> ((OpMonoid1OL2Term2 n A) -> A)))
    evalOp Mo vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Mo vars (sing2 x1) = x1 
    evalOp Mo vars 1OL2 = (1 Mo) 
    evalOp Mo vars (opOL2 x1 x2) = ((op Mo) (evalOp Mo vars x1) (evalOp Mo vars x2)) 
    inductionB : {P : (Monoid1LTerm -> Set)} -> ((P 1L) -> (((x1 x2 : Monoid1LTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : Monoid1LTerm) -> (P x))))
    inductionB {p} p1l popl 1L = p1l 
    inductionB {p} p1l popl (opL x1 x2) = (popl _ _ (inductionB {p} p1l popl x1) (inductionB {p} p1l popl x2)) 
    inductionCl : {A : Set} {P : ((ClMonoid1ClTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 1Cl) -> (((x1 x2 : (ClMonoid1ClTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClMonoid1ClTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p1cl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p1cl popcl 1Cl = p1cl 
    inductionCl {_} {p} psing p1cl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing p1cl popcl x1) (inductionCl {_} {p} psing p1cl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpMonoid1OLTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 1OL) -> (((x1 x2 : (OpMonoid1OLTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpMonoid1OLTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p1ol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p1ol popol 1OL = p1ol 
    inductionOpB {_} {p} pv p1ol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv p1ol popol x1) (inductionOpB {_} {p} pv p1ol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpMonoid1OL2Term2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 1OL2) -> (((x1 x2 : (OpMonoid1OL2Term2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpMonoid1OL2Term2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 popol2 1OL2 = p1ol2 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p1ol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p1ol2 popol2 x2)) 
    1L' : Monoid1LTerm
    1L'  = 1L 
    opL' : (Monoid1LTerm -> (Monoid1LTerm -> Monoid1LTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (Monoid1LTerm -> (Staged Monoid1LTerm))
    stageB 1L = (Now 1L) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    1Cl' : {A : Set} -> (ClMonoid1ClTerm A)
    1Cl'  = 1Cl 
    opCl' : {A : Set} -> ((ClMonoid1ClTerm A) -> ((ClMonoid1ClTerm A) -> (ClMonoid1ClTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClMonoid1ClTerm A) -> (Staged (ClMonoid1ClTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 1Cl = (Now 1Cl) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    1OL' : {n : Nat} -> (OpMonoid1OLTerm n)
    1OL'  = 1OL 
    opOL' : {n : Nat} -> ((OpMonoid1OLTerm n) -> ((OpMonoid1OLTerm n) -> (OpMonoid1OLTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpMonoid1OLTerm n) -> (Staged (OpMonoid1OLTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 1OL = (Now 1OL) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    1OL2' : {n : Nat} {A : Set} -> (OpMonoid1OL2Term2 n A)
    1OL2'  = 1OL2 
    opOL2' : {n : Nat} {A : Set} -> ((OpMonoid1OL2Term2 n A) -> ((OpMonoid1OL2Term2 n A) -> (OpMonoid1OL2Term2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpMonoid1OL2Term2 n A) -> (Staged (OpMonoid1OL2Term2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 1OL2 = (Now 1OL2) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        1T : (Repr A)
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module MoufangIdentity  where
    record MoufangIdentity (A : Set) : Set where
      constructor MoufangIdentityC
      field
        op : (A -> (A -> A))
        moufangId : {x y z : A} -> (op (op z x) (op y z)) == (op (op z (op x y)) z)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        moufangIdP : {xP yP zP : (Prod A A)} -> (opP (opP zP xP) (opP yP zP)) == (opP (opP zP (opP xP yP)) zP)
    record Hom {A1 : Set} {A2 : Set} (Mo1 : (MoufangIdentity A1)) (Mo2 : (MoufangIdentity A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Mo1) x1 x2)) == ((op Mo2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Mo1 : (MoufangIdentity A1)) (Mo2 : (MoufangIdentity A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Mo1) x1 x2) ((op Mo2) y1 y2))))
    data MoufangIdentityTerm  : Set where
      opL : (MoufangIdentityTerm -> (MoufangIdentityTerm -> MoufangIdentityTerm))
    data ClMoufangIdentityTerm (A : Set) : Set where
      sing : (A -> (ClMoufangIdentityTerm A))
      opCl : ((ClMoufangIdentityTerm A) -> ((ClMoufangIdentityTerm A) -> (ClMoufangIdentityTerm A)))
    data OpMoufangIdentityTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpMoufangIdentityTerm n))
      opOL : ((OpMoufangIdentityTerm n) -> ((OpMoufangIdentityTerm n) -> (OpMoufangIdentityTerm n)))
    data OpMoufangIdentityTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpMoufangIdentityTerm2 n A))
      sing2 : (A -> (OpMoufangIdentityTerm2 n A))
      opOL2 : ((OpMoufangIdentityTerm2 n A) -> ((OpMoufangIdentityTerm2 n A) -> (OpMoufangIdentityTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClMoufangIdentityTerm A) -> (ClMoufangIdentityTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpMoufangIdentityTerm n) -> (OpMoufangIdentityTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpMoufangIdentityTerm2 n A) -> (OpMoufangIdentityTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((MoufangIdentity A) -> (MoufangIdentityTerm -> A))
    evalB Mo (opL x1 x2) = ((op Mo) (evalB Mo x1) (evalB Mo x2)) 
    evalCl : {A : Set} -> ((MoufangIdentity A) -> ((ClMoufangIdentityTerm A) -> A))
    evalCl Mo (sing x1) = x1 
    evalCl Mo (opCl x1 x2) = ((op Mo) (evalCl Mo x1) (evalCl Mo x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((MoufangIdentity A) -> ((Vec A n) -> ((OpMoufangIdentityTerm n) -> A)))
    evalOpB Mo vars (v x1) = (lookup _ x1 vars) 
    evalOpB Mo vars (opOL x1 x2) = ((op Mo) (evalOpB Mo vars x1) (evalOpB Mo vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((MoufangIdentity A) -> ((Vec A n) -> ((OpMoufangIdentityTerm2 n A) -> A)))
    evalOp Mo vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Mo vars (sing2 x1) = x1 
    evalOp Mo vars (opOL2 x1 x2) = ((op Mo) (evalOp Mo vars x1) (evalOp Mo vars x2)) 
    inductionB : {P : (MoufangIdentityTerm -> Set)} -> (((x1 x2 : MoufangIdentityTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : MoufangIdentityTerm) -> (P x)))
    inductionB {p} popl (opL x1 x2) = (popl _ _ (inductionB {p} popl x1) (inductionB {p} popl x2)) 
    inductionCl : {A : Set} {P : ((ClMoufangIdentityTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClMoufangIdentityTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClMoufangIdentityTerm A)) -> (P x))))
    inductionCl {_} {p} psing popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl x1) (inductionCl {_} {p} psing popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpMoufangIdentityTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpMoufangIdentityTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpMoufangIdentityTerm n)) -> (P x))))
    inductionOpB {_} {p} pv popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol x1) (inductionOpB {_} {p} pv popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpMoufangIdentityTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpMoufangIdentityTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpMoufangIdentityTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 x2)) 
    opL' : (MoufangIdentityTerm -> (MoufangIdentityTerm -> MoufangIdentityTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (MoufangIdentityTerm -> (Staged MoufangIdentityTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClMoufangIdentityTerm A) -> ((ClMoufangIdentityTerm A) -> (ClMoufangIdentityTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClMoufangIdentityTerm A) -> (Staged (ClMoufangIdentityTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpMoufangIdentityTerm n) -> ((OpMoufangIdentityTerm n) -> (OpMoufangIdentityTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpMoufangIdentityTerm n) -> (Staged (OpMoufangIdentityTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpMoufangIdentityTerm2 n A) -> ((OpMoufangIdentityTerm2 n A) -> (OpMoufangIdentityTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpMoufangIdentityTerm2 n A) -> (Staged (OpMoufangIdentityTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module MoufangLaw  where
    record MoufangLaw (A : Set) : Set where
      constructor MoufangLawC
      field
        op : (A -> (A -> A))
        moufangLaw : {e x y z : A} -> ((op y e) == y -> (op (op (op x y) z) x) == (op x (op y (op (op e z) x))))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        moufangLawP : {eP xP yP zP : (Prod A A)} -> ((opP yP eP) == yP -> (opP (opP (opP xP yP) zP) xP) == (opP xP (opP yP (opP (opP eP zP) xP))))
    record Hom {A1 : Set} {A2 : Set} (Mo1 : (MoufangLaw A1)) (Mo2 : (MoufangLaw A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Mo1) x1 x2)) == ((op Mo2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Mo1 : (MoufangLaw A1)) (Mo2 : (MoufangLaw A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Mo1) x1 x2) ((op Mo2) y1 y2))))
    data MoufangLawTerm  : Set where
      opL : (MoufangLawTerm -> (MoufangLawTerm -> MoufangLawTerm))
    data ClMoufangLawTerm (A : Set) : Set where
      sing : (A -> (ClMoufangLawTerm A))
      opCl : ((ClMoufangLawTerm A) -> ((ClMoufangLawTerm A) -> (ClMoufangLawTerm A)))
    data OpMoufangLawTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpMoufangLawTerm n))
      opOL : ((OpMoufangLawTerm n) -> ((OpMoufangLawTerm n) -> (OpMoufangLawTerm n)))
    data OpMoufangLawTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpMoufangLawTerm2 n A))
      sing2 : (A -> (OpMoufangLawTerm2 n A))
      opOL2 : ((OpMoufangLawTerm2 n A) -> ((OpMoufangLawTerm2 n A) -> (OpMoufangLawTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClMoufangLawTerm A) -> (ClMoufangLawTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpMoufangLawTerm n) -> (OpMoufangLawTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpMoufangLawTerm2 n A) -> (OpMoufangLawTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((MoufangLaw A) -> (MoufangLawTerm -> A))
    evalB Mo (opL x1 x2) = ((op Mo) (evalB Mo x1) (evalB Mo x2)) 
    evalCl : {A : Set} -> ((MoufangLaw A) -> ((ClMoufangLawTerm A) -> A))
    evalCl Mo (sing x1) = x1 
    evalCl Mo (opCl x1 x2) = ((op Mo) (evalCl Mo x1) (evalCl Mo x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((MoufangLaw A) -> ((Vec A n) -> ((OpMoufangLawTerm n) -> A)))
    evalOpB Mo vars (v x1) = (lookup _ x1 vars) 
    evalOpB Mo vars (opOL x1 x2) = ((op Mo) (evalOpB Mo vars x1) (evalOpB Mo vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((MoufangLaw A) -> ((Vec A n) -> ((OpMoufangLawTerm2 n A) -> A)))
    evalOp Mo vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Mo vars (sing2 x1) = x1 
    evalOp Mo vars (opOL2 x1 x2) = ((op Mo) (evalOp Mo vars x1) (evalOp Mo vars x2)) 
    inductionB : {P : (MoufangLawTerm -> Set)} -> (((x1 x2 : MoufangLawTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : MoufangLawTerm) -> (P x)))
    inductionB {p} popl (opL x1 x2) = (popl _ _ (inductionB {p} popl x1) (inductionB {p} popl x2)) 
    inductionCl : {A : Set} {P : ((ClMoufangLawTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClMoufangLawTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClMoufangLawTerm A)) -> (P x))))
    inductionCl {_} {p} psing popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl x1) (inductionCl {_} {p} psing popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpMoufangLawTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpMoufangLawTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpMoufangLawTerm n)) -> (P x))))
    inductionOpB {_} {p} pv popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol x1) (inductionOpB {_} {p} pv popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpMoufangLawTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpMoufangLawTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpMoufangLawTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 x2)) 
    opL' : (MoufangLawTerm -> (MoufangLawTerm -> MoufangLawTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (MoufangLawTerm -> (Staged MoufangLawTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClMoufangLawTerm A) -> ((ClMoufangLawTerm A) -> (ClMoufangLawTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClMoufangLawTerm A) -> (Staged (ClMoufangLawTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpMoufangLawTerm n) -> ((OpMoufangLawTerm n) -> (OpMoufangLawTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpMoufangLawTerm n) -> (Staged (OpMoufangLawTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpMoufangLawTerm2 n A) -> ((OpMoufangLawTerm2 n A) -> (OpMoufangLawTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpMoufangLawTerm2 n A) -> (Staged (OpMoufangLawTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module MoufangLoop  where
    record MoufangLoop (A : Set) : Set where
      constructor MoufangLoopC
      field
        op : (A -> (A -> A))
        e : A
        lunit_e : {x : A} -> (op e x) == x
        runit_e : {x : A} -> (op x e) == x
        linv : (A -> (A -> A))
        leftCancel : {x y : A} -> (op x (linv x y)) == y
        lefCancelOp : {x y : A} -> (linv x (op x y)) == y
        rinv : (A -> (A -> A))
        rightCancel : {x y : A} -> (op (rinv y x) x) == y
        rightCancelOp : {x y : A} -> (rinv (op y x) x) == y
        moufangId : {x y z : A} -> (op (op z x) (op y z)) == (op (op z (op x y)) z)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        eS : AS
        linvS : (AS -> (AS -> AS))
        rinvS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        eP : (Prod A A)
        linvP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        rinvP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        lunit_eP : {xP : (Prod A A)} -> (opP eP xP) == xP
        runit_eP : {xP : (Prod A A)} -> (opP xP eP) == xP
        leftCancelP : {xP yP : (Prod A A)} -> (opP xP (linvP xP yP)) == yP
        lefCancelOpP : {xP yP : (Prod A A)} -> (linvP xP (opP xP yP)) == yP
        rightCancelP : {xP yP : (Prod A A)} -> (opP (rinvP yP xP) xP) == yP
        rightCancelOpP : {xP yP : (Prod A A)} -> (rinvP (opP yP xP) xP) == yP
        moufangIdP : {xP yP zP : (Prod A A)} -> (opP (opP zP xP) (opP yP zP)) == (opP (opP zP (opP xP yP)) zP)
    record Hom {A1 : Set} {A2 : Set} (Mo1 : (MoufangLoop A1)) (Mo2 : (MoufangLoop A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Mo1) x1 x2)) == ((op Mo2) (hom x1) (hom x2))
        pres-e : (hom (e Mo1)) == (e Mo2)
        pres-linv : {x1 x2 : A1} -> (hom ((linv Mo1) x1 x2)) == ((linv Mo2) (hom x1) (hom x2))
        pres-rinv : {x1 x2 : A1} -> (hom ((rinv Mo1) x1 x2)) == ((rinv Mo2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Mo1 : (MoufangLoop A1)) (Mo2 : (MoufangLoop A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Mo1) x1 x2) ((op Mo2) y1 y2))))
        interp-e : (interp (e Mo1) (e Mo2))
        interp-linv : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((linv Mo1) x1 x2) ((linv Mo2) y1 y2))))
        interp-rinv : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((rinv Mo1) x1 x2) ((rinv Mo2) y1 y2))))
    data MoufangLoopLTerm  : Set where
      opL : (MoufangLoopLTerm -> (MoufangLoopLTerm -> MoufangLoopLTerm))
      eL : MoufangLoopLTerm
      linvL : (MoufangLoopLTerm -> (MoufangLoopLTerm -> MoufangLoopLTerm))
      rinvL : (MoufangLoopLTerm -> (MoufangLoopLTerm -> MoufangLoopLTerm))
    data ClMoufangLoopClTerm (A : Set) : Set where
      sing : (A -> (ClMoufangLoopClTerm A))
      opCl : ((ClMoufangLoopClTerm A) -> ((ClMoufangLoopClTerm A) -> (ClMoufangLoopClTerm A)))
      eCl : (ClMoufangLoopClTerm A)
      linvCl : ((ClMoufangLoopClTerm A) -> ((ClMoufangLoopClTerm A) -> (ClMoufangLoopClTerm A)))
      rinvCl : ((ClMoufangLoopClTerm A) -> ((ClMoufangLoopClTerm A) -> (ClMoufangLoopClTerm A)))
    data OpMoufangLoopOLTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpMoufangLoopOLTerm n))
      opOL : ((OpMoufangLoopOLTerm n) -> ((OpMoufangLoopOLTerm n) -> (OpMoufangLoopOLTerm n)))
      eOL : (OpMoufangLoopOLTerm n)
      linvOL : ((OpMoufangLoopOLTerm n) -> ((OpMoufangLoopOLTerm n) -> (OpMoufangLoopOLTerm n)))
      rinvOL : ((OpMoufangLoopOLTerm n) -> ((OpMoufangLoopOLTerm n) -> (OpMoufangLoopOLTerm n)))
    data OpMoufangLoopOL2Term2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpMoufangLoopOL2Term2 n A))
      sing2 : (A -> (OpMoufangLoopOL2Term2 n A))
      opOL2 : ((OpMoufangLoopOL2Term2 n A) -> ((OpMoufangLoopOL2Term2 n A) -> (OpMoufangLoopOL2Term2 n A)))
      eOL2 : (OpMoufangLoopOL2Term2 n A)
      linvOL2 : ((OpMoufangLoopOL2Term2 n A) -> ((OpMoufangLoopOL2Term2 n A) -> (OpMoufangLoopOL2Term2 n A)))
      rinvOL2 : ((OpMoufangLoopOL2Term2 n A) -> ((OpMoufangLoopOL2Term2 n A) -> (OpMoufangLoopOL2Term2 n A)))
    simplifyCl : {A : Set} -> ((ClMoufangLoopClTerm A) -> (ClMoufangLoopClTerm A))
    simplifyCl (opCl eCl x) = x 
    simplifyCl (opCl x eCl) = x 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl eCl = eCl 
    simplifyCl (linvCl x1 x2) = (linvCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (rinvCl x1 x2) = (rinvCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpMoufangLoopOLTerm n) -> (OpMoufangLoopOLTerm n))
    simplifyOpB (opOL eOL x) = x 
    simplifyOpB (opOL x eOL) = x 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB eOL = eOL 
    simplifyOpB (linvOL x1 x2) = (linvOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (rinvOL x1 x2) = (rinvOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpMoufangLoopOL2Term2 n A) -> (OpMoufangLoopOL2Term2 n A))
    simplifyOp (opOL2 eOL2 x) = x 
    simplifyOp (opOL2 x eOL2) = x 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp eOL2 = eOL2 
    simplifyOp (linvOL2 x1 x2) = (linvOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (rinvOL2 x1 x2) = (rinvOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((MoufangLoop A) -> (MoufangLoopLTerm -> A))
    evalB Mo (opL x1 x2) = ((op Mo) (evalB Mo x1) (evalB Mo x2)) 
    evalB Mo eL = (e Mo) 
    evalB Mo (linvL x1 x2) = ((linv Mo) (evalB Mo x1) (evalB Mo x2)) 
    evalB Mo (rinvL x1 x2) = ((rinv Mo) (evalB Mo x1) (evalB Mo x2)) 
    evalCl : {A : Set} -> ((MoufangLoop A) -> ((ClMoufangLoopClTerm A) -> A))
    evalCl Mo (sing x1) = x1 
    evalCl Mo (opCl x1 x2) = ((op Mo) (evalCl Mo x1) (evalCl Mo x2)) 
    evalCl Mo eCl = (e Mo) 
    evalCl Mo (linvCl x1 x2) = ((linv Mo) (evalCl Mo x1) (evalCl Mo x2)) 
    evalCl Mo (rinvCl x1 x2) = ((rinv Mo) (evalCl Mo x1) (evalCl Mo x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((MoufangLoop A) -> ((Vec A n) -> ((OpMoufangLoopOLTerm n) -> A)))
    evalOpB Mo vars (v x1) = (lookup _ x1 vars) 
    evalOpB Mo vars (opOL x1 x2) = ((op Mo) (evalOpB Mo vars x1) (evalOpB Mo vars x2)) 
    evalOpB Mo vars eOL = (e Mo) 
    evalOpB Mo vars (linvOL x1 x2) = ((linv Mo) (evalOpB Mo vars x1) (evalOpB Mo vars x2)) 
    evalOpB Mo vars (rinvOL x1 x2) = ((rinv Mo) (evalOpB Mo vars x1) (evalOpB Mo vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((MoufangLoop A) -> ((Vec A n) -> ((OpMoufangLoopOL2Term2 n A) -> A)))
    evalOp Mo vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Mo vars (sing2 x1) = x1 
    evalOp Mo vars (opOL2 x1 x2) = ((op Mo) (evalOp Mo vars x1) (evalOp Mo vars x2)) 
    evalOp Mo vars eOL2 = (e Mo) 
    evalOp Mo vars (linvOL2 x1 x2) = ((linv Mo) (evalOp Mo vars x1) (evalOp Mo vars x2)) 
    evalOp Mo vars (rinvOL2 x1 x2) = ((rinv Mo) (evalOp Mo vars x1) (evalOp Mo vars x2)) 
    inductionB : {P : (MoufangLoopLTerm -> Set)} -> (((x1 x2 : MoufangLoopLTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((P eL) -> (((x1 x2 : MoufangLoopLTerm) -> ((P x1) -> ((P x2) -> (P (linvL x1 x2))))) -> (((x1 x2 : MoufangLoopLTerm) -> ((P x1) -> ((P x2) -> (P (rinvL x1 x2))))) -> ((x : MoufangLoopLTerm) -> (P x))))))
    inductionB {p} popl pel plinvl prinvl (opL x1 x2) = (popl _ _ (inductionB {p} popl pel plinvl prinvl x1) (inductionB {p} popl pel plinvl prinvl x2)) 
    inductionB {p} popl pel plinvl prinvl eL = pel 
    inductionB {p} popl pel plinvl prinvl (linvL x1 x2) = (plinvl _ _ (inductionB {p} popl pel plinvl prinvl x1) (inductionB {p} popl pel plinvl prinvl x2)) 
    inductionB {p} popl pel plinvl prinvl (rinvL x1 x2) = (prinvl _ _ (inductionB {p} popl pel plinvl prinvl x1) (inductionB {p} popl pel plinvl prinvl x2)) 
    inductionCl : {A : Set} {P : ((ClMoufangLoopClTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClMoufangLoopClTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((P eCl) -> (((x1 x2 : (ClMoufangLoopClTerm A)) -> ((P x1) -> ((P x2) -> (P (linvCl x1 x2))))) -> (((x1 x2 : (ClMoufangLoopClTerm A)) -> ((P x1) -> ((P x2) -> (P (rinvCl x1 x2))))) -> ((x : (ClMoufangLoopClTerm A)) -> (P x)))))))
    inductionCl {_} {p} psing popcl pecl plinvcl prinvcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl pecl plinvcl prinvcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl pecl plinvcl prinvcl x1) (inductionCl {_} {p} psing popcl pecl plinvcl prinvcl x2)) 
    inductionCl {_} {p} psing popcl pecl plinvcl prinvcl eCl = pecl 
    inductionCl {_} {p} psing popcl pecl plinvcl prinvcl (linvCl x1 x2) = (plinvcl _ _ (inductionCl {_} {p} psing popcl pecl plinvcl prinvcl x1) (inductionCl {_} {p} psing popcl pecl plinvcl prinvcl x2)) 
    inductionCl {_} {p} psing popcl pecl plinvcl prinvcl (rinvCl x1 x2) = (prinvcl _ _ (inductionCl {_} {p} psing popcl pecl plinvcl prinvcl x1) (inductionCl {_} {p} psing popcl pecl plinvcl prinvcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpMoufangLoopOLTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpMoufangLoopOLTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((P eOL) -> (((x1 x2 : (OpMoufangLoopOLTerm n)) -> ((P x1) -> ((P x2) -> (P (linvOL x1 x2))))) -> (((x1 x2 : (OpMoufangLoopOLTerm n)) -> ((P x1) -> ((P x2) -> (P (rinvOL x1 x2))))) -> ((x : (OpMoufangLoopOLTerm n)) -> (P x)))))))
    inductionOpB {_} {p} pv popol peol plinvol prinvol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol peol plinvol prinvol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol peol plinvol prinvol x1) (inductionOpB {_} {p} pv popol peol plinvol prinvol x2)) 
    inductionOpB {_} {p} pv popol peol plinvol prinvol eOL = peol 
    inductionOpB {_} {p} pv popol peol plinvol prinvol (linvOL x1 x2) = (plinvol _ _ (inductionOpB {_} {p} pv popol peol plinvol prinvol x1) (inductionOpB {_} {p} pv popol peol plinvol prinvol x2)) 
    inductionOpB {_} {p} pv popol peol plinvol prinvol (rinvOL x1 x2) = (prinvol _ _ (inductionOpB {_} {p} pv popol peol plinvol prinvol x1) (inductionOpB {_} {p} pv popol peol plinvol prinvol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpMoufangLoopOL2Term2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpMoufangLoopOL2Term2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((P eOL2) -> (((x1 x2 : (OpMoufangLoopOL2Term2 n A)) -> ((P x1) -> ((P x2) -> (P (linvOL2 x1 x2))))) -> (((x1 x2 : (OpMoufangLoopOL2Term2 n A)) -> ((P x1) -> ((P x2) -> (P (rinvOL2 x1 x2))))) -> ((x : (OpMoufangLoopOL2Term2 n A)) -> (P x))))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 prinvol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 prinvol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 prinvol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 prinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 prinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 prinvol2 eOL2 = peol2 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 prinvol2 (linvOL2 x1 x2) = (plinvol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 prinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 prinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 prinvol2 (rinvOL2 x1 x2) = (prinvol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 prinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 plinvol2 prinvol2 x2)) 
    opL' : (MoufangLoopLTerm -> (MoufangLoopLTerm -> MoufangLoopLTerm))
    opL' x1 x2 = (opL x1 x2) 
    eL' : MoufangLoopLTerm
    eL'  = eL 
    linvL' : (MoufangLoopLTerm -> (MoufangLoopLTerm -> MoufangLoopLTerm))
    linvL' x1 x2 = (linvL x1 x2) 
    rinvL' : (MoufangLoopLTerm -> (MoufangLoopLTerm -> MoufangLoopLTerm))
    rinvL' x1 x2 = (rinvL x1 x2) 
    stageB : (MoufangLoopLTerm -> (Staged MoufangLoopLTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB eL = (Now eL) 
    stageB (linvL x1 x2) = (stage2 linvL' (codeLift2 linvL') (stageB x1) (stageB x2)) 
    stageB (rinvL x1 x2) = (stage2 rinvL' (codeLift2 rinvL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClMoufangLoopClTerm A) -> ((ClMoufangLoopClTerm A) -> (ClMoufangLoopClTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    eCl' : {A : Set} -> (ClMoufangLoopClTerm A)
    eCl'  = eCl 
    linvCl' : {A : Set} -> ((ClMoufangLoopClTerm A) -> ((ClMoufangLoopClTerm A) -> (ClMoufangLoopClTerm A)))
    linvCl' x1 x2 = (linvCl x1 x2) 
    rinvCl' : {A : Set} -> ((ClMoufangLoopClTerm A) -> ((ClMoufangLoopClTerm A) -> (ClMoufangLoopClTerm A)))
    rinvCl' x1 x2 = (rinvCl x1 x2) 
    stageCl : {A : Set} -> ((ClMoufangLoopClTerm A) -> (Staged (ClMoufangLoopClTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl eCl = (Now eCl) 
    stageCl (linvCl x1 x2) = (stage2 linvCl' (codeLift2 linvCl') (stageCl x1) (stageCl x2)) 
    stageCl (rinvCl x1 x2) = (stage2 rinvCl' (codeLift2 rinvCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpMoufangLoopOLTerm n) -> ((OpMoufangLoopOLTerm n) -> (OpMoufangLoopOLTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    eOL' : {n : Nat} -> (OpMoufangLoopOLTerm n)
    eOL'  = eOL 
    linvOL' : {n : Nat} -> ((OpMoufangLoopOLTerm n) -> ((OpMoufangLoopOLTerm n) -> (OpMoufangLoopOLTerm n)))
    linvOL' x1 x2 = (linvOL x1 x2) 
    rinvOL' : {n : Nat} -> ((OpMoufangLoopOLTerm n) -> ((OpMoufangLoopOLTerm n) -> (OpMoufangLoopOLTerm n)))
    rinvOL' x1 x2 = (rinvOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpMoufangLoopOLTerm n) -> (Staged (OpMoufangLoopOLTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB eOL = (Now eOL) 
    stageOpB (linvOL x1 x2) = (stage2 linvOL' (codeLift2 linvOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (rinvOL x1 x2) = (stage2 rinvOL' (codeLift2 rinvOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpMoufangLoopOL2Term2 n A) -> ((OpMoufangLoopOL2Term2 n A) -> (OpMoufangLoopOL2Term2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    eOL2' : {n : Nat} {A : Set} -> (OpMoufangLoopOL2Term2 n A)
    eOL2'  = eOL2 
    linvOL2' : {n : Nat} {A : Set} -> ((OpMoufangLoopOL2Term2 n A) -> ((OpMoufangLoopOL2Term2 n A) -> (OpMoufangLoopOL2Term2 n A)))
    linvOL2' x1 x2 = (linvOL2 x1 x2) 
    rinvOL2' : {n : Nat} {A : Set} -> ((OpMoufangLoopOL2Term2 n A) -> ((OpMoufangLoopOL2Term2 n A) -> (OpMoufangLoopOL2Term2 n A)))
    rinvOL2' x1 x2 = (rinvOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpMoufangLoopOL2Term2 n A) -> (Staged (OpMoufangLoopOL2Term2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp eOL2 = (Now eOL2) 
    stageOp (linvOL2 x1 x2) = (stage2 linvOL2' (codeLift2 linvOL2') (stageOp x1) (stageOp x2)) 
    stageOp (rinvOL2 x1 x2) = (stage2 rinvOL2' (codeLift2 rinvOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        eT : (Repr A)
        linvT : ((Repr A) -> ((Repr A) -> (Repr A)))
        rinvT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module MoufangQuasiGroup  where
    record MoufangQuasiGroup (A : Set) : Set where
      constructor MoufangQuasiGroupC
      field
        op : (A -> (A -> A))
        linv : (A -> (A -> A))
        leftCancel : {x y : A} -> (op x (linv x y)) == y
        lefCancelOp : {x y : A} -> (linv x (op x y)) == y
        rinv : (A -> (A -> A))
        rightCancel : {x y : A} -> (op (rinv y x) x) == y
        rightCancelOp : {x y : A} -> (rinv (op y x) x) == y
        moufangLaw : {e x y z : A} -> ((op y e) == y -> (op (op (op x y) z) x) == (op x (op y (op (op e z) x))))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        linvS : (AS -> (AS -> AS))
        rinvS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        linvP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        rinvP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftCancelP : {xP yP : (Prod A A)} -> (opP xP (linvP xP yP)) == yP
        lefCancelOpP : {xP yP : (Prod A A)} -> (linvP xP (opP xP yP)) == yP
        rightCancelP : {xP yP : (Prod A A)} -> (opP (rinvP yP xP) xP) == yP
        rightCancelOpP : {xP yP : (Prod A A)} -> (rinvP (opP yP xP) xP) == yP
        moufangLawP : {eP xP yP zP : (Prod A A)} -> ((opP yP eP) == yP -> (opP (opP (opP xP yP) zP) xP) == (opP xP (opP yP (opP (opP eP zP) xP))))
    record Hom {A1 : Set} {A2 : Set} (Mo1 : (MoufangQuasiGroup A1)) (Mo2 : (MoufangQuasiGroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Mo1) x1 x2)) == ((op Mo2) (hom x1) (hom x2))
        pres-linv : {x1 x2 : A1} -> (hom ((linv Mo1) x1 x2)) == ((linv Mo2) (hom x1) (hom x2))
        pres-rinv : {x1 x2 : A1} -> (hom ((rinv Mo1) x1 x2)) == ((rinv Mo2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Mo1 : (MoufangQuasiGroup A1)) (Mo2 : (MoufangQuasiGroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Mo1) x1 x2) ((op Mo2) y1 y2))))
        interp-linv : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((linv Mo1) x1 x2) ((linv Mo2) y1 y2))))
        interp-rinv : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((rinv Mo1) x1 x2) ((rinv Mo2) y1 y2))))
    data MoufangQuasiGroupTerm  : Set where
      opL : (MoufangQuasiGroupTerm -> (MoufangQuasiGroupTerm -> MoufangQuasiGroupTerm))
      linvL : (MoufangQuasiGroupTerm -> (MoufangQuasiGroupTerm -> MoufangQuasiGroupTerm))
      rinvL : (MoufangQuasiGroupTerm -> (MoufangQuasiGroupTerm -> MoufangQuasiGroupTerm))
    data ClMoufangQuasiGroupTerm (A : Set) : Set where
      sing : (A -> (ClMoufangQuasiGroupTerm A))
      opCl : ((ClMoufangQuasiGroupTerm A) -> ((ClMoufangQuasiGroupTerm A) -> (ClMoufangQuasiGroupTerm A)))
      linvCl : ((ClMoufangQuasiGroupTerm A) -> ((ClMoufangQuasiGroupTerm A) -> (ClMoufangQuasiGroupTerm A)))
      rinvCl : ((ClMoufangQuasiGroupTerm A) -> ((ClMoufangQuasiGroupTerm A) -> (ClMoufangQuasiGroupTerm A)))
    data OpMoufangQuasiGroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpMoufangQuasiGroupTerm n))
      opOL : ((OpMoufangQuasiGroupTerm n) -> ((OpMoufangQuasiGroupTerm n) -> (OpMoufangQuasiGroupTerm n)))
      linvOL : ((OpMoufangQuasiGroupTerm n) -> ((OpMoufangQuasiGroupTerm n) -> (OpMoufangQuasiGroupTerm n)))
      rinvOL : ((OpMoufangQuasiGroupTerm n) -> ((OpMoufangQuasiGroupTerm n) -> (OpMoufangQuasiGroupTerm n)))
    data OpMoufangQuasiGroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpMoufangQuasiGroupTerm2 n A))
      sing2 : (A -> (OpMoufangQuasiGroupTerm2 n A))
      opOL2 : ((OpMoufangQuasiGroupTerm2 n A) -> ((OpMoufangQuasiGroupTerm2 n A) -> (OpMoufangQuasiGroupTerm2 n A)))
      linvOL2 : ((OpMoufangQuasiGroupTerm2 n A) -> ((OpMoufangQuasiGroupTerm2 n A) -> (OpMoufangQuasiGroupTerm2 n A)))
      rinvOL2 : ((OpMoufangQuasiGroupTerm2 n A) -> ((OpMoufangQuasiGroupTerm2 n A) -> (OpMoufangQuasiGroupTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClMoufangQuasiGroupTerm A) -> (ClMoufangQuasiGroupTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (linvCl x1 x2) = (linvCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (rinvCl x1 x2) = (rinvCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpMoufangQuasiGroupTerm n) -> (OpMoufangQuasiGroupTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (linvOL x1 x2) = (linvOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (rinvOL x1 x2) = (rinvOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpMoufangQuasiGroupTerm2 n A) -> (OpMoufangQuasiGroupTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (linvOL2 x1 x2) = (linvOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (rinvOL2 x1 x2) = (rinvOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((MoufangQuasiGroup A) -> (MoufangQuasiGroupTerm -> A))
    evalB Mo (opL x1 x2) = ((op Mo) (evalB Mo x1) (evalB Mo x2)) 
    evalB Mo (linvL x1 x2) = ((linv Mo) (evalB Mo x1) (evalB Mo x2)) 
    evalB Mo (rinvL x1 x2) = ((rinv Mo) (evalB Mo x1) (evalB Mo x2)) 
    evalCl : {A : Set} -> ((MoufangQuasiGroup A) -> ((ClMoufangQuasiGroupTerm A) -> A))
    evalCl Mo (sing x1) = x1 
    evalCl Mo (opCl x1 x2) = ((op Mo) (evalCl Mo x1) (evalCl Mo x2)) 
    evalCl Mo (linvCl x1 x2) = ((linv Mo) (evalCl Mo x1) (evalCl Mo x2)) 
    evalCl Mo (rinvCl x1 x2) = ((rinv Mo) (evalCl Mo x1) (evalCl Mo x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((MoufangQuasiGroup A) -> ((Vec A n) -> ((OpMoufangQuasiGroupTerm n) -> A)))
    evalOpB Mo vars (v x1) = (lookup _ x1 vars) 
    evalOpB Mo vars (opOL x1 x2) = ((op Mo) (evalOpB Mo vars x1) (evalOpB Mo vars x2)) 
    evalOpB Mo vars (linvOL x1 x2) = ((linv Mo) (evalOpB Mo vars x1) (evalOpB Mo vars x2)) 
    evalOpB Mo vars (rinvOL x1 x2) = ((rinv Mo) (evalOpB Mo vars x1) (evalOpB Mo vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((MoufangQuasiGroup A) -> ((Vec A n) -> ((OpMoufangQuasiGroupTerm2 n A) -> A)))
    evalOp Mo vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Mo vars (sing2 x1) = x1 
    evalOp Mo vars (opOL2 x1 x2) = ((op Mo) (evalOp Mo vars x1) (evalOp Mo vars x2)) 
    evalOp Mo vars (linvOL2 x1 x2) = ((linv Mo) (evalOp Mo vars x1) (evalOp Mo vars x2)) 
    evalOp Mo vars (rinvOL2 x1 x2) = ((rinv Mo) (evalOp Mo vars x1) (evalOp Mo vars x2)) 
    inductionB : {P : (MoufangQuasiGroupTerm -> Set)} -> (((x1 x2 : MoufangQuasiGroupTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> (((x1 x2 : MoufangQuasiGroupTerm) -> ((P x1) -> ((P x2) -> (P (linvL x1 x2))))) -> (((x1 x2 : MoufangQuasiGroupTerm) -> ((P x1) -> ((P x2) -> (P (rinvL x1 x2))))) -> ((x : MoufangQuasiGroupTerm) -> (P x)))))
    inductionB {p} popl plinvl prinvl (opL x1 x2) = (popl _ _ (inductionB {p} popl plinvl prinvl x1) (inductionB {p} popl plinvl prinvl x2)) 
    inductionB {p} popl plinvl prinvl (linvL x1 x2) = (plinvl _ _ (inductionB {p} popl plinvl prinvl x1) (inductionB {p} popl plinvl prinvl x2)) 
    inductionB {p} popl plinvl prinvl (rinvL x1 x2) = (prinvl _ _ (inductionB {p} popl plinvl prinvl x1) (inductionB {p} popl plinvl prinvl x2)) 
    inductionCl : {A : Set} {P : ((ClMoufangQuasiGroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClMoufangQuasiGroupTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> (((x1 x2 : (ClMoufangQuasiGroupTerm A)) -> ((P x1) -> ((P x2) -> (P (linvCl x1 x2))))) -> (((x1 x2 : (ClMoufangQuasiGroupTerm A)) -> ((P x1) -> ((P x2) -> (P (rinvCl x1 x2))))) -> ((x : (ClMoufangQuasiGroupTerm A)) -> (P x))))))
    inductionCl {_} {p} psing popcl plinvcl prinvcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl plinvcl prinvcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl plinvcl prinvcl x1) (inductionCl {_} {p} psing popcl plinvcl prinvcl x2)) 
    inductionCl {_} {p} psing popcl plinvcl prinvcl (linvCl x1 x2) = (plinvcl _ _ (inductionCl {_} {p} psing popcl plinvcl prinvcl x1) (inductionCl {_} {p} psing popcl plinvcl prinvcl x2)) 
    inductionCl {_} {p} psing popcl plinvcl prinvcl (rinvCl x1 x2) = (prinvcl _ _ (inductionCl {_} {p} psing popcl plinvcl prinvcl x1) (inductionCl {_} {p} psing popcl plinvcl prinvcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpMoufangQuasiGroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpMoufangQuasiGroupTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> (((x1 x2 : (OpMoufangQuasiGroupTerm n)) -> ((P x1) -> ((P x2) -> (P (linvOL x1 x2))))) -> (((x1 x2 : (OpMoufangQuasiGroupTerm n)) -> ((P x1) -> ((P x2) -> (P (rinvOL x1 x2))))) -> ((x : (OpMoufangQuasiGroupTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv popol plinvol prinvol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol plinvol prinvol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol plinvol prinvol x1) (inductionOpB {_} {p} pv popol plinvol prinvol x2)) 
    inductionOpB {_} {p} pv popol plinvol prinvol (linvOL x1 x2) = (plinvol _ _ (inductionOpB {_} {p} pv popol plinvol prinvol x1) (inductionOpB {_} {p} pv popol plinvol prinvol x2)) 
    inductionOpB {_} {p} pv popol plinvol prinvol (rinvOL x1 x2) = (prinvol _ _ (inductionOpB {_} {p} pv popol plinvol prinvol x1) (inductionOpB {_} {p} pv popol plinvol prinvol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpMoufangQuasiGroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpMoufangQuasiGroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> (((x1 x2 : (OpMoufangQuasiGroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (linvOL2 x1 x2))))) -> (((x1 x2 : (OpMoufangQuasiGroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (rinvOL2 x1 x2))))) -> ((x : (OpMoufangQuasiGroupTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 (linvOL2 x1 x2) = (plinvol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 (rinvOL2 x1 x2) = (prinvol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 x2)) 
    opL' : (MoufangQuasiGroupTerm -> (MoufangQuasiGroupTerm -> MoufangQuasiGroupTerm))
    opL' x1 x2 = (opL x1 x2) 
    linvL' : (MoufangQuasiGroupTerm -> (MoufangQuasiGroupTerm -> MoufangQuasiGroupTerm))
    linvL' x1 x2 = (linvL x1 x2) 
    rinvL' : (MoufangQuasiGroupTerm -> (MoufangQuasiGroupTerm -> MoufangQuasiGroupTerm))
    rinvL' x1 x2 = (rinvL x1 x2) 
    stageB : (MoufangQuasiGroupTerm -> (Staged MoufangQuasiGroupTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB (linvL x1 x2) = (stage2 linvL' (codeLift2 linvL') (stageB x1) (stageB x2)) 
    stageB (rinvL x1 x2) = (stage2 rinvL' (codeLift2 rinvL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClMoufangQuasiGroupTerm A) -> ((ClMoufangQuasiGroupTerm A) -> (ClMoufangQuasiGroupTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    linvCl' : {A : Set} -> ((ClMoufangQuasiGroupTerm A) -> ((ClMoufangQuasiGroupTerm A) -> (ClMoufangQuasiGroupTerm A)))
    linvCl' x1 x2 = (linvCl x1 x2) 
    rinvCl' : {A : Set} -> ((ClMoufangQuasiGroupTerm A) -> ((ClMoufangQuasiGroupTerm A) -> (ClMoufangQuasiGroupTerm A)))
    rinvCl' x1 x2 = (rinvCl x1 x2) 
    stageCl : {A : Set} -> ((ClMoufangQuasiGroupTerm A) -> (Staged (ClMoufangQuasiGroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl (linvCl x1 x2) = (stage2 linvCl' (codeLift2 linvCl') (stageCl x1) (stageCl x2)) 
    stageCl (rinvCl x1 x2) = (stage2 rinvCl' (codeLift2 rinvCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpMoufangQuasiGroupTerm n) -> ((OpMoufangQuasiGroupTerm n) -> (OpMoufangQuasiGroupTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    linvOL' : {n : Nat} -> ((OpMoufangQuasiGroupTerm n) -> ((OpMoufangQuasiGroupTerm n) -> (OpMoufangQuasiGroupTerm n)))
    linvOL' x1 x2 = (linvOL x1 x2) 
    rinvOL' : {n : Nat} -> ((OpMoufangQuasiGroupTerm n) -> ((OpMoufangQuasiGroupTerm n) -> (OpMoufangQuasiGroupTerm n)))
    rinvOL' x1 x2 = (rinvOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpMoufangQuasiGroupTerm n) -> (Staged (OpMoufangQuasiGroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (linvOL x1 x2) = (stage2 linvOL' (codeLift2 linvOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (rinvOL x1 x2) = (stage2 rinvOL' (codeLift2 rinvOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpMoufangQuasiGroupTerm2 n A) -> ((OpMoufangQuasiGroupTerm2 n A) -> (OpMoufangQuasiGroupTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    linvOL2' : {n : Nat} {A : Set} -> ((OpMoufangQuasiGroupTerm2 n A) -> ((OpMoufangQuasiGroupTerm2 n A) -> (OpMoufangQuasiGroupTerm2 n A)))
    linvOL2' x1 x2 = (linvOL2 x1 x2) 
    rinvOL2' : {n : Nat} {A : Set} -> ((OpMoufangQuasiGroupTerm2 n A) -> ((OpMoufangQuasiGroupTerm2 n A) -> (OpMoufangQuasiGroupTerm2 n A)))
    rinvOL2' x1 x2 = (rinvOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpMoufangQuasiGroupTerm2 n A) -> (Staged (OpMoufangQuasiGroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp (linvOL2 x1 x2) = (stage2 linvOL2' (codeLift2 linvOL2') (stageOp x1) (stageOp x2)) 
    stageOp (rinvOL2 x1 x2) = (stage2 rinvOL2' (codeLift2 rinvOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        linvT : ((Repr A) -> ((Repr A) -> (Repr A)))
        rinvT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module MultCommutativeMonoid  where
    record MultCommutativeMonoid (A : Set) : Set where
      constructor MultCommutativeMonoidC
      field
        * : (A -> (A -> A))
        1 : A
        lunit_1 : {x : A} -> (* 1 x) == x
        runit_1 : {x : A} -> (* x 1) == x
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        commutative_* : {x y : A} -> (* x y) == (* y x)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        1S : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        1P : (Prod A A)
        lunit_1P : {xP : (Prod A A)} -> (*P 1P xP) == xP
        runit_1P : {xP : (Prod A A)} -> (*P xP 1P) == xP
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        commutative_*P : {xP yP : (Prod A A)} -> (*P xP yP) == (*P yP xP)
    record Hom {A1 : Set} {A2 : Set} (Mu1 : (MultCommutativeMonoid A1)) (Mu2 : (MultCommutativeMonoid A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Mu1) x1 x2)) == ((* Mu2) (hom x1) (hom x2))
        pres-1 : (hom (1 Mu1)) == (1 Mu2)
    record RelInterp {A1 : Set} {A2 : Set} (Mu1 : (MultCommutativeMonoid A1)) (Mu2 : (MultCommutativeMonoid A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Mu1) x1 x2) ((* Mu2) y1 y2))))
        interp-1 : (interp (1 Mu1) (1 Mu2))
    data MultCommutativeMonoidTerm  : Set where
      *L : (MultCommutativeMonoidTerm -> (MultCommutativeMonoidTerm -> MultCommutativeMonoidTerm))
      1L : MultCommutativeMonoidTerm
    data ClMultCommutativeMonoidTerm (A : Set) : Set where
      sing : (A -> (ClMultCommutativeMonoidTerm A))
      *Cl : ((ClMultCommutativeMonoidTerm A) -> ((ClMultCommutativeMonoidTerm A) -> (ClMultCommutativeMonoidTerm A)))
      1Cl : (ClMultCommutativeMonoidTerm A)
    data OpMultCommutativeMonoidTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpMultCommutativeMonoidTerm n))
      *OL : ((OpMultCommutativeMonoidTerm n) -> ((OpMultCommutativeMonoidTerm n) -> (OpMultCommutativeMonoidTerm n)))
      1OL : (OpMultCommutativeMonoidTerm n)
    data OpMultCommutativeMonoidTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpMultCommutativeMonoidTerm2 n A))
      sing2 : (A -> (OpMultCommutativeMonoidTerm2 n A))
      *OL2 : ((OpMultCommutativeMonoidTerm2 n A) -> ((OpMultCommutativeMonoidTerm2 n A) -> (OpMultCommutativeMonoidTerm2 n A)))
      1OL2 : (OpMultCommutativeMonoidTerm2 n A)
    simplifyCl : {A : Set} -> ((ClMultCommutativeMonoidTerm A) -> (ClMultCommutativeMonoidTerm A))
    simplifyCl (*Cl 1Cl x) = x 
    simplifyCl (*Cl x 1Cl) = x 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpMultCommutativeMonoidTerm n) -> (OpMultCommutativeMonoidTerm n))
    simplifyOpB (*OL 1OL x) = x 
    simplifyOpB (*OL x 1OL) = x 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpMultCommutativeMonoidTerm2 n A) -> (OpMultCommutativeMonoidTerm2 n A))
    simplifyOp (*OL2 1OL2 x) = x 
    simplifyOp (*OL2 x 1OL2) = x 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((MultCommutativeMonoid A) -> (MultCommutativeMonoidTerm -> A))
    evalB Mu (*L x1 x2) = ((* Mu) (evalB Mu x1) (evalB Mu x2)) 
    evalB Mu 1L = (1 Mu) 
    evalCl : {A : Set} -> ((MultCommutativeMonoid A) -> ((ClMultCommutativeMonoidTerm A) -> A))
    evalCl Mu (sing x1) = x1 
    evalCl Mu (*Cl x1 x2) = ((* Mu) (evalCl Mu x1) (evalCl Mu x2)) 
    evalCl Mu 1Cl = (1 Mu) 
    evalOpB : {A : Set} {n : Nat} -> ((MultCommutativeMonoid A) -> ((Vec A n) -> ((OpMultCommutativeMonoidTerm n) -> A)))
    evalOpB Mu vars (v x1) = (lookup _ x1 vars) 
    evalOpB Mu vars (*OL x1 x2) = ((* Mu) (evalOpB Mu vars x1) (evalOpB Mu vars x2)) 
    evalOpB Mu vars 1OL = (1 Mu) 
    evalOp : {A : Set} {n : Nat} -> ((MultCommutativeMonoid A) -> ((Vec A n) -> ((OpMultCommutativeMonoidTerm2 n A) -> A)))
    evalOp Mu vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Mu vars (sing2 x1) = x1 
    evalOp Mu vars (*OL2 x1 x2) = ((* Mu) (evalOp Mu vars x1) (evalOp Mu vars x2)) 
    evalOp Mu vars 1OL2 = (1 Mu) 
    inductionB : {P : (MultCommutativeMonoidTerm -> Set)} -> (((x1 x2 : MultCommutativeMonoidTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((P 1L) -> ((x : MultCommutativeMonoidTerm) -> (P x))))
    inductionB {p} p*l p1l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p1l x1) (inductionB {p} p*l p1l x2)) 
    inductionB {p} p*l p1l 1L = p1l 
    inductionCl : {A : Set} {P : ((ClMultCommutativeMonoidTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClMultCommutativeMonoidTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((P 1Cl) -> ((x : (ClMultCommutativeMonoidTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p*cl p1cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p1cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p1cl x1) (inductionCl {_} {p} psing p*cl p1cl x2)) 
    inductionCl {_} {p} psing p*cl p1cl 1Cl = p1cl 
    inductionOpB : {n : Nat} {P : ((OpMultCommutativeMonoidTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpMultCommutativeMonoidTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((P 1OL) -> ((x : (OpMultCommutativeMonoidTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p*ol p1ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p1ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p1ol x1) (inductionOpB {_} {p} pv p*ol p1ol x2)) 
    inductionOpB {_} {p} pv p*ol p1ol 1OL = p1ol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpMultCommutativeMonoidTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpMultCommutativeMonoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((P 1OL2) -> ((x : (OpMultCommutativeMonoidTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 1OL2 = p1ol2 
    *L' : (MultCommutativeMonoidTerm -> (MultCommutativeMonoidTerm -> MultCommutativeMonoidTerm))
    *L' x1 x2 = (*L x1 x2) 
    1L' : MultCommutativeMonoidTerm
    1L'  = 1L 
    stageB : (MultCommutativeMonoidTerm -> (Staged MultCommutativeMonoidTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB 1L = (Now 1L) 
    *Cl' : {A : Set} -> ((ClMultCommutativeMonoidTerm A) -> ((ClMultCommutativeMonoidTerm A) -> (ClMultCommutativeMonoidTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    1Cl' : {A : Set} -> (ClMultCommutativeMonoidTerm A)
    1Cl'  = 1Cl 
    stageCl : {A : Set} -> ((ClMultCommutativeMonoidTerm A) -> (Staged (ClMultCommutativeMonoidTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl 1Cl = (Now 1Cl) 
    *OL' : {n : Nat} -> ((OpMultCommutativeMonoidTerm n) -> ((OpMultCommutativeMonoidTerm n) -> (OpMultCommutativeMonoidTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    1OL' : {n : Nat} -> (OpMultCommutativeMonoidTerm n)
    1OL'  = 1OL 
    stageOpB : {n : Nat} -> ((OpMultCommutativeMonoidTerm n) -> (Staged (OpMultCommutativeMonoidTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 1OL = (Now 1OL) 
    *OL2' : {n : Nat} {A : Set} -> ((OpMultCommutativeMonoidTerm2 n A) -> ((OpMultCommutativeMonoidTerm2 n A) -> (OpMultCommutativeMonoidTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    1OL2' : {n : Nat} {A : Set} -> (OpMultCommutativeMonoidTerm2 n A)
    1OL2'  = 1OL2 
    stageOp : {n : Nat} {A : Set} -> ((OpMultCommutativeMonoidTerm2 n A) -> (Staged (OpMultCommutativeMonoidTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp 1OL2 = (Now 1OL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        1T : (Repr A)
  module MultCommutativeSemigroup  where
    record MultCommutativeSemigroup (A : Set) : Set where
      constructor MultCommutativeSemigroupC
      field
        * : (A -> (A -> A))
        commutative_* : {x y : A} -> (* x y) == (* y x)
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        commutative_*P : {xP yP : (Prod A A)} -> (*P xP yP) == (*P yP xP)
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
    record Hom {A1 : Set} {A2 : Set} (Mu1 : (MultCommutativeSemigroup A1)) (Mu2 : (MultCommutativeSemigroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Mu1) x1 x2)) == ((* Mu2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Mu1 : (MultCommutativeSemigroup A1)) (Mu2 : (MultCommutativeSemigroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Mu1) x1 x2) ((* Mu2) y1 y2))))
    data MultCommutativeSemigroupTerm  : Set where
      *L : (MultCommutativeSemigroupTerm -> (MultCommutativeSemigroupTerm -> MultCommutativeSemigroupTerm))
    data ClMultCommutativeSemigroupTerm (A : Set) : Set where
      sing : (A -> (ClMultCommutativeSemigroupTerm A))
      *Cl : ((ClMultCommutativeSemigroupTerm A) -> ((ClMultCommutativeSemigroupTerm A) -> (ClMultCommutativeSemigroupTerm A)))
    data OpMultCommutativeSemigroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpMultCommutativeSemigroupTerm n))
      *OL : ((OpMultCommutativeSemigroupTerm n) -> ((OpMultCommutativeSemigroupTerm n) -> (OpMultCommutativeSemigroupTerm n)))
    data OpMultCommutativeSemigroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpMultCommutativeSemigroupTerm2 n A))
      sing2 : (A -> (OpMultCommutativeSemigroupTerm2 n A))
      *OL2 : ((OpMultCommutativeSemigroupTerm2 n A) -> ((OpMultCommutativeSemigroupTerm2 n A) -> (OpMultCommutativeSemigroupTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClMultCommutativeSemigroupTerm A) -> (ClMultCommutativeSemigroupTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpMultCommutativeSemigroupTerm n) -> (OpMultCommutativeSemigroupTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpMultCommutativeSemigroupTerm2 n A) -> (OpMultCommutativeSemigroupTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((MultCommutativeSemigroup A) -> (MultCommutativeSemigroupTerm -> A))
    evalB Mu (*L x1 x2) = ((* Mu) (evalB Mu x1) (evalB Mu x2)) 
    evalCl : {A : Set} -> ((MultCommutativeSemigroup A) -> ((ClMultCommutativeSemigroupTerm A) -> A))
    evalCl Mu (sing x1) = x1 
    evalCl Mu (*Cl x1 x2) = ((* Mu) (evalCl Mu x1) (evalCl Mu x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((MultCommutativeSemigroup A) -> ((Vec A n) -> ((OpMultCommutativeSemigroupTerm n) -> A)))
    evalOpB Mu vars (v x1) = (lookup _ x1 vars) 
    evalOpB Mu vars (*OL x1 x2) = ((* Mu) (evalOpB Mu vars x1) (evalOpB Mu vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((MultCommutativeSemigroup A) -> ((Vec A n) -> ((OpMultCommutativeSemigroupTerm2 n A) -> A)))
    evalOp Mu vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Mu vars (sing2 x1) = x1 
    evalOp Mu vars (*OL2 x1 x2) = ((* Mu) (evalOp Mu vars x1) (evalOp Mu vars x2)) 
    inductionB : {P : (MultCommutativeSemigroupTerm -> Set)} -> (((x1 x2 : MultCommutativeSemigroupTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((x : MultCommutativeSemigroupTerm) -> (P x)))
    inductionB {p} p*l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l x1) (inductionB {p} p*l x2)) 
    inductionCl : {A : Set} {P : ((ClMultCommutativeSemigroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClMultCommutativeSemigroupTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((x : (ClMultCommutativeSemigroupTerm A)) -> (P x))))
    inductionCl {_} {p} psing p*cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl x1) (inductionCl {_} {p} psing p*cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpMultCommutativeSemigroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpMultCommutativeSemigroupTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((x : (OpMultCommutativeSemigroupTerm n)) -> (P x))))
    inductionOpB {_} {p} pv p*ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol x1) (inductionOpB {_} {p} pv p*ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpMultCommutativeSemigroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpMultCommutativeSemigroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((x : (OpMultCommutativeSemigroupTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 x2)) 
    *L' : (MultCommutativeSemigroupTerm -> (MultCommutativeSemigroupTerm -> MultCommutativeSemigroupTerm))
    *L' x1 x2 = (*L x1 x2) 
    stageB : (MultCommutativeSemigroupTerm -> (Staged MultCommutativeSemigroupTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClMultCommutativeSemigroupTerm A) -> ((ClMultCommutativeSemigroupTerm A) -> (ClMultCommutativeSemigroupTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    stageCl : {A : Set} -> ((ClMultCommutativeSemigroupTerm A) -> (Staged (ClMultCommutativeSemigroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpMultCommutativeSemigroupTerm n) -> ((OpMultCommutativeSemigroupTerm n) -> (OpMultCommutativeSemigroupTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpMultCommutativeSemigroupTerm n) -> (Staged (OpMultCommutativeSemigroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpMultCommutativeSemigroupTerm2 n A) -> ((OpMultCommutativeSemigroupTerm2 n A) -> (OpMultCommutativeSemigroupTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpMultCommutativeSemigroupTerm2 n A) -> (Staged (OpMultCommutativeSemigroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module MultGroup  where
    record MultGroup (A : Set) : Set where
      constructor MultGroupC
      field
        * : (A -> (A -> A))
        1 : A
        lunit_1 : {x : A} -> (* 1 x) == x
        runit_1 : {x : A} -> (* x 1) == x
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        inv : (A -> A)
        leftInverse_inv_op_1 : {x : A} -> (* x (inv x)) == 1
        rightInverse_inv_op_1 : {x : A} -> (* (inv x) x) == 1
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        1S : AS
        invS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        1P : (Prod A A)
        invP : ((Prod A A) -> (Prod A A))
        lunit_1P : {xP : (Prod A A)} -> (*P 1P xP) == xP
        runit_1P : {xP : (Prod A A)} -> (*P xP 1P) == xP
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        leftInverse_inv_op_1P : {xP : (Prod A A)} -> (*P xP (invP xP)) == 1P
        rightInverse_inv_op_1P : {xP : (Prod A A)} -> (*P (invP xP) xP) == 1P
    record Hom {A1 : Set} {A2 : Set} (Mu1 : (MultGroup A1)) (Mu2 : (MultGroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Mu1) x1 x2)) == ((* Mu2) (hom x1) (hom x2))
        pres-1 : (hom (1 Mu1)) == (1 Mu2)
        pres-inv : {x1 : A1} -> (hom ((inv Mu1) x1)) == ((inv Mu2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (Mu1 : (MultGroup A1)) (Mu2 : (MultGroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Mu1) x1 x2) ((* Mu2) y1 y2))))
        interp-1 : (interp (1 Mu1) (1 Mu2))
        interp-inv : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((inv Mu1) x1) ((inv Mu2) y1)))
    data MultGroupTerm  : Set where
      *L : (MultGroupTerm -> (MultGroupTerm -> MultGroupTerm))
      1L : MultGroupTerm
      invL : (MultGroupTerm -> MultGroupTerm)
    data ClMultGroupTerm (A : Set) : Set where
      sing : (A -> (ClMultGroupTerm A))
      *Cl : ((ClMultGroupTerm A) -> ((ClMultGroupTerm A) -> (ClMultGroupTerm A)))
      1Cl : (ClMultGroupTerm A)
      invCl : ((ClMultGroupTerm A) -> (ClMultGroupTerm A))
    data OpMultGroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpMultGroupTerm n))
      *OL : ((OpMultGroupTerm n) -> ((OpMultGroupTerm n) -> (OpMultGroupTerm n)))
      1OL : (OpMultGroupTerm n)
      invOL : ((OpMultGroupTerm n) -> (OpMultGroupTerm n))
    data OpMultGroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpMultGroupTerm2 n A))
      sing2 : (A -> (OpMultGroupTerm2 n A))
      *OL2 : ((OpMultGroupTerm2 n A) -> ((OpMultGroupTerm2 n A) -> (OpMultGroupTerm2 n A)))
      1OL2 : (OpMultGroupTerm2 n A)
      invOL2 : ((OpMultGroupTerm2 n A) -> (OpMultGroupTerm2 n A))
    simplifyCl : {A : Set} -> ((ClMultGroupTerm A) -> (ClMultGroupTerm A))
    simplifyCl (*Cl 1Cl x) = x 
    simplifyCl (*Cl x 1Cl) = x 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (invCl x1) = (invCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpMultGroupTerm n) -> (OpMultGroupTerm n))
    simplifyOpB (*OL 1OL x) = x 
    simplifyOpB (*OL x 1OL) = x 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (invOL x1) = (invOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpMultGroupTerm2 n A) -> (OpMultGroupTerm2 n A))
    simplifyOp (*OL2 1OL2 x) = x 
    simplifyOp (*OL2 x 1OL2) = x 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (invOL2 x1) = (invOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((MultGroup A) -> (MultGroupTerm -> A))
    evalB Mu (*L x1 x2) = ((* Mu) (evalB Mu x1) (evalB Mu x2)) 
    evalB Mu 1L = (1 Mu) 
    evalB Mu (invL x1) = ((inv Mu) (evalB Mu x1)) 
    evalCl : {A : Set} -> ((MultGroup A) -> ((ClMultGroupTerm A) -> A))
    evalCl Mu (sing x1) = x1 
    evalCl Mu (*Cl x1 x2) = ((* Mu) (evalCl Mu x1) (evalCl Mu x2)) 
    evalCl Mu 1Cl = (1 Mu) 
    evalCl Mu (invCl x1) = ((inv Mu) (evalCl Mu x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((MultGroup A) -> ((Vec A n) -> ((OpMultGroupTerm n) -> A)))
    evalOpB Mu vars (v x1) = (lookup _ x1 vars) 
    evalOpB Mu vars (*OL x1 x2) = ((* Mu) (evalOpB Mu vars x1) (evalOpB Mu vars x2)) 
    evalOpB Mu vars 1OL = (1 Mu) 
    evalOpB Mu vars (invOL x1) = ((inv Mu) (evalOpB Mu vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((MultGroup A) -> ((Vec A n) -> ((OpMultGroupTerm2 n A) -> A)))
    evalOp Mu vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Mu vars (sing2 x1) = x1 
    evalOp Mu vars (*OL2 x1 x2) = ((* Mu) (evalOp Mu vars x1) (evalOp Mu vars x2)) 
    evalOp Mu vars 1OL2 = (1 Mu) 
    evalOp Mu vars (invOL2 x1) = ((inv Mu) (evalOp Mu vars x1)) 
    inductionB : {P : (MultGroupTerm -> Set)} -> (((x1 x2 : MultGroupTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((P 1L) -> (((x1 : MultGroupTerm) -> ((P x1) -> (P (invL x1)))) -> ((x : MultGroupTerm) -> (P x)))))
    inductionB {p} p*l p1l pinvl (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p1l pinvl x1) (inductionB {p} p*l p1l pinvl x2)) 
    inductionB {p} p*l p1l pinvl 1L = p1l 
    inductionB {p} p*l p1l pinvl (invL x1) = (pinvl _ (inductionB {p} p*l p1l pinvl x1)) 
    inductionCl : {A : Set} {P : ((ClMultGroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClMultGroupTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((P 1Cl) -> (((x1 : (ClMultGroupTerm A)) -> ((P x1) -> (P (invCl x1)))) -> ((x : (ClMultGroupTerm A)) -> (P x))))))
    inductionCl {_} {p} psing p*cl p1cl pinvcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p1cl pinvcl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p1cl pinvcl x1) (inductionCl {_} {p} psing p*cl p1cl pinvcl x2)) 
    inductionCl {_} {p} psing p*cl p1cl pinvcl 1Cl = p1cl 
    inductionCl {_} {p} psing p*cl p1cl pinvcl (invCl x1) = (pinvcl _ (inductionCl {_} {p} psing p*cl p1cl pinvcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpMultGroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpMultGroupTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((P 1OL) -> (((x1 : (OpMultGroupTerm n)) -> ((P x1) -> (P (invOL x1)))) -> ((x : (OpMultGroupTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv p*ol p1ol pinvol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p1ol pinvol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p1ol pinvol x1) (inductionOpB {_} {p} pv p*ol p1ol pinvol x2)) 
    inductionOpB {_} {p} pv p*ol p1ol pinvol 1OL = p1ol 
    inductionOpB {_} {p} pv p*ol p1ol pinvol (invOL x1) = (pinvol _ (inductionOpB {_} {p} pv p*ol p1ol pinvol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpMultGroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpMultGroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((P 1OL2) -> (((x1 : (OpMultGroupTerm2 n A)) -> ((P x1) -> (P (invOL2 x1)))) -> ((x : (OpMultGroupTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 pinvol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 pinvol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 pinvol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 pinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 pinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 pinvol2 1OL2 = p1ol2 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 pinvol2 (invOL2 x1) = (pinvol2 _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 pinvol2 x1)) 
    *L' : (MultGroupTerm -> (MultGroupTerm -> MultGroupTerm))
    *L' x1 x2 = (*L x1 x2) 
    1L' : MultGroupTerm
    1L'  = 1L 
    invL' : (MultGroupTerm -> MultGroupTerm)
    invL' x1 = (invL x1) 
    stageB : (MultGroupTerm -> (Staged MultGroupTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB 1L = (Now 1L) 
    stageB (invL x1) = (stage1 invL' (codeLift1 invL') (stageB x1)) 
    *Cl' : {A : Set} -> ((ClMultGroupTerm A) -> ((ClMultGroupTerm A) -> (ClMultGroupTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    1Cl' : {A : Set} -> (ClMultGroupTerm A)
    1Cl'  = 1Cl 
    invCl' : {A : Set} -> ((ClMultGroupTerm A) -> (ClMultGroupTerm A))
    invCl' x1 = (invCl x1) 
    stageCl : {A : Set} -> ((ClMultGroupTerm A) -> (Staged (ClMultGroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl 1Cl = (Now 1Cl) 
    stageCl (invCl x1) = (stage1 invCl' (codeLift1 invCl') (stageCl x1)) 
    *OL' : {n : Nat} -> ((OpMultGroupTerm n) -> ((OpMultGroupTerm n) -> (OpMultGroupTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    1OL' : {n : Nat} -> (OpMultGroupTerm n)
    1OL'  = 1OL 
    invOL' : {n : Nat} -> ((OpMultGroupTerm n) -> (OpMultGroupTerm n))
    invOL' x1 = (invOL x1) 
    stageOpB : {n : Nat} -> ((OpMultGroupTerm n) -> (Staged (OpMultGroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 1OL = (Now 1OL) 
    stageOpB (invOL x1) = (stage1 invOL' (codeLift1 invOL') (stageOpB x1)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpMultGroupTerm2 n A) -> ((OpMultGroupTerm2 n A) -> (OpMultGroupTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    1OL2' : {n : Nat} {A : Set} -> (OpMultGroupTerm2 n A)
    1OL2'  = 1OL2 
    invOL2' : {n : Nat} {A : Set} -> ((OpMultGroupTerm2 n A) -> (OpMultGroupTerm2 n A))
    invOL2' x1 = (invOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpMultGroupTerm2 n A) -> (Staged (OpMultGroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp 1OL2 = (Now 1OL2) 
    stageOp (invOL2 x1) = (stage1 invOL2' (codeLift1 invOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        1T : (Repr A)
        invT : ((Repr A) -> (Repr A))
  module MultMagma  where
    record MultMagma (A : Set) : Set where
      constructor MultMagmaC
      field
        * : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
    record Hom {A1 : Set} {A2 : Set} (Mu1 : (MultMagma A1)) (Mu2 : (MultMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Mu1) x1 x2)) == ((* Mu2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Mu1 : (MultMagma A1)) (Mu2 : (MultMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Mu1) x1 x2) ((* Mu2) y1 y2))))
    data MultMagmaTerm  : Set where
      *L : (MultMagmaTerm -> (MultMagmaTerm -> MultMagmaTerm))
    data ClMultMagmaTerm (A : Set) : Set where
      sing : (A -> (ClMultMagmaTerm A))
      *Cl : ((ClMultMagmaTerm A) -> ((ClMultMagmaTerm A) -> (ClMultMagmaTerm A)))
    data OpMultMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpMultMagmaTerm n))
      *OL : ((OpMultMagmaTerm n) -> ((OpMultMagmaTerm n) -> (OpMultMagmaTerm n)))
    data OpMultMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpMultMagmaTerm2 n A))
      sing2 : (A -> (OpMultMagmaTerm2 n A))
      *OL2 : ((OpMultMagmaTerm2 n A) -> ((OpMultMagmaTerm2 n A) -> (OpMultMagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClMultMagmaTerm A) -> (ClMultMagmaTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpMultMagmaTerm n) -> (OpMultMagmaTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpMultMagmaTerm2 n A) -> (OpMultMagmaTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((MultMagma A) -> (MultMagmaTerm -> A))
    evalB Mu (*L x1 x2) = ((* Mu) (evalB Mu x1) (evalB Mu x2)) 
    evalCl : {A : Set} -> ((MultMagma A) -> ((ClMultMagmaTerm A) -> A))
    evalCl Mu (sing x1) = x1 
    evalCl Mu (*Cl x1 x2) = ((* Mu) (evalCl Mu x1) (evalCl Mu x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((MultMagma A) -> ((Vec A n) -> ((OpMultMagmaTerm n) -> A)))
    evalOpB Mu vars (v x1) = (lookup _ x1 vars) 
    evalOpB Mu vars (*OL x1 x2) = ((* Mu) (evalOpB Mu vars x1) (evalOpB Mu vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((MultMagma A) -> ((Vec A n) -> ((OpMultMagmaTerm2 n A) -> A)))
    evalOp Mu vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Mu vars (sing2 x1) = x1 
    evalOp Mu vars (*OL2 x1 x2) = ((* Mu) (evalOp Mu vars x1) (evalOp Mu vars x2)) 
    inductionB : {P : (MultMagmaTerm -> Set)} -> (((x1 x2 : MultMagmaTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((x : MultMagmaTerm) -> (P x)))
    inductionB {p} p*l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l x1) (inductionB {p} p*l x2)) 
    inductionCl : {A : Set} {P : ((ClMultMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClMultMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((x : (ClMultMagmaTerm A)) -> (P x))))
    inductionCl {_} {p} psing p*cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl x1) (inductionCl {_} {p} psing p*cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpMultMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpMultMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((x : (OpMultMagmaTerm n)) -> (P x))))
    inductionOpB {_} {p} pv p*ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol x1) (inductionOpB {_} {p} pv p*ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpMultMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpMultMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((x : (OpMultMagmaTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 x2)) 
    *L' : (MultMagmaTerm -> (MultMagmaTerm -> MultMagmaTerm))
    *L' x1 x2 = (*L x1 x2) 
    stageB : (MultMagmaTerm -> (Staged MultMagmaTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClMultMagmaTerm A) -> ((ClMultMagmaTerm A) -> (ClMultMagmaTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    stageCl : {A : Set} -> ((ClMultMagmaTerm A) -> (Staged (ClMultMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpMultMagmaTerm n) -> ((OpMultMagmaTerm n) -> (OpMultMagmaTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpMultMagmaTerm n) -> (Staged (OpMultMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpMultMagmaTerm2 n A) -> ((OpMultMagmaTerm2 n A) -> (OpMultMagmaTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpMultMagmaTerm2 n A) -> (Staged (OpMultMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module MultMeetSemilattice  where
    record MultMeetSemilattice (A : Set) : Set where
      constructor MultMeetSemilatticeC
      field
        * : (A -> (A -> A))
        commutative_* : {x y : A} -> (* x y) == (* y x)
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        idempotent_* : {x : A} -> (* x x) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        commutative_*P : {xP yP : (Prod A A)} -> (*P xP yP) == (*P yP xP)
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        idempotent_*P : {xP : (Prod A A)} -> (*P xP xP) == xP
    record Hom {A1 : Set} {A2 : Set} (Mu1 : (MultMeetSemilattice A1)) (Mu2 : (MultMeetSemilattice A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Mu1) x1 x2)) == ((* Mu2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Mu1 : (MultMeetSemilattice A1)) (Mu2 : (MultMeetSemilattice A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Mu1) x1 x2) ((* Mu2) y1 y2))))
    data MultMeetSemilatticeTerm  : Set where
      *L : (MultMeetSemilatticeTerm -> (MultMeetSemilatticeTerm -> MultMeetSemilatticeTerm))
    data ClMultMeetSemilatticeTerm (A : Set) : Set where
      sing : (A -> (ClMultMeetSemilatticeTerm A))
      *Cl : ((ClMultMeetSemilatticeTerm A) -> ((ClMultMeetSemilatticeTerm A) -> (ClMultMeetSemilatticeTerm A)))
    data OpMultMeetSemilatticeTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpMultMeetSemilatticeTerm n))
      *OL : ((OpMultMeetSemilatticeTerm n) -> ((OpMultMeetSemilatticeTerm n) -> (OpMultMeetSemilatticeTerm n)))
    data OpMultMeetSemilatticeTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpMultMeetSemilatticeTerm2 n A))
      sing2 : (A -> (OpMultMeetSemilatticeTerm2 n A))
      *OL2 : ((OpMultMeetSemilatticeTerm2 n A) -> ((OpMultMeetSemilatticeTerm2 n A) -> (OpMultMeetSemilatticeTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClMultMeetSemilatticeTerm A) -> (ClMultMeetSemilatticeTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpMultMeetSemilatticeTerm n) -> (OpMultMeetSemilatticeTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpMultMeetSemilatticeTerm2 n A) -> (OpMultMeetSemilatticeTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((MultMeetSemilattice A) -> (MultMeetSemilatticeTerm -> A))
    evalB Mu (*L x1 x2) = ((* Mu) (evalB Mu x1) (evalB Mu x2)) 
    evalCl : {A : Set} -> ((MultMeetSemilattice A) -> ((ClMultMeetSemilatticeTerm A) -> A))
    evalCl Mu (sing x1) = x1 
    evalCl Mu (*Cl x1 x2) = ((* Mu) (evalCl Mu x1) (evalCl Mu x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((MultMeetSemilattice A) -> ((Vec A n) -> ((OpMultMeetSemilatticeTerm n) -> A)))
    evalOpB Mu vars (v x1) = (lookup _ x1 vars) 
    evalOpB Mu vars (*OL x1 x2) = ((* Mu) (evalOpB Mu vars x1) (evalOpB Mu vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((MultMeetSemilattice A) -> ((Vec A n) -> ((OpMultMeetSemilatticeTerm2 n A) -> A)))
    evalOp Mu vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Mu vars (sing2 x1) = x1 
    evalOp Mu vars (*OL2 x1 x2) = ((* Mu) (evalOp Mu vars x1) (evalOp Mu vars x2)) 
    inductionB : {P : (MultMeetSemilatticeTerm -> Set)} -> (((x1 x2 : MultMeetSemilatticeTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((x : MultMeetSemilatticeTerm) -> (P x)))
    inductionB {p} p*l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l x1) (inductionB {p} p*l x2)) 
    inductionCl : {A : Set} {P : ((ClMultMeetSemilatticeTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClMultMeetSemilatticeTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((x : (ClMultMeetSemilatticeTerm A)) -> (P x))))
    inductionCl {_} {p} psing p*cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl x1) (inductionCl {_} {p} psing p*cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpMultMeetSemilatticeTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpMultMeetSemilatticeTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((x : (OpMultMeetSemilatticeTerm n)) -> (P x))))
    inductionOpB {_} {p} pv p*ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol x1) (inductionOpB {_} {p} pv p*ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpMultMeetSemilatticeTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpMultMeetSemilatticeTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((x : (OpMultMeetSemilatticeTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 x2)) 
    *L' : (MultMeetSemilatticeTerm -> (MultMeetSemilatticeTerm -> MultMeetSemilatticeTerm))
    *L' x1 x2 = (*L x1 x2) 
    stageB : (MultMeetSemilatticeTerm -> (Staged MultMeetSemilatticeTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClMultMeetSemilatticeTerm A) -> ((ClMultMeetSemilatticeTerm A) -> (ClMultMeetSemilatticeTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    stageCl : {A : Set} -> ((ClMultMeetSemilatticeTerm A) -> (Staged (ClMultMeetSemilatticeTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpMultMeetSemilatticeTerm n) -> ((OpMultMeetSemilatticeTerm n) -> (OpMultMeetSemilatticeTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpMultMeetSemilatticeTerm n) -> (Staged (OpMultMeetSemilatticeTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpMultMeetSemilatticeTerm2 n A) -> ((OpMultMeetSemilatticeTerm2 n A) -> (OpMultMeetSemilatticeTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpMultMeetSemilatticeTerm2 n A) -> (Staged (OpMultMeetSemilatticeTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module MultMonoid  where
    record MultMonoid (A : Set) : Set where
      constructor MultMonoidC
      field
        1 : A
        * : (A -> (A -> A))
        lunit_1 : {x : A} -> (* 1 x) == x
        runit_1 : {x : A} -> (* x 1) == x
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        1S : AS
        *S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        1P : (Prod A A)
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        lunit_1P : {xP : (Prod A A)} -> (*P 1P xP) == xP
        runit_1P : {xP : (Prod A A)} -> (*P xP 1P) == xP
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
    record Hom {A1 : Set} {A2 : Set} (Mu1 : (MultMonoid A1)) (Mu2 : (MultMonoid A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-1 : (hom (1 Mu1)) == (1 Mu2)
        pres-* : {x1 x2 : A1} -> (hom ((* Mu1) x1 x2)) == ((* Mu2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Mu1 : (MultMonoid A1)) (Mu2 : (MultMonoid A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-1 : (interp (1 Mu1) (1 Mu2))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Mu1) x1 x2) ((* Mu2) y1 y2))))
    data MultMonoidTerm  : Set where
      1L : MultMonoidTerm
      *L : (MultMonoidTerm -> (MultMonoidTerm -> MultMonoidTerm))
    data ClMultMonoidTerm (A : Set) : Set where
      sing : (A -> (ClMultMonoidTerm A))
      1Cl : (ClMultMonoidTerm A)
      *Cl : ((ClMultMonoidTerm A) -> ((ClMultMonoidTerm A) -> (ClMultMonoidTerm A)))
    data OpMultMonoidTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpMultMonoidTerm n))
      1OL : (OpMultMonoidTerm n)
      *OL : ((OpMultMonoidTerm n) -> ((OpMultMonoidTerm n) -> (OpMultMonoidTerm n)))
    data OpMultMonoidTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpMultMonoidTerm2 n A))
      sing2 : (A -> (OpMultMonoidTerm2 n A))
      1OL2 : (OpMultMonoidTerm2 n A)
      *OL2 : ((OpMultMonoidTerm2 n A) -> ((OpMultMonoidTerm2 n A) -> (OpMultMonoidTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClMultMonoidTerm A) -> (ClMultMonoidTerm A))
    simplifyCl (*Cl 1Cl x) = x 
    simplifyCl (*Cl x 1Cl) = x 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpMultMonoidTerm n) -> (OpMultMonoidTerm n))
    simplifyOpB (*OL 1OL x) = x 
    simplifyOpB (*OL x 1OL) = x 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpMultMonoidTerm2 n A) -> (OpMultMonoidTerm2 n A))
    simplifyOp (*OL2 1OL2 x) = x 
    simplifyOp (*OL2 x 1OL2) = x 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((MultMonoid A) -> (MultMonoidTerm -> A))
    evalB Mu 1L = (1 Mu) 
    evalB Mu (*L x1 x2) = ((* Mu) (evalB Mu x1) (evalB Mu x2)) 
    evalCl : {A : Set} -> ((MultMonoid A) -> ((ClMultMonoidTerm A) -> A))
    evalCl Mu (sing x1) = x1 
    evalCl Mu 1Cl = (1 Mu) 
    evalCl Mu (*Cl x1 x2) = ((* Mu) (evalCl Mu x1) (evalCl Mu x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((MultMonoid A) -> ((Vec A n) -> ((OpMultMonoidTerm n) -> A)))
    evalOpB Mu vars (v x1) = (lookup _ x1 vars) 
    evalOpB Mu vars 1OL = (1 Mu) 
    evalOpB Mu vars (*OL x1 x2) = ((* Mu) (evalOpB Mu vars x1) (evalOpB Mu vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((MultMonoid A) -> ((Vec A n) -> ((OpMultMonoidTerm2 n A) -> A)))
    evalOp Mu vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Mu vars (sing2 x1) = x1 
    evalOp Mu vars 1OL2 = (1 Mu) 
    evalOp Mu vars (*OL2 x1 x2) = ((* Mu) (evalOp Mu vars x1) (evalOp Mu vars x2)) 
    inductionB : {P : (MultMonoidTerm -> Set)} -> ((P 1L) -> (((x1 x2 : MultMonoidTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((x : MultMonoidTerm) -> (P x))))
    inductionB {p} p1l p*l 1L = p1l 
    inductionB {p} p1l p*l (*L x1 x2) = (p*l _ _ (inductionB {p} p1l p*l x1) (inductionB {p} p1l p*l x2)) 
    inductionCl : {A : Set} {P : ((ClMultMonoidTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 1Cl) -> (((x1 x2 : (ClMultMonoidTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((x : (ClMultMonoidTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p1cl p*cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p1cl p*cl 1Cl = p1cl 
    inductionCl {_} {p} psing p1cl p*cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p1cl p*cl x1) (inductionCl {_} {p} psing p1cl p*cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpMultMonoidTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 1OL) -> (((x1 x2 : (OpMultMonoidTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((x : (OpMultMonoidTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p1ol p*ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p1ol p*ol 1OL = p1ol 
    inductionOpB {_} {p} pv p1ol p*ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p1ol p*ol x1) (inductionOpB {_} {p} pv p1ol p*ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpMultMonoidTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 1OL2) -> (((x1 x2 : (OpMultMonoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((x : (OpMultMonoidTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 1OL2 = p1ol2 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 x2)) 
    1L' : MultMonoidTerm
    1L'  = 1L 
    *L' : (MultMonoidTerm -> (MultMonoidTerm -> MultMonoidTerm))
    *L' x1 x2 = (*L x1 x2) 
    stageB : (MultMonoidTerm -> (Staged MultMonoidTerm))
    stageB 1L = (Now 1L) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    1Cl' : {A : Set} -> (ClMultMonoidTerm A)
    1Cl'  = 1Cl 
    *Cl' : {A : Set} -> ((ClMultMonoidTerm A) -> ((ClMultMonoidTerm A) -> (ClMultMonoidTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    stageCl : {A : Set} -> ((ClMultMonoidTerm A) -> (Staged (ClMultMonoidTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 1Cl = (Now 1Cl) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    1OL' : {n : Nat} -> (OpMultMonoidTerm n)
    1OL'  = 1OL 
    *OL' : {n : Nat} -> ((OpMultMonoidTerm n) -> ((OpMultMonoidTerm n) -> (OpMultMonoidTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpMultMonoidTerm n) -> (Staged (OpMultMonoidTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 1OL = (Now 1OL) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    1OL2' : {n : Nat} {A : Set} -> (OpMultMonoidTerm2 n A)
    1OL2'  = 1OL2 
    *OL2' : {n : Nat} {A : Set} -> ((OpMultMonoidTerm2 n A) -> ((OpMultMonoidTerm2 n A) -> (OpMultMonoidTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpMultMonoidTerm2 n A) -> (Staged (OpMultMonoidTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 1OL2 = (Now 1OL2) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        1T : (Repr A)
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module MultPointedMagma  where
    record MultPointedMagma (A : Set) : Set where
      constructor MultPointedMagmaC
      field
        1 : A
        * : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        1S : AS
        *S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        1P : (Prod A A)
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
    record Hom {A1 : Set} {A2 : Set} (Mu1 : (MultPointedMagma A1)) (Mu2 : (MultPointedMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-1 : (hom (1 Mu1)) == (1 Mu2)
        pres-* : {x1 x2 : A1} -> (hom ((* Mu1) x1 x2)) == ((* Mu2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Mu1 : (MultPointedMagma A1)) (Mu2 : (MultPointedMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-1 : (interp (1 Mu1) (1 Mu2))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Mu1) x1 x2) ((* Mu2) y1 y2))))
    data MultPointedMagmaTerm  : Set where
      1L : MultPointedMagmaTerm
      *L : (MultPointedMagmaTerm -> (MultPointedMagmaTerm -> MultPointedMagmaTerm))
    data ClMultPointedMagmaTerm (A : Set) : Set where
      sing : (A -> (ClMultPointedMagmaTerm A))
      1Cl : (ClMultPointedMagmaTerm A)
      *Cl : ((ClMultPointedMagmaTerm A) -> ((ClMultPointedMagmaTerm A) -> (ClMultPointedMagmaTerm A)))
    data OpMultPointedMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpMultPointedMagmaTerm n))
      1OL : (OpMultPointedMagmaTerm n)
      *OL : ((OpMultPointedMagmaTerm n) -> ((OpMultPointedMagmaTerm n) -> (OpMultPointedMagmaTerm n)))
    data OpMultPointedMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpMultPointedMagmaTerm2 n A))
      sing2 : (A -> (OpMultPointedMagmaTerm2 n A))
      1OL2 : (OpMultPointedMagmaTerm2 n A)
      *OL2 : ((OpMultPointedMagmaTerm2 n A) -> ((OpMultPointedMagmaTerm2 n A) -> (OpMultPointedMagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClMultPointedMagmaTerm A) -> (ClMultPointedMagmaTerm A))
    simplifyCl 1Cl = 1Cl 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpMultPointedMagmaTerm n) -> (OpMultPointedMagmaTerm n))
    simplifyOpB 1OL = 1OL 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpMultPointedMagmaTerm2 n A) -> (OpMultPointedMagmaTerm2 n A))
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((MultPointedMagma A) -> (MultPointedMagmaTerm -> A))
    evalB Mu 1L = (1 Mu) 
    evalB Mu (*L x1 x2) = ((* Mu) (evalB Mu x1) (evalB Mu x2)) 
    evalCl : {A : Set} -> ((MultPointedMagma A) -> ((ClMultPointedMagmaTerm A) -> A))
    evalCl Mu (sing x1) = x1 
    evalCl Mu 1Cl = (1 Mu) 
    evalCl Mu (*Cl x1 x2) = ((* Mu) (evalCl Mu x1) (evalCl Mu x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((MultPointedMagma A) -> ((Vec A n) -> ((OpMultPointedMagmaTerm n) -> A)))
    evalOpB Mu vars (v x1) = (lookup _ x1 vars) 
    evalOpB Mu vars 1OL = (1 Mu) 
    evalOpB Mu vars (*OL x1 x2) = ((* Mu) (evalOpB Mu vars x1) (evalOpB Mu vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((MultPointedMagma A) -> ((Vec A n) -> ((OpMultPointedMagmaTerm2 n A) -> A)))
    evalOp Mu vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Mu vars (sing2 x1) = x1 
    evalOp Mu vars 1OL2 = (1 Mu) 
    evalOp Mu vars (*OL2 x1 x2) = ((* Mu) (evalOp Mu vars x1) (evalOp Mu vars x2)) 
    inductionB : {P : (MultPointedMagmaTerm -> Set)} -> ((P 1L) -> (((x1 x2 : MultPointedMagmaTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((x : MultPointedMagmaTerm) -> (P x))))
    inductionB {p} p1l p*l 1L = p1l 
    inductionB {p} p1l p*l (*L x1 x2) = (p*l _ _ (inductionB {p} p1l p*l x1) (inductionB {p} p1l p*l x2)) 
    inductionCl : {A : Set} {P : ((ClMultPointedMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 1Cl) -> (((x1 x2 : (ClMultPointedMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((x : (ClMultPointedMagmaTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p1cl p*cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p1cl p*cl 1Cl = p1cl 
    inductionCl {_} {p} psing p1cl p*cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p1cl p*cl x1) (inductionCl {_} {p} psing p1cl p*cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpMultPointedMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 1OL) -> (((x1 x2 : (OpMultPointedMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((x : (OpMultPointedMagmaTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p1ol p*ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p1ol p*ol 1OL = p1ol 
    inductionOpB {_} {p} pv p1ol p*ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p1ol p*ol x1) (inductionOpB {_} {p} pv p1ol p*ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpMultPointedMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 1OL2) -> (((x1 x2 : (OpMultPointedMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((x : (OpMultPointedMagmaTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 1OL2 = p1ol2 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 x2)) 
    1L' : MultPointedMagmaTerm
    1L'  = 1L 
    *L' : (MultPointedMagmaTerm -> (MultPointedMagmaTerm -> MultPointedMagmaTerm))
    *L' x1 x2 = (*L x1 x2) 
    stageB : (MultPointedMagmaTerm -> (Staged MultPointedMagmaTerm))
    stageB 1L = (Now 1L) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    1Cl' : {A : Set} -> (ClMultPointedMagmaTerm A)
    1Cl'  = 1Cl 
    *Cl' : {A : Set} -> ((ClMultPointedMagmaTerm A) -> ((ClMultPointedMagmaTerm A) -> (ClMultPointedMagmaTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    stageCl : {A : Set} -> ((ClMultPointedMagmaTerm A) -> (Staged (ClMultPointedMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 1Cl = (Now 1Cl) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    1OL' : {n : Nat} -> (OpMultPointedMagmaTerm n)
    1OL'  = 1OL 
    *OL' : {n : Nat} -> ((OpMultPointedMagmaTerm n) -> ((OpMultPointedMagmaTerm n) -> (OpMultPointedMagmaTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpMultPointedMagmaTerm n) -> (Staged (OpMultPointedMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 1OL = (Now 1OL) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    1OL2' : {n : Nat} {A : Set} -> (OpMultPointedMagmaTerm2 n A)
    1OL2'  = 1OL2 
    *OL2' : {n : Nat} {A : Set} -> ((OpMultPointedMagmaTerm2 n A) -> ((OpMultPointedMagmaTerm2 n A) -> (OpMultPointedMagmaTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpMultPointedMagmaTerm2 n A) -> (Staged (OpMultPointedMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 1OL2 = (Now 1OL2) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        1T : (Repr A)
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module MultPointedSemigroup  where
    record MultPointedSemigroup (A : Set) : Set where
      constructor MultPointedSemigroupC
      field
        1 : A
        * : (A -> (A -> A))
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        1S : AS
        *S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        1P : (Prod A A)
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
    record Hom {A1 : Set} {A2 : Set} (Mu1 : (MultPointedSemigroup A1)) (Mu2 : (MultPointedSemigroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-1 : (hom (1 Mu1)) == (1 Mu2)
        pres-* : {x1 x2 : A1} -> (hom ((* Mu1) x1 x2)) == ((* Mu2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Mu1 : (MultPointedSemigroup A1)) (Mu2 : (MultPointedSemigroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-1 : (interp (1 Mu1) (1 Mu2))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Mu1) x1 x2) ((* Mu2) y1 y2))))
    data MultPointedSemigroupTerm  : Set where
      1L : MultPointedSemigroupTerm
      *L : (MultPointedSemigroupTerm -> (MultPointedSemigroupTerm -> MultPointedSemigroupTerm))
    data ClMultPointedSemigroupTerm (A : Set) : Set where
      sing : (A -> (ClMultPointedSemigroupTerm A))
      1Cl : (ClMultPointedSemigroupTerm A)
      *Cl : ((ClMultPointedSemigroupTerm A) -> ((ClMultPointedSemigroupTerm A) -> (ClMultPointedSemigroupTerm A)))
    data OpMultPointedSemigroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpMultPointedSemigroupTerm n))
      1OL : (OpMultPointedSemigroupTerm n)
      *OL : ((OpMultPointedSemigroupTerm n) -> ((OpMultPointedSemigroupTerm n) -> (OpMultPointedSemigroupTerm n)))
    data OpMultPointedSemigroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpMultPointedSemigroupTerm2 n A))
      sing2 : (A -> (OpMultPointedSemigroupTerm2 n A))
      1OL2 : (OpMultPointedSemigroupTerm2 n A)
      *OL2 : ((OpMultPointedSemigroupTerm2 n A) -> ((OpMultPointedSemigroupTerm2 n A) -> (OpMultPointedSemigroupTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClMultPointedSemigroupTerm A) -> (ClMultPointedSemigroupTerm A))
    simplifyCl 1Cl = 1Cl 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpMultPointedSemigroupTerm n) -> (OpMultPointedSemigroupTerm n))
    simplifyOpB 1OL = 1OL 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpMultPointedSemigroupTerm2 n A) -> (OpMultPointedSemigroupTerm2 n A))
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((MultPointedSemigroup A) -> (MultPointedSemigroupTerm -> A))
    evalB Mu 1L = (1 Mu) 
    evalB Mu (*L x1 x2) = ((* Mu) (evalB Mu x1) (evalB Mu x2)) 
    evalCl : {A : Set} -> ((MultPointedSemigroup A) -> ((ClMultPointedSemigroupTerm A) -> A))
    evalCl Mu (sing x1) = x1 
    evalCl Mu 1Cl = (1 Mu) 
    evalCl Mu (*Cl x1 x2) = ((* Mu) (evalCl Mu x1) (evalCl Mu x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((MultPointedSemigroup A) -> ((Vec A n) -> ((OpMultPointedSemigroupTerm n) -> A)))
    evalOpB Mu vars (v x1) = (lookup _ x1 vars) 
    evalOpB Mu vars 1OL = (1 Mu) 
    evalOpB Mu vars (*OL x1 x2) = ((* Mu) (evalOpB Mu vars x1) (evalOpB Mu vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((MultPointedSemigroup A) -> ((Vec A n) -> ((OpMultPointedSemigroupTerm2 n A) -> A)))
    evalOp Mu vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Mu vars (sing2 x1) = x1 
    evalOp Mu vars 1OL2 = (1 Mu) 
    evalOp Mu vars (*OL2 x1 x2) = ((* Mu) (evalOp Mu vars x1) (evalOp Mu vars x2)) 
    inductionB : {P : (MultPointedSemigroupTerm -> Set)} -> ((P 1L) -> (((x1 x2 : MultPointedSemigroupTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((x : MultPointedSemigroupTerm) -> (P x))))
    inductionB {p} p1l p*l 1L = p1l 
    inductionB {p} p1l p*l (*L x1 x2) = (p*l _ _ (inductionB {p} p1l p*l x1) (inductionB {p} p1l p*l x2)) 
    inductionCl : {A : Set} {P : ((ClMultPointedSemigroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 1Cl) -> (((x1 x2 : (ClMultPointedSemigroupTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((x : (ClMultPointedSemigroupTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p1cl p*cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p1cl p*cl 1Cl = p1cl 
    inductionCl {_} {p} psing p1cl p*cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p1cl p*cl x1) (inductionCl {_} {p} psing p1cl p*cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpMultPointedSemigroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 1OL) -> (((x1 x2 : (OpMultPointedSemigroupTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((x : (OpMultPointedSemigroupTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p1ol p*ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p1ol p*ol 1OL = p1ol 
    inductionOpB {_} {p} pv p1ol p*ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p1ol p*ol x1) (inductionOpB {_} {p} pv p1ol p*ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpMultPointedSemigroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 1OL2) -> (((x1 x2 : (OpMultPointedSemigroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((x : (OpMultPointedSemigroupTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 1OL2 = p1ol2 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 x2)) 
    1L' : MultPointedSemigroupTerm
    1L'  = 1L 
    *L' : (MultPointedSemigroupTerm -> (MultPointedSemigroupTerm -> MultPointedSemigroupTerm))
    *L' x1 x2 = (*L x1 x2) 
    stageB : (MultPointedSemigroupTerm -> (Staged MultPointedSemigroupTerm))
    stageB 1L = (Now 1L) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    1Cl' : {A : Set} -> (ClMultPointedSemigroupTerm A)
    1Cl'  = 1Cl 
    *Cl' : {A : Set} -> ((ClMultPointedSemigroupTerm A) -> ((ClMultPointedSemigroupTerm A) -> (ClMultPointedSemigroupTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    stageCl : {A : Set} -> ((ClMultPointedSemigroupTerm A) -> (Staged (ClMultPointedSemigroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 1Cl = (Now 1Cl) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    1OL' : {n : Nat} -> (OpMultPointedSemigroupTerm n)
    1OL'  = 1OL 
    *OL' : {n : Nat} -> ((OpMultPointedSemigroupTerm n) -> ((OpMultPointedSemigroupTerm n) -> (OpMultPointedSemigroupTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpMultPointedSemigroupTerm n) -> (Staged (OpMultPointedSemigroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 1OL = (Now 1OL) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    1OL2' : {n : Nat} {A : Set} -> (OpMultPointedSemigroupTerm2 n A)
    1OL2'  = 1OL2 
    *OL2' : {n : Nat} {A : Set} -> ((OpMultPointedSemigroupTerm2 n A) -> ((OpMultPointedSemigroupTerm2 n A) -> (OpMultPointedSemigroupTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpMultPointedSemigroupTerm2 n A) -> (Staged (OpMultPointedSemigroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 1OL2 = (Now 1OL2) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        1T : (Repr A)
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module MultSemigroup  where
    record MultSemigroup (A : Set) : Set where
      constructor MultSemigroupC
      field
        * : (A -> (A -> A))
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
    record Hom {A1 : Set} {A2 : Set} (Mu1 : (MultSemigroup A1)) (Mu2 : (MultSemigroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Mu1) x1 x2)) == ((* Mu2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Mu1 : (MultSemigroup A1)) (Mu2 : (MultSemigroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Mu1) x1 x2) ((* Mu2) y1 y2))))
    data MultSemigroupTerm  : Set where
      *L : (MultSemigroupTerm -> (MultSemigroupTerm -> MultSemigroupTerm))
    data ClMultSemigroupTerm (A : Set) : Set where
      sing : (A -> (ClMultSemigroupTerm A))
      *Cl : ((ClMultSemigroupTerm A) -> ((ClMultSemigroupTerm A) -> (ClMultSemigroupTerm A)))
    data OpMultSemigroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpMultSemigroupTerm n))
      *OL : ((OpMultSemigroupTerm n) -> ((OpMultSemigroupTerm n) -> (OpMultSemigroupTerm n)))
    data OpMultSemigroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpMultSemigroupTerm2 n A))
      sing2 : (A -> (OpMultSemigroupTerm2 n A))
      *OL2 : ((OpMultSemigroupTerm2 n A) -> ((OpMultSemigroupTerm2 n A) -> (OpMultSemigroupTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClMultSemigroupTerm A) -> (ClMultSemigroupTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpMultSemigroupTerm n) -> (OpMultSemigroupTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpMultSemigroupTerm2 n A) -> (OpMultSemigroupTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((MultSemigroup A) -> (MultSemigroupTerm -> A))
    evalB Mu (*L x1 x2) = ((* Mu) (evalB Mu x1) (evalB Mu x2)) 
    evalCl : {A : Set} -> ((MultSemigroup A) -> ((ClMultSemigroupTerm A) -> A))
    evalCl Mu (sing x1) = x1 
    evalCl Mu (*Cl x1 x2) = ((* Mu) (evalCl Mu x1) (evalCl Mu x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((MultSemigroup A) -> ((Vec A n) -> ((OpMultSemigroupTerm n) -> A)))
    evalOpB Mu vars (v x1) = (lookup _ x1 vars) 
    evalOpB Mu vars (*OL x1 x2) = ((* Mu) (evalOpB Mu vars x1) (evalOpB Mu vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((MultSemigroup A) -> ((Vec A n) -> ((OpMultSemigroupTerm2 n A) -> A)))
    evalOp Mu vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Mu vars (sing2 x1) = x1 
    evalOp Mu vars (*OL2 x1 x2) = ((* Mu) (evalOp Mu vars x1) (evalOp Mu vars x2)) 
    inductionB : {P : (MultSemigroupTerm -> Set)} -> (((x1 x2 : MultSemigroupTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((x : MultSemigroupTerm) -> (P x)))
    inductionB {p} p*l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l x1) (inductionB {p} p*l x2)) 
    inductionCl : {A : Set} {P : ((ClMultSemigroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClMultSemigroupTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((x : (ClMultSemigroupTerm A)) -> (P x))))
    inductionCl {_} {p} psing p*cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl x1) (inductionCl {_} {p} psing p*cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpMultSemigroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpMultSemigroupTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((x : (OpMultSemigroupTerm n)) -> (P x))))
    inductionOpB {_} {p} pv p*ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol x1) (inductionOpB {_} {p} pv p*ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpMultSemigroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpMultSemigroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((x : (OpMultSemigroupTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 x2)) 
    *L' : (MultSemigroupTerm -> (MultSemigroupTerm -> MultSemigroupTerm))
    *L' x1 x2 = (*L x1 x2) 
    stageB : (MultSemigroupTerm -> (Staged MultSemigroupTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClMultSemigroupTerm A) -> ((ClMultSemigroupTerm A) -> (ClMultSemigroupTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    stageCl : {A : Set} -> ((ClMultSemigroupTerm A) -> (Staged (ClMultSemigroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpMultSemigroupTerm n) -> ((OpMultSemigroupTerm n) -> (OpMultSemigroupTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpMultSemigroupTerm n) -> (Staged (OpMultSemigroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpMultSemigroupTerm2 n A) -> ((OpMultSemigroupTerm2 n A) -> (OpMultSemigroupTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpMultSemigroupTerm2 n A) -> (Staged (OpMultSemigroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module MultSemilattice_RingoidSig  where
    record MultSemilattice_RingoidSig (A : Set) : Set where
      constructor MultSemilattice_RingoidSigC
      field
        * : (A -> (A -> A))
        commutative_* : {x y : A} -> (* x y) == (* y x)
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        idempotent_* : {x : A} -> (* x x) == x
        + : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        commutative_*P : {xP yP : (Prod A A)} -> (*P xP yP) == (*P yP xP)
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        idempotent_*P : {xP : (Prod A A)} -> (*P xP xP) == xP
    record Hom {A1 : Set} {A2 : Set} (Mu1 : (MultSemilattice_RingoidSig A1)) (Mu2 : (MultSemilattice_RingoidSig A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Mu1) x1 x2)) == ((* Mu2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Mu1) x1 x2)) == ((+ Mu2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Mu1 : (MultSemilattice_RingoidSig A1)) (Mu2 : (MultSemilattice_RingoidSig A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Mu1) x1 x2) ((* Mu2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Mu1) x1 x2) ((+ Mu2) y1 y2))))
    data MultSemilattice_RingoidSigTerm  : Set where
      *L : (MultSemilattice_RingoidSigTerm -> (MultSemilattice_RingoidSigTerm -> MultSemilattice_RingoidSigTerm))
      +L : (MultSemilattice_RingoidSigTerm -> (MultSemilattice_RingoidSigTerm -> MultSemilattice_RingoidSigTerm))
    data ClMultSemilattice_RingoidSigTerm (A : Set) : Set where
      sing : (A -> (ClMultSemilattice_RingoidSigTerm A))
      *Cl : ((ClMultSemilattice_RingoidSigTerm A) -> ((ClMultSemilattice_RingoidSigTerm A) -> (ClMultSemilattice_RingoidSigTerm A)))
      +Cl : ((ClMultSemilattice_RingoidSigTerm A) -> ((ClMultSemilattice_RingoidSigTerm A) -> (ClMultSemilattice_RingoidSigTerm A)))
    data OpMultSemilattice_RingoidSigTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpMultSemilattice_RingoidSigTerm n))
      *OL : ((OpMultSemilattice_RingoidSigTerm n) -> ((OpMultSemilattice_RingoidSigTerm n) -> (OpMultSemilattice_RingoidSigTerm n)))
      +OL : ((OpMultSemilattice_RingoidSigTerm n) -> ((OpMultSemilattice_RingoidSigTerm n) -> (OpMultSemilattice_RingoidSigTerm n)))
    data OpMultSemilattice_RingoidSigTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpMultSemilattice_RingoidSigTerm2 n A))
      sing2 : (A -> (OpMultSemilattice_RingoidSigTerm2 n A))
      *OL2 : ((OpMultSemilattice_RingoidSigTerm2 n A) -> ((OpMultSemilattice_RingoidSigTerm2 n A) -> (OpMultSemilattice_RingoidSigTerm2 n A)))
      +OL2 : ((OpMultSemilattice_RingoidSigTerm2 n A) -> ((OpMultSemilattice_RingoidSigTerm2 n A) -> (OpMultSemilattice_RingoidSigTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClMultSemilattice_RingoidSigTerm A) -> (ClMultSemilattice_RingoidSigTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpMultSemilattice_RingoidSigTerm n) -> (OpMultSemilattice_RingoidSigTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpMultSemilattice_RingoidSigTerm2 n A) -> (OpMultSemilattice_RingoidSigTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((MultSemilattice_RingoidSig A) -> (MultSemilattice_RingoidSigTerm -> A))
    evalB Mu (*L x1 x2) = ((* Mu) (evalB Mu x1) (evalB Mu x2)) 
    evalB Mu (+L x1 x2) = ((+ Mu) (evalB Mu x1) (evalB Mu x2)) 
    evalCl : {A : Set} -> ((MultSemilattice_RingoidSig A) -> ((ClMultSemilattice_RingoidSigTerm A) -> A))
    evalCl Mu (sing x1) = x1 
    evalCl Mu (*Cl x1 x2) = ((* Mu) (evalCl Mu x1) (evalCl Mu x2)) 
    evalCl Mu (+Cl x1 x2) = ((+ Mu) (evalCl Mu x1) (evalCl Mu x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((MultSemilattice_RingoidSig A) -> ((Vec A n) -> ((OpMultSemilattice_RingoidSigTerm n) -> A)))
    evalOpB Mu vars (v x1) = (lookup _ x1 vars) 
    evalOpB Mu vars (*OL x1 x2) = ((* Mu) (evalOpB Mu vars x1) (evalOpB Mu vars x2)) 
    evalOpB Mu vars (+OL x1 x2) = ((+ Mu) (evalOpB Mu vars x1) (evalOpB Mu vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((MultSemilattice_RingoidSig A) -> ((Vec A n) -> ((OpMultSemilattice_RingoidSigTerm2 n A) -> A)))
    evalOp Mu vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Mu vars (sing2 x1) = x1 
    evalOp Mu vars (*OL2 x1 x2) = ((* Mu) (evalOp Mu vars x1) (evalOp Mu vars x2)) 
    evalOp Mu vars (+OL2 x1 x2) = ((+ Mu) (evalOp Mu vars x1) (evalOp Mu vars x2)) 
    inductionB : {P : (MultSemilattice_RingoidSigTerm -> Set)} -> (((x1 x2 : MultSemilattice_RingoidSigTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : MultSemilattice_RingoidSigTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : MultSemilattice_RingoidSigTerm) -> (P x))))
    inductionB {p} p*l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionB {p} p*l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClMultSemilattice_RingoidSigTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClMultSemilattice_RingoidSigTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClMultSemilattice_RingoidSigTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClMultSemilattice_RingoidSigTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p*cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpMultSemilattice_RingoidSigTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpMultSemilattice_RingoidSigTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpMultSemilattice_RingoidSigTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpMultSemilattice_RingoidSigTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p*ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpMultSemilattice_RingoidSigTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpMultSemilattice_RingoidSigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpMultSemilattice_RingoidSigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpMultSemilattice_RingoidSigTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    *L' : (MultSemilattice_RingoidSigTerm -> (MultSemilattice_RingoidSigTerm -> MultSemilattice_RingoidSigTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (MultSemilattice_RingoidSigTerm -> (MultSemilattice_RingoidSigTerm -> MultSemilattice_RingoidSigTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (MultSemilattice_RingoidSigTerm -> (Staged MultSemilattice_RingoidSigTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClMultSemilattice_RingoidSigTerm A) -> ((ClMultSemilattice_RingoidSigTerm A) -> (ClMultSemilattice_RingoidSigTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClMultSemilattice_RingoidSigTerm A) -> ((ClMultSemilattice_RingoidSigTerm A) -> (ClMultSemilattice_RingoidSigTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClMultSemilattice_RingoidSigTerm A) -> (Staged (ClMultSemilattice_RingoidSigTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpMultSemilattice_RingoidSigTerm n) -> ((OpMultSemilattice_RingoidSigTerm n) -> (OpMultSemilattice_RingoidSigTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpMultSemilattice_RingoidSigTerm n) -> ((OpMultSemilattice_RingoidSigTerm n) -> (OpMultSemilattice_RingoidSigTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpMultSemilattice_RingoidSigTerm n) -> (Staged (OpMultSemilattice_RingoidSigTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpMultSemilattice_RingoidSigTerm2 n A) -> ((OpMultSemilattice_RingoidSigTerm2 n A) -> (OpMultSemilattice_RingoidSigTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpMultSemilattice_RingoidSigTerm2 n A) -> ((OpMultSemilattice_RingoidSigTerm2 n A) -> (OpMultSemilattice_RingoidSigTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpMultSemilattice_RingoidSigTerm2 n A) -> (Staged (OpMultSemilattice_RingoidSigTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module MultUnaryAntiDistribution  where
    record MultUnaryAntiDistribution (A : Set) : Set where
      constructor MultUnaryAntiDistributionC
      field
        prim : (A -> A)
        * : (A -> (A -> A))
        antidis_prim_* : {x y : A} -> (prim (* x y)) == (* (prim y) (prim x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        primS : (AS -> AS)
        *S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        primP : ((Prod A A) -> (Prod A A))
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        antidis_prim_*P : {xP yP : (Prod A A)} -> (primP (*P xP yP)) == (*P (primP yP) (primP xP))
    record Hom {A1 : Set} {A2 : Set} (Mu1 : (MultUnaryAntiDistribution A1)) (Mu2 : (MultUnaryAntiDistribution A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-prim : {x1 : A1} -> (hom ((prim Mu1) x1)) == ((prim Mu2) (hom x1))
        pres-* : {x1 x2 : A1} -> (hom ((* Mu1) x1 x2)) == ((* Mu2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Mu1 : (MultUnaryAntiDistribution A1)) (Mu2 : (MultUnaryAntiDistribution A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim Mu1) x1) ((prim Mu2) y1)))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Mu1) x1 x2) ((* Mu2) y1 y2))))
    data MultUnaryAntiDistributionTerm  : Set where
      primL : (MultUnaryAntiDistributionTerm -> MultUnaryAntiDistributionTerm)
      *L : (MultUnaryAntiDistributionTerm -> (MultUnaryAntiDistributionTerm -> MultUnaryAntiDistributionTerm))
    data ClMultUnaryAntiDistributionTerm (A : Set) : Set where
      sing : (A -> (ClMultUnaryAntiDistributionTerm A))
      primCl : ((ClMultUnaryAntiDistributionTerm A) -> (ClMultUnaryAntiDistributionTerm A))
      *Cl : ((ClMultUnaryAntiDistributionTerm A) -> ((ClMultUnaryAntiDistributionTerm A) -> (ClMultUnaryAntiDistributionTerm A)))
    data OpMultUnaryAntiDistributionTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpMultUnaryAntiDistributionTerm n))
      primOL : ((OpMultUnaryAntiDistributionTerm n) -> (OpMultUnaryAntiDistributionTerm n))
      *OL : ((OpMultUnaryAntiDistributionTerm n) -> ((OpMultUnaryAntiDistributionTerm n) -> (OpMultUnaryAntiDistributionTerm n)))
    data OpMultUnaryAntiDistributionTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpMultUnaryAntiDistributionTerm2 n A))
      sing2 : (A -> (OpMultUnaryAntiDistributionTerm2 n A))
      primOL2 : ((OpMultUnaryAntiDistributionTerm2 n A) -> (OpMultUnaryAntiDistributionTerm2 n A))
      *OL2 : ((OpMultUnaryAntiDistributionTerm2 n A) -> ((OpMultUnaryAntiDistributionTerm2 n A) -> (OpMultUnaryAntiDistributionTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClMultUnaryAntiDistributionTerm A) -> (ClMultUnaryAntiDistributionTerm A))
    simplifyCl (*Cl (primCl y) (primCl x)) = (primCl (*Cl x y)) 
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpMultUnaryAntiDistributionTerm n) -> (OpMultUnaryAntiDistributionTerm n))
    simplifyOpB (*OL (primOL y) (primOL x)) = (primOL (*OL x y)) 
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpMultUnaryAntiDistributionTerm2 n A) -> (OpMultUnaryAntiDistributionTerm2 n A))
    simplifyOp (*OL2 (primOL2 y) (primOL2 x)) = (primOL2 (*OL2 x y)) 
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((MultUnaryAntiDistribution A) -> (MultUnaryAntiDistributionTerm -> A))
    evalB Mu (primL x1) = ((prim Mu) (evalB Mu x1)) 
    evalB Mu (*L x1 x2) = ((* Mu) (evalB Mu x1) (evalB Mu x2)) 
    evalCl : {A : Set} -> ((MultUnaryAntiDistribution A) -> ((ClMultUnaryAntiDistributionTerm A) -> A))
    evalCl Mu (sing x1) = x1 
    evalCl Mu (primCl x1) = ((prim Mu) (evalCl Mu x1)) 
    evalCl Mu (*Cl x1 x2) = ((* Mu) (evalCl Mu x1) (evalCl Mu x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((MultUnaryAntiDistribution A) -> ((Vec A n) -> ((OpMultUnaryAntiDistributionTerm n) -> A)))
    evalOpB Mu vars (v x1) = (lookup _ x1 vars) 
    evalOpB Mu vars (primOL x1) = ((prim Mu) (evalOpB Mu vars x1)) 
    evalOpB Mu vars (*OL x1 x2) = ((* Mu) (evalOpB Mu vars x1) (evalOpB Mu vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((MultUnaryAntiDistribution A) -> ((Vec A n) -> ((OpMultUnaryAntiDistributionTerm2 n A) -> A)))
    evalOp Mu vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Mu vars (sing2 x1) = x1 
    evalOp Mu vars (primOL2 x1) = ((prim Mu) (evalOp Mu vars x1)) 
    evalOp Mu vars (*OL2 x1 x2) = ((* Mu) (evalOp Mu vars x1) (evalOp Mu vars x2)) 
    inductionB : {P : (MultUnaryAntiDistributionTerm -> Set)} -> (((x1 : MultUnaryAntiDistributionTerm) -> ((P x1) -> (P (primL x1)))) -> (((x1 x2 : MultUnaryAntiDistributionTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((x : MultUnaryAntiDistributionTerm) -> (P x))))
    inductionB {p} ppriml p*l (primL x1) = (ppriml _ (inductionB {p} ppriml p*l x1)) 
    inductionB {p} ppriml p*l (*L x1 x2) = (p*l _ _ (inductionB {p} ppriml p*l x1) (inductionB {p} ppriml p*l x2)) 
    inductionCl : {A : Set} {P : ((ClMultUnaryAntiDistributionTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 : (ClMultUnaryAntiDistributionTerm A)) -> ((P x1) -> (P (primCl x1)))) -> (((x1 x2 : (ClMultUnaryAntiDistributionTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((x : (ClMultUnaryAntiDistributionTerm A)) -> (P x)))))
    inductionCl {_} {p} psing pprimcl p*cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pprimcl p*cl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing pprimcl p*cl x1)) 
    inductionCl {_} {p} psing pprimcl p*cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing pprimcl p*cl x1) (inductionCl {_} {p} psing pprimcl p*cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpMultUnaryAntiDistributionTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 : (OpMultUnaryAntiDistributionTerm n)) -> ((P x1) -> (P (primOL x1)))) -> (((x1 x2 : (OpMultUnaryAntiDistributionTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((x : (OpMultUnaryAntiDistributionTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv pprimol p*ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pprimol p*ol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv pprimol p*ol x1)) 
    inductionOpB {_} {p} pv pprimol p*ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv pprimol p*ol x1) (inductionOpB {_} {p} pv pprimol p*ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpMultUnaryAntiDistributionTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 : (OpMultUnaryAntiDistributionTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> (((x1 x2 : (OpMultUnaryAntiDistributionTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((x : (OpMultUnaryAntiDistributionTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 p*ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 p*ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 p*ol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 pprimol2 p*ol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 p*ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 pprimol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 pprimol2 p*ol2 x2)) 
    primL' : (MultUnaryAntiDistributionTerm -> MultUnaryAntiDistributionTerm)
    primL' x1 = (primL x1) 
    *L' : (MultUnaryAntiDistributionTerm -> (MultUnaryAntiDistributionTerm -> MultUnaryAntiDistributionTerm))
    *L' x1 x2 = (*L x1 x2) 
    stageB : (MultUnaryAntiDistributionTerm -> (Staged MultUnaryAntiDistributionTerm))
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    primCl' : {A : Set} -> ((ClMultUnaryAntiDistributionTerm A) -> (ClMultUnaryAntiDistributionTerm A))
    primCl' x1 = (primCl x1) 
    *Cl' : {A : Set} -> ((ClMultUnaryAntiDistributionTerm A) -> ((ClMultUnaryAntiDistributionTerm A) -> (ClMultUnaryAntiDistributionTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    stageCl : {A : Set} -> ((ClMultUnaryAntiDistributionTerm A) -> (Staged (ClMultUnaryAntiDistributionTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    primOL' : {n : Nat} -> ((OpMultUnaryAntiDistributionTerm n) -> (OpMultUnaryAntiDistributionTerm n))
    primOL' x1 = (primOL x1) 
    *OL' : {n : Nat} -> ((OpMultUnaryAntiDistributionTerm n) -> ((OpMultUnaryAntiDistributionTerm n) -> (OpMultUnaryAntiDistributionTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpMultUnaryAntiDistributionTerm n) -> (Staged (OpMultUnaryAntiDistributionTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    primOL2' : {n : Nat} {A : Set} -> ((OpMultUnaryAntiDistributionTerm2 n A) -> (OpMultUnaryAntiDistributionTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    *OL2' : {n : Nat} {A : Set} -> ((OpMultUnaryAntiDistributionTerm2 n A) -> ((OpMultUnaryAntiDistributionTerm2 n A) -> (OpMultUnaryAntiDistributionTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpMultUnaryAntiDistributionTerm2 n A) -> (Staged (OpMultUnaryAntiDistributionTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        primT : ((Repr A) -> (Repr A))
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module MultUnital  where
    record MultUnital (A : Set) : Set where
      constructor MultUnitalC
      field
        1 : A
        * : (A -> (A -> A))
        lunit_1 : {x : A} -> (* 1 x) == x
        runit_1 : {x : A} -> (* x 1) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        1S : AS
        *S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        1P : (Prod A A)
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        lunit_1P : {xP : (Prod A A)} -> (*P 1P xP) == xP
        runit_1P : {xP : (Prod A A)} -> (*P xP 1P) == xP
    record Hom {A1 : Set} {A2 : Set} (Mu1 : (MultUnital A1)) (Mu2 : (MultUnital A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-1 : (hom (1 Mu1)) == (1 Mu2)
        pres-* : {x1 x2 : A1} -> (hom ((* Mu1) x1 x2)) == ((* Mu2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Mu1 : (MultUnital A1)) (Mu2 : (MultUnital A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-1 : (interp (1 Mu1) (1 Mu2))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Mu1) x1 x2) ((* Mu2) y1 y2))))
    data MultUnitalTerm  : Set where
      1L : MultUnitalTerm
      *L : (MultUnitalTerm -> (MultUnitalTerm -> MultUnitalTerm))
    data ClMultUnitalTerm (A : Set) : Set where
      sing : (A -> (ClMultUnitalTerm A))
      1Cl : (ClMultUnitalTerm A)
      *Cl : ((ClMultUnitalTerm A) -> ((ClMultUnitalTerm A) -> (ClMultUnitalTerm A)))
    data OpMultUnitalTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpMultUnitalTerm n))
      1OL : (OpMultUnitalTerm n)
      *OL : ((OpMultUnitalTerm n) -> ((OpMultUnitalTerm n) -> (OpMultUnitalTerm n)))
    data OpMultUnitalTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpMultUnitalTerm2 n A))
      sing2 : (A -> (OpMultUnitalTerm2 n A))
      1OL2 : (OpMultUnitalTerm2 n A)
      *OL2 : ((OpMultUnitalTerm2 n A) -> ((OpMultUnitalTerm2 n A) -> (OpMultUnitalTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClMultUnitalTerm A) -> (ClMultUnitalTerm A))
    simplifyCl (*Cl 1Cl x) = x 
    simplifyCl (*Cl x 1Cl) = x 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpMultUnitalTerm n) -> (OpMultUnitalTerm n))
    simplifyOpB (*OL 1OL x) = x 
    simplifyOpB (*OL x 1OL) = x 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpMultUnitalTerm2 n A) -> (OpMultUnitalTerm2 n A))
    simplifyOp (*OL2 1OL2 x) = x 
    simplifyOp (*OL2 x 1OL2) = x 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((MultUnital A) -> (MultUnitalTerm -> A))
    evalB Mu 1L = (1 Mu) 
    evalB Mu (*L x1 x2) = ((* Mu) (evalB Mu x1) (evalB Mu x2)) 
    evalCl : {A : Set} -> ((MultUnital A) -> ((ClMultUnitalTerm A) -> A))
    evalCl Mu (sing x1) = x1 
    evalCl Mu 1Cl = (1 Mu) 
    evalCl Mu (*Cl x1 x2) = ((* Mu) (evalCl Mu x1) (evalCl Mu x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((MultUnital A) -> ((Vec A n) -> ((OpMultUnitalTerm n) -> A)))
    evalOpB Mu vars (v x1) = (lookup _ x1 vars) 
    evalOpB Mu vars 1OL = (1 Mu) 
    evalOpB Mu vars (*OL x1 x2) = ((* Mu) (evalOpB Mu vars x1) (evalOpB Mu vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((MultUnital A) -> ((Vec A n) -> ((OpMultUnitalTerm2 n A) -> A)))
    evalOp Mu vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Mu vars (sing2 x1) = x1 
    evalOp Mu vars 1OL2 = (1 Mu) 
    evalOp Mu vars (*OL2 x1 x2) = ((* Mu) (evalOp Mu vars x1) (evalOp Mu vars x2)) 
    inductionB : {P : (MultUnitalTerm -> Set)} -> ((P 1L) -> (((x1 x2 : MultUnitalTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((x : MultUnitalTerm) -> (P x))))
    inductionB {p} p1l p*l 1L = p1l 
    inductionB {p} p1l p*l (*L x1 x2) = (p*l _ _ (inductionB {p} p1l p*l x1) (inductionB {p} p1l p*l x2)) 
    inductionCl : {A : Set} {P : ((ClMultUnitalTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 1Cl) -> (((x1 x2 : (ClMultUnitalTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((x : (ClMultUnitalTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p1cl p*cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p1cl p*cl 1Cl = p1cl 
    inductionCl {_} {p} psing p1cl p*cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p1cl p*cl x1) (inductionCl {_} {p} psing p1cl p*cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpMultUnitalTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 1OL) -> (((x1 x2 : (OpMultUnitalTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((x : (OpMultUnitalTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p1ol p*ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p1ol p*ol 1OL = p1ol 
    inductionOpB {_} {p} pv p1ol p*ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p1ol p*ol x1) (inductionOpB {_} {p} pv p1ol p*ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpMultUnitalTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 1OL2) -> (((x1 x2 : (OpMultUnitalTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((x : (OpMultUnitalTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 1OL2 = p1ol2 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p1ol2 p*ol2 x2)) 
    1L' : MultUnitalTerm
    1L'  = 1L 
    *L' : (MultUnitalTerm -> (MultUnitalTerm -> MultUnitalTerm))
    *L' x1 x2 = (*L x1 x2) 
    stageB : (MultUnitalTerm -> (Staged MultUnitalTerm))
    stageB 1L = (Now 1L) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    1Cl' : {A : Set} -> (ClMultUnitalTerm A)
    1Cl'  = 1Cl 
    *Cl' : {A : Set} -> ((ClMultUnitalTerm A) -> ((ClMultUnitalTerm A) -> (ClMultUnitalTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    stageCl : {A : Set} -> ((ClMultUnitalTerm A) -> (Staged (ClMultUnitalTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 1Cl = (Now 1Cl) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    1OL' : {n : Nat} -> (OpMultUnitalTerm n)
    1OL'  = 1OL 
    *OL' : {n : Nat} -> ((OpMultUnitalTerm n) -> ((OpMultUnitalTerm n) -> (OpMultUnitalTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpMultUnitalTerm n) -> (Staged (OpMultUnitalTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 1OL = (Now 1OL) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    1OL2' : {n : Nat} {A : Set} -> (OpMultUnitalTerm2 n A)
    1OL2'  = 1OL2 
    *OL2' : {n : Nat} {A : Set} -> ((OpMultUnitalTerm2 n A) -> ((OpMultUnitalTerm2 n A) -> (OpMultUnitalTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpMultUnitalTerm2 n A) -> (Staged (OpMultUnitalTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 1OL2 = (Now 1OL2) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        1T : (Repr A)
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module NearRing  where
    record NearRing (A : Set) : Set where
      constructor NearRingC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        0 : A
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        neg : (A -> A)
        leftInverse_inv_op_0 : {x : A} -> (+ x (neg x)) == 0
        rightInverse_inv_op_0 : {x : A} -> (+ (neg x) x) == 0
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        rightDistributive_*_+ : {x y z : A} -> (* (+ y z) x) == (+ (* y x) (* z x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
        0S : AS
        negS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        0P : (Prod A A)
        negP : ((Prod A A) -> (Prod A A))
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        leftInverse_inv_op_0P : {xP : (Prod A A)} -> (+P xP (negP xP)) == 0P
        rightInverse_inv_op_0P : {xP : (Prod A A)} -> (+P (negP xP) xP) == 0P
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        rightDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P (+P yP zP) xP) == (+P (*P yP xP) (*P zP xP))
    record Hom {A1 : Set} {A2 : Set} (Ne1 : (NearRing A1)) (Ne2 : (NearRing A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Ne1) x1 x2)) == ((* Ne2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ne1) x1 x2)) == ((+ Ne2) (hom x1) (hom x2))
        pres-0 : (hom (0 Ne1)) == (0 Ne2)
        pres-neg : {x1 : A1} -> (hom ((neg Ne1) x1)) == ((neg Ne2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (Ne1 : (NearRing A1)) (Ne2 : (NearRing A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Ne1) x1 x2) ((* Ne2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ne1) x1 x2) ((+ Ne2) y1 y2))))
        interp-0 : (interp (0 Ne1) (0 Ne2))
        interp-neg : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((neg Ne1) x1) ((neg Ne2) y1)))
    data NearRingTerm  : Set where
      *L : (NearRingTerm -> (NearRingTerm -> NearRingTerm))
      +L : (NearRingTerm -> (NearRingTerm -> NearRingTerm))
      0L : NearRingTerm
      negL : (NearRingTerm -> NearRingTerm)
    data ClNearRingTerm (A : Set) : Set where
      sing : (A -> (ClNearRingTerm A))
      *Cl : ((ClNearRingTerm A) -> ((ClNearRingTerm A) -> (ClNearRingTerm A)))
      +Cl : ((ClNearRingTerm A) -> ((ClNearRingTerm A) -> (ClNearRingTerm A)))
      0Cl : (ClNearRingTerm A)
      negCl : ((ClNearRingTerm A) -> (ClNearRingTerm A))
    data OpNearRingTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpNearRingTerm n))
      *OL : ((OpNearRingTerm n) -> ((OpNearRingTerm n) -> (OpNearRingTerm n)))
      +OL : ((OpNearRingTerm n) -> ((OpNearRingTerm n) -> (OpNearRingTerm n)))
      0OL : (OpNearRingTerm n)
      negOL : ((OpNearRingTerm n) -> (OpNearRingTerm n))
    data OpNearRingTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpNearRingTerm2 n A))
      sing2 : (A -> (OpNearRingTerm2 n A))
      *OL2 : ((OpNearRingTerm2 n A) -> ((OpNearRingTerm2 n A) -> (OpNearRingTerm2 n A)))
      +OL2 : ((OpNearRingTerm2 n A) -> ((OpNearRingTerm2 n A) -> (OpNearRingTerm2 n A)))
      0OL2 : (OpNearRingTerm2 n A)
      negOL2 : ((OpNearRingTerm2 n A) -> (OpNearRingTerm2 n A))
    simplifyCl : {A : Set} -> ((ClNearRingTerm A) -> (ClNearRingTerm A))
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 0Cl = 0Cl 
    simplifyCl (negCl x1) = (negCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpNearRingTerm n) -> (OpNearRingTerm n))
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 0OL = 0OL 
    simplifyOpB (negOL x1) = (negOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpNearRingTerm2 n A) -> (OpNearRingTerm2 n A))
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (negOL2 x1) = (negOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((NearRing A) -> (NearRingTerm -> A))
    evalB Ne (*L x1 x2) = ((* Ne) (evalB Ne x1) (evalB Ne x2)) 
    evalB Ne (+L x1 x2) = ((+ Ne) (evalB Ne x1) (evalB Ne x2)) 
    evalB Ne 0L = (0 Ne) 
    evalB Ne (negL x1) = ((neg Ne) (evalB Ne x1)) 
    evalCl : {A : Set} -> ((NearRing A) -> ((ClNearRingTerm A) -> A))
    evalCl Ne (sing x1) = x1 
    evalCl Ne (*Cl x1 x2) = ((* Ne) (evalCl Ne x1) (evalCl Ne x2)) 
    evalCl Ne (+Cl x1 x2) = ((+ Ne) (evalCl Ne x1) (evalCl Ne x2)) 
    evalCl Ne 0Cl = (0 Ne) 
    evalCl Ne (negCl x1) = ((neg Ne) (evalCl Ne x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((NearRing A) -> ((Vec A n) -> ((OpNearRingTerm n) -> A)))
    evalOpB Ne vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ne vars (*OL x1 x2) = ((* Ne) (evalOpB Ne vars x1) (evalOpB Ne vars x2)) 
    evalOpB Ne vars (+OL x1 x2) = ((+ Ne) (evalOpB Ne vars x1) (evalOpB Ne vars x2)) 
    evalOpB Ne vars 0OL = (0 Ne) 
    evalOpB Ne vars (negOL x1) = ((neg Ne) (evalOpB Ne vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((NearRing A) -> ((Vec A n) -> ((OpNearRingTerm2 n A) -> A)))
    evalOp Ne vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ne vars (sing2 x1) = x1 
    evalOp Ne vars (*OL2 x1 x2) = ((* Ne) (evalOp Ne vars x1) (evalOp Ne vars x2)) 
    evalOp Ne vars (+OL2 x1 x2) = ((+ Ne) (evalOp Ne vars x1) (evalOp Ne vars x2)) 
    evalOp Ne vars 0OL2 = (0 Ne) 
    evalOp Ne vars (negOL2 x1) = ((neg Ne) (evalOp Ne vars x1)) 
    inductionB : {P : (NearRingTerm -> Set)} -> (((x1 x2 : NearRingTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : NearRingTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((P 0L) -> (((x1 : NearRingTerm) -> ((P x1) -> (P (negL x1)))) -> ((x : NearRingTerm) -> (P x))))))
    inductionB {p} p*l p+l p0l pnegl (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l p0l pnegl x1) (inductionB {p} p*l p+l p0l pnegl x2)) 
    inductionB {p} p*l p+l p0l pnegl (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l p0l pnegl x1) (inductionB {p} p*l p+l p0l pnegl x2)) 
    inductionB {p} p*l p+l p0l pnegl 0L = p0l 
    inductionB {p} p*l p+l p0l pnegl (negL x1) = (pnegl _ (inductionB {p} p*l p+l p0l pnegl x1)) 
    inductionCl : {A : Set} {P : ((ClNearRingTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClNearRingTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClNearRingTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((P 0Cl) -> (((x1 : (ClNearRingTerm A)) -> ((P x1) -> (P (negCl x1)))) -> ((x : (ClNearRingTerm A)) -> (P x)))))))
    inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl x1) (inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl x2)) 
    inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl x1) (inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl x2)) 
    inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl 0Cl = p0cl 
    inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl (negCl x1) = (pnegcl _ (inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpNearRingTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpNearRingTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpNearRingTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((P 0OL) -> (((x1 : (OpNearRingTerm n)) -> ((P x1) -> (P (negOL x1)))) -> ((x : (OpNearRingTerm n)) -> (P x)))))))
    inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol x1) (inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol x1) (inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol 0OL = p0ol 
    inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol (negOL x1) = (pnegol _ (inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpNearRingTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpNearRingTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpNearRingTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((P 0OL2) -> (((x1 : (OpNearRingTerm2 n A)) -> ((P x1) -> (P (negOL2 x1)))) -> ((x : (OpNearRingTerm2 n A)) -> (P x))))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 (negOL2 x1) = (pnegol2 _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 x1)) 
    *L' : (NearRingTerm -> (NearRingTerm -> NearRingTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (NearRingTerm -> (NearRingTerm -> NearRingTerm))
    +L' x1 x2 = (+L x1 x2) 
    0L' : NearRingTerm
    0L'  = 0L 
    negL' : (NearRingTerm -> NearRingTerm)
    negL' x1 = (negL x1) 
    stageB : (NearRingTerm -> (Staged NearRingTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB 0L = (Now 0L) 
    stageB (negL x1) = (stage1 negL' (codeLift1 negL') (stageB x1)) 
    *Cl' : {A : Set} -> ((ClNearRingTerm A) -> ((ClNearRingTerm A) -> (ClNearRingTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClNearRingTerm A) -> ((ClNearRingTerm A) -> (ClNearRingTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    0Cl' : {A : Set} -> (ClNearRingTerm A)
    0Cl'  = 0Cl 
    negCl' : {A : Set} -> ((ClNearRingTerm A) -> (ClNearRingTerm A))
    negCl' x1 = (negCl x1) 
    stageCl : {A : Set} -> ((ClNearRingTerm A) -> (Staged (ClNearRingTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (negCl x1) = (stage1 negCl' (codeLift1 negCl') (stageCl x1)) 
    *OL' : {n : Nat} -> ((OpNearRingTerm n) -> ((OpNearRingTerm n) -> (OpNearRingTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpNearRingTerm n) -> ((OpNearRingTerm n) -> (OpNearRingTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    0OL' : {n : Nat} -> (OpNearRingTerm n)
    0OL'  = 0OL 
    negOL' : {n : Nat} -> ((OpNearRingTerm n) -> (OpNearRingTerm n))
    negOL' x1 = (negOL x1) 
    stageOpB : {n : Nat} -> ((OpNearRingTerm n) -> (Staged (OpNearRingTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (negOL x1) = (stage1 negOL' (codeLift1 negOL') (stageOpB x1)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpNearRingTerm2 n A) -> ((OpNearRingTerm2 n A) -> (OpNearRingTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpNearRingTerm2 n A) -> ((OpNearRingTerm2 n A) -> (OpNearRingTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    0OL2' : {n : Nat} {A : Set} -> (OpNearRingTerm2 n A)
    0OL2'  = 0OL2 
    negOL2' : {n : Nat} {A : Set} -> ((OpNearRingTerm2 n A) -> (OpNearRingTerm2 n A))
    negOL2' x1 = (negOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpNearRingTerm2 n A) -> (Staged (OpNearRingTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (negOL2 x1) = (stage1 negOL2' (codeLift1 negOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        0T : (Repr A)
        negT : ((Repr A) -> (Repr A))
  module NearSemiring  where
    record NearSemiring (A : Set) : Set where
      constructor NearSemiringC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        rightDistributive_*_+ : {x y z : A} -> (* (+ y z) x) == (+ (* y x) (* z x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        rightDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P (+P yP zP) xP) == (+P (*P yP xP) (*P zP xP))
    record Hom {A1 : Set} {A2 : Set} (Ne1 : (NearSemiring A1)) (Ne2 : (NearSemiring A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Ne1) x1 x2)) == ((* Ne2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ne1) x1 x2)) == ((+ Ne2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ne1 : (NearSemiring A1)) (Ne2 : (NearSemiring A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Ne1) x1 x2) ((* Ne2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ne1) x1 x2) ((+ Ne2) y1 y2))))
    data NearSemiringTerm  : Set where
      *L : (NearSemiringTerm -> (NearSemiringTerm -> NearSemiringTerm))
      +L : (NearSemiringTerm -> (NearSemiringTerm -> NearSemiringTerm))
    data ClNearSemiringTerm (A : Set) : Set where
      sing : (A -> (ClNearSemiringTerm A))
      *Cl : ((ClNearSemiringTerm A) -> ((ClNearSemiringTerm A) -> (ClNearSemiringTerm A)))
      +Cl : ((ClNearSemiringTerm A) -> ((ClNearSemiringTerm A) -> (ClNearSemiringTerm A)))
    data OpNearSemiringTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpNearSemiringTerm n))
      *OL : ((OpNearSemiringTerm n) -> ((OpNearSemiringTerm n) -> (OpNearSemiringTerm n)))
      +OL : ((OpNearSemiringTerm n) -> ((OpNearSemiringTerm n) -> (OpNearSemiringTerm n)))
    data OpNearSemiringTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpNearSemiringTerm2 n A))
      sing2 : (A -> (OpNearSemiringTerm2 n A))
      *OL2 : ((OpNearSemiringTerm2 n A) -> ((OpNearSemiringTerm2 n A) -> (OpNearSemiringTerm2 n A)))
      +OL2 : ((OpNearSemiringTerm2 n A) -> ((OpNearSemiringTerm2 n A) -> (OpNearSemiringTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClNearSemiringTerm A) -> (ClNearSemiringTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpNearSemiringTerm n) -> (OpNearSemiringTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpNearSemiringTerm2 n A) -> (OpNearSemiringTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((NearSemiring A) -> (NearSemiringTerm -> A))
    evalB Ne (*L x1 x2) = ((* Ne) (evalB Ne x1) (evalB Ne x2)) 
    evalB Ne (+L x1 x2) = ((+ Ne) (evalB Ne x1) (evalB Ne x2)) 
    evalCl : {A : Set} -> ((NearSemiring A) -> ((ClNearSemiringTerm A) -> A))
    evalCl Ne (sing x1) = x1 
    evalCl Ne (*Cl x1 x2) = ((* Ne) (evalCl Ne x1) (evalCl Ne x2)) 
    evalCl Ne (+Cl x1 x2) = ((+ Ne) (evalCl Ne x1) (evalCl Ne x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((NearSemiring A) -> ((Vec A n) -> ((OpNearSemiringTerm n) -> A)))
    evalOpB Ne vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ne vars (*OL x1 x2) = ((* Ne) (evalOpB Ne vars x1) (evalOpB Ne vars x2)) 
    evalOpB Ne vars (+OL x1 x2) = ((+ Ne) (evalOpB Ne vars x1) (evalOpB Ne vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((NearSemiring A) -> ((Vec A n) -> ((OpNearSemiringTerm2 n A) -> A)))
    evalOp Ne vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ne vars (sing2 x1) = x1 
    evalOp Ne vars (*OL2 x1 x2) = ((* Ne) (evalOp Ne vars x1) (evalOp Ne vars x2)) 
    evalOp Ne vars (+OL2 x1 x2) = ((+ Ne) (evalOp Ne vars x1) (evalOp Ne vars x2)) 
    inductionB : {P : (NearSemiringTerm -> Set)} -> (((x1 x2 : NearSemiringTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : NearSemiringTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : NearSemiringTerm) -> (P x))))
    inductionB {p} p*l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionB {p} p*l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClNearSemiringTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClNearSemiringTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClNearSemiringTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClNearSemiringTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p*cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpNearSemiringTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpNearSemiringTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpNearSemiringTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpNearSemiringTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p*ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpNearSemiringTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpNearSemiringTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpNearSemiringTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpNearSemiringTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    *L' : (NearSemiringTerm -> (NearSemiringTerm -> NearSemiringTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (NearSemiringTerm -> (NearSemiringTerm -> NearSemiringTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (NearSemiringTerm -> (Staged NearSemiringTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClNearSemiringTerm A) -> ((ClNearSemiringTerm A) -> (ClNearSemiringTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClNearSemiringTerm A) -> ((ClNearSemiringTerm A) -> (ClNearSemiringTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClNearSemiringTerm A) -> (Staged (ClNearSemiringTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpNearSemiringTerm n) -> ((OpNearSemiringTerm n) -> (OpNearSemiringTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpNearSemiringTerm n) -> ((OpNearSemiringTerm n) -> (OpNearSemiringTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpNearSemiringTerm n) -> (Staged (OpNearSemiringTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpNearSemiringTerm2 n A) -> ((OpNearSemiringTerm2 n A) -> (OpNearSemiringTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpNearSemiringTerm2 n A) -> ((OpNearSemiringTerm2 n A) -> (OpNearSemiringTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpNearSemiringTerm2 n A) -> (Staged (OpNearSemiringTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module NonDistributiveAddPreSemiring  where
    record NonDistributiveAddPreSemiring (A : Set) : Set where
      constructor NonDistributiveAddPreSemiringC
      field
        + : (A -> (A -> A))
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        * : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        +S : (AS -> (AS -> AS))
        *S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
    record Hom {A1 : Set} {A2 : Set} (No1 : (NonDistributiveAddPreSemiring A1)) (No2 : (NonDistributiveAddPreSemiring A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ No1) x1 x2)) == ((+ No2) (hom x1) (hom x2))
        pres-* : {x1 x2 : A1} -> (hom ((* No1) x1 x2)) == ((* No2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (No1 : (NonDistributiveAddPreSemiring A1)) (No2 : (NonDistributiveAddPreSemiring A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ No1) x1 x2) ((+ No2) y1 y2))))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* No1) x1 x2) ((* No2) y1 y2))))
    data NonDistributiveAddPreSemiringTerm  : Set where
      +L : (NonDistributiveAddPreSemiringTerm -> (NonDistributiveAddPreSemiringTerm -> NonDistributiveAddPreSemiringTerm))
      *L : (NonDistributiveAddPreSemiringTerm -> (NonDistributiveAddPreSemiringTerm -> NonDistributiveAddPreSemiringTerm))
    data ClNonDistributiveAddPreSemiringTerm (A : Set) : Set where
      sing : (A -> (ClNonDistributiveAddPreSemiringTerm A))
      +Cl : ((ClNonDistributiveAddPreSemiringTerm A) -> ((ClNonDistributiveAddPreSemiringTerm A) -> (ClNonDistributiveAddPreSemiringTerm A)))
      *Cl : ((ClNonDistributiveAddPreSemiringTerm A) -> ((ClNonDistributiveAddPreSemiringTerm A) -> (ClNonDistributiveAddPreSemiringTerm A)))
    data OpNonDistributiveAddPreSemiringTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpNonDistributiveAddPreSemiringTerm n))
      +OL : ((OpNonDistributiveAddPreSemiringTerm n) -> ((OpNonDistributiveAddPreSemiringTerm n) -> (OpNonDistributiveAddPreSemiringTerm n)))
      *OL : ((OpNonDistributiveAddPreSemiringTerm n) -> ((OpNonDistributiveAddPreSemiringTerm n) -> (OpNonDistributiveAddPreSemiringTerm n)))
    data OpNonDistributiveAddPreSemiringTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpNonDistributiveAddPreSemiringTerm2 n A))
      sing2 : (A -> (OpNonDistributiveAddPreSemiringTerm2 n A))
      +OL2 : ((OpNonDistributiveAddPreSemiringTerm2 n A) -> ((OpNonDistributiveAddPreSemiringTerm2 n A) -> (OpNonDistributiveAddPreSemiringTerm2 n A)))
      *OL2 : ((OpNonDistributiveAddPreSemiringTerm2 n A) -> ((OpNonDistributiveAddPreSemiringTerm2 n A) -> (OpNonDistributiveAddPreSemiringTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClNonDistributiveAddPreSemiringTerm A) -> (ClNonDistributiveAddPreSemiringTerm A))
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpNonDistributiveAddPreSemiringTerm n) -> (OpNonDistributiveAddPreSemiringTerm n))
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpNonDistributiveAddPreSemiringTerm2 n A) -> (OpNonDistributiveAddPreSemiringTerm2 n A))
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((NonDistributiveAddPreSemiring A) -> (NonDistributiveAddPreSemiringTerm -> A))
    evalB No (+L x1 x2) = ((+ No) (evalB No x1) (evalB No x2)) 
    evalB No (*L x1 x2) = ((* No) (evalB No x1) (evalB No x2)) 
    evalCl : {A : Set} -> ((NonDistributiveAddPreSemiring A) -> ((ClNonDistributiveAddPreSemiringTerm A) -> A))
    evalCl No (sing x1) = x1 
    evalCl No (+Cl x1 x2) = ((+ No) (evalCl No x1) (evalCl No x2)) 
    evalCl No (*Cl x1 x2) = ((* No) (evalCl No x1) (evalCl No x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((NonDistributiveAddPreSemiring A) -> ((Vec A n) -> ((OpNonDistributiveAddPreSemiringTerm n) -> A)))
    evalOpB No vars (v x1) = (lookup _ x1 vars) 
    evalOpB No vars (+OL x1 x2) = ((+ No) (evalOpB No vars x1) (evalOpB No vars x2)) 
    evalOpB No vars (*OL x1 x2) = ((* No) (evalOpB No vars x1) (evalOpB No vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((NonDistributiveAddPreSemiring A) -> ((Vec A n) -> ((OpNonDistributiveAddPreSemiringTerm2 n A) -> A)))
    evalOp No vars (v2 x1) = (lookup _ x1 vars) 
    evalOp No vars (sing2 x1) = x1 
    evalOp No vars (+OL2 x1 x2) = ((+ No) (evalOp No vars x1) (evalOp No vars x2)) 
    evalOp No vars (*OL2 x1 x2) = ((* No) (evalOp No vars x1) (evalOp No vars x2)) 
    inductionB : {P : (NonDistributiveAddPreSemiringTerm -> Set)} -> (((x1 x2 : NonDistributiveAddPreSemiringTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> (((x1 x2 : NonDistributiveAddPreSemiringTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((x : NonDistributiveAddPreSemiringTerm) -> (P x))))
    inductionB {p} p+l p*l (+L x1 x2) = (p+l _ _ (inductionB {p} p+l p*l x1) (inductionB {p} p+l p*l x2)) 
    inductionB {p} p+l p*l (*L x1 x2) = (p*l _ _ (inductionB {p} p+l p*l x1) (inductionB {p} p+l p*l x2)) 
    inductionCl : {A : Set} {P : ((ClNonDistributiveAddPreSemiringTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClNonDistributiveAddPreSemiringTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> (((x1 x2 : (ClNonDistributiveAddPreSemiringTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((x : (ClNonDistributiveAddPreSemiringTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p+cl p*cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p+cl p*cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p+cl p*cl x1) (inductionCl {_} {p} psing p+cl p*cl x2)) 
    inductionCl {_} {p} psing p+cl p*cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p+cl p*cl x1) (inductionCl {_} {p} psing p+cl p*cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpNonDistributiveAddPreSemiringTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpNonDistributiveAddPreSemiringTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> (((x1 x2 : (OpNonDistributiveAddPreSemiringTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((x : (OpNonDistributiveAddPreSemiringTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p+ol p*ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p+ol p*ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p+ol p*ol x1) (inductionOpB {_} {p} pv p+ol p*ol x2)) 
    inductionOpB {_} {p} pv p+ol p*ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p+ol p*ol x1) (inductionOpB {_} {p} pv p+ol p*ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpNonDistributiveAddPreSemiringTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpNonDistributiveAddPreSemiringTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> (((x1 x2 : (OpNonDistributiveAddPreSemiringTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((x : (OpNonDistributiveAddPreSemiringTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p*ol2 x2)) 
    +L' : (NonDistributiveAddPreSemiringTerm -> (NonDistributiveAddPreSemiringTerm -> NonDistributiveAddPreSemiringTerm))
    +L' x1 x2 = (+L x1 x2) 
    *L' : (NonDistributiveAddPreSemiringTerm -> (NonDistributiveAddPreSemiringTerm -> NonDistributiveAddPreSemiringTerm))
    *L' x1 x2 = (*L x1 x2) 
    stageB : (NonDistributiveAddPreSemiringTerm -> (Staged NonDistributiveAddPreSemiringTerm))
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    +Cl' : {A : Set} -> ((ClNonDistributiveAddPreSemiringTerm A) -> ((ClNonDistributiveAddPreSemiringTerm A) -> (ClNonDistributiveAddPreSemiringTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    *Cl' : {A : Set} -> ((ClNonDistributiveAddPreSemiringTerm A) -> ((ClNonDistributiveAddPreSemiringTerm A) -> (ClNonDistributiveAddPreSemiringTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    stageCl : {A : Set} -> ((ClNonDistributiveAddPreSemiringTerm A) -> (Staged (ClNonDistributiveAddPreSemiringTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    +OL' : {n : Nat} -> ((OpNonDistributiveAddPreSemiringTerm n) -> ((OpNonDistributiveAddPreSemiringTerm n) -> (OpNonDistributiveAddPreSemiringTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    *OL' : {n : Nat} -> ((OpNonDistributiveAddPreSemiringTerm n) -> ((OpNonDistributiveAddPreSemiringTerm n) -> (OpNonDistributiveAddPreSemiringTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpNonDistributiveAddPreSemiringTerm n) -> (Staged (OpNonDistributiveAddPreSemiringTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    +OL2' : {n : Nat} {A : Set} -> ((OpNonDistributiveAddPreSemiringTerm2 n A) -> ((OpNonDistributiveAddPreSemiringTerm2 n A) -> (OpNonDistributiveAddPreSemiringTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    *OL2' : {n : Nat} {A : Set} -> ((OpNonDistributiveAddPreSemiringTerm2 n A) -> ((OpNonDistributiveAddPreSemiringTerm2 n A) -> (OpNonDistributiveAddPreSemiringTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpNonDistributiveAddPreSemiringTerm2 n A) -> (Staged (OpNonDistributiveAddPreSemiringTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module NonassociativeNondistributiveRing  where
    record NonassociativeNondistributiveRing (A : Set) : Set where
      constructor NonassociativeNondistributiveRingC
      field
        * : (A -> (A -> A))
        1 : A
        lunit_1 : {x : A} -> (* 1 x) == x
        runit_1 : {x : A} -> (* x 1) == x
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        inv : (A -> A)
        leftInverse_inv_op_1 : {x : A} -> (* x (inv x)) == 1
        rightInverse_inv_op_1 : {x : A} -> (* (inv x) x) == 1
        commutative_* : {x y : A} -> (* x y) == (* y x)
        + : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        1S : AS
        invS : (AS -> AS)
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        1P : (Prod A A)
        invP : ((Prod A A) -> (Prod A A))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        lunit_1P : {xP : (Prod A A)} -> (*P 1P xP) == xP
        runit_1P : {xP : (Prod A A)} -> (*P xP 1P) == xP
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        leftInverse_inv_op_1P : {xP : (Prod A A)} -> (*P xP (invP xP)) == 1P
        rightInverse_inv_op_1P : {xP : (Prod A A)} -> (*P (invP xP) xP) == 1P
        commutative_*P : {xP yP : (Prod A A)} -> (*P xP yP) == (*P yP xP)
    record Hom {A1 : Set} {A2 : Set} (No1 : (NonassociativeNondistributiveRing A1)) (No2 : (NonassociativeNondistributiveRing A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* No1) x1 x2)) == ((* No2) (hom x1) (hom x2))
        pres-1 : (hom (1 No1)) == (1 No2)
        pres-inv : {x1 : A1} -> (hom ((inv No1) x1)) == ((inv No2) (hom x1))
        pres-+ : {x1 x2 : A1} -> (hom ((+ No1) x1 x2)) == ((+ No2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (No1 : (NonassociativeNondistributiveRing A1)) (No2 : (NonassociativeNondistributiveRing A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* No1) x1 x2) ((* No2) y1 y2))))
        interp-1 : (interp (1 No1) (1 No2))
        interp-inv : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((inv No1) x1) ((inv No2) y1)))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ No1) x1 x2) ((+ No2) y1 y2))))
    data NonassociativeNondistributiveRingTerm  : Set where
      *L : (NonassociativeNondistributiveRingTerm -> (NonassociativeNondistributiveRingTerm -> NonassociativeNondistributiveRingTerm))
      1L : NonassociativeNondistributiveRingTerm
      invL : (NonassociativeNondistributiveRingTerm -> NonassociativeNondistributiveRingTerm)
      +L : (NonassociativeNondistributiveRingTerm -> (NonassociativeNondistributiveRingTerm -> NonassociativeNondistributiveRingTerm))
    data ClNonassociativeNondistributiveRingTerm (A : Set) : Set where
      sing : (A -> (ClNonassociativeNondistributiveRingTerm A))
      *Cl : ((ClNonassociativeNondistributiveRingTerm A) -> ((ClNonassociativeNondistributiveRingTerm A) -> (ClNonassociativeNondistributiveRingTerm A)))
      1Cl : (ClNonassociativeNondistributiveRingTerm A)
      invCl : ((ClNonassociativeNondistributiveRingTerm A) -> (ClNonassociativeNondistributiveRingTerm A))
      +Cl : ((ClNonassociativeNondistributiveRingTerm A) -> ((ClNonassociativeNondistributiveRingTerm A) -> (ClNonassociativeNondistributiveRingTerm A)))
    data OpNonassociativeNondistributiveRingTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpNonassociativeNondistributiveRingTerm n))
      *OL : ((OpNonassociativeNondistributiveRingTerm n) -> ((OpNonassociativeNondistributiveRingTerm n) -> (OpNonassociativeNondistributiveRingTerm n)))
      1OL : (OpNonassociativeNondistributiveRingTerm n)
      invOL : ((OpNonassociativeNondistributiveRingTerm n) -> (OpNonassociativeNondistributiveRingTerm n))
      +OL : ((OpNonassociativeNondistributiveRingTerm n) -> ((OpNonassociativeNondistributiveRingTerm n) -> (OpNonassociativeNondistributiveRingTerm n)))
    data OpNonassociativeNondistributiveRingTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpNonassociativeNondistributiveRingTerm2 n A))
      sing2 : (A -> (OpNonassociativeNondistributiveRingTerm2 n A))
      *OL2 : ((OpNonassociativeNondistributiveRingTerm2 n A) -> ((OpNonassociativeNondistributiveRingTerm2 n A) -> (OpNonassociativeNondistributiveRingTerm2 n A)))
      1OL2 : (OpNonassociativeNondistributiveRingTerm2 n A)
      invOL2 : ((OpNonassociativeNondistributiveRingTerm2 n A) -> (OpNonassociativeNondistributiveRingTerm2 n A))
      +OL2 : ((OpNonassociativeNondistributiveRingTerm2 n A) -> ((OpNonassociativeNondistributiveRingTerm2 n A) -> (OpNonassociativeNondistributiveRingTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClNonassociativeNondistributiveRingTerm A) -> (ClNonassociativeNondistributiveRingTerm A))
    simplifyCl (*Cl 1Cl x) = x 
    simplifyCl (*Cl x 1Cl) = x 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (invCl x1) = (invCl (simplifyCl x1)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpNonassociativeNondistributiveRingTerm n) -> (OpNonassociativeNondistributiveRingTerm n))
    simplifyOpB (*OL 1OL x) = x 
    simplifyOpB (*OL x 1OL) = x 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (invOL x1) = (invOL (simplifyOpB x1)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpNonassociativeNondistributiveRingTerm2 n A) -> (OpNonassociativeNondistributiveRingTerm2 n A))
    simplifyOp (*OL2 1OL2 x) = x 
    simplifyOp (*OL2 x 1OL2) = x 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (invOL2 x1) = (invOL2 (simplifyOp x1)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((NonassociativeNondistributiveRing A) -> (NonassociativeNondistributiveRingTerm -> A))
    evalB No (*L x1 x2) = ((* No) (evalB No x1) (evalB No x2)) 
    evalB No 1L = (1 No) 
    evalB No (invL x1) = ((inv No) (evalB No x1)) 
    evalB No (+L x1 x2) = ((+ No) (evalB No x1) (evalB No x2)) 
    evalCl : {A : Set} -> ((NonassociativeNondistributiveRing A) -> ((ClNonassociativeNondistributiveRingTerm A) -> A))
    evalCl No (sing x1) = x1 
    evalCl No (*Cl x1 x2) = ((* No) (evalCl No x1) (evalCl No x2)) 
    evalCl No 1Cl = (1 No) 
    evalCl No (invCl x1) = ((inv No) (evalCl No x1)) 
    evalCl No (+Cl x1 x2) = ((+ No) (evalCl No x1) (evalCl No x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((NonassociativeNondistributiveRing A) -> ((Vec A n) -> ((OpNonassociativeNondistributiveRingTerm n) -> A)))
    evalOpB No vars (v x1) = (lookup _ x1 vars) 
    evalOpB No vars (*OL x1 x2) = ((* No) (evalOpB No vars x1) (evalOpB No vars x2)) 
    evalOpB No vars 1OL = (1 No) 
    evalOpB No vars (invOL x1) = ((inv No) (evalOpB No vars x1)) 
    evalOpB No vars (+OL x1 x2) = ((+ No) (evalOpB No vars x1) (evalOpB No vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((NonassociativeNondistributiveRing A) -> ((Vec A n) -> ((OpNonassociativeNondistributiveRingTerm2 n A) -> A)))
    evalOp No vars (v2 x1) = (lookup _ x1 vars) 
    evalOp No vars (sing2 x1) = x1 
    evalOp No vars (*OL2 x1 x2) = ((* No) (evalOp No vars x1) (evalOp No vars x2)) 
    evalOp No vars 1OL2 = (1 No) 
    evalOp No vars (invOL2 x1) = ((inv No) (evalOp No vars x1)) 
    evalOp No vars (+OL2 x1 x2) = ((+ No) (evalOp No vars x1) (evalOp No vars x2)) 
    inductionB : {P : (NonassociativeNondistributiveRingTerm -> Set)} -> (((x1 x2 : NonassociativeNondistributiveRingTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((P 1L) -> (((x1 : NonassociativeNondistributiveRingTerm) -> ((P x1) -> (P (invL x1)))) -> (((x1 x2 : NonassociativeNondistributiveRingTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : NonassociativeNondistributiveRingTerm) -> (P x))))))
    inductionB {p} p*l p1l pinvl p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p1l pinvl p+l x1) (inductionB {p} p*l p1l pinvl p+l x2)) 
    inductionB {p} p*l p1l pinvl p+l 1L = p1l 
    inductionB {p} p*l p1l pinvl p+l (invL x1) = (pinvl _ (inductionB {p} p*l p1l pinvl p+l x1)) 
    inductionB {p} p*l p1l pinvl p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p1l pinvl p+l x1) (inductionB {p} p*l p1l pinvl p+l x2)) 
    inductionCl : {A : Set} {P : ((ClNonassociativeNondistributiveRingTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClNonassociativeNondistributiveRingTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((P 1Cl) -> (((x1 : (ClNonassociativeNondistributiveRingTerm A)) -> ((P x1) -> (P (invCl x1)))) -> (((x1 x2 : (ClNonassociativeNondistributiveRingTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClNonassociativeNondistributiveRingTerm A)) -> (P x)))))))
    inductionCl {_} {p} psing p*cl p1cl pinvcl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p1cl pinvcl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p1cl pinvcl p+cl x1) (inductionCl {_} {p} psing p*cl p1cl pinvcl p+cl x2)) 
    inductionCl {_} {p} psing p*cl p1cl pinvcl p+cl 1Cl = p1cl 
    inductionCl {_} {p} psing p*cl p1cl pinvcl p+cl (invCl x1) = (pinvcl _ (inductionCl {_} {p} psing p*cl p1cl pinvcl p+cl x1)) 
    inductionCl {_} {p} psing p*cl p1cl pinvcl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p1cl pinvcl p+cl x1) (inductionCl {_} {p} psing p*cl p1cl pinvcl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpNonassociativeNondistributiveRingTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpNonassociativeNondistributiveRingTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((P 1OL) -> (((x1 : (OpNonassociativeNondistributiveRingTerm n)) -> ((P x1) -> (P (invOL x1)))) -> (((x1 x2 : (OpNonassociativeNondistributiveRingTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpNonassociativeNondistributiveRingTerm n)) -> (P x)))))))
    inductionOpB {_} {p} pv p*ol p1ol pinvol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p1ol pinvol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p1ol pinvol p+ol x1) (inductionOpB {_} {p} pv p*ol p1ol pinvol p+ol x2)) 
    inductionOpB {_} {p} pv p*ol p1ol pinvol p+ol 1OL = p1ol 
    inductionOpB {_} {p} pv p*ol p1ol pinvol p+ol (invOL x1) = (pinvol _ (inductionOpB {_} {p} pv p*ol p1ol pinvol p+ol x1)) 
    inductionOpB {_} {p} pv p*ol p1ol pinvol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p1ol pinvol p+ol x1) (inductionOpB {_} {p} pv p*ol p1ol pinvol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpNonassociativeNondistributiveRingTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpNonassociativeNondistributiveRingTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((P 1OL2) -> (((x1 : (OpNonassociativeNondistributiveRingTerm2 n A)) -> ((P x1) -> (P (invOL2 x1)))) -> (((x1 x2 : (OpNonassociativeNondistributiveRingTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpNonassociativeNondistributiveRingTerm2 n A)) -> (P x))))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 pinvol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 pinvol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 pinvol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 pinvol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 pinvol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 pinvol2 p+ol2 1OL2 = p1ol2 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 pinvol2 p+ol2 (invOL2 x1) = (pinvol2 _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 pinvol2 p+ol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 pinvol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 pinvol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 pinvol2 p+ol2 x2)) 
    *L' : (NonassociativeNondistributiveRingTerm -> (NonassociativeNondistributiveRingTerm -> NonassociativeNondistributiveRingTerm))
    *L' x1 x2 = (*L x1 x2) 
    1L' : NonassociativeNondistributiveRingTerm
    1L'  = 1L 
    invL' : (NonassociativeNondistributiveRingTerm -> NonassociativeNondistributiveRingTerm)
    invL' x1 = (invL x1) 
    +L' : (NonassociativeNondistributiveRingTerm -> (NonassociativeNondistributiveRingTerm -> NonassociativeNondistributiveRingTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (NonassociativeNondistributiveRingTerm -> (Staged NonassociativeNondistributiveRingTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB 1L = (Now 1L) 
    stageB (invL x1) = (stage1 invL' (codeLift1 invL') (stageB x1)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClNonassociativeNondistributiveRingTerm A) -> ((ClNonassociativeNondistributiveRingTerm A) -> (ClNonassociativeNondistributiveRingTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    1Cl' : {A : Set} -> (ClNonassociativeNondistributiveRingTerm A)
    1Cl'  = 1Cl 
    invCl' : {A : Set} -> ((ClNonassociativeNondistributiveRingTerm A) -> (ClNonassociativeNondistributiveRingTerm A))
    invCl' x1 = (invCl x1) 
    +Cl' : {A : Set} -> ((ClNonassociativeNondistributiveRingTerm A) -> ((ClNonassociativeNondistributiveRingTerm A) -> (ClNonassociativeNondistributiveRingTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClNonassociativeNondistributiveRingTerm A) -> (Staged (ClNonassociativeNondistributiveRingTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl 1Cl = (Now 1Cl) 
    stageCl (invCl x1) = (stage1 invCl' (codeLift1 invCl') (stageCl x1)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpNonassociativeNondistributiveRingTerm n) -> ((OpNonassociativeNondistributiveRingTerm n) -> (OpNonassociativeNondistributiveRingTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    1OL' : {n : Nat} -> (OpNonassociativeNondistributiveRingTerm n)
    1OL'  = 1OL 
    invOL' : {n : Nat} -> ((OpNonassociativeNondistributiveRingTerm n) -> (OpNonassociativeNondistributiveRingTerm n))
    invOL' x1 = (invOL x1) 
    +OL' : {n : Nat} -> ((OpNonassociativeNondistributiveRingTerm n) -> ((OpNonassociativeNondistributiveRingTerm n) -> (OpNonassociativeNondistributiveRingTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpNonassociativeNondistributiveRingTerm n) -> (Staged (OpNonassociativeNondistributiveRingTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 1OL = (Now 1OL) 
    stageOpB (invOL x1) = (stage1 invOL' (codeLift1 invOL') (stageOpB x1)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpNonassociativeNondistributiveRingTerm2 n A) -> ((OpNonassociativeNondistributiveRingTerm2 n A) -> (OpNonassociativeNondistributiveRingTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    1OL2' : {n : Nat} {A : Set} -> (OpNonassociativeNondistributiveRingTerm2 n A)
    1OL2'  = 1OL2 
    invOL2' : {n : Nat} {A : Set} -> ((OpNonassociativeNondistributiveRingTerm2 n A) -> (OpNonassociativeNondistributiveRingTerm2 n A))
    invOL2' x1 = (invOL2 x1) 
    +OL2' : {n : Nat} {A : Set} -> ((OpNonassociativeNondistributiveRingTerm2 n A) -> ((OpNonassociativeNondistributiveRingTerm2 n A) -> (OpNonassociativeNondistributiveRingTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpNonassociativeNondistributiveRingTerm2 n A) -> (Staged (OpNonassociativeNondistributiveRingTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp 1OL2 = (Now 1OL2) 
    stageOp (invOL2 x1) = (stage1 invOL2' (codeLift1 invOL2') (stageOp x1)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        1T : (Repr A)
        invT : ((Repr A) -> (Repr A))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module NonassociativeRing  where
    record NonassociativeRing (A : Set) : Set where
      constructor NonassociativeRingC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        1 : A
        lunit_1 : {x : A} -> (* 1 x) == x
        runit_1 : {x : A} -> (* x 1) == x
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        inv : (A -> A)
        leftInverse_inv_op_1 : {x : A} -> (* x (inv x)) == 1
        rightInverse_inv_op_1 : {x : A} -> (* (inv x) x) == 1
        commutative_* : {x y : A} -> (* x y) == (* y x)
        leftDistributive_*_+ : {x y z : A} -> (* x (+ y z)) == (+ (* x y) (* x z))
        rightDistributive_*_+ : {x y z : A} -> (* (+ y z) x) == (+ (* y x) (* z x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
        1S : AS
        invS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        1P : (Prod A A)
        invP : ((Prod A A) -> (Prod A A))
        lunit_1P : {xP : (Prod A A)} -> (*P 1P xP) == xP
        runit_1P : {xP : (Prod A A)} -> (*P xP 1P) == xP
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        leftInverse_inv_op_1P : {xP : (Prod A A)} -> (*P xP (invP xP)) == 1P
        rightInverse_inv_op_1P : {xP : (Prod A A)} -> (*P (invP xP) xP) == 1P
        commutative_*P : {xP yP : (Prod A A)} -> (*P xP yP) == (*P yP xP)
        leftDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P xP (+P yP zP)) == (+P (*P xP yP) (*P xP zP))
        rightDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P (+P yP zP) xP) == (+P (*P yP xP) (*P zP xP))
    record Hom {A1 : Set} {A2 : Set} (No1 : (NonassociativeRing A1)) (No2 : (NonassociativeRing A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* No1) x1 x2)) == ((* No2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ No1) x1 x2)) == ((+ No2) (hom x1) (hom x2))
        pres-1 : (hom (1 No1)) == (1 No2)
        pres-inv : {x1 : A1} -> (hom ((inv No1) x1)) == ((inv No2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (No1 : (NonassociativeRing A1)) (No2 : (NonassociativeRing A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* No1) x1 x2) ((* No2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ No1) x1 x2) ((+ No2) y1 y2))))
        interp-1 : (interp (1 No1) (1 No2))
        interp-inv : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((inv No1) x1) ((inv No2) y1)))
    data NonassociativeRingTerm  : Set where
      *L : (NonassociativeRingTerm -> (NonassociativeRingTerm -> NonassociativeRingTerm))
      +L : (NonassociativeRingTerm -> (NonassociativeRingTerm -> NonassociativeRingTerm))
      1L : NonassociativeRingTerm
      invL : (NonassociativeRingTerm -> NonassociativeRingTerm)
    data ClNonassociativeRingTerm (A : Set) : Set where
      sing : (A -> (ClNonassociativeRingTerm A))
      *Cl : ((ClNonassociativeRingTerm A) -> ((ClNonassociativeRingTerm A) -> (ClNonassociativeRingTerm A)))
      +Cl : ((ClNonassociativeRingTerm A) -> ((ClNonassociativeRingTerm A) -> (ClNonassociativeRingTerm A)))
      1Cl : (ClNonassociativeRingTerm A)
      invCl : ((ClNonassociativeRingTerm A) -> (ClNonassociativeRingTerm A))
    data OpNonassociativeRingTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpNonassociativeRingTerm n))
      *OL : ((OpNonassociativeRingTerm n) -> ((OpNonassociativeRingTerm n) -> (OpNonassociativeRingTerm n)))
      +OL : ((OpNonassociativeRingTerm n) -> ((OpNonassociativeRingTerm n) -> (OpNonassociativeRingTerm n)))
      1OL : (OpNonassociativeRingTerm n)
      invOL : ((OpNonassociativeRingTerm n) -> (OpNonassociativeRingTerm n))
    data OpNonassociativeRingTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpNonassociativeRingTerm2 n A))
      sing2 : (A -> (OpNonassociativeRingTerm2 n A))
      *OL2 : ((OpNonassociativeRingTerm2 n A) -> ((OpNonassociativeRingTerm2 n A) -> (OpNonassociativeRingTerm2 n A)))
      +OL2 : ((OpNonassociativeRingTerm2 n A) -> ((OpNonassociativeRingTerm2 n A) -> (OpNonassociativeRingTerm2 n A)))
      1OL2 : (OpNonassociativeRingTerm2 n A)
      invOL2 : ((OpNonassociativeRingTerm2 n A) -> (OpNonassociativeRingTerm2 n A))
    simplifyCl : {A : Set} -> ((ClNonassociativeRingTerm A) -> (ClNonassociativeRingTerm A))
    simplifyCl (*Cl 1Cl x) = x 
    simplifyCl (*Cl x 1Cl) = x 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (invCl x1) = (invCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpNonassociativeRingTerm n) -> (OpNonassociativeRingTerm n))
    simplifyOpB (*OL 1OL x) = x 
    simplifyOpB (*OL x 1OL) = x 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (invOL x1) = (invOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpNonassociativeRingTerm2 n A) -> (OpNonassociativeRingTerm2 n A))
    simplifyOp (*OL2 1OL2 x) = x 
    simplifyOp (*OL2 x 1OL2) = x 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (invOL2 x1) = (invOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((NonassociativeRing A) -> (NonassociativeRingTerm -> A))
    evalB No (*L x1 x2) = ((* No) (evalB No x1) (evalB No x2)) 
    evalB No (+L x1 x2) = ((+ No) (evalB No x1) (evalB No x2)) 
    evalB No 1L = (1 No) 
    evalB No (invL x1) = ((inv No) (evalB No x1)) 
    evalCl : {A : Set} -> ((NonassociativeRing A) -> ((ClNonassociativeRingTerm A) -> A))
    evalCl No (sing x1) = x1 
    evalCl No (*Cl x1 x2) = ((* No) (evalCl No x1) (evalCl No x2)) 
    evalCl No (+Cl x1 x2) = ((+ No) (evalCl No x1) (evalCl No x2)) 
    evalCl No 1Cl = (1 No) 
    evalCl No (invCl x1) = ((inv No) (evalCl No x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((NonassociativeRing A) -> ((Vec A n) -> ((OpNonassociativeRingTerm n) -> A)))
    evalOpB No vars (v x1) = (lookup _ x1 vars) 
    evalOpB No vars (*OL x1 x2) = ((* No) (evalOpB No vars x1) (evalOpB No vars x2)) 
    evalOpB No vars (+OL x1 x2) = ((+ No) (evalOpB No vars x1) (evalOpB No vars x2)) 
    evalOpB No vars 1OL = (1 No) 
    evalOpB No vars (invOL x1) = ((inv No) (evalOpB No vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((NonassociativeRing A) -> ((Vec A n) -> ((OpNonassociativeRingTerm2 n A) -> A)))
    evalOp No vars (v2 x1) = (lookup _ x1 vars) 
    evalOp No vars (sing2 x1) = x1 
    evalOp No vars (*OL2 x1 x2) = ((* No) (evalOp No vars x1) (evalOp No vars x2)) 
    evalOp No vars (+OL2 x1 x2) = ((+ No) (evalOp No vars x1) (evalOp No vars x2)) 
    evalOp No vars 1OL2 = (1 No) 
    evalOp No vars (invOL2 x1) = ((inv No) (evalOp No vars x1)) 
    inductionB : {P : (NonassociativeRingTerm -> Set)} -> (((x1 x2 : NonassociativeRingTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : NonassociativeRingTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((P 1L) -> (((x1 : NonassociativeRingTerm) -> ((P x1) -> (P (invL x1)))) -> ((x : NonassociativeRingTerm) -> (P x))))))
    inductionB {p} p*l p+l p1l pinvl (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l p1l pinvl x1) (inductionB {p} p*l p+l p1l pinvl x2)) 
    inductionB {p} p*l p+l p1l pinvl (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l p1l pinvl x1) (inductionB {p} p*l p+l p1l pinvl x2)) 
    inductionB {p} p*l p+l p1l pinvl 1L = p1l 
    inductionB {p} p*l p+l p1l pinvl (invL x1) = (pinvl _ (inductionB {p} p*l p+l p1l pinvl x1)) 
    inductionCl : {A : Set} {P : ((ClNonassociativeRingTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClNonassociativeRingTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClNonassociativeRingTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((P 1Cl) -> (((x1 : (ClNonassociativeRingTerm A)) -> ((P x1) -> (P (invCl x1)))) -> ((x : (ClNonassociativeRingTerm A)) -> (P x)))))))
    inductionCl {_} {p} psing p*cl p+cl p1cl pinvcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl p1cl pinvcl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl p1cl pinvcl x1) (inductionCl {_} {p} psing p*cl p+cl p1cl pinvcl x2)) 
    inductionCl {_} {p} psing p*cl p+cl p1cl pinvcl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl p1cl pinvcl x1) (inductionCl {_} {p} psing p*cl p+cl p1cl pinvcl x2)) 
    inductionCl {_} {p} psing p*cl p+cl p1cl pinvcl 1Cl = p1cl 
    inductionCl {_} {p} psing p*cl p+cl p1cl pinvcl (invCl x1) = (pinvcl _ (inductionCl {_} {p} psing p*cl p+cl p1cl pinvcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpNonassociativeRingTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpNonassociativeRingTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpNonassociativeRingTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((P 1OL) -> (((x1 : (OpNonassociativeRingTerm n)) -> ((P x1) -> (P (invOL x1)))) -> ((x : (OpNonassociativeRingTerm n)) -> (P x)))))))
    inductionOpB {_} {p} pv p*ol p+ol p1ol pinvol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol p1ol pinvol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol p1ol pinvol x1) (inductionOpB {_} {p} pv p*ol p+ol p1ol pinvol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol p1ol pinvol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol p1ol pinvol x1) (inductionOpB {_} {p} pv p*ol p+ol p1ol pinvol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol p1ol pinvol 1OL = p1ol 
    inductionOpB {_} {p} pv p*ol p+ol p1ol pinvol (invOL x1) = (pinvol _ (inductionOpB {_} {p} pv p*ol p+ol p1ol pinvol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpNonassociativeRingTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpNonassociativeRingTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpNonassociativeRingTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((P 1OL2) -> (((x1 : (OpNonassociativeRingTerm2 n A)) -> ((P x1) -> (P (invOL2 x1)))) -> ((x : (OpNonassociativeRingTerm2 n A)) -> (P x))))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 pinvol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 pinvol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 pinvol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 pinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 pinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 pinvol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 pinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 pinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 pinvol2 1OL2 = p1ol2 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 pinvol2 (invOL2 x1) = (pinvol2 _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 pinvol2 x1)) 
    *L' : (NonassociativeRingTerm -> (NonassociativeRingTerm -> NonassociativeRingTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (NonassociativeRingTerm -> (NonassociativeRingTerm -> NonassociativeRingTerm))
    +L' x1 x2 = (+L x1 x2) 
    1L' : NonassociativeRingTerm
    1L'  = 1L 
    invL' : (NonassociativeRingTerm -> NonassociativeRingTerm)
    invL' x1 = (invL x1) 
    stageB : (NonassociativeRingTerm -> (Staged NonassociativeRingTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB 1L = (Now 1L) 
    stageB (invL x1) = (stage1 invL' (codeLift1 invL') (stageB x1)) 
    *Cl' : {A : Set} -> ((ClNonassociativeRingTerm A) -> ((ClNonassociativeRingTerm A) -> (ClNonassociativeRingTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClNonassociativeRingTerm A) -> ((ClNonassociativeRingTerm A) -> (ClNonassociativeRingTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    1Cl' : {A : Set} -> (ClNonassociativeRingTerm A)
    1Cl'  = 1Cl 
    invCl' : {A : Set} -> ((ClNonassociativeRingTerm A) -> (ClNonassociativeRingTerm A))
    invCl' x1 = (invCl x1) 
    stageCl : {A : Set} -> ((ClNonassociativeRingTerm A) -> (Staged (ClNonassociativeRingTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl 1Cl = (Now 1Cl) 
    stageCl (invCl x1) = (stage1 invCl' (codeLift1 invCl') (stageCl x1)) 
    *OL' : {n : Nat} -> ((OpNonassociativeRingTerm n) -> ((OpNonassociativeRingTerm n) -> (OpNonassociativeRingTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpNonassociativeRingTerm n) -> ((OpNonassociativeRingTerm n) -> (OpNonassociativeRingTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    1OL' : {n : Nat} -> (OpNonassociativeRingTerm n)
    1OL'  = 1OL 
    invOL' : {n : Nat} -> ((OpNonassociativeRingTerm n) -> (OpNonassociativeRingTerm n))
    invOL' x1 = (invOL x1) 
    stageOpB : {n : Nat} -> ((OpNonassociativeRingTerm n) -> (Staged (OpNonassociativeRingTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 1OL = (Now 1OL) 
    stageOpB (invOL x1) = (stage1 invOL' (codeLift1 invOL') (stageOpB x1)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpNonassociativeRingTerm2 n A) -> ((OpNonassociativeRingTerm2 n A) -> (OpNonassociativeRingTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpNonassociativeRingTerm2 n A) -> ((OpNonassociativeRingTerm2 n A) -> (OpNonassociativeRingTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    1OL2' : {n : Nat} {A : Set} -> (OpNonassociativeRingTerm2 n A)
    1OL2'  = 1OL2 
    invOL2' : {n : Nat} {A : Set} -> ((OpNonassociativeRingTerm2 n A) -> (OpNonassociativeRingTerm2 n A))
    invOL2' x1 = (invOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpNonassociativeRingTerm2 n A) -> (Staged (OpNonassociativeRingTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp 1OL2 = (Now 1OL2) 
    stageOp (invOL2 x1) = (stage1 invOL2' (codeLift1 invOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        1T : (Repr A)
        invT : ((Repr A) -> (Repr A))
  module NormalBand  where
    record NormalBand (A : Set) : Set where
      constructor NormalBandC
      field
        op : (A -> (A -> A))
        associative_op : {x y z : A} -> (op (op x y) z) == (op x (op y z))
        idempotent_op : {x : A} -> (op x x) == x
        middleCommute_* : {x y z : A} -> (op (op (op x y) z) x) == (op (op (op x z) y) x)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        associative_opP : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP (opP yP zP))
        idempotent_opP : {xP : (Prod A A)} -> (opP xP xP) == xP
        middleCommute_*P : {xP yP zP : (Prod A A)} -> (opP (opP (opP xP yP) zP) xP) == (opP (opP (opP xP zP) yP) xP)
    record Hom {A1 : Set} {A2 : Set} (No1 : (NormalBand A1)) (No2 : (NormalBand A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op No1) x1 x2)) == ((op No2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (No1 : (NormalBand A1)) (No2 : (NormalBand A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op No1) x1 x2) ((op No2) y1 y2))))
    data NormalBandTerm  : Set where
      opL : (NormalBandTerm -> (NormalBandTerm -> NormalBandTerm))
    data ClNormalBandTerm (A : Set) : Set where
      sing : (A -> (ClNormalBandTerm A))
      opCl : ((ClNormalBandTerm A) -> ((ClNormalBandTerm A) -> (ClNormalBandTerm A)))
    data OpNormalBandTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpNormalBandTerm n))
      opOL : ((OpNormalBandTerm n) -> ((OpNormalBandTerm n) -> (OpNormalBandTerm n)))
    data OpNormalBandTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpNormalBandTerm2 n A))
      sing2 : (A -> (OpNormalBandTerm2 n A))
      opOL2 : ((OpNormalBandTerm2 n A) -> ((OpNormalBandTerm2 n A) -> (OpNormalBandTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClNormalBandTerm A) -> (ClNormalBandTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpNormalBandTerm n) -> (OpNormalBandTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpNormalBandTerm2 n A) -> (OpNormalBandTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((NormalBand A) -> (NormalBandTerm -> A))
    evalB No (opL x1 x2) = ((op No) (evalB No x1) (evalB No x2)) 
    evalCl : {A : Set} -> ((NormalBand A) -> ((ClNormalBandTerm A) -> A))
    evalCl No (sing x1) = x1 
    evalCl No (opCl x1 x2) = ((op No) (evalCl No x1) (evalCl No x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((NormalBand A) -> ((Vec A n) -> ((OpNormalBandTerm n) -> A)))
    evalOpB No vars (v x1) = (lookup _ x1 vars) 
    evalOpB No vars (opOL x1 x2) = ((op No) (evalOpB No vars x1) (evalOpB No vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((NormalBand A) -> ((Vec A n) -> ((OpNormalBandTerm2 n A) -> A)))
    evalOp No vars (v2 x1) = (lookup _ x1 vars) 
    evalOp No vars (sing2 x1) = x1 
    evalOp No vars (opOL2 x1 x2) = ((op No) (evalOp No vars x1) (evalOp No vars x2)) 
    inductionB : {P : (NormalBandTerm -> Set)} -> (((x1 x2 : NormalBandTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : NormalBandTerm) -> (P x)))
    inductionB {p} popl (opL x1 x2) = (popl _ _ (inductionB {p} popl x1) (inductionB {p} popl x2)) 
    inductionCl : {A : Set} {P : ((ClNormalBandTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClNormalBandTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClNormalBandTerm A)) -> (P x))))
    inductionCl {_} {p} psing popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl x1) (inductionCl {_} {p} psing popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpNormalBandTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpNormalBandTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpNormalBandTerm n)) -> (P x))))
    inductionOpB {_} {p} pv popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol x1) (inductionOpB {_} {p} pv popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpNormalBandTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpNormalBandTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpNormalBandTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 x2)) 
    opL' : (NormalBandTerm -> (NormalBandTerm -> NormalBandTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (NormalBandTerm -> (Staged NormalBandTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClNormalBandTerm A) -> ((ClNormalBandTerm A) -> (ClNormalBandTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClNormalBandTerm A) -> (Staged (ClNormalBandTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpNormalBandTerm n) -> ((OpNormalBandTerm n) -> (OpNormalBandTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpNormalBandTerm n) -> (Staged (OpNormalBandTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpNormalBandTerm2 n A) -> ((OpNormalBandTerm2 n A) -> (OpNormalBandTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpNormalBandTerm2 n A) -> (Staged (OpNormalBandTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module OrDeMorgran  where
    record OrDeMorgran (A : Set) : Set where
      constructor OrDeMorgranC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        prim : (A -> A)
        orDeMorgan_+_*_prim : {x y z : A} -> (prim (+ x y)) == (* (prim x) (prim y))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
        primS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        primP : ((Prod A A) -> (Prod A A))
        orDeMorgan_+_*_primP : {xP yP zP : (Prod A A)} -> (primP (+P xP yP)) == (*P (primP xP) (primP yP))
    record Hom {A1 : Set} {A2 : Set} (Or1 : (OrDeMorgran A1)) (Or2 : (OrDeMorgran A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Or1) x1 x2)) == ((* Or2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Or1) x1 x2)) == ((+ Or2) (hom x1) (hom x2))
        pres-prim : {x1 : A1} -> (hom ((prim Or1) x1)) == ((prim Or2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (Or1 : (OrDeMorgran A1)) (Or2 : (OrDeMorgran A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Or1) x1 x2) ((* Or2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Or1) x1 x2) ((+ Or2) y1 y2))))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim Or1) x1) ((prim Or2) y1)))
    data OrDeMorgranTerm  : Set where
      *L : (OrDeMorgranTerm -> (OrDeMorgranTerm -> OrDeMorgranTerm))
      +L : (OrDeMorgranTerm -> (OrDeMorgranTerm -> OrDeMorgranTerm))
      primL : (OrDeMorgranTerm -> OrDeMorgranTerm)
    data ClOrDeMorgranTerm (A : Set) : Set where
      sing : (A -> (ClOrDeMorgranTerm A))
      *Cl : ((ClOrDeMorgranTerm A) -> ((ClOrDeMorgranTerm A) -> (ClOrDeMorgranTerm A)))
      +Cl : ((ClOrDeMorgranTerm A) -> ((ClOrDeMorgranTerm A) -> (ClOrDeMorgranTerm A)))
      primCl : ((ClOrDeMorgranTerm A) -> (ClOrDeMorgranTerm A))
    data OpOrDeMorgranTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpOrDeMorgranTerm n))
      *OL : ((OpOrDeMorgranTerm n) -> ((OpOrDeMorgranTerm n) -> (OpOrDeMorgranTerm n)))
      +OL : ((OpOrDeMorgranTerm n) -> ((OpOrDeMorgranTerm n) -> (OpOrDeMorgranTerm n)))
      primOL : ((OpOrDeMorgranTerm n) -> (OpOrDeMorgranTerm n))
    data OpOrDeMorgranTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpOrDeMorgranTerm2 n A))
      sing2 : (A -> (OpOrDeMorgranTerm2 n A))
      *OL2 : ((OpOrDeMorgranTerm2 n A) -> ((OpOrDeMorgranTerm2 n A) -> (OpOrDeMorgranTerm2 n A)))
      +OL2 : ((OpOrDeMorgranTerm2 n A) -> ((OpOrDeMorgranTerm2 n A) -> (OpOrDeMorgranTerm2 n A)))
      primOL2 : ((OpOrDeMorgranTerm2 n A) -> (OpOrDeMorgranTerm2 n A))
    simplifyCl : {A : Set} -> ((ClOrDeMorgranTerm A) -> (ClOrDeMorgranTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpOrDeMorgranTerm n) -> (OpOrDeMorgranTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpOrDeMorgranTerm2 n A) -> (OpOrDeMorgranTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((OrDeMorgran A) -> (OrDeMorgranTerm -> A))
    evalB Or (*L x1 x2) = ((* Or) (evalB Or x1) (evalB Or x2)) 
    evalB Or (+L x1 x2) = ((+ Or) (evalB Or x1) (evalB Or x2)) 
    evalB Or (primL x1) = ((prim Or) (evalB Or x1)) 
    evalCl : {A : Set} -> ((OrDeMorgran A) -> ((ClOrDeMorgranTerm A) -> A))
    evalCl Or (sing x1) = x1 
    evalCl Or (*Cl x1 x2) = ((* Or) (evalCl Or x1) (evalCl Or x2)) 
    evalCl Or (+Cl x1 x2) = ((+ Or) (evalCl Or x1) (evalCl Or x2)) 
    evalCl Or (primCl x1) = ((prim Or) (evalCl Or x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((OrDeMorgran A) -> ((Vec A n) -> ((OpOrDeMorgranTerm n) -> A)))
    evalOpB Or vars (v x1) = (lookup _ x1 vars) 
    evalOpB Or vars (*OL x1 x2) = ((* Or) (evalOpB Or vars x1) (evalOpB Or vars x2)) 
    evalOpB Or vars (+OL x1 x2) = ((+ Or) (evalOpB Or vars x1) (evalOpB Or vars x2)) 
    evalOpB Or vars (primOL x1) = ((prim Or) (evalOpB Or vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((OrDeMorgran A) -> ((Vec A n) -> ((OpOrDeMorgranTerm2 n A) -> A)))
    evalOp Or vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Or vars (sing2 x1) = x1 
    evalOp Or vars (*OL2 x1 x2) = ((* Or) (evalOp Or vars x1) (evalOp Or vars x2)) 
    evalOp Or vars (+OL2 x1 x2) = ((+ Or) (evalOp Or vars x1) (evalOp Or vars x2)) 
    evalOp Or vars (primOL2 x1) = ((prim Or) (evalOp Or vars x1)) 
    inductionB : {P : (OrDeMorgranTerm -> Set)} -> (((x1 x2 : OrDeMorgranTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : OrDeMorgranTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> (((x1 : OrDeMorgranTerm) -> ((P x1) -> (P (primL x1)))) -> ((x : OrDeMorgranTerm) -> (P x)))))
    inductionB {p} p*l p+l ppriml (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l ppriml x1) (inductionB {p} p*l p+l ppriml x2)) 
    inductionB {p} p*l p+l ppriml (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l ppriml x1) (inductionB {p} p*l p+l ppriml x2)) 
    inductionB {p} p*l p+l ppriml (primL x1) = (ppriml _ (inductionB {p} p*l p+l ppriml x1)) 
    inductionCl : {A : Set} {P : ((ClOrDeMorgranTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClOrDeMorgranTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClOrDeMorgranTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> (((x1 : (ClOrDeMorgranTerm A)) -> ((P x1) -> (P (primCl x1)))) -> ((x : (ClOrDeMorgranTerm A)) -> (P x))))))
    inductionCl {_} {p} psing p*cl p+cl pprimcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl pprimcl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl pprimcl x1) (inductionCl {_} {p} psing p*cl p+cl pprimcl x2)) 
    inductionCl {_} {p} psing p*cl p+cl pprimcl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl pprimcl x1) (inductionCl {_} {p} psing p*cl p+cl pprimcl x2)) 
    inductionCl {_} {p} psing p*cl p+cl pprimcl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing p*cl p+cl pprimcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpOrDeMorgranTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpOrDeMorgranTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpOrDeMorgranTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> (((x1 : (OpOrDeMorgranTerm n)) -> ((P x1) -> (P (primOL x1)))) -> ((x : (OpOrDeMorgranTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv p*ol p+ol pprimol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol pprimol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol pprimol x1) (inductionOpB {_} {p} pv p*ol p+ol pprimol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol pprimol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol pprimol x1) (inductionOpB {_} {p} pv p*ol p+ol pprimol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol pprimol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv p*ol p+ol pprimol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpOrDeMorgranTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpOrDeMorgranTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpOrDeMorgranTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> (((x1 : (OpOrDeMorgranTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> ((x : (OpOrDeMorgranTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x1)) 
    *L' : (OrDeMorgranTerm -> (OrDeMorgranTerm -> OrDeMorgranTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (OrDeMorgranTerm -> (OrDeMorgranTerm -> OrDeMorgranTerm))
    +L' x1 x2 = (+L x1 x2) 
    primL' : (OrDeMorgranTerm -> OrDeMorgranTerm)
    primL' x1 = (primL x1) 
    stageB : (OrDeMorgranTerm -> (Staged OrDeMorgranTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    *Cl' : {A : Set} -> ((ClOrDeMorgranTerm A) -> ((ClOrDeMorgranTerm A) -> (ClOrDeMorgranTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClOrDeMorgranTerm A) -> ((ClOrDeMorgranTerm A) -> (ClOrDeMorgranTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    primCl' : {A : Set} -> ((ClOrDeMorgranTerm A) -> (ClOrDeMorgranTerm A))
    primCl' x1 = (primCl x1) 
    stageCl : {A : Set} -> ((ClOrDeMorgranTerm A) -> (Staged (ClOrDeMorgranTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    *OL' : {n : Nat} -> ((OpOrDeMorgranTerm n) -> ((OpOrDeMorgranTerm n) -> (OpOrDeMorgranTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpOrDeMorgranTerm n) -> ((OpOrDeMorgranTerm n) -> (OpOrDeMorgranTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    primOL' : {n : Nat} -> ((OpOrDeMorgranTerm n) -> (OpOrDeMorgranTerm n))
    primOL' x1 = (primOL x1) 
    stageOpB : {n : Nat} -> ((OpOrDeMorgranTerm n) -> (Staged (OpOrDeMorgranTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpOrDeMorgranTerm2 n A) -> ((OpOrDeMorgranTerm2 n A) -> (OpOrDeMorgranTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpOrDeMorgranTerm2 n A) -> ((OpOrDeMorgranTerm2 n A) -> (OpOrDeMorgranTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    primOL2' : {n : Nat} {A : Set} -> ((OpOrDeMorgranTerm2 n A) -> (OpOrDeMorgranTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpOrDeMorgranTerm2 n A) -> (Staged (OpOrDeMorgranTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        primT : ((Repr A) -> (Repr A))
  module Pointed  where
    record Pointed (A : Set) : Set where
      constructor PointedC
      field
        e : A
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        eS : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        eP : (Prod A A)
    record Hom {A1 : Set} {A2 : Set} (Po1 : (Pointed A1)) (Po2 : (Pointed A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-e : (hom (e Po1)) == (e Po2)
    record RelInterp {A1 : Set} {A2 : Set} (Po1 : (Pointed A1)) (Po2 : (Pointed A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-e : (interp (e Po1) (e Po2))
    data PointedTerm  : Set where
      eL : PointedTerm
    data ClPointedTerm (A : Set) : Set where
      sing : (A -> (ClPointedTerm A))
      eCl : (ClPointedTerm A)
    data OpPointedTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpPointedTerm n))
      eOL : (OpPointedTerm n)
    data OpPointedTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpPointedTerm2 n A))
      sing2 : (A -> (OpPointedTerm2 n A))
      eOL2 : (OpPointedTerm2 n A)
    simplifyCl : {A : Set} -> ((ClPointedTerm A) -> (ClPointedTerm A))
    simplifyCl eCl = eCl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpPointedTerm n) -> (OpPointedTerm n))
    simplifyOpB eOL = eOL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpPointedTerm2 n A) -> (OpPointedTerm2 n A))
    simplifyOp eOL2 = eOL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Pointed A) -> (PointedTerm -> A))
    evalB Po eL = (e Po) 
    evalCl : {A : Set} -> ((Pointed A) -> ((ClPointedTerm A) -> A))
    evalCl Po (sing x1) = x1 
    evalCl Po eCl = (e Po) 
    evalOpB : {A : Set} {n : Nat} -> ((Pointed A) -> ((Vec A n) -> ((OpPointedTerm n) -> A)))
    evalOpB Po vars (v x1) = (lookup _ x1 vars) 
    evalOpB Po vars eOL = (e Po) 
    evalOp : {A : Set} {n : Nat} -> ((Pointed A) -> ((Vec A n) -> ((OpPointedTerm2 n A) -> A)))
    evalOp Po vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Po vars (sing2 x1) = x1 
    evalOp Po vars eOL2 = (e Po) 
    inductionB : {P : (PointedTerm -> Set)} -> ((P eL) -> ((x : PointedTerm) -> (P x)))
    inductionB {p} pel eL = pel 
    inductionCl : {A : Set} {P : ((ClPointedTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P eCl) -> ((x : (ClPointedTerm A)) -> (P x))))
    inductionCl {_} {p} psing pecl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pecl eCl = pecl 
    inductionOpB : {n : Nat} {P : ((OpPointedTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P eOL) -> ((x : (OpPointedTerm n)) -> (P x))))
    inductionOpB {_} {p} pv peol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv peol eOL = peol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpPointedTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P eOL2) -> ((x : (OpPointedTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 peol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 peol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 peol2 eOL2 = peol2 
    eL' : PointedTerm
    eL'  = eL 
    stageB : (PointedTerm -> (Staged PointedTerm))
    stageB eL = (Now eL) 
    eCl' : {A : Set} -> (ClPointedTerm A)
    eCl'  = eCl 
    stageCl : {A : Set} -> ((ClPointedTerm A) -> (Staged (ClPointedTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl eCl = (Now eCl) 
    eOL' : {n : Nat} -> (OpPointedTerm n)
    eOL'  = eOL 
    stageOpB : {n : Nat} -> ((OpPointedTerm n) -> (Staged (OpPointedTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB eOL = (Now eOL) 
    eOL2' : {n : Nat} {A : Set} -> (OpPointedTerm2 n A)
    eOL2'  = eOL2 
    stageOp : {n : Nat} {A : Set} -> ((OpPointedTerm2 n A) -> (Staged (OpPointedTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp eOL2 = (Now eOL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        eT : (Repr A)
  module Pointed0Magma  where
    record Pointed0Magma (A : Set) : Set where
      constructor Pointed0MagmaC
      field
        0 : A
        op : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        0S : AS
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        0P : (Prod A A)
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
    record Hom {A1 : Set} {A2 : Set} (Po1 : (Pointed0Magma A1)) (Po2 : (Pointed0Magma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-0 : (hom (0 Po1)) == (0 Po2)
        pres-op : {x1 x2 : A1} -> (hom ((op Po1) x1 x2)) == ((op Po2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Po1 : (Pointed0Magma A1)) (Po2 : (Pointed0Magma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-0 : (interp (0 Po1) (0 Po2))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Po1) x1 x2) ((op Po2) y1 y2))))
    data Pointed0MagmaTerm  : Set where
      0L : Pointed0MagmaTerm
      opL : (Pointed0MagmaTerm -> (Pointed0MagmaTerm -> Pointed0MagmaTerm))
    data ClPointed0MagmaTerm (A : Set) : Set where
      sing : (A -> (ClPointed0MagmaTerm A))
      0Cl : (ClPointed0MagmaTerm A)
      opCl : ((ClPointed0MagmaTerm A) -> ((ClPointed0MagmaTerm A) -> (ClPointed0MagmaTerm A)))
    data OpPointed0MagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpPointed0MagmaTerm n))
      0OL : (OpPointed0MagmaTerm n)
      opOL : ((OpPointed0MagmaTerm n) -> ((OpPointed0MagmaTerm n) -> (OpPointed0MagmaTerm n)))
    data OpPointed0MagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpPointed0MagmaTerm2 n A))
      sing2 : (A -> (OpPointed0MagmaTerm2 n A))
      0OL2 : (OpPointed0MagmaTerm2 n A)
      opOL2 : ((OpPointed0MagmaTerm2 n A) -> ((OpPointed0MagmaTerm2 n A) -> (OpPointed0MagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClPointed0MagmaTerm A) -> (ClPointed0MagmaTerm A))
    simplifyCl 0Cl = 0Cl 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpPointed0MagmaTerm n) -> (OpPointed0MagmaTerm n))
    simplifyOpB 0OL = 0OL 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpPointed0MagmaTerm2 n A) -> (OpPointed0MagmaTerm2 n A))
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Pointed0Magma A) -> (Pointed0MagmaTerm -> A))
    evalB Po 0L = (0 Po) 
    evalB Po (opL x1 x2) = ((op Po) (evalB Po x1) (evalB Po x2)) 
    evalCl : {A : Set} -> ((Pointed0Magma A) -> ((ClPointed0MagmaTerm A) -> A))
    evalCl Po (sing x1) = x1 
    evalCl Po 0Cl = (0 Po) 
    evalCl Po (opCl x1 x2) = ((op Po) (evalCl Po x1) (evalCl Po x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Pointed0Magma A) -> ((Vec A n) -> ((OpPointed0MagmaTerm n) -> A)))
    evalOpB Po vars (v x1) = (lookup _ x1 vars) 
    evalOpB Po vars 0OL = (0 Po) 
    evalOpB Po vars (opOL x1 x2) = ((op Po) (evalOpB Po vars x1) (evalOpB Po vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Pointed0Magma A) -> ((Vec A n) -> ((OpPointed0MagmaTerm2 n A) -> A)))
    evalOp Po vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Po vars (sing2 x1) = x1 
    evalOp Po vars 0OL2 = (0 Po) 
    evalOp Po vars (opOL2 x1 x2) = ((op Po) (evalOp Po vars x1) (evalOp Po vars x2)) 
    inductionB : {P : (Pointed0MagmaTerm -> Set)} -> ((P 0L) -> (((x1 x2 : Pointed0MagmaTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : Pointed0MagmaTerm) -> (P x))))
    inductionB {p} p0l popl 0L = p0l 
    inductionB {p} p0l popl (opL x1 x2) = (popl _ _ (inductionB {p} p0l popl x1) (inductionB {p} p0l popl x2)) 
    inductionCl : {A : Set} {P : ((ClPointed0MagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 0Cl) -> (((x1 x2 : (ClPointed0MagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClPointed0MagmaTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p0cl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p0cl popcl 0Cl = p0cl 
    inductionCl {_} {p} psing p0cl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing p0cl popcl x1) (inductionCl {_} {p} psing p0cl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpPointed0MagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 0OL) -> (((x1 x2 : (OpPointed0MagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpPointed0MagmaTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p0ol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p0ol popol 0OL = p0ol 
    inductionOpB {_} {p} pv p0ol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv p0ol popol x1) (inductionOpB {_} {p} pv p0ol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpPointed0MagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 0OL2) -> (((x1 x2 : (OpPointed0MagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpPointed0MagmaTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 popol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p0ol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p0ol2 popol2 x2)) 
    0L' : Pointed0MagmaTerm
    0L'  = 0L 
    opL' : (Pointed0MagmaTerm -> (Pointed0MagmaTerm -> Pointed0MagmaTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (Pointed0MagmaTerm -> (Staged Pointed0MagmaTerm))
    stageB 0L = (Now 0L) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    0Cl' : {A : Set} -> (ClPointed0MagmaTerm A)
    0Cl'  = 0Cl 
    opCl' : {A : Set} -> ((ClPointed0MagmaTerm A) -> ((ClPointed0MagmaTerm A) -> (ClPointed0MagmaTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClPointed0MagmaTerm A) -> (Staged (ClPointed0MagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    0OL' : {n : Nat} -> (OpPointed0MagmaTerm n)
    0OL'  = 0OL 
    opOL' : {n : Nat} -> ((OpPointed0MagmaTerm n) -> ((OpPointed0MagmaTerm n) -> (OpPointed0MagmaTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpPointed0MagmaTerm n) -> (Staged (OpPointed0MagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    0OL2' : {n : Nat} {A : Set} -> (OpPointed0MagmaTerm2 n A)
    0OL2'  = 0OL2 
    opOL2' : {n : Nat} {A : Set} -> ((OpPointed0MagmaTerm2 n A) -> ((OpPointed0MagmaTerm2 n A) -> (OpPointed0MagmaTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpPointed0MagmaTerm2 n A) -> (Staged (OpPointed0MagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        0T : (Repr A)
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module Pointed1Magma  where
    record Pointed1Magma (A : Set) : Set where
      constructor Pointed1MagmaC
      field
        1 : A
        op : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        1S : AS
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        1P : (Prod A A)
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
    record Hom {A1 : Set} {A2 : Set} (Po1 : (Pointed1Magma A1)) (Po2 : (Pointed1Magma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-1 : (hom (1 Po1)) == (1 Po2)
        pres-op : {x1 x2 : A1} -> (hom ((op Po1) x1 x2)) == ((op Po2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Po1 : (Pointed1Magma A1)) (Po2 : (Pointed1Magma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-1 : (interp (1 Po1) (1 Po2))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Po1) x1 x2) ((op Po2) y1 y2))))
    data Pointed1MagmaTerm  : Set where
      1L : Pointed1MagmaTerm
      opL : (Pointed1MagmaTerm -> (Pointed1MagmaTerm -> Pointed1MagmaTerm))
    data ClPointed1MagmaTerm (A : Set) : Set where
      sing : (A -> (ClPointed1MagmaTerm A))
      1Cl : (ClPointed1MagmaTerm A)
      opCl : ((ClPointed1MagmaTerm A) -> ((ClPointed1MagmaTerm A) -> (ClPointed1MagmaTerm A)))
    data OpPointed1MagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpPointed1MagmaTerm n))
      1OL : (OpPointed1MagmaTerm n)
      opOL : ((OpPointed1MagmaTerm n) -> ((OpPointed1MagmaTerm n) -> (OpPointed1MagmaTerm n)))
    data OpPointed1MagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpPointed1MagmaTerm2 n A))
      sing2 : (A -> (OpPointed1MagmaTerm2 n A))
      1OL2 : (OpPointed1MagmaTerm2 n A)
      opOL2 : ((OpPointed1MagmaTerm2 n A) -> ((OpPointed1MagmaTerm2 n A) -> (OpPointed1MagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClPointed1MagmaTerm A) -> (ClPointed1MagmaTerm A))
    simplifyCl 1Cl = 1Cl 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpPointed1MagmaTerm n) -> (OpPointed1MagmaTerm n))
    simplifyOpB 1OL = 1OL 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpPointed1MagmaTerm2 n A) -> (OpPointed1MagmaTerm2 n A))
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Pointed1Magma A) -> (Pointed1MagmaTerm -> A))
    evalB Po 1L = (1 Po) 
    evalB Po (opL x1 x2) = ((op Po) (evalB Po x1) (evalB Po x2)) 
    evalCl : {A : Set} -> ((Pointed1Magma A) -> ((ClPointed1MagmaTerm A) -> A))
    evalCl Po (sing x1) = x1 
    evalCl Po 1Cl = (1 Po) 
    evalCl Po (opCl x1 x2) = ((op Po) (evalCl Po x1) (evalCl Po x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Pointed1Magma A) -> ((Vec A n) -> ((OpPointed1MagmaTerm n) -> A)))
    evalOpB Po vars (v x1) = (lookup _ x1 vars) 
    evalOpB Po vars 1OL = (1 Po) 
    evalOpB Po vars (opOL x1 x2) = ((op Po) (evalOpB Po vars x1) (evalOpB Po vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Pointed1Magma A) -> ((Vec A n) -> ((OpPointed1MagmaTerm2 n A) -> A)))
    evalOp Po vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Po vars (sing2 x1) = x1 
    evalOp Po vars 1OL2 = (1 Po) 
    evalOp Po vars (opOL2 x1 x2) = ((op Po) (evalOp Po vars x1) (evalOp Po vars x2)) 
    inductionB : {P : (Pointed1MagmaTerm -> Set)} -> ((P 1L) -> (((x1 x2 : Pointed1MagmaTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : Pointed1MagmaTerm) -> (P x))))
    inductionB {p} p1l popl 1L = p1l 
    inductionB {p} p1l popl (opL x1 x2) = (popl _ _ (inductionB {p} p1l popl x1) (inductionB {p} p1l popl x2)) 
    inductionCl : {A : Set} {P : ((ClPointed1MagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 1Cl) -> (((x1 x2 : (ClPointed1MagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClPointed1MagmaTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p1cl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p1cl popcl 1Cl = p1cl 
    inductionCl {_} {p} psing p1cl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing p1cl popcl x1) (inductionCl {_} {p} psing p1cl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpPointed1MagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 1OL) -> (((x1 x2 : (OpPointed1MagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpPointed1MagmaTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p1ol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p1ol popol 1OL = p1ol 
    inductionOpB {_} {p} pv p1ol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv p1ol popol x1) (inductionOpB {_} {p} pv p1ol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpPointed1MagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 1OL2) -> (((x1 x2 : (OpPointed1MagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpPointed1MagmaTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 popol2 1OL2 = p1ol2 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p1ol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p1ol2 popol2 x2)) 
    1L' : Pointed1MagmaTerm
    1L'  = 1L 
    opL' : (Pointed1MagmaTerm -> (Pointed1MagmaTerm -> Pointed1MagmaTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (Pointed1MagmaTerm -> (Staged Pointed1MagmaTerm))
    stageB 1L = (Now 1L) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    1Cl' : {A : Set} -> (ClPointed1MagmaTerm A)
    1Cl'  = 1Cl 
    opCl' : {A : Set} -> ((ClPointed1MagmaTerm A) -> ((ClPointed1MagmaTerm A) -> (ClPointed1MagmaTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClPointed1MagmaTerm A) -> (Staged (ClPointed1MagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 1Cl = (Now 1Cl) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    1OL' : {n : Nat} -> (OpPointed1MagmaTerm n)
    1OL'  = 1OL 
    opOL' : {n : Nat} -> ((OpPointed1MagmaTerm n) -> ((OpPointed1MagmaTerm n) -> (OpPointed1MagmaTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpPointed1MagmaTerm n) -> (Staged (OpPointed1MagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 1OL = (Now 1OL) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    1OL2' : {n : Nat} {A : Set} -> (OpPointed1MagmaTerm2 n A)
    1OL2'  = 1OL2 
    opOL2' : {n : Nat} {A : Set} -> ((OpPointed1MagmaTerm2 n A) -> ((OpPointed1MagmaTerm2 n A) -> (OpPointed1MagmaTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpPointed1MagmaTerm2 n A) -> (Staged (OpPointed1MagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 1OL2 = (Now 1OL2) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        1T : (Repr A)
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module PointedInvolutiveMagma0Sig  where
    record PointedInvolutiveMagma0Sig (A : Set) : Set where
      constructor PointedInvolutiveMagma0SigC
      field
        * : (A -> (A -> A))
        prim : (A -> A)
        0 : A
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        primS : (AS -> AS)
        0S : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        primP : ((Prod A A) -> (Prod A A))
        0P : (Prod A A)
    record Hom {A1 : Set} {A2 : Set} (Po1 : (PointedInvolutiveMagma0Sig A1)) (Po2 : (PointedInvolutiveMagma0Sig A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Po1) x1 x2)) == ((* Po2) (hom x1) (hom x2))
        pres-prim : {x1 : A1} -> (hom ((prim Po1) x1)) == ((prim Po2) (hom x1))
        pres-0 : (hom (0 Po1)) == (0 Po2)
    record RelInterp {A1 : Set} {A2 : Set} (Po1 : (PointedInvolutiveMagma0Sig A1)) (Po2 : (PointedInvolutiveMagma0Sig A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Po1) x1 x2) ((* Po2) y1 y2))))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim Po1) x1) ((prim Po2) y1)))
        interp-0 : (interp (0 Po1) (0 Po2))
    data PointedInvolutiveMagma0SigTerm  : Set where
      *L : (PointedInvolutiveMagma0SigTerm -> (PointedInvolutiveMagma0SigTerm -> PointedInvolutiveMagma0SigTerm))
      primL : (PointedInvolutiveMagma0SigTerm -> PointedInvolutiveMagma0SigTerm)
      0L : PointedInvolutiveMagma0SigTerm
    data ClPointedInvolutiveMagma0SigTerm (A : Set) : Set where
      sing : (A -> (ClPointedInvolutiveMagma0SigTerm A))
      *Cl : ((ClPointedInvolutiveMagma0SigTerm A) -> ((ClPointedInvolutiveMagma0SigTerm A) -> (ClPointedInvolutiveMagma0SigTerm A)))
      primCl : ((ClPointedInvolutiveMagma0SigTerm A) -> (ClPointedInvolutiveMagma0SigTerm A))
      0Cl : (ClPointedInvolutiveMagma0SigTerm A)
    data OpPointedInvolutiveMagma0SigTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpPointedInvolutiveMagma0SigTerm n))
      *OL : ((OpPointedInvolutiveMagma0SigTerm n) -> ((OpPointedInvolutiveMagma0SigTerm n) -> (OpPointedInvolutiveMagma0SigTerm n)))
      primOL : ((OpPointedInvolutiveMagma0SigTerm n) -> (OpPointedInvolutiveMagma0SigTerm n))
      0OL : (OpPointedInvolutiveMagma0SigTerm n)
    data OpPointedInvolutiveMagma0SigTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpPointedInvolutiveMagma0SigTerm2 n A))
      sing2 : (A -> (OpPointedInvolutiveMagma0SigTerm2 n A))
      *OL2 : ((OpPointedInvolutiveMagma0SigTerm2 n A) -> ((OpPointedInvolutiveMagma0SigTerm2 n A) -> (OpPointedInvolutiveMagma0SigTerm2 n A)))
      primOL2 : ((OpPointedInvolutiveMagma0SigTerm2 n A) -> (OpPointedInvolutiveMagma0SigTerm2 n A))
      0OL2 : (OpPointedInvolutiveMagma0SigTerm2 n A)
    simplifyCl : {A : Set} -> ((ClPointedInvolutiveMagma0SigTerm A) -> (ClPointedInvolutiveMagma0SigTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl 0Cl = 0Cl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpPointedInvolutiveMagma0SigTerm n) -> (OpPointedInvolutiveMagma0SigTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB 0OL = 0OL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpPointedInvolutiveMagma0SigTerm2 n A) -> (OpPointedInvolutiveMagma0SigTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((PointedInvolutiveMagma0Sig A) -> (PointedInvolutiveMagma0SigTerm -> A))
    evalB Po (*L x1 x2) = ((* Po) (evalB Po x1) (evalB Po x2)) 
    evalB Po (primL x1) = ((prim Po) (evalB Po x1)) 
    evalB Po 0L = (0 Po) 
    evalCl : {A : Set} -> ((PointedInvolutiveMagma0Sig A) -> ((ClPointedInvolutiveMagma0SigTerm A) -> A))
    evalCl Po (sing x1) = x1 
    evalCl Po (*Cl x1 x2) = ((* Po) (evalCl Po x1) (evalCl Po x2)) 
    evalCl Po (primCl x1) = ((prim Po) (evalCl Po x1)) 
    evalCl Po 0Cl = (0 Po) 
    evalOpB : {A : Set} {n : Nat} -> ((PointedInvolutiveMagma0Sig A) -> ((Vec A n) -> ((OpPointedInvolutiveMagma0SigTerm n) -> A)))
    evalOpB Po vars (v x1) = (lookup _ x1 vars) 
    evalOpB Po vars (*OL x1 x2) = ((* Po) (evalOpB Po vars x1) (evalOpB Po vars x2)) 
    evalOpB Po vars (primOL x1) = ((prim Po) (evalOpB Po vars x1)) 
    evalOpB Po vars 0OL = (0 Po) 
    evalOp : {A : Set} {n : Nat} -> ((PointedInvolutiveMagma0Sig A) -> ((Vec A n) -> ((OpPointedInvolutiveMagma0SigTerm2 n A) -> A)))
    evalOp Po vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Po vars (sing2 x1) = x1 
    evalOp Po vars (*OL2 x1 x2) = ((* Po) (evalOp Po vars x1) (evalOp Po vars x2)) 
    evalOp Po vars (primOL2 x1) = ((prim Po) (evalOp Po vars x1)) 
    evalOp Po vars 0OL2 = (0 Po) 
    inductionB : {P : (PointedInvolutiveMagma0SigTerm -> Set)} -> (((x1 x2 : PointedInvolutiveMagma0SigTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 : PointedInvolutiveMagma0SigTerm) -> ((P x1) -> (P (primL x1)))) -> ((P 0L) -> ((x : PointedInvolutiveMagma0SigTerm) -> (P x)))))
    inductionB {p} p*l ppriml p0l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l ppriml p0l x1) (inductionB {p} p*l ppriml p0l x2)) 
    inductionB {p} p*l ppriml p0l (primL x1) = (ppriml _ (inductionB {p} p*l ppriml p0l x1)) 
    inductionB {p} p*l ppriml p0l 0L = p0l 
    inductionCl : {A : Set} {P : ((ClPointedInvolutiveMagma0SigTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClPointedInvolutiveMagma0SigTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 : (ClPointedInvolutiveMagma0SigTerm A)) -> ((P x1) -> (P (primCl x1)))) -> ((P 0Cl) -> ((x : (ClPointedInvolutiveMagma0SigTerm A)) -> (P x))))))
    inductionCl {_} {p} psing p*cl pprimcl p0cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl pprimcl p0cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl pprimcl p0cl x1) (inductionCl {_} {p} psing p*cl pprimcl p0cl x2)) 
    inductionCl {_} {p} psing p*cl pprimcl p0cl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing p*cl pprimcl p0cl x1)) 
    inductionCl {_} {p} psing p*cl pprimcl p0cl 0Cl = p0cl 
    inductionOpB : {n : Nat} {P : ((OpPointedInvolutiveMagma0SigTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpPointedInvolutiveMagma0SigTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 : (OpPointedInvolutiveMagma0SigTerm n)) -> ((P x1) -> (P (primOL x1)))) -> ((P 0OL) -> ((x : (OpPointedInvolutiveMagma0SigTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv p*ol pprimol p0ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol pprimol p0ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol pprimol p0ol x1) (inductionOpB {_} {p} pv p*ol pprimol p0ol x2)) 
    inductionOpB {_} {p} pv p*ol pprimol p0ol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv p*ol pprimol p0ol x1)) 
    inductionOpB {_} {p} pv p*ol pprimol p0ol 0OL = p0ol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpPointedInvolutiveMagma0SigTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpPointedInvolutiveMagma0SigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 : (OpPointedInvolutiveMagma0SigTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> ((P 0OL2) -> ((x : (OpPointedInvolutiveMagma0SigTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 pprimol2 p0ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 pprimol2 p0ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 pprimol2 p0ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 pprimol2 p0ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 pprimol2 p0ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 pprimol2 p0ol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 pprimol2 p0ol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 pprimol2 p0ol2 0OL2 = p0ol2 
    *L' : (PointedInvolutiveMagma0SigTerm -> (PointedInvolutiveMagma0SigTerm -> PointedInvolutiveMagma0SigTerm))
    *L' x1 x2 = (*L x1 x2) 
    primL' : (PointedInvolutiveMagma0SigTerm -> PointedInvolutiveMagma0SigTerm)
    primL' x1 = (primL x1) 
    0L' : PointedInvolutiveMagma0SigTerm
    0L'  = 0L 
    stageB : (PointedInvolutiveMagma0SigTerm -> (Staged PointedInvolutiveMagma0SigTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    stageB 0L = (Now 0L) 
    *Cl' : {A : Set} -> ((ClPointedInvolutiveMagma0SigTerm A) -> ((ClPointedInvolutiveMagma0SigTerm A) -> (ClPointedInvolutiveMagma0SigTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    primCl' : {A : Set} -> ((ClPointedInvolutiveMagma0SigTerm A) -> (ClPointedInvolutiveMagma0SigTerm A))
    primCl' x1 = (primCl x1) 
    0Cl' : {A : Set} -> (ClPointedInvolutiveMagma0SigTerm A)
    0Cl'  = 0Cl 
    stageCl : {A : Set} -> ((ClPointedInvolutiveMagma0SigTerm A) -> (Staged (ClPointedInvolutiveMagma0SigTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    stageCl 0Cl = (Now 0Cl) 
    *OL' : {n : Nat} -> ((OpPointedInvolutiveMagma0SigTerm n) -> ((OpPointedInvolutiveMagma0SigTerm n) -> (OpPointedInvolutiveMagma0SigTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    primOL' : {n : Nat} -> ((OpPointedInvolutiveMagma0SigTerm n) -> (OpPointedInvolutiveMagma0SigTerm n))
    primOL' x1 = (primOL x1) 
    0OL' : {n : Nat} -> (OpPointedInvolutiveMagma0SigTerm n)
    0OL'  = 0OL 
    stageOpB : {n : Nat} -> ((OpPointedInvolutiveMagma0SigTerm n) -> (Staged (OpPointedInvolutiveMagma0SigTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    stageOpB 0OL = (Now 0OL) 
    *OL2' : {n : Nat} {A : Set} -> ((OpPointedInvolutiveMagma0SigTerm2 n A) -> ((OpPointedInvolutiveMagma0SigTerm2 n A) -> (OpPointedInvolutiveMagma0SigTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    primOL2' : {n : Nat} {A : Set} -> ((OpPointedInvolutiveMagma0SigTerm2 n A) -> (OpPointedInvolutiveMagma0SigTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    0OL2' : {n : Nat} {A : Set} -> (OpPointedInvolutiveMagma0SigTerm2 n A)
    0OL2'  = 0OL2 
    stageOp : {n : Nat} {A : Set} -> ((OpPointedInvolutiveMagma0SigTerm2 n A) -> (Staged (OpPointedInvolutiveMagma0SigTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    stageOp 0OL2 = (Now 0OL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        primT : ((Repr A) -> (Repr A))
        0T : (Repr A)
  module PointedMagma  where
    record PointedMagma (A : Set) : Set where
      constructor PointedMagmaC
      field
        e : A
        op : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        eS : AS
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        eP : (Prod A A)
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
    record Hom {A1 : Set} {A2 : Set} (Po1 : (PointedMagma A1)) (Po2 : (PointedMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-e : (hom (e Po1)) == (e Po2)
        pres-op : {x1 x2 : A1} -> (hom ((op Po1) x1 x2)) == ((op Po2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Po1 : (PointedMagma A1)) (Po2 : (PointedMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-e : (interp (e Po1) (e Po2))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Po1) x1 x2) ((op Po2) y1 y2))))
    data PointedMagmaTerm  : Set where
      eL : PointedMagmaTerm
      opL : (PointedMagmaTerm -> (PointedMagmaTerm -> PointedMagmaTerm))
    data ClPointedMagmaTerm (A : Set) : Set where
      sing : (A -> (ClPointedMagmaTerm A))
      eCl : (ClPointedMagmaTerm A)
      opCl : ((ClPointedMagmaTerm A) -> ((ClPointedMagmaTerm A) -> (ClPointedMagmaTerm A)))
    data OpPointedMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpPointedMagmaTerm n))
      eOL : (OpPointedMagmaTerm n)
      opOL : ((OpPointedMagmaTerm n) -> ((OpPointedMagmaTerm n) -> (OpPointedMagmaTerm n)))
    data OpPointedMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpPointedMagmaTerm2 n A))
      sing2 : (A -> (OpPointedMagmaTerm2 n A))
      eOL2 : (OpPointedMagmaTerm2 n A)
      opOL2 : ((OpPointedMagmaTerm2 n A) -> ((OpPointedMagmaTerm2 n A) -> (OpPointedMagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClPointedMagmaTerm A) -> (ClPointedMagmaTerm A))
    simplifyCl eCl = eCl 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpPointedMagmaTerm n) -> (OpPointedMagmaTerm n))
    simplifyOpB eOL = eOL 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpPointedMagmaTerm2 n A) -> (OpPointedMagmaTerm2 n A))
    simplifyOp eOL2 = eOL2 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((PointedMagma A) -> (PointedMagmaTerm -> A))
    evalB Po eL = (e Po) 
    evalB Po (opL x1 x2) = ((op Po) (evalB Po x1) (evalB Po x2)) 
    evalCl : {A : Set} -> ((PointedMagma A) -> ((ClPointedMagmaTerm A) -> A))
    evalCl Po (sing x1) = x1 
    evalCl Po eCl = (e Po) 
    evalCl Po (opCl x1 x2) = ((op Po) (evalCl Po x1) (evalCl Po x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((PointedMagma A) -> ((Vec A n) -> ((OpPointedMagmaTerm n) -> A)))
    evalOpB Po vars (v x1) = (lookup _ x1 vars) 
    evalOpB Po vars eOL = (e Po) 
    evalOpB Po vars (opOL x1 x2) = ((op Po) (evalOpB Po vars x1) (evalOpB Po vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((PointedMagma A) -> ((Vec A n) -> ((OpPointedMagmaTerm2 n A) -> A)))
    evalOp Po vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Po vars (sing2 x1) = x1 
    evalOp Po vars eOL2 = (e Po) 
    evalOp Po vars (opOL2 x1 x2) = ((op Po) (evalOp Po vars x1) (evalOp Po vars x2)) 
    inductionB : {P : (PointedMagmaTerm -> Set)} -> ((P eL) -> (((x1 x2 : PointedMagmaTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : PointedMagmaTerm) -> (P x))))
    inductionB {p} pel popl eL = pel 
    inductionB {p} pel popl (opL x1 x2) = (popl _ _ (inductionB {p} pel popl x1) (inductionB {p} pel popl x2)) 
    inductionCl : {A : Set} {P : ((ClPointedMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P eCl) -> (((x1 x2 : (ClPointedMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClPointedMagmaTerm A)) -> (P x)))))
    inductionCl {_} {p} psing pecl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pecl popcl eCl = pecl 
    inductionCl {_} {p} psing pecl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing pecl popcl x1) (inductionCl {_} {p} psing pecl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpPointedMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P eOL) -> (((x1 x2 : (OpPointedMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpPointedMagmaTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv peol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv peol popol eOL = peol 
    inductionOpB {_} {p} pv peol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv peol popol x1) (inductionOpB {_} {p} pv peol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpPointedMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P eOL2) -> (((x1 x2 : (OpPointedMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpPointedMagmaTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 eOL2 = peol2 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 x2)) 
    eL' : PointedMagmaTerm
    eL'  = eL 
    opL' : (PointedMagmaTerm -> (PointedMagmaTerm -> PointedMagmaTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (PointedMagmaTerm -> (Staged PointedMagmaTerm))
    stageB eL = (Now eL) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    eCl' : {A : Set} -> (ClPointedMagmaTerm A)
    eCl'  = eCl 
    opCl' : {A : Set} -> ((ClPointedMagmaTerm A) -> ((ClPointedMagmaTerm A) -> (ClPointedMagmaTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClPointedMagmaTerm A) -> (Staged (ClPointedMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl eCl = (Now eCl) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    eOL' : {n : Nat} -> (OpPointedMagmaTerm n)
    eOL'  = eOL 
    opOL' : {n : Nat} -> ((OpPointedMagmaTerm n) -> ((OpPointedMagmaTerm n) -> (OpPointedMagmaTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpPointedMagmaTerm n) -> (Staged (OpPointedMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB eOL = (Now eOL) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    eOL2' : {n : Nat} {A : Set} -> (OpPointedMagmaTerm2 n A)
    eOL2'  = eOL2 
    opOL2' : {n : Nat} {A : Set} -> ((OpPointedMagmaTerm2 n A) -> ((OpPointedMagmaTerm2 n A) -> (OpPointedMagmaTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpPointedMagmaTerm2 n A) -> (Staged (OpPointedMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp eOL2 = (Now eOL2) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        eT : (Repr A)
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module PointedOne  where
    record PointedOne (A : Set) : Set where
      constructor PointedOneC
      field
        1 : A
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        1S : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        1P : (Prod A A)
    record Hom {A1 : Set} {A2 : Set} (Po1 : (PointedOne A1)) (Po2 : (PointedOne A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-1 : (hom (1 Po1)) == (1 Po2)
    record RelInterp {A1 : Set} {A2 : Set} (Po1 : (PointedOne A1)) (Po2 : (PointedOne A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-1 : (interp (1 Po1) (1 Po2))
    data PointedOneTerm  : Set where
      1L : PointedOneTerm
    data ClPointedOneTerm (A : Set) : Set where
      sing : (A -> (ClPointedOneTerm A))
      1Cl : (ClPointedOneTerm A)
    data OpPointedOneTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpPointedOneTerm n))
      1OL : (OpPointedOneTerm n)
    data OpPointedOneTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpPointedOneTerm2 n A))
      sing2 : (A -> (OpPointedOneTerm2 n A))
      1OL2 : (OpPointedOneTerm2 n A)
    simplifyCl : {A : Set} -> ((ClPointedOneTerm A) -> (ClPointedOneTerm A))
    simplifyCl 1Cl = 1Cl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpPointedOneTerm n) -> (OpPointedOneTerm n))
    simplifyOpB 1OL = 1OL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpPointedOneTerm2 n A) -> (OpPointedOneTerm2 n A))
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((PointedOne A) -> (PointedOneTerm -> A))
    evalB Po 1L = (1 Po) 
    evalCl : {A : Set} -> ((PointedOne A) -> ((ClPointedOneTerm A) -> A))
    evalCl Po (sing x1) = x1 
    evalCl Po 1Cl = (1 Po) 
    evalOpB : {A : Set} {n : Nat} -> ((PointedOne A) -> ((Vec A n) -> ((OpPointedOneTerm n) -> A)))
    evalOpB Po vars (v x1) = (lookup _ x1 vars) 
    evalOpB Po vars 1OL = (1 Po) 
    evalOp : {A : Set} {n : Nat} -> ((PointedOne A) -> ((Vec A n) -> ((OpPointedOneTerm2 n A) -> A)))
    evalOp Po vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Po vars (sing2 x1) = x1 
    evalOp Po vars 1OL2 = (1 Po) 
    inductionB : {P : (PointedOneTerm -> Set)} -> ((P 1L) -> ((x : PointedOneTerm) -> (P x)))
    inductionB {p} p1l 1L = p1l 
    inductionCl : {A : Set} {P : ((ClPointedOneTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 1Cl) -> ((x : (ClPointedOneTerm A)) -> (P x))))
    inductionCl {_} {p} psing p1cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p1cl 1Cl = p1cl 
    inductionOpB : {n : Nat} {P : ((OpPointedOneTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 1OL) -> ((x : (OpPointedOneTerm n)) -> (P x))))
    inductionOpB {_} {p} pv p1ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p1ol 1OL = p1ol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpPointedOneTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 1OL2) -> ((x : (OpPointedOneTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p1ol2 1OL2 = p1ol2 
    1L' : PointedOneTerm
    1L'  = 1L 
    stageB : (PointedOneTerm -> (Staged PointedOneTerm))
    stageB 1L = (Now 1L) 
    1Cl' : {A : Set} -> (ClPointedOneTerm A)
    1Cl'  = 1Cl 
    stageCl : {A : Set} -> ((ClPointedOneTerm A) -> (Staged (ClPointedOneTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 1Cl = (Now 1Cl) 
    1OL' : {n : Nat} -> (OpPointedOneTerm n)
    1OL'  = 1OL 
    stageOpB : {n : Nat} -> ((OpPointedOneTerm n) -> (Staged (OpPointedOneTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 1OL = (Now 1OL) 
    1OL2' : {n : Nat} {A : Set} -> (OpPointedOneTerm2 n A)
    1OL2'  = 1OL2 
    stageOp : {n : Nat} {A : Set} -> ((OpPointedOneTerm2 n A) -> (Staged (OpPointedOneTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 1OL2 = (Now 1OL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        1T : (Repr A)
  module PointedPlusMagma  where
    record PointedPlusMagma (A : Set) : Set where
      constructor PointedPlusMagmaC
      field
        + : (A -> (A -> A))
        e : A
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        +S : (AS -> (AS -> AS))
        eS : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        eP : (Prod A A)
    record Hom {A1 : Set} {A2 : Set} (Po1 : (PointedPlusMagma A1)) (Po2 : (PointedPlusMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Po1) x1 x2)) == ((+ Po2) (hom x1) (hom x2))
        pres-e : (hom (e Po1)) == (e Po2)
    record RelInterp {A1 : Set} {A2 : Set} (Po1 : (PointedPlusMagma A1)) (Po2 : (PointedPlusMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Po1) x1 x2) ((+ Po2) y1 y2))))
        interp-e : (interp (e Po1) (e Po2))
    data PointedPlusMagmaTerm  : Set where
      +L : (PointedPlusMagmaTerm -> (PointedPlusMagmaTerm -> PointedPlusMagmaTerm))
      eL : PointedPlusMagmaTerm
    data ClPointedPlusMagmaTerm (A : Set) : Set where
      sing : (A -> (ClPointedPlusMagmaTerm A))
      +Cl : ((ClPointedPlusMagmaTerm A) -> ((ClPointedPlusMagmaTerm A) -> (ClPointedPlusMagmaTerm A)))
      eCl : (ClPointedPlusMagmaTerm A)
    data OpPointedPlusMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpPointedPlusMagmaTerm n))
      +OL : ((OpPointedPlusMagmaTerm n) -> ((OpPointedPlusMagmaTerm n) -> (OpPointedPlusMagmaTerm n)))
      eOL : (OpPointedPlusMagmaTerm n)
    data OpPointedPlusMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpPointedPlusMagmaTerm2 n A))
      sing2 : (A -> (OpPointedPlusMagmaTerm2 n A))
      +OL2 : ((OpPointedPlusMagmaTerm2 n A) -> ((OpPointedPlusMagmaTerm2 n A) -> (OpPointedPlusMagmaTerm2 n A)))
      eOL2 : (OpPointedPlusMagmaTerm2 n A)
    simplifyCl : {A : Set} -> ((ClPointedPlusMagmaTerm A) -> (ClPointedPlusMagmaTerm A))
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl eCl = eCl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpPointedPlusMagmaTerm n) -> (OpPointedPlusMagmaTerm n))
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB eOL = eOL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpPointedPlusMagmaTerm2 n A) -> (OpPointedPlusMagmaTerm2 n A))
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp eOL2 = eOL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((PointedPlusMagma A) -> (PointedPlusMagmaTerm -> A))
    evalB Po (+L x1 x2) = ((+ Po) (evalB Po x1) (evalB Po x2)) 
    evalB Po eL = (e Po) 
    evalCl : {A : Set} -> ((PointedPlusMagma A) -> ((ClPointedPlusMagmaTerm A) -> A))
    evalCl Po (sing x1) = x1 
    evalCl Po (+Cl x1 x2) = ((+ Po) (evalCl Po x1) (evalCl Po x2)) 
    evalCl Po eCl = (e Po) 
    evalOpB : {A : Set} {n : Nat} -> ((PointedPlusMagma A) -> ((Vec A n) -> ((OpPointedPlusMagmaTerm n) -> A)))
    evalOpB Po vars (v x1) = (lookup _ x1 vars) 
    evalOpB Po vars (+OL x1 x2) = ((+ Po) (evalOpB Po vars x1) (evalOpB Po vars x2)) 
    evalOpB Po vars eOL = (e Po) 
    evalOp : {A : Set} {n : Nat} -> ((PointedPlusMagma A) -> ((Vec A n) -> ((OpPointedPlusMagmaTerm2 n A) -> A)))
    evalOp Po vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Po vars (sing2 x1) = x1 
    evalOp Po vars (+OL2 x1 x2) = ((+ Po) (evalOp Po vars x1) (evalOp Po vars x2)) 
    evalOp Po vars eOL2 = (e Po) 
    inductionB : {P : (PointedPlusMagmaTerm -> Set)} -> (((x1 x2 : PointedPlusMagmaTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((P eL) -> ((x : PointedPlusMagmaTerm) -> (P x))))
    inductionB {p} p+l pel (+L x1 x2) = (p+l _ _ (inductionB {p} p+l pel x1) (inductionB {p} p+l pel x2)) 
    inductionB {p} p+l pel eL = pel 
    inductionCl : {A : Set} {P : ((ClPointedPlusMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClPointedPlusMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((P eCl) -> ((x : (ClPointedPlusMagmaTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p+cl pecl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p+cl pecl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p+cl pecl x1) (inductionCl {_} {p} psing p+cl pecl x2)) 
    inductionCl {_} {p} psing p+cl pecl eCl = pecl 
    inductionOpB : {n : Nat} {P : ((OpPointedPlusMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpPointedPlusMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((P eOL) -> ((x : (OpPointedPlusMagmaTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p+ol peol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p+ol peol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p+ol peol x1) (inductionOpB {_} {p} pv p+ol peol x2)) 
    inductionOpB {_} {p} pv p+ol peol eOL = peol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpPointedPlusMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpPointedPlusMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((P eOL2) -> ((x : (OpPointedPlusMagmaTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 peol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 peol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 peol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 peol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 peol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 peol2 eOL2 = peol2 
    +L' : (PointedPlusMagmaTerm -> (PointedPlusMagmaTerm -> PointedPlusMagmaTerm))
    +L' x1 x2 = (+L x1 x2) 
    eL' : PointedPlusMagmaTerm
    eL'  = eL 
    stageB : (PointedPlusMagmaTerm -> (Staged PointedPlusMagmaTerm))
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB eL = (Now eL) 
    +Cl' : {A : Set} -> ((ClPointedPlusMagmaTerm A) -> ((ClPointedPlusMagmaTerm A) -> (ClPointedPlusMagmaTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    eCl' : {A : Set} -> (ClPointedPlusMagmaTerm A)
    eCl'  = eCl 
    stageCl : {A : Set} -> ((ClPointedPlusMagmaTerm A) -> (Staged (ClPointedPlusMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl eCl = (Now eCl) 
    +OL' : {n : Nat} -> ((OpPointedPlusMagmaTerm n) -> ((OpPointedPlusMagmaTerm n) -> (OpPointedPlusMagmaTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    eOL' : {n : Nat} -> (OpPointedPlusMagmaTerm n)
    eOL'  = eOL 
    stageOpB : {n : Nat} -> ((OpPointedPlusMagmaTerm n) -> (Staged (OpPointedPlusMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB eOL = (Now eOL) 
    +OL2' : {n : Nat} {A : Set} -> ((OpPointedPlusMagmaTerm2 n A) -> ((OpPointedPlusMagmaTerm2 n A) -> (OpPointedPlusMagmaTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    eOL2' : {n : Nat} {A : Set} -> (OpPointedPlusMagmaTerm2 n A)
    eOL2'  = eOL2 
    stageOp : {n : Nat} {A : Set} -> ((OpPointedPlusMagmaTerm2 n A) -> (Staged (OpPointedPlusMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp eOL2 = (Now eOL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        eT : (Repr A)
  module PointedSemigroup  where
    record PointedSemigroup (A : Set) : Set where
      constructor PointedSemigroupC
      field
        op : (A -> (A -> A))
        associative_op : {x y z : A} -> (op (op x y) z) == (op x (op y z))
        e : A
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        eS : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        eP : (Prod A A)
        associative_opP : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP (opP yP zP))
    record Hom {A1 : Set} {A2 : Set} (Po1 : (PointedSemigroup A1)) (Po2 : (PointedSemigroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Po1) x1 x2)) == ((op Po2) (hom x1) (hom x2))
        pres-e : (hom (e Po1)) == (e Po2)
    record RelInterp {A1 : Set} {A2 : Set} (Po1 : (PointedSemigroup A1)) (Po2 : (PointedSemigroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Po1) x1 x2) ((op Po2) y1 y2))))
        interp-e : (interp (e Po1) (e Po2))
    data PointedSemigroupTerm  : Set where
      opL : (PointedSemigroupTerm -> (PointedSemigroupTerm -> PointedSemigroupTerm))
      eL : PointedSemigroupTerm
    data ClPointedSemigroupTerm (A : Set) : Set where
      sing : (A -> (ClPointedSemigroupTerm A))
      opCl : ((ClPointedSemigroupTerm A) -> ((ClPointedSemigroupTerm A) -> (ClPointedSemigroupTerm A)))
      eCl : (ClPointedSemigroupTerm A)
    data OpPointedSemigroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpPointedSemigroupTerm n))
      opOL : ((OpPointedSemigroupTerm n) -> ((OpPointedSemigroupTerm n) -> (OpPointedSemigroupTerm n)))
      eOL : (OpPointedSemigroupTerm n)
    data OpPointedSemigroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpPointedSemigroupTerm2 n A))
      sing2 : (A -> (OpPointedSemigroupTerm2 n A))
      opOL2 : ((OpPointedSemigroupTerm2 n A) -> ((OpPointedSemigroupTerm2 n A) -> (OpPointedSemigroupTerm2 n A)))
      eOL2 : (OpPointedSemigroupTerm2 n A)
    simplifyCl : {A : Set} -> ((ClPointedSemigroupTerm A) -> (ClPointedSemigroupTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl eCl = eCl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpPointedSemigroupTerm n) -> (OpPointedSemigroupTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB eOL = eOL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpPointedSemigroupTerm2 n A) -> (OpPointedSemigroupTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp eOL2 = eOL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((PointedSemigroup A) -> (PointedSemigroupTerm -> A))
    evalB Po (opL x1 x2) = ((op Po) (evalB Po x1) (evalB Po x2)) 
    evalB Po eL = (e Po) 
    evalCl : {A : Set} -> ((PointedSemigroup A) -> ((ClPointedSemigroupTerm A) -> A))
    evalCl Po (sing x1) = x1 
    evalCl Po (opCl x1 x2) = ((op Po) (evalCl Po x1) (evalCl Po x2)) 
    evalCl Po eCl = (e Po) 
    evalOpB : {A : Set} {n : Nat} -> ((PointedSemigroup A) -> ((Vec A n) -> ((OpPointedSemigroupTerm n) -> A)))
    evalOpB Po vars (v x1) = (lookup _ x1 vars) 
    evalOpB Po vars (opOL x1 x2) = ((op Po) (evalOpB Po vars x1) (evalOpB Po vars x2)) 
    evalOpB Po vars eOL = (e Po) 
    evalOp : {A : Set} {n : Nat} -> ((PointedSemigroup A) -> ((Vec A n) -> ((OpPointedSemigroupTerm2 n A) -> A)))
    evalOp Po vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Po vars (sing2 x1) = x1 
    evalOp Po vars (opOL2 x1 x2) = ((op Po) (evalOp Po vars x1) (evalOp Po vars x2)) 
    evalOp Po vars eOL2 = (e Po) 
    inductionB : {P : (PointedSemigroupTerm -> Set)} -> (((x1 x2 : PointedSemigroupTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((P eL) -> ((x : PointedSemigroupTerm) -> (P x))))
    inductionB {p} popl pel (opL x1 x2) = (popl _ _ (inductionB {p} popl pel x1) (inductionB {p} popl pel x2)) 
    inductionB {p} popl pel eL = pel 
    inductionCl : {A : Set} {P : ((ClPointedSemigroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClPointedSemigroupTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((P eCl) -> ((x : (ClPointedSemigroupTerm A)) -> (P x)))))
    inductionCl {_} {p} psing popcl pecl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl pecl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl pecl x1) (inductionCl {_} {p} psing popcl pecl x2)) 
    inductionCl {_} {p} psing popcl pecl eCl = pecl 
    inductionOpB : {n : Nat} {P : ((OpPointedSemigroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpPointedSemigroupTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((P eOL) -> ((x : (OpPointedSemigroupTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv popol peol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol peol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol peol x1) (inductionOpB {_} {p} pv popol peol x2)) 
    inductionOpB {_} {p} pv popol peol eOL = peol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpPointedSemigroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpPointedSemigroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((P eOL2) -> ((x : (OpPointedSemigroupTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 eOL2 = peol2 
    opL' : (PointedSemigroupTerm -> (PointedSemigroupTerm -> PointedSemigroupTerm))
    opL' x1 x2 = (opL x1 x2) 
    eL' : PointedSemigroupTerm
    eL'  = eL 
    stageB : (PointedSemigroupTerm -> (Staged PointedSemigroupTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB eL = (Now eL) 
    opCl' : {A : Set} -> ((ClPointedSemigroupTerm A) -> ((ClPointedSemigroupTerm A) -> (ClPointedSemigroupTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    eCl' : {A : Set} -> (ClPointedSemigroupTerm A)
    eCl'  = eCl 
    stageCl : {A : Set} -> ((ClPointedSemigroupTerm A) -> (Staged (ClPointedSemigroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl eCl = (Now eCl) 
    opOL' : {n : Nat} -> ((OpPointedSemigroupTerm n) -> ((OpPointedSemigroupTerm n) -> (OpPointedSemigroupTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    eOL' : {n : Nat} -> (OpPointedSemigroupTerm n)
    eOL'  = eOL 
    stageOpB : {n : Nat} -> ((OpPointedSemigroupTerm n) -> (Staged (OpPointedSemigroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB eOL = (Now eOL) 
    opOL2' : {n : Nat} {A : Set} -> ((OpPointedSemigroupTerm2 n A) -> ((OpPointedSemigroupTerm2 n A) -> (OpPointedSemigroupTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    eOL2' : {n : Nat} {A : Set} -> (OpPointedSemigroupTerm2 n A)
    eOL2'  = eOL2 
    stageOp : {n : Nat} {A : Set} -> ((OpPointedSemigroupTerm2 n A) -> (Staged (OpPointedSemigroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp eOL2 = (Now eOL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        eT : (Repr A)
  module PointedSteinerMagma  where
    record PointedSteinerMagma (A : Set) : Set where
      constructor PointedSteinerMagmaC
      field
        op : (A -> (A -> A))
        e : A
        commutative_op : {x y : A} -> (op x y) == (op y x)
        antiAbsorbent : {x y : A} -> (op x (op x y)) == y
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        eS : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        eP : (Prod A A)
        commutative_opP : {xP yP : (Prod A A)} -> (opP xP yP) == (opP yP xP)
        antiAbsorbentP : {xP yP : (Prod A A)} -> (opP xP (opP xP yP)) == yP
    record Hom {A1 : Set} {A2 : Set} (Po1 : (PointedSteinerMagma A1)) (Po2 : (PointedSteinerMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Po1) x1 x2)) == ((op Po2) (hom x1) (hom x2))
        pres-e : (hom (e Po1)) == (e Po2)
    record RelInterp {A1 : Set} {A2 : Set} (Po1 : (PointedSteinerMagma A1)) (Po2 : (PointedSteinerMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Po1) x1 x2) ((op Po2) y1 y2))))
        interp-e : (interp (e Po1) (e Po2))
    data PointedSteinerMagmaTerm  : Set where
      opL : (PointedSteinerMagmaTerm -> (PointedSteinerMagmaTerm -> PointedSteinerMagmaTerm))
      eL : PointedSteinerMagmaTerm
    data ClPointedSteinerMagmaTerm (A : Set) : Set where
      sing : (A -> (ClPointedSteinerMagmaTerm A))
      opCl : ((ClPointedSteinerMagmaTerm A) -> ((ClPointedSteinerMagmaTerm A) -> (ClPointedSteinerMagmaTerm A)))
      eCl : (ClPointedSteinerMagmaTerm A)
    data OpPointedSteinerMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpPointedSteinerMagmaTerm n))
      opOL : ((OpPointedSteinerMagmaTerm n) -> ((OpPointedSteinerMagmaTerm n) -> (OpPointedSteinerMagmaTerm n)))
      eOL : (OpPointedSteinerMagmaTerm n)
    data OpPointedSteinerMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpPointedSteinerMagmaTerm2 n A))
      sing2 : (A -> (OpPointedSteinerMagmaTerm2 n A))
      opOL2 : ((OpPointedSteinerMagmaTerm2 n A) -> ((OpPointedSteinerMagmaTerm2 n A) -> (OpPointedSteinerMagmaTerm2 n A)))
      eOL2 : (OpPointedSteinerMagmaTerm2 n A)
    simplifyCl : {A : Set} -> ((ClPointedSteinerMagmaTerm A) -> (ClPointedSteinerMagmaTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl eCl = eCl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpPointedSteinerMagmaTerm n) -> (OpPointedSteinerMagmaTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB eOL = eOL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpPointedSteinerMagmaTerm2 n A) -> (OpPointedSteinerMagmaTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp eOL2 = eOL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((PointedSteinerMagma A) -> (PointedSteinerMagmaTerm -> A))
    evalB Po (opL x1 x2) = ((op Po) (evalB Po x1) (evalB Po x2)) 
    evalB Po eL = (e Po) 
    evalCl : {A : Set} -> ((PointedSteinerMagma A) -> ((ClPointedSteinerMagmaTerm A) -> A))
    evalCl Po (sing x1) = x1 
    evalCl Po (opCl x1 x2) = ((op Po) (evalCl Po x1) (evalCl Po x2)) 
    evalCl Po eCl = (e Po) 
    evalOpB : {A : Set} {n : Nat} -> ((PointedSteinerMagma A) -> ((Vec A n) -> ((OpPointedSteinerMagmaTerm n) -> A)))
    evalOpB Po vars (v x1) = (lookup _ x1 vars) 
    evalOpB Po vars (opOL x1 x2) = ((op Po) (evalOpB Po vars x1) (evalOpB Po vars x2)) 
    evalOpB Po vars eOL = (e Po) 
    evalOp : {A : Set} {n : Nat} -> ((PointedSteinerMagma A) -> ((Vec A n) -> ((OpPointedSteinerMagmaTerm2 n A) -> A)))
    evalOp Po vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Po vars (sing2 x1) = x1 
    evalOp Po vars (opOL2 x1 x2) = ((op Po) (evalOp Po vars x1) (evalOp Po vars x2)) 
    evalOp Po vars eOL2 = (e Po) 
    inductionB : {P : (PointedSteinerMagmaTerm -> Set)} -> (((x1 x2 : PointedSteinerMagmaTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((P eL) -> ((x : PointedSteinerMagmaTerm) -> (P x))))
    inductionB {p} popl pel (opL x1 x2) = (popl _ _ (inductionB {p} popl pel x1) (inductionB {p} popl pel x2)) 
    inductionB {p} popl pel eL = pel 
    inductionCl : {A : Set} {P : ((ClPointedSteinerMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClPointedSteinerMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((P eCl) -> ((x : (ClPointedSteinerMagmaTerm A)) -> (P x)))))
    inductionCl {_} {p} psing popcl pecl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl pecl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl pecl x1) (inductionCl {_} {p} psing popcl pecl x2)) 
    inductionCl {_} {p} psing popcl pecl eCl = pecl 
    inductionOpB : {n : Nat} {P : ((OpPointedSteinerMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpPointedSteinerMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((P eOL) -> ((x : (OpPointedSteinerMagmaTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv popol peol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol peol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol peol x1) (inductionOpB {_} {p} pv popol peol x2)) 
    inductionOpB {_} {p} pv popol peol eOL = peol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpPointedSteinerMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpPointedSteinerMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((P eOL2) -> ((x : (OpPointedSteinerMagmaTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 eOL2 = peol2 
    opL' : (PointedSteinerMagmaTerm -> (PointedSteinerMagmaTerm -> PointedSteinerMagmaTerm))
    opL' x1 x2 = (opL x1 x2) 
    eL' : PointedSteinerMagmaTerm
    eL'  = eL 
    stageB : (PointedSteinerMagmaTerm -> (Staged PointedSteinerMagmaTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB eL = (Now eL) 
    opCl' : {A : Set} -> ((ClPointedSteinerMagmaTerm A) -> ((ClPointedSteinerMagmaTerm A) -> (ClPointedSteinerMagmaTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    eCl' : {A : Set} -> (ClPointedSteinerMagmaTerm A)
    eCl'  = eCl 
    stageCl : {A : Set} -> ((ClPointedSteinerMagmaTerm A) -> (Staged (ClPointedSteinerMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl eCl = (Now eCl) 
    opOL' : {n : Nat} -> ((OpPointedSteinerMagmaTerm n) -> ((OpPointedSteinerMagmaTerm n) -> (OpPointedSteinerMagmaTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    eOL' : {n : Nat} -> (OpPointedSteinerMagmaTerm n)
    eOL'  = eOL 
    stageOpB : {n : Nat} -> ((OpPointedSteinerMagmaTerm n) -> (Staged (OpPointedSteinerMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB eOL = (Now eOL) 
    opOL2' : {n : Nat} {A : Set} -> ((OpPointedSteinerMagmaTerm2 n A) -> ((OpPointedSteinerMagmaTerm2 n A) -> (OpPointedSteinerMagmaTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    eOL2' : {n : Nat} {A : Set} -> (OpPointedSteinerMagmaTerm2 n A)
    eOL2'  = eOL2 
    stageOp : {n : Nat} {A : Set} -> ((OpPointedSteinerMagmaTerm2 n A) -> (Staged (OpPointedSteinerMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp eOL2 = (Now eOL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        eT : (Repr A)
  module PointedTimesMagma  where
    record PointedTimesMagma (A : Set) : Set where
      constructor PointedTimesMagmaC
      field
        * : (A -> (A -> A))
        e : A
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        eS : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        eP : (Prod A A)
    record Hom {A1 : Set} {A2 : Set} (Po1 : (PointedTimesMagma A1)) (Po2 : (PointedTimesMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Po1) x1 x2)) == ((* Po2) (hom x1) (hom x2))
        pres-e : (hom (e Po1)) == (e Po2)
    record RelInterp {A1 : Set} {A2 : Set} (Po1 : (PointedTimesMagma A1)) (Po2 : (PointedTimesMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Po1) x1 x2) ((* Po2) y1 y2))))
        interp-e : (interp (e Po1) (e Po2))
    data PointedTimesMagmaTerm  : Set where
      *L : (PointedTimesMagmaTerm -> (PointedTimesMagmaTerm -> PointedTimesMagmaTerm))
      eL : PointedTimesMagmaTerm
    data ClPointedTimesMagmaTerm (A : Set) : Set where
      sing : (A -> (ClPointedTimesMagmaTerm A))
      *Cl : ((ClPointedTimesMagmaTerm A) -> ((ClPointedTimesMagmaTerm A) -> (ClPointedTimesMagmaTerm A)))
      eCl : (ClPointedTimesMagmaTerm A)
    data OpPointedTimesMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpPointedTimesMagmaTerm n))
      *OL : ((OpPointedTimesMagmaTerm n) -> ((OpPointedTimesMagmaTerm n) -> (OpPointedTimesMagmaTerm n)))
      eOL : (OpPointedTimesMagmaTerm n)
    data OpPointedTimesMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpPointedTimesMagmaTerm2 n A))
      sing2 : (A -> (OpPointedTimesMagmaTerm2 n A))
      *OL2 : ((OpPointedTimesMagmaTerm2 n A) -> ((OpPointedTimesMagmaTerm2 n A) -> (OpPointedTimesMagmaTerm2 n A)))
      eOL2 : (OpPointedTimesMagmaTerm2 n A)
    simplifyCl : {A : Set} -> ((ClPointedTimesMagmaTerm A) -> (ClPointedTimesMagmaTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl eCl = eCl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpPointedTimesMagmaTerm n) -> (OpPointedTimesMagmaTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB eOL = eOL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpPointedTimesMagmaTerm2 n A) -> (OpPointedTimesMagmaTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp eOL2 = eOL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((PointedTimesMagma A) -> (PointedTimesMagmaTerm -> A))
    evalB Po (*L x1 x2) = ((* Po) (evalB Po x1) (evalB Po x2)) 
    evalB Po eL = (e Po) 
    evalCl : {A : Set} -> ((PointedTimesMagma A) -> ((ClPointedTimesMagmaTerm A) -> A))
    evalCl Po (sing x1) = x1 
    evalCl Po (*Cl x1 x2) = ((* Po) (evalCl Po x1) (evalCl Po x2)) 
    evalCl Po eCl = (e Po) 
    evalOpB : {A : Set} {n : Nat} -> ((PointedTimesMagma A) -> ((Vec A n) -> ((OpPointedTimesMagmaTerm n) -> A)))
    evalOpB Po vars (v x1) = (lookup _ x1 vars) 
    evalOpB Po vars (*OL x1 x2) = ((* Po) (evalOpB Po vars x1) (evalOpB Po vars x2)) 
    evalOpB Po vars eOL = (e Po) 
    evalOp : {A : Set} {n : Nat} -> ((PointedTimesMagma A) -> ((Vec A n) -> ((OpPointedTimesMagmaTerm2 n A) -> A)))
    evalOp Po vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Po vars (sing2 x1) = x1 
    evalOp Po vars (*OL2 x1 x2) = ((* Po) (evalOp Po vars x1) (evalOp Po vars x2)) 
    evalOp Po vars eOL2 = (e Po) 
    inductionB : {P : (PointedTimesMagmaTerm -> Set)} -> (((x1 x2 : PointedTimesMagmaTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((P eL) -> ((x : PointedTimesMagmaTerm) -> (P x))))
    inductionB {p} p*l pel (*L x1 x2) = (p*l _ _ (inductionB {p} p*l pel x1) (inductionB {p} p*l pel x2)) 
    inductionB {p} p*l pel eL = pel 
    inductionCl : {A : Set} {P : ((ClPointedTimesMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClPointedTimesMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((P eCl) -> ((x : (ClPointedTimesMagmaTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p*cl pecl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl pecl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl pecl x1) (inductionCl {_} {p} psing p*cl pecl x2)) 
    inductionCl {_} {p} psing p*cl pecl eCl = pecl 
    inductionOpB : {n : Nat} {P : ((OpPointedTimesMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpPointedTimesMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((P eOL) -> ((x : (OpPointedTimesMagmaTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p*ol peol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol peol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol peol x1) (inductionOpB {_} {p} pv p*ol peol x2)) 
    inductionOpB {_} {p} pv p*ol peol eOL = peol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpPointedTimesMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpPointedTimesMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((P eOL2) -> ((x : (OpPointedTimesMagmaTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 peol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 peol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 peol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 peol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 peol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 peol2 eOL2 = peol2 
    *L' : (PointedTimesMagmaTerm -> (PointedTimesMagmaTerm -> PointedTimesMagmaTerm))
    *L' x1 x2 = (*L x1 x2) 
    eL' : PointedTimesMagmaTerm
    eL'  = eL 
    stageB : (PointedTimesMagmaTerm -> (Staged PointedTimesMagmaTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB eL = (Now eL) 
    *Cl' : {A : Set} -> ((ClPointedTimesMagmaTerm A) -> ((ClPointedTimesMagmaTerm A) -> (ClPointedTimesMagmaTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    eCl' : {A : Set} -> (ClPointedTimesMagmaTerm A)
    eCl'  = eCl 
    stageCl : {A : Set} -> ((ClPointedTimesMagmaTerm A) -> (Staged (ClPointedTimesMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl eCl = (Now eCl) 
    *OL' : {n : Nat} -> ((OpPointedTimesMagmaTerm n) -> ((OpPointedTimesMagmaTerm n) -> (OpPointedTimesMagmaTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    eOL' : {n : Nat} -> (OpPointedTimesMagmaTerm n)
    eOL'  = eOL 
    stageOpB : {n : Nat} -> ((OpPointedTimesMagmaTerm n) -> (Staged (OpPointedTimesMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB eOL = (Now eOL) 
    *OL2' : {n : Nat} {A : Set} -> ((OpPointedTimesMagmaTerm2 n A) -> ((OpPointedTimesMagmaTerm2 n A) -> (OpPointedTimesMagmaTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    eOL2' : {n : Nat} {A : Set} -> (OpPointedTimesMagmaTerm2 n A)
    eOL2'  = eOL2 
    stageOp : {n : Nat} {A : Set} -> ((OpPointedTimesMagmaTerm2 n A) -> (Staged (OpPointedTimesMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp eOL2 = (Now eOL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        eT : (Repr A)
  module PointedTimesZeroMagma  where
    record PointedTimesZeroMagma (A : Set) : Set where
      constructor PointedTimesZeroMagmaC
      field
        0 : A
        * : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        0S : AS
        *S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        0P : (Prod A A)
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
    record Hom {A1 : Set} {A2 : Set} (Po1 : (PointedTimesZeroMagma A1)) (Po2 : (PointedTimesZeroMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-0 : (hom (0 Po1)) == (0 Po2)
        pres-* : {x1 x2 : A1} -> (hom ((* Po1) x1 x2)) == ((* Po2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Po1 : (PointedTimesZeroMagma A1)) (Po2 : (PointedTimesZeroMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-0 : (interp (0 Po1) (0 Po2))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Po1) x1 x2) ((* Po2) y1 y2))))
    data PointedTimesZeroMagmaTerm  : Set where
      0L : PointedTimesZeroMagmaTerm
      *L : (PointedTimesZeroMagmaTerm -> (PointedTimesZeroMagmaTerm -> PointedTimesZeroMagmaTerm))
    data ClPointedTimesZeroMagmaTerm (A : Set) : Set where
      sing : (A -> (ClPointedTimesZeroMagmaTerm A))
      0Cl : (ClPointedTimesZeroMagmaTerm A)
      *Cl : ((ClPointedTimesZeroMagmaTerm A) -> ((ClPointedTimesZeroMagmaTerm A) -> (ClPointedTimesZeroMagmaTerm A)))
    data OpPointedTimesZeroMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpPointedTimesZeroMagmaTerm n))
      0OL : (OpPointedTimesZeroMagmaTerm n)
      *OL : ((OpPointedTimesZeroMagmaTerm n) -> ((OpPointedTimesZeroMagmaTerm n) -> (OpPointedTimesZeroMagmaTerm n)))
    data OpPointedTimesZeroMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpPointedTimesZeroMagmaTerm2 n A))
      sing2 : (A -> (OpPointedTimesZeroMagmaTerm2 n A))
      0OL2 : (OpPointedTimesZeroMagmaTerm2 n A)
      *OL2 : ((OpPointedTimesZeroMagmaTerm2 n A) -> ((OpPointedTimesZeroMagmaTerm2 n A) -> (OpPointedTimesZeroMagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClPointedTimesZeroMagmaTerm A) -> (ClPointedTimesZeroMagmaTerm A))
    simplifyCl 0Cl = 0Cl 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpPointedTimesZeroMagmaTerm n) -> (OpPointedTimesZeroMagmaTerm n))
    simplifyOpB 0OL = 0OL 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpPointedTimesZeroMagmaTerm2 n A) -> (OpPointedTimesZeroMagmaTerm2 n A))
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((PointedTimesZeroMagma A) -> (PointedTimesZeroMagmaTerm -> A))
    evalB Po 0L = (0 Po) 
    evalB Po (*L x1 x2) = ((* Po) (evalB Po x1) (evalB Po x2)) 
    evalCl : {A : Set} -> ((PointedTimesZeroMagma A) -> ((ClPointedTimesZeroMagmaTerm A) -> A))
    evalCl Po (sing x1) = x1 
    evalCl Po 0Cl = (0 Po) 
    evalCl Po (*Cl x1 x2) = ((* Po) (evalCl Po x1) (evalCl Po x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((PointedTimesZeroMagma A) -> ((Vec A n) -> ((OpPointedTimesZeroMagmaTerm n) -> A)))
    evalOpB Po vars (v x1) = (lookup _ x1 vars) 
    evalOpB Po vars 0OL = (0 Po) 
    evalOpB Po vars (*OL x1 x2) = ((* Po) (evalOpB Po vars x1) (evalOpB Po vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((PointedTimesZeroMagma A) -> ((Vec A n) -> ((OpPointedTimesZeroMagmaTerm2 n A) -> A)))
    evalOp Po vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Po vars (sing2 x1) = x1 
    evalOp Po vars 0OL2 = (0 Po) 
    evalOp Po vars (*OL2 x1 x2) = ((* Po) (evalOp Po vars x1) (evalOp Po vars x2)) 
    inductionB : {P : (PointedTimesZeroMagmaTerm -> Set)} -> ((P 0L) -> (((x1 x2 : PointedTimesZeroMagmaTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((x : PointedTimesZeroMagmaTerm) -> (P x))))
    inductionB {p} p0l p*l 0L = p0l 
    inductionB {p} p0l p*l (*L x1 x2) = (p*l _ _ (inductionB {p} p0l p*l x1) (inductionB {p} p0l p*l x2)) 
    inductionCl : {A : Set} {P : ((ClPointedTimesZeroMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 0Cl) -> (((x1 x2 : (ClPointedTimesZeroMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((x : (ClPointedTimesZeroMagmaTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p0cl p*cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p0cl p*cl 0Cl = p0cl 
    inductionCl {_} {p} psing p0cl p*cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p0cl p*cl x1) (inductionCl {_} {p} psing p0cl p*cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpPointedTimesZeroMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 0OL) -> (((x1 x2 : (OpPointedTimesZeroMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((x : (OpPointedTimesZeroMagmaTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p0ol p*ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p0ol p*ol 0OL = p0ol 
    inductionOpB {_} {p} pv p0ol p*ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p0ol p*ol x1) (inductionOpB {_} {p} pv p0ol p*ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpPointedTimesZeroMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 0OL2) -> (((x1 x2 : (OpPointedTimesZeroMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((x : (OpPointedTimesZeroMagmaTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p*ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p*ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p*ol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p*ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p*ol2 x2)) 
    0L' : PointedTimesZeroMagmaTerm
    0L'  = 0L 
    *L' : (PointedTimesZeroMagmaTerm -> (PointedTimesZeroMagmaTerm -> PointedTimesZeroMagmaTerm))
    *L' x1 x2 = (*L x1 x2) 
    stageB : (PointedTimesZeroMagmaTerm -> (Staged PointedTimesZeroMagmaTerm))
    stageB 0L = (Now 0L) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    0Cl' : {A : Set} -> (ClPointedTimesZeroMagmaTerm A)
    0Cl'  = 0Cl 
    *Cl' : {A : Set} -> ((ClPointedTimesZeroMagmaTerm A) -> ((ClPointedTimesZeroMagmaTerm A) -> (ClPointedTimesZeroMagmaTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    stageCl : {A : Set} -> ((ClPointedTimesZeroMagmaTerm A) -> (Staged (ClPointedTimesZeroMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    0OL' : {n : Nat} -> (OpPointedTimesZeroMagmaTerm n)
    0OL'  = 0OL 
    *OL' : {n : Nat} -> ((OpPointedTimesZeroMagmaTerm n) -> ((OpPointedTimesZeroMagmaTerm n) -> (OpPointedTimesZeroMagmaTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpPointedTimesZeroMagmaTerm n) -> (Staged (OpPointedTimesZeroMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    0OL2' : {n : Nat} {A : Set} -> (OpPointedTimesZeroMagmaTerm2 n A)
    0OL2'  = 0OL2 
    *OL2' : {n : Nat} {A : Set} -> ((OpPointedTimesZeroMagmaTerm2 n A) -> ((OpPointedTimesZeroMagmaTerm2 n A) -> (OpPointedTimesZeroMagmaTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpPointedTimesZeroMagmaTerm2 n A) -> (Staged (OpPointedTimesZeroMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        0T : (Repr A)
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module PointedUnarySystem  where
    record PointedUnarySystem (A : Set) : Set where
      constructor PointedUnarySystemC
      field
        prim : (A -> A)
        e : A
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        primS : (AS -> AS)
        eS : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        primP : ((Prod A A) -> (Prod A A))
        eP : (Prod A A)
    record Hom {A1 : Set} {A2 : Set} (Po1 : (PointedUnarySystem A1)) (Po2 : (PointedUnarySystem A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-prim : {x1 : A1} -> (hom ((prim Po1) x1)) == ((prim Po2) (hom x1))
        pres-e : (hom (e Po1)) == (e Po2)
    record RelInterp {A1 : Set} {A2 : Set} (Po1 : (PointedUnarySystem A1)) (Po2 : (PointedUnarySystem A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim Po1) x1) ((prim Po2) y1)))
        interp-e : (interp (e Po1) (e Po2))
    data PointedUnarySystemTerm  : Set where
      primL : (PointedUnarySystemTerm -> PointedUnarySystemTerm)
      eL : PointedUnarySystemTerm
    data ClPointedUnarySystemTerm (A : Set) : Set where
      sing : (A -> (ClPointedUnarySystemTerm A))
      primCl : ((ClPointedUnarySystemTerm A) -> (ClPointedUnarySystemTerm A))
      eCl : (ClPointedUnarySystemTerm A)
    data OpPointedUnarySystemTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpPointedUnarySystemTerm n))
      primOL : ((OpPointedUnarySystemTerm n) -> (OpPointedUnarySystemTerm n))
      eOL : (OpPointedUnarySystemTerm n)
    data OpPointedUnarySystemTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpPointedUnarySystemTerm2 n A))
      sing2 : (A -> (OpPointedUnarySystemTerm2 n A))
      primOL2 : ((OpPointedUnarySystemTerm2 n A) -> (OpPointedUnarySystemTerm2 n A))
      eOL2 : (OpPointedUnarySystemTerm2 n A)
    simplifyCl : {A : Set} -> ((ClPointedUnarySystemTerm A) -> (ClPointedUnarySystemTerm A))
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl eCl = eCl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpPointedUnarySystemTerm n) -> (OpPointedUnarySystemTerm n))
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB eOL = eOL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpPointedUnarySystemTerm2 n A) -> (OpPointedUnarySystemTerm2 n A))
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp eOL2 = eOL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((PointedUnarySystem A) -> (PointedUnarySystemTerm -> A))
    evalB Po (primL x1) = ((prim Po) (evalB Po x1)) 
    evalB Po eL = (e Po) 
    evalCl : {A : Set} -> ((PointedUnarySystem A) -> ((ClPointedUnarySystemTerm A) -> A))
    evalCl Po (sing x1) = x1 
    evalCl Po (primCl x1) = ((prim Po) (evalCl Po x1)) 
    evalCl Po eCl = (e Po) 
    evalOpB : {A : Set} {n : Nat} -> ((PointedUnarySystem A) -> ((Vec A n) -> ((OpPointedUnarySystemTerm n) -> A)))
    evalOpB Po vars (v x1) = (lookup _ x1 vars) 
    evalOpB Po vars (primOL x1) = ((prim Po) (evalOpB Po vars x1)) 
    evalOpB Po vars eOL = (e Po) 
    evalOp : {A : Set} {n : Nat} -> ((PointedUnarySystem A) -> ((Vec A n) -> ((OpPointedUnarySystemTerm2 n A) -> A)))
    evalOp Po vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Po vars (sing2 x1) = x1 
    evalOp Po vars (primOL2 x1) = ((prim Po) (evalOp Po vars x1)) 
    evalOp Po vars eOL2 = (e Po) 
    inductionB : {P : (PointedUnarySystemTerm -> Set)} -> (((x1 : PointedUnarySystemTerm) -> ((P x1) -> (P (primL x1)))) -> ((P eL) -> ((x : PointedUnarySystemTerm) -> (P x))))
    inductionB {p} ppriml pel (primL x1) = (ppriml _ (inductionB {p} ppriml pel x1)) 
    inductionB {p} ppriml pel eL = pel 
    inductionCl : {A : Set} {P : ((ClPointedUnarySystemTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 : (ClPointedUnarySystemTerm A)) -> ((P x1) -> (P (primCl x1)))) -> ((P eCl) -> ((x : (ClPointedUnarySystemTerm A)) -> (P x)))))
    inductionCl {_} {p} psing pprimcl pecl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pprimcl pecl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing pprimcl pecl x1)) 
    inductionCl {_} {p} psing pprimcl pecl eCl = pecl 
    inductionOpB : {n : Nat} {P : ((OpPointedUnarySystemTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 : (OpPointedUnarySystemTerm n)) -> ((P x1) -> (P (primOL x1)))) -> ((P eOL) -> ((x : (OpPointedUnarySystemTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv pprimol peol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pprimol peol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv pprimol peol x1)) 
    inductionOpB {_} {p} pv pprimol peol eOL = peol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpPointedUnarySystemTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 : (OpPointedUnarySystemTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> ((P eOL2) -> ((x : (OpPointedUnarySystemTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 peol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 peol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 peol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 pprimol2 peol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 peol2 eOL2 = peol2 
    primL' : (PointedUnarySystemTerm -> PointedUnarySystemTerm)
    primL' x1 = (primL x1) 
    eL' : PointedUnarySystemTerm
    eL'  = eL 
    stageB : (PointedUnarySystemTerm -> (Staged PointedUnarySystemTerm))
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    stageB eL = (Now eL) 
    primCl' : {A : Set} -> ((ClPointedUnarySystemTerm A) -> (ClPointedUnarySystemTerm A))
    primCl' x1 = (primCl x1) 
    eCl' : {A : Set} -> (ClPointedUnarySystemTerm A)
    eCl'  = eCl 
    stageCl : {A : Set} -> ((ClPointedUnarySystemTerm A) -> (Staged (ClPointedUnarySystemTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    stageCl eCl = (Now eCl) 
    primOL' : {n : Nat} -> ((OpPointedUnarySystemTerm n) -> (OpPointedUnarySystemTerm n))
    primOL' x1 = (primOL x1) 
    eOL' : {n : Nat} -> (OpPointedUnarySystemTerm n)
    eOL'  = eOL 
    stageOpB : {n : Nat} -> ((OpPointedUnarySystemTerm n) -> (Staged (OpPointedUnarySystemTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    stageOpB eOL = (Now eOL) 
    primOL2' : {n : Nat} {A : Set} -> ((OpPointedUnarySystemTerm2 n A) -> (OpPointedUnarySystemTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    eOL2' : {n : Nat} {A : Set} -> (OpPointedUnarySystemTerm2 n A)
    eOL2'  = eOL2 
    stageOp : {n : Nat} {A : Set} -> ((OpPointedUnarySystemTerm2 n A) -> (Staged (OpPointedUnarySystemTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    stageOp eOL2 = (Now eOL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        primT : ((Repr A) -> (Repr A))
        eT : (Repr A)
  module PointedZero  where
    record PointedZero (A : Set) : Set where
      constructor PointedZeroC
      field
        0 : A
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        0S : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        0P : (Prod A A)
    record Hom {A1 : Set} {A2 : Set} (Po1 : (PointedZero A1)) (Po2 : (PointedZero A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-0 : (hom (0 Po1)) == (0 Po2)
    record RelInterp {A1 : Set} {A2 : Set} (Po1 : (PointedZero A1)) (Po2 : (PointedZero A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-0 : (interp (0 Po1) (0 Po2))
    data PointedZeroTerm  : Set where
      0L : PointedZeroTerm
    data ClPointedZeroTerm (A : Set) : Set where
      sing : (A -> (ClPointedZeroTerm A))
      0Cl : (ClPointedZeroTerm A)
    data OpPointedZeroTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpPointedZeroTerm n))
      0OL : (OpPointedZeroTerm n)
    data OpPointedZeroTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpPointedZeroTerm2 n A))
      sing2 : (A -> (OpPointedZeroTerm2 n A))
      0OL2 : (OpPointedZeroTerm2 n A)
    simplifyCl : {A : Set} -> ((ClPointedZeroTerm A) -> (ClPointedZeroTerm A))
    simplifyCl 0Cl = 0Cl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpPointedZeroTerm n) -> (OpPointedZeroTerm n))
    simplifyOpB 0OL = 0OL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpPointedZeroTerm2 n A) -> (OpPointedZeroTerm2 n A))
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((PointedZero A) -> (PointedZeroTerm -> A))
    evalB Po 0L = (0 Po) 
    evalCl : {A : Set} -> ((PointedZero A) -> ((ClPointedZeroTerm A) -> A))
    evalCl Po (sing x1) = x1 
    evalCl Po 0Cl = (0 Po) 
    evalOpB : {A : Set} {n : Nat} -> ((PointedZero A) -> ((Vec A n) -> ((OpPointedZeroTerm n) -> A)))
    evalOpB Po vars (v x1) = (lookup _ x1 vars) 
    evalOpB Po vars 0OL = (0 Po) 
    evalOp : {A : Set} {n : Nat} -> ((PointedZero A) -> ((Vec A n) -> ((OpPointedZeroTerm2 n A) -> A)))
    evalOp Po vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Po vars (sing2 x1) = x1 
    evalOp Po vars 0OL2 = (0 Po) 
    inductionB : {P : (PointedZeroTerm -> Set)} -> ((P 0L) -> ((x : PointedZeroTerm) -> (P x)))
    inductionB {p} p0l 0L = p0l 
    inductionCl : {A : Set} {P : ((ClPointedZeroTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 0Cl) -> ((x : (ClPointedZeroTerm A)) -> (P x))))
    inductionCl {_} {p} psing p0cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p0cl 0Cl = p0cl 
    inductionOpB : {n : Nat} {P : ((OpPointedZeroTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 0OL) -> ((x : (OpPointedZeroTerm n)) -> (P x))))
    inductionOpB {_} {p} pv p0ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p0ol 0OL = p0ol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpPointedZeroTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 0OL2) -> ((x : (OpPointedZeroTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 0OL2 = p0ol2 
    0L' : PointedZeroTerm
    0L'  = 0L 
    stageB : (PointedZeroTerm -> (Staged PointedZeroTerm))
    stageB 0L = (Now 0L) 
    0Cl' : {A : Set} -> (ClPointedZeroTerm A)
    0Cl'  = 0Cl 
    stageCl : {A : Set} -> ((ClPointedZeroTerm A) -> (Staged (ClPointedZeroTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 0Cl = (Now 0Cl) 
    0OL' : {n : Nat} -> (OpPointedZeroTerm n)
    0OL'  = 0OL 
    stageOpB : {n : Nat} -> ((OpPointedZeroTerm n) -> (Staged (OpPointedZeroTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 0OL = (Now 0OL) 
    0OL2' : {n : Nat} {A : Set} -> (OpPointedZeroTerm2 n A)
    0OL2'  = 0OL2 
    stageOp : {n : Nat} {A : Set} -> ((OpPointedZeroTerm2 n A) -> (Staged (OpPointedZeroTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 0OL2 = (Now 0OL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        0T : (Repr A)
  module PreSemiring  where
    record PreSemiring (A : Set) : Set where
      constructor PreSemiringC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        leftDistributive_*_+ : {x y z : A} -> (* x (+ y z)) == (+ (* x y) (* x z))
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        rightDistributive_*_+ : {x y z : A} -> (* (+ y z) x) == (+ (* y x) (* z x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        leftDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P xP (+P yP zP)) == (+P (*P xP yP) (*P xP zP))
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        rightDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P (+P yP zP) xP) == (+P (*P yP xP) (*P zP xP))
    record Hom {A1 : Set} {A2 : Set} (Pr1 : (PreSemiring A1)) (Pr2 : (PreSemiring A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Pr1) x1 x2)) == ((* Pr2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Pr1) x1 x2)) == ((+ Pr2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Pr1 : (PreSemiring A1)) (Pr2 : (PreSemiring A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Pr1) x1 x2) ((* Pr2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Pr1) x1 x2) ((+ Pr2) y1 y2))))
    data PreSemiringTerm  : Set where
      *L : (PreSemiringTerm -> (PreSemiringTerm -> PreSemiringTerm))
      +L : (PreSemiringTerm -> (PreSemiringTerm -> PreSemiringTerm))
    data ClPreSemiringTerm (A : Set) : Set where
      sing : (A -> (ClPreSemiringTerm A))
      *Cl : ((ClPreSemiringTerm A) -> ((ClPreSemiringTerm A) -> (ClPreSemiringTerm A)))
      +Cl : ((ClPreSemiringTerm A) -> ((ClPreSemiringTerm A) -> (ClPreSemiringTerm A)))
    data OpPreSemiringTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpPreSemiringTerm n))
      *OL : ((OpPreSemiringTerm n) -> ((OpPreSemiringTerm n) -> (OpPreSemiringTerm n)))
      +OL : ((OpPreSemiringTerm n) -> ((OpPreSemiringTerm n) -> (OpPreSemiringTerm n)))
    data OpPreSemiringTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpPreSemiringTerm2 n A))
      sing2 : (A -> (OpPreSemiringTerm2 n A))
      *OL2 : ((OpPreSemiringTerm2 n A) -> ((OpPreSemiringTerm2 n A) -> (OpPreSemiringTerm2 n A)))
      +OL2 : ((OpPreSemiringTerm2 n A) -> ((OpPreSemiringTerm2 n A) -> (OpPreSemiringTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClPreSemiringTerm A) -> (ClPreSemiringTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpPreSemiringTerm n) -> (OpPreSemiringTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpPreSemiringTerm2 n A) -> (OpPreSemiringTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((PreSemiring A) -> (PreSemiringTerm -> A))
    evalB Pr (*L x1 x2) = ((* Pr) (evalB Pr x1) (evalB Pr x2)) 
    evalB Pr (+L x1 x2) = ((+ Pr) (evalB Pr x1) (evalB Pr x2)) 
    evalCl : {A : Set} -> ((PreSemiring A) -> ((ClPreSemiringTerm A) -> A))
    evalCl Pr (sing x1) = x1 
    evalCl Pr (*Cl x1 x2) = ((* Pr) (evalCl Pr x1) (evalCl Pr x2)) 
    evalCl Pr (+Cl x1 x2) = ((+ Pr) (evalCl Pr x1) (evalCl Pr x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((PreSemiring A) -> ((Vec A n) -> ((OpPreSemiringTerm n) -> A)))
    evalOpB Pr vars (v x1) = (lookup _ x1 vars) 
    evalOpB Pr vars (*OL x1 x2) = ((* Pr) (evalOpB Pr vars x1) (evalOpB Pr vars x2)) 
    evalOpB Pr vars (+OL x1 x2) = ((+ Pr) (evalOpB Pr vars x1) (evalOpB Pr vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((PreSemiring A) -> ((Vec A n) -> ((OpPreSemiringTerm2 n A) -> A)))
    evalOp Pr vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Pr vars (sing2 x1) = x1 
    evalOp Pr vars (*OL2 x1 x2) = ((* Pr) (evalOp Pr vars x1) (evalOp Pr vars x2)) 
    evalOp Pr vars (+OL2 x1 x2) = ((+ Pr) (evalOp Pr vars x1) (evalOp Pr vars x2)) 
    inductionB : {P : (PreSemiringTerm -> Set)} -> (((x1 x2 : PreSemiringTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : PreSemiringTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : PreSemiringTerm) -> (P x))))
    inductionB {p} p*l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionB {p} p*l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClPreSemiringTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClPreSemiringTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClPreSemiringTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClPreSemiringTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p*cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpPreSemiringTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpPreSemiringTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpPreSemiringTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpPreSemiringTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p*ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpPreSemiringTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpPreSemiringTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpPreSemiringTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpPreSemiringTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    *L' : (PreSemiringTerm -> (PreSemiringTerm -> PreSemiringTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (PreSemiringTerm -> (PreSemiringTerm -> PreSemiringTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (PreSemiringTerm -> (Staged PreSemiringTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClPreSemiringTerm A) -> ((ClPreSemiringTerm A) -> (ClPreSemiringTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClPreSemiringTerm A) -> ((ClPreSemiringTerm A) -> (ClPreSemiringTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClPreSemiringTerm A) -> (Staged (ClPreSemiringTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpPreSemiringTerm n) -> ((OpPreSemiringTerm n) -> (OpPreSemiringTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpPreSemiringTerm n) -> ((OpPreSemiringTerm n) -> (OpPreSemiringTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpPreSemiringTerm n) -> (Staged (OpPreSemiringTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpPreSemiringTerm2 n A) -> ((OpPreSemiringTerm2 n A) -> (OpPreSemiringTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpPreSemiringTerm2 n A) -> ((OpPreSemiringTerm2 n A) -> (OpPreSemiringTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpPreSemiringTerm2 n A) -> (Staged (OpPreSemiringTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module PrimAdditiveGroup  where
    record PrimAdditiveGroup (A : Set) : Set where
      constructor PrimAdditiveGroupC
      field
        0_ : A
        *_ : (A -> (A -> A))
        lunit_0_ : {x : A} -> (*_ 0_ x) == x
        runit_0_ : {x : A} -> (*_ x 0_) == x
        associative_*_ : {x y z : A} -> (*_ (*_ x y) z) == (*_ x (*_ y z))
        inv_ : (A -> A)
        leftInverse_inv_op_0_ : {x : A} -> (*_ x (inv_ x)) == 0_
        rightInverse_inv_op_0_ : {x : A} -> (*_ (inv_ x) x) == 0_
        commutative_*_ : {x y : A} -> (*_ x y) == (*_ y x)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        0_S : AS
        *_S : (AS -> (AS -> AS))
        inv_S : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        0_P : (Prod A A)
        *_P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        inv_P : ((Prod A A) -> (Prod A A))
        lunit_0_P : {xP : (Prod A A)} -> (*_P 0_P xP) == xP
        runit_0_P : {xP : (Prod A A)} -> (*_P xP 0_P) == xP
        associative_*_P : {xP yP zP : (Prod A A)} -> (*_P (*_P xP yP) zP) == (*_P xP (*_P yP zP))
        leftInverse_inv_op_0_P : {xP : (Prod A A)} -> (*_P xP (inv_P xP)) == 0_P
        rightInverse_inv_op_0_P : {xP : (Prod A A)} -> (*_P (inv_P xP) xP) == 0_P
        commutative_*_P : {xP yP : (Prod A A)} -> (*_P xP yP) == (*_P yP xP)
    record Hom {A1 : Set} {A2 : Set} (Pr1 : (PrimAdditiveGroup A1)) (Pr2 : (PrimAdditiveGroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-0_ : (hom (0_ Pr1)) == (0_ Pr2)
        pres-*_ : {x1 x2 : A1} -> (hom ((*_ Pr1) x1 x2)) == ((*_ Pr2) (hom x1) (hom x2))
        pres-inv_ : {x1 : A1} -> (hom ((inv_ Pr1) x1)) == ((inv_ Pr2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (Pr1 : (PrimAdditiveGroup A1)) (Pr2 : (PrimAdditiveGroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-0_ : (interp (0_ Pr1) (0_ Pr2))
        interp-*_ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((*_ Pr1) x1 x2) ((*_ Pr2) y1 y2))))
        interp-inv_ : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((inv_ Pr1) x1) ((inv_ Pr2) y1)))
    data PrimAdditiveGroupTerm  : Set where
      0_L : PrimAdditiveGroupTerm
      *_L : (PrimAdditiveGroupTerm -> (PrimAdditiveGroupTerm -> PrimAdditiveGroupTerm))
      inv_L : (PrimAdditiveGroupTerm -> PrimAdditiveGroupTerm)
    data ClPrimAdditiveGroupTerm (A : Set) : Set where
      sing : (A -> (ClPrimAdditiveGroupTerm A))
      0_Cl : (ClPrimAdditiveGroupTerm A)
      *_Cl : ((ClPrimAdditiveGroupTerm A) -> ((ClPrimAdditiveGroupTerm A) -> (ClPrimAdditiveGroupTerm A)))
      inv_Cl : ((ClPrimAdditiveGroupTerm A) -> (ClPrimAdditiveGroupTerm A))
    data OpPrimAdditiveGroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpPrimAdditiveGroupTerm n))
      0_OL : (OpPrimAdditiveGroupTerm n)
      *_OL : ((OpPrimAdditiveGroupTerm n) -> ((OpPrimAdditiveGroupTerm n) -> (OpPrimAdditiveGroupTerm n)))
      inv_OL : ((OpPrimAdditiveGroupTerm n) -> (OpPrimAdditiveGroupTerm n))
    data OpPrimAdditiveGroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpPrimAdditiveGroupTerm2 n A))
      sing2 : (A -> (OpPrimAdditiveGroupTerm2 n A))
      0_OL2 : (OpPrimAdditiveGroupTerm2 n A)
      *_OL2 : ((OpPrimAdditiveGroupTerm2 n A) -> ((OpPrimAdditiveGroupTerm2 n A) -> (OpPrimAdditiveGroupTerm2 n A)))
      inv_OL2 : ((OpPrimAdditiveGroupTerm2 n A) -> (OpPrimAdditiveGroupTerm2 n A))
    simplifyCl : {A : Set} -> ((ClPrimAdditiveGroupTerm A) -> (ClPrimAdditiveGroupTerm A))
    simplifyCl (*_Cl 0_Cl x) = x 
    simplifyCl (*_Cl x 0_Cl) = x 
    simplifyCl 0_Cl = 0_Cl 
    simplifyCl (*_Cl x1 x2) = (*_Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (inv_Cl x1) = (inv_Cl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpPrimAdditiveGroupTerm n) -> (OpPrimAdditiveGroupTerm n))
    simplifyOpB (*_OL 0_OL x) = x 
    simplifyOpB (*_OL x 0_OL) = x 
    simplifyOpB 0_OL = 0_OL 
    simplifyOpB (*_OL x1 x2) = (*_OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (inv_OL x1) = (inv_OL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpPrimAdditiveGroupTerm2 n A) -> (OpPrimAdditiveGroupTerm2 n A))
    simplifyOp (*_OL2 0_OL2 x) = x 
    simplifyOp (*_OL2 x 0_OL2) = x 
    simplifyOp 0_OL2 = 0_OL2 
    simplifyOp (*_OL2 x1 x2) = (*_OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (inv_OL2 x1) = (inv_OL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((PrimAdditiveGroup A) -> (PrimAdditiveGroupTerm -> A))
    evalB Pr 0_L = (0_ Pr) 
    evalB Pr (*_L x1 x2) = ((*_ Pr) (evalB Pr x1) (evalB Pr x2)) 
    evalB Pr (inv_L x1) = ((inv_ Pr) (evalB Pr x1)) 
    evalCl : {A : Set} -> ((PrimAdditiveGroup A) -> ((ClPrimAdditiveGroupTerm A) -> A))
    evalCl Pr (sing x1) = x1 
    evalCl Pr 0_Cl = (0_ Pr) 
    evalCl Pr (*_Cl x1 x2) = ((*_ Pr) (evalCl Pr x1) (evalCl Pr x2)) 
    evalCl Pr (inv_Cl x1) = ((inv_ Pr) (evalCl Pr x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((PrimAdditiveGroup A) -> ((Vec A n) -> ((OpPrimAdditiveGroupTerm n) -> A)))
    evalOpB Pr vars (v x1) = (lookup _ x1 vars) 
    evalOpB Pr vars 0_OL = (0_ Pr) 
    evalOpB Pr vars (*_OL x1 x2) = ((*_ Pr) (evalOpB Pr vars x1) (evalOpB Pr vars x2)) 
    evalOpB Pr vars (inv_OL x1) = ((inv_ Pr) (evalOpB Pr vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((PrimAdditiveGroup A) -> ((Vec A n) -> ((OpPrimAdditiveGroupTerm2 n A) -> A)))
    evalOp Pr vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Pr vars (sing2 x1) = x1 
    evalOp Pr vars 0_OL2 = (0_ Pr) 
    evalOp Pr vars (*_OL2 x1 x2) = ((*_ Pr) (evalOp Pr vars x1) (evalOp Pr vars x2)) 
    evalOp Pr vars (inv_OL2 x1) = ((inv_ Pr) (evalOp Pr vars x1)) 
    inductionB : {P : (PrimAdditiveGroupTerm -> Set)} -> ((P 0_L) -> (((x1 x2 : PrimAdditiveGroupTerm) -> ((P x1) -> ((P x2) -> (P (*_L x1 x2))))) -> (((x1 : PrimAdditiveGroupTerm) -> ((P x1) -> (P (inv_L x1)))) -> ((x : PrimAdditiveGroupTerm) -> (P x)))))
    inductionB {p} p0_l p*_l pinv_l 0_L = p0_l 
    inductionB {p} p0_l p*_l pinv_l (*_L x1 x2) = (p*_l _ _ (inductionB {p} p0_l p*_l pinv_l x1) (inductionB {p} p0_l p*_l pinv_l x2)) 
    inductionB {p} p0_l p*_l pinv_l (inv_L x1) = (pinv_l _ (inductionB {p} p0_l p*_l pinv_l x1)) 
    inductionCl : {A : Set} {P : ((ClPrimAdditiveGroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 0_Cl) -> (((x1 x2 : (ClPrimAdditiveGroupTerm A)) -> ((P x1) -> ((P x2) -> (P (*_Cl x1 x2))))) -> (((x1 : (ClPrimAdditiveGroupTerm A)) -> ((P x1) -> (P (inv_Cl x1)))) -> ((x : (ClPrimAdditiveGroupTerm A)) -> (P x))))))
    inductionCl {_} {p} psing p0_cl p*_cl pinv_cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p0_cl p*_cl pinv_cl 0_Cl = p0_cl 
    inductionCl {_} {p} psing p0_cl p*_cl pinv_cl (*_Cl x1 x2) = (p*_cl _ _ (inductionCl {_} {p} psing p0_cl p*_cl pinv_cl x1) (inductionCl {_} {p} psing p0_cl p*_cl pinv_cl x2)) 
    inductionCl {_} {p} psing p0_cl p*_cl pinv_cl (inv_Cl x1) = (pinv_cl _ (inductionCl {_} {p} psing p0_cl p*_cl pinv_cl x1)) 
    inductionOpB : {n : Nat} {P : ((OpPrimAdditiveGroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 0_OL) -> (((x1 x2 : (OpPrimAdditiveGroupTerm n)) -> ((P x1) -> ((P x2) -> (P (*_OL x1 x2))))) -> (((x1 : (OpPrimAdditiveGroupTerm n)) -> ((P x1) -> (P (inv_OL x1)))) -> ((x : (OpPrimAdditiveGroupTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv p0_ol p*_ol pinv_ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p0_ol p*_ol pinv_ol 0_OL = p0_ol 
    inductionOpB {_} {p} pv p0_ol p*_ol pinv_ol (*_OL x1 x2) = (p*_ol _ _ (inductionOpB {_} {p} pv p0_ol p*_ol pinv_ol x1) (inductionOpB {_} {p} pv p0_ol p*_ol pinv_ol x2)) 
    inductionOpB {_} {p} pv p0_ol p*_ol pinv_ol (inv_OL x1) = (pinv_ol _ (inductionOpB {_} {p} pv p0_ol p*_ol pinv_ol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpPrimAdditiveGroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 0_OL2) -> (((x1 x2 : (OpPrimAdditiveGroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*_OL2 x1 x2))))) -> (((x1 : (OpPrimAdditiveGroupTerm2 n A)) -> ((P x1) -> (P (inv_OL2 x1)))) -> ((x : (OpPrimAdditiveGroupTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 p0_ol2 p*_ol2 pinv_ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0_ol2 p*_ol2 pinv_ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0_ol2 p*_ol2 pinv_ol2 0_OL2 = p0_ol2 
    inductionOp {_} {_} {p} pv2 psing2 p0_ol2 p*_ol2 pinv_ol2 (*_OL2 x1 x2) = (p*_ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p0_ol2 p*_ol2 pinv_ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p0_ol2 p*_ol2 pinv_ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p0_ol2 p*_ol2 pinv_ol2 (inv_OL2 x1) = (pinv_ol2 _ (inductionOp {_} {_} {p} pv2 psing2 p0_ol2 p*_ol2 pinv_ol2 x1)) 
    0_L' : PrimAdditiveGroupTerm
    0_L'  = 0_L 
    *_L' : (PrimAdditiveGroupTerm -> (PrimAdditiveGroupTerm -> PrimAdditiveGroupTerm))
    *_L' x1 x2 = (*_L x1 x2) 
    inv_L' : (PrimAdditiveGroupTerm -> PrimAdditiveGroupTerm)
    inv_L' x1 = (inv_L x1) 
    stageB : (PrimAdditiveGroupTerm -> (Staged PrimAdditiveGroupTerm))
    stageB 0_L = (Now 0_L) 
    stageB (*_L x1 x2) = (stage2 *_L' (codeLift2 *_L') (stageB x1) (stageB x2)) 
    stageB (inv_L x1) = (stage1 inv_L' (codeLift1 inv_L') (stageB x1)) 
    0_Cl' : {A : Set} -> (ClPrimAdditiveGroupTerm A)
    0_Cl'  = 0_Cl 
    *_Cl' : {A : Set} -> ((ClPrimAdditiveGroupTerm A) -> ((ClPrimAdditiveGroupTerm A) -> (ClPrimAdditiveGroupTerm A)))
    *_Cl' x1 x2 = (*_Cl x1 x2) 
    inv_Cl' : {A : Set} -> ((ClPrimAdditiveGroupTerm A) -> (ClPrimAdditiveGroupTerm A))
    inv_Cl' x1 = (inv_Cl x1) 
    stageCl : {A : Set} -> ((ClPrimAdditiveGroupTerm A) -> (Staged (ClPrimAdditiveGroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 0_Cl = (Now 0_Cl) 
    stageCl (*_Cl x1 x2) = (stage2 *_Cl' (codeLift2 *_Cl') (stageCl x1) (stageCl x2)) 
    stageCl (inv_Cl x1) = (stage1 inv_Cl' (codeLift1 inv_Cl') (stageCl x1)) 
    0_OL' : {n : Nat} -> (OpPrimAdditiveGroupTerm n)
    0_OL'  = 0_OL 
    *_OL' : {n : Nat} -> ((OpPrimAdditiveGroupTerm n) -> ((OpPrimAdditiveGroupTerm n) -> (OpPrimAdditiveGroupTerm n)))
    *_OL' x1 x2 = (*_OL x1 x2) 
    inv_OL' : {n : Nat} -> ((OpPrimAdditiveGroupTerm n) -> (OpPrimAdditiveGroupTerm n))
    inv_OL' x1 = (inv_OL x1) 
    stageOpB : {n : Nat} -> ((OpPrimAdditiveGroupTerm n) -> (Staged (OpPrimAdditiveGroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 0_OL = (Now 0_OL) 
    stageOpB (*_OL x1 x2) = (stage2 *_OL' (codeLift2 *_OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (inv_OL x1) = (stage1 inv_OL' (codeLift1 inv_OL') (stageOpB x1)) 
    0_OL2' : {n : Nat} {A : Set} -> (OpPrimAdditiveGroupTerm2 n A)
    0_OL2'  = 0_OL2 
    *_OL2' : {n : Nat} {A : Set} -> ((OpPrimAdditiveGroupTerm2 n A) -> ((OpPrimAdditiveGroupTerm2 n A) -> (OpPrimAdditiveGroupTerm2 n A)))
    *_OL2' x1 x2 = (*_OL2 x1 x2) 
    inv_OL2' : {n : Nat} {A : Set} -> ((OpPrimAdditiveGroupTerm2 n A) -> (OpPrimAdditiveGroupTerm2 n A))
    inv_OL2' x1 = (inv_OL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpPrimAdditiveGroupTerm2 n A) -> (Staged (OpPrimAdditiveGroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 0_OL2 = (Now 0_OL2) 
    stageOp (*_OL2 x1 x2) = (stage2 *_OL2' (codeLift2 *_OL2') (stageOp x1) (stageOp x2)) 
    stageOp (inv_OL2 x1) = (stage1 inv_OL2' (codeLift1 inv_OL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        0_T : (Repr A)
        *_T : ((Repr A) -> ((Repr A) -> (Repr A)))
        inv_T : ((Repr A) -> (Repr A))
  module PrimRingoidSig  where
    record PrimRingoidSig (A : Set) : Set where
      constructor PrimRingoidSigC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        prim : (A -> A)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
        primS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        primP : ((Prod A A) -> (Prod A A))
    record Hom {A1 : Set} {A2 : Set} (Pr1 : (PrimRingoidSig A1)) (Pr2 : (PrimRingoidSig A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Pr1) x1 x2)) == ((* Pr2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Pr1) x1 x2)) == ((+ Pr2) (hom x1) (hom x2))
        pres-prim : {x1 : A1} -> (hom ((prim Pr1) x1)) == ((prim Pr2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (Pr1 : (PrimRingoidSig A1)) (Pr2 : (PrimRingoidSig A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Pr1) x1 x2) ((* Pr2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Pr1) x1 x2) ((+ Pr2) y1 y2))))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim Pr1) x1) ((prim Pr2) y1)))
    data PrimRingoidSigTerm  : Set where
      *L : (PrimRingoidSigTerm -> (PrimRingoidSigTerm -> PrimRingoidSigTerm))
      +L : (PrimRingoidSigTerm -> (PrimRingoidSigTerm -> PrimRingoidSigTerm))
      primL : (PrimRingoidSigTerm -> PrimRingoidSigTerm)
    data ClPrimRingoidSigTerm (A : Set) : Set where
      sing : (A -> (ClPrimRingoidSigTerm A))
      *Cl : ((ClPrimRingoidSigTerm A) -> ((ClPrimRingoidSigTerm A) -> (ClPrimRingoidSigTerm A)))
      +Cl : ((ClPrimRingoidSigTerm A) -> ((ClPrimRingoidSigTerm A) -> (ClPrimRingoidSigTerm A)))
      primCl : ((ClPrimRingoidSigTerm A) -> (ClPrimRingoidSigTerm A))
    data OpPrimRingoidSigTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpPrimRingoidSigTerm n))
      *OL : ((OpPrimRingoidSigTerm n) -> ((OpPrimRingoidSigTerm n) -> (OpPrimRingoidSigTerm n)))
      +OL : ((OpPrimRingoidSigTerm n) -> ((OpPrimRingoidSigTerm n) -> (OpPrimRingoidSigTerm n)))
      primOL : ((OpPrimRingoidSigTerm n) -> (OpPrimRingoidSigTerm n))
    data OpPrimRingoidSigTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpPrimRingoidSigTerm2 n A))
      sing2 : (A -> (OpPrimRingoidSigTerm2 n A))
      *OL2 : ((OpPrimRingoidSigTerm2 n A) -> ((OpPrimRingoidSigTerm2 n A) -> (OpPrimRingoidSigTerm2 n A)))
      +OL2 : ((OpPrimRingoidSigTerm2 n A) -> ((OpPrimRingoidSigTerm2 n A) -> (OpPrimRingoidSigTerm2 n A)))
      primOL2 : ((OpPrimRingoidSigTerm2 n A) -> (OpPrimRingoidSigTerm2 n A))
    simplifyCl : {A : Set} -> ((ClPrimRingoidSigTerm A) -> (ClPrimRingoidSigTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpPrimRingoidSigTerm n) -> (OpPrimRingoidSigTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpPrimRingoidSigTerm2 n A) -> (OpPrimRingoidSigTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((PrimRingoidSig A) -> (PrimRingoidSigTerm -> A))
    evalB Pr (*L x1 x2) = ((* Pr) (evalB Pr x1) (evalB Pr x2)) 
    evalB Pr (+L x1 x2) = ((+ Pr) (evalB Pr x1) (evalB Pr x2)) 
    evalB Pr (primL x1) = ((prim Pr) (evalB Pr x1)) 
    evalCl : {A : Set} -> ((PrimRingoidSig A) -> ((ClPrimRingoidSigTerm A) -> A))
    evalCl Pr (sing x1) = x1 
    evalCl Pr (*Cl x1 x2) = ((* Pr) (evalCl Pr x1) (evalCl Pr x2)) 
    evalCl Pr (+Cl x1 x2) = ((+ Pr) (evalCl Pr x1) (evalCl Pr x2)) 
    evalCl Pr (primCl x1) = ((prim Pr) (evalCl Pr x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((PrimRingoidSig A) -> ((Vec A n) -> ((OpPrimRingoidSigTerm n) -> A)))
    evalOpB Pr vars (v x1) = (lookup _ x1 vars) 
    evalOpB Pr vars (*OL x1 x2) = ((* Pr) (evalOpB Pr vars x1) (evalOpB Pr vars x2)) 
    evalOpB Pr vars (+OL x1 x2) = ((+ Pr) (evalOpB Pr vars x1) (evalOpB Pr vars x2)) 
    evalOpB Pr vars (primOL x1) = ((prim Pr) (evalOpB Pr vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((PrimRingoidSig A) -> ((Vec A n) -> ((OpPrimRingoidSigTerm2 n A) -> A)))
    evalOp Pr vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Pr vars (sing2 x1) = x1 
    evalOp Pr vars (*OL2 x1 x2) = ((* Pr) (evalOp Pr vars x1) (evalOp Pr vars x2)) 
    evalOp Pr vars (+OL2 x1 x2) = ((+ Pr) (evalOp Pr vars x1) (evalOp Pr vars x2)) 
    evalOp Pr vars (primOL2 x1) = ((prim Pr) (evalOp Pr vars x1)) 
    inductionB : {P : (PrimRingoidSigTerm -> Set)} -> (((x1 x2 : PrimRingoidSigTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : PrimRingoidSigTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> (((x1 : PrimRingoidSigTerm) -> ((P x1) -> (P (primL x1)))) -> ((x : PrimRingoidSigTerm) -> (P x)))))
    inductionB {p} p*l p+l ppriml (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l ppriml x1) (inductionB {p} p*l p+l ppriml x2)) 
    inductionB {p} p*l p+l ppriml (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l ppriml x1) (inductionB {p} p*l p+l ppriml x2)) 
    inductionB {p} p*l p+l ppriml (primL x1) = (ppriml _ (inductionB {p} p*l p+l ppriml x1)) 
    inductionCl : {A : Set} {P : ((ClPrimRingoidSigTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClPrimRingoidSigTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClPrimRingoidSigTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> (((x1 : (ClPrimRingoidSigTerm A)) -> ((P x1) -> (P (primCl x1)))) -> ((x : (ClPrimRingoidSigTerm A)) -> (P x))))))
    inductionCl {_} {p} psing p*cl p+cl pprimcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl pprimcl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl pprimcl x1) (inductionCl {_} {p} psing p*cl p+cl pprimcl x2)) 
    inductionCl {_} {p} psing p*cl p+cl pprimcl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl pprimcl x1) (inductionCl {_} {p} psing p*cl p+cl pprimcl x2)) 
    inductionCl {_} {p} psing p*cl p+cl pprimcl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing p*cl p+cl pprimcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpPrimRingoidSigTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpPrimRingoidSigTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpPrimRingoidSigTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> (((x1 : (OpPrimRingoidSigTerm n)) -> ((P x1) -> (P (primOL x1)))) -> ((x : (OpPrimRingoidSigTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv p*ol p+ol pprimol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol pprimol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol pprimol x1) (inductionOpB {_} {p} pv p*ol p+ol pprimol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol pprimol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol pprimol x1) (inductionOpB {_} {p} pv p*ol p+ol pprimol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol pprimol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv p*ol p+ol pprimol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpPrimRingoidSigTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpPrimRingoidSigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpPrimRingoidSigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> (((x1 : (OpPrimRingoidSigTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> ((x : (OpPrimRingoidSigTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x1)) 
    *L' : (PrimRingoidSigTerm -> (PrimRingoidSigTerm -> PrimRingoidSigTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (PrimRingoidSigTerm -> (PrimRingoidSigTerm -> PrimRingoidSigTerm))
    +L' x1 x2 = (+L x1 x2) 
    primL' : (PrimRingoidSigTerm -> PrimRingoidSigTerm)
    primL' x1 = (primL x1) 
    stageB : (PrimRingoidSigTerm -> (Staged PrimRingoidSigTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    *Cl' : {A : Set} -> ((ClPrimRingoidSigTerm A) -> ((ClPrimRingoidSigTerm A) -> (ClPrimRingoidSigTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClPrimRingoidSigTerm A) -> ((ClPrimRingoidSigTerm A) -> (ClPrimRingoidSigTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    primCl' : {A : Set} -> ((ClPrimRingoidSigTerm A) -> (ClPrimRingoidSigTerm A))
    primCl' x1 = (primCl x1) 
    stageCl : {A : Set} -> ((ClPrimRingoidSigTerm A) -> (Staged (ClPrimRingoidSigTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    *OL' : {n : Nat} -> ((OpPrimRingoidSigTerm n) -> ((OpPrimRingoidSigTerm n) -> (OpPrimRingoidSigTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpPrimRingoidSigTerm n) -> ((OpPrimRingoidSigTerm n) -> (OpPrimRingoidSigTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    primOL' : {n : Nat} -> ((OpPrimRingoidSigTerm n) -> (OpPrimRingoidSigTerm n))
    primOL' x1 = (primOL x1) 
    stageOpB : {n : Nat} -> ((OpPrimRingoidSigTerm n) -> (Staged (OpPrimRingoidSigTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpPrimRingoidSigTerm2 n A) -> ((OpPrimRingoidSigTerm2 n A) -> (OpPrimRingoidSigTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpPrimRingoidSigTerm2 n A) -> ((OpPrimRingoidSigTerm2 n A) -> (OpPrimRingoidSigTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    primOL2' : {n : Nat} {A : Set} -> ((OpPrimRingoidSigTerm2 n A) -> (OpPrimRingoidSigTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpPrimRingoidSigTerm2 n A) -> (Staged (OpPrimRingoidSigTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        primT : ((Repr A) -> (Repr A))
  module PseudoInverse  where
    record PseudoInverse (A : Set) : Set where
      constructor PseudoInverseC
      field
        inv : (A -> A)
        op : (A -> (A -> A))
        quasiInverse_inv_op_e : {x : A} -> (op (op x (inv x)) x) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        invS : (AS -> AS)
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        invP : ((Prod A A) -> (Prod A A))
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        quasiInverse_inv_op_eP : {xP : (Prod A A)} -> (opP (opP xP (invP xP)) xP) == xP
    record Hom {A1 : Set} {A2 : Set} (Ps1 : (PseudoInverse A1)) (Ps2 : (PseudoInverse A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-inv : {x1 : A1} -> (hom ((inv Ps1) x1)) == ((inv Ps2) (hom x1))
        pres-op : {x1 x2 : A1} -> (hom ((op Ps1) x1 x2)) == ((op Ps2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ps1 : (PseudoInverse A1)) (Ps2 : (PseudoInverse A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-inv : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((inv Ps1) x1) ((inv Ps2) y1)))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Ps1) x1 x2) ((op Ps2) y1 y2))))
    data PseudoInverseTerm  : Set where
      invL : (PseudoInverseTerm -> PseudoInverseTerm)
      opL : (PseudoInverseTerm -> (PseudoInverseTerm -> PseudoInverseTerm))
    data ClPseudoInverseTerm (A : Set) : Set where
      sing : (A -> (ClPseudoInverseTerm A))
      invCl : ((ClPseudoInverseTerm A) -> (ClPseudoInverseTerm A))
      opCl : ((ClPseudoInverseTerm A) -> ((ClPseudoInverseTerm A) -> (ClPseudoInverseTerm A)))
    data OpPseudoInverseTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpPseudoInverseTerm n))
      invOL : ((OpPseudoInverseTerm n) -> (OpPseudoInverseTerm n))
      opOL : ((OpPseudoInverseTerm n) -> ((OpPseudoInverseTerm n) -> (OpPseudoInverseTerm n)))
    data OpPseudoInverseTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpPseudoInverseTerm2 n A))
      sing2 : (A -> (OpPseudoInverseTerm2 n A))
      invOL2 : ((OpPseudoInverseTerm2 n A) -> (OpPseudoInverseTerm2 n A))
      opOL2 : ((OpPseudoInverseTerm2 n A) -> ((OpPseudoInverseTerm2 n A) -> (OpPseudoInverseTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClPseudoInverseTerm A) -> (ClPseudoInverseTerm A))
    simplifyCl (invCl x1) = (invCl (simplifyCl x1)) 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpPseudoInverseTerm n) -> (OpPseudoInverseTerm n))
    simplifyOpB (invOL x1) = (invOL (simplifyOpB x1)) 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpPseudoInverseTerm2 n A) -> (OpPseudoInverseTerm2 n A))
    simplifyOp (invOL2 x1) = (invOL2 (simplifyOp x1)) 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((PseudoInverse A) -> (PseudoInverseTerm -> A))
    evalB Ps (invL x1) = ((inv Ps) (evalB Ps x1)) 
    evalB Ps (opL x1 x2) = ((op Ps) (evalB Ps x1) (evalB Ps x2)) 
    evalCl : {A : Set} -> ((PseudoInverse A) -> ((ClPseudoInverseTerm A) -> A))
    evalCl Ps (sing x1) = x1 
    evalCl Ps (invCl x1) = ((inv Ps) (evalCl Ps x1)) 
    evalCl Ps (opCl x1 x2) = ((op Ps) (evalCl Ps x1) (evalCl Ps x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((PseudoInverse A) -> ((Vec A n) -> ((OpPseudoInverseTerm n) -> A)))
    evalOpB Ps vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ps vars (invOL x1) = ((inv Ps) (evalOpB Ps vars x1)) 
    evalOpB Ps vars (opOL x1 x2) = ((op Ps) (evalOpB Ps vars x1) (evalOpB Ps vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((PseudoInverse A) -> ((Vec A n) -> ((OpPseudoInverseTerm2 n A) -> A)))
    evalOp Ps vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ps vars (sing2 x1) = x1 
    evalOp Ps vars (invOL2 x1) = ((inv Ps) (evalOp Ps vars x1)) 
    evalOp Ps vars (opOL2 x1 x2) = ((op Ps) (evalOp Ps vars x1) (evalOp Ps vars x2)) 
    inductionB : {P : (PseudoInverseTerm -> Set)} -> (((x1 : PseudoInverseTerm) -> ((P x1) -> (P (invL x1)))) -> (((x1 x2 : PseudoInverseTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : PseudoInverseTerm) -> (P x))))
    inductionB {p} pinvl popl (invL x1) = (pinvl _ (inductionB {p} pinvl popl x1)) 
    inductionB {p} pinvl popl (opL x1 x2) = (popl _ _ (inductionB {p} pinvl popl x1) (inductionB {p} pinvl popl x2)) 
    inductionCl : {A : Set} {P : ((ClPseudoInverseTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 : (ClPseudoInverseTerm A)) -> ((P x1) -> (P (invCl x1)))) -> (((x1 x2 : (ClPseudoInverseTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClPseudoInverseTerm A)) -> (P x)))))
    inductionCl {_} {p} psing pinvcl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pinvcl popcl (invCl x1) = (pinvcl _ (inductionCl {_} {p} psing pinvcl popcl x1)) 
    inductionCl {_} {p} psing pinvcl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing pinvcl popcl x1) (inductionCl {_} {p} psing pinvcl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpPseudoInverseTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 : (OpPseudoInverseTerm n)) -> ((P x1) -> (P (invOL x1)))) -> (((x1 x2 : (OpPseudoInverseTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpPseudoInverseTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv pinvol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pinvol popol (invOL x1) = (pinvol _ (inductionOpB {_} {p} pv pinvol popol x1)) 
    inductionOpB {_} {p} pv pinvol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv pinvol popol x1) (inductionOpB {_} {p} pv pinvol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpPseudoInverseTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 : (OpPseudoInverseTerm2 n A)) -> ((P x1) -> (P (invOL2 x1)))) -> (((x1 x2 : (OpPseudoInverseTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpPseudoInverseTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 (invOL2 x1) = (pinvol2 _ (inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 x2)) 
    invL' : (PseudoInverseTerm -> PseudoInverseTerm)
    invL' x1 = (invL x1) 
    opL' : (PseudoInverseTerm -> (PseudoInverseTerm -> PseudoInverseTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (PseudoInverseTerm -> (Staged PseudoInverseTerm))
    stageB (invL x1) = (stage1 invL' (codeLift1 invL') (stageB x1)) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    invCl' : {A : Set} -> ((ClPseudoInverseTerm A) -> (ClPseudoInverseTerm A))
    invCl' x1 = (invCl x1) 
    opCl' : {A : Set} -> ((ClPseudoInverseTerm A) -> ((ClPseudoInverseTerm A) -> (ClPseudoInverseTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClPseudoInverseTerm A) -> (Staged (ClPseudoInverseTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (invCl x1) = (stage1 invCl' (codeLift1 invCl') (stageCl x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    invOL' : {n : Nat} -> ((OpPseudoInverseTerm n) -> (OpPseudoInverseTerm n))
    invOL' x1 = (invOL x1) 
    opOL' : {n : Nat} -> ((OpPseudoInverseTerm n) -> ((OpPseudoInverseTerm n) -> (OpPseudoInverseTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpPseudoInverseTerm n) -> (Staged (OpPseudoInverseTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (invOL x1) = (stage1 invOL' (codeLift1 invOL') (stageOpB x1)) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    invOL2' : {n : Nat} {A : Set} -> ((OpPseudoInverseTerm2 n A) -> (OpPseudoInverseTerm2 n A))
    invOL2' x1 = (invOL2 x1) 
    opOL2' : {n : Nat} {A : Set} -> ((OpPseudoInverseTerm2 n A) -> ((OpPseudoInverseTerm2 n A) -> (OpPseudoInverseTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpPseudoInverseTerm2 n A) -> (Staged (OpPseudoInverseTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (invOL2 x1) = (stage1 invOL2' (codeLift1 invOL2') (stageOp x1)) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        invT : ((Repr A) -> (Repr A))
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module PseudoInverseSig  where
    record PseudoInverseSig (A : Set) : Set where
      constructor PseudoInverseSigC
      field
        inv : (A -> A)
        op : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        invS : (AS -> AS)
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        invP : ((Prod A A) -> (Prod A A))
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
    record Hom {A1 : Set} {A2 : Set} (Ps1 : (PseudoInverseSig A1)) (Ps2 : (PseudoInverseSig A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-inv : {x1 : A1} -> (hom ((inv Ps1) x1)) == ((inv Ps2) (hom x1))
        pres-op : {x1 x2 : A1} -> (hom ((op Ps1) x1 x2)) == ((op Ps2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ps1 : (PseudoInverseSig A1)) (Ps2 : (PseudoInverseSig A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-inv : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((inv Ps1) x1) ((inv Ps2) y1)))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Ps1) x1 x2) ((op Ps2) y1 y2))))
    data PseudoInverseSigTerm  : Set where
      invL : (PseudoInverseSigTerm -> PseudoInverseSigTerm)
      opL : (PseudoInverseSigTerm -> (PseudoInverseSigTerm -> PseudoInverseSigTerm))
    data ClPseudoInverseSigTerm (A : Set) : Set where
      sing : (A -> (ClPseudoInverseSigTerm A))
      invCl : ((ClPseudoInverseSigTerm A) -> (ClPseudoInverseSigTerm A))
      opCl : ((ClPseudoInverseSigTerm A) -> ((ClPseudoInverseSigTerm A) -> (ClPseudoInverseSigTerm A)))
    data OpPseudoInverseSigTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpPseudoInverseSigTerm n))
      invOL : ((OpPseudoInverseSigTerm n) -> (OpPseudoInverseSigTerm n))
      opOL : ((OpPseudoInverseSigTerm n) -> ((OpPseudoInverseSigTerm n) -> (OpPseudoInverseSigTerm n)))
    data OpPseudoInverseSigTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpPseudoInverseSigTerm2 n A))
      sing2 : (A -> (OpPseudoInverseSigTerm2 n A))
      invOL2 : ((OpPseudoInverseSigTerm2 n A) -> (OpPseudoInverseSigTerm2 n A))
      opOL2 : ((OpPseudoInverseSigTerm2 n A) -> ((OpPseudoInverseSigTerm2 n A) -> (OpPseudoInverseSigTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClPseudoInverseSigTerm A) -> (ClPseudoInverseSigTerm A))
    simplifyCl (invCl x1) = (invCl (simplifyCl x1)) 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpPseudoInverseSigTerm n) -> (OpPseudoInverseSigTerm n))
    simplifyOpB (invOL x1) = (invOL (simplifyOpB x1)) 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpPseudoInverseSigTerm2 n A) -> (OpPseudoInverseSigTerm2 n A))
    simplifyOp (invOL2 x1) = (invOL2 (simplifyOp x1)) 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((PseudoInverseSig A) -> (PseudoInverseSigTerm -> A))
    evalB Ps (invL x1) = ((inv Ps) (evalB Ps x1)) 
    evalB Ps (opL x1 x2) = ((op Ps) (evalB Ps x1) (evalB Ps x2)) 
    evalCl : {A : Set} -> ((PseudoInverseSig A) -> ((ClPseudoInverseSigTerm A) -> A))
    evalCl Ps (sing x1) = x1 
    evalCl Ps (invCl x1) = ((inv Ps) (evalCl Ps x1)) 
    evalCl Ps (opCl x1 x2) = ((op Ps) (evalCl Ps x1) (evalCl Ps x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((PseudoInverseSig A) -> ((Vec A n) -> ((OpPseudoInverseSigTerm n) -> A)))
    evalOpB Ps vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ps vars (invOL x1) = ((inv Ps) (evalOpB Ps vars x1)) 
    evalOpB Ps vars (opOL x1 x2) = ((op Ps) (evalOpB Ps vars x1) (evalOpB Ps vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((PseudoInverseSig A) -> ((Vec A n) -> ((OpPseudoInverseSigTerm2 n A) -> A)))
    evalOp Ps vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ps vars (sing2 x1) = x1 
    evalOp Ps vars (invOL2 x1) = ((inv Ps) (evalOp Ps vars x1)) 
    evalOp Ps vars (opOL2 x1 x2) = ((op Ps) (evalOp Ps vars x1) (evalOp Ps vars x2)) 
    inductionB : {P : (PseudoInverseSigTerm -> Set)} -> (((x1 : PseudoInverseSigTerm) -> ((P x1) -> (P (invL x1)))) -> (((x1 x2 : PseudoInverseSigTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : PseudoInverseSigTerm) -> (P x))))
    inductionB {p} pinvl popl (invL x1) = (pinvl _ (inductionB {p} pinvl popl x1)) 
    inductionB {p} pinvl popl (opL x1 x2) = (popl _ _ (inductionB {p} pinvl popl x1) (inductionB {p} pinvl popl x2)) 
    inductionCl : {A : Set} {P : ((ClPseudoInverseSigTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 : (ClPseudoInverseSigTerm A)) -> ((P x1) -> (P (invCl x1)))) -> (((x1 x2 : (ClPseudoInverseSigTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClPseudoInverseSigTerm A)) -> (P x)))))
    inductionCl {_} {p} psing pinvcl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pinvcl popcl (invCl x1) = (pinvcl _ (inductionCl {_} {p} psing pinvcl popcl x1)) 
    inductionCl {_} {p} psing pinvcl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing pinvcl popcl x1) (inductionCl {_} {p} psing pinvcl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpPseudoInverseSigTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 : (OpPseudoInverseSigTerm n)) -> ((P x1) -> (P (invOL x1)))) -> (((x1 x2 : (OpPseudoInverseSigTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpPseudoInverseSigTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv pinvol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pinvol popol (invOL x1) = (pinvol _ (inductionOpB {_} {p} pv pinvol popol x1)) 
    inductionOpB {_} {p} pv pinvol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv pinvol popol x1) (inductionOpB {_} {p} pv pinvol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpPseudoInverseSigTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 : (OpPseudoInverseSigTerm2 n A)) -> ((P x1) -> (P (invOL2 x1)))) -> (((x1 x2 : (OpPseudoInverseSigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpPseudoInverseSigTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 (invOL2 x1) = (pinvol2 _ (inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 x2)) 
    invL' : (PseudoInverseSigTerm -> PseudoInverseSigTerm)
    invL' x1 = (invL x1) 
    opL' : (PseudoInverseSigTerm -> (PseudoInverseSigTerm -> PseudoInverseSigTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (PseudoInverseSigTerm -> (Staged PseudoInverseSigTerm))
    stageB (invL x1) = (stage1 invL' (codeLift1 invL') (stageB x1)) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    invCl' : {A : Set} -> ((ClPseudoInverseSigTerm A) -> (ClPseudoInverseSigTerm A))
    invCl' x1 = (invCl x1) 
    opCl' : {A : Set} -> ((ClPseudoInverseSigTerm A) -> ((ClPseudoInverseSigTerm A) -> (ClPseudoInverseSigTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClPseudoInverseSigTerm A) -> (Staged (ClPseudoInverseSigTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (invCl x1) = (stage1 invCl' (codeLift1 invCl') (stageCl x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    invOL' : {n : Nat} -> ((OpPseudoInverseSigTerm n) -> (OpPseudoInverseSigTerm n))
    invOL' x1 = (invOL x1) 
    opOL' : {n : Nat} -> ((OpPseudoInverseSigTerm n) -> ((OpPseudoInverseSigTerm n) -> (OpPseudoInverseSigTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpPseudoInverseSigTerm n) -> (Staged (OpPseudoInverseSigTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (invOL x1) = (stage1 invOL' (codeLift1 invOL') (stageOpB x1)) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    invOL2' : {n : Nat} {A : Set} -> ((OpPseudoInverseSigTerm2 n A) -> (OpPseudoInverseSigTerm2 n A))
    invOL2' x1 = (invOL2 x1) 
    opOL2' : {n : Nat} {A : Set} -> ((OpPseudoInverseSigTerm2 n A) -> ((OpPseudoInverseSigTerm2 n A) -> (OpPseudoInverseSigTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpPseudoInverseSigTerm2 n A) -> (Staged (OpPseudoInverseSigTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (invOL2 x1) = (stage1 invOL2' (codeLift1 invOL2') (stageOp x1)) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        invT : ((Repr A) -> (Repr A))
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module PseudoInvolution  where
    record PseudoInvolution (A : Set) : Set where
      constructor PseudoInvolutionC
      field
        inv : (A -> A)
        op : (A -> (A -> A))
        quasiRightInverse_inv_op_e : {x : A} -> (op (op (inv x) x) (inv x)) == (inv x)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        invS : (AS -> AS)
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        invP : ((Prod A A) -> (Prod A A))
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        quasiRightInverse_inv_op_eP : {xP : (Prod A A)} -> (opP (opP (invP xP) xP) (invP xP)) == (invP xP)
    record Hom {A1 : Set} {A2 : Set} (Ps1 : (PseudoInvolution A1)) (Ps2 : (PseudoInvolution A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-inv : {x1 : A1} -> (hom ((inv Ps1) x1)) == ((inv Ps2) (hom x1))
        pres-op : {x1 x2 : A1} -> (hom ((op Ps1) x1 x2)) == ((op Ps2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ps1 : (PseudoInvolution A1)) (Ps2 : (PseudoInvolution A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-inv : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((inv Ps1) x1) ((inv Ps2) y1)))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Ps1) x1 x2) ((op Ps2) y1 y2))))
    data PseudoInvolutionTerm  : Set where
      invL : (PseudoInvolutionTerm -> PseudoInvolutionTerm)
      opL : (PseudoInvolutionTerm -> (PseudoInvolutionTerm -> PseudoInvolutionTerm))
    data ClPseudoInvolutionTerm (A : Set) : Set where
      sing : (A -> (ClPseudoInvolutionTerm A))
      invCl : ((ClPseudoInvolutionTerm A) -> (ClPseudoInvolutionTerm A))
      opCl : ((ClPseudoInvolutionTerm A) -> ((ClPseudoInvolutionTerm A) -> (ClPseudoInvolutionTerm A)))
    data OpPseudoInvolutionTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpPseudoInvolutionTerm n))
      invOL : ((OpPseudoInvolutionTerm n) -> (OpPseudoInvolutionTerm n))
      opOL : ((OpPseudoInvolutionTerm n) -> ((OpPseudoInvolutionTerm n) -> (OpPseudoInvolutionTerm n)))
    data OpPseudoInvolutionTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpPseudoInvolutionTerm2 n A))
      sing2 : (A -> (OpPseudoInvolutionTerm2 n A))
      invOL2 : ((OpPseudoInvolutionTerm2 n A) -> (OpPseudoInvolutionTerm2 n A))
      opOL2 : ((OpPseudoInvolutionTerm2 n A) -> ((OpPseudoInvolutionTerm2 n A) -> (OpPseudoInvolutionTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClPseudoInvolutionTerm A) -> (ClPseudoInvolutionTerm A))
    simplifyCl (invCl x1) = (invCl (simplifyCl x1)) 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpPseudoInvolutionTerm n) -> (OpPseudoInvolutionTerm n))
    simplifyOpB (invOL x1) = (invOL (simplifyOpB x1)) 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpPseudoInvolutionTerm2 n A) -> (OpPseudoInvolutionTerm2 n A))
    simplifyOp (invOL2 x1) = (invOL2 (simplifyOp x1)) 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((PseudoInvolution A) -> (PseudoInvolutionTerm -> A))
    evalB Ps (invL x1) = ((inv Ps) (evalB Ps x1)) 
    evalB Ps (opL x1 x2) = ((op Ps) (evalB Ps x1) (evalB Ps x2)) 
    evalCl : {A : Set} -> ((PseudoInvolution A) -> ((ClPseudoInvolutionTerm A) -> A))
    evalCl Ps (sing x1) = x1 
    evalCl Ps (invCl x1) = ((inv Ps) (evalCl Ps x1)) 
    evalCl Ps (opCl x1 x2) = ((op Ps) (evalCl Ps x1) (evalCl Ps x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((PseudoInvolution A) -> ((Vec A n) -> ((OpPseudoInvolutionTerm n) -> A)))
    evalOpB Ps vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ps vars (invOL x1) = ((inv Ps) (evalOpB Ps vars x1)) 
    evalOpB Ps vars (opOL x1 x2) = ((op Ps) (evalOpB Ps vars x1) (evalOpB Ps vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((PseudoInvolution A) -> ((Vec A n) -> ((OpPseudoInvolutionTerm2 n A) -> A)))
    evalOp Ps vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ps vars (sing2 x1) = x1 
    evalOp Ps vars (invOL2 x1) = ((inv Ps) (evalOp Ps vars x1)) 
    evalOp Ps vars (opOL2 x1 x2) = ((op Ps) (evalOp Ps vars x1) (evalOp Ps vars x2)) 
    inductionB : {P : (PseudoInvolutionTerm -> Set)} -> (((x1 : PseudoInvolutionTerm) -> ((P x1) -> (P (invL x1)))) -> (((x1 x2 : PseudoInvolutionTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : PseudoInvolutionTerm) -> (P x))))
    inductionB {p} pinvl popl (invL x1) = (pinvl _ (inductionB {p} pinvl popl x1)) 
    inductionB {p} pinvl popl (opL x1 x2) = (popl _ _ (inductionB {p} pinvl popl x1) (inductionB {p} pinvl popl x2)) 
    inductionCl : {A : Set} {P : ((ClPseudoInvolutionTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 : (ClPseudoInvolutionTerm A)) -> ((P x1) -> (P (invCl x1)))) -> (((x1 x2 : (ClPseudoInvolutionTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClPseudoInvolutionTerm A)) -> (P x)))))
    inductionCl {_} {p} psing pinvcl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pinvcl popcl (invCl x1) = (pinvcl _ (inductionCl {_} {p} psing pinvcl popcl x1)) 
    inductionCl {_} {p} psing pinvcl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing pinvcl popcl x1) (inductionCl {_} {p} psing pinvcl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpPseudoInvolutionTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 : (OpPseudoInvolutionTerm n)) -> ((P x1) -> (P (invOL x1)))) -> (((x1 x2 : (OpPseudoInvolutionTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpPseudoInvolutionTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv pinvol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pinvol popol (invOL x1) = (pinvol _ (inductionOpB {_} {p} pv pinvol popol x1)) 
    inductionOpB {_} {p} pv pinvol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv pinvol popol x1) (inductionOpB {_} {p} pv pinvol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpPseudoInvolutionTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 : (OpPseudoInvolutionTerm2 n A)) -> ((P x1) -> (P (invOL2 x1)))) -> (((x1 x2 : (OpPseudoInvolutionTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpPseudoInvolutionTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 (invOL2 x1) = (pinvol2 _ (inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 x2)) 
    invL' : (PseudoInvolutionTerm -> PseudoInvolutionTerm)
    invL' x1 = (invL x1) 
    opL' : (PseudoInvolutionTerm -> (PseudoInvolutionTerm -> PseudoInvolutionTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (PseudoInvolutionTerm -> (Staged PseudoInvolutionTerm))
    stageB (invL x1) = (stage1 invL' (codeLift1 invL') (stageB x1)) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    invCl' : {A : Set} -> ((ClPseudoInvolutionTerm A) -> (ClPseudoInvolutionTerm A))
    invCl' x1 = (invCl x1) 
    opCl' : {A : Set} -> ((ClPseudoInvolutionTerm A) -> ((ClPseudoInvolutionTerm A) -> (ClPseudoInvolutionTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClPseudoInvolutionTerm A) -> (Staged (ClPseudoInvolutionTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (invCl x1) = (stage1 invCl' (codeLift1 invCl') (stageCl x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    invOL' : {n : Nat} -> ((OpPseudoInvolutionTerm n) -> (OpPseudoInvolutionTerm n))
    invOL' x1 = (invOL x1) 
    opOL' : {n : Nat} -> ((OpPseudoInvolutionTerm n) -> ((OpPseudoInvolutionTerm n) -> (OpPseudoInvolutionTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpPseudoInvolutionTerm n) -> (Staged (OpPseudoInvolutionTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (invOL x1) = (stage1 invOL' (codeLift1 invOL') (stageOpB x1)) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    invOL2' : {n : Nat} {A : Set} -> ((OpPseudoInvolutionTerm2 n A) -> (OpPseudoInvolutionTerm2 n A))
    invOL2' x1 = (invOL2 x1) 
    opOL2' : {n : Nat} {A : Set} -> ((OpPseudoInvolutionTerm2 n A) -> ((OpPseudoInvolutionTerm2 n A) -> (OpPseudoInvolutionTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpPseudoInvolutionTerm2 n A) -> (Staged (OpPseudoInvolutionTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (invOL2 x1) = (stage1 invOL2' (codeLift1 invOL2') (stageOp x1)) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        invT : ((Repr A) -> (Repr A))
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module Quandle  where
    record Quandle (A : Set) : Set where
      constructor QuandleC
      field
        |> : (A -> (A -> A))
        <| : (A -> (A -> A))
        leftDistributive : {x y z : A} -> (|> x (|> y z)) == (|> (|> x y) (|> x z))
        rightDistributive : {x y z : A} -> (<| (<| y z) x) == (<| (<| y x) (<| z x))
        leftInverse : {x y : A} -> (<| (|> x y) x) == y
        rightInverse : {x y : A} -> (|> x (<| y x)) == y
        idempotent_|> : {x : A} -> (|> x x) == x
        idempotent_<| : {x : A} -> (<| x x) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        |>S : (AS -> (AS -> AS))
        <|S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        |>P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        <|P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftDistributiveP : {xP yP zP : (Prod A A)} -> (|>P xP (|>P yP zP)) == (|>P (|>P xP yP) (|>P xP zP))
        rightDistributiveP : {xP yP zP : (Prod A A)} -> (<|P (<|P yP zP) xP) == (<|P (<|P yP xP) (<|P zP xP))
        leftInverseP : {xP yP : (Prod A A)} -> (<|P (|>P xP yP) xP) == yP
        rightInverseP : {xP yP : (Prod A A)} -> (|>P xP (<|P yP xP)) == yP
        idempotent_|>P : {xP : (Prod A A)} -> (|>P xP xP) == xP
        idempotent_<|P : {xP : (Prod A A)} -> (<|P xP xP) == xP
    record Hom {A1 : Set} {A2 : Set} (Qu1 : (Quandle A1)) (Qu2 : (Quandle A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-|> : {x1 x2 : A1} -> (hom ((|> Qu1) x1 x2)) == ((|> Qu2) (hom x1) (hom x2))
        pres-<| : {x1 x2 : A1} -> (hom ((<| Qu1) x1 x2)) == ((<| Qu2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Qu1 : (Quandle A1)) (Qu2 : (Quandle A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-|> : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((|> Qu1) x1 x2) ((|> Qu2) y1 y2))))
        interp-<| : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((<| Qu1) x1 x2) ((<| Qu2) y1 y2))))
    data QuandleTerm  : Set where
      |>L : (QuandleTerm -> (QuandleTerm -> QuandleTerm))
      <|L : (QuandleTerm -> (QuandleTerm -> QuandleTerm))
    data ClQuandleTerm (A : Set) : Set where
      sing : (A -> (ClQuandleTerm A))
      |>Cl : ((ClQuandleTerm A) -> ((ClQuandleTerm A) -> (ClQuandleTerm A)))
      <|Cl : ((ClQuandleTerm A) -> ((ClQuandleTerm A) -> (ClQuandleTerm A)))
    data OpQuandleTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpQuandleTerm n))
      |>OL : ((OpQuandleTerm n) -> ((OpQuandleTerm n) -> (OpQuandleTerm n)))
      <|OL : ((OpQuandleTerm n) -> ((OpQuandleTerm n) -> (OpQuandleTerm n)))
    data OpQuandleTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpQuandleTerm2 n A))
      sing2 : (A -> (OpQuandleTerm2 n A))
      |>OL2 : ((OpQuandleTerm2 n A) -> ((OpQuandleTerm2 n A) -> (OpQuandleTerm2 n A)))
      <|OL2 : ((OpQuandleTerm2 n A) -> ((OpQuandleTerm2 n A) -> (OpQuandleTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClQuandleTerm A) -> (ClQuandleTerm A))
    simplifyCl (|>Cl x1 x2) = (|>Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (<|Cl x1 x2) = (<|Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpQuandleTerm n) -> (OpQuandleTerm n))
    simplifyOpB (|>OL x1 x2) = (|>OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (<|OL x1 x2) = (<|OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpQuandleTerm2 n A) -> (OpQuandleTerm2 n A))
    simplifyOp (|>OL2 x1 x2) = (|>OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (<|OL2 x1 x2) = (<|OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Quandle A) -> (QuandleTerm -> A))
    evalB Qu (|>L x1 x2) = ((|> Qu) (evalB Qu x1) (evalB Qu x2)) 
    evalB Qu (<|L x1 x2) = ((<| Qu) (evalB Qu x1) (evalB Qu x2)) 
    evalCl : {A : Set} -> ((Quandle A) -> ((ClQuandleTerm A) -> A))
    evalCl Qu (sing x1) = x1 
    evalCl Qu (|>Cl x1 x2) = ((|> Qu) (evalCl Qu x1) (evalCl Qu x2)) 
    evalCl Qu (<|Cl x1 x2) = ((<| Qu) (evalCl Qu x1) (evalCl Qu x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Quandle A) -> ((Vec A n) -> ((OpQuandleTerm n) -> A)))
    evalOpB Qu vars (v x1) = (lookup _ x1 vars) 
    evalOpB Qu vars (|>OL x1 x2) = ((|> Qu) (evalOpB Qu vars x1) (evalOpB Qu vars x2)) 
    evalOpB Qu vars (<|OL x1 x2) = ((<| Qu) (evalOpB Qu vars x1) (evalOpB Qu vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Quandle A) -> ((Vec A n) -> ((OpQuandleTerm2 n A) -> A)))
    evalOp Qu vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Qu vars (sing2 x1) = x1 
    evalOp Qu vars (|>OL2 x1 x2) = ((|> Qu) (evalOp Qu vars x1) (evalOp Qu vars x2)) 
    evalOp Qu vars (<|OL2 x1 x2) = ((<| Qu) (evalOp Qu vars x1) (evalOp Qu vars x2)) 
    inductionB : {P : (QuandleTerm -> Set)} -> (((x1 x2 : QuandleTerm) -> ((P x1) -> ((P x2) -> (P (|>L x1 x2))))) -> (((x1 x2 : QuandleTerm) -> ((P x1) -> ((P x2) -> (P (<|L x1 x2))))) -> ((x : QuandleTerm) -> (P x))))
    inductionB {p} p|>l p<|l (|>L x1 x2) = (p|>l _ _ (inductionB {p} p|>l p<|l x1) (inductionB {p} p|>l p<|l x2)) 
    inductionB {p} p|>l p<|l (<|L x1 x2) = (p<|l _ _ (inductionB {p} p|>l p<|l x1) (inductionB {p} p|>l p<|l x2)) 
    inductionCl : {A : Set} {P : ((ClQuandleTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClQuandleTerm A)) -> ((P x1) -> ((P x2) -> (P (|>Cl x1 x2))))) -> (((x1 x2 : (ClQuandleTerm A)) -> ((P x1) -> ((P x2) -> (P (<|Cl x1 x2))))) -> ((x : (ClQuandleTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p|>cl p<|cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p|>cl p<|cl (|>Cl x1 x2) = (p|>cl _ _ (inductionCl {_} {p} psing p|>cl p<|cl x1) (inductionCl {_} {p} psing p|>cl p<|cl x2)) 
    inductionCl {_} {p} psing p|>cl p<|cl (<|Cl x1 x2) = (p<|cl _ _ (inductionCl {_} {p} psing p|>cl p<|cl x1) (inductionCl {_} {p} psing p|>cl p<|cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpQuandleTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpQuandleTerm n)) -> ((P x1) -> ((P x2) -> (P (|>OL x1 x2))))) -> (((x1 x2 : (OpQuandleTerm n)) -> ((P x1) -> ((P x2) -> (P (<|OL x1 x2))))) -> ((x : (OpQuandleTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p|>ol p<|ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p|>ol p<|ol (|>OL x1 x2) = (p|>ol _ _ (inductionOpB {_} {p} pv p|>ol p<|ol x1) (inductionOpB {_} {p} pv p|>ol p<|ol x2)) 
    inductionOpB {_} {p} pv p|>ol p<|ol (<|OL x1 x2) = (p<|ol _ _ (inductionOpB {_} {p} pv p|>ol p<|ol x1) (inductionOpB {_} {p} pv p|>ol p<|ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpQuandleTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpQuandleTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (|>OL2 x1 x2))))) -> (((x1 x2 : (OpQuandleTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (<|OL2 x1 x2))))) -> ((x : (OpQuandleTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (|>OL2 x1 x2) = (p|>ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (<|OL2 x1 x2) = (p<|ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x2)) 
    |>L' : (QuandleTerm -> (QuandleTerm -> QuandleTerm))
    |>L' x1 x2 = (|>L x1 x2) 
    <|L' : (QuandleTerm -> (QuandleTerm -> QuandleTerm))
    <|L' x1 x2 = (<|L x1 x2) 
    stageB : (QuandleTerm -> (Staged QuandleTerm))
    stageB (|>L x1 x2) = (stage2 |>L' (codeLift2 |>L') (stageB x1) (stageB x2)) 
    stageB (<|L x1 x2) = (stage2 <|L' (codeLift2 <|L') (stageB x1) (stageB x2)) 
    |>Cl' : {A : Set} -> ((ClQuandleTerm A) -> ((ClQuandleTerm A) -> (ClQuandleTerm A)))
    |>Cl' x1 x2 = (|>Cl x1 x2) 
    <|Cl' : {A : Set} -> ((ClQuandleTerm A) -> ((ClQuandleTerm A) -> (ClQuandleTerm A)))
    <|Cl' x1 x2 = (<|Cl x1 x2) 
    stageCl : {A : Set} -> ((ClQuandleTerm A) -> (Staged (ClQuandleTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (|>Cl x1 x2) = (stage2 |>Cl' (codeLift2 |>Cl') (stageCl x1) (stageCl x2)) 
    stageCl (<|Cl x1 x2) = (stage2 <|Cl' (codeLift2 <|Cl') (stageCl x1) (stageCl x2)) 
    |>OL' : {n : Nat} -> ((OpQuandleTerm n) -> ((OpQuandleTerm n) -> (OpQuandleTerm n)))
    |>OL' x1 x2 = (|>OL x1 x2) 
    <|OL' : {n : Nat} -> ((OpQuandleTerm n) -> ((OpQuandleTerm n) -> (OpQuandleTerm n)))
    <|OL' x1 x2 = (<|OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpQuandleTerm n) -> (Staged (OpQuandleTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (|>OL x1 x2) = (stage2 |>OL' (codeLift2 |>OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (<|OL x1 x2) = (stage2 <|OL' (codeLift2 <|OL') (stageOpB x1) (stageOpB x2)) 
    |>OL2' : {n : Nat} {A : Set} -> ((OpQuandleTerm2 n A) -> ((OpQuandleTerm2 n A) -> (OpQuandleTerm2 n A)))
    |>OL2' x1 x2 = (|>OL2 x1 x2) 
    <|OL2' : {n : Nat} {A : Set} -> ((OpQuandleTerm2 n A) -> ((OpQuandleTerm2 n A) -> (OpQuandleTerm2 n A)))
    <|OL2' x1 x2 = (<|OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpQuandleTerm2 n A) -> (Staged (OpQuandleTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (|>OL2 x1 x2) = (stage2 |>OL2' (codeLift2 |>OL2') (stageOp x1) (stageOp x2)) 
    stageOp (<|OL2 x1 x2) = (stage2 <|OL2' (codeLift2 <|OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        |>T : ((Repr A) -> ((Repr A) -> (Repr A)))
        <|T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module QuasiGroup  where
    record QuasiGroup (A : Set) : Set where
      constructor QuasiGroupC
      field
        op : (A -> (A -> A))
        linv : (A -> (A -> A))
        leftCancel : {x y : A} -> (op x (linv x y)) == y
        lefCancelOp : {x y : A} -> (linv x (op x y)) == y
        rinv : (A -> (A -> A))
        rightCancel : {x y : A} -> (op (rinv y x) x) == y
        rightCancelOp : {x y : A} -> (rinv (op y x) x) == y
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        linvS : (AS -> (AS -> AS))
        rinvS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        linvP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        rinvP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftCancelP : {xP yP : (Prod A A)} -> (opP xP (linvP xP yP)) == yP
        lefCancelOpP : {xP yP : (Prod A A)} -> (linvP xP (opP xP yP)) == yP
        rightCancelP : {xP yP : (Prod A A)} -> (opP (rinvP yP xP) xP) == yP
        rightCancelOpP : {xP yP : (Prod A A)} -> (rinvP (opP yP xP) xP) == yP
    record Hom {A1 : Set} {A2 : Set} (Qu1 : (QuasiGroup A1)) (Qu2 : (QuasiGroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Qu1) x1 x2)) == ((op Qu2) (hom x1) (hom x2))
        pres-linv : {x1 x2 : A1} -> (hom ((linv Qu1) x1 x2)) == ((linv Qu2) (hom x1) (hom x2))
        pres-rinv : {x1 x2 : A1} -> (hom ((rinv Qu1) x1 x2)) == ((rinv Qu2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Qu1 : (QuasiGroup A1)) (Qu2 : (QuasiGroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Qu1) x1 x2) ((op Qu2) y1 y2))))
        interp-linv : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((linv Qu1) x1 x2) ((linv Qu2) y1 y2))))
        interp-rinv : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((rinv Qu1) x1 x2) ((rinv Qu2) y1 y2))))
    data QuasiGroupTerm  : Set where
      opL : (QuasiGroupTerm -> (QuasiGroupTerm -> QuasiGroupTerm))
      linvL : (QuasiGroupTerm -> (QuasiGroupTerm -> QuasiGroupTerm))
      rinvL : (QuasiGroupTerm -> (QuasiGroupTerm -> QuasiGroupTerm))
    data ClQuasiGroupTerm (A : Set) : Set where
      sing : (A -> (ClQuasiGroupTerm A))
      opCl : ((ClQuasiGroupTerm A) -> ((ClQuasiGroupTerm A) -> (ClQuasiGroupTerm A)))
      linvCl : ((ClQuasiGroupTerm A) -> ((ClQuasiGroupTerm A) -> (ClQuasiGroupTerm A)))
      rinvCl : ((ClQuasiGroupTerm A) -> ((ClQuasiGroupTerm A) -> (ClQuasiGroupTerm A)))
    data OpQuasiGroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpQuasiGroupTerm n))
      opOL : ((OpQuasiGroupTerm n) -> ((OpQuasiGroupTerm n) -> (OpQuasiGroupTerm n)))
      linvOL : ((OpQuasiGroupTerm n) -> ((OpQuasiGroupTerm n) -> (OpQuasiGroupTerm n)))
      rinvOL : ((OpQuasiGroupTerm n) -> ((OpQuasiGroupTerm n) -> (OpQuasiGroupTerm n)))
    data OpQuasiGroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpQuasiGroupTerm2 n A))
      sing2 : (A -> (OpQuasiGroupTerm2 n A))
      opOL2 : ((OpQuasiGroupTerm2 n A) -> ((OpQuasiGroupTerm2 n A) -> (OpQuasiGroupTerm2 n A)))
      linvOL2 : ((OpQuasiGroupTerm2 n A) -> ((OpQuasiGroupTerm2 n A) -> (OpQuasiGroupTerm2 n A)))
      rinvOL2 : ((OpQuasiGroupTerm2 n A) -> ((OpQuasiGroupTerm2 n A) -> (OpQuasiGroupTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClQuasiGroupTerm A) -> (ClQuasiGroupTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (linvCl x1 x2) = (linvCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (rinvCl x1 x2) = (rinvCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpQuasiGroupTerm n) -> (OpQuasiGroupTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (linvOL x1 x2) = (linvOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (rinvOL x1 x2) = (rinvOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpQuasiGroupTerm2 n A) -> (OpQuasiGroupTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (linvOL2 x1 x2) = (linvOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (rinvOL2 x1 x2) = (rinvOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((QuasiGroup A) -> (QuasiGroupTerm -> A))
    evalB Qu (opL x1 x2) = ((op Qu) (evalB Qu x1) (evalB Qu x2)) 
    evalB Qu (linvL x1 x2) = ((linv Qu) (evalB Qu x1) (evalB Qu x2)) 
    evalB Qu (rinvL x1 x2) = ((rinv Qu) (evalB Qu x1) (evalB Qu x2)) 
    evalCl : {A : Set} -> ((QuasiGroup A) -> ((ClQuasiGroupTerm A) -> A))
    evalCl Qu (sing x1) = x1 
    evalCl Qu (opCl x1 x2) = ((op Qu) (evalCl Qu x1) (evalCl Qu x2)) 
    evalCl Qu (linvCl x1 x2) = ((linv Qu) (evalCl Qu x1) (evalCl Qu x2)) 
    evalCl Qu (rinvCl x1 x2) = ((rinv Qu) (evalCl Qu x1) (evalCl Qu x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((QuasiGroup A) -> ((Vec A n) -> ((OpQuasiGroupTerm n) -> A)))
    evalOpB Qu vars (v x1) = (lookup _ x1 vars) 
    evalOpB Qu vars (opOL x1 x2) = ((op Qu) (evalOpB Qu vars x1) (evalOpB Qu vars x2)) 
    evalOpB Qu vars (linvOL x1 x2) = ((linv Qu) (evalOpB Qu vars x1) (evalOpB Qu vars x2)) 
    evalOpB Qu vars (rinvOL x1 x2) = ((rinv Qu) (evalOpB Qu vars x1) (evalOpB Qu vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((QuasiGroup A) -> ((Vec A n) -> ((OpQuasiGroupTerm2 n A) -> A)))
    evalOp Qu vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Qu vars (sing2 x1) = x1 
    evalOp Qu vars (opOL2 x1 x2) = ((op Qu) (evalOp Qu vars x1) (evalOp Qu vars x2)) 
    evalOp Qu vars (linvOL2 x1 x2) = ((linv Qu) (evalOp Qu vars x1) (evalOp Qu vars x2)) 
    evalOp Qu vars (rinvOL2 x1 x2) = ((rinv Qu) (evalOp Qu vars x1) (evalOp Qu vars x2)) 
    inductionB : {P : (QuasiGroupTerm -> Set)} -> (((x1 x2 : QuasiGroupTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> (((x1 x2 : QuasiGroupTerm) -> ((P x1) -> ((P x2) -> (P (linvL x1 x2))))) -> (((x1 x2 : QuasiGroupTerm) -> ((P x1) -> ((P x2) -> (P (rinvL x1 x2))))) -> ((x : QuasiGroupTerm) -> (P x)))))
    inductionB {p} popl plinvl prinvl (opL x1 x2) = (popl _ _ (inductionB {p} popl plinvl prinvl x1) (inductionB {p} popl plinvl prinvl x2)) 
    inductionB {p} popl plinvl prinvl (linvL x1 x2) = (plinvl _ _ (inductionB {p} popl plinvl prinvl x1) (inductionB {p} popl plinvl prinvl x2)) 
    inductionB {p} popl plinvl prinvl (rinvL x1 x2) = (prinvl _ _ (inductionB {p} popl plinvl prinvl x1) (inductionB {p} popl plinvl prinvl x2)) 
    inductionCl : {A : Set} {P : ((ClQuasiGroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClQuasiGroupTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> (((x1 x2 : (ClQuasiGroupTerm A)) -> ((P x1) -> ((P x2) -> (P (linvCl x1 x2))))) -> (((x1 x2 : (ClQuasiGroupTerm A)) -> ((P x1) -> ((P x2) -> (P (rinvCl x1 x2))))) -> ((x : (ClQuasiGroupTerm A)) -> (P x))))))
    inductionCl {_} {p} psing popcl plinvcl prinvcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl plinvcl prinvcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl plinvcl prinvcl x1) (inductionCl {_} {p} psing popcl plinvcl prinvcl x2)) 
    inductionCl {_} {p} psing popcl plinvcl prinvcl (linvCl x1 x2) = (plinvcl _ _ (inductionCl {_} {p} psing popcl plinvcl prinvcl x1) (inductionCl {_} {p} psing popcl plinvcl prinvcl x2)) 
    inductionCl {_} {p} psing popcl plinvcl prinvcl (rinvCl x1 x2) = (prinvcl _ _ (inductionCl {_} {p} psing popcl plinvcl prinvcl x1) (inductionCl {_} {p} psing popcl plinvcl prinvcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpQuasiGroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpQuasiGroupTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> (((x1 x2 : (OpQuasiGroupTerm n)) -> ((P x1) -> ((P x2) -> (P (linvOL x1 x2))))) -> (((x1 x2 : (OpQuasiGroupTerm n)) -> ((P x1) -> ((P x2) -> (P (rinvOL x1 x2))))) -> ((x : (OpQuasiGroupTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv popol plinvol prinvol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol plinvol prinvol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol plinvol prinvol x1) (inductionOpB {_} {p} pv popol plinvol prinvol x2)) 
    inductionOpB {_} {p} pv popol plinvol prinvol (linvOL x1 x2) = (plinvol _ _ (inductionOpB {_} {p} pv popol plinvol prinvol x1) (inductionOpB {_} {p} pv popol plinvol prinvol x2)) 
    inductionOpB {_} {p} pv popol plinvol prinvol (rinvOL x1 x2) = (prinvol _ _ (inductionOpB {_} {p} pv popol plinvol prinvol x1) (inductionOpB {_} {p} pv popol plinvol prinvol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpQuasiGroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpQuasiGroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> (((x1 x2 : (OpQuasiGroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (linvOL2 x1 x2))))) -> (((x1 x2 : (OpQuasiGroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (rinvOL2 x1 x2))))) -> ((x : (OpQuasiGroupTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 (linvOL2 x1 x2) = (plinvol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 (rinvOL2 x1 x2) = (prinvol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 plinvol2 prinvol2 x2)) 
    opL' : (QuasiGroupTerm -> (QuasiGroupTerm -> QuasiGroupTerm))
    opL' x1 x2 = (opL x1 x2) 
    linvL' : (QuasiGroupTerm -> (QuasiGroupTerm -> QuasiGroupTerm))
    linvL' x1 x2 = (linvL x1 x2) 
    rinvL' : (QuasiGroupTerm -> (QuasiGroupTerm -> QuasiGroupTerm))
    rinvL' x1 x2 = (rinvL x1 x2) 
    stageB : (QuasiGroupTerm -> (Staged QuasiGroupTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB (linvL x1 x2) = (stage2 linvL' (codeLift2 linvL') (stageB x1) (stageB x2)) 
    stageB (rinvL x1 x2) = (stage2 rinvL' (codeLift2 rinvL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClQuasiGroupTerm A) -> ((ClQuasiGroupTerm A) -> (ClQuasiGroupTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    linvCl' : {A : Set} -> ((ClQuasiGroupTerm A) -> ((ClQuasiGroupTerm A) -> (ClQuasiGroupTerm A)))
    linvCl' x1 x2 = (linvCl x1 x2) 
    rinvCl' : {A : Set} -> ((ClQuasiGroupTerm A) -> ((ClQuasiGroupTerm A) -> (ClQuasiGroupTerm A)))
    rinvCl' x1 x2 = (rinvCl x1 x2) 
    stageCl : {A : Set} -> ((ClQuasiGroupTerm A) -> (Staged (ClQuasiGroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl (linvCl x1 x2) = (stage2 linvCl' (codeLift2 linvCl') (stageCl x1) (stageCl x2)) 
    stageCl (rinvCl x1 x2) = (stage2 rinvCl' (codeLift2 rinvCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpQuasiGroupTerm n) -> ((OpQuasiGroupTerm n) -> (OpQuasiGroupTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    linvOL' : {n : Nat} -> ((OpQuasiGroupTerm n) -> ((OpQuasiGroupTerm n) -> (OpQuasiGroupTerm n)))
    linvOL' x1 x2 = (linvOL x1 x2) 
    rinvOL' : {n : Nat} -> ((OpQuasiGroupTerm n) -> ((OpQuasiGroupTerm n) -> (OpQuasiGroupTerm n)))
    rinvOL' x1 x2 = (rinvOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpQuasiGroupTerm n) -> (Staged (OpQuasiGroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (linvOL x1 x2) = (stage2 linvOL' (codeLift2 linvOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (rinvOL x1 x2) = (stage2 rinvOL' (codeLift2 rinvOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpQuasiGroupTerm2 n A) -> ((OpQuasiGroupTerm2 n A) -> (OpQuasiGroupTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    linvOL2' : {n : Nat} {A : Set} -> ((OpQuasiGroupTerm2 n A) -> ((OpQuasiGroupTerm2 n A) -> (OpQuasiGroupTerm2 n A)))
    linvOL2' x1 x2 = (linvOL2 x1 x2) 
    rinvOL2' : {n : Nat} {A : Set} -> ((OpQuasiGroupTerm2 n A) -> ((OpQuasiGroupTerm2 n A) -> (OpQuasiGroupTerm2 n A)))
    rinvOL2' x1 x2 = (rinvOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpQuasiGroupTerm2 n A) -> (Staged (OpQuasiGroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp (linvOL2 x1 x2) = (stage2 linvOL2' (codeLift2 linvOL2') (stageOp x1) (stageOp x2)) 
    stageOp (rinvOL2 x1 x2) = (stage2 rinvOL2' (codeLift2 rinvOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        linvT : ((Repr A) -> ((Repr A) -> (Repr A)))
        rinvT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module QuasiInverse  where
    record QuasiInverse (A : Set) : Set where
      constructor QuasiInverseC
      field
        inv : (A -> A)
        op : (A -> (A -> A))
        quasiInverse_inv_op_e : {x : A} -> (op (op x (inv x)) x) == x
        quasiRightInverse_inv_op_e : {x : A} -> (op (op (inv x) x) (inv x)) == (inv x)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        invS : (AS -> AS)
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        invP : ((Prod A A) -> (Prod A A))
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        quasiInverse_inv_op_eP : {xP : (Prod A A)} -> (opP (opP xP (invP xP)) xP) == xP
        quasiRightInverse_inv_op_eP : {xP : (Prod A A)} -> (opP (opP (invP xP) xP) (invP xP)) == (invP xP)
    record Hom {A1 : Set} {A2 : Set} (Qu1 : (QuasiInverse A1)) (Qu2 : (QuasiInverse A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-inv : {x1 : A1} -> (hom ((inv Qu1) x1)) == ((inv Qu2) (hom x1))
        pres-op : {x1 x2 : A1} -> (hom ((op Qu1) x1 x2)) == ((op Qu2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Qu1 : (QuasiInverse A1)) (Qu2 : (QuasiInverse A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-inv : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((inv Qu1) x1) ((inv Qu2) y1)))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Qu1) x1 x2) ((op Qu2) y1 y2))))
    data QuasiInverseTerm  : Set where
      invL : (QuasiInverseTerm -> QuasiInverseTerm)
      opL : (QuasiInverseTerm -> (QuasiInverseTerm -> QuasiInverseTerm))
    data ClQuasiInverseTerm (A : Set) : Set where
      sing : (A -> (ClQuasiInverseTerm A))
      invCl : ((ClQuasiInverseTerm A) -> (ClQuasiInverseTerm A))
      opCl : ((ClQuasiInverseTerm A) -> ((ClQuasiInverseTerm A) -> (ClQuasiInverseTerm A)))
    data OpQuasiInverseTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpQuasiInverseTerm n))
      invOL : ((OpQuasiInverseTerm n) -> (OpQuasiInverseTerm n))
      opOL : ((OpQuasiInverseTerm n) -> ((OpQuasiInverseTerm n) -> (OpQuasiInverseTerm n)))
    data OpQuasiInverseTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpQuasiInverseTerm2 n A))
      sing2 : (A -> (OpQuasiInverseTerm2 n A))
      invOL2 : ((OpQuasiInverseTerm2 n A) -> (OpQuasiInverseTerm2 n A))
      opOL2 : ((OpQuasiInverseTerm2 n A) -> ((OpQuasiInverseTerm2 n A) -> (OpQuasiInverseTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClQuasiInverseTerm A) -> (ClQuasiInverseTerm A))
    simplifyCl (invCl x1) = (invCl (simplifyCl x1)) 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpQuasiInverseTerm n) -> (OpQuasiInverseTerm n))
    simplifyOpB (invOL x1) = (invOL (simplifyOpB x1)) 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpQuasiInverseTerm2 n A) -> (OpQuasiInverseTerm2 n A))
    simplifyOp (invOL2 x1) = (invOL2 (simplifyOp x1)) 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((QuasiInverse A) -> (QuasiInverseTerm -> A))
    evalB Qu (invL x1) = ((inv Qu) (evalB Qu x1)) 
    evalB Qu (opL x1 x2) = ((op Qu) (evalB Qu x1) (evalB Qu x2)) 
    evalCl : {A : Set} -> ((QuasiInverse A) -> ((ClQuasiInverseTerm A) -> A))
    evalCl Qu (sing x1) = x1 
    evalCl Qu (invCl x1) = ((inv Qu) (evalCl Qu x1)) 
    evalCl Qu (opCl x1 x2) = ((op Qu) (evalCl Qu x1) (evalCl Qu x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((QuasiInverse A) -> ((Vec A n) -> ((OpQuasiInverseTerm n) -> A)))
    evalOpB Qu vars (v x1) = (lookup _ x1 vars) 
    evalOpB Qu vars (invOL x1) = ((inv Qu) (evalOpB Qu vars x1)) 
    evalOpB Qu vars (opOL x1 x2) = ((op Qu) (evalOpB Qu vars x1) (evalOpB Qu vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((QuasiInverse A) -> ((Vec A n) -> ((OpQuasiInverseTerm2 n A) -> A)))
    evalOp Qu vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Qu vars (sing2 x1) = x1 
    evalOp Qu vars (invOL2 x1) = ((inv Qu) (evalOp Qu vars x1)) 
    evalOp Qu vars (opOL2 x1 x2) = ((op Qu) (evalOp Qu vars x1) (evalOp Qu vars x2)) 
    inductionB : {P : (QuasiInverseTerm -> Set)} -> (((x1 : QuasiInverseTerm) -> ((P x1) -> (P (invL x1)))) -> (((x1 x2 : QuasiInverseTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : QuasiInverseTerm) -> (P x))))
    inductionB {p} pinvl popl (invL x1) = (pinvl _ (inductionB {p} pinvl popl x1)) 
    inductionB {p} pinvl popl (opL x1 x2) = (popl _ _ (inductionB {p} pinvl popl x1) (inductionB {p} pinvl popl x2)) 
    inductionCl : {A : Set} {P : ((ClQuasiInverseTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 : (ClQuasiInverseTerm A)) -> ((P x1) -> (P (invCl x1)))) -> (((x1 x2 : (ClQuasiInverseTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClQuasiInverseTerm A)) -> (P x)))))
    inductionCl {_} {p} psing pinvcl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pinvcl popcl (invCl x1) = (pinvcl _ (inductionCl {_} {p} psing pinvcl popcl x1)) 
    inductionCl {_} {p} psing pinvcl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing pinvcl popcl x1) (inductionCl {_} {p} psing pinvcl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpQuasiInverseTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 : (OpQuasiInverseTerm n)) -> ((P x1) -> (P (invOL x1)))) -> (((x1 x2 : (OpQuasiInverseTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpQuasiInverseTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv pinvol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pinvol popol (invOL x1) = (pinvol _ (inductionOpB {_} {p} pv pinvol popol x1)) 
    inductionOpB {_} {p} pv pinvol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv pinvol popol x1) (inductionOpB {_} {p} pv pinvol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpQuasiInverseTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 : (OpQuasiInverseTerm2 n A)) -> ((P x1) -> (P (invOL2 x1)))) -> (((x1 x2 : (OpQuasiInverseTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpQuasiInverseTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 (invOL2 x1) = (pinvol2 _ (inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 pinvol2 popol2 x2)) 
    invL' : (QuasiInverseTerm -> QuasiInverseTerm)
    invL' x1 = (invL x1) 
    opL' : (QuasiInverseTerm -> (QuasiInverseTerm -> QuasiInverseTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (QuasiInverseTerm -> (Staged QuasiInverseTerm))
    stageB (invL x1) = (stage1 invL' (codeLift1 invL') (stageB x1)) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    invCl' : {A : Set} -> ((ClQuasiInverseTerm A) -> (ClQuasiInverseTerm A))
    invCl' x1 = (invCl x1) 
    opCl' : {A : Set} -> ((ClQuasiInverseTerm A) -> ((ClQuasiInverseTerm A) -> (ClQuasiInverseTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClQuasiInverseTerm A) -> (Staged (ClQuasiInverseTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (invCl x1) = (stage1 invCl' (codeLift1 invCl') (stageCl x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    invOL' : {n : Nat} -> ((OpQuasiInverseTerm n) -> (OpQuasiInverseTerm n))
    invOL' x1 = (invOL x1) 
    opOL' : {n : Nat} -> ((OpQuasiInverseTerm n) -> ((OpQuasiInverseTerm n) -> (OpQuasiInverseTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpQuasiInverseTerm n) -> (Staged (OpQuasiInverseTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (invOL x1) = (stage1 invOL' (codeLift1 invOL') (stageOpB x1)) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    invOL2' : {n : Nat} {A : Set} -> ((OpQuasiInverseTerm2 n A) -> (OpQuasiInverseTerm2 n A))
    invOL2' x1 = (invOL2 x1) 
    opOL2' : {n : Nat} {A : Set} -> ((OpQuasiInverseTerm2 n A) -> ((OpQuasiInverseTerm2 n A) -> (OpQuasiInverseTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpQuasiInverseTerm2 n A) -> (Staged (OpQuasiInverseTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (invOL2 x1) = (stage1 invOL2' (codeLift1 invOL2') (stageOp x1)) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        invT : ((Repr A) -> (Repr A))
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module Rack  where
    record Rack (A : Set) : Set where
      constructor RackC
      field
        |> : (A -> (A -> A))
        <| : (A -> (A -> A))
        leftDistributive : {x y z : A} -> (|> x (|> y z)) == (|> (|> x y) (|> x z))
        rightDistributive : {x y z : A} -> (<| (<| y z) x) == (<| (<| y x) (<| z x))
        leftInverse : {x y : A} -> (<| (|> x y) x) == y
        rightInverse : {x y : A} -> (|> x (<| y x)) == y
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        |>S : (AS -> (AS -> AS))
        <|S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        |>P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        <|P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftDistributiveP : {xP yP zP : (Prod A A)} -> (|>P xP (|>P yP zP)) == (|>P (|>P xP yP) (|>P xP zP))
        rightDistributiveP : {xP yP zP : (Prod A A)} -> (<|P (<|P yP zP) xP) == (<|P (<|P yP xP) (<|P zP xP))
        leftInverseP : {xP yP : (Prod A A)} -> (<|P (|>P xP yP) xP) == yP
        rightInverseP : {xP yP : (Prod A A)} -> (|>P xP (<|P yP xP)) == yP
    record Hom {A1 : Set} {A2 : Set} (Ra1 : (Rack A1)) (Ra2 : (Rack A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-|> : {x1 x2 : A1} -> (hom ((|> Ra1) x1 x2)) == ((|> Ra2) (hom x1) (hom x2))
        pres-<| : {x1 x2 : A1} -> (hom ((<| Ra1) x1 x2)) == ((<| Ra2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ra1 : (Rack A1)) (Ra2 : (Rack A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-|> : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((|> Ra1) x1 x2) ((|> Ra2) y1 y2))))
        interp-<| : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((<| Ra1) x1 x2) ((<| Ra2) y1 y2))))
    data RackTerm  : Set where
      |>L : (RackTerm -> (RackTerm -> RackTerm))
      <|L : (RackTerm -> (RackTerm -> RackTerm))
    data ClRackTerm (A : Set) : Set where
      sing : (A -> (ClRackTerm A))
      |>Cl : ((ClRackTerm A) -> ((ClRackTerm A) -> (ClRackTerm A)))
      <|Cl : ((ClRackTerm A) -> ((ClRackTerm A) -> (ClRackTerm A)))
    data OpRackTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRackTerm n))
      |>OL : ((OpRackTerm n) -> ((OpRackTerm n) -> (OpRackTerm n)))
      <|OL : ((OpRackTerm n) -> ((OpRackTerm n) -> (OpRackTerm n)))
    data OpRackTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRackTerm2 n A))
      sing2 : (A -> (OpRackTerm2 n A))
      |>OL2 : ((OpRackTerm2 n A) -> ((OpRackTerm2 n A) -> (OpRackTerm2 n A)))
      <|OL2 : ((OpRackTerm2 n A) -> ((OpRackTerm2 n A) -> (OpRackTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRackTerm A) -> (ClRackTerm A))
    simplifyCl (|>Cl x1 x2) = (|>Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (<|Cl x1 x2) = (<|Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRackTerm n) -> (OpRackTerm n))
    simplifyOpB (|>OL x1 x2) = (|>OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (<|OL x1 x2) = (<|OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRackTerm2 n A) -> (OpRackTerm2 n A))
    simplifyOp (|>OL2 x1 x2) = (|>OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (<|OL2 x1 x2) = (<|OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Rack A) -> (RackTerm -> A))
    evalB Ra (|>L x1 x2) = ((|> Ra) (evalB Ra x1) (evalB Ra x2)) 
    evalB Ra (<|L x1 x2) = ((<| Ra) (evalB Ra x1) (evalB Ra x2)) 
    evalCl : {A : Set} -> ((Rack A) -> ((ClRackTerm A) -> A))
    evalCl Ra (sing x1) = x1 
    evalCl Ra (|>Cl x1 x2) = ((|> Ra) (evalCl Ra x1) (evalCl Ra x2)) 
    evalCl Ra (<|Cl x1 x2) = ((<| Ra) (evalCl Ra x1) (evalCl Ra x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Rack A) -> ((Vec A n) -> ((OpRackTerm n) -> A)))
    evalOpB Ra vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ra vars (|>OL x1 x2) = ((|> Ra) (evalOpB Ra vars x1) (evalOpB Ra vars x2)) 
    evalOpB Ra vars (<|OL x1 x2) = ((<| Ra) (evalOpB Ra vars x1) (evalOpB Ra vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Rack A) -> ((Vec A n) -> ((OpRackTerm2 n A) -> A)))
    evalOp Ra vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ra vars (sing2 x1) = x1 
    evalOp Ra vars (|>OL2 x1 x2) = ((|> Ra) (evalOp Ra vars x1) (evalOp Ra vars x2)) 
    evalOp Ra vars (<|OL2 x1 x2) = ((<| Ra) (evalOp Ra vars x1) (evalOp Ra vars x2)) 
    inductionB : {P : (RackTerm -> Set)} -> (((x1 x2 : RackTerm) -> ((P x1) -> ((P x2) -> (P (|>L x1 x2))))) -> (((x1 x2 : RackTerm) -> ((P x1) -> ((P x2) -> (P (<|L x1 x2))))) -> ((x : RackTerm) -> (P x))))
    inductionB {p} p|>l p<|l (|>L x1 x2) = (p|>l _ _ (inductionB {p} p|>l p<|l x1) (inductionB {p} p|>l p<|l x2)) 
    inductionB {p} p|>l p<|l (<|L x1 x2) = (p<|l _ _ (inductionB {p} p|>l p<|l x1) (inductionB {p} p|>l p<|l x2)) 
    inductionCl : {A : Set} {P : ((ClRackTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRackTerm A)) -> ((P x1) -> ((P x2) -> (P (|>Cl x1 x2))))) -> (((x1 x2 : (ClRackTerm A)) -> ((P x1) -> ((P x2) -> (P (<|Cl x1 x2))))) -> ((x : (ClRackTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p|>cl p<|cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p|>cl p<|cl (|>Cl x1 x2) = (p|>cl _ _ (inductionCl {_} {p} psing p|>cl p<|cl x1) (inductionCl {_} {p} psing p|>cl p<|cl x2)) 
    inductionCl {_} {p} psing p|>cl p<|cl (<|Cl x1 x2) = (p<|cl _ _ (inductionCl {_} {p} psing p|>cl p<|cl x1) (inductionCl {_} {p} psing p|>cl p<|cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRackTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRackTerm n)) -> ((P x1) -> ((P x2) -> (P (|>OL x1 x2))))) -> (((x1 x2 : (OpRackTerm n)) -> ((P x1) -> ((P x2) -> (P (<|OL x1 x2))))) -> ((x : (OpRackTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p|>ol p<|ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p|>ol p<|ol (|>OL x1 x2) = (p|>ol _ _ (inductionOpB {_} {p} pv p|>ol p<|ol x1) (inductionOpB {_} {p} pv p|>ol p<|ol x2)) 
    inductionOpB {_} {p} pv p|>ol p<|ol (<|OL x1 x2) = (p<|ol _ _ (inductionOpB {_} {p} pv p|>ol p<|ol x1) (inductionOpB {_} {p} pv p|>ol p<|ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRackTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRackTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (|>OL2 x1 x2))))) -> (((x1 x2 : (OpRackTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (<|OL2 x1 x2))))) -> ((x : (OpRackTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (|>OL2 x1 x2) = (p|>ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (<|OL2 x1 x2) = (p<|ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x2)) 
    |>L' : (RackTerm -> (RackTerm -> RackTerm))
    |>L' x1 x2 = (|>L x1 x2) 
    <|L' : (RackTerm -> (RackTerm -> RackTerm))
    <|L' x1 x2 = (<|L x1 x2) 
    stageB : (RackTerm -> (Staged RackTerm))
    stageB (|>L x1 x2) = (stage2 |>L' (codeLift2 |>L') (stageB x1) (stageB x2)) 
    stageB (<|L x1 x2) = (stage2 <|L' (codeLift2 <|L') (stageB x1) (stageB x2)) 
    |>Cl' : {A : Set} -> ((ClRackTerm A) -> ((ClRackTerm A) -> (ClRackTerm A)))
    |>Cl' x1 x2 = (|>Cl x1 x2) 
    <|Cl' : {A : Set} -> ((ClRackTerm A) -> ((ClRackTerm A) -> (ClRackTerm A)))
    <|Cl' x1 x2 = (<|Cl x1 x2) 
    stageCl : {A : Set} -> ((ClRackTerm A) -> (Staged (ClRackTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (|>Cl x1 x2) = (stage2 |>Cl' (codeLift2 |>Cl') (stageCl x1) (stageCl x2)) 
    stageCl (<|Cl x1 x2) = (stage2 <|Cl' (codeLift2 <|Cl') (stageCl x1) (stageCl x2)) 
    |>OL' : {n : Nat} -> ((OpRackTerm n) -> ((OpRackTerm n) -> (OpRackTerm n)))
    |>OL' x1 x2 = (|>OL x1 x2) 
    <|OL' : {n : Nat} -> ((OpRackTerm n) -> ((OpRackTerm n) -> (OpRackTerm n)))
    <|OL' x1 x2 = (<|OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRackTerm n) -> (Staged (OpRackTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (|>OL x1 x2) = (stage2 |>OL' (codeLift2 |>OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (<|OL x1 x2) = (stage2 <|OL' (codeLift2 <|OL') (stageOpB x1) (stageOpB x2)) 
    |>OL2' : {n : Nat} {A : Set} -> ((OpRackTerm2 n A) -> ((OpRackTerm2 n A) -> (OpRackTerm2 n A)))
    |>OL2' x1 x2 = (|>OL2 x1 x2) 
    <|OL2' : {n : Nat} {A : Set} -> ((OpRackTerm2 n A) -> ((OpRackTerm2 n A) -> (OpRackTerm2 n A)))
    <|OL2' x1 x2 = (<|OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRackTerm2 n A) -> (Staged (OpRackTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (|>OL2 x1 x2) = (stage2 |>OL2' (codeLift2 |>OL2') (stageOp x1) (stageOp x2)) 
    stageOp (<|OL2 x1 x2) = (stage2 <|OL2' (codeLift2 <|OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        |>T : ((Repr A) -> ((Repr A) -> (Repr A)))
        <|T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RectangularBand  where
    record RectangularBand (A : Set) : Set where
      constructor RectangularBandC
      field
        op : (A -> (A -> A))
        associative_op : {x y z : A} -> (op (op x y) z) == (op x (op y z))
        idempotent_op : {x : A} -> (op x x) == x
        middleCommute_* : {x y z : A} -> (op (op (op x y) z) x) == (op (op (op x z) y) x)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        associative_opP : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP (opP yP zP))
        idempotent_opP : {xP : (Prod A A)} -> (opP xP xP) == xP
        middleCommute_*P : {xP yP zP : (Prod A A)} -> (opP (opP (opP xP yP) zP) xP) == (opP (opP (opP xP zP) yP) xP)
    record Hom {A1 : Set} {A2 : Set} (Re1 : (RectangularBand A1)) (Re2 : (RectangularBand A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Re1) x1 x2)) == ((op Re2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Re1 : (RectangularBand A1)) (Re2 : (RectangularBand A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Re1) x1 x2) ((op Re2) y1 y2))))
    data RectangularBandTerm  : Set where
      opL : (RectangularBandTerm -> (RectangularBandTerm -> RectangularBandTerm))
    data ClRectangularBandTerm (A : Set) : Set where
      sing : (A -> (ClRectangularBandTerm A))
      opCl : ((ClRectangularBandTerm A) -> ((ClRectangularBandTerm A) -> (ClRectangularBandTerm A)))
    data OpRectangularBandTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRectangularBandTerm n))
      opOL : ((OpRectangularBandTerm n) -> ((OpRectangularBandTerm n) -> (OpRectangularBandTerm n)))
    data OpRectangularBandTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRectangularBandTerm2 n A))
      sing2 : (A -> (OpRectangularBandTerm2 n A))
      opOL2 : ((OpRectangularBandTerm2 n A) -> ((OpRectangularBandTerm2 n A) -> (OpRectangularBandTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRectangularBandTerm A) -> (ClRectangularBandTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRectangularBandTerm n) -> (OpRectangularBandTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRectangularBandTerm2 n A) -> (OpRectangularBandTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RectangularBand A) -> (RectangularBandTerm -> A))
    evalB Re (opL x1 x2) = ((op Re) (evalB Re x1) (evalB Re x2)) 
    evalCl : {A : Set} -> ((RectangularBand A) -> ((ClRectangularBandTerm A) -> A))
    evalCl Re (sing x1) = x1 
    evalCl Re (opCl x1 x2) = ((op Re) (evalCl Re x1) (evalCl Re x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((RectangularBand A) -> ((Vec A n) -> ((OpRectangularBandTerm n) -> A)))
    evalOpB Re vars (v x1) = (lookup _ x1 vars) 
    evalOpB Re vars (opOL x1 x2) = ((op Re) (evalOpB Re vars x1) (evalOpB Re vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((RectangularBand A) -> ((Vec A n) -> ((OpRectangularBandTerm2 n A) -> A)))
    evalOp Re vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Re vars (sing2 x1) = x1 
    evalOp Re vars (opOL2 x1 x2) = ((op Re) (evalOp Re vars x1) (evalOp Re vars x2)) 
    inductionB : {P : (RectangularBandTerm -> Set)} -> (((x1 x2 : RectangularBandTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : RectangularBandTerm) -> (P x)))
    inductionB {p} popl (opL x1 x2) = (popl _ _ (inductionB {p} popl x1) (inductionB {p} popl x2)) 
    inductionCl : {A : Set} {P : ((ClRectangularBandTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRectangularBandTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClRectangularBandTerm A)) -> (P x))))
    inductionCl {_} {p} psing popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl x1) (inductionCl {_} {p} psing popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRectangularBandTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRectangularBandTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpRectangularBandTerm n)) -> (P x))))
    inductionOpB {_} {p} pv popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol x1) (inductionOpB {_} {p} pv popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRectangularBandTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRectangularBandTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpRectangularBandTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 x2)) 
    opL' : (RectangularBandTerm -> (RectangularBandTerm -> RectangularBandTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (RectangularBandTerm -> (Staged RectangularBandTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClRectangularBandTerm A) -> ((ClRectangularBandTerm A) -> (ClRectangularBandTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClRectangularBandTerm A) -> (Staged (ClRectangularBandTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpRectangularBandTerm n) -> ((OpRectangularBandTerm n) -> (OpRectangularBandTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRectangularBandTerm n) -> (Staged (OpRectangularBandTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpRectangularBandTerm2 n A) -> ((OpRectangularBandTerm2 n A) -> (OpRectangularBandTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRectangularBandTerm2 n A) -> (Staged (OpRectangularBandTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RegularSemigroup  where
    record RegularSemigroup (A : Set) : Set where
      constructor RegularSemigroupC
      field
        op : (A -> (A -> A))
        associative_op : {x y z : A} -> (op (op x y) z) == (op x (op y z))
        inv : (A -> A)
        quasiInverse_inv_op_e : {x : A} -> (op (op x (inv x)) x) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        invS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        invP : ((Prod A A) -> (Prod A A))
        associative_opP : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP (opP yP zP))
        quasiInverse_inv_op_eP : {xP : (Prod A A)} -> (opP (opP xP (invP xP)) xP) == xP
    record Hom {A1 : Set} {A2 : Set} (Re1 : (RegularSemigroup A1)) (Re2 : (RegularSemigroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Re1) x1 x2)) == ((op Re2) (hom x1) (hom x2))
        pres-inv : {x1 : A1} -> (hom ((inv Re1) x1)) == ((inv Re2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (Re1 : (RegularSemigroup A1)) (Re2 : (RegularSemigroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Re1) x1 x2) ((op Re2) y1 y2))))
        interp-inv : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((inv Re1) x1) ((inv Re2) y1)))
    data RegularSemigroupTerm  : Set where
      opL : (RegularSemigroupTerm -> (RegularSemigroupTerm -> RegularSemigroupTerm))
      invL : (RegularSemigroupTerm -> RegularSemigroupTerm)
    data ClRegularSemigroupTerm (A : Set) : Set where
      sing : (A -> (ClRegularSemigroupTerm A))
      opCl : ((ClRegularSemigroupTerm A) -> ((ClRegularSemigroupTerm A) -> (ClRegularSemigroupTerm A)))
      invCl : ((ClRegularSemigroupTerm A) -> (ClRegularSemigroupTerm A))
    data OpRegularSemigroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRegularSemigroupTerm n))
      opOL : ((OpRegularSemigroupTerm n) -> ((OpRegularSemigroupTerm n) -> (OpRegularSemigroupTerm n)))
      invOL : ((OpRegularSemigroupTerm n) -> (OpRegularSemigroupTerm n))
    data OpRegularSemigroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRegularSemigroupTerm2 n A))
      sing2 : (A -> (OpRegularSemigroupTerm2 n A))
      opOL2 : ((OpRegularSemigroupTerm2 n A) -> ((OpRegularSemigroupTerm2 n A) -> (OpRegularSemigroupTerm2 n A)))
      invOL2 : ((OpRegularSemigroupTerm2 n A) -> (OpRegularSemigroupTerm2 n A))
    simplifyCl : {A : Set} -> ((ClRegularSemigroupTerm A) -> (ClRegularSemigroupTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (invCl x1) = (invCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRegularSemigroupTerm n) -> (OpRegularSemigroupTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (invOL x1) = (invOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRegularSemigroupTerm2 n A) -> (OpRegularSemigroupTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (invOL2 x1) = (invOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RegularSemigroup A) -> (RegularSemigroupTerm -> A))
    evalB Re (opL x1 x2) = ((op Re) (evalB Re x1) (evalB Re x2)) 
    evalB Re (invL x1) = ((inv Re) (evalB Re x1)) 
    evalCl : {A : Set} -> ((RegularSemigroup A) -> ((ClRegularSemigroupTerm A) -> A))
    evalCl Re (sing x1) = x1 
    evalCl Re (opCl x1 x2) = ((op Re) (evalCl Re x1) (evalCl Re x2)) 
    evalCl Re (invCl x1) = ((inv Re) (evalCl Re x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((RegularSemigroup A) -> ((Vec A n) -> ((OpRegularSemigroupTerm n) -> A)))
    evalOpB Re vars (v x1) = (lookup _ x1 vars) 
    evalOpB Re vars (opOL x1 x2) = ((op Re) (evalOpB Re vars x1) (evalOpB Re vars x2)) 
    evalOpB Re vars (invOL x1) = ((inv Re) (evalOpB Re vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((RegularSemigroup A) -> ((Vec A n) -> ((OpRegularSemigroupTerm2 n A) -> A)))
    evalOp Re vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Re vars (sing2 x1) = x1 
    evalOp Re vars (opOL2 x1 x2) = ((op Re) (evalOp Re vars x1) (evalOp Re vars x2)) 
    evalOp Re vars (invOL2 x1) = ((inv Re) (evalOp Re vars x1)) 
    inductionB : {P : (RegularSemigroupTerm -> Set)} -> (((x1 x2 : RegularSemigroupTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> (((x1 : RegularSemigroupTerm) -> ((P x1) -> (P (invL x1)))) -> ((x : RegularSemigroupTerm) -> (P x))))
    inductionB {p} popl pinvl (opL x1 x2) = (popl _ _ (inductionB {p} popl pinvl x1) (inductionB {p} popl pinvl x2)) 
    inductionB {p} popl pinvl (invL x1) = (pinvl _ (inductionB {p} popl pinvl x1)) 
    inductionCl : {A : Set} {P : ((ClRegularSemigroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRegularSemigroupTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> (((x1 : (ClRegularSemigroupTerm A)) -> ((P x1) -> (P (invCl x1)))) -> ((x : (ClRegularSemigroupTerm A)) -> (P x)))))
    inductionCl {_} {p} psing popcl pinvcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl pinvcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl pinvcl x1) (inductionCl {_} {p} psing popcl pinvcl x2)) 
    inductionCl {_} {p} psing popcl pinvcl (invCl x1) = (pinvcl _ (inductionCl {_} {p} psing popcl pinvcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpRegularSemigroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRegularSemigroupTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> (((x1 : (OpRegularSemigroupTerm n)) -> ((P x1) -> (P (invOL x1)))) -> ((x : (OpRegularSemigroupTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv popol pinvol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol pinvol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol pinvol x1) (inductionOpB {_} {p} pv popol pinvol x2)) 
    inductionOpB {_} {p} pv popol pinvol (invOL x1) = (pinvol _ (inductionOpB {_} {p} pv popol pinvol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRegularSemigroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRegularSemigroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> (((x1 : (OpRegularSemigroupTerm2 n A)) -> ((P x1) -> (P (invOL2 x1)))) -> ((x : (OpRegularSemigroupTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 pinvol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 pinvol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 pinvol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 pinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 pinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 pinvol2 (invOL2 x1) = (pinvol2 _ (inductionOp {_} {_} {p} pv2 psing2 popol2 pinvol2 x1)) 
    opL' : (RegularSemigroupTerm -> (RegularSemigroupTerm -> RegularSemigroupTerm))
    opL' x1 x2 = (opL x1 x2) 
    invL' : (RegularSemigroupTerm -> RegularSemigroupTerm)
    invL' x1 = (invL x1) 
    stageB : (RegularSemigroupTerm -> (Staged RegularSemigroupTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB (invL x1) = (stage1 invL' (codeLift1 invL') (stageB x1)) 
    opCl' : {A : Set} -> ((ClRegularSemigroupTerm A) -> ((ClRegularSemigroupTerm A) -> (ClRegularSemigroupTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    invCl' : {A : Set} -> ((ClRegularSemigroupTerm A) -> (ClRegularSemigroupTerm A))
    invCl' x1 = (invCl x1) 
    stageCl : {A : Set} -> ((ClRegularSemigroupTerm A) -> (Staged (ClRegularSemigroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl (invCl x1) = (stage1 invCl' (codeLift1 invCl') (stageCl x1)) 
    opOL' : {n : Nat} -> ((OpRegularSemigroupTerm n) -> ((OpRegularSemigroupTerm n) -> (OpRegularSemigroupTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    invOL' : {n : Nat} -> ((OpRegularSemigroupTerm n) -> (OpRegularSemigroupTerm n))
    invOL' x1 = (invOL x1) 
    stageOpB : {n : Nat} -> ((OpRegularSemigroupTerm n) -> (Staged (OpRegularSemigroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (invOL x1) = (stage1 invOL' (codeLift1 invOL') (stageOpB x1)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpRegularSemigroupTerm2 n A) -> ((OpRegularSemigroupTerm2 n A) -> (OpRegularSemigroupTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    invOL2' : {n : Nat} {A : Set} -> ((OpRegularSemigroupTerm2 n A) -> (OpRegularSemigroupTerm2 n A))
    invOL2' x1 = (invOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpRegularSemigroupTerm2 n A) -> (Staged (OpRegularSemigroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp (invOL2 x1) = (stage1 invOL2' (codeLift1 invOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        invT : ((Repr A) -> (Repr A))
  module Right0  where
    record Right0 (A : Set) : Set where
      constructor Right0C
      field
        0 : A
        op : (A -> (A -> A))
        rightZero_op_0 : {x : A} -> (op x 0) == 0
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        0S : AS
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        0P : (Prod A A)
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        rightZero_op_0P : {xP : (Prod A A)} -> (opP xP 0P) == 0P
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (Right0 A1)) (Ri2 : (Right0 A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-0 : (hom (0 Ri1)) == (0 Ri2)
        pres-op : {x1 x2 : A1} -> (hom ((op Ri1) x1 x2)) == ((op Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (Right0 A1)) (Ri2 : (Right0 A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-0 : (interp (0 Ri1) (0 Ri2))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Ri1) x1 x2) ((op Ri2) y1 y2))))
    data Right0LTerm  : Set where
      0L : Right0LTerm
      opL : (Right0LTerm -> (Right0LTerm -> Right0LTerm))
    data ClRight0ClTerm (A : Set) : Set where
      sing : (A -> (ClRight0ClTerm A))
      0Cl : (ClRight0ClTerm A)
      opCl : ((ClRight0ClTerm A) -> ((ClRight0ClTerm A) -> (ClRight0ClTerm A)))
    data OpRight0OLTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRight0OLTerm n))
      0OL : (OpRight0OLTerm n)
      opOL : ((OpRight0OLTerm n) -> ((OpRight0OLTerm n) -> (OpRight0OLTerm n)))
    data OpRight0OL2Term2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRight0OL2Term2 n A))
      sing2 : (A -> (OpRight0OL2Term2 n A))
      0OL2 : (OpRight0OL2Term2 n A)
      opOL2 : ((OpRight0OL2Term2 n A) -> ((OpRight0OL2Term2 n A) -> (OpRight0OL2Term2 n A)))
    simplifyCl : {A : Set} -> ((ClRight0ClTerm A) -> (ClRight0ClTerm A))
    simplifyCl 0Cl = 0Cl 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRight0OLTerm n) -> (OpRight0OLTerm n))
    simplifyOpB 0OL = 0OL 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRight0OL2Term2 n A) -> (OpRight0OL2Term2 n A))
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Right0 A) -> (Right0LTerm -> A))
    evalB Ri 0L = (0 Ri) 
    evalB Ri (opL x1 x2) = ((op Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((Right0 A) -> ((ClRight0ClTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri 0Cl = (0 Ri) 
    evalCl Ri (opCl x1 x2) = ((op Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Right0 A) -> ((Vec A n) -> ((OpRight0OLTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars 0OL = (0 Ri) 
    evalOpB Ri vars (opOL x1 x2) = ((op Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Right0 A) -> ((Vec A n) -> ((OpRight0OL2Term2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars 0OL2 = (0 Ri) 
    evalOp Ri vars (opOL2 x1 x2) = ((op Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (Right0LTerm -> Set)} -> ((P 0L) -> (((x1 x2 : Right0LTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : Right0LTerm) -> (P x))))
    inductionB {p} p0l popl 0L = p0l 
    inductionB {p} p0l popl (opL x1 x2) = (popl _ _ (inductionB {p} p0l popl x1) (inductionB {p} p0l popl x2)) 
    inductionCl : {A : Set} {P : ((ClRight0ClTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 0Cl) -> (((x1 x2 : (ClRight0ClTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClRight0ClTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p0cl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p0cl popcl 0Cl = p0cl 
    inductionCl {_} {p} psing p0cl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing p0cl popcl x1) (inductionCl {_} {p} psing p0cl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRight0OLTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 0OL) -> (((x1 x2 : (OpRight0OLTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpRight0OLTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p0ol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p0ol popol 0OL = p0ol 
    inductionOpB {_} {p} pv p0ol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv p0ol popol x1) (inductionOpB {_} {p} pv p0ol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRight0OL2Term2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 0OL2) -> (((x1 x2 : (OpRight0OL2Term2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpRight0OL2Term2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 popol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p0ol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p0ol2 popol2 x2)) 
    0L' : Right0LTerm
    0L'  = 0L 
    opL' : (Right0LTerm -> (Right0LTerm -> Right0LTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (Right0LTerm -> (Staged Right0LTerm))
    stageB 0L = (Now 0L) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    0Cl' : {A : Set} -> (ClRight0ClTerm A)
    0Cl'  = 0Cl 
    opCl' : {A : Set} -> ((ClRight0ClTerm A) -> ((ClRight0ClTerm A) -> (ClRight0ClTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClRight0ClTerm A) -> (Staged (ClRight0ClTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    0OL' : {n : Nat} -> (OpRight0OLTerm n)
    0OL'  = 0OL 
    opOL' : {n : Nat} -> ((OpRight0OLTerm n) -> ((OpRight0OLTerm n) -> (OpRight0OLTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRight0OLTerm n) -> (Staged (OpRight0OLTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    0OL2' : {n : Nat} {A : Set} -> (OpRight0OL2Term2 n A)
    0OL2'  = 0OL2 
    opOL2' : {n : Nat} {A : Set} -> ((OpRight0OL2Term2 n A) -> ((OpRight0OL2Term2 n A) -> (OpRight0OL2Term2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRight0OL2Term2 n A) -> (Staged (OpRight0OL2Term2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        0T : (Repr A)
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RightBiMagma  where
    record RightBiMagma (A : Set) : Set where
      constructor RightBiMagmaC
      field
        op : (A -> (A -> A))
        rinv : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        rinvS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        rinvP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RightBiMagma A1)) (Ri2 : (RightBiMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Ri1) x1 x2)) == ((op Ri2) (hom x1) (hom x2))
        pres-rinv : {x1 x2 : A1} -> (hom ((rinv Ri1) x1 x2)) == ((rinv Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RightBiMagma A1)) (Ri2 : (RightBiMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Ri1) x1 x2) ((op Ri2) y1 y2))))
        interp-rinv : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((rinv Ri1) x1 x2) ((rinv Ri2) y1 y2))))
    data RightBiMagmaTerm  : Set where
      opL : (RightBiMagmaTerm -> (RightBiMagmaTerm -> RightBiMagmaTerm))
      rinvL : (RightBiMagmaTerm -> (RightBiMagmaTerm -> RightBiMagmaTerm))
    data ClRightBiMagmaTerm (A : Set) : Set where
      sing : (A -> (ClRightBiMagmaTerm A))
      opCl : ((ClRightBiMagmaTerm A) -> ((ClRightBiMagmaTerm A) -> (ClRightBiMagmaTerm A)))
      rinvCl : ((ClRightBiMagmaTerm A) -> ((ClRightBiMagmaTerm A) -> (ClRightBiMagmaTerm A)))
    data OpRightBiMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRightBiMagmaTerm n))
      opOL : ((OpRightBiMagmaTerm n) -> ((OpRightBiMagmaTerm n) -> (OpRightBiMagmaTerm n)))
      rinvOL : ((OpRightBiMagmaTerm n) -> ((OpRightBiMagmaTerm n) -> (OpRightBiMagmaTerm n)))
    data OpRightBiMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRightBiMagmaTerm2 n A))
      sing2 : (A -> (OpRightBiMagmaTerm2 n A))
      opOL2 : ((OpRightBiMagmaTerm2 n A) -> ((OpRightBiMagmaTerm2 n A) -> (OpRightBiMagmaTerm2 n A)))
      rinvOL2 : ((OpRightBiMagmaTerm2 n A) -> ((OpRightBiMagmaTerm2 n A) -> (OpRightBiMagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRightBiMagmaTerm A) -> (ClRightBiMagmaTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (rinvCl x1 x2) = (rinvCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRightBiMagmaTerm n) -> (OpRightBiMagmaTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (rinvOL x1 x2) = (rinvOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRightBiMagmaTerm2 n A) -> (OpRightBiMagmaTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (rinvOL2 x1 x2) = (rinvOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RightBiMagma A) -> (RightBiMagmaTerm -> A))
    evalB Ri (opL x1 x2) = ((op Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalB Ri (rinvL x1 x2) = ((rinv Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((RightBiMagma A) -> ((ClRightBiMagmaTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (opCl x1 x2) = ((op Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalCl Ri (rinvCl x1 x2) = ((rinv Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((RightBiMagma A) -> ((Vec A n) -> ((OpRightBiMagmaTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (opOL x1 x2) = ((op Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOpB Ri vars (rinvOL x1 x2) = ((rinv Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((RightBiMagma A) -> ((Vec A n) -> ((OpRightBiMagmaTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (opOL2 x1 x2) = ((op Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    evalOp Ri vars (rinvOL2 x1 x2) = ((rinv Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (RightBiMagmaTerm -> Set)} -> (((x1 x2 : RightBiMagmaTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> (((x1 x2 : RightBiMagmaTerm) -> ((P x1) -> ((P x2) -> (P (rinvL x1 x2))))) -> ((x : RightBiMagmaTerm) -> (P x))))
    inductionB {p} popl prinvl (opL x1 x2) = (popl _ _ (inductionB {p} popl prinvl x1) (inductionB {p} popl prinvl x2)) 
    inductionB {p} popl prinvl (rinvL x1 x2) = (prinvl _ _ (inductionB {p} popl prinvl x1) (inductionB {p} popl prinvl x2)) 
    inductionCl : {A : Set} {P : ((ClRightBiMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRightBiMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> (((x1 x2 : (ClRightBiMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (rinvCl x1 x2))))) -> ((x : (ClRightBiMagmaTerm A)) -> (P x)))))
    inductionCl {_} {p} psing popcl prinvcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl prinvcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl prinvcl x1) (inductionCl {_} {p} psing popcl prinvcl x2)) 
    inductionCl {_} {p} psing popcl prinvcl (rinvCl x1 x2) = (prinvcl _ _ (inductionCl {_} {p} psing popcl prinvcl x1) (inductionCl {_} {p} psing popcl prinvcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRightBiMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRightBiMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> (((x1 x2 : (OpRightBiMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (rinvOL x1 x2))))) -> ((x : (OpRightBiMagmaTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv popol prinvol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol prinvol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol prinvol x1) (inductionOpB {_} {p} pv popol prinvol x2)) 
    inductionOpB {_} {p} pv popol prinvol (rinvOL x1 x2) = (prinvol _ _ (inductionOpB {_} {p} pv popol prinvol x1) (inductionOpB {_} {p} pv popol prinvol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRightBiMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRightBiMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> (((x1 x2 : (OpRightBiMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (rinvOL2 x1 x2))))) -> ((x : (OpRightBiMagmaTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 (rinvOL2 x1 x2) = (prinvol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 x2)) 
    opL' : (RightBiMagmaTerm -> (RightBiMagmaTerm -> RightBiMagmaTerm))
    opL' x1 x2 = (opL x1 x2) 
    rinvL' : (RightBiMagmaTerm -> (RightBiMagmaTerm -> RightBiMagmaTerm))
    rinvL' x1 x2 = (rinvL x1 x2) 
    stageB : (RightBiMagmaTerm -> (Staged RightBiMagmaTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB (rinvL x1 x2) = (stage2 rinvL' (codeLift2 rinvL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClRightBiMagmaTerm A) -> ((ClRightBiMagmaTerm A) -> (ClRightBiMagmaTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    rinvCl' : {A : Set} -> ((ClRightBiMagmaTerm A) -> ((ClRightBiMagmaTerm A) -> (ClRightBiMagmaTerm A)))
    rinvCl' x1 x2 = (rinvCl x1 x2) 
    stageCl : {A : Set} -> ((ClRightBiMagmaTerm A) -> (Staged (ClRightBiMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl (rinvCl x1 x2) = (stage2 rinvCl' (codeLift2 rinvCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpRightBiMagmaTerm n) -> ((OpRightBiMagmaTerm n) -> (OpRightBiMagmaTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    rinvOL' : {n : Nat} -> ((OpRightBiMagmaTerm n) -> ((OpRightBiMagmaTerm n) -> (OpRightBiMagmaTerm n)))
    rinvOL' x1 x2 = (rinvOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRightBiMagmaTerm n) -> (Staged (OpRightBiMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (rinvOL x1 x2) = (stage2 rinvOL' (codeLift2 rinvOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpRightBiMagmaTerm2 n A) -> ((OpRightBiMagmaTerm2 n A) -> (OpRightBiMagmaTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    rinvOL2' : {n : Nat} {A : Set} -> ((OpRightBiMagmaTerm2 n A) -> ((OpRightBiMagmaTerm2 n A) -> (OpRightBiMagmaTerm2 n A)))
    rinvOL2' x1 x2 = (rinvOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRightBiMagmaTerm2 n A) -> (Staged (OpRightBiMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp (rinvOL2 x1 x2) = (stage2 rinvOL2' (codeLift2 rinvOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        rinvT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RightBinaryInverse  where
    record RightBinaryInverse (A : Set) : Set where
      constructor RightBinaryInverseC
      field
        |> : (A -> (A -> A))
        <| : (A -> (A -> A))
        rightInverse : {x y : A} -> (|> x (<| y x)) == y
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        |>S : (AS -> (AS -> AS))
        <|S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        |>P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        <|P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        rightInverseP : {xP yP : (Prod A A)} -> (|>P xP (<|P yP xP)) == yP
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RightBinaryInverse A1)) (Ri2 : (RightBinaryInverse A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-|> : {x1 x2 : A1} -> (hom ((|> Ri1) x1 x2)) == ((|> Ri2) (hom x1) (hom x2))
        pres-<| : {x1 x2 : A1} -> (hom ((<| Ri1) x1 x2)) == ((<| Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RightBinaryInverse A1)) (Ri2 : (RightBinaryInverse A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-|> : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((|> Ri1) x1 x2) ((|> Ri2) y1 y2))))
        interp-<| : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((<| Ri1) x1 x2) ((<| Ri2) y1 y2))))
    data RightBinaryInverseTerm  : Set where
      |>L : (RightBinaryInverseTerm -> (RightBinaryInverseTerm -> RightBinaryInverseTerm))
      <|L : (RightBinaryInverseTerm -> (RightBinaryInverseTerm -> RightBinaryInverseTerm))
    data ClRightBinaryInverseTerm (A : Set) : Set where
      sing : (A -> (ClRightBinaryInverseTerm A))
      |>Cl : ((ClRightBinaryInverseTerm A) -> ((ClRightBinaryInverseTerm A) -> (ClRightBinaryInverseTerm A)))
      <|Cl : ((ClRightBinaryInverseTerm A) -> ((ClRightBinaryInverseTerm A) -> (ClRightBinaryInverseTerm A)))
    data OpRightBinaryInverseTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRightBinaryInverseTerm n))
      |>OL : ((OpRightBinaryInverseTerm n) -> ((OpRightBinaryInverseTerm n) -> (OpRightBinaryInverseTerm n)))
      <|OL : ((OpRightBinaryInverseTerm n) -> ((OpRightBinaryInverseTerm n) -> (OpRightBinaryInverseTerm n)))
    data OpRightBinaryInverseTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRightBinaryInverseTerm2 n A))
      sing2 : (A -> (OpRightBinaryInverseTerm2 n A))
      |>OL2 : ((OpRightBinaryInverseTerm2 n A) -> ((OpRightBinaryInverseTerm2 n A) -> (OpRightBinaryInverseTerm2 n A)))
      <|OL2 : ((OpRightBinaryInverseTerm2 n A) -> ((OpRightBinaryInverseTerm2 n A) -> (OpRightBinaryInverseTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRightBinaryInverseTerm A) -> (ClRightBinaryInverseTerm A))
    simplifyCl (|>Cl x1 x2) = (|>Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (<|Cl x1 x2) = (<|Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRightBinaryInverseTerm n) -> (OpRightBinaryInverseTerm n))
    simplifyOpB (|>OL x1 x2) = (|>OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (<|OL x1 x2) = (<|OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRightBinaryInverseTerm2 n A) -> (OpRightBinaryInverseTerm2 n A))
    simplifyOp (|>OL2 x1 x2) = (|>OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (<|OL2 x1 x2) = (<|OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RightBinaryInverse A) -> (RightBinaryInverseTerm -> A))
    evalB Ri (|>L x1 x2) = ((|> Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalB Ri (<|L x1 x2) = ((<| Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((RightBinaryInverse A) -> ((ClRightBinaryInverseTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (|>Cl x1 x2) = ((|> Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalCl Ri (<|Cl x1 x2) = ((<| Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((RightBinaryInverse A) -> ((Vec A n) -> ((OpRightBinaryInverseTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (|>OL x1 x2) = ((|> Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOpB Ri vars (<|OL x1 x2) = ((<| Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((RightBinaryInverse A) -> ((Vec A n) -> ((OpRightBinaryInverseTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (|>OL2 x1 x2) = ((|> Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    evalOp Ri vars (<|OL2 x1 x2) = ((<| Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (RightBinaryInverseTerm -> Set)} -> (((x1 x2 : RightBinaryInverseTerm) -> ((P x1) -> ((P x2) -> (P (|>L x1 x2))))) -> (((x1 x2 : RightBinaryInverseTerm) -> ((P x1) -> ((P x2) -> (P (<|L x1 x2))))) -> ((x : RightBinaryInverseTerm) -> (P x))))
    inductionB {p} p|>l p<|l (|>L x1 x2) = (p|>l _ _ (inductionB {p} p|>l p<|l x1) (inductionB {p} p|>l p<|l x2)) 
    inductionB {p} p|>l p<|l (<|L x1 x2) = (p<|l _ _ (inductionB {p} p|>l p<|l x1) (inductionB {p} p|>l p<|l x2)) 
    inductionCl : {A : Set} {P : ((ClRightBinaryInverseTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRightBinaryInverseTerm A)) -> ((P x1) -> ((P x2) -> (P (|>Cl x1 x2))))) -> (((x1 x2 : (ClRightBinaryInverseTerm A)) -> ((P x1) -> ((P x2) -> (P (<|Cl x1 x2))))) -> ((x : (ClRightBinaryInverseTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p|>cl p<|cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p|>cl p<|cl (|>Cl x1 x2) = (p|>cl _ _ (inductionCl {_} {p} psing p|>cl p<|cl x1) (inductionCl {_} {p} psing p|>cl p<|cl x2)) 
    inductionCl {_} {p} psing p|>cl p<|cl (<|Cl x1 x2) = (p<|cl _ _ (inductionCl {_} {p} psing p|>cl p<|cl x1) (inductionCl {_} {p} psing p|>cl p<|cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRightBinaryInverseTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRightBinaryInverseTerm n)) -> ((P x1) -> ((P x2) -> (P (|>OL x1 x2))))) -> (((x1 x2 : (OpRightBinaryInverseTerm n)) -> ((P x1) -> ((P x2) -> (P (<|OL x1 x2))))) -> ((x : (OpRightBinaryInverseTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p|>ol p<|ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p|>ol p<|ol (|>OL x1 x2) = (p|>ol _ _ (inductionOpB {_} {p} pv p|>ol p<|ol x1) (inductionOpB {_} {p} pv p|>ol p<|ol x2)) 
    inductionOpB {_} {p} pv p|>ol p<|ol (<|OL x1 x2) = (p<|ol _ _ (inductionOpB {_} {p} pv p|>ol p<|ol x1) (inductionOpB {_} {p} pv p|>ol p<|ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRightBinaryInverseTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRightBinaryInverseTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (|>OL2 x1 x2))))) -> (((x1 x2 : (OpRightBinaryInverseTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (<|OL2 x1 x2))))) -> ((x : (OpRightBinaryInverseTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (|>OL2 x1 x2) = (p|>ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (<|OL2 x1 x2) = (p<|ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x2)) 
    |>L' : (RightBinaryInverseTerm -> (RightBinaryInverseTerm -> RightBinaryInverseTerm))
    |>L' x1 x2 = (|>L x1 x2) 
    <|L' : (RightBinaryInverseTerm -> (RightBinaryInverseTerm -> RightBinaryInverseTerm))
    <|L' x1 x2 = (<|L x1 x2) 
    stageB : (RightBinaryInverseTerm -> (Staged RightBinaryInverseTerm))
    stageB (|>L x1 x2) = (stage2 |>L' (codeLift2 |>L') (stageB x1) (stageB x2)) 
    stageB (<|L x1 x2) = (stage2 <|L' (codeLift2 <|L') (stageB x1) (stageB x2)) 
    |>Cl' : {A : Set} -> ((ClRightBinaryInverseTerm A) -> ((ClRightBinaryInverseTerm A) -> (ClRightBinaryInverseTerm A)))
    |>Cl' x1 x2 = (|>Cl x1 x2) 
    <|Cl' : {A : Set} -> ((ClRightBinaryInverseTerm A) -> ((ClRightBinaryInverseTerm A) -> (ClRightBinaryInverseTerm A)))
    <|Cl' x1 x2 = (<|Cl x1 x2) 
    stageCl : {A : Set} -> ((ClRightBinaryInverseTerm A) -> (Staged (ClRightBinaryInverseTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (|>Cl x1 x2) = (stage2 |>Cl' (codeLift2 |>Cl') (stageCl x1) (stageCl x2)) 
    stageCl (<|Cl x1 x2) = (stage2 <|Cl' (codeLift2 <|Cl') (stageCl x1) (stageCl x2)) 
    |>OL' : {n : Nat} -> ((OpRightBinaryInverseTerm n) -> ((OpRightBinaryInverseTerm n) -> (OpRightBinaryInverseTerm n)))
    |>OL' x1 x2 = (|>OL x1 x2) 
    <|OL' : {n : Nat} -> ((OpRightBinaryInverseTerm n) -> ((OpRightBinaryInverseTerm n) -> (OpRightBinaryInverseTerm n)))
    <|OL' x1 x2 = (<|OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRightBinaryInverseTerm n) -> (Staged (OpRightBinaryInverseTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (|>OL x1 x2) = (stage2 |>OL' (codeLift2 |>OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (<|OL x1 x2) = (stage2 <|OL' (codeLift2 <|OL') (stageOpB x1) (stageOpB x2)) 
    |>OL2' : {n : Nat} {A : Set} -> ((OpRightBinaryInverseTerm2 n A) -> ((OpRightBinaryInverseTerm2 n A) -> (OpRightBinaryInverseTerm2 n A)))
    |>OL2' x1 x2 = (|>OL2 x1 x2) 
    <|OL2' : {n : Nat} {A : Set} -> ((OpRightBinaryInverseTerm2 n A) -> ((OpRightBinaryInverseTerm2 n A) -> (OpRightBinaryInverseTerm2 n A)))
    <|OL2' x1 x2 = (<|OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRightBinaryInverseTerm2 n A) -> (Staged (OpRightBinaryInverseTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (|>OL2 x1 x2) = (stage2 |>OL2' (codeLift2 |>OL2') (stageOp x1) (stageOp x2)) 
    stageOp (<|OL2 x1 x2) = (stage2 <|OL2' (codeLift2 <|OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        |>T : ((Repr A) -> ((Repr A) -> (Repr A)))
        <|T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RightCancellative  where
    record RightCancellative (A : Set) : Set where
      constructor RightCancellativeC
      field
        op : (A -> (A -> A))
        rinv : (A -> (A -> A))
        rightCancel : {x y : A} -> (op (rinv y x) x) == y
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        rinvS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        rinvP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        rightCancelP : {xP yP : (Prod A A)} -> (opP (rinvP yP xP) xP) == yP
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RightCancellative A1)) (Ri2 : (RightCancellative A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Ri1) x1 x2)) == ((op Ri2) (hom x1) (hom x2))
        pres-rinv : {x1 x2 : A1} -> (hom ((rinv Ri1) x1 x2)) == ((rinv Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RightCancellative A1)) (Ri2 : (RightCancellative A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Ri1) x1 x2) ((op Ri2) y1 y2))))
        interp-rinv : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((rinv Ri1) x1 x2) ((rinv Ri2) y1 y2))))
    data RightCancellativeTerm  : Set where
      opL : (RightCancellativeTerm -> (RightCancellativeTerm -> RightCancellativeTerm))
      rinvL : (RightCancellativeTerm -> (RightCancellativeTerm -> RightCancellativeTerm))
    data ClRightCancellativeTerm (A : Set) : Set where
      sing : (A -> (ClRightCancellativeTerm A))
      opCl : ((ClRightCancellativeTerm A) -> ((ClRightCancellativeTerm A) -> (ClRightCancellativeTerm A)))
      rinvCl : ((ClRightCancellativeTerm A) -> ((ClRightCancellativeTerm A) -> (ClRightCancellativeTerm A)))
    data OpRightCancellativeTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRightCancellativeTerm n))
      opOL : ((OpRightCancellativeTerm n) -> ((OpRightCancellativeTerm n) -> (OpRightCancellativeTerm n)))
      rinvOL : ((OpRightCancellativeTerm n) -> ((OpRightCancellativeTerm n) -> (OpRightCancellativeTerm n)))
    data OpRightCancellativeTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRightCancellativeTerm2 n A))
      sing2 : (A -> (OpRightCancellativeTerm2 n A))
      opOL2 : ((OpRightCancellativeTerm2 n A) -> ((OpRightCancellativeTerm2 n A) -> (OpRightCancellativeTerm2 n A)))
      rinvOL2 : ((OpRightCancellativeTerm2 n A) -> ((OpRightCancellativeTerm2 n A) -> (OpRightCancellativeTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRightCancellativeTerm A) -> (ClRightCancellativeTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (rinvCl x1 x2) = (rinvCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRightCancellativeTerm n) -> (OpRightCancellativeTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (rinvOL x1 x2) = (rinvOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRightCancellativeTerm2 n A) -> (OpRightCancellativeTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (rinvOL2 x1 x2) = (rinvOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RightCancellative A) -> (RightCancellativeTerm -> A))
    evalB Ri (opL x1 x2) = ((op Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalB Ri (rinvL x1 x2) = ((rinv Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((RightCancellative A) -> ((ClRightCancellativeTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (opCl x1 x2) = ((op Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalCl Ri (rinvCl x1 x2) = ((rinv Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((RightCancellative A) -> ((Vec A n) -> ((OpRightCancellativeTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (opOL x1 x2) = ((op Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOpB Ri vars (rinvOL x1 x2) = ((rinv Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((RightCancellative A) -> ((Vec A n) -> ((OpRightCancellativeTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (opOL2 x1 x2) = ((op Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    evalOp Ri vars (rinvOL2 x1 x2) = ((rinv Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (RightCancellativeTerm -> Set)} -> (((x1 x2 : RightCancellativeTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> (((x1 x2 : RightCancellativeTerm) -> ((P x1) -> ((P x2) -> (P (rinvL x1 x2))))) -> ((x : RightCancellativeTerm) -> (P x))))
    inductionB {p} popl prinvl (opL x1 x2) = (popl _ _ (inductionB {p} popl prinvl x1) (inductionB {p} popl prinvl x2)) 
    inductionB {p} popl prinvl (rinvL x1 x2) = (prinvl _ _ (inductionB {p} popl prinvl x1) (inductionB {p} popl prinvl x2)) 
    inductionCl : {A : Set} {P : ((ClRightCancellativeTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRightCancellativeTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> (((x1 x2 : (ClRightCancellativeTerm A)) -> ((P x1) -> ((P x2) -> (P (rinvCl x1 x2))))) -> ((x : (ClRightCancellativeTerm A)) -> (P x)))))
    inductionCl {_} {p} psing popcl prinvcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl prinvcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl prinvcl x1) (inductionCl {_} {p} psing popcl prinvcl x2)) 
    inductionCl {_} {p} psing popcl prinvcl (rinvCl x1 x2) = (prinvcl _ _ (inductionCl {_} {p} psing popcl prinvcl x1) (inductionCl {_} {p} psing popcl prinvcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRightCancellativeTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRightCancellativeTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> (((x1 x2 : (OpRightCancellativeTerm n)) -> ((P x1) -> ((P x2) -> (P (rinvOL x1 x2))))) -> ((x : (OpRightCancellativeTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv popol prinvol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol prinvol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol prinvol x1) (inductionOpB {_} {p} pv popol prinvol x2)) 
    inductionOpB {_} {p} pv popol prinvol (rinvOL x1 x2) = (prinvol _ _ (inductionOpB {_} {p} pv popol prinvol x1) (inductionOpB {_} {p} pv popol prinvol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRightCancellativeTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRightCancellativeTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> (((x1 x2 : (OpRightCancellativeTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (rinvOL2 x1 x2))))) -> ((x : (OpRightCancellativeTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 (rinvOL2 x1 x2) = (prinvol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 x2)) 
    opL' : (RightCancellativeTerm -> (RightCancellativeTerm -> RightCancellativeTerm))
    opL' x1 x2 = (opL x1 x2) 
    rinvL' : (RightCancellativeTerm -> (RightCancellativeTerm -> RightCancellativeTerm))
    rinvL' x1 x2 = (rinvL x1 x2) 
    stageB : (RightCancellativeTerm -> (Staged RightCancellativeTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB (rinvL x1 x2) = (stage2 rinvL' (codeLift2 rinvL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClRightCancellativeTerm A) -> ((ClRightCancellativeTerm A) -> (ClRightCancellativeTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    rinvCl' : {A : Set} -> ((ClRightCancellativeTerm A) -> ((ClRightCancellativeTerm A) -> (ClRightCancellativeTerm A)))
    rinvCl' x1 x2 = (rinvCl x1 x2) 
    stageCl : {A : Set} -> ((ClRightCancellativeTerm A) -> (Staged (ClRightCancellativeTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl (rinvCl x1 x2) = (stage2 rinvCl' (codeLift2 rinvCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpRightCancellativeTerm n) -> ((OpRightCancellativeTerm n) -> (OpRightCancellativeTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    rinvOL' : {n : Nat} -> ((OpRightCancellativeTerm n) -> ((OpRightCancellativeTerm n) -> (OpRightCancellativeTerm n)))
    rinvOL' x1 x2 = (rinvOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRightCancellativeTerm n) -> (Staged (OpRightCancellativeTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (rinvOL x1 x2) = (stage2 rinvOL' (codeLift2 rinvOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpRightCancellativeTerm2 n A) -> ((OpRightCancellativeTerm2 n A) -> (OpRightCancellativeTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    rinvOL2' : {n : Nat} {A : Set} -> ((OpRightCancellativeTerm2 n A) -> ((OpRightCancellativeTerm2 n A) -> (OpRightCancellativeTerm2 n A)))
    rinvOL2' x1 x2 = (rinvOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRightCancellativeTerm2 n A) -> (Staged (OpRightCancellativeTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp (rinvOL2 x1 x2) = (stage2 rinvOL2' (codeLift2 rinvOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        rinvT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RightCancellativeMagma  where
    record RightCancellativeMagma (A : Set) : Set where
      constructor RightCancellativeMagmaC
      field
        op : (A -> (A -> A))
        rightCancellative : {x y z : A} -> ((op x z) == (op y z) -> x == y)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        rightCancellativeP : {xP yP zP : (Prod A A)} -> ((opP xP zP) == (opP yP zP) -> xP == yP)
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RightCancellativeMagma A1)) (Ri2 : (RightCancellativeMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Ri1) x1 x2)) == ((op Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RightCancellativeMagma A1)) (Ri2 : (RightCancellativeMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Ri1) x1 x2) ((op Ri2) y1 y2))))
    data RightCancellativeMagmaTerm  : Set where
      opL : (RightCancellativeMagmaTerm -> (RightCancellativeMagmaTerm -> RightCancellativeMagmaTerm))
    data ClRightCancellativeMagmaTerm (A : Set) : Set where
      sing : (A -> (ClRightCancellativeMagmaTerm A))
      opCl : ((ClRightCancellativeMagmaTerm A) -> ((ClRightCancellativeMagmaTerm A) -> (ClRightCancellativeMagmaTerm A)))
    data OpRightCancellativeMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRightCancellativeMagmaTerm n))
      opOL : ((OpRightCancellativeMagmaTerm n) -> ((OpRightCancellativeMagmaTerm n) -> (OpRightCancellativeMagmaTerm n)))
    data OpRightCancellativeMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRightCancellativeMagmaTerm2 n A))
      sing2 : (A -> (OpRightCancellativeMagmaTerm2 n A))
      opOL2 : ((OpRightCancellativeMagmaTerm2 n A) -> ((OpRightCancellativeMagmaTerm2 n A) -> (OpRightCancellativeMagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRightCancellativeMagmaTerm A) -> (ClRightCancellativeMagmaTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRightCancellativeMagmaTerm n) -> (OpRightCancellativeMagmaTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRightCancellativeMagmaTerm2 n A) -> (OpRightCancellativeMagmaTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RightCancellativeMagma A) -> (RightCancellativeMagmaTerm -> A))
    evalB Ri (opL x1 x2) = ((op Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((RightCancellativeMagma A) -> ((ClRightCancellativeMagmaTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (opCl x1 x2) = ((op Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((RightCancellativeMagma A) -> ((Vec A n) -> ((OpRightCancellativeMagmaTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (opOL x1 x2) = ((op Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((RightCancellativeMagma A) -> ((Vec A n) -> ((OpRightCancellativeMagmaTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (opOL2 x1 x2) = ((op Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (RightCancellativeMagmaTerm -> Set)} -> (((x1 x2 : RightCancellativeMagmaTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : RightCancellativeMagmaTerm) -> (P x)))
    inductionB {p} popl (opL x1 x2) = (popl _ _ (inductionB {p} popl x1) (inductionB {p} popl x2)) 
    inductionCl : {A : Set} {P : ((ClRightCancellativeMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRightCancellativeMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClRightCancellativeMagmaTerm A)) -> (P x))))
    inductionCl {_} {p} psing popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl x1) (inductionCl {_} {p} psing popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRightCancellativeMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRightCancellativeMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpRightCancellativeMagmaTerm n)) -> (P x))))
    inductionOpB {_} {p} pv popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol x1) (inductionOpB {_} {p} pv popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRightCancellativeMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRightCancellativeMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpRightCancellativeMagmaTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 x2)) 
    opL' : (RightCancellativeMagmaTerm -> (RightCancellativeMagmaTerm -> RightCancellativeMagmaTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (RightCancellativeMagmaTerm -> (Staged RightCancellativeMagmaTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClRightCancellativeMagmaTerm A) -> ((ClRightCancellativeMagmaTerm A) -> (ClRightCancellativeMagmaTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClRightCancellativeMagmaTerm A) -> (Staged (ClRightCancellativeMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpRightCancellativeMagmaTerm n) -> ((OpRightCancellativeMagmaTerm n) -> (OpRightCancellativeMagmaTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRightCancellativeMagmaTerm n) -> (Staged (OpRightCancellativeMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpRightCancellativeMagmaTerm2 n A) -> ((OpRightCancellativeMagmaTerm2 n A) -> (OpRightCancellativeMagmaTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRightCancellativeMagmaTerm2 n A) -> (Staged (OpRightCancellativeMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RightCancellativeOp  where
    record RightCancellativeOp (A : Set) : Set where
      constructor RightCancellativeOpC
      field
        op : (A -> (A -> A))
        rinv : (A -> (A -> A))
        rightCancelOp : {x y : A} -> (rinv (op y x) x) == y
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        rinvS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        rinvP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        rightCancelOpP : {xP yP : (Prod A A)} -> (rinvP (opP yP xP) xP) == yP
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RightCancellativeOp A1)) (Ri2 : (RightCancellativeOp A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Ri1) x1 x2)) == ((op Ri2) (hom x1) (hom x2))
        pres-rinv : {x1 x2 : A1} -> (hom ((rinv Ri1) x1 x2)) == ((rinv Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RightCancellativeOp A1)) (Ri2 : (RightCancellativeOp A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Ri1) x1 x2) ((op Ri2) y1 y2))))
        interp-rinv : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((rinv Ri1) x1 x2) ((rinv Ri2) y1 y2))))
    data RightCancellativeOpTerm  : Set where
      opL : (RightCancellativeOpTerm -> (RightCancellativeOpTerm -> RightCancellativeOpTerm))
      rinvL : (RightCancellativeOpTerm -> (RightCancellativeOpTerm -> RightCancellativeOpTerm))
    data ClRightCancellativeOpTerm (A : Set) : Set where
      sing : (A -> (ClRightCancellativeOpTerm A))
      opCl : ((ClRightCancellativeOpTerm A) -> ((ClRightCancellativeOpTerm A) -> (ClRightCancellativeOpTerm A)))
      rinvCl : ((ClRightCancellativeOpTerm A) -> ((ClRightCancellativeOpTerm A) -> (ClRightCancellativeOpTerm A)))
    data OpRightCancellativeOpTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRightCancellativeOpTerm n))
      opOL : ((OpRightCancellativeOpTerm n) -> ((OpRightCancellativeOpTerm n) -> (OpRightCancellativeOpTerm n)))
      rinvOL : ((OpRightCancellativeOpTerm n) -> ((OpRightCancellativeOpTerm n) -> (OpRightCancellativeOpTerm n)))
    data OpRightCancellativeOpTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRightCancellativeOpTerm2 n A))
      sing2 : (A -> (OpRightCancellativeOpTerm2 n A))
      opOL2 : ((OpRightCancellativeOpTerm2 n A) -> ((OpRightCancellativeOpTerm2 n A) -> (OpRightCancellativeOpTerm2 n A)))
      rinvOL2 : ((OpRightCancellativeOpTerm2 n A) -> ((OpRightCancellativeOpTerm2 n A) -> (OpRightCancellativeOpTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRightCancellativeOpTerm A) -> (ClRightCancellativeOpTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (rinvCl x1 x2) = (rinvCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRightCancellativeOpTerm n) -> (OpRightCancellativeOpTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (rinvOL x1 x2) = (rinvOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRightCancellativeOpTerm2 n A) -> (OpRightCancellativeOpTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (rinvOL2 x1 x2) = (rinvOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RightCancellativeOp A) -> (RightCancellativeOpTerm -> A))
    evalB Ri (opL x1 x2) = ((op Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalB Ri (rinvL x1 x2) = ((rinv Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((RightCancellativeOp A) -> ((ClRightCancellativeOpTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (opCl x1 x2) = ((op Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalCl Ri (rinvCl x1 x2) = ((rinv Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((RightCancellativeOp A) -> ((Vec A n) -> ((OpRightCancellativeOpTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (opOL x1 x2) = ((op Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOpB Ri vars (rinvOL x1 x2) = ((rinv Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((RightCancellativeOp A) -> ((Vec A n) -> ((OpRightCancellativeOpTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (opOL2 x1 x2) = ((op Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    evalOp Ri vars (rinvOL2 x1 x2) = ((rinv Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (RightCancellativeOpTerm -> Set)} -> (((x1 x2 : RightCancellativeOpTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> (((x1 x2 : RightCancellativeOpTerm) -> ((P x1) -> ((P x2) -> (P (rinvL x1 x2))))) -> ((x : RightCancellativeOpTerm) -> (P x))))
    inductionB {p} popl prinvl (opL x1 x2) = (popl _ _ (inductionB {p} popl prinvl x1) (inductionB {p} popl prinvl x2)) 
    inductionB {p} popl prinvl (rinvL x1 x2) = (prinvl _ _ (inductionB {p} popl prinvl x1) (inductionB {p} popl prinvl x2)) 
    inductionCl : {A : Set} {P : ((ClRightCancellativeOpTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRightCancellativeOpTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> (((x1 x2 : (ClRightCancellativeOpTerm A)) -> ((P x1) -> ((P x2) -> (P (rinvCl x1 x2))))) -> ((x : (ClRightCancellativeOpTerm A)) -> (P x)))))
    inductionCl {_} {p} psing popcl prinvcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl prinvcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl prinvcl x1) (inductionCl {_} {p} psing popcl prinvcl x2)) 
    inductionCl {_} {p} psing popcl prinvcl (rinvCl x1 x2) = (prinvcl _ _ (inductionCl {_} {p} psing popcl prinvcl x1) (inductionCl {_} {p} psing popcl prinvcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRightCancellativeOpTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRightCancellativeOpTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> (((x1 x2 : (OpRightCancellativeOpTerm n)) -> ((P x1) -> ((P x2) -> (P (rinvOL x1 x2))))) -> ((x : (OpRightCancellativeOpTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv popol prinvol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol prinvol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol prinvol x1) (inductionOpB {_} {p} pv popol prinvol x2)) 
    inductionOpB {_} {p} pv popol prinvol (rinvOL x1 x2) = (prinvol _ _ (inductionOpB {_} {p} pv popol prinvol x1) (inductionOpB {_} {p} pv popol prinvol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRightCancellativeOpTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRightCancellativeOpTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> (((x1 x2 : (OpRightCancellativeOpTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (rinvOL2 x1 x2))))) -> ((x : (OpRightCancellativeOpTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 (rinvOL2 x1 x2) = (prinvol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 x2)) 
    opL' : (RightCancellativeOpTerm -> (RightCancellativeOpTerm -> RightCancellativeOpTerm))
    opL' x1 x2 = (opL x1 x2) 
    rinvL' : (RightCancellativeOpTerm -> (RightCancellativeOpTerm -> RightCancellativeOpTerm))
    rinvL' x1 x2 = (rinvL x1 x2) 
    stageB : (RightCancellativeOpTerm -> (Staged RightCancellativeOpTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB (rinvL x1 x2) = (stage2 rinvL' (codeLift2 rinvL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClRightCancellativeOpTerm A) -> ((ClRightCancellativeOpTerm A) -> (ClRightCancellativeOpTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    rinvCl' : {A : Set} -> ((ClRightCancellativeOpTerm A) -> ((ClRightCancellativeOpTerm A) -> (ClRightCancellativeOpTerm A)))
    rinvCl' x1 x2 = (rinvCl x1 x2) 
    stageCl : {A : Set} -> ((ClRightCancellativeOpTerm A) -> (Staged (ClRightCancellativeOpTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl (rinvCl x1 x2) = (stage2 rinvCl' (codeLift2 rinvCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpRightCancellativeOpTerm n) -> ((OpRightCancellativeOpTerm n) -> (OpRightCancellativeOpTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    rinvOL' : {n : Nat} -> ((OpRightCancellativeOpTerm n) -> ((OpRightCancellativeOpTerm n) -> (OpRightCancellativeOpTerm n)))
    rinvOL' x1 x2 = (rinvOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRightCancellativeOpTerm n) -> (Staged (OpRightCancellativeOpTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (rinvOL x1 x2) = (stage2 rinvOL' (codeLift2 rinvOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpRightCancellativeOpTerm2 n A) -> ((OpRightCancellativeOpTerm2 n A) -> (OpRightCancellativeOpTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    rinvOL2' : {n : Nat} {A : Set} -> ((OpRightCancellativeOpTerm2 n A) -> ((OpRightCancellativeOpTerm2 n A) -> (OpRightCancellativeOpTerm2 n A)))
    rinvOL2' x1 x2 = (rinvOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRightCancellativeOpTerm2 n A) -> (Staged (OpRightCancellativeOpTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp (rinvOL2 x1 x2) = (stage2 rinvOL2' (codeLift2 rinvOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        rinvT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RightCancellativeSemigroup  where
    record RightCancellativeSemigroup (A : Set) : Set where
      constructor RightCancellativeSemigroupC
      field
        op : (A -> (A -> A))
        associative_op : {x y z : A} -> (op (op x y) z) == (op x (op y z))
        rightCancellative : {x y z : A} -> ((op x z) == (op y z) -> x == y)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        associative_opP : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP (opP yP zP))
        rightCancellativeP : {xP yP zP : (Prod A A)} -> ((opP xP zP) == (opP yP zP) -> xP == yP)
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RightCancellativeSemigroup A1)) (Ri2 : (RightCancellativeSemigroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Ri1) x1 x2)) == ((op Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RightCancellativeSemigroup A1)) (Ri2 : (RightCancellativeSemigroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Ri1) x1 x2) ((op Ri2) y1 y2))))
    data RightCancellativeSemigroupTerm  : Set where
      opL : (RightCancellativeSemigroupTerm -> (RightCancellativeSemigroupTerm -> RightCancellativeSemigroupTerm))
    data ClRightCancellativeSemigroupTerm (A : Set) : Set where
      sing : (A -> (ClRightCancellativeSemigroupTerm A))
      opCl : ((ClRightCancellativeSemigroupTerm A) -> ((ClRightCancellativeSemigroupTerm A) -> (ClRightCancellativeSemigroupTerm A)))
    data OpRightCancellativeSemigroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRightCancellativeSemigroupTerm n))
      opOL : ((OpRightCancellativeSemigroupTerm n) -> ((OpRightCancellativeSemigroupTerm n) -> (OpRightCancellativeSemigroupTerm n)))
    data OpRightCancellativeSemigroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRightCancellativeSemigroupTerm2 n A))
      sing2 : (A -> (OpRightCancellativeSemigroupTerm2 n A))
      opOL2 : ((OpRightCancellativeSemigroupTerm2 n A) -> ((OpRightCancellativeSemigroupTerm2 n A) -> (OpRightCancellativeSemigroupTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRightCancellativeSemigroupTerm A) -> (ClRightCancellativeSemigroupTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRightCancellativeSemigroupTerm n) -> (OpRightCancellativeSemigroupTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRightCancellativeSemigroupTerm2 n A) -> (OpRightCancellativeSemigroupTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RightCancellativeSemigroup A) -> (RightCancellativeSemigroupTerm -> A))
    evalB Ri (opL x1 x2) = ((op Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((RightCancellativeSemigroup A) -> ((ClRightCancellativeSemigroupTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (opCl x1 x2) = ((op Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((RightCancellativeSemigroup A) -> ((Vec A n) -> ((OpRightCancellativeSemigroupTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (opOL x1 x2) = ((op Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((RightCancellativeSemigroup A) -> ((Vec A n) -> ((OpRightCancellativeSemigroupTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (opOL2 x1 x2) = ((op Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (RightCancellativeSemigroupTerm -> Set)} -> (((x1 x2 : RightCancellativeSemigroupTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : RightCancellativeSemigroupTerm) -> (P x)))
    inductionB {p} popl (opL x1 x2) = (popl _ _ (inductionB {p} popl x1) (inductionB {p} popl x2)) 
    inductionCl : {A : Set} {P : ((ClRightCancellativeSemigroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRightCancellativeSemigroupTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClRightCancellativeSemigroupTerm A)) -> (P x))))
    inductionCl {_} {p} psing popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl x1) (inductionCl {_} {p} psing popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRightCancellativeSemigroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRightCancellativeSemigroupTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpRightCancellativeSemigroupTerm n)) -> (P x))))
    inductionOpB {_} {p} pv popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol x1) (inductionOpB {_} {p} pv popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRightCancellativeSemigroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRightCancellativeSemigroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpRightCancellativeSemigroupTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 x2)) 
    opL' : (RightCancellativeSemigroupTerm -> (RightCancellativeSemigroupTerm -> RightCancellativeSemigroupTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (RightCancellativeSemigroupTerm -> (Staged RightCancellativeSemigroupTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClRightCancellativeSemigroupTerm A) -> ((ClRightCancellativeSemigroupTerm A) -> (ClRightCancellativeSemigroupTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClRightCancellativeSemigroupTerm A) -> (Staged (ClRightCancellativeSemigroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpRightCancellativeSemigroupTerm n) -> ((OpRightCancellativeSemigroupTerm n) -> (OpRightCancellativeSemigroupTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRightCancellativeSemigroupTerm n) -> (Staged (OpRightCancellativeSemigroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpRightCancellativeSemigroupTerm2 n A) -> ((OpRightCancellativeSemigroupTerm2 n A) -> (OpRightCancellativeSemigroupTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRightCancellativeSemigroupTerm2 n A) -> (Staged (OpRightCancellativeSemigroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RightDistributiveMagma  where
    record RightDistributiveMagma (A : Set) : Set where
      constructor RightDistributiveMagmaC
      field
        op : (A -> (A -> A))
        rightDistributive : {x y z : A} -> (op (op y z) x) == (op (op y x) (op z x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        rightDistributiveP : {xP yP zP : (Prod A A)} -> (opP (opP yP zP) xP) == (opP (opP yP xP) (opP zP xP))
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RightDistributiveMagma A1)) (Ri2 : (RightDistributiveMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Ri1) x1 x2)) == ((op Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RightDistributiveMagma A1)) (Ri2 : (RightDistributiveMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Ri1) x1 x2) ((op Ri2) y1 y2))))
    data RightDistributiveMagmaTerm  : Set where
      opL : (RightDistributiveMagmaTerm -> (RightDistributiveMagmaTerm -> RightDistributiveMagmaTerm))
    data ClRightDistributiveMagmaTerm (A : Set) : Set where
      sing : (A -> (ClRightDistributiveMagmaTerm A))
      opCl : ((ClRightDistributiveMagmaTerm A) -> ((ClRightDistributiveMagmaTerm A) -> (ClRightDistributiveMagmaTerm A)))
    data OpRightDistributiveMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRightDistributiveMagmaTerm n))
      opOL : ((OpRightDistributiveMagmaTerm n) -> ((OpRightDistributiveMagmaTerm n) -> (OpRightDistributiveMagmaTerm n)))
    data OpRightDistributiveMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRightDistributiveMagmaTerm2 n A))
      sing2 : (A -> (OpRightDistributiveMagmaTerm2 n A))
      opOL2 : ((OpRightDistributiveMagmaTerm2 n A) -> ((OpRightDistributiveMagmaTerm2 n A) -> (OpRightDistributiveMagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRightDistributiveMagmaTerm A) -> (ClRightDistributiveMagmaTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRightDistributiveMagmaTerm n) -> (OpRightDistributiveMagmaTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRightDistributiveMagmaTerm2 n A) -> (OpRightDistributiveMagmaTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RightDistributiveMagma A) -> (RightDistributiveMagmaTerm -> A))
    evalB Ri (opL x1 x2) = ((op Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((RightDistributiveMagma A) -> ((ClRightDistributiveMagmaTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (opCl x1 x2) = ((op Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((RightDistributiveMagma A) -> ((Vec A n) -> ((OpRightDistributiveMagmaTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (opOL x1 x2) = ((op Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((RightDistributiveMagma A) -> ((Vec A n) -> ((OpRightDistributiveMagmaTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (opOL2 x1 x2) = ((op Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (RightDistributiveMagmaTerm -> Set)} -> (((x1 x2 : RightDistributiveMagmaTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : RightDistributiveMagmaTerm) -> (P x)))
    inductionB {p} popl (opL x1 x2) = (popl _ _ (inductionB {p} popl x1) (inductionB {p} popl x2)) 
    inductionCl : {A : Set} {P : ((ClRightDistributiveMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRightDistributiveMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClRightDistributiveMagmaTerm A)) -> (P x))))
    inductionCl {_} {p} psing popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl x1) (inductionCl {_} {p} psing popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRightDistributiveMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRightDistributiveMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpRightDistributiveMagmaTerm n)) -> (P x))))
    inductionOpB {_} {p} pv popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol x1) (inductionOpB {_} {p} pv popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRightDistributiveMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRightDistributiveMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpRightDistributiveMagmaTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 x2)) 
    opL' : (RightDistributiveMagmaTerm -> (RightDistributiveMagmaTerm -> RightDistributiveMagmaTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (RightDistributiveMagmaTerm -> (Staged RightDistributiveMagmaTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClRightDistributiveMagmaTerm A) -> ((ClRightDistributiveMagmaTerm A) -> (ClRightDistributiveMagmaTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClRightDistributiveMagmaTerm A) -> (Staged (ClRightDistributiveMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpRightDistributiveMagmaTerm n) -> ((OpRightDistributiveMagmaTerm n) -> (OpRightDistributiveMagmaTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRightDistributiveMagmaTerm n) -> (Staged (OpRightDistributiveMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpRightDistributiveMagmaTerm2 n A) -> ((OpRightDistributiveMagmaTerm2 n A) -> (OpRightDistributiveMagmaTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRightDistributiveMagmaTerm2 n A) -> (Staged (OpRightDistributiveMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RightIdempotence  where
    record RightIdempotence (A : Set) : Set where
      constructor RightIdempotenceC
      field
        <| : (A -> (A -> A))
        idempotent_<| : {x : A} -> (<| x x) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        <|S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        <|P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        idempotent_<|P : {xP : (Prod A A)} -> (<|P xP xP) == xP
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RightIdempotence A1)) (Ri2 : (RightIdempotence A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-<| : {x1 x2 : A1} -> (hom ((<| Ri1) x1 x2)) == ((<| Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RightIdempotence A1)) (Ri2 : (RightIdempotence A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-<| : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((<| Ri1) x1 x2) ((<| Ri2) y1 y2))))
    data RightIdempotenceTerm  : Set where
      <|L : (RightIdempotenceTerm -> (RightIdempotenceTerm -> RightIdempotenceTerm))
    data ClRightIdempotenceTerm (A : Set) : Set where
      sing : (A -> (ClRightIdempotenceTerm A))
      <|Cl : ((ClRightIdempotenceTerm A) -> ((ClRightIdempotenceTerm A) -> (ClRightIdempotenceTerm A)))
    data OpRightIdempotenceTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRightIdempotenceTerm n))
      <|OL : ((OpRightIdempotenceTerm n) -> ((OpRightIdempotenceTerm n) -> (OpRightIdempotenceTerm n)))
    data OpRightIdempotenceTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRightIdempotenceTerm2 n A))
      sing2 : (A -> (OpRightIdempotenceTerm2 n A))
      <|OL2 : ((OpRightIdempotenceTerm2 n A) -> ((OpRightIdempotenceTerm2 n A) -> (OpRightIdempotenceTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRightIdempotenceTerm A) -> (ClRightIdempotenceTerm A))
    simplifyCl (<|Cl x1 x2) = (<|Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRightIdempotenceTerm n) -> (OpRightIdempotenceTerm n))
    simplifyOpB (<|OL x1 x2) = (<|OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRightIdempotenceTerm2 n A) -> (OpRightIdempotenceTerm2 n A))
    simplifyOp (<|OL2 x1 x2) = (<|OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RightIdempotence A) -> (RightIdempotenceTerm -> A))
    evalB Ri (<|L x1 x2) = ((<| Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((RightIdempotence A) -> ((ClRightIdempotenceTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (<|Cl x1 x2) = ((<| Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((RightIdempotence A) -> ((Vec A n) -> ((OpRightIdempotenceTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (<|OL x1 x2) = ((<| Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((RightIdempotence A) -> ((Vec A n) -> ((OpRightIdempotenceTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (<|OL2 x1 x2) = ((<| Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (RightIdempotenceTerm -> Set)} -> (((x1 x2 : RightIdempotenceTerm) -> ((P x1) -> ((P x2) -> (P (<|L x1 x2))))) -> ((x : RightIdempotenceTerm) -> (P x)))
    inductionB {p} p<|l (<|L x1 x2) = (p<|l _ _ (inductionB {p} p<|l x1) (inductionB {p} p<|l x2)) 
    inductionCl : {A : Set} {P : ((ClRightIdempotenceTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRightIdempotenceTerm A)) -> ((P x1) -> ((P x2) -> (P (<|Cl x1 x2))))) -> ((x : (ClRightIdempotenceTerm A)) -> (P x))))
    inductionCl {_} {p} psing p<|cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p<|cl (<|Cl x1 x2) = (p<|cl _ _ (inductionCl {_} {p} psing p<|cl x1) (inductionCl {_} {p} psing p<|cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRightIdempotenceTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRightIdempotenceTerm n)) -> ((P x1) -> ((P x2) -> (P (<|OL x1 x2))))) -> ((x : (OpRightIdempotenceTerm n)) -> (P x))))
    inductionOpB {_} {p} pv p<|ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p<|ol (<|OL x1 x2) = (p<|ol _ _ (inductionOpB {_} {p} pv p<|ol x1) (inductionOpB {_} {p} pv p<|ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRightIdempotenceTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRightIdempotenceTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (<|OL2 x1 x2))))) -> ((x : (OpRightIdempotenceTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 p<|ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p<|ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p<|ol2 (<|OL2 x1 x2) = (p<|ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p<|ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p<|ol2 x2)) 
    <|L' : (RightIdempotenceTerm -> (RightIdempotenceTerm -> RightIdempotenceTerm))
    <|L' x1 x2 = (<|L x1 x2) 
    stageB : (RightIdempotenceTerm -> (Staged RightIdempotenceTerm))
    stageB (<|L x1 x2) = (stage2 <|L' (codeLift2 <|L') (stageB x1) (stageB x2)) 
    <|Cl' : {A : Set} -> ((ClRightIdempotenceTerm A) -> ((ClRightIdempotenceTerm A) -> (ClRightIdempotenceTerm A)))
    <|Cl' x1 x2 = (<|Cl x1 x2) 
    stageCl : {A : Set} -> ((ClRightIdempotenceTerm A) -> (Staged (ClRightIdempotenceTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (<|Cl x1 x2) = (stage2 <|Cl' (codeLift2 <|Cl') (stageCl x1) (stageCl x2)) 
    <|OL' : {n : Nat} -> ((OpRightIdempotenceTerm n) -> ((OpRightIdempotenceTerm n) -> (OpRightIdempotenceTerm n)))
    <|OL' x1 x2 = (<|OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRightIdempotenceTerm n) -> (Staged (OpRightIdempotenceTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (<|OL x1 x2) = (stage2 <|OL' (codeLift2 <|OL') (stageOpB x1) (stageOpB x2)) 
    <|OL2' : {n : Nat} {A : Set} -> ((OpRightIdempotenceTerm2 n A) -> ((OpRightIdempotenceTerm2 n A) -> (OpRightIdempotenceTerm2 n A)))
    <|OL2' x1 x2 = (<|OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRightIdempotenceTerm2 n A) -> (Staged (OpRightIdempotenceTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (<|OL2 x1 x2) = (stage2 <|OL2' (codeLift2 <|OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        <|T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RightInverse  where
    record RightInverse (A : Set) : Set where
      constructor RightInverseC
      field
        inv : (A -> A)
        e : A
        op : (A -> (A -> A))
        rightInverse_inv_op_e : {x : A} -> (op (inv x) x) == e
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        invS : (AS -> AS)
        eS : AS
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        invP : ((Prod A A) -> (Prod A A))
        eP : (Prod A A)
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        rightInverse_inv_op_eP : {xP : (Prod A A)} -> (opP (invP xP) xP) == eP
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RightInverse A1)) (Ri2 : (RightInverse A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-inv : {x1 : A1} -> (hom ((inv Ri1) x1)) == ((inv Ri2) (hom x1))
        pres-e : (hom (e Ri1)) == (e Ri2)
        pres-op : {x1 x2 : A1} -> (hom ((op Ri1) x1 x2)) == ((op Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RightInverse A1)) (Ri2 : (RightInverse A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-inv : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((inv Ri1) x1) ((inv Ri2) y1)))
        interp-e : (interp (e Ri1) (e Ri2))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Ri1) x1 x2) ((op Ri2) y1 y2))))
    data RightInverseLTerm  : Set where
      invL : (RightInverseLTerm -> RightInverseLTerm)
      eL : RightInverseLTerm
      opL : (RightInverseLTerm -> (RightInverseLTerm -> RightInverseLTerm))
    data ClRightInverseClTerm (A : Set) : Set where
      sing : (A -> (ClRightInverseClTerm A))
      invCl : ((ClRightInverseClTerm A) -> (ClRightInverseClTerm A))
      eCl : (ClRightInverseClTerm A)
      opCl : ((ClRightInverseClTerm A) -> ((ClRightInverseClTerm A) -> (ClRightInverseClTerm A)))
    data OpRightInverseOLTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRightInverseOLTerm n))
      invOL : ((OpRightInverseOLTerm n) -> (OpRightInverseOLTerm n))
      eOL : (OpRightInverseOLTerm n)
      opOL : ((OpRightInverseOLTerm n) -> ((OpRightInverseOLTerm n) -> (OpRightInverseOLTerm n)))
    data OpRightInverseOL2Term2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRightInverseOL2Term2 n A))
      sing2 : (A -> (OpRightInverseOL2Term2 n A))
      invOL2 : ((OpRightInverseOL2Term2 n A) -> (OpRightInverseOL2Term2 n A))
      eOL2 : (OpRightInverseOL2Term2 n A)
      opOL2 : ((OpRightInverseOL2Term2 n A) -> ((OpRightInverseOL2Term2 n A) -> (OpRightInverseOL2Term2 n A)))
    simplifyCl : {A : Set} -> ((ClRightInverseClTerm A) -> (ClRightInverseClTerm A))
    simplifyCl (invCl x1) = (invCl (simplifyCl x1)) 
    simplifyCl eCl = eCl 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRightInverseOLTerm n) -> (OpRightInverseOLTerm n))
    simplifyOpB (invOL x1) = (invOL (simplifyOpB x1)) 
    simplifyOpB eOL = eOL 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRightInverseOL2Term2 n A) -> (OpRightInverseOL2Term2 n A))
    simplifyOp (invOL2 x1) = (invOL2 (simplifyOp x1)) 
    simplifyOp eOL2 = eOL2 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RightInverse A) -> (RightInverseLTerm -> A))
    evalB Ri (invL x1) = ((inv Ri) (evalB Ri x1)) 
    evalB Ri eL = (e Ri) 
    evalB Ri (opL x1 x2) = ((op Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((RightInverse A) -> ((ClRightInverseClTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (invCl x1) = ((inv Ri) (evalCl Ri x1)) 
    evalCl Ri eCl = (e Ri) 
    evalCl Ri (opCl x1 x2) = ((op Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((RightInverse A) -> ((Vec A n) -> ((OpRightInverseOLTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (invOL x1) = ((inv Ri) (evalOpB Ri vars x1)) 
    evalOpB Ri vars eOL = (e Ri) 
    evalOpB Ri vars (opOL x1 x2) = ((op Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((RightInverse A) -> ((Vec A n) -> ((OpRightInverseOL2Term2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (invOL2 x1) = ((inv Ri) (evalOp Ri vars x1)) 
    evalOp Ri vars eOL2 = (e Ri) 
    evalOp Ri vars (opOL2 x1 x2) = ((op Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (RightInverseLTerm -> Set)} -> (((x1 : RightInverseLTerm) -> ((P x1) -> (P (invL x1)))) -> ((P eL) -> (((x1 x2 : RightInverseLTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : RightInverseLTerm) -> (P x)))))
    inductionB {p} pinvl pel popl (invL x1) = (pinvl _ (inductionB {p} pinvl pel popl x1)) 
    inductionB {p} pinvl pel popl eL = pel 
    inductionB {p} pinvl pel popl (opL x1 x2) = (popl _ _ (inductionB {p} pinvl pel popl x1) (inductionB {p} pinvl pel popl x2)) 
    inductionCl : {A : Set} {P : ((ClRightInverseClTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 : (ClRightInverseClTerm A)) -> ((P x1) -> (P (invCl x1)))) -> ((P eCl) -> (((x1 x2 : (ClRightInverseClTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClRightInverseClTerm A)) -> (P x))))))
    inductionCl {_} {p} psing pinvcl pecl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pinvcl pecl popcl (invCl x1) = (pinvcl _ (inductionCl {_} {p} psing pinvcl pecl popcl x1)) 
    inductionCl {_} {p} psing pinvcl pecl popcl eCl = pecl 
    inductionCl {_} {p} psing pinvcl pecl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing pinvcl pecl popcl x1) (inductionCl {_} {p} psing pinvcl pecl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRightInverseOLTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 : (OpRightInverseOLTerm n)) -> ((P x1) -> (P (invOL x1)))) -> ((P eOL) -> (((x1 x2 : (OpRightInverseOLTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpRightInverseOLTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv pinvol peol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pinvol peol popol (invOL x1) = (pinvol _ (inductionOpB {_} {p} pv pinvol peol popol x1)) 
    inductionOpB {_} {p} pv pinvol peol popol eOL = peol 
    inductionOpB {_} {p} pv pinvol peol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv pinvol peol popol x1) (inductionOpB {_} {p} pv pinvol peol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRightInverseOL2Term2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 : (OpRightInverseOL2Term2 n A)) -> ((P x1) -> (P (invOL2 x1)))) -> ((P eOL2) -> (((x1 x2 : (OpRightInverseOL2Term2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpRightInverseOL2Term2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 (invOL2 x1) = (pinvol2 _ (inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 eOL2 = peol2 
    inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 pinvol2 peol2 popol2 x2)) 
    invL' : (RightInverseLTerm -> RightInverseLTerm)
    invL' x1 = (invL x1) 
    eL' : RightInverseLTerm
    eL'  = eL 
    opL' : (RightInverseLTerm -> (RightInverseLTerm -> RightInverseLTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (RightInverseLTerm -> (Staged RightInverseLTerm))
    stageB (invL x1) = (stage1 invL' (codeLift1 invL') (stageB x1)) 
    stageB eL = (Now eL) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    invCl' : {A : Set} -> ((ClRightInverseClTerm A) -> (ClRightInverseClTerm A))
    invCl' x1 = (invCl x1) 
    eCl' : {A : Set} -> (ClRightInverseClTerm A)
    eCl'  = eCl 
    opCl' : {A : Set} -> ((ClRightInverseClTerm A) -> ((ClRightInverseClTerm A) -> (ClRightInverseClTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClRightInverseClTerm A) -> (Staged (ClRightInverseClTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (invCl x1) = (stage1 invCl' (codeLift1 invCl') (stageCl x1)) 
    stageCl eCl = (Now eCl) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    invOL' : {n : Nat} -> ((OpRightInverseOLTerm n) -> (OpRightInverseOLTerm n))
    invOL' x1 = (invOL x1) 
    eOL' : {n : Nat} -> (OpRightInverseOLTerm n)
    eOL'  = eOL 
    opOL' : {n : Nat} -> ((OpRightInverseOLTerm n) -> ((OpRightInverseOLTerm n) -> (OpRightInverseOLTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRightInverseOLTerm n) -> (Staged (OpRightInverseOLTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (invOL x1) = (stage1 invOL' (codeLift1 invOL') (stageOpB x1)) 
    stageOpB eOL = (Now eOL) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    invOL2' : {n : Nat} {A : Set} -> ((OpRightInverseOL2Term2 n A) -> (OpRightInverseOL2Term2 n A))
    invOL2' x1 = (invOL2 x1) 
    eOL2' : {n : Nat} {A : Set} -> (OpRightInverseOL2Term2 n A)
    eOL2'  = eOL2 
    opOL2' : {n : Nat} {A : Set} -> ((OpRightInverseOL2Term2 n A) -> ((OpRightInverseOL2Term2 n A) -> (OpRightInverseOL2Term2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRightInverseOL2Term2 n A) -> (Staged (OpRightInverseOL2Term2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (invOL2 x1) = (stage1 invOL2' (codeLift1 invOL2') (stageOp x1)) 
    stageOp eOL2 = (Now eOL2) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        invT : ((Repr A) -> (Repr A))
        eT : (Repr A)
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RightInverseMagma  where
    record RightInverseMagma (A : Set) : Set where
      constructor RightInverseMagmaC
      field
        rinv : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        rinvS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        rinvP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RightInverseMagma A1)) (Ri2 : (RightInverseMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-rinv : {x1 x2 : A1} -> (hom ((rinv Ri1) x1 x2)) == ((rinv Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RightInverseMagma A1)) (Ri2 : (RightInverseMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-rinv : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((rinv Ri1) x1 x2) ((rinv Ri2) y1 y2))))
    data RightInverseMagmaTerm  : Set where
      rinvL : (RightInverseMagmaTerm -> (RightInverseMagmaTerm -> RightInverseMagmaTerm))
    data ClRightInverseMagmaTerm (A : Set) : Set where
      sing : (A -> (ClRightInverseMagmaTerm A))
      rinvCl : ((ClRightInverseMagmaTerm A) -> ((ClRightInverseMagmaTerm A) -> (ClRightInverseMagmaTerm A)))
    data OpRightInverseMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRightInverseMagmaTerm n))
      rinvOL : ((OpRightInverseMagmaTerm n) -> ((OpRightInverseMagmaTerm n) -> (OpRightInverseMagmaTerm n)))
    data OpRightInverseMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRightInverseMagmaTerm2 n A))
      sing2 : (A -> (OpRightInverseMagmaTerm2 n A))
      rinvOL2 : ((OpRightInverseMagmaTerm2 n A) -> ((OpRightInverseMagmaTerm2 n A) -> (OpRightInverseMagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRightInverseMagmaTerm A) -> (ClRightInverseMagmaTerm A))
    simplifyCl (rinvCl x1 x2) = (rinvCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRightInverseMagmaTerm n) -> (OpRightInverseMagmaTerm n))
    simplifyOpB (rinvOL x1 x2) = (rinvOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRightInverseMagmaTerm2 n A) -> (OpRightInverseMagmaTerm2 n A))
    simplifyOp (rinvOL2 x1 x2) = (rinvOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RightInverseMagma A) -> (RightInverseMagmaTerm -> A))
    evalB Ri (rinvL x1 x2) = ((rinv Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((RightInverseMagma A) -> ((ClRightInverseMagmaTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (rinvCl x1 x2) = ((rinv Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((RightInverseMagma A) -> ((Vec A n) -> ((OpRightInverseMagmaTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (rinvOL x1 x2) = ((rinv Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((RightInverseMagma A) -> ((Vec A n) -> ((OpRightInverseMagmaTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (rinvOL2 x1 x2) = ((rinv Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (RightInverseMagmaTerm -> Set)} -> (((x1 x2 : RightInverseMagmaTerm) -> ((P x1) -> ((P x2) -> (P (rinvL x1 x2))))) -> ((x : RightInverseMagmaTerm) -> (P x)))
    inductionB {p} prinvl (rinvL x1 x2) = (prinvl _ _ (inductionB {p} prinvl x1) (inductionB {p} prinvl x2)) 
    inductionCl : {A : Set} {P : ((ClRightInverseMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRightInverseMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (rinvCl x1 x2))))) -> ((x : (ClRightInverseMagmaTerm A)) -> (P x))))
    inductionCl {_} {p} psing prinvcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing prinvcl (rinvCl x1 x2) = (prinvcl _ _ (inductionCl {_} {p} psing prinvcl x1) (inductionCl {_} {p} psing prinvcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRightInverseMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRightInverseMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (rinvOL x1 x2))))) -> ((x : (OpRightInverseMagmaTerm n)) -> (P x))))
    inductionOpB {_} {p} pv prinvol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv prinvol (rinvOL x1 x2) = (prinvol _ _ (inductionOpB {_} {p} pv prinvol x1) (inductionOpB {_} {p} pv prinvol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRightInverseMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRightInverseMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (rinvOL2 x1 x2))))) -> ((x : (OpRightInverseMagmaTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 prinvol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 prinvol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 prinvol2 (rinvOL2 x1 x2) = (prinvol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 prinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 prinvol2 x2)) 
    rinvL' : (RightInverseMagmaTerm -> (RightInverseMagmaTerm -> RightInverseMagmaTerm))
    rinvL' x1 x2 = (rinvL x1 x2) 
    stageB : (RightInverseMagmaTerm -> (Staged RightInverseMagmaTerm))
    stageB (rinvL x1 x2) = (stage2 rinvL' (codeLift2 rinvL') (stageB x1) (stageB x2)) 
    rinvCl' : {A : Set} -> ((ClRightInverseMagmaTerm A) -> ((ClRightInverseMagmaTerm A) -> (ClRightInverseMagmaTerm A)))
    rinvCl' x1 x2 = (rinvCl x1 x2) 
    stageCl : {A : Set} -> ((ClRightInverseMagmaTerm A) -> (Staged (ClRightInverseMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (rinvCl x1 x2) = (stage2 rinvCl' (codeLift2 rinvCl') (stageCl x1) (stageCl x2)) 
    rinvOL' : {n : Nat} -> ((OpRightInverseMagmaTerm n) -> ((OpRightInverseMagmaTerm n) -> (OpRightInverseMagmaTerm n)))
    rinvOL' x1 x2 = (rinvOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRightInverseMagmaTerm n) -> (Staged (OpRightInverseMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (rinvOL x1 x2) = (stage2 rinvOL' (codeLift2 rinvOL') (stageOpB x1) (stageOpB x2)) 
    rinvOL2' : {n : Nat} {A : Set} -> ((OpRightInverseMagmaTerm2 n A) -> ((OpRightInverseMagmaTerm2 n A) -> (OpRightInverseMagmaTerm2 n A)))
    rinvOL2' x1 x2 = (rinvOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRightInverseMagmaTerm2 n A) -> (Staged (OpRightInverseMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (rinvOL2 x1 x2) = (stage2 rinvOL2' (codeLift2 rinvOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        rinvT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RightMonoid  where
    record RightMonoid (A : Set) : Set where
      constructor RightMonoidC
      field
        op : (A -> (A -> A))
        e : A
        runit_e : {x : A} -> (op x e) == x
        associative_op : {x y z : A} -> (op (op x y) z) == (op x (op y z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        eS : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        eP : (Prod A A)
        runit_eP : {xP : (Prod A A)} -> (opP xP eP) == xP
        associative_opP : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP (opP yP zP))
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RightMonoid A1)) (Ri2 : (RightMonoid A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Ri1) x1 x2)) == ((op Ri2) (hom x1) (hom x2))
        pres-e : (hom (e Ri1)) == (e Ri2)
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RightMonoid A1)) (Ri2 : (RightMonoid A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Ri1) x1 x2) ((op Ri2) y1 y2))))
        interp-e : (interp (e Ri1) (e Ri2))
    data RightMonoidTerm  : Set where
      opL : (RightMonoidTerm -> (RightMonoidTerm -> RightMonoidTerm))
      eL : RightMonoidTerm
    data ClRightMonoidTerm (A : Set) : Set where
      sing : (A -> (ClRightMonoidTerm A))
      opCl : ((ClRightMonoidTerm A) -> ((ClRightMonoidTerm A) -> (ClRightMonoidTerm A)))
      eCl : (ClRightMonoidTerm A)
    data OpRightMonoidTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRightMonoidTerm n))
      opOL : ((OpRightMonoidTerm n) -> ((OpRightMonoidTerm n) -> (OpRightMonoidTerm n)))
      eOL : (OpRightMonoidTerm n)
    data OpRightMonoidTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRightMonoidTerm2 n A))
      sing2 : (A -> (OpRightMonoidTerm2 n A))
      opOL2 : ((OpRightMonoidTerm2 n A) -> ((OpRightMonoidTerm2 n A) -> (OpRightMonoidTerm2 n A)))
      eOL2 : (OpRightMonoidTerm2 n A)
    simplifyCl : {A : Set} -> ((ClRightMonoidTerm A) -> (ClRightMonoidTerm A))
    simplifyCl (opCl x eCl) = x 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl eCl = eCl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRightMonoidTerm n) -> (OpRightMonoidTerm n))
    simplifyOpB (opOL x eOL) = x 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB eOL = eOL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRightMonoidTerm2 n A) -> (OpRightMonoidTerm2 n A))
    simplifyOp (opOL2 x eOL2) = x 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp eOL2 = eOL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RightMonoid A) -> (RightMonoidTerm -> A))
    evalB Ri (opL x1 x2) = ((op Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalB Ri eL = (e Ri) 
    evalCl : {A : Set} -> ((RightMonoid A) -> ((ClRightMonoidTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (opCl x1 x2) = ((op Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalCl Ri eCl = (e Ri) 
    evalOpB : {A : Set} {n : Nat} -> ((RightMonoid A) -> ((Vec A n) -> ((OpRightMonoidTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (opOL x1 x2) = ((op Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOpB Ri vars eOL = (e Ri) 
    evalOp : {A : Set} {n : Nat} -> ((RightMonoid A) -> ((Vec A n) -> ((OpRightMonoidTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (opOL2 x1 x2) = ((op Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    evalOp Ri vars eOL2 = (e Ri) 
    inductionB : {P : (RightMonoidTerm -> Set)} -> (((x1 x2 : RightMonoidTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((P eL) -> ((x : RightMonoidTerm) -> (P x))))
    inductionB {p} popl pel (opL x1 x2) = (popl _ _ (inductionB {p} popl pel x1) (inductionB {p} popl pel x2)) 
    inductionB {p} popl pel eL = pel 
    inductionCl : {A : Set} {P : ((ClRightMonoidTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRightMonoidTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((P eCl) -> ((x : (ClRightMonoidTerm A)) -> (P x)))))
    inductionCl {_} {p} psing popcl pecl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl pecl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl pecl x1) (inductionCl {_} {p} psing popcl pecl x2)) 
    inductionCl {_} {p} psing popcl pecl eCl = pecl 
    inductionOpB : {n : Nat} {P : ((OpRightMonoidTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRightMonoidTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((P eOL) -> ((x : (OpRightMonoidTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv popol peol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol peol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol peol x1) (inductionOpB {_} {p} pv popol peol x2)) 
    inductionOpB {_} {p} pv popol peol eOL = peol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRightMonoidTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRightMonoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((P eOL2) -> ((x : (OpRightMonoidTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 peol2 eOL2 = peol2 
    opL' : (RightMonoidTerm -> (RightMonoidTerm -> RightMonoidTerm))
    opL' x1 x2 = (opL x1 x2) 
    eL' : RightMonoidTerm
    eL'  = eL 
    stageB : (RightMonoidTerm -> (Staged RightMonoidTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB eL = (Now eL) 
    opCl' : {A : Set} -> ((ClRightMonoidTerm A) -> ((ClRightMonoidTerm A) -> (ClRightMonoidTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    eCl' : {A : Set} -> (ClRightMonoidTerm A)
    eCl'  = eCl 
    stageCl : {A : Set} -> ((ClRightMonoidTerm A) -> (Staged (ClRightMonoidTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl eCl = (Now eCl) 
    opOL' : {n : Nat} -> ((OpRightMonoidTerm n) -> ((OpRightMonoidTerm n) -> (OpRightMonoidTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    eOL' : {n : Nat} -> (OpRightMonoidTerm n)
    eOL'  = eOL 
    stageOpB : {n : Nat} -> ((OpRightMonoidTerm n) -> (Staged (OpRightMonoidTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB eOL = (Now eOL) 
    opOL2' : {n : Nat} {A : Set} -> ((OpRightMonoidTerm2 n A) -> ((OpRightMonoidTerm2 n A) -> (OpRightMonoidTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    eOL2' : {n : Nat} {A : Set} -> (OpRightMonoidTerm2 n A)
    eOL2'  = eOL2 
    stageOp : {n : Nat} {A : Set} -> ((OpRightMonoidTerm2 n A) -> (Staged (OpRightMonoidTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp eOL2 = (Now eOL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        eT : (Repr A)
  module RightPreSemiring  where
    record RightPreSemiring (A : Set) : Set where
      constructor RightPreSemiringC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        rightDistributive_*_+ : {x y z : A} -> (* (+ y z) x) == (+ (* y x) (* z x))
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        rightDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P (+P yP zP) xP) == (+P (*P yP xP) (*P zP xP))
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RightPreSemiring A1)) (Ri2 : (RightPreSemiring A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Ri1) x1 x2)) == ((* Ri2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ri1) x1 x2)) == ((+ Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RightPreSemiring A1)) (Ri2 : (RightPreSemiring A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Ri1) x1 x2) ((* Ri2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ri1) x1 x2) ((+ Ri2) y1 y2))))
    data RightPreSemiringTerm  : Set where
      *L : (RightPreSemiringTerm -> (RightPreSemiringTerm -> RightPreSemiringTerm))
      +L : (RightPreSemiringTerm -> (RightPreSemiringTerm -> RightPreSemiringTerm))
    data ClRightPreSemiringTerm (A : Set) : Set where
      sing : (A -> (ClRightPreSemiringTerm A))
      *Cl : ((ClRightPreSemiringTerm A) -> ((ClRightPreSemiringTerm A) -> (ClRightPreSemiringTerm A)))
      +Cl : ((ClRightPreSemiringTerm A) -> ((ClRightPreSemiringTerm A) -> (ClRightPreSemiringTerm A)))
    data OpRightPreSemiringTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRightPreSemiringTerm n))
      *OL : ((OpRightPreSemiringTerm n) -> ((OpRightPreSemiringTerm n) -> (OpRightPreSemiringTerm n)))
      +OL : ((OpRightPreSemiringTerm n) -> ((OpRightPreSemiringTerm n) -> (OpRightPreSemiringTerm n)))
    data OpRightPreSemiringTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRightPreSemiringTerm2 n A))
      sing2 : (A -> (OpRightPreSemiringTerm2 n A))
      *OL2 : ((OpRightPreSemiringTerm2 n A) -> ((OpRightPreSemiringTerm2 n A) -> (OpRightPreSemiringTerm2 n A)))
      +OL2 : ((OpRightPreSemiringTerm2 n A) -> ((OpRightPreSemiringTerm2 n A) -> (OpRightPreSemiringTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRightPreSemiringTerm A) -> (ClRightPreSemiringTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRightPreSemiringTerm n) -> (OpRightPreSemiringTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRightPreSemiringTerm2 n A) -> (OpRightPreSemiringTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RightPreSemiring A) -> (RightPreSemiringTerm -> A))
    evalB Ri (*L x1 x2) = ((* Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalB Ri (+L x1 x2) = ((+ Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((RightPreSemiring A) -> ((ClRightPreSemiringTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (*Cl x1 x2) = ((* Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalCl Ri (+Cl x1 x2) = ((+ Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((RightPreSemiring A) -> ((Vec A n) -> ((OpRightPreSemiringTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (*OL x1 x2) = ((* Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOpB Ri vars (+OL x1 x2) = ((+ Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((RightPreSemiring A) -> ((Vec A n) -> ((OpRightPreSemiringTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (*OL2 x1 x2) = ((* Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    evalOp Ri vars (+OL2 x1 x2) = ((+ Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (RightPreSemiringTerm -> Set)} -> (((x1 x2 : RightPreSemiringTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : RightPreSemiringTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : RightPreSemiringTerm) -> (P x))))
    inductionB {p} p*l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionB {p} p*l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClRightPreSemiringTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRightPreSemiringTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClRightPreSemiringTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClRightPreSemiringTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p*cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRightPreSemiringTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRightPreSemiringTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpRightPreSemiringTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpRightPreSemiringTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p*ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRightPreSemiringTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRightPreSemiringTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpRightPreSemiringTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpRightPreSemiringTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    *L' : (RightPreSemiringTerm -> (RightPreSemiringTerm -> RightPreSemiringTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (RightPreSemiringTerm -> (RightPreSemiringTerm -> RightPreSemiringTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (RightPreSemiringTerm -> (Staged RightPreSemiringTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClRightPreSemiringTerm A) -> ((ClRightPreSemiringTerm A) -> (ClRightPreSemiringTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClRightPreSemiringTerm A) -> ((ClRightPreSemiringTerm A) -> (ClRightPreSemiringTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClRightPreSemiringTerm A) -> (Staged (ClRightPreSemiringTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpRightPreSemiringTerm n) -> ((OpRightPreSemiringTerm n) -> (OpRightPreSemiringTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpRightPreSemiringTerm n) -> ((OpRightPreSemiringTerm n) -> (OpRightPreSemiringTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRightPreSemiringTerm n) -> (Staged (OpRightPreSemiringTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpRightPreSemiringTerm2 n A) -> ((OpRightPreSemiringTerm2 n A) -> (OpRightPreSemiringTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpRightPreSemiringTerm2 n A) -> ((OpRightPreSemiringTerm2 n A) -> (OpRightPreSemiringTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRightPreSemiringTerm2 n A) -> (Staged (OpRightPreSemiringTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RightQuasiGroup  where
    record RightQuasiGroup (A : Set) : Set where
      constructor RightQuasiGroupC
      field
        op : (A -> (A -> A))
        rinv : (A -> (A -> A))
        rightCancel : {x y : A} -> (op (rinv y x) x) == y
        rightCancelOp : {x y : A} -> (rinv (op y x) x) == y
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
        rinvS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        rinvP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        rightCancelP : {xP yP : (Prod A A)} -> (opP (rinvP yP xP) xP) == yP
        rightCancelOpP : {xP yP : (Prod A A)} -> (rinvP (opP yP xP) xP) == yP
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RightQuasiGroup A1)) (Ri2 : (RightQuasiGroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Ri1) x1 x2)) == ((op Ri2) (hom x1) (hom x2))
        pres-rinv : {x1 x2 : A1} -> (hom ((rinv Ri1) x1 x2)) == ((rinv Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RightQuasiGroup A1)) (Ri2 : (RightQuasiGroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Ri1) x1 x2) ((op Ri2) y1 y2))))
        interp-rinv : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((rinv Ri1) x1 x2) ((rinv Ri2) y1 y2))))
    data RightQuasiGroupTerm  : Set where
      opL : (RightQuasiGroupTerm -> (RightQuasiGroupTerm -> RightQuasiGroupTerm))
      rinvL : (RightQuasiGroupTerm -> (RightQuasiGroupTerm -> RightQuasiGroupTerm))
    data ClRightQuasiGroupTerm (A : Set) : Set where
      sing : (A -> (ClRightQuasiGroupTerm A))
      opCl : ((ClRightQuasiGroupTerm A) -> ((ClRightQuasiGroupTerm A) -> (ClRightQuasiGroupTerm A)))
      rinvCl : ((ClRightQuasiGroupTerm A) -> ((ClRightQuasiGroupTerm A) -> (ClRightQuasiGroupTerm A)))
    data OpRightQuasiGroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRightQuasiGroupTerm n))
      opOL : ((OpRightQuasiGroupTerm n) -> ((OpRightQuasiGroupTerm n) -> (OpRightQuasiGroupTerm n)))
      rinvOL : ((OpRightQuasiGroupTerm n) -> ((OpRightQuasiGroupTerm n) -> (OpRightQuasiGroupTerm n)))
    data OpRightQuasiGroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRightQuasiGroupTerm2 n A))
      sing2 : (A -> (OpRightQuasiGroupTerm2 n A))
      opOL2 : ((OpRightQuasiGroupTerm2 n A) -> ((OpRightQuasiGroupTerm2 n A) -> (OpRightQuasiGroupTerm2 n A)))
      rinvOL2 : ((OpRightQuasiGroupTerm2 n A) -> ((OpRightQuasiGroupTerm2 n A) -> (OpRightQuasiGroupTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRightQuasiGroupTerm A) -> (ClRightQuasiGroupTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (rinvCl x1 x2) = (rinvCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRightQuasiGroupTerm n) -> (OpRightQuasiGroupTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (rinvOL x1 x2) = (rinvOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRightQuasiGroupTerm2 n A) -> (OpRightQuasiGroupTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (rinvOL2 x1 x2) = (rinvOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RightQuasiGroup A) -> (RightQuasiGroupTerm -> A))
    evalB Ri (opL x1 x2) = ((op Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalB Ri (rinvL x1 x2) = ((rinv Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((RightQuasiGroup A) -> ((ClRightQuasiGroupTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (opCl x1 x2) = ((op Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalCl Ri (rinvCl x1 x2) = ((rinv Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((RightQuasiGroup A) -> ((Vec A n) -> ((OpRightQuasiGroupTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (opOL x1 x2) = ((op Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOpB Ri vars (rinvOL x1 x2) = ((rinv Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((RightQuasiGroup A) -> ((Vec A n) -> ((OpRightQuasiGroupTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (opOL2 x1 x2) = ((op Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    evalOp Ri vars (rinvOL2 x1 x2) = ((rinv Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (RightQuasiGroupTerm -> Set)} -> (((x1 x2 : RightQuasiGroupTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> (((x1 x2 : RightQuasiGroupTerm) -> ((P x1) -> ((P x2) -> (P (rinvL x1 x2))))) -> ((x : RightQuasiGroupTerm) -> (P x))))
    inductionB {p} popl prinvl (opL x1 x2) = (popl _ _ (inductionB {p} popl prinvl x1) (inductionB {p} popl prinvl x2)) 
    inductionB {p} popl prinvl (rinvL x1 x2) = (prinvl _ _ (inductionB {p} popl prinvl x1) (inductionB {p} popl prinvl x2)) 
    inductionCl : {A : Set} {P : ((ClRightQuasiGroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRightQuasiGroupTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> (((x1 x2 : (ClRightQuasiGroupTerm A)) -> ((P x1) -> ((P x2) -> (P (rinvCl x1 x2))))) -> ((x : (ClRightQuasiGroupTerm A)) -> (P x)))))
    inductionCl {_} {p} psing popcl prinvcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl prinvcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl prinvcl x1) (inductionCl {_} {p} psing popcl prinvcl x2)) 
    inductionCl {_} {p} psing popcl prinvcl (rinvCl x1 x2) = (prinvcl _ _ (inductionCl {_} {p} psing popcl prinvcl x1) (inductionCl {_} {p} psing popcl prinvcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRightQuasiGroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRightQuasiGroupTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> (((x1 x2 : (OpRightQuasiGroupTerm n)) -> ((P x1) -> ((P x2) -> (P (rinvOL x1 x2))))) -> ((x : (OpRightQuasiGroupTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv popol prinvol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol prinvol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol prinvol x1) (inductionOpB {_} {p} pv popol prinvol x2)) 
    inductionOpB {_} {p} pv popol prinvol (rinvOL x1 x2) = (prinvol _ _ (inductionOpB {_} {p} pv popol prinvol x1) (inductionOpB {_} {p} pv popol prinvol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRightQuasiGroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRightQuasiGroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> (((x1 x2 : (OpRightQuasiGroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (rinvOL2 x1 x2))))) -> ((x : (OpRightQuasiGroupTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 (rinvOL2 x1 x2) = (prinvol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 prinvol2 x2)) 
    opL' : (RightQuasiGroupTerm -> (RightQuasiGroupTerm -> RightQuasiGroupTerm))
    opL' x1 x2 = (opL x1 x2) 
    rinvL' : (RightQuasiGroupTerm -> (RightQuasiGroupTerm -> RightQuasiGroupTerm))
    rinvL' x1 x2 = (rinvL x1 x2) 
    stageB : (RightQuasiGroupTerm -> (Staged RightQuasiGroupTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    stageB (rinvL x1 x2) = (stage2 rinvL' (codeLift2 rinvL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClRightQuasiGroupTerm A) -> ((ClRightQuasiGroupTerm A) -> (ClRightQuasiGroupTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    rinvCl' : {A : Set} -> ((ClRightQuasiGroupTerm A) -> ((ClRightQuasiGroupTerm A) -> (ClRightQuasiGroupTerm A)))
    rinvCl' x1 x2 = (rinvCl x1 x2) 
    stageCl : {A : Set} -> ((ClRightQuasiGroupTerm A) -> (Staged (ClRightQuasiGroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    stageCl (rinvCl x1 x2) = (stage2 rinvCl' (codeLift2 rinvCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpRightQuasiGroupTerm n) -> ((OpRightQuasiGroupTerm n) -> (OpRightQuasiGroupTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    rinvOL' : {n : Nat} -> ((OpRightQuasiGroupTerm n) -> ((OpRightQuasiGroupTerm n) -> (OpRightQuasiGroupTerm n)))
    rinvOL' x1 x2 = (rinvOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRightQuasiGroupTerm n) -> (Staged (OpRightQuasiGroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (rinvOL x1 x2) = (stage2 rinvOL' (codeLift2 rinvOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpRightQuasiGroupTerm2 n A) -> ((OpRightQuasiGroupTerm2 n A) -> (OpRightQuasiGroupTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    rinvOL2' : {n : Nat} {A : Set} -> ((OpRightQuasiGroupTerm2 n A) -> ((OpRightQuasiGroupTerm2 n A) -> (OpRightQuasiGroupTerm2 n A)))
    rinvOL2' x1 x2 = (rinvOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRightQuasiGroupTerm2 n A) -> (Staged (OpRightQuasiGroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    stageOp (rinvOL2 x1 x2) = (stage2 rinvOL2' (codeLift2 rinvOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
        rinvT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RightRack  where
    record RightRack (A : Set) : Set where
      constructor RightRackC
      field
        <| : (A -> (A -> A))
        |> : (A -> (A -> A))
        rightDistributive : {x y z : A} -> (<| (<| y z) x) == (<| (<| y x) (<| z x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        <|S : (AS -> (AS -> AS))
        |>S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        <|P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        |>P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        rightDistributiveP : {xP yP zP : (Prod A A)} -> (<|P (<|P yP zP) xP) == (<|P (<|P yP xP) (<|P zP xP))
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RightRack A1)) (Ri2 : (RightRack A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-<| : {x1 x2 : A1} -> (hom ((<| Ri1) x1 x2)) == ((<| Ri2) (hom x1) (hom x2))
        pres-|> : {x1 x2 : A1} -> (hom ((|> Ri1) x1 x2)) == ((|> Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RightRack A1)) (Ri2 : (RightRack A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-<| : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((<| Ri1) x1 x2) ((<| Ri2) y1 y2))))
        interp-|> : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((|> Ri1) x1 x2) ((|> Ri2) y1 y2))))
    data RightRackTerm  : Set where
      <|L : (RightRackTerm -> (RightRackTerm -> RightRackTerm))
      |>L : (RightRackTerm -> (RightRackTerm -> RightRackTerm))
    data ClRightRackTerm (A : Set) : Set where
      sing : (A -> (ClRightRackTerm A))
      <|Cl : ((ClRightRackTerm A) -> ((ClRightRackTerm A) -> (ClRightRackTerm A)))
      |>Cl : ((ClRightRackTerm A) -> ((ClRightRackTerm A) -> (ClRightRackTerm A)))
    data OpRightRackTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRightRackTerm n))
      <|OL : ((OpRightRackTerm n) -> ((OpRightRackTerm n) -> (OpRightRackTerm n)))
      |>OL : ((OpRightRackTerm n) -> ((OpRightRackTerm n) -> (OpRightRackTerm n)))
    data OpRightRackTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRightRackTerm2 n A))
      sing2 : (A -> (OpRightRackTerm2 n A))
      <|OL2 : ((OpRightRackTerm2 n A) -> ((OpRightRackTerm2 n A) -> (OpRightRackTerm2 n A)))
      |>OL2 : ((OpRightRackTerm2 n A) -> ((OpRightRackTerm2 n A) -> (OpRightRackTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRightRackTerm A) -> (ClRightRackTerm A))
    simplifyCl (<|Cl x1 x2) = (<|Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (|>Cl x1 x2) = (|>Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRightRackTerm n) -> (OpRightRackTerm n))
    simplifyOpB (<|OL x1 x2) = (<|OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (|>OL x1 x2) = (|>OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRightRackTerm2 n A) -> (OpRightRackTerm2 n A))
    simplifyOp (<|OL2 x1 x2) = (<|OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (|>OL2 x1 x2) = (|>OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RightRack A) -> (RightRackTerm -> A))
    evalB Ri (<|L x1 x2) = ((<| Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalB Ri (|>L x1 x2) = ((|> Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((RightRack A) -> ((ClRightRackTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (<|Cl x1 x2) = ((<| Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalCl Ri (|>Cl x1 x2) = ((|> Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((RightRack A) -> ((Vec A n) -> ((OpRightRackTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (<|OL x1 x2) = ((<| Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOpB Ri vars (|>OL x1 x2) = ((|> Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((RightRack A) -> ((Vec A n) -> ((OpRightRackTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (<|OL2 x1 x2) = ((<| Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    evalOp Ri vars (|>OL2 x1 x2) = ((|> Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (RightRackTerm -> Set)} -> (((x1 x2 : RightRackTerm) -> ((P x1) -> ((P x2) -> (P (<|L x1 x2))))) -> (((x1 x2 : RightRackTerm) -> ((P x1) -> ((P x2) -> (P (|>L x1 x2))))) -> ((x : RightRackTerm) -> (P x))))
    inductionB {p} p<|l p|>l (<|L x1 x2) = (p<|l _ _ (inductionB {p} p<|l p|>l x1) (inductionB {p} p<|l p|>l x2)) 
    inductionB {p} p<|l p|>l (|>L x1 x2) = (p|>l _ _ (inductionB {p} p<|l p|>l x1) (inductionB {p} p<|l p|>l x2)) 
    inductionCl : {A : Set} {P : ((ClRightRackTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRightRackTerm A)) -> ((P x1) -> ((P x2) -> (P (<|Cl x1 x2))))) -> (((x1 x2 : (ClRightRackTerm A)) -> ((P x1) -> ((P x2) -> (P (|>Cl x1 x2))))) -> ((x : (ClRightRackTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p<|cl p|>cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p<|cl p|>cl (<|Cl x1 x2) = (p<|cl _ _ (inductionCl {_} {p} psing p<|cl p|>cl x1) (inductionCl {_} {p} psing p<|cl p|>cl x2)) 
    inductionCl {_} {p} psing p<|cl p|>cl (|>Cl x1 x2) = (p|>cl _ _ (inductionCl {_} {p} psing p<|cl p|>cl x1) (inductionCl {_} {p} psing p<|cl p|>cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRightRackTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRightRackTerm n)) -> ((P x1) -> ((P x2) -> (P (<|OL x1 x2))))) -> (((x1 x2 : (OpRightRackTerm n)) -> ((P x1) -> ((P x2) -> (P (|>OL x1 x2))))) -> ((x : (OpRightRackTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p<|ol p|>ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p<|ol p|>ol (<|OL x1 x2) = (p<|ol _ _ (inductionOpB {_} {p} pv p<|ol p|>ol x1) (inductionOpB {_} {p} pv p<|ol p|>ol x2)) 
    inductionOpB {_} {p} pv p<|ol p|>ol (|>OL x1 x2) = (p|>ol _ _ (inductionOpB {_} {p} pv p<|ol p|>ol x1) (inductionOpB {_} {p} pv p<|ol p|>ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRightRackTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRightRackTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (<|OL2 x1 x2))))) -> (((x1 x2 : (OpRightRackTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (|>OL2 x1 x2))))) -> ((x : (OpRightRackTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p<|ol2 p|>ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p<|ol2 p|>ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p<|ol2 p|>ol2 (<|OL2 x1 x2) = (p<|ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p<|ol2 p|>ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p<|ol2 p|>ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p<|ol2 p|>ol2 (|>OL2 x1 x2) = (p|>ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p<|ol2 p|>ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p<|ol2 p|>ol2 x2)) 
    <|L' : (RightRackTerm -> (RightRackTerm -> RightRackTerm))
    <|L' x1 x2 = (<|L x1 x2) 
    |>L' : (RightRackTerm -> (RightRackTerm -> RightRackTerm))
    |>L' x1 x2 = (|>L x1 x2) 
    stageB : (RightRackTerm -> (Staged RightRackTerm))
    stageB (<|L x1 x2) = (stage2 <|L' (codeLift2 <|L') (stageB x1) (stageB x2)) 
    stageB (|>L x1 x2) = (stage2 |>L' (codeLift2 |>L') (stageB x1) (stageB x2)) 
    <|Cl' : {A : Set} -> ((ClRightRackTerm A) -> ((ClRightRackTerm A) -> (ClRightRackTerm A)))
    <|Cl' x1 x2 = (<|Cl x1 x2) 
    |>Cl' : {A : Set} -> ((ClRightRackTerm A) -> ((ClRightRackTerm A) -> (ClRightRackTerm A)))
    |>Cl' x1 x2 = (|>Cl x1 x2) 
    stageCl : {A : Set} -> ((ClRightRackTerm A) -> (Staged (ClRightRackTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (<|Cl x1 x2) = (stage2 <|Cl' (codeLift2 <|Cl') (stageCl x1) (stageCl x2)) 
    stageCl (|>Cl x1 x2) = (stage2 |>Cl' (codeLift2 |>Cl') (stageCl x1) (stageCl x2)) 
    <|OL' : {n : Nat} -> ((OpRightRackTerm n) -> ((OpRightRackTerm n) -> (OpRightRackTerm n)))
    <|OL' x1 x2 = (<|OL x1 x2) 
    |>OL' : {n : Nat} -> ((OpRightRackTerm n) -> ((OpRightRackTerm n) -> (OpRightRackTerm n)))
    |>OL' x1 x2 = (|>OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRightRackTerm n) -> (Staged (OpRightRackTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (<|OL x1 x2) = (stage2 <|OL' (codeLift2 <|OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (|>OL x1 x2) = (stage2 |>OL' (codeLift2 |>OL') (stageOpB x1) (stageOpB x2)) 
    <|OL2' : {n : Nat} {A : Set} -> ((OpRightRackTerm2 n A) -> ((OpRightRackTerm2 n A) -> (OpRightRackTerm2 n A)))
    <|OL2' x1 x2 = (<|OL2 x1 x2) 
    |>OL2' : {n : Nat} {A : Set} -> ((OpRightRackTerm2 n A) -> ((OpRightRackTerm2 n A) -> (OpRightRackTerm2 n A)))
    |>OL2' x1 x2 = (|>OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRightRackTerm2 n A) -> (Staged (OpRightRackTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (<|OL2 x1 x2) = (stage2 <|OL2' (codeLift2 <|OL2') (stageOp x1) (stageOp x2)) 
    stageOp (|>OL2 x1 x2) = (stage2 |>OL2' (codeLift2 |>OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        <|T : ((Repr A) -> ((Repr A) -> (Repr A)))
        |>T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RightRingoid  where
    record RightRingoid (A : Set) : Set where
      constructor RightRingoidC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        rightDistributive_*_+ : {x y z : A} -> (* (+ y z) x) == (+ (* y x) (* z x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        rightDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P (+P yP zP) xP) == (+P (*P yP xP) (*P zP xP))
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RightRingoid A1)) (Ri2 : (RightRingoid A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Ri1) x1 x2)) == ((* Ri2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ri1) x1 x2)) == ((+ Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RightRingoid A1)) (Ri2 : (RightRingoid A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Ri1) x1 x2) ((* Ri2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ri1) x1 x2) ((+ Ri2) y1 y2))))
    data RightRingoidTerm  : Set where
      *L : (RightRingoidTerm -> (RightRingoidTerm -> RightRingoidTerm))
      +L : (RightRingoidTerm -> (RightRingoidTerm -> RightRingoidTerm))
    data ClRightRingoidTerm (A : Set) : Set where
      sing : (A -> (ClRightRingoidTerm A))
      *Cl : ((ClRightRingoidTerm A) -> ((ClRightRingoidTerm A) -> (ClRightRingoidTerm A)))
      +Cl : ((ClRightRingoidTerm A) -> ((ClRightRingoidTerm A) -> (ClRightRingoidTerm A)))
    data OpRightRingoidTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRightRingoidTerm n))
      *OL : ((OpRightRingoidTerm n) -> ((OpRightRingoidTerm n) -> (OpRightRingoidTerm n)))
      +OL : ((OpRightRingoidTerm n) -> ((OpRightRingoidTerm n) -> (OpRightRingoidTerm n)))
    data OpRightRingoidTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRightRingoidTerm2 n A))
      sing2 : (A -> (OpRightRingoidTerm2 n A))
      *OL2 : ((OpRightRingoidTerm2 n A) -> ((OpRightRingoidTerm2 n A) -> (OpRightRingoidTerm2 n A)))
      +OL2 : ((OpRightRingoidTerm2 n A) -> ((OpRightRingoidTerm2 n A) -> (OpRightRingoidTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRightRingoidTerm A) -> (ClRightRingoidTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRightRingoidTerm n) -> (OpRightRingoidTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRightRingoidTerm2 n A) -> (OpRightRingoidTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RightRingoid A) -> (RightRingoidTerm -> A))
    evalB Ri (*L x1 x2) = ((* Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalB Ri (+L x1 x2) = ((+ Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((RightRingoid A) -> ((ClRightRingoidTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (*Cl x1 x2) = ((* Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalCl Ri (+Cl x1 x2) = ((+ Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((RightRingoid A) -> ((Vec A n) -> ((OpRightRingoidTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (*OL x1 x2) = ((* Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOpB Ri vars (+OL x1 x2) = ((+ Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((RightRingoid A) -> ((Vec A n) -> ((OpRightRingoidTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (*OL2 x1 x2) = ((* Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    evalOp Ri vars (+OL2 x1 x2) = ((+ Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (RightRingoidTerm -> Set)} -> (((x1 x2 : RightRingoidTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : RightRingoidTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : RightRingoidTerm) -> (P x))))
    inductionB {p} p*l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionB {p} p*l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClRightRingoidTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRightRingoidTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClRightRingoidTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClRightRingoidTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p*cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRightRingoidTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRightRingoidTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpRightRingoidTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpRightRingoidTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p*ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRightRingoidTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRightRingoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpRightRingoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpRightRingoidTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    *L' : (RightRingoidTerm -> (RightRingoidTerm -> RightRingoidTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (RightRingoidTerm -> (RightRingoidTerm -> RightRingoidTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (RightRingoidTerm -> (Staged RightRingoidTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClRightRingoidTerm A) -> ((ClRightRingoidTerm A) -> (ClRightRingoidTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClRightRingoidTerm A) -> ((ClRightRingoidTerm A) -> (ClRightRingoidTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClRightRingoidTerm A) -> (Staged (ClRightRingoidTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpRightRingoidTerm n) -> ((OpRightRingoidTerm n) -> (OpRightRingoidTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpRightRingoidTerm n) -> ((OpRightRingoidTerm n) -> (OpRightRingoidTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRightRingoidTerm n) -> (Staged (OpRightRingoidTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpRightRingoidTerm2 n A) -> ((OpRightRingoidTerm2 n A) -> (OpRightRingoidTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpRightRingoidTerm2 n A) -> ((OpRightRingoidTerm2 n A) -> (OpRightRingoidTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRightRingoidTerm2 n A) -> (Staged (OpRightRingoidTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RightSelfInverse  where
    record RightSelfInverse (A : Set) : Set where
      constructor RightSelfInverseC
      field
        |> : (A -> (A -> A))
        rightSelfInverse_|> : {x y : A} -> (|> (|> x y) y) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        |>S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        |>P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        rightSelfInverse_|>P : {xP yP : (Prod A A)} -> (|>P (|>P xP yP) yP) == xP
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RightSelfInverse A1)) (Ri2 : (RightSelfInverse A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-|> : {x1 x2 : A1} -> (hom ((|> Ri1) x1 x2)) == ((|> Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RightSelfInverse A1)) (Ri2 : (RightSelfInverse A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-|> : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((|> Ri1) x1 x2) ((|> Ri2) y1 y2))))
    data RightSelfInverseTerm  : Set where
      |>L : (RightSelfInverseTerm -> (RightSelfInverseTerm -> RightSelfInverseTerm))
    data ClRightSelfInverseTerm (A : Set) : Set where
      sing : (A -> (ClRightSelfInverseTerm A))
      |>Cl : ((ClRightSelfInverseTerm A) -> ((ClRightSelfInverseTerm A) -> (ClRightSelfInverseTerm A)))
    data OpRightSelfInverseTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRightSelfInverseTerm n))
      |>OL : ((OpRightSelfInverseTerm n) -> ((OpRightSelfInverseTerm n) -> (OpRightSelfInverseTerm n)))
    data OpRightSelfInverseTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRightSelfInverseTerm2 n A))
      sing2 : (A -> (OpRightSelfInverseTerm2 n A))
      |>OL2 : ((OpRightSelfInverseTerm2 n A) -> ((OpRightSelfInverseTerm2 n A) -> (OpRightSelfInverseTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRightSelfInverseTerm A) -> (ClRightSelfInverseTerm A))
    simplifyCl (|>Cl x1 x2) = (|>Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRightSelfInverseTerm n) -> (OpRightSelfInverseTerm n))
    simplifyOpB (|>OL x1 x2) = (|>OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRightSelfInverseTerm2 n A) -> (OpRightSelfInverseTerm2 n A))
    simplifyOp (|>OL2 x1 x2) = (|>OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RightSelfInverse A) -> (RightSelfInverseTerm -> A))
    evalB Ri (|>L x1 x2) = ((|> Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((RightSelfInverse A) -> ((ClRightSelfInverseTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (|>Cl x1 x2) = ((|> Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((RightSelfInverse A) -> ((Vec A n) -> ((OpRightSelfInverseTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (|>OL x1 x2) = ((|> Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((RightSelfInverse A) -> ((Vec A n) -> ((OpRightSelfInverseTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (|>OL2 x1 x2) = ((|> Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (RightSelfInverseTerm -> Set)} -> (((x1 x2 : RightSelfInverseTerm) -> ((P x1) -> ((P x2) -> (P (|>L x1 x2))))) -> ((x : RightSelfInverseTerm) -> (P x)))
    inductionB {p} p|>l (|>L x1 x2) = (p|>l _ _ (inductionB {p} p|>l x1) (inductionB {p} p|>l x2)) 
    inductionCl : {A : Set} {P : ((ClRightSelfInverseTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRightSelfInverseTerm A)) -> ((P x1) -> ((P x2) -> (P (|>Cl x1 x2))))) -> ((x : (ClRightSelfInverseTerm A)) -> (P x))))
    inductionCl {_} {p} psing p|>cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p|>cl (|>Cl x1 x2) = (p|>cl _ _ (inductionCl {_} {p} psing p|>cl x1) (inductionCl {_} {p} psing p|>cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRightSelfInverseTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRightSelfInverseTerm n)) -> ((P x1) -> ((P x2) -> (P (|>OL x1 x2))))) -> ((x : (OpRightSelfInverseTerm n)) -> (P x))))
    inductionOpB {_} {p} pv p|>ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p|>ol (|>OL x1 x2) = (p|>ol _ _ (inductionOpB {_} {p} pv p|>ol x1) (inductionOpB {_} {p} pv p|>ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRightSelfInverseTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRightSelfInverseTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (|>OL2 x1 x2))))) -> ((x : (OpRightSelfInverseTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 (|>OL2 x1 x2) = (p|>ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 x2)) 
    |>L' : (RightSelfInverseTerm -> (RightSelfInverseTerm -> RightSelfInverseTerm))
    |>L' x1 x2 = (|>L x1 x2) 
    stageB : (RightSelfInverseTerm -> (Staged RightSelfInverseTerm))
    stageB (|>L x1 x2) = (stage2 |>L' (codeLift2 |>L') (stageB x1) (stageB x2)) 
    |>Cl' : {A : Set} -> ((ClRightSelfInverseTerm A) -> ((ClRightSelfInverseTerm A) -> (ClRightSelfInverseTerm A)))
    |>Cl' x1 x2 = (|>Cl x1 x2) 
    stageCl : {A : Set} -> ((ClRightSelfInverseTerm A) -> (Staged (ClRightSelfInverseTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (|>Cl x1 x2) = (stage2 |>Cl' (codeLift2 |>Cl') (stageCl x1) (stageCl x2)) 
    |>OL' : {n : Nat} -> ((OpRightSelfInverseTerm n) -> ((OpRightSelfInverseTerm n) -> (OpRightSelfInverseTerm n)))
    |>OL' x1 x2 = (|>OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRightSelfInverseTerm n) -> (Staged (OpRightSelfInverseTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (|>OL x1 x2) = (stage2 |>OL' (codeLift2 |>OL') (stageOpB x1) (stageOpB x2)) 
    |>OL2' : {n : Nat} {A : Set} -> ((OpRightSelfInverseTerm2 n A) -> ((OpRightSelfInverseTerm2 n A) -> (OpRightSelfInverseTerm2 n A)))
    |>OL2' x1 x2 = (|>OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRightSelfInverseTerm2 n A) -> (Staged (OpRightSelfInverseTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (|>OL2 x1 x2) = (stage2 |>OL2' (codeLift2 |>OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        |>T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RightShelf  where
    record RightShelf (A : Set) : Set where
      constructor RightShelfC
      field
        <| : (A -> (A -> A))
        rightDistributive : {x y z : A} -> (<| (<| y z) x) == (<| (<| y x) (<| z x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        <|S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        <|P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        rightDistributiveP : {xP yP zP : (Prod A A)} -> (<|P (<|P yP zP) xP) == (<|P (<|P yP xP) (<|P zP xP))
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RightShelf A1)) (Ri2 : (RightShelf A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-<| : {x1 x2 : A1} -> (hom ((<| Ri1) x1 x2)) == ((<| Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RightShelf A1)) (Ri2 : (RightShelf A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-<| : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((<| Ri1) x1 x2) ((<| Ri2) y1 y2))))
    data RightShelfTerm  : Set where
      <|L : (RightShelfTerm -> (RightShelfTerm -> RightShelfTerm))
    data ClRightShelfTerm (A : Set) : Set where
      sing : (A -> (ClRightShelfTerm A))
      <|Cl : ((ClRightShelfTerm A) -> ((ClRightShelfTerm A) -> (ClRightShelfTerm A)))
    data OpRightShelfTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRightShelfTerm n))
      <|OL : ((OpRightShelfTerm n) -> ((OpRightShelfTerm n) -> (OpRightShelfTerm n)))
    data OpRightShelfTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRightShelfTerm2 n A))
      sing2 : (A -> (OpRightShelfTerm2 n A))
      <|OL2 : ((OpRightShelfTerm2 n A) -> ((OpRightShelfTerm2 n A) -> (OpRightShelfTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRightShelfTerm A) -> (ClRightShelfTerm A))
    simplifyCl (<|Cl x1 x2) = (<|Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRightShelfTerm n) -> (OpRightShelfTerm n))
    simplifyOpB (<|OL x1 x2) = (<|OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRightShelfTerm2 n A) -> (OpRightShelfTerm2 n A))
    simplifyOp (<|OL2 x1 x2) = (<|OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RightShelf A) -> (RightShelfTerm -> A))
    evalB Ri (<|L x1 x2) = ((<| Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((RightShelf A) -> ((ClRightShelfTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (<|Cl x1 x2) = ((<| Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((RightShelf A) -> ((Vec A n) -> ((OpRightShelfTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (<|OL x1 x2) = ((<| Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((RightShelf A) -> ((Vec A n) -> ((OpRightShelfTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (<|OL2 x1 x2) = ((<| Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (RightShelfTerm -> Set)} -> (((x1 x2 : RightShelfTerm) -> ((P x1) -> ((P x2) -> (P (<|L x1 x2))))) -> ((x : RightShelfTerm) -> (P x)))
    inductionB {p} p<|l (<|L x1 x2) = (p<|l _ _ (inductionB {p} p<|l x1) (inductionB {p} p<|l x2)) 
    inductionCl : {A : Set} {P : ((ClRightShelfTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRightShelfTerm A)) -> ((P x1) -> ((P x2) -> (P (<|Cl x1 x2))))) -> ((x : (ClRightShelfTerm A)) -> (P x))))
    inductionCl {_} {p} psing p<|cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p<|cl (<|Cl x1 x2) = (p<|cl _ _ (inductionCl {_} {p} psing p<|cl x1) (inductionCl {_} {p} psing p<|cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRightShelfTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRightShelfTerm n)) -> ((P x1) -> ((P x2) -> (P (<|OL x1 x2))))) -> ((x : (OpRightShelfTerm n)) -> (P x))))
    inductionOpB {_} {p} pv p<|ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p<|ol (<|OL x1 x2) = (p<|ol _ _ (inductionOpB {_} {p} pv p<|ol x1) (inductionOpB {_} {p} pv p<|ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRightShelfTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRightShelfTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (<|OL2 x1 x2))))) -> ((x : (OpRightShelfTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 p<|ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p<|ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p<|ol2 (<|OL2 x1 x2) = (p<|ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p<|ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p<|ol2 x2)) 
    <|L' : (RightShelfTerm -> (RightShelfTerm -> RightShelfTerm))
    <|L' x1 x2 = (<|L x1 x2) 
    stageB : (RightShelfTerm -> (Staged RightShelfTerm))
    stageB (<|L x1 x2) = (stage2 <|L' (codeLift2 <|L') (stageB x1) (stageB x2)) 
    <|Cl' : {A : Set} -> ((ClRightShelfTerm A) -> ((ClRightShelfTerm A) -> (ClRightShelfTerm A)))
    <|Cl' x1 x2 = (<|Cl x1 x2) 
    stageCl : {A : Set} -> ((ClRightShelfTerm A) -> (Staged (ClRightShelfTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (<|Cl x1 x2) = (stage2 <|Cl' (codeLift2 <|Cl') (stageCl x1) (stageCl x2)) 
    <|OL' : {n : Nat} -> ((OpRightShelfTerm n) -> ((OpRightShelfTerm n) -> (OpRightShelfTerm n)))
    <|OL' x1 x2 = (<|OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRightShelfTerm n) -> (Staged (OpRightShelfTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (<|OL x1 x2) = (stage2 <|OL' (codeLift2 <|OL') (stageOpB x1) (stageOpB x2)) 
    <|OL2' : {n : Nat} {A : Set} -> ((OpRightShelfTerm2 n A) -> ((OpRightShelfTerm2 n A) -> (OpRightShelfTerm2 n A)))
    <|OL2' x1 x2 = (<|OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRightShelfTerm2 n A) -> (Staged (OpRightShelfTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (<|OL2 x1 x2) = (stage2 <|OL2' (codeLift2 <|OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        <|T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RightShelfSig  where
    record RightShelfSig (A : Set) : Set where
      constructor RightShelfSigC
      field
        <| : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        <|S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        <|P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RightShelfSig A1)) (Ri2 : (RightShelfSig A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-<| : {x1 x2 : A1} -> (hom ((<| Ri1) x1 x2)) == ((<| Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RightShelfSig A1)) (Ri2 : (RightShelfSig A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-<| : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((<| Ri1) x1 x2) ((<| Ri2) y1 y2))))
    data RightShelfSigTerm  : Set where
      <|L : (RightShelfSigTerm -> (RightShelfSigTerm -> RightShelfSigTerm))
    data ClRightShelfSigTerm (A : Set) : Set where
      sing : (A -> (ClRightShelfSigTerm A))
      <|Cl : ((ClRightShelfSigTerm A) -> ((ClRightShelfSigTerm A) -> (ClRightShelfSigTerm A)))
    data OpRightShelfSigTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRightShelfSigTerm n))
      <|OL : ((OpRightShelfSigTerm n) -> ((OpRightShelfSigTerm n) -> (OpRightShelfSigTerm n)))
    data OpRightShelfSigTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRightShelfSigTerm2 n A))
      sing2 : (A -> (OpRightShelfSigTerm2 n A))
      <|OL2 : ((OpRightShelfSigTerm2 n A) -> ((OpRightShelfSigTerm2 n A) -> (OpRightShelfSigTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRightShelfSigTerm A) -> (ClRightShelfSigTerm A))
    simplifyCl (<|Cl x1 x2) = (<|Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRightShelfSigTerm n) -> (OpRightShelfSigTerm n))
    simplifyOpB (<|OL x1 x2) = (<|OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRightShelfSigTerm2 n A) -> (OpRightShelfSigTerm2 n A))
    simplifyOp (<|OL2 x1 x2) = (<|OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RightShelfSig A) -> (RightShelfSigTerm -> A))
    evalB Ri (<|L x1 x2) = ((<| Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((RightShelfSig A) -> ((ClRightShelfSigTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (<|Cl x1 x2) = ((<| Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((RightShelfSig A) -> ((Vec A n) -> ((OpRightShelfSigTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (<|OL x1 x2) = ((<| Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((RightShelfSig A) -> ((Vec A n) -> ((OpRightShelfSigTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (<|OL2 x1 x2) = ((<| Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (RightShelfSigTerm -> Set)} -> (((x1 x2 : RightShelfSigTerm) -> ((P x1) -> ((P x2) -> (P (<|L x1 x2))))) -> ((x : RightShelfSigTerm) -> (P x)))
    inductionB {p} p<|l (<|L x1 x2) = (p<|l _ _ (inductionB {p} p<|l x1) (inductionB {p} p<|l x2)) 
    inductionCl : {A : Set} {P : ((ClRightShelfSigTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRightShelfSigTerm A)) -> ((P x1) -> ((P x2) -> (P (<|Cl x1 x2))))) -> ((x : (ClRightShelfSigTerm A)) -> (P x))))
    inductionCl {_} {p} psing p<|cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p<|cl (<|Cl x1 x2) = (p<|cl _ _ (inductionCl {_} {p} psing p<|cl x1) (inductionCl {_} {p} psing p<|cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRightShelfSigTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRightShelfSigTerm n)) -> ((P x1) -> ((P x2) -> (P (<|OL x1 x2))))) -> ((x : (OpRightShelfSigTerm n)) -> (P x))))
    inductionOpB {_} {p} pv p<|ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p<|ol (<|OL x1 x2) = (p<|ol _ _ (inductionOpB {_} {p} pv p<|ol x1) (inductionOpB {_} {p} pv p<|ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRightShelfSigTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRightShelfSigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (<|OL2 x1 x2))))) -> ((x : (OpRightShelfSigTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 p<|ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p<|ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p<|ol2 (<|OL2 x1 x2) = (p<|ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p<|ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p<|ol2 x2)) 
    <|L' : (RightShelfSigTerm -> (RightShelfSigTerm -> RightShelfSigTerm))
    <|L' x1 x2 = (<|L x1 x2) 
    stageB : (RightShelfSigTerm -> (Staged RightShelfSigTerm))
    stageB (<|L x1 x2) = (stage2 <|L' (codeLift2 <|L') (stageB x1) (stageB x2)) 
    <|Cl' : {A : Set} -> ((ClRightShelfSigTerm A) -> ((ClRightShelfSigTerm A) -> (ClRightShelfSigTerm A)))
    <|Cl' x1 x2 = (<|Cl x1 x2) 
    stageCl : {A : Set} -> ((ClRightShelfSigTerm A) -> (Staged (ClRightShelfSigTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (<|Cl x1 x2) = (stage2 <|Cl' (codeLift2 <|Cl') (stageCl x1) (stageCl x2)) 
    <|OL' : {n : Nat} -> ((OpRightShelfSigTerm n) -> ((OpRightShelfSigTerm n) -> (OpRightShelfSigTerm n)))
    <|OL' x1 x2 = (<|OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRightShelfSigTerm n) -> (Staged (OpRightShelfSigTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (<|OL x1 x2) = (stage2 <|OL' (codeLift2 <|OL') (stageOpB x1) (stageOpB x2)) 
    <|OL2' : {n : Nat} {A : Set} -> ((OpRightShelfSigTerm2 n A) -> ((OpRightShelfSigTerm2 n A) -> (OpRightShelfSigTerm2 n A)))
    <|OL2' x1 x2 = (<|OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRightShelfSigTerm2 n A) -> (Staged (OpRightShelfSigTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (<|OL2 x1 x2) = (stage2 <|OL2' (codeLift2 <|OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        <|T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RightSpindle  where
    record RightSpindle (A : Set) : Set where
      constructor RightSpindleC
      field
        <| : (A -> (A -> A))
        rightDistributive : {x y z : A} -> (<| (<| y z) x) == (<| (<| y x) (<| z x))
        idempotent_<| : {x : A} -> (<| x x) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        <|S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        <|P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        rightDistributiveP : {xP yP zP : (Prod A A)} -> (<|P (<|P yP zP) xP) == (<|P (<|P yP xP) (<|P zP xP))
        idempotent_<|P : {xP : (Prod A A)} -> (<|P xP xP) == xP
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RightSpindle A1)) (Ri2 : (RightSpindle A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-<| : {x1 x2 : A1} -> (hom ((<| Ri1) x1 x2)) == ((<| Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RightSpindle A1)) (Ri2 : (RightSpindle A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-<| : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((<| Ri1) x1 x2) ((<| Ri2) y1 y2))))
    data RightSpindleTerm  : Set where
      <|L : (RightSpindleTerm -> (RightSpindleTerm -> RightSpindleTerm))
    data ClRightSpindleTerm (A : Set) : Set where
      sing : (A -> (ClRightSpindleTerm A))
      <|Cl : ((ClRightSpindleTerm A) -> ((ClRightSpindleTerm A) -> (ClRightSpindleTerm A)))
    data OpRightSpindleTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRightSpindleTerm n))
      <|OL : ((OpRightSpindleTerm n) -> ((OpRightSpindleTerm n) -> (OpRightSpindleTerm n)))
    data OpRightSpindleTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRightSpindleTerm2 n A))
      sing2 : (A -> (OpRightSpindleTerm2 n A))
      <|OL2 : ((OpRightSpindleTerm2 n A) -> ((OpRightSpindleTerm2 n A) -> (OpRightSpindleTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRightSpindleTerm A) -> (ClRightSpindleTerm A))
    simplifyCl (<|Cl x1 x2) = (<|Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRightSpindleTerm n) -> (OpRightSpindleTerm n))
    simplifyOpB (<|OL x1 x2) = (<|OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRightSpindleTerm2 n A) -> (OpRightSpindleTerm2 n A))
    simplifyOp (<|OL2 x1 x2) = (<|OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RightSpindle A) -> (RightSpindleTerm -> A))
    evalB Ri (<|L x1 x2) = ((<| Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((RightSpindle A) -> ((ClRightSpindleTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (<|Cl x1 x2) = ((<| Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((RightSpindle A) -> ((Vec A n) -> ((OpRightSpindleTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (<|OL x1 x2) = ((<| Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((RightSpindle A) -> ((Vec A n) -> ((OpRightSpindleTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (<|OL2 x1 x2) = ((<| Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (RightSpindleTerm -> Set)} -> (((x1 x2 : RightSpindleTerm) -> ((P x1) -> ((P x2) -> (P (<|L x1 x2))))) -> ((x : RightSpindleTerm) -> (P x)))
    inductionB {p} p<|l (<|L x1 x2) = (p<|l _ _ (inductionB {p} p<|l x1) (inductionB {p} p<|l x2)) 
    inductionCl : {A : Set} {P : ((ClRightSpindleTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRightSpindleTerm A)) -> ((P x1) -> ((P x2) -> (P (<|Cl x1 x2))))) -> ((x : (ClRightSpindleTerm A)) -> (P x))))
    inductionCl {_} {p} psing p<|cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p<|cl (<|Cl x1 x2) = (p<|cl _ _ (inductionCl {_} {p} psing p<|cl x1) (inductionCl {_} {p} psing p<|cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRightSpindleTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRightSpindleTerm n)) -> ((P x1) -> ((P x2) -> (P (<|OL x1 x2))))) -> ((x : (OpRightSpindleTerm n)) -> (P x))))
    inductionOpB {_} {p} pv p<|ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p<|ol (<|OL x1 x2) = (p<|ol _ _ (inductionOpB {_} {p} pv p<|ol x1) (inductionOpB {_} {p} pv p<|ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRightSpindleTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRightSpindleTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (<|OL2 x1 x2))))) -> ((x : (OpRightSpindleTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 p<|ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p<|ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p<|ol2 (<|OL2 x1 x2) = (p<|ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p<|ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p<|ol2 x2)) 
    <|L' : (RightSpindleTerm -> (RightSpindleTerm -> RightSpindleTerm))
    <|L' x1 x2 = (<|L x1 x2) 
    stageB : (RightSpindleTerm -> (Staged RightSpindleTerm))
    stageB (<|L x1 x2) = (stage2 <|L' (codeLift2 <|L') (stageB x1) (stageB x2)) 
    <|Cl' : {A : Set} -> ((ClRightSpindleTerm A) -> ((ClRightSpindleTerm A) -> (ClRightSpindleTerm A)))
    <|Cl' x1 x2 = (<|Cl x1 x2) 
    stageCl : {A : Set} -> ((ClRightSpindleTerm A) -> (Staged (ClRightSpindleTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (<|Cl x1 x2) = (stage2 <|Cl' (codeLift2 <|Cl') (stageCl x1) (stageCl x2)) 
    <|OL' : {n : Nat} -> ((OpRightSpindleTerm n) -> ((OpRightSpindleTerm n) -> (OpRightSpindleTerm n)))
    <|OL' x1 x2 = (<|OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRightSpindleTerm n) -> (Staged (OpRightSpindleTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (<|OL x1 x2) = (stage2 <|OL' (codeLift2 <|OL') (stageOpB x1) (stageOpB x2)) 
    <|OL2' : {n : Nat} {A : Set} -> ((OpRightSpindleTerm2 n A) -> ((OpRightSpindleTerm2 n A) -> (OpRightSpindleTerm2 n A)))
    <|OL2' x1 x2 = (<|OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRightSpindleTerm2 n A) -> (Staged (OpRightSpindleTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (<|OL2 x1 x2) = (stage2 <|OL2' (codeLift2 <|OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        <|T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RightSpindle_Shelf  where
    record RightSpindle_Shelf (A : Set) : Set where
      constructor RightSpindle_ShelfC
      field
        <| : (A -> (A -> A))
        rightDistributive : {x y z : A} -> (<| (<| y z) x) == (<| (<| y x) (<| z x))
        idempotent_<| : {x : A} -> (<| x x) == x
        |> : (A -> (A -> A))
        leftDistributive : {x y z : A} -> (|> x (|> y z)) == (|> (|> x y) (|> x z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        <|S : (AS -> (AS -> AS))
        |>S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        <|P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        |>P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        rightDistributiveP : {xP yP zP : (Prod A A)} -> (<|P (<|P yP zP) xP) == (<|P (<|P yP xP) (<|P zP xP))
        idempotent_<|P : {xP : (Prod A A)} -> (<|P xP xP) == xP
        leftDistributiveP : {xP yP zP : (Prod A A)} -> (|>P xP (|>P yP zP)) == (|>P (|>P xP yP) (|>P xP zP))
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RightSpindle_Shelf A1)) (Ri2 : (RightSpindle_Shelf A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-<| : {x1 x2 : A1} -> (hom ((<| Ri1) x1 x2)) == ((<| Ri2) (hom x1) (hom x2))
        pres-|> : {x1 x2 : A1} -> (hom ((|> Ri1) x1 x2)) == ((|> Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RightSpindle_Shelf A1)) (Ri2 : (RightSpindle_Shelf A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-<| : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((<| Ri1) x1 x2) ((<| Ri2) y1 y2))))
        interp-|> : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((|> Ri1) x1 x2) ((|> Ri2) y1 y2))))
    data RightSpindle_ShelfTerm  : Set where
      <|L : (RightSpindle_ShelfTerm -> (RightSpindle_ShelfTerm -> RightSpindle_ShelfTerm))
      |>L : (RightSpindle_ShelfTerm -> (RightSpindle_ShelfTerm -> RightSpindle_ShelfTerm))
    data ClRightSpindle_ShelfTerm (A : Set) : Set where
      sing : (A -> (ClRightSpindle_ShelfTerm A))
      <|Cl : ((ClRightSpindle_ShelfTerm A) -> ((ClRightSpindle_ShelfTerm A) -> (ClRightSpindle_ShelfTerm A)))
      |>Cl : ((ClRightSpindle_ShelfTerm A) -> ((ClRightSpindle_ShelfTerm A) -> (ClRightSpindle_ShelfTerm A)))
    data OpRightSpindle_ShelfTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRightSpindle_ShelfTerm n))
      <|OL : ((OpRightSpindle_ShelfTerm n) -> ((OpRightSpindle_ShelfTerm n) -> (OpRightSpindle_ShelfTerm n)))
      |>OL : ((OpRightSpindle_ShelfTerm n) -> ((OpRightSpindle_ShelfTerm n) -> (OpRightSpindle_ShelfTerm n)))
    data OpRightSpindle_ShelfTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRightSpindle_ShelfTerm2 n A))
      sing2 : (A -> (OpRightSpindle_ShelfTerm2 n A))
      <|OL2 : ((OpRightSpindle_ShelfTerm2 n A) -> ((OpRightSpindle_ShelfTerm2 n A) -> (OpRightSpindle_ShelfTerm2 n A)))
      |>OL2 : ((OpRightSpindle_ShelfTerm2 n A) -> ((OpRightSpindle_ShelfTerm2 n A) -> (OpRightSpindle_ShelfTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRightSpindle_ShelfTerm A) -> (ClRightSpindle_ShelfTerm A))
    simplifyCl (<|Cl x1 x2) = (<|Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (|>Cl x1 x2) = (|>Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRightSpindle_ShelfTerm n) -> (OpRightSpindle_ShelfTerm n))
    simplifyOpB (<|OL x1 x2) = (<|OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (|>OL x1 x2) = (|>OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRightSpindle_ShelfTerm2 n A) -> (OpRightSpindle_ShelfTerm2 n A))
    simplifyOp (<|OL2 x1 x2) = (<|OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (|>OL2 x1 x2) = (|>OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RightSpindle_Shelf A) -> (RightSpindle_ShelfTerm -> A))
    evalB Ri (<|L x1 x2) = ((<| Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalB Ri (|>L x1 x2) = ((|> Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((RightSpindle_Shelf A) -> ((ClRightSpindle_ShelfTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (<|Cl x1 x2) = ((<| Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalCl Ri (|>Cl x1 x2) = ((|> Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((RightSpindle_Shelf A) -> ((Vec A n) -> ((OpRightSpindle_ShelfTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (<|OL x1 x2) = ((<| Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOpB Ri vars (|>OL x1 x2) = ((|> Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((RightSpindle_Shelf A) -> ((Vec A n) -> ((OpRightSpindle_ShelfTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (<|OL2 x1 x2) = ((<| Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    evalOp Ri vars (|>OL2 x1 x2) = ((|> Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (RightSpindle_ShelfTerm -> Set)} -> (((x1 x2 : RightSpindle_ShelfTerm) -> ((P x1) -> ((P x2) -> (P (<|L x1 x2))))) -> (((x1 x2 : RightSpindle_ShelfTerm) -> ((P x1) -> ((P x2) -> (P (|>L x1 x2))))) -> ((x : RightSpindle_ShelfTerm) -> (P x))))
    inductionB {p} p<|l p|>l (<|L x1 x2) = (p<|l _ _ (inductionB {p} p<|l p|>l x1) (inductionB {p} p<|l p|>l x2)) 
    inductionB {p} p<|l p|>l (|>L x1 x2) = (p|>l _ _ (inductionB {p} p<|l p|>l x1) (inductionB {p} p<|l p|>l x2)) 
    inductionCl : {A : Set} {P : ((ClRightSpindle_ShelfTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRightSpindle_ShelfTerm A)) -> ((P x1) -> ((P x2) -> (P (<|Cl x1 x2))))) -> (((x1 x2 : (ClRightSpindle_ShelfTerm A)) -> ((P x1) -> ((P x2) -> (P (|>Cl x1 x2))))) -> ((x : (ClRightSpindle_ShelfTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p<|cl p|>cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p<|cl p|>cl (<|Cl x1 x2) = (p<|cl _ _ (inductionCl {_} {p} psing p<|cl p|>cl x1) (inductionCl {_} {p} psing p<|cl p|>cl x2)) 
    inductionCl {_} {p} psing p<|cl p|>cl (|>Cl x1 x2) = (p|>cl _ _ (inductionCl {_} {p} psing p<|cl p|>cl x1) (inductionCl {_} {p} psing p<|cl p|>cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRightSpindle_ShelfTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRightSpindle_ShelfTerm n)) -> ((P x1) -> ((P x2) -> (P (<|OL x1 x2))))) -> (((x1 x2 : (OpRightSpindle_ShelfTerm n)) -> ((P x1) -> ((P x2) -> (P (|>OL x1 x2))))) -> ((x : (OpRightSpindle_ShelfTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p<|ol p|>ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p<|ol p|>ol (<|OL x1 x2) = (p<|ol _ _ (inductionOpB {_} {p} pv p<|ol p|>ol x1) (inductionOpB {_} {p} pv p<|ol p|>ol x2)) 
    inductionOpB {_} {p} pv p<|ol p|>ol (|>OL x1 x2) = (p|>ol _ _ (inductionOpB {_} {p} pv p<|ol p|>ol x1) (inductionOpB {_} {p} pv p<|ol p|>ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRightSpindle_ShelfTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRightSpindle_ShelfTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (<|OL2 x1 x2))))) -> (((x1 x2 : (OpRightSpindle_ShelfTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (|>OL2 x1 x2))))) -> ((x : (OpRightSpindle_ShelfTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p<|ol2 p|>ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p<|ol2 p|>ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p<|ol2 p|>ol2 (<|OL2 x1 x2) = (p<|ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p<|ol2 p|>ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p<|ol2 p|>ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p<|ol2 p|>ol2 (|>OL2 x1 x2) = (p|>ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p<|ol2 p|>ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p<|ol2 p|>ol2 x2)) 
    <|L' : (RightSpindle_ShelfTerm -> (RightSpindle_ShelfTerm -> RightSpindle_ShelfTerm))
    <|L' x1 x2 = (<|L x1 x2) 
    |>L' : (RightSpindle_ShelfTerm -> (RightSpindle_ShelfTerm -> RightSpindle_ShelfTerm))
    |>L' x1 x2 = (|>L x1 x2) 
    stageB : (RightSpindle_ShelfTerm -> (Staged RightSpindle_ShelfTerm))
    stageB (<|L x1 x2) = (stage2 <|L' (codeLift2 <|L') (stageB x1) (stageB x2)) 
    stageB (|>L x1 x2) = (stage2 |>L' (codeLift2 |>L') (stageB x1) (stageB x2)) 
    <|Cl' : {A : Set} -> ((ClRightSpindle_ShelfTerm A) -> ((ClRightSpindle_ShelfTerm A) -> (ClRightSpindle_ShelfTerm A)))
    <|Cl' x1 x2 = (<|Cl x1 x2) 
    |>Cl' : {A : Set} -> ((ClRightSpindle_ShelfTerm A) -> ((ClRightSpindle_ShelfTerm A) -> (ClRightSpindle_ShelfTerm A)))
    |>Cl' x1 x2 = (|>Cl x1 x2) 
    stageCl : {A : Set} -> ((ClRightSpindle_ShelfTerm A) -> (Staged (ClRightSpindle_ShelfTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (<|Cl x1 x2) = (stage2 <|Cl' (codeLift2 <|Cl') (stageCl x1) (stageCl x2)) 
    stageCl (|>Cl x1 x2) = (stage2 |>Cl' (codeLift2 |>Cl') (stageCl x1) (stageCl x2)) 
    <|OL' : {n : Nat} -> ((OpRightSpindle_ShelfTerm n) -> ((OpRightSpindle_ShelfTerm n) -> (OpRightSpindle_ShelfTerm n)))
    <|OL' x1 x2 = (<|OL x1 x2) 
    |>OL' : {n : Nat} -> ((OpRightSpindle_ShelfTerm n) -> ((OpRightSpindle_ShelfTerm n) -> (OpRightSpindle_ShelfTerm n)))
    |>OL' x1 x2 = (|>OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRightSpindle_ShelfTerm n) -> (Staged (OpRightSpindle_ShelfTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (<|OL x1 x2) = (stage2 <|OL' (codeLift2 <|OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (|>OL x1 x2) = (stage2 |>OL' (codeLift2 |>OL') (stageOpB x1) (stageOpB x2)) 
    <|OL2' : {n : Nat} {A : Set} -> ((OpRightSpindle_ShelfTerm2 n A) -> ((OpRightSpindle_ShelfTerm2 n A) -> (OpRightSpindle_ShelfTerm2 n A)))
    <|OL2' x1 x2 = (<|OL2 x1 x2) 
    |>OL2' : {n : Nat} {A : Set} -> ((OpRightSpindle_ShelfTerm2 n A) -> ((OpRightSpindle_ShelfTerm2 n A) -> (OpRightSpindle_ShelfTerm2 n A)))
    |>OL2' x1 x2 = (|>OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRightSpindle_ShelfTerm2 n A) -> (Staged (OpRightSpindle_ShelfTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (<|OL2 x1 x2) = (stage2 <|OL2' (codeLift2 <|OL2') (stageOp x1) (stageOp x2)) 
    stageOp (|>OL2 x1 x2) = (stage2 |>OL2' (codeLift2 |>OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        <|T : ((Repr A) -> ((Repr A) -> (Repr A)))
        |>T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RightSpindle_ShelfSig  where
    record RightSpindle_ShelfSig (A : Set) : Set where
      constructor RightSpindle_ShelfSigC
      field
        <| : (A -> (A -> A))
        rightDistributive : {x y z : A} -> (<| (<| y z) x) == (<| (<| y x) (<| z x))
        idempotent_<| : {x : A} -> (<| x x) == x
        |> : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        <|S : (AS -> (AS -> AS))
        |>S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        <|P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        |>P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        rightDistributiveP : {xP yP zP : (Prod A A)} -> (<|P (<|P yP zP) xP) == (<|P (<|P yP xP) (<|P zP xP))
        idempotent_<|P : {xP : (Prod A A)} -> (<|P xP xP) == xP
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RightSpindle_ShelfSig A1)) (Ri2 : (RightSpindle_ShelfSig A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-<| : {x1 x2 : A1} -> (hom ((<| Ri1) x1 x2)) == ((<| Ri2) (hom x1) (hom x2))
        pres-|> : {x1 x2 : A1} -> (hom ((|> Ri1) x1 x2)) == ((|> Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RightSpindle_ShelfSig A1)) (Ri2 : (RightSpindle_ShelfSig A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-<| : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((<| Ri1) x1 x2) ((<| Ri2) y1 y2))))
        interp-|> : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((|> Ri1) x1 x2) ((|> Ri2) y1 y2))))
    data RightSpindle_ShelfSigTerm  : Set where
      <|L : (RightSpindle_ShelfSigTerm -> (RightSpindle_ShelfSigTerm -> RightSpindle_ShelfSigTerm))
      |>L : (RightSpindle_ShelfSigTerm -> (RightSpindle_ShelfSigTerm -> RightSpindle_ShelfSigTerm))
    data ClRightSpindle_ShelfSigTerm (A : Set) : Set where
      sing : (A -> (ClRightSpindle_ShelfSigTerm A))
      <|Cl : ((ClRightSpindle_ShelfSigTerm A) -> ((ClRightSpindle_ShelfSigTerm A) -> (ClRightSpindle_ShelfSigTerm A)))
      |>Cl : ((ClRightSpindle_ShelfSigTerm A) -> ((ClRightSpindle_ShelfSigTerm A) -> (ClRightSpindle_ShelfSigTerm A)))
    data OpRightSpindle_ShelfSigTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRightSpindle_ShelfSigTerm n))
      <|OL : ((OpRightSpindle_ShelfSigTerm n) -> ((OpRightSpindle_ShelfSigTerm n) -> (OpRightSpindle_ShelfSigTerm n)))
      |>OL : ((OpRightSpindle_ShelfSigTerm n) -> ((OpRightSpindle_ShelfSigTerm n) -> (OpRightSpindle_ShelfSigTerm n)))
    data OpRightSpindle_ShelfSigTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRightSpindle_ShelfSigTerm2 n A))
      sing2 : (A -> (OpRightSpindle_ShelfSigTerm2 n A))
      <|OL2 : ((OpRightSpindle_ShelfSigTerm2 n A) -> ((OpRightSpindle_ShelfSigTerm2 n A) -> (OpRightSpindle_ShelfSigTerm2 n A)))
      |>OL2 : ((OpRightSpindle_ShelfSigTerm2 n A) -> ((OpRightSpindle_ShelfSigTerm2 n A) -> (OpRightSpindle_ShelfSigTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRightSpindle_ShelfSigTerm A) -> (ClRightSpindle_ShelfSigTerm A))
    simplifyCl (<|Cl x1 x2) = (<|Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (|>Cl x1 x2) = (|>Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRightSpindle_ShelfSigTerm n) -> (OpRightSpindle_ShelfSigTerm n))
    simplifyOpB (<|OL x1 x2) = (<|OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (|>OL x1 x2) = (|>OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRightSpindle_ShelfSigTerm2 n A) -> (OpRightSpindle_ShelfSigTerm2 n A))
    simplifyOp (<|OL2 x1 x2) = (<|OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (|>OL2 x1 x2) = (|>OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RightSpindle_ShelfSig A) -> (RightSpindle_ShelfSigTerm -> A))
    evalB Ri (<|L x1 x2) = ((<| Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalB Ri (|>L x1 x2) = ((|> Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((RightSpindle_ShelfSig A) -> ((ClRightSpindle_ShelfSigTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (<|Cl x1 x2) = ((<| Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalCl Ri (|>Cl x1 x2) = ((|> Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((RightSpindle_ShelfSig A) -> ((Vec A n) -> ((OpRightSpindle_ShelfSigTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (<|OL x1 x2) = ((<| Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOpB Ri vars (|>OL x1 x2) = ((|> Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((RightSpindle_ShelfSig A) -> ((Vec A n) -> ((OpRightSpindle_ShelfSigTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (<|OL2 x1 x2) = ((<| Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    evalOp Ri vars (|>OL2 x1 x2) = ((|> Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (RightSpindle_ShelfSigTerm -> Set)} -> (((x1 x2 : RightSpindle_ShelfSigTerm) -> ((P x1) -> ((P x2) -> (P (<|L x1 x2))))) -> (((x1 x2 : RightSpindle_ShelfSigTerm) -> ((P x1) -> ((P x2) -> (P (|>L x1 x2))))) -> ((x : RightSpindle_ShelfSigTerm) -> (P x))))
    inductionB {p} p<|l p|>l (<|L x1 x2) = (p<|l _ _ (inductionB {p} p<|l p|>l x1) (inductionB {p} p<|l p|>l x2)) 
    inductionB {p} p<|l p|>l (|>L x1 x2) = (p|>l _ _ (inductionB {p} p<|l p|>l x1) (inductionB {p} p<|l p|>l x2)) 
    inductionCl : {A : Set} {P : ((ClRightSpindle_ShelfSigTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRightSpindle_ShelfSigTerm A)) -> ((P x1) -> ((P x2) -> (P (<|Cl x1 x2))))) -> (((x1 x2 : (ClRightSpindle_ShelfSigTerm A)) -> ((P x1) -> ((P x2) -> (P (|>Cl x1 x2))))) -> ((x : (ClRightSpindle_ShelfSigTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p<|cl p|>cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p<|cl p|>cl (<|Cl x1 x2) = (p<|cl _ _ (inductionCl {_} {p} psing p<|cl p|>cl x1) (inductionCl {_} {p} psing p<|cl p|>cl x2)) 
    inductionCl {_} {p} psing p<|cl p|>cl (|>Cl x1 x2) = (p|>cl _ _ (inductionCl {_} {p} psing p<|cl p|>cl x1) (inductionCl {_} {p} psing p<|cl p|>cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRightSpindle_ShelfSigTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRightSpindle_ShelfSigTerm n)) -> ((P x1) -> ((P x2) -> (P (<|OL x1 x2))))) -> (((x1 x2 : (OpRightSpindle_ShelfSigTerm n)) -> ((P x1) -> ((P x2) -> (P (|>OL x1 x2))))) -> ((x : (OpRightSpindle_ShelfSigTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p<|ol p|>ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p<|ol p|>ol (<|OL x1 x2) = (p<|ol _ _ (inductionOpB {_} {p} pv p<|ol p|>ol x1) (inductionOpB {_} {p} pv p<|ol p|>ol x2)) 
    inductionOpB {_} {p} pv p<|ol p|>ol (|>OL x1 x2) = (p|>ol _ _ (inductionOpB {_} {p} pv p<|ol p|>ol x1) (inductionOpB {_} {p} pv p<|ol p|>ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRightSpindle_ShelfSigTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRightSpindle_ShelfSigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (<|OL2 x1 x2))))) -> (((x1 x2 : (OpRightSpindle_ShelfSigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (|>OL2 x1 x2))))) -> ((x : (OpRightSpindle_ShelfSigTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p<|ol2 p|>ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p<|ol2 p|>ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p<|ol2 p|>ol2 (<|OL2 x1 x2) = (p<|ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p<|ol2 p|>ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p<|ol2 p|>ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p<|ol2 p|>ol2 (|>OL2 x1 x2) = (p|>ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p<|ol2 p|>ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p<|ol2 p|>ol2 x2)) 
    <|L' : (RightSpindle_ShelfSigTerm -> (RightSpindle_ShelfSigTerm -> RightSpindle_ShelfSigTerm))
    <|L' x1 x2 = (<|L x1 x2) 
    |>L' : (RightSpindle_ShelfSigTerm -> (RightSpindle_ShelfSigTerm -> RightSpindle_ShelfSigTerm))
    |>L' x1 x2 = (|>L x1 x2) 
    stageB : (RightSpindle_ShelfSigTerm -> (Staged RightSpindle_ShelfSigTerm))
    stageB (<|L x1 x2) = (stage2 <|L' (codeLift2 <|L') (stageB x1) (stageB x2)) 
    stageB (|>L x1 x2) = (stage2 |>L' (codeLift2 |>L') (stageB x1) (stageB x2)) 
    <|Cl' : {A : Set} -> ((ClRightSpindle_ShelfSigTerm A) -> ((ClRightSpindle_ShelfSigTerm A) -> (ClRightSpindle_ShelfSigTerm A)))
    <|Cl' x1 x2 = (<|Cl x1 x2) 
    |>Cl' : {A : Set} -> ((ClRightSpindle_ShelfSigTerm A) -> ((ClRightSpindle_ShelfSigTerm A) -> (ClRightSpindle_ShelfSigTerm A)))
    |>Cl' x1 x2 = (|>Cl x1 x2) 
    stageCl : {A : Set} -> ((ClRightSpindle_ShelfSigTerm A) -> (Staged (ClRightSpindle_ShelfSigTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (<|Cl x1 x2) = (stage2 <|Cl' (codeLift2 <|Cl') (stageCl x1) (stageCl x2)) 
    stageCl (|>Cl x1 x2) = (stage2 |>Cl' (codeLift2 |>Cl') (stageCl x1) (stageCl x2)) 
    <|OL' : {n : Nat} -> ((OpRightSpindle_ShelfSigTerm n) -> ((OpRightSpindle_ShelfSigTerm n) -> (OpRightSpindle_ShelfSigTerm n)))
    <|OL' x1 x2 = (<|OL x1 x2) 
    |>OL' : {n : Nat} -> ((OpRightSpindle_ShelfSigTerm n) -> ((OpRightSpindle_ShelfSigTerm n) -> (OpRightSpindle_ShelfSigTerm n)))
    |>OL' x1 x2 = (|>OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRightSpindle_ShelfSigTerm n) -> (Staged (OpRightSpindle_ShelfSigTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (<|OL x1 x2) = (stage2 <|OL' (codeLift2 <|OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (|>OL x1 x2) = (stage2 |>OL' (codeLift2 |>OL') (stageOpB x1) (stageOpB x2)) 
    <|OL2' : {n : Nat} {A : Set} -> ((OpRightSpindle_ShelfSigTerm2 n A) -> ((OpRightSpindle_ShelfSigTerm2 n A) -> (OpRightSpindle_ShelfSigTerm2 n A)))
    <|OL2' x1 x2 = (<|OL2 x1 x2) 
    |>OL2' : {n : Nat} {A : Set} -> ((OpRightSpindle_ShelfSigTerm2 n A) -> ((OpRightSpindle_ShelfSigTerm2 n A) -> (OpRightSpindle_ShelfSigTerm2 n A)))
    |>OL2' x1 x2 = (|>OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRightSpindle_ShelfSigTerm2 n A) -> (Staged (OpRightSpindle_ShelfSigTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (<|OL2 x1 x2) = (stage2 <|OL2' (codeLift2 <|OL2') (stageOp x1) (stageOp x2)) 
    stageOp (|>OL2 x1 x2) = (stage2 |>OL2' (codeLift2 |>OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        <|T : ((Repr A) -> ((Repr A) -> (Repr A)))
        |>T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RightUnital  where
    record RightUnital (A : Set) : Set where
      constructor RightUnitalC
      field
        e : A
        op : (A -> (A -> A))
        runit_e : {x : A} -> (op x e) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        eS : AS
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        eP : (Prod A A)
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        runit_eP : {xP : (Prod A A)} -> (opP xP eP) == xP
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RightUnital A1)) (Ri2 : (RightUnital A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-e : (hom (e Ri1)) == (e Ri2)
        pres-op : {x1 x2 : A1} -> (hom ((op Ri1) x1 x2)) == ((op Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RightUnital A1)) (Ri2 : (RightUnital A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-e : (interp (e Ri1) (e Ri2))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Ri1) x1 x2) ((op Ri2) y1 y2))))
    data RightUnitalTerm  : Set where
      eL : RightUnitalTerm
      opL : (RightUnitalTerm -> (RightUnitalTerm -> RightUnitalTerm))
    data ClRightUnitalTerm (A : Set) : Set where
      sing : (A -> (ClRightUnitalTerm A))
      eCl : (ClRightUnitalTerm A)
      opCl : ((ClRightUnitalTerm A) -> ((ClRightUnitalTerm A) -> (ClRightUnitalTerm A)))
    data OpRightUnitalTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRightUnitalTerm n))
      eOL : (OpRightUnitalTerm n)
      opOL : ((OpRightUnitalTerm n) -> ((OpRightUnitalTerm n) -> (OpRightUnitalTerm n)))
    data OpRightUnitalTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRightUnitalTerm2 n A))
      sing2 : (A -> (OpRightUnitalTerm2 n A))
      eOL2 : (OpRightUnitalTerm2 n A)
      opOL2 : ((OpRightUnitalTerm2 n A) -> ((OpRightUnitalTerm2 n A) -> (OpRightUnitalTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRightUnitalTerm A) -> (ClRightUnitalTerm A))
    simplifyCl (opCl x eCl) = x 
    simplifyCl eCl = eCl 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRightUnitalTerm n) -> (OpRightUnitalTerm n))
    simplifyOpB (opOL x eOL) = x 
    simplifyOpB eOL = eOL 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRightUnitalTerm2 n A) -> (OpRightUnitalTerm2 n A))
    simplifyOp (opOL2 x eOL2) = x 
    simplifyOp eOL2 = eOL2 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RightUnital A) -> (RightUnitalTerm -> A))
    evalB Ri eL = (e Ri) 
    evalB Ri (opL x1 x2) = ((op Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((RightUnital A) -> ((ClRightUnitalTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri eCl = (e Ri) 
    evalCl Ri (opCl x1 x2) = ((op Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((RightUnital A) -> ((Vec A n) -> ((OpRightUnitalTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars eOL = (e Ri) 
    evalOpB Ri vars (opOL x1 x2) = ((op Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((RightUnital A) -> ((Vec A n) -> ((OpRightUnitalTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars eOL2 = (e Ri) 
    evalOp Ri vars (opOL2 x1 x2) = ((op Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (RightUnitalTerm -> Set)} -> ((P eL) -> (((x1 x2 : RightUnitalTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : RightUnitalTerm) -> (P x))))
    inductionB {p} pel popl eL = pel 
    inductionB {p} pel popl (opL x1 x2) = (popl _ _ (inductionB {p} pel popl x1) (inductionB {p} pel popl x2)) 
    inductionCl : {A : Set} {P : ((ClRightUnitalTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P eCl) -> (((x1 x2 : (ClRightUnitalTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClRightUnitalTerm A)) -> (P x)))))
    inductionCl {_} {p} psing pecl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pecl popcl eCl = pecl 
    inductionCl {_} {p} psing pecl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing pecl popcl x1) (inductionCl {_} {p} psing pecl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRightUnitalTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P eOL) -> (((x1 x2 : (OpRightUnitalTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpRightUnitalTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv peol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv peol popol eOL = peol 
    inductionOpB {_} {p} pv peol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv peol popol x1) (inductionOpB {_} {p} pv peol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRightUnitalTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P eOL2) -> (((x1 x2 : (OpRightUnitalTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpRightUnitalTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 eOL2 = peol2 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 x2)) 
    eL' : RightUnitalTerm
    eL'  = eL 
    opL' : (RightUnitalTerm -> (RightUnitalTerm -> RightUnitalTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (RightUnitalTerm -> (Staged RightUnitalTerm))
    stageB eL = (Now eL) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    eCl' : {A : Set} -> (ClRightUnitalTerm A)
    eCl'  = eCl 
    opCl' : {A : Set} -> ((ClRightUnitalTerm A) -> ((ClRightUnitalTerm A) -> (ClRightUnitalTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClRightUnitalTerm A) -> (Staged (ClRightUnitalTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl eCl = (Now eCl) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    eOL' : {n : Nat} -> (OpRightUnitalTerm n)
    eOL'  = eOL 
    opOL' : {n : Nat} -> ((OpRightUnitalTerm n) -> ((OpRightUnitalTerm n) -> (OpRightUnitalTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRightUnitalTerm n) -> (Staged (OpRightUnitalTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB eOL = (Now eOL) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    eOL2' : {n : Nat} {A : Set} -> (OpRightUnitalTerm2 n A)
    eOL2'  = eOL2 
    opOL2' : {n : Nat} {A : Set} -> ((OpRightUnitalTerm2 n A) -> ((OpRightUnitalTerm2 n A) -> (OpRightUnitalTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRightUnitalTerm2 n A) -> (Staged (OpRightUnitalTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp eOL2 = (Now eOL2) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        eT : (Repr A)
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RightZero  where
    record RightZero (A : Set) : Set where
      constructor RightZeroC
      field
        e : A
        op : (A -> (A -> A))
        rightZero_op_e : {x : A} -> (op x e) == e
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        eS : AS
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        eP : (Prod A A)
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        rightZero_op_eP : {xP : (Prod A A)} -> (opP xP eP) == eP
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RightZero A1)) (Ri2 : (RightZero A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-e : (hom (e Ri1)) == (e Ri2)
        pres-op : {x1 x2 : A1} -> (hom ((op Ri1) x1 x2)) == ((op Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RightZero A1)) (Ri2 : (RightZero A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-e : (interp (e Ri1) (e Ri2))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Ri1) x1 x2) ((op Ri2) y1 y2))))
    data RightZeroTerm  : Set where
      eL : RightZeroTerm
      opL : (RightZeroTerm -> (RightZeroTerm -> RightZeroTerm))
    data ClRightZeroTerm (A : Set) : Set where
      sing : (A -> (ClRightZeroTerm A))
      eCl : (ClRightZeroTerm A)
      opCl : ((ClRightZeroTerm A) -> ((ClRightZeroTerm A) -> (ClRightZeroTerm A)))
    data OpRightZeroTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRightZeroTerm n))
      eOL : (OpRightZeroTerm n)
      opOL : ((OpRightZeroTerm n) -> ((OpRightZeroTerm n) -> (OpRightZeroTerm n)))
    data OpRightZeroTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRightZeroTerm2 n A))
      sing2 : (A -> (OpRightZeroTerm2 n A))
      eOL2 : (OpRightZeroTerm2 n A)
      opOL2 : ((OpRightZeroTerm2 n A) -> ((OpRightZeroTerm2 n A) -> (OpRightZeroTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRightZeroTerm A) -> (ClRightZeroTerm A))
    simplifyCl eCl = eCl 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRightZeroTerm n) -> (OpRightZeroTerm n))
    simplifyOpB eOL = eOL 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRightZeroTerm2 n A) -> (OpRightZeroTerm2 n A))
    simplifyOp eOL2 = eOL2 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RightZero A) -> (RightZeroTerm -> A))
    evalB Ri eL = (e Ri) 
    evalB Ri (opL x1 x2) = ((op Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((RightZero A) -> ((ClRightZeroTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri eCl = (e Ri) 
    evalCl Ri (opCl x1 x2) = ((op Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((RightZero A) -> ((Vec A n) -> ((OpRightZeroTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars eOL = (e Ri) 
    evalOpB Ri vars (opOL x1 x2) = ((op Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((RightZero A) -> ((Vec A n) -> ((OpRightZeroTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars eOL2 = (e Ri) 
    evalOp Ri vars (opOL2 x1 x2) = ((op Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (RightZeroTerm -> Set)} -> ((P eL) -> (((x1 x2 : RightZeroTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : RightZeroTerm) -> (P x))))
    inductionB {p} pel popl eL = pel 
    inductionB {p} pel popl (opL x1 x2) = (popl _ _ (inductionB {p} pel popl x1) (inductionB {p} pel popl x2)) 
    inductionCl : {A : Set} {P : ((ClRightZeroTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P eCl) -> (((x1 x2 : (ClRightZeroTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClRightZeroTerm A)) -> (P x)))))
    inductionCl {_} {p} psing pecl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pecl popcl eCl = pecl 
    inductionCl {_} {p} psing pecl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing pecl popcl x1) (inductionCl {_} {p} psing pecl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRightZeroTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P eOL) -> (((x1 x2 : (OpRightZeroTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpRightZeroTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv peol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv peol popol eOL = peol 
    inductionOpB {_} {p} pv peol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv peol popol x1) (inductionOpB {_} {p} pv peol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRightZeroTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P eOL2) -> (((x1 x2 : (OpRightZeroTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpRightZeroTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 eOL2 = peol2 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 x2)) 
    eL' : RightZeroTerm
    eL'  = eL 
    opL' : (RightZeroTerm -> (RightZeroTerm -> RightZeroTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (RightZeroTerm -> (Staged RightZeroTerm))
    stageB eL = (Now eL) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    eCl' : {A : Set} -> (ClRightZeroTerm A)
    eCl'  = eCl 
    opCl' : {A : Set} -> ((ClRightZeroTerm A) -> ((ClRightZeroTerm A) -> (ClRightZeroTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClRightZeroTerm A) -> (Staged (ClRightZeroTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl eCl = (Now eCl) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    eOL' : {n : Nat} -> (OpRightZeroTerm n)
    eOL'  = eOL 
    opOL' : {n : Nat} -> ((OpRightZeroTerm n) -> ((OpRightZeroTerm n) -> (OpRightZeroTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRightZeroTerm n) -> (Staged (OpRightZeroTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB eOL = (Now eOL) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    eOL2' : {n : Nat} {A : Set} -> (OpRightZeroTerm2 n A)
    eOL2'  = eOL2 
    opOL2' : {n : Nat} {A : Set} -> ((OpRightZeroTerm2 n A) -> ((OpRightZeroTerm2 n A) -> (OpRightZeroTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRightZeroTerm2 n A) -> (Staged (OpRightZeroTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp eOL2 = (Now eOL2) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        eT : (Repr A)
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module Ring  where
    record Ring (A : Set) : Set where
      constructor RingC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        0 : A
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        leftDistributive_*_+ : {x y z : A} -> (* x (+ y z)) == (+ (* x y) (* x z))
        rightDistributive_*_+ : {x y z : A} -> (* (+ y z) x) == (+ (* y x) (* z x))
        neg : (A -> A)
        leftInverse_inv_op_0 : {x : A} -> (+ x (neg x)) == 0
        rightInverse_inv_op_0 : {x : A} -> (+ (neg x) x) == 0
        1 : A
        lunit_1 : {x : A} -> (* 1 x) == x
        runit_1 : {x : A} -> (* x 1) == x
        leftZero_op_0 : {x : A} -> (* 0 x) == 0
        rightZero_op_0 : {x : A} -> (* x 0) == 0
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
        0S : AS
        negS : (AS -> AS)
        1S : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        0P : (Prod A A)
        negP : ((Prod A A) -> (Prod A A))
        1P : (Prod A A)
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        leftDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P xP (+P yP zP)) == (+P (*P xP yP) (*P xP zP))
        rightDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P (+P yP zP) xP) == (+P (*P yP xP) (*P zP xP))
        leftInverse_inv_op_0P : {xP : (Prod A A)} -> (+P xP (negP xP)) == 0P
        rightInverse_inv_op_0P : {xP : (Prod A A)} -> (+P (negP xP) xP) == 0P
        lunit_1P : {xP : (Prod A A)} -> (*P 1P xP) == xP
        runit_1P : {xP : (Prod A A)} -> (*P xP 1P) == xP
        leftZero_op_0P : {xP : (Prod A A)} -> (*P 0P xP) == 0P
        rightZero_op_0P : {xP : (Prod A A)} -> (*P xP 0P) == 0P
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (Ring A1)) (Ri2 : (Ring A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Ri1) x1 x2)) == ((* Ri2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ri1) x1 x2)) == ((+ Ri2) (hom x1) (hom x2))
        pres-0 : (hom (0 Ri1)) == (0 Ri2)
        pres-neg : {x1 : A1} -> (hom ((neg Ri1) x1)) == ((neg Ri2) (hom x1))
        pres-1 : (hom (1 Ri1)) == (1 Ri2)
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (Ring A1)) (Ri2 : (Ring A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Ri1) x1 x2) ((* Ri2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ri1) x1 x2) ((+ Ri2) y1 y2))))
        interp-0 : (interp (0 Ri1) (0 Ri2))
        interp-neg : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((neg Ri1) x1) ((neg Ri2) y1)))
        interp-1 : (interp (1 Ri1) (1 Ri2))
    data RingTerm  : Set where
      *L : (RingTerm -> (RingTerm -> RingTerm))
      +L : (RingTerm -> (RingTerm -> RingTerm))
      0L : RingTerm
      negL : (RingTerm -> RingTerm)
      1L : RingTerm
    data ClRingTerm (A : Set) : Set where
      sing : (A -> (ClRingTerm A))
      *Cl : ((ClRingTerm A) -> ((ClRingTerm A) -> (ClRingTerm A)))
      +Cl : ((ClRingTerm A) -> ((ClRingTerm A) -> (ClRingTerm A)))
      0Cl : (ClRingTerm A)
      negCl : ((ClRingTerm A) -> (ClRingTerm A))
      1Cl : (ClRingTerm A)
    data OpRingTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRingTerm n))
      *OL : ((OpRingTerm n) -> ((OpRingTerm n) -> (OpRingTerm n)))
      +OL : ((OpRingTerm n) -> ((OpRingTerm n) -> (OpRingTerm n)))
      0OL : (OpRingTerm n)
      negOL : ((OpRingTerm n) -> (OpRingTerm n))
      1OL : (OpRingTerm n)
    data OpRingTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRingTerm2 n A))
      sing2 : (A -> (OpRingTerm2 n A))
      *OL2 : ((OpRingTerm2 n A) -> ((OpRingTerm2 n A) -> (OpRingTerm2 n A)))
      +OL2 : ((OpRingTerm2 n A) -> ((OpRingTerm2 n A) -> (OpRingTerm2 n A)))
      0OL2 : (OpRingTerm2 n A)
      negOL2 : ((OpRingTerm2 n A) -> (OpRingTerm2 n A))
      1OL2 : (OpRingTerm2 n A)
    simplifyCl : {A : Set} -> ((ClRingTerm A) -> (ClRingTerm A))
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl (*Cl 1Cl x) = x 
    simplifyCl (*Cl x 1Cl) = x 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 0Cl = 0Cl 
    simplifyCl (negCl x1) = (negCl (simplifyCl x1)) 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRingTerm n) -> (OpRingTerm n))
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB (*OL 1OL x) = x 
    simplifyOpB (*OL x 1OL) = x 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 0OL = 0OL 
    simplifyOpB (negOL x1) = (negOL (simplifyOpB x1)) 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRingTerm2 n A) -> (OpRingTerm2 n A))
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp (*OL2 1OL2 x) = x 
    simplifyOp (*OL2 x 1OL2) = x 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (negOL2 x1) = (negOL2 (simplifyOp x1)) 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Ring A) -> (RingTerm -> A))
    evalB Ri (*L x1 x2) = ((* Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalB Ri (+L x1 x2) = ((+ Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalB Ri 0L = (0 Ri) 
    evalB Ri (negL x1) = ((neg Ri) (evalB Ri x1)) 
    evalB Ri 1L = (1 Ri) 
    evalCl : {A : Set} -> ((Ring A) -> ((ClRingTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (*Cl x1 x2) = ((* Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalCl Ri (+Cl x1 x2) = ((+ Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalCl Ri 0Cl = (0 Ri) 
    evalCl Ri (negCl x1) = ((neg Ri) (evalCl Ri x1)) 
    evalCl Ri 1Cl = (1 Ri) 
    evalOpB : {A : Set} {n : Nat} -> ((Ring A) -> ((Vec A n) -> ((OpRingTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (*OL x1 x2) = ((* Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOpB Ri vars (+OL x1 x2) = ((+ Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOpB Ri vars 0OL = (0 Ri) 
    evalOpB Ri vars (negOL x1) = ((neg Ri) (evalOpB Ri vars x1)) 
    evalOpB Ri vars 1OL = (1 Ri) 
    evalOp : {A : Set} {n : Nat} -> ((Ring A) -> ((Vec A n) -> ((OpRingTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (*OL2 x1 x2) = ((* Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    evalOp Ri vars (+OL2 x1 x2) = ((+ Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    evalOp Ri vars 0OL2 = (0 Ri) 
    evalOp Ri vars (negOL2 x1) = ((neg Ri) (evalOp Ri vars x1)) 
    evalOp Ri vars 1OL2 = (1 Ri) 
    inductionB : {P : (RingTerm -> Set)} -> (((x1 x2 : RingTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : RingTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((P 0L) -> (((x1 : RingTerm) -> ((P x1) -> (P (negL x1)))) -> ((P 1L) -> ((x : RingTerm) -> (P x)))))))
    inductionB {p} p*l p+l p0l pnegl p1l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l p0l pnegl p1l x1) (inductionB {p} p*l p+l p0l pnegl p1l x2)) 
    inductionB {p} p*l p+l p0l pnegl p1l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l p0l pnegl p1l x1) (inductionB {p} p*l p+l p0l pnegl p1l x2)) 
    inductionB {p} p*l p+l p0l pnegl p1l 0L = p0l 
    inductionB {p} p*l p+l p0l pnegl p1l (negL x1) = (pnegl _ (inductionB {p} p*l p+l p0l pnegl p1l x1)) 
    inductionB {p} p*l p+l p0l pnegl p1l 1L = p1l 
    inductionCl : {A : Set} {P : ((ClRingTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRingTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClRingTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((P 0Cl) -> (((x1 : (ClRingTerm A)) -> ((P x1) -> (P (negCl x1)))) -> ((P 1Cl) -> ((x : (ClRingTerm A)) -> (P x))))))))
    inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl p1cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl p1cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl p1cl x1) (inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl p1cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl p1cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl p1cl x1) (inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl p1cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl p1cl 0Cl = p0cl 
    inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl p1cl (negCl x1) = (pnegcl _ (inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl p1cl x1)) 
    inductionCl {_} {p} psing p*cl p+cl p0cl pnegcl p1cl 1Cl = p1cl 
    inductionOpB : {n : Nat} {P : ((OpRingTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRingTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpRingTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((P 0OL) -> (((x1 : (OpRingTerm n)) -> ((P x1) -> (P (negOL x1)))) -> ((P 1OL) -> ((x : (OpRingTerm n)) -> (P x))))))))
    inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol p1ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol p1ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol p1ol x1) (inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol p1ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol p1ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol p1ol x1) (inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol p1ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol p1ol 0OL = p0ol 
    inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol p1ol (negOL x1) = (pnegol _ (inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol p1ol x1)) 
    inductionOpB {_} {p} pv p*ol p+ol p0ol pnegol p1ol 1OL = p1ol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRingTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRingTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpRingTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((P 0OL2) -> (((x1 : (OpRingTerm2 n A)) -> ((P x1) -> (P (negOL2 x1)))) -> ((P 1OL2) -> ((x : (OpRingTerm2 n A)) -> (P x)))))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 (negOL2 x1) = (pnegol2 _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 1OL2 = p1ol2 
    *L' : (RingTerm -> (RingTerm -> RingTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (RingTerm -> (RingTerm -> RingTerm))
    +L' x1 x2 = (+L x1 x2) 
    0L' : RingTerm
    0L'  = 0L 
    negL' : (RingTerm -> RingTerm)
    negL' x1 = (negL x1) 
    1L' : RingTerm
    1L'  = 1L 
    stageB : (RingTerm -> (Staged RingTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB 0L = (Now 0L) 
    stageB (negL x1) = (stage1 negL' (codeLift1 negL') (stageB x1)) 
    stageB 1L = (Now 1L) 
    *Cl' : {A : Set} -> ((ClRingTerm A) -> ((ClRingTerm A) -> (ClRingTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClRingTerm A) -> ((ClRingTerm A) -> (ClRingTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    0Cl' : {A : Set} -> (ClRingTerm A)
    0Cl'  = 0Cl 
    negCl' : {A : Set} -> ((ClRingTerm A) -> (ClRingTerm A))
    negCl' x1 = (negCl x1) 
    1Cl' : {A : Set} -> (ClRingTerm A)
    1Cl'  = 1Cl 
    stageCl : {A : Set} -> ((ClRingTerm A) -> (Staged (ClRingTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (negCl x1) = (stage1 negCl' (codeLift1 negCl') (stageCl x1)) 
    stageCl 1Cl = (Now 1Cl) 
    *OL' : {n : Nat} -> ((OpRingTerm n) -> ((OpRingTerm n) -> (OpRingTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpRingTerm n) -> ((OpRingTerm n) -> (OpRingTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    0OL' : {n : Nat} -> (OpRingTerm n)
    0OL'  = 0OL 
    negOL' : {n : Nat} -> ((OpRingTerm n) -> (OpRingTerm n))
    negOL' x1 = (negOL x1) 
    1OL' : {n : Nat} -> (OpRingTerm n)
    1OL'  = 1OL 
    stageOpB : {n : Nat} -> ((OpRingTerm n) -> (Staged (OpRingTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (negOL x1) = (stage1 negOL' (codeLift1 negOL') (stageOpB x1)) 
    stageOpB 1OL = (Now 1OL) 
    *OL2' : {n : Nat} {A : Set} -> ((OpRingTerm2 n A) -> ((OpRingTerm2 n A) -> (OpRingTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpRingTerm2 n A) -> ((OpRingTerm2 n A) -> (OpRingTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    0OL2' : {n : Nat} {A : Set} -> (OpRingTerm2 n A)
    0OL2'  = 0OL2 
    negOL2' : {n : Nat} {A : Set} -> ((OpRingTerm2 n A) -> (OpRingTerm2 n A))
    negOL2' x1 = (negOL2 x1) 
    1OL2' : {n : Nat} {A : Set} -> (OpRingTerm2 n A)
    1OL2'  = 1OL2 
    stageOp : {n : Nat} {A : Set} -> ((OpRingTerm2 n A) -> (Staged (OpRingTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (negOL2 x1) = (stage1 negOL2' (codeLift1 negOL2') (stageOp x1)) 
    stageOp 1OL2 = (Now 1OL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        0T : (Repr A)
        negT : ((Repr A) -> (Repr A))
        1T : (Repr A)
  module Ringoid  where
    record Ringoid (A : Set) : Set where
      constructor RingoidC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        leftDistributive_*_+ : {x y z : A} -> (* x (+ y z)) == (+ (* x y) (* x z))
        rightDistributive_*_+ : {x y z : A} -> (* (+ y z) x) == (+ (* y x) (* z x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P xP (+P yP zP)) == (+P (*P xP yP) (*P xP zP))
        rightDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P (+P yP zP) xP) == (+P (*P yP xP) (*P zP xP))
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (Ringoid A1)) (Ri2 : (Ringoid A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Ri1) x1 x2)) == ((* Ri2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ri1) x1 x2)) == ((+ Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (Ringoid A1)) (Ri2 : (Ringoid A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Ri1) x1 x2) ((* Ri2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ri1) x1 x2) ((+ Ri2) y1 y2))))
    data RingoidTerm  : Set where
      *L : (RingoidTerm -> (RingoidTerm -> RingoidTerm))
      +L : (RingoidTerm -> (RingoidTerm -> RingoidTerm))
    data ClRingoidTerm (A : Set) : Set where
      sing : (A -> (ClRingoidTerm A))
      *Cl : ((ClRingoidTerm A) -> ((ClRingoidTerm A) -> (ClRingoidTerm A)))
      +Cl : ((ClRingoidTerm A) -> ((ClRingoidTerm A) -> (ClRingoidTerm A)))
    data OpRingoidTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRingoidTerm n))
      *OL : ((OpRingoidTerm n) -> ((OpRingoidTerm n) -> (OpRingoidTerm n)))
      +OL : ((OpRingoidTerm n) -> ((OpRingoidTerm n) -> (OpRingoidTerm n)))
    data OpRingoidTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRingoidTerm2 n A))
      sing2 : (A -> (OpRingoidTerm2 n A))
      *OL2 : ((OpRingoidTerm2 n A) -> ((OpRingoidTerm2 n A) -> (OpRingoidTerm2 n A)))
      +OL2 : ((OpRingoidTerm2 n A) -> ((OpRingoidTerm2 n A) -> (OpRingoidTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRingoidTerm A) -> (ClRingoidTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRingoidTerm n) -> (OpRingoidTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRingoidTerm2 n A) -> (OpRingoidTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Ringoid A) -> (RingoidTerm -> A))
    evalB Ri (*L x1 x2) = ((* Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalB Ri (+L x1 x2) = ((+ Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((Ringoid A) -> ((ClRingoidTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (*Cl x1 x2) = ((* Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalCl Ri (+Cl x1 x2) = ((+ Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Ringoid A) -> ((Vec A n) -> ((OpRingoidTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (*OL x1 x2) = ((* Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOpB Ri vars (+OL x1 x2) = ((+ Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Ringoid A) -> ((Vec A n) -> ((OpRingoidTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (*OL2 x1 x2) = ((* Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    evalOp Ri vars (+OL2 x1 x2) = ((+ Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (RingoidTerm -> Set)} -> (((x1 x2 : RingoidTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : RingoidTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : RingoidTerm) -> (P x))))
    inductionB {p} p*l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionB {p} p*l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClRingoidTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRingoidTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClRingoidTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClRingoidTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p*cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRingoidTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRingoidTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpRingoidTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpRingoidTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p*ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRingoidTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRingoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpRingoidTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpRingoidTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    *L' : (RingoidTerm -> (RingoidTerm -> RingoidTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (RingoidTerm -> (RingoidTerm -> RingoidTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (RingoidTerm -> (Staged RingoidTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClRingoidTerm A) -> ((ClRingoidTerm A) -> (ClRingoidTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClRingoidTerm A) -> ((ClRingoidTerm A) -> (ClRingoidTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClRingoidTerm A) -> (Staged (ClRingoidTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpRingoidTerm n) -> ((OpRingoidTerm n) -> (OpRingoidTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpRingoidTerm n) -> ((OpRingoidTerm n) -> (OpRingoidTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRingoidTerm n) -> (Staged (OpRingoidTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpRingoidTerm2 n A) -> ((OpRingoidTerm2 n A) -> (OpRingoidTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpRingoidTerm2 n A) -> ((OpRingoidTerm2 n A) -> (OpRingoidTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRingoidTerm2 n A) -> (Staged (OpRingoidTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module Ringoid01Sig  where
    record Ringoid01Sig (A : Set) : Set where
      constructor Ringoid01SigC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        0 : A
        1 : A
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
        0S : AS
        1S : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        0P : (Prod A A)
        1P : (Prod A A)
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (Ringoid01Sig A1)) (Ri2 : (Ringoid01Sig A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Ri1) x1 x2)) == ((* Ri2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ri1) x1 x2)) == ((+ Ri2) (hom x1) (hom x2))
        pres-0 : (hom (0 Ri1)) == (0 Ri2)
        pres-1 : (hom (1 Ri1)) == (1 Ri2)
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (Ringoid01Sig A1)) (Ri2 : (Ringoid01Sig A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Ri1) x1 x2) ((* Ri2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ri1) x1 x2) ((+ Ri2) y1 y2))))
        interp-0 : (interp (0 Ri1) (0 Ri2))
        interp-1 : (interp (1 Ri1) (1 Ri2))
    data Ringoid01SigTerm  : Set where
      *L : (Ringoid01SigTerm -> (Ringoid01SigTerm -> Ringoid01SigTerm))
      +L : (Ringoid01SigTerm -> (Ringoid01SigTerm -> Ringoid01SigTerm))
      0L : Ringoid01SigTerm
      1L : Ringoid01SigTerm
    data ClRingoid01SigTerm (A : Set) : Set where
      sing : (A -> (ClRingoid01SigTerm A))
      *Cl : ((ClRingoid01SigTerm A) -> ((ClRingoid01SigTerm A) -> (ClRingoid01SigTerm A)))
      +Cl : ((ClRingoid01SigTerm A) -> ((ClRingoid01SigTerm A) -> (ClRingoid01SigTerm A)))
      0Cl : (ClRingoid01SigTerm A)
      1Cl : (ClRingoid01SigTerm A)
    data OpRingoid01SigTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRingoid01SigTerm n))
      *OL : ((OpRingoid01SigTerm n) -> ((OpRingoid01SigTerm n) -> (OpRingoid01SigTerm n)))
      +OL : ((OpRingoid01SigTerm n) -> ((OpRingoid01SigTerm n) -> (OpRingoid01SigTerm n)))
      0OL : (OpRingoid01SigTerm n)
      1OL : (OpRingoid01SigTerm n)
    data OpRingoid01SigTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRingoid01SigTerm2 n A))
      sing2 : (A -> (OpRingoid01SigTerm2 n A))
      *OL2 : ((OpRingoid01SigTerm2 n A) -> ((OpRingoid01SigTerm2 n A) -> (OpRingoid01SigTerm2 n A)))
      +OL2 : ((OpRingoid01SigTerm2 n A) -> ((OpRingoid01SigTerm2 n A) -> (OpRingoid01SigTerm2 n A)))
      0OL2 : (OpRingoid01SigTerm2 n A)
      1OL2 : (OpRingoid01SigTerm2 n A)
    simplifyCl : {A : Set} -> ((ClRingoid01SigTerm A) -> (ClRingoid01SigTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 0Cl = 0Cl 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRingoid01SigTerm n) -> (OpRingoid01SigTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 0OL = 0OL 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRingoid01SigTerm2 n A) -> (OpRingoid01SigTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Ringoid01Sig A) -> (Ringoid01SigTerm -> A))
    evalB Ri (*L x1 x2) = ((* Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalB Ri (+L x1 x2) = ((+ Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalB Ri 0L = (0 Ri) 
    evalB Ri 1L = (1 Ri) 
    evalCl : {A : Set} -> ((Ringoid01Sig A) -> ((ClRingoid01SigTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (*Cl x1 x2) = ((* Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalCl Ri (+Cl x1 x2) = ((+ Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalCl Ri 0Cl = (0 Ri) 
    evalCl Ri 1Cl = (1 Ri) 
    evalOpB : {A : Set} {n : Nat} -> ((Ringoid01Sig A) -> ((Vec A n) -> ((OpRingoid01SigTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (*OL x1 x2) = ((* Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOpB Ri vars (+OL x1 x2) = ((+ Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOpB Ri vars 0OL = (0 Ri) 
    evalOpB Ri vars 1OL = (1 Ri) 
    evalOp : {A : Set} {n : Nat} -> ((Ringoid01Sig A) -> ((Vec A n) -> ((OpRingoid01SigTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (*OL2 x1 x2) = ((* Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    evalOp Ri vars (+OL2 x1 x2) = ((+ Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    evalOp Ri vars 0OL2 = (0 Ri) 
    evalOp Ri vars 1OL2 = (1 Ri) 
    inductionB : {P : (Ringoid01SigTerm -> Set)} -> (((x1 x2 : Ringoid01SigTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : Ringoid01SigTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((P 0L) -> ((P 1L) -> ((x : Ringoid01SigTerm) -> (P x))))))
    inductionB {p} p*l p+l p0l p1l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l p0l p1l x1) (inductionB {p} p*l p+l p0l p1l x2)) 
    inductionB {p} p*l p+l p0l p1l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l p0l p1l x1) (inductionB {p} p*l p+l p0l p1l x2)) 
    inductionB {p} p*l p+l p0l p1l 0L = p0l 
    inductionB {p} p*l p+l p0l p1l 1L = p1l 
    inductionCl : {A : Set} {P : ((ClRingoid01SigTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRingoid01SigTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClRingoid01SigTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((P 0Cl) -> ((P 1Cl) -> ((x : (ClRingoid01SigTerm A)) -> (P x)))))))
    inductionCl {_} {p} psing p*cl p+cl p0cl p1cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl p0cl p1cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl p0cl p1cl x1) (inductionCl {_} {p} psing p*cl p+cl p0cl p1cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl p0cl p1cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl p0cl p1cl x1) (inductionCl {_} {p} psing p*cl p+cl p0cl p1cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl p0cl p1cl 0Cl = p0cl 
    inductionCl {_} {p} psing p*cl p+cl p0cl p1cl 1Cl = p1cl 
    inductionOpB : {n : Nat} {P : ((OpRingoid01SigTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRingoid01SigTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpRingoid01SigTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((P 0OL) -> ((P 1OL) -> ((x : (OpRingoid01SigTerm n)) -> (P x)))))))
    inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol x1) (inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol x1) (inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol 0OL = p0ol 
    inductionOpB {_} {p} pv p*ol p+ol p0ol p1ol 1OL = p1ol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRingoid01SigTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRingoid01SigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpRingoid01SigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((P 0OL2) -> ((P 1OL2) -> ((x : (OpRingoid01SigTerm2 n A)) -> (P x))))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 1OL2 = p1ol2 
    *L' : (Ringoid01SigTerm -> (Ringoid01SigTerm -> Ringoid01SigTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (Ringoid01SigTerm -> (Ringoid01SigTerm -> Ringoid01SigTerm))
    +L' x1 x2 = (+L x1 x2) 
    0L' : Ringoid01SigTerm
    0L'  = 0L 
    1L' : Ringoid01SigTerm
    1L'  = 1L 
    stageB : (Ringoid01SigTerm -> (Staged Ringoid01SigTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB 0L = (Now 0L) 
    stageB 1L = (Now 1L) 
    *Cl' : {A : Set} -> ((ClRingoid01SigTerm A) -> ((ClRingoid01SigTerm A) -> (ClRingoid01SigTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClRingoid01SigTerm A) -> ((ClRingoid01SigTerm A) -> (ClRingoid01SigTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    0Cl' : {A : Set} -> (ClRingoid01SigTerm A)
    0Cl'  = 0Cl 
    1Cl' : {A : Set} -> (ClRingoid01SigTerm A)
    1Cl'  = 1Cl 
    stageCl : {A : Set} -> ((ClRingoid01SigTerm A) -> (Staged (ClRingoid01SigTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl 1Cl = (Now 1Cl) 
    *OL' : {n : Nat} -> ((OpRingoid01SigTerm n) -> ((OpRingoid01SigTerm n) -> (OpRingoid01SigTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpRingoid01SigTerm n) -> ((OpRingoid01SigTerm n) -> (OpRingoid01SigTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    0OL' : {n : Nat} -> (OpRingoid01SigTerm n)
    0OL'  = 0OL 
    1OL' : {n : Nat} -> (OpRingoid01SigTerm n)
    1OL'  = 1OL 
    stageOpB : {n : Nat} -> ((OpRingoid01SigTerm n) -> (Staged (OpRingoid01SigTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB 1OL = (Now 1OL) 
    *OL2' : {n : Nat} {A : Set} -> ((OpRingoid01SigTerm2 n A) -> ((OpRingoid01SigTerm2 n A) -> (OpRingoid01SigTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpRingoid01SigTerm2 n A) -> ((OpRingoid01SigTerm2 n A) -> (OpRingoid01SigTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    0OL2' : {n : Nat} {A : Set} -> (OpRingoid01SigTerm2 n A)
    0OL2'  = 0OL2 
    1OL2' : {n : Nat} {A : Set} -> (OpRingoid01SigTerm2 n A)
    1OL2'  = 1OL2 
    stageOp : {n : Nat} {A : Set} -> ((OpRingoid01SigTerm2 n A) -> (Staged (OpRingoid01SigTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp 1OL2 = (Now 1OL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        0T : (Repr A)
        1T : (Repr A)
  module Ringoid0Sig  where
    record Ringoid0Sig (A : Set) : Set where
      constructor Ringoid0SigC
      field
        0 : A
        + : (A -> (A -> A))
        * : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        0S : AS
        +S : (AS -> (AS -> AS))
        *S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        0P : (Prod A A)
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (Ringoid0Sig A1)) (Ri2 : (Ringoid0Sig A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-0 : (hom (0 Ri1)) == (0 Ri2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ri1) x1 x2)) == ((+ Ri2) (hom x1) (hom x2))
        pres-* : {x1 x2 : A1} -> (hom ((* Ri1) x1 x2)) == ((* Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (Ringoid0Sig A1)) (Ri2 : (Ringoid0Sig A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-0 : (interp (0 Ri1) (0 Ri2))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ri1) x1 x2) ((+ Ri2) y1 y2))))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Ri1) x1 x2) ((* Ri2) y1 y2))))
    data Ringoid0SigTerm  : Set where
      0L : Ringoid0SigTerm
      +L : (Ringoid0SigTerm -> (Ringoid0SigTerm -> Ringoid0SigTerm))
      *L : (Ringoid0SigTerm -> (Ringoid0SigTerm -> Ringoid0SigTerm))
    data ClRingoid0SigTerm (A : Set) : Set where
      sing : (A -> (ClRingoid0SigTerm A))
      0Cl : (ClRingoid0SigTerm A)
      +Cl : ((ClRingoid0SigTerm A) -> ((ClRingoid0SigTerm A) -> (ClRingoid0SigTerm A)))
      *Cl : ((ClRingoid0SigTerm A) -> ((ClRingoid0SigTerm A) -> (ClRingoid0SigTerm A)))
    data OpRingoid0SigTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRingoid0SigTerm n))
      0OL : (OpRingoid0SigTerm n)
      +OL : ((OpRingoid0SigTerm n) -> ((OpRingoid0SigTerm n) -> (OpRingoid0SigTerm n)))
      *OL : ((OpRingoid0SigTerm n) -> ((OpRingoid0SigTerm n) -> (OpRingoid0SigTerm n)))
    data OpRingoid0SigTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRingoid0SigTerm2 n A))
      sing2 : (A -> (OpRingoid0SigTerm2 n A))
      0OL2 : (OpRingoid0SigTerm2 n A)
      +OL2 : ((OpRingoid0SigTerm2 n A) -> ((OpRingoid0SigTerm2 n A) -> (OpRingoid0SigTerm2 n A)))
      *OL2 : ((OpRingoid0SigTerm2 n A) -> ((OpRingoid0SigTerm2 n A) -> (OpRingoid0SigTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRingoid0SigTerm A) -> (ClRingoid0SigTerm A))
    simplifyCl 0Cl = 0Cl 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRingoid0SigTerm n) -> (OpRingoid0SigTerm n))
    simplifyOpB 0OL = 0OL 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRingoid0SigTerm2 n A) -> (OpRingoid0SigTerm2 n A))
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Ringoid0Sig A) -> (Ringoid0SigTerm -> A))
    evalB Ri 0L = (0 Ri) 
    evalB Ri (+L x1 x2) = ((+ Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalB Ri (*L x1 x2) = ((* Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((Ringoid0Sig A) -> ((ClRingoid0SigTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri 0Cl = (0 Ri) 
    evalCl Ri (+Cl x1 x2) = ((+ Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalCl Ri (*Cl x1 x2) = ((* Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Ringoid0Sig A) -> ((Vec A n) -> ((OpRingoid0SigTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars 0OL = (0 Ri) 
    evalOpB Ri vars (+OL x1 x2) = ((+ Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOpB Ri vars (*OL x1 x2) = ((* Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Ringoid0Sig A) -> ((Vec A n) -> ((OpRingoid0SigTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars 0OL2 = (0 Ri) 
    evalOp Ri vars (+OL2 x1 x2) = ((+ Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    evalOp Ri vars (*OL2 x1 x2) = ((* Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (Ringoid0SigTerm -> Set)} -> ((P 0L) -> (((x1 x2 : Ringoid0SigTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> (((x1 x2 : Ringoid0SigTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((x : Ringoid0SigTerm) -> (P x)))))
    inductionB {p} p0l p+l p*l 0L = p0l 
    inductionB {p} p0l p+l p*l (+L x1 x2) = (p+l _ _ (inductionB {p} p0l p+l p*l x1) (inductionB {p} p0l p+l p*l x2)) 
    inductionB {p} p0l p+l p*l (*L x1 x2) = (p*l _ _ (inductionB {p} p0l p+l p*l x1) (inductionB {p} p0l p+l p*l x2)) 
    inductionCl : {A : Set} {P : ((ClRingoid0SigTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 0Cl) -> (((x1 x2 : (ClRingoid0SigTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> (((x1 x2 : (ClRingoid0SigTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((x : (ClRingoid0SigTerm A)) -> (P x))))))
    inductionCl {_} {p} psing p0cl p+cl p*cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p0cl p+cl p*cl 0Cl = p0cl 
    inductionCl {_} {p} psing p0cl p+cl p*cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p0cl p+cl p*cl x1) (inductionCl {_} {p} psing p0cl p+cl p*cl x2)) 
    inductionCl {_} {p} psing p0cl p+cl p*cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p0cl p+cl p*cl x1) (inductionCl {_} {p} psing p0cl p+cl p*cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRingoid0SigTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 0OL) -> (((x1 x2 : (OpRingoid0SigTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> (((x1 x2 : (OpRingoid0SigTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((x : (OpRingoid0SigTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv p0ol p+ol p*ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p0ol p+ol p*ol 0OL = p0ol 
    inductionOpB {_} {p} pv p0ol p+ol p*ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p0ol p+ol p*ol x1) (inductionOpB {_} {p} pv p0ol p+ol p*ol x2)) 
    inductionOpB {_} {p} pv p0ol p+ol p*ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p0ol p+ol p*ol x1) (inductionOpB {_} {p} pv p0ol p+ol p*ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRingoid0SigTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 0OL2) -> (((x1 x2 : (OpRingoid0SigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> (((x1 x2 : (OpRingoid0SigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((x : (OpRingoid0SigTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 x2)) 
    0L' : Ringoid0SigTerm
    0L'  = 0L 
    +L' : (Ringoid0SigTerm -> (Ringoid0SigTerm -> Ringoid0SigTerm))
    +L' x1 x2 = (+L x1 x2) 
    *L' : (Ringoid0SigTerm -> (Ringoid0SigTerm -> Ringoid0SigTerm))
    *L' x1 x2 = (*L x1 x2) 
    stageB : (Ringoid0SigTerm -> (Staged Ringoid0SigTerm))
    stageB 0L = (Now 0L) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    0Cl' : {A : Set} -> (ClRingoid0SigTerm A)
    0Cl'  = 0Cl 
    +Cl' : {A : Set} -> ((ClRingoid0SigTerm A) -> ((ClRingoid0SigTerm A) -> (ClRingoid0SigTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    *Cl' : {A : Set} -> ((ClRingoid0SigTerm A) -> ((ClRingoid0SigTerm A) -> (ClRingoid0SigTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    stageCl : {A : Set} -> ((ClRingoid0SigTerm A) -> (Staged (ClRingoid0SigTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    0OL' : {n : Nat} -> (OpRingoid0SigTerm n)
    0OL'  = 0OL 
    +OL' : {n : Nat} -> ((OpRingoid0SigTerm n) -> ((OpRingoid0SigTerm n) -> (OpRingoid0SigTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    *OL' : {n : Nat} -> ((OpRingoid0SigTerm n) -> ((OpRingoid0SigTerm n) -> (OpRingoid0SigTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRingoid0SigTerm n) -> (Staged (OpRingoid0SigTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    0OL2' : {n : Nat} {A : Set} -> (OpRingoid0SigTerm2 n A)
    0OL2'  = 0OL2 
    +OL2' : {n : Nat} {A : Set} -> ((OpRingoid0SigTerm2 n A) -> ((OpRingoid0SigTerm2 n A) -> (OpRingoid0SigTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    *OL2' : {n : Nat} {A : Set} -> ((OpRingoid0SigTerm2 n A) -> ((OpRingoid0SigTerm2 n A) -> (OpRingoid0SigTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRingoid0SigTerm2 n A) -> (Staged (OpRingoid0SigTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        0T : (Repr A)
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module Ringoid1  where
    record Ringoid1 (A : Set) : Set where
      constructor Ringoid1C
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        1 : A
        leftDistributive_*_+ : {x y z : A} -> (* x (+ y z)) == (+ (* x y) (* x z))
        rightDistributive_*_+ : {x y z : A} -> (* (+ y z) x) == (+ (* y x) (* z x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
        1S : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        1P : (Prod A A)
        leftDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P xP (+P yP zP)) == (+P (*P xP yP) (*P xP zP))
        rightDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P (+P yP zP) xP) == (+P (*P yP xP) (*P zP xP))
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (Ringoid1 A1)) (Ri2 : (Ringoid1 A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Ri1) x1 x2)) == ((* Ri2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ri1) x1 x2)) == ((+ Ri2) (hom x1) (hom x2))
        pres-1 : (hom (1 Ri1)) == (1 Ri2)
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (Ringoid1 A1)) (Ri2 : (Ringoid1 A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Ri1) x1 x2) ((* Ri2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ri1) x1 x2) ((+ Ri2) y1 y2))))
        interp-1 : (interp (1 Ri1) (1 Ri2))
    data Ringoid1LTerm  : Set where
      *L : (Ringoid1LTerm -> (Ringoid1LTerm -> Ringoid1LTerm))
      +L : (Ringoid1LTerm -> (Ringoid1LTerm -> Ringoid1LTerm))
      1L : Ringoid1LTerm
    data ClRingoid1ClTerm (A : Set) : Set where
      sing : (A -> (ClRingoid1ClTerm A))
      *Cl : ((ClRingoid1ClTerm A) -> ((ClRingoid1ClTerm A) -> (ClRingoid1ClTerm A)))
      +Cl : ((ClRingoid1ClTerm A) -> ((ClRingoid1ClTerm A) -> (ClRingoid1ClTerm A)))
      1Cl : (ClRingoid1ClTerm A)
    data OpRingoid1OLTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRingoid1OLTerm n))
      *OL : ((OpRingoid1OLTerm n) -> ((OpRingoid1OLTerm n) -> (OpRingoid1OLTerm n)))
      +OL : ((OpRingoid1OLTerm n) -> ((OpRingoid1OLTerm n) -> (OpRingoid1OLTerm n)))
      1OL : (OpRingoid1OLTerm n)
    data OpRingoid1OL2Term2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRingoid1OL2Term2 n A))
      sing2 : (A -> (OpRingoid1OL2Term2 n A))
      *OL2 : ((OpRingoid1OL2Term2 n A) -> ((OpRingoid1OL2Term2 n A) -> (OpRingoid1OL2Term2 n A)))
      +OL2 : ((OpRingoid1OL2Term2 n A) -> ((OpRingoid1OL2Term2 n A) -> (OpRingoid1OL2Term2 n A)))
      1OL2 : (OpRingoid1OL2Term2 n A)
    simplifyCl : {A : Set} -> ((ClRingoid1ClTerm A) -> (ClRingoid1ClTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRingoid1OLTerm n) -> (OpRingoid1OLTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRingoid1OL2Term2 n A) -> (OpRingoid1OL2Term2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Ringoid1 A) -> (Ringoid1LTerm -> A))
    evalB Ri (*L x1 x2) = ((* Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalB Ri (+L x1 x2) = ((+ Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalB Ri 1L = (1 Ri) 
    evalCl : {A : Set} -> ((Ringoid1 A) -> ((ClRingoid1ClTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (*Cl x1 x2) = ((* Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalCl Ri (+Cl x1 x2) = ((+ Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalCl Ri 1Cl = (1 Ri) 
    evalOpB : {A : Set} {n : Nat} -> ((Ringoid1 A) -> ((Vec A n) -> ((OpRingoid1OLTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (*OL x1 x2) = ((* Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOpB Ri vars (+OL x1 x2) = ((+ Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOpB Ri vars 1OL = (1 Ri) 
    evalOp : {A : Set} {n : Nat} -> ((Ringoid1 A) -> ((Vec A n) -> ((OpRingoid1OL2Term2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (*OL2 x1 x2) = ((* Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    evalOp Ri vars (+OL2 x1 x2) = ((+ Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    evalOp Ri vars 1OL2 = (1 Ri) 
    inductionB : {P : (Ringoid1LTerm -> Set)} -> (((x1 x2 : Ringoid1LTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : Ringoid1LTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((P 1L) -> ((x : Ringoid1LTerm) -> (P x)))))
    inductionB {p} p*l p+l p1l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l p1l x1) (inductionB {p} p*l p+l p1l x2)) 
    inductionB {p} p*l p+l p1l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l p1l x1) (inductionB {p} p*l p+l p1l x2)) 
    inductionB {p} p*l p+l p1l 1L = p1l 
    inductionCl : {A : Set} {P : ((ClRingoid1ClTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRingoid1ClTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClRingoid1ClTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((P 1Cl) -> ((x : (ClRingoid1ClTerm A)) -> (P x))))))
    inductionCl {_} {p} psing p*cl p+cl p1cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl p1cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl p1cl x1) (inductionCl {_} {p} psing p*cl p+cl p1cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl p1cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl p1cl x1) (inductionCl {_} {p} psing p*cl p+cl p1cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl p1cl 1Cl = p1cl 
    inductionOpB : {n : Nat} {P : ((OpRingoid1OLTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRingoid1OLTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpRingoid1OLTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((P 1OL) -> ((x : (OpRingoid1OLTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv p*ol p+ol p1ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol p1ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol p1ol x1) (inductionOpB {_} {p} pv p*ol p+ol p1ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol p1ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol p1ol x1) (inductionOpB {_} {p} pv p*ol p+ol p1ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol p1ol 1OL = p1ol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRingoid1OL2Term2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRingoid1OL2Term2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpRingoid1OL2Term2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((P 1OL2) -> ((x : (OpRingoid1OL2Term2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p1ol2 1OL2 = p1ol2 
    *L' : (Ringoid1LTerm -> (Ringoid1LTerm -> Ringoid1LTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (Ringoid1LTerm -> (Ringoid1LTerm -> Ringoid1LTerm))
    +L' x1 x2 = (+L x1 x2) 
    1L' : Ringoid1LTerm
    1L'  = 1L 
    stageB : (Ringoid1LTerm -> (Staged Ringoid1LTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB 1L = (Now 1L) 
    *Cl' : {A : Set} -> ((ClRingoid1ClTerm A) -> ((ClRingoid1ClTerm A) -> (ClRingoid1ClTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClRingoid1ClTerm A) -> ((ClRingoid1ClTerm A) -> (ClRingoid1ClTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    1Cl' : {A : Set} -> (ClRingoid1ClTerm A)
    1Cl'  = 1Cl 
    stageCl : {A : Set} -> ((ClRingoid1ClTerm A) -> (Staged (ClRingoid1ClTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl 1Cl = (Now 1Cl) 
    *OL' : {n : Nat} -> ((OpRingoid1OLTerm n) -> ((OpRingoid1OLTerm n) -> (OpRingoid1OLTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpRingoid1OLTerm n) -> ((OpRingoid1OLTerm n) -> (OpRingoid1OLTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    1OL' : {n : Nat} -> (OpRingoid1OLTerm n)
    1OL'  = 1OL 
    stageOpB : {n : Nat} -> ((OpRingoid1OLTerm n) -> (Staged (OpRingoid1OLTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 1OL = (Now 1OL) 
    *OL2' : {n : Nat} {A : Set} -> ((OpRingoid1OL2Term2 n A) -> ((OpRingoid1OL2Term2 n A) -> (OpRingoid1OL2Term2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpRingoid1OL2Term2 n A) -> ((OpRingoid1OL2Term2 n A) -> (OpRingoid1OL2Term2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    1OL2' : {n : Nat} {A : Set} -> (OpRingoid1OL2Term2 n A)
    1OL2'  = 1OL2 
    stageOp : {n : Nat} {A : Set} -> ((OpRingoid1OL2Term2 n A) -> (Staged (OpRingoid1OL2Term2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp 1OL2 = (Now 1OL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        1T : (Repr A)
  module Ringoid1Sig  where
    record Ringoid1Sig (A : Set) : Set where
      constructor Ringoid1SigC
      field
        * : (A -> (A -> A))
        1 : A
        + : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        1S : AS
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        1P : (Prod A A)
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (Ringoid1Sig A1)) (Ri2 : (Ringoid1Sig A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Ri1) x1 x2)) == ((* Ri2) (hom x1) (hom x2))
        pres-1 : (hom (1 Ri1)) == (1 Ri2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ri1) x1 x2)) == ((+ Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (Ringoid1Sig A1)) (Ri2 : (Ringoid1Sig A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Ri1) x1 x2) ((* Ri2) y1 y2))))
        interp-1 : (interp (1 Ri1) (1 Ri2))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ri1) x1 x2) ((+ Ri2) y1 y2))))
    data Ringoid1SigTerm  : Set where
      *L : (Ringoid1SigTerm -> (Ringoid1SigTerm -> Ringoid1SigTerm))
      1L : Ringoid1SigTerm
      +L : (Ringoid1SigTerm -> (Ringoid1SigTerm -> Ringoid1SigTerm))
    data ClRingoid1SigTerm (A : Set) : Set where
      sing : (A -> (ClRingoid1SigTerm A))
      *Cl : ((ClRingoid1SigTerm A) -> ((ClRingoid1SigTerm A) -> (ClRingoid1SigTerm A)))
      1Cl : (ClRingoid1SigTerm A)
      +Cl : ((ClRingoid1SigTerm A) -> ((ClRingoid1SigTerm A) -> (ClRingoid1SigTerm A)))
    data OpRingoid1SigTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRingoid1SigTerm n))
      *OL : ((OpRingoid1SigTerm n) -> ((OpRingoid1SigTerm n) -> (OpRingoid1SigTerm n)))
      1OL : (OpRingoid1SigTerm n)
      +OL : ((OpRingoid1SigTerm n) -> ((OpRingoid1SigTerm n) -> (OpRingoid1SigTerm n)))
    data OpRingoid1SigTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRingoid1SigTerm2 n A))
      sing2 : (A -> (OpRingoid1SigTerm2 n A))
      *OL2 : ((OpRingoid1SigTerm2 n A) -> ((OpRingoid1SigTerm2 n A) -> (OpRingoid1SigTerm2 n A)))
      1OL2 : (OpRingoid1SigTerm2 n A)
      +OL2 : ((OpRingoid1SigTerm2 n A) -> ((OpRingoid1SigTerm2 n A) -> (OpRingoid1SigTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRingoid1SigTerm A) -> (ClRingoid1SigTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRingoid1SigTerm n) -> (OpRingoid1SigTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRingoid1SigTerm2 n A) -> (OpRingoid1SigTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Ringoid1Sig A) -> (Ringoid1SigTerm -> A))
    evalB Ri (*L x1 x2) = ((* Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalB Ri 1L = (1 Ri) 
    evalB Ri (+L x1 x2) = ((+ Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((Ringoid1Sig A) -> ((ClRingoid1SigTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (*Cl x1 x2) = ((* Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalCl Ri 1Cl = (1 Ri) 
    evalCl Ri (+Cl x1 x2) = ((+ Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Ringoid1Sig A) -> ((Vec A n) -> ((OpRingoid1SigTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (*OL x1 x2) = ((* Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOpB Ri vars 1OL = (1 Ri) 
    evalOpB Ri vars (+OL x1 x2) = ((+ Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Ringoid1Sig A) -> ((Vec A n) -> ((OpRingoid1SigTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (*OL2 x1 x2) = ((* Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    evalOp Ri vars 1OL2 = (1 Ri) 
    evalOp Ri vars (+OL2 x1 x2) = ((+ Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (Ringoid1SigTerm -> Set)} -> (((x1 x2 : Ringoid1SigTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((P 1L) -> (((x1 x2 : Ringoid1SigTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : Ringoid1SigTerm) -> (P x)))))
    inductionB {p} p*l p1l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p1l p+l x1) (inductionB {p} p*l p1l p+l x2)) 
    inductionB {p} p*l p1l p+l 1L = p1l 
    inductionB {p} p*l p1l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p1l p+l x1) (inductionB {p} p*l p1l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClRingoid1SigTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRingoid1SigTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((P 1Cl) -> (((x1 x2 : (ClRingoid1SigTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClRingoid1SigTerm A)) -> (P x))))))
    inductionCl {_} {p} psing p*cl p1cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p1cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p1cl p+cl x1) (inductionCl {_} {p} psing p*cl p1cl p+cl x2)) 
    inductionCl {_} {p} psing p*cl p1cl p+cl 1Cl = p1cl 
    inductionCl {_} {p} psing p*cl p1cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p1cl p+cl x1) (inductionCl {_} {p} psing p*cl p1cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRingoid1SigTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRingoid1SigTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((P 1OL) -> (((x1 x2 : (OpRingoid1SigTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpRingoid1SigTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv p*ol p1ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p1ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p1ol p+ol x1) (inductionOpB {_} {p} pv p*ol p1ol p+ol x2)) 
    inductionOpB {_} {p} pv p*ol p1ol p+ol 1OL = p1ol 
    inductionOpB {_} {p} pv p*ol p1ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p1ol p+ol x1) (inductionOpB {_} {p} pv p*ol p1ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRingoid1SigTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRingoid1SigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((P 1OL2) -> (((x1 x2 : (OpRingoid1SigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpRingoid1SigTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 1OL2 = p1ol2 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 x2)) 
    *L' : (Ringoid1SigTerm -> (Ringoid1SigTerm -> Ringoid1SigTerm))
    *L' x1 x2 = (*L x1 x2) 
    1L' : Ringoid1SigTerm
    1L'  = 1L 
    +L' : (Ringoid1SigTerm -> (Ringoid1SigTerm -> Ringoid1SigTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (Ringoid1SigTerm -> (Staged Ringoid1SigTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB 1L = (Now 1L) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClRingoid1SigTerm A) -> ((ClRingoid1SigTerm A) -> (ClRingoid1SigTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    1Cl' : {A : Set} -> (ClRingoid1SigTerm A)
    1Cl'  = 1Cl 
    +Cl' : {A : Set} -> ((ClRingoid1SigTerm A) -> ((ClRingoid1SigTerm A) -> (ClRingoid1SigTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClRingoid1SigTerm A) -> (Staged (ClRingoid1SigTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl 1Cl = (Now 1Cl) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpRingoid1SigTerm n) -> ((OpRingoid1SigTerm n) -> (OpRingoid1SigTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    1OL' : {n : Nat} -> (OpRingoid1SigTerm n)
    1OL'  = 1OL 
    +OL' : {n : Nat} -> ((OpRingoid1SigTerm n) -> ((OpRingoid1SigTerm n) -> (OpRingoid1SigTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRingoid1SigTerm n) -> (Staged (OpRingoid1SigTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 1OL = (Now 1OL) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpRingoid1SigTerm2 n A) -> ((OpRingoid1SigTerm2 n A) -> (OpRingoid1SigTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    1OL2' : {n : Nat} {A : Set} -> (OpRingoid1SigTerm2 n A)
    1OL2'  = 1OL2 
    +OL2' : {n : Nat} {A : Set} -> ((OpRingoid1SigTerm2 n A) -> ((OpRingoid1SigTerm2 n A) -> (OpRingoid1SigTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRingoid1SigTerm2 n A) -> (Staged (OpRingoid1SigTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp 1OL2 = (Now 1OL2) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        1T : (Repr A)
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RingoidSig  where
    record RingoidSig (A : Set) : Set where
      constructor RingoidSigC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RingoidSig A1)) (Ri2 : (RingoidSig A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Ri1) x1 x2)) == ((* Ri2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ri1) x1 x2)) == ((+ Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RingoidSig A1)) (Ri2 : (RingoidSig A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Ri1) x1 x2) ((* Ri2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ri1) x1 x2) ((+ Ri2) y1 y2))))
    data RingoidSigTerm  : Set where
      *L : (RingoidSigTerm -> (RingoidSigTerm -> RingoidSigTerm))
      +L : (RingoidSigTerm -> (RingoidSigTerm -> RingoidSigTerm))
    data ClRingoidSigTerm (A : Set) : Set where
      sing : (A -> (ClRingoidSigTerm A))
      *Cl : ((ClRingoidSigTerm A) -> ((ClRingoidSigTerm A) -> (ClRingoidSigTerm A)))
      +Cl : ((ClRingoidSigTerm A) -> ((ClRingoidSigTerm A) -> (ClRingoidSigTerm A)))
    data OpRingoidSigTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRingoidSigTerm n))
      *OL : ((OpRingoidSigTerm n) -> ((OpRingoidSigTerm n) -> (OpRingoidSigTerm n)))
      +OL : ((OpRingoidSigTerm n) -> ((OpRingoidSigTerm n) -> (OpRingoidSigTerm n)))
    data OpRingoidSigTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRingoidSigTerm2 n A))
      sing2 : (A -> (OpRingoidSigTerm2 n A))
      *OL2 : ((OpRingoidSigTerm2 n A) -> ((OpRingoidSigTerm2 n A) -> (OpRingoidSigTerm2 n A)))
      +OL2 : ((OpRingoidSigTerm2 n A) -> ((OpRingoidSigTerm2 n A) -> (OpRingoidSigTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRingoidSigTerm A) -> (ClRingoidSigTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRingoidSigTerm n) -> (OpRingoidSigTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRingoidSigTerm2 n A) -> (OpRingoidSigTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RingoidSig A) -> (RingoidSigTerm -> A))
    evalB Ri (*L x1 x2) = ((* Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalB Ri (+L x1 x2) = ((+ Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((RingoidSig A) -> ((ClRingoidSigTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (*Cl x1 x2) = ((* Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalCl Ri (+Cl x1 x2) = ((+ Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((RingoidSig A) -> ((Vec A n) -> ((OpRingoidSigTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (*OL x1 x2) = ((* Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOpB Ri vars (+OL x1 x2) = ((+ Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((RingoidSig A) -> ((Vec A n) -> ((OpRingoidSigTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (*OL2 x1 x2) = ((* Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    evalOp Ri vars (+OL2 x1 x2) = ((+ Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (RingoidSigTerm -> Set)} -> (((x1 x2 : RingoidSigTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : RingoidSigTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : RingoidSigTerm) -> (P x))))
    inductionB {p} p*l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionB {p} p*l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l x1) (inductionB {p} p*l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClRingoidSigTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRingoidSigTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClRingoidSigTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClRingoidSigTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p*cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl x1) (inductionCl {_} {p} psing p*cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRingoidSigTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRingoidSigTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpRingoidSigTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpRingoidSigTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p*ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol x1) (inductionOpB {_} {p} pv p*ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRingoidSigTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRingoidSigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpRingoidSigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpRingoidSigTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 x2)) 
    *L' : (RingoidSigTerm -> (RingoidSigTerm -> RingoidSigTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (RingoidSigTerm -> (RingoidSigTerm -> RingoidSigTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (RingoidSigTerm -> (Staged RingoidSigTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClRingoidSigTerm A) -> ((ClRingoidSigTerm A) -> (ClRingoidSigTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClRingoidSigTerm A) -> ((ClRingoidSigTerm A) -> (ClRingoidSigTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClRingoidSigTerm A) -> (Staged (ClRingoidSigTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpRingoidSigTerm n) -> ((OpRingoidSigTerm n) -> (OpRingoidSigTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpRingoidSigTerm n) -> ((OpRingoidSigTerm n) -> (OpRingoidSigTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRingoidSigTerm n) -> (Staged (OpRingoidSigTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpRingoidSigTerm2 n A) -> ((OpRingoidSigTerm2 n A) -> (OpRingoidSigTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpRingoidSigTerm2 n A) -> ((OpRingoidSigTerm2 n A) -> (OpRingoidSigTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRingoidSigTerm2 n A) -> (Staged (OpRingoidSigTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RingoidWithAddAntiDistrib  where
    record RingoidWithAddAntiDistrib (A : Set) : Set where
      constructor RingoidWithAddAntiDistribC
      field
        + : (A -> (A -> A))
        prim : (A -> A)
        antidis_prim_+ : {x y : A} -> (prim (+ x y)) == (+ (prim y) (prim x))
        * : (A -> (A -> A))
        leftDistributive_*_+ : {x y z : A} -> (* x (+ y z)) == (+ (* x y) (* x z))
        rightDistributive_*_+ : {x y z : A} -> (* (+ y z) x) == (+ (* y x) (* z x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        +S : (AS -> (AS -> AS))
        primS : (AS -> AS)
        *S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        primP : ((Prod A A) -> (Prod A A))
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        antidis_prim_+P : {xP yP : (Prod A A)} -> (primP (+P xP yP)) == (+P (primP yP) (primP xP))
        leftDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P xP (+P yP zP)) == (+P (*P xP yP) (*P xP zP))
        rightDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P (+P yP zP) xP) == (+P (*P yP xP) (*P zP xP))
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RingoidWithAddAntiDistrib A1)) (Ri2 : (RingoidWithAddAntiDistrib A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ri1) x1 x2)) == ((+ Ri2) (hom x1) (hom x2))
        pres-prim : {x1 : A1} -> (hom ((prim Ri1) x1)) == ((prim Ri2) (hom x1))
        pres-* : {x1 x2 : A1} -> (hom ((* Ri1) x1 x2)) == ((* Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RingoidWithAddAntiDistrib A1)) (Ri2 : (RingoidWithAddAntiDistrib A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ri1) x1 x2) ((+ Ri2) y1 y2))))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim Ri1) x1) ((prim Ri2) y1)))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Ri1) x1 x2) ((* Ri2) y1 y2))))
    data RingoidWithAddAntiDistribTerm  : Set where
      +L : (RingoidWithAddAntiDistribTerm -> (RingoidWithAddAntiDistribTerm -> RingoidWithAddAntiDistribTerm))
      primL : (RingoidWithAddAntiDistribTerm -> RingoidWithAddAntiDistribTerm)
      *L : (RingoidWithAddAntiDistribTerm -> (RingoidWithAddAntiDistribTerm -> RingoidWithAddAntiDistribTerm))
    data ClRingoidWithAddAntiDistribTerm (A : Set) : Set where
      sing : (A -> (ClRingoidWithAddAntiDistribTerm A))
      +Cl : ((ClRingoidWithAddAntiDistribTerm A) -> ((ClRingoidWithAddAntiDistribTerm A) -> (ClRingoidWithAddAntiDistribTerm A)))
      primCl : ((ClRingoidWithAddAntiDistribTerm A) -> (ClRingoidWithAddAntiDistribTerm A))
      *Cl : ((ClRingoidWithAddAntiDistribTerm A) -> ((ClRingoidWithAddAntiDistribTerm A) -> (ClRingoidWithAddAntiDistribTerm A)))
    data OpRingoidWithAddAntiDistribTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRingoidWithAddAntiDistribTerm n))
      +OL : ((OpRingoidWithAddAntiDistribTerm n) -> ((OpRingoidWithAddAntiDistribTerm n) -> (OpRingoidWithAddAntiDistribTerm n)))
      primOL : ((OpRingoidWithAddAntiDistribTerm n) -> (OpRingoidWithAddAntiDistribTerm n))
      *OL : ((OpRingoidWithAddAntiDistribTerm n) -> ((OpRingoidWithAddAntiDistribTerm n) -> (OpRingoidWithAddAntiDistribTerm n)))
    data OpRingoidWithAddAntiDistribTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRingoidWithAddAntiDistribTerm2 n A))
      sing2 : (A -> (OpRingoidWithAddAntiDistribTerm2 n A))
      +OL2 : ((OpRingoidWithAddAntiDistribTerm2 n A) -> ((OpRingoidWithAddAntiDistribTerm2 n A) -> (OpRingoidWithAddAntiDistribTerm2 n A)))
      primOL2 : ((OpRingoidWithAddAntiDistribTerm2 n A) -> (OpRingoidWithAddAntiDistribTerm2 n A))
      *OL2 : ((OpRingoidWithAddAntiDistribTerm2 n A) -> ((OpRingoidWithAddAntiDistribTerm2 n A) -> (OpRingoidWithAddAntiDistribTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRingoidWithAddAntiDistribTerm A) -> (ClRingoidWithAddAntiDistribTerm A))
    simplifyCl (+Cl (primCl y) (primCl x)) = (primCl (+Cl x y)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRingoidWithAddAntiDistribTerm n) -> (OpRingoidWithAddAntiDistribTerm n))
    simplifyOpB (+OL (primOL y) (primOL x)) = (primOL (+OL x y)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRingoidWithAddAntiDistribTerm2 n A) -> (OpRingoidWithAddAntiDistribTerm2 n A))
    simplifyOp (+OL2 (primOL2 y) (primOL2 x)) = (primOL2 (+OL2 x y)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RingoidWithAddAntiDistrib A) -> (RingoidWithAddAntiDistribTerm -> A))
    evalB Ri (+L x1 x2) = ((+ Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalB Ri (primL x1) = ((prim Ri) (evalB Ri x1)) 
    evalB Ri (*L x1 x2) = ((* Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((RingoidWithAddAntiDistrib A) -> ((ClRingoidWithAddAntiDistribTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (+Cl x1 x2) = ((+ Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalCl Ri (primCl x1) = ((prim Ri) (evalCl Ri x1)) 
    evalCl Ri (*Cl x1 x2) = ((* Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((RingoidWithAddAntiDistrib A) -> ((Vec A n) -> ((OpRingoidWithAddAntiDistribTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (+OL x1 x2) = ((+ Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOpB Ri vars (primOL x1) = ((prim Ri) (evalOpB Ri vars x1)) 
    evalOpB Ri vars (*OL x1 x2) = ((* Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((RingoidWithAddAntiDistrib A) -> ((Vec A n) -> ((OpRingoidWithAddAntiDistribTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (+OL2 x1 x2) = ((+ Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    evalOp Ri vars (primOL2 x1) = ((prim Ri) (evalOp Ri vars x1)) 
    evalOp Ri vars (*OL2 x1 x2) = ((* Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (RingoidWithAddAntiDistribTerm -> Set)} -> (((x1 x2 : RingoidWithAddAntiDistribTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> (((x1 : RingoidWithAddAntiDistribTerm) -> ((P x1) -> (P (primL x1)))) -> (((x1 x2 : RingoidWithAddAntiDistribTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((x : RingoidWithAddAntiDistribTerm) -> (P x)))))
    inductionB {p} p+l ppriml p*l (+L x1 x2) = (p+l _ _ (inductionB {p} p+l ppriml p*l x1) (inductionB {p} p+l ppriml p*l x2)) 
    inductionB {p} p+l ppriml p*l (primL x1) = (ppriml _ (inductionB {p} p+l ppriml p*l x1)) 
    inductionB {p} p+l ppriml p*l (*L x1 x2) = (p*l _ _ (inductionB {p} p+l ppriml p*l x1) (inductionB {p} p+l ppriml p*l x2)) 
    inductionCl : {A : Set} {P : ((ClRingoidWithAddAntiDistribTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRingoidWithAddAntiDistribTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> (((x1 : (ClRingoidWithAddAntiDistribTerm A)) -> ((P x1) -> (P (primCl x1)))) -> (((x1 x2 : (ClRingoidWithAddAntiDistribTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((x : (ClRingoidWithAddAntiDistribTerm A)) -> (P x))))))
    inductionCl {_} {p} psing p+cl pprimcl p*cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p+cl pprimcl p*cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p+cl pprimcl p*cl x1) (inductionCl {_} {p} psing p+cl pprimcl p*cl x2)) 
    inductionCl {_} {p} psing p+cl pprimcl p*cl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing p+cl pprimcl p*cl x1)) 
    inductionCl {_} {p} psing p+cl pprimcl p*cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p+cl pprimcl p*cl x1) (inductionCl {_} {p} psing p+cl pprimcl p*cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRingoidWithAddAntiDistribTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRingoidWithAddAntiDistribTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> (((x1 : (OpRingoidWithAddAntiDistribTerm n)) -> ((P x1) -> (P (primOL x1)))) -> (((x1 x2 : (OpRingoidWithAddAntiDistribTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((x : (OpRingoidWithAddAntiDistribTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv p+ol pprimol p*ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p+ol pprimol p*ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p+ol pprimol p*ol x1) (inductionOpB {_} {p} pv p+ol pprimol p*ol x2)) 
    inductionOpB {_} {p} pv p+ol pprimol p*ol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv p+ol pprimol p*ol x1)) 
    inductionOpB {_} {p} pv p+ol pprimol p*ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p+ol pprimol p*ol x1) (inductionOpB {_} {p} pv p+ol pprimol p*ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRingoidWithAddAntiDistribTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRingoidWithAddAntiDistribTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> (((x1 : (OpRingoidWithAddAntiDistribTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> (((x1 x2 : (OpRingoidWithAddAntiDistribTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((x : (OpRingoidWithAddAntiDistribTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 pprimol2 p*ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 pprimol2 p*ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 pprimol2 p*ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 pprimol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 pprimol2 p*ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 pprimol2 p*ol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 pprimol2 p*ol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 pprimol2 p*ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 pprimol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 pprimol2 p*ol2 x2)) 
    +L' : (RingoidWithAddAntiDistribTerm -> (RingoidWithAddAntiDistribTerm -> RingoidWithAddAntiDistribTerm))
    +L' x1 x2 = (+L x1 x2) 
    primL' : (RingoidWithAddAntiDistribTerm -> RingoidWithAddAntiDistribTerm)
    primL' x1 = (primL x1) 
    *L' : (RingoidWithAddAntiDistribTerm -> (RingoidWithAddAntiDistribTerm -> RingoidWithAddAntiDistribTerm))
    *L' x1 x2 = (*L x1 x2) 
    stageB : (RingoidWithAddAntiDistribTerm -> (Staged RingoidWithAddAntiDistribTerm))
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    +Cl' : {A : Set} -> ((ClRingoidWithAddAntiDistribTerm A) -> ((ClRingoidWithAddAntiDistribTerm A) -> (ClRingoidWithAddAntiDistribTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    primCl' : {A : Set} -> ((ClRingoidWithAddAntiDistribTerm A) -> (ClRingoidWithAddAntiDistribTerm A))
    primCl' x1 = (primCl x1) 
    *Cl' : {A : Set} -> ((ClRingoidWithAddAntiDistribTerm A) -> ((ClRingoidWithAddAntiDistribTerm A) -> (ClRingoidWithAddAntiDistribTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    stageCl : {A : Set} -> ((ClRingoidWithAddAntiDistribTerm A) -> (Staged (ClRingoidWithAddAntiDistribTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    +OL' : {n : Nat} -> ((OpRingoidWithAddAntiDistribTerm n) -> ((OpRingoidWithAddAntiDistribTerm n) -> (OpRingoidWithAddAntiDistribTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    primOL' : {n : Nat} -> ((OpRingoidWithAddAntiDistribTerm n) -> (OpRingoidWithAddAntiDistribTerm n))
    primOL' x1 = (primOL x1) 
    *OL' : {n : Nat} -> ((OpRingoidWithAddAntiDistribTerm n) -> ((OpRingoidWithAddAntiDistribTerm n) -> (OpRingoidWithAddAntiDistribTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRingoidWithAddAntiDistribTerm n) -> (Staged (OpRingoidWithAddAntiDistribTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    +OL2' : {n : Nat} {A : Set} -> ((OpRingoidWithAddAntiDistribTerm2 n A) -> ((OpRingoidWithAddAntiDistribTerm2 n A) -> (OpRingoidWithAddAntiDistribTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    primOL2' : {n : Nat} {A : Set} -> ((OpRingoidWithAddAntiDistribTerm2 n A) -> (OpRingoidWithAddAntiDistribTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    *OL2' : {n : Nat} {A : Set} -> ((OpRingoidWithAddAntiDistribTerm2 n A) -> ((OpRingoidWithAddAntiDistribTerm2 n A) -> (OpRingoidWithAddAntiDistribTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRingoidWithAddAntiDistribTerm2 n A) -> (Staged (OpRingoidWithAddAntiDistribTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        primT : ((Repr A) -> (Repr A))
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module RingoidWithInvolution  where
    record RingoidWithInvolution (A : Set) : Set where
      constructor RingoidWithInvolutionC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        leftDistributive_*_+ : {x y z : A} -> (* x (+ y z)) == (+ (* x y) (* x z))
        rightDistributive_*_+ : {x y z : A} -> (* (+ y z) x) == (+ (* y x) (* z x))
        prim : (A -> A)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
        primS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        primP : ((Prod A A) -> (Prod A A))
        leftDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P xP (+P yP zP)) == (+P (*P xP yP) (*P xP zP))
        rightDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P (+P yP zP) xP) == (+P (*P yP xP) (*P zP xP))
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RingoidWithInvolution A1)) (Ri2 : (RingoidWithInvolution A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Ri1) x1 x2)) == ((* Ri2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ri1) x1 x2)) == ((+ Ri2) (hom x1) (hom x2))
        pres-prim : {x1 : A1} -> (hom ((prim Ri1) x1)) == ((prim Ri2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RingoidWithInvolution A1)) (Ri2 : (RingoidWithInvolution A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Ri1) x1 x2) ((* Ri2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ri1) x1 x2) ((+ Ri2) y1 y2))))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim Ri1) x1) ((prim Ri2) y1)))
    data RingoidWithInvolutionTerm  : Set where
      *L : (RingoidWithInvolutionTerm -> (RingoidWithInvolutionTerm -> RingoidWithInvolutionTerm))
      +L : (RingoidWithInvolutionTerm -> (RingoidWithInvolutionTerm -> RingoidWithInvolutionTerm))
      primL : (RingoidWithInvolutionTerm -> RingoidWithInvolutionTerm)
    data ClRingoidWithInvolutionTerm (A : Set) : Set where
      sing : (A -> (ClRingoidWithInvolutionTerm A))
      *Cl : ((ClRingoidWithInvolutionTerm A) -> ((ClRingoidWithInvolutionTerm A) -> (ClRingoidWithInvolutionTerm A)))
      +Cl : ((ClRingoidWithInvolutionTerm A) -> ((ClRingoidWithInvolutionTerm A) -> (ClRingoidWithInvolutionTerm A)))
      primCl : ((ClRingoidWithInvolutionTerm A) -> (ClRingoidWithInvolutionTerm A))
    data OpRingoidWithInvolutionTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRingoidWithInvolutionTerm n))
      *OL : ((OpRingoidWithInvolutionTerm n) -> ((OpRingoidWithInvolutionTerm n) -> (OpRingoidWithInvolutionTerm n)))
      +OL : ((OpRingoidWithInvolutionTerm n) -> ((OpRingoidWithInvolutionTerm n) -> (OpRingoidWithInvolutionTerm n)))
      primOL : ((OpRingoidWithInvolutionTerm n) -> (OpRingoidWithInvolutionTerm n))
    data OpRingoidWithInvolutionTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRingoidWithInvolutionTerm2 n A))
      sing2 : (A -> (OpRingoidWithInvolutionTerm2 n A))
      *OL2 : ((OpRingoidWithInvolutionTerm2 n A) -> ((OpRingoidWithInvolutionTerm2 n A) -> (OpRingoidWithInvolutionTerm2 n A)))
      +OL2 : ((OpRingoidWithInvolutionTerm2 n A) -> ((OpRingoidWithInvolutionTerm2 n A) -> (OpRingoidWithInvolutionTerm2 n A)))
      primOL2 : ((OpRingoidWithInvolutionTerm2 n A) -> (OpRingoidWithInvolutionTerm2 n A))
    simplifyCl : {A : Set} -> ((ClRingoidWithInvolutionTerm A) -> (ClRingoidWithInvolutionTerm A))
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRingoidWithInvolutionTerm n) -> (OpRingoidWithInvolutionTerm n))
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRingoidWithInvolutionTerm2 n A) -> (OpRingoidWithInvolutionTerm2 n A))
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RingoidWithInvolution A) -> (RingoidWithInvolutionTerm -> A))
    evalB Ri (*L x1 x2) = ((* Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalB Ri (+L x1 x2) = ((+ Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalB Ri (primL x1) = ((prim Ri) (evalB Ri x1)) 
    evalCl : {A : Set} -> ((RingoidWithInvolution A) -> ((ClRingoidWithInvolutionTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (*Cl x1 x2) = ((* Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalCl Ri (+Cl x1 x2) = ((+ Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalCl Ri (primCl x1) = ((prim Ri) (evalCl Ri x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((RingoidWithInvolution A) -> ((Vec A n) -> ((OpRingoidWithInvolutionTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (*OL x1 x2) = ((* Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOpB Ri vars (+OL x1 x2) = ((+ Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOpB Ri vars (primOL x1) = ((prim Ri) (evalOpB Ri vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((RingoidWithInvolution A) -> ((Vec A n) -> ((OpRingoidWithInvolutionTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (*OL2 x1 x2) = ((* Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    evalOp Ri vars (+OL2 x1 x2) = ((+ Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    evalOp Ri vars (primOL2 x1) = ((prim Ri) (evalOp Ri vars x1)) 
    inductionB : {P : (RingoidWithInvolutionTerm -> Set)} -> (((x1 x2 : RingoidWithInvolutionTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : RingoidWithInvolutionTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> (((x1 : RingoidWithInvolutionTerm) -> ((P x1) -> (P (primL x1)))) -> ((x : RingoidWithInvolutionTerm) -> (P x)))))
    inductionB {p} p*l p+l ppriml (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l ppriml x1) (inductionB {p} p*l p+l ppriml x2)) 
    inductionB {p} p*l p+l ppriml (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l ppriml x1) (inductionB {p} p*l p+l ppriml x2)) 
    inductionB {p} p*l p+l ppriml (primL x1) = (ppriml _ (inductionB {p} p*l p+l ppriml x1)) 
    inductionCl : {A : Set} {P : ((ClRingoidWithInvolutionTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRingoidWithInvolutionTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClRingoidWithInvolutionTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> (((x1 : (ClRingoidWithInvolutionTerm A)) -> ((P x1) -> (P (primCl x1)))) -> ((x : (ClRingoidWithInvolutionTerm A)) -> (P x))))))
    inductionCl {_} {p} psing p*cl p+cl pprimcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl pprimcl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl pprimcl x1) (inductionCl {_} {p} psing p*cl p+cl pprimcl x2)) 
    inductionCl {_} {p} psing p*cl p+cl pprimcl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl pprimcl x1) (inductionCl {_} {p} psing p*cl p+cl pprimcl x2)) 
    inductionCl {_} {p} psing p*cl p+cl pprimcl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing p*cl p+cl pprimcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpRingoidWithInvolutionTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRingoidWithInvolutionTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpRingoidWithInvolutionTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> (((x1 : (OpRingoidWithInvolutionTerm n)) -> ((P x1) -> (P (primOL x1)))) -> ((x : (OpRingoidWithInvolutionTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv p*ol p+ol pprimol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol pprimol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol pprimol x1) (inductionOpB {_} {p} pv p*ol p+ol pprimol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol pprimol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol pprimol x1) (inductionOpB {_} {p} pv p*ol p+ol pprimol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol pprimol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv p*ol p+ol pprimol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRingoidWithInvolutionTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRingoidWithInvolutionTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpRingoidWithInvolutionTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> (((x1 : (OpRingoidWithInvolutionTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> ((x : (OpRingoidWithInvolutionTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 pprimol2 x1)) 
    *L' : (RingoidWithInvolutionTerm -> (RingoidWithInvolutionTerm -> RingoidWithInvolutionTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (RingoidWithInvolutionTerm -> (RingoidWithInvolutionTerm -> RingoidWithInvolutionTerm))
    +L' x1 x2 = (+L x1 x2) 
    primL' : (RingoidWithInvolutionTerm -> RingoidWithInvolutionTerm)
    primL' x1 = (primL x1) 
    stageB : (RingoidWithInvolutionTerm -> (Staged RingoidWithInvolutionTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    *Cl' : {A : Set} -> ((ClRingoidWithInvolutionTerm A) -> ((ClRingoidWithInvolutionTerm A) -> (ClRingoidWithInvolutionTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClRingoidWithInvolutionTerm A) -> ((ClRingoidWithInvolutionTerm A) -> (ClRingoidWithInvolutionTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    primCl' : {A : Set} -> ((ClRingoidWithInvolutionTerm A) -> (ClRingoidWithInvolutionTerm A))
    primCl' x1 = (primCl x1) 
    stageCl : {A : Set} -> ((ClRingoidWithInvolutionTerm A) -> (Staged (ClRingoidWithInvolutionTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    *OL' : {n : Nat} -> ((OpRingoidWithInvolutionTerm n) -> ((OpRingoidWithInvolutionTerm n) -> (OpRingoidWithInvolutionTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpRingoidWithInvolutionTerm n) -> ((OpRingoidWithInvolutionTerm n) -> (OpRingoidWithInvolutionTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    primOL' : {n : Nat} -> ((OpRingoidWithInvolutionTerm n) -> (OpRingoidWithInvolutionTerm n))
    primOL' x1 = (primOL x1) 
    stageOpB : {n : Nat} -> ((OpRingoidWithInvolutionTerm n) -> (Staged (OpRingoidWithInvolutionTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpRingoidWithInvolutionTerm2 n A) -> ((OpRingoidWithInvolutionTerm2 n A) -> (OpRingoidWithInvolutionTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpRingoidWithInvolutionTerm2 n A) -> ((OpRingoidWithInvolutionTerm2 n A) -> (OpRingoidWithInvolutionTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    primOL2' : {n : Nat} {A : Set} -> ((OpRingoidWithInvolutionTerm2 n A) -> (OpRingoidWithInvolutionTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpRingoidWithInvolutionTerm2 n A) -> (Staged (OpRingoidWithInvolutionTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        primT : ((Repr A) -> (Repr A))
  module RingoidWithMultAntiDistrib  where
    record RingoidWithMultAntiDistrib (A : Set) : Set where
      constructor RingoidWithMultAntiDistribC
      field
        * : (A -> (A -> A))
        prim : (A -> A)
        antidis_prim_* : {x y : A} -> (prim (* x y)) == (* (prim y) (prim x))
        + : (A -> (A -> A))
        leftDistributive_*_+ : {x y z : A} -> (* x (+ y z)) == (+ (* x y) (* x z))
        rightDistributive_*_+ : {x y z : A} -> (* (+ y z) x) == (+ (* y x) (* z x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        primS : (AS -> AS)
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        primP : ((Prod A A) -> (Prod A A))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        antidis_prim_*P : {xP yP : (Prod A A)} -> (primP (*P xP yP)) == (*P (primP yP) (primP xP))
        leftDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P xP (+P yP zP)) == (+P (*P xP yP) (*P xP zP))
        rightDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P (+P yP zP) xP) == (+P (*P yP xP) (*P zP xP))
    record Hom {A1 : Set} {A2 : Set} (Ri1 : (RingoidWithMultAntiDistrib A1)) (Ri2 : (RingoidWithMultAntiDistrib A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Ri1) x1 x2)) == ((* Ri2) (hom x1) (hom x2))
        pres-prim : {x1 : A1} -> (hom ((prim Ri1) x1)) == ((prim Ri2) (hom x1))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ri1) x1 x2)) == ((+ Ri2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ri1 : (RingoidWithMultAntiDistrib A1)) (Ri2 : (RingoidWithMultAntiDistrib A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Ri1) x1 x2) ((* Ri2) y1 y2))))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim Ri1) x1) ((prim Ri2) y1)))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ri1) x1 x2) ((+ Ri2) y1 y2))))
    data RingoidWithMultAntiDistribTerm  : Set where
      *L : (RingoidWithMultAntiDistribTerm -> (RingoidWithMultAntiDistribTerm -> RingoidWithMultAntiDistribTerm))
      primL : (RingoidWithMultAntiDistribTerm -> RingoidWithMultAntiDistribTerm)
      +L : (RingoidWithMultAntiDistribTerm -> (RingoidWithMultAntiDistribTerm -> RingoidWithMultAntiDistribTerm))
    data ClRingoidWithMultAntiDistribTerm (A : Set) : Set where
      sing : (A -> (ClRingoidWithMultAntiDistribTerm A))
      *Cl : ((ClRingoidWithMultAntiDistribTerm A) -> ((ClRingoidWithMultAntiDistribTerm A) -> (ClRingoidWithMultAntiDistribTerm A)))
      primCl : ((ClRingoidWithMultAntiDistribTerm A) -> (ClRingoidWithMultAntiDistribTerm A))
      +Cl : ((ClRingoidWithMultAntiDistribTerm A) -> ((ClRingoidWithMultAntiDistribTerm A) -> (ClRingoidWithMultAntiDistribTerm A)))
    data OpRingoidWithMultAntiDistribTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRingoidWithMultAntiDistribTerm n))
      *OL : ((OpRingoidWithMultAntiDistribTerm n) -> ((OpRingoidWithMultAntiDistribTerm n) -> (OpRingoidWithMultAntiDistribTerm n)))
      primOL : ((OpRingoidWithMultAntiDistribTerm n) -> (OpRingoidWithMultAntiDistribTerm n))
      +OL : ((OpRingoidWithMultAntiDistribTerm n) -> ((OpRingoidWithMultAntiDistribTerm n) -> (OpRingoidWithMultAntiDistribTerm n)))
    data OpRingoidWithMultAntiDistribTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRingoidWithMultAntiDistribTerm2 n A))
      sing2 : (A -> (OpRingoidWithMultAntiDistribTerm2 n A))
      *OL2 : ((OpRingoidWithMultAntiDistribTerm2 n A) -> ((OpRingoidWithMultAntiDistribTerm2 n A) -> (OpRingoidWithMultAntiDistribTerm2 n A)))
      primOL2 : ((OpRingoidWithMultAntiDistribTerm2 n A) -> (OpRingoidWithMultAntiDistribTerm2 n A))
      +OL2 : ((OpRingoidWithMultAntiDistribTerm2 n A) -> ((OpRingoidWithMultAntiDistribTerm2 n A) -> (OpRingoidWithMultAntiDistribTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRingoidWithMultAntiDistribTerm A) -> (ClRingoidWithMultAntiDistribTerm A))
    simplifyCl (*Cl (primCl y) (primCl x)) = (primCl (*Cl x y)) 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRingoidWithMultAntiDistribTerm n) -> (OpRingoidWithMultAntiDistribTerm n))
    simplifyOpB (*OL (primOL y) (primOL x)) = (primOL (*OL x y)) 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRingoidWithMultAntiDistribTerm2 n A) -> (OpRingoidWithMultAntiDistribTerm2 n A))
    simplifyOp (*OL2 (primOL2 y) (primOL2 x)) = (primOL2 (*OL2 x y)) 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((RingoidWithMultAntiDistrib A) -> (RingoidWithMultAntiDistribTerm -> A))
    evalB Ri (*L x1 x2) = ((* Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalB Ri (primL x1) = ((prim Ri) (evalB Ri x1)) 
    evalB Ri (+L x1 x2) = ((+ Ri) (evalB Ri x1) (evalB Ri x2)) 
    evalCl : {A : Set} -> ((RingoidWithMultAntiDistrib A) -> ((ClRingoidWithMultAntiDistribTerm A) -> A))
    evalCl Ri (sing x1) = x1 
    evalCl Ri (*Cl x1 x2) = ((* Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalCl Ri (primCl x1) = ((prim Ri) (evalCl Ri x1)) 
    evalCl Ri (+Cl x1 x2) = ((+ Ri) (evalCl Ri x1) (evalCl Ri x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((RingoidWithMultAntiDistrib A) -> ((Vec A n) -> ((OpRingoidWithMultAntiDistribTerm n) -> A)))
    evalOpB Ri vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ri vars (*OL x1 x2) = ((* Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOpB Ri vars (primOL x1) = ((prim Ri) (evalOpB Ri vars x1)) 
    evalOpB Ri vars (+OL x1 x2) = ((+ Ri) (evalOpB Ri vars x1) (evalOpB Ri vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((RingoidWithMultAntiDistrib A) -> ((Vec A n) -> ((OpRingoidWithMultAntiDistribTerm2 n A) -> A)))
    evalOp Ri vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ri vars (sing2 x1) = x1 
    evalOp Ri vars (*OL2 x1 x2) = ((* Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    evalOp Ri vars (primOL2 x1) = ((prim Ri) (evalOp Ri vars x1)) 
    evalOp Ri vars (+OL2 x1 x2) = ((+ Ri) (evalOp Ri vars x1) (evalOp Ri vars x2)) 
    inductionB : {P : (RingoidWithMultAntiDistribTerm -> Set)} -> (((x1 x2 : RingoidWithMultAntiDistribTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 : RingoidWithMultAntiDistribTerm) -> ((P x1) -> (P (primL x1)))) -> (((x1 x2 : RingoidWithMultAntiDistribTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : RingoidWithMultAntiDistribTerm) -> (P x)))))
    inductionB {p} p*l ppriml p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l ppriml p+l x1) (inductionB {p} p*l ppriml p+l x2)) 
    inductionB {p} p*l ppriml p+l (primL x1) = (ppriml _ (inductionB {p} p*l ppriml p+l x1)) 
    inductionB {p} p*l ppriml p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l ppriml p+l x1) (inductionB {p} p*l ppriml p+l x2)) 
    inductionCl : {A : Set} {P : ((ClRingoidWithMultAntiDistribTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRingoidWithMultAntiDistribTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 : (ClRingoidWithMultAntiDistribTerm A)) -> ((P x1) -> (P (primCl x1)))) -> (((x1 x2 : (ClRingoidWithMultAntiDistribTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClRingoidWithMultAntiDistribTerm A)) -> (P x))))))
    inductionCl {_} {p} psing p*cl pprimcl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl pprimcl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl pprimcl p+cl x1) (inductionCl {_} {p} psing p*cl pprimcl p+cl x2)) 
    inductionCl {_} {p} psing p*cl pprimcl p+cl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing p*cl pprimcl p+cl x1)) 
    inductionCl {_} {p} psing p*cl pprimcl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl pprimcl p+cl x1) (inductionCl {_} {p} psing p*cl pprimcl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRingoidWithMultAntiDistribTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRingoidWithMultAntiDistribTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 : (OpRingoidWithMultAntiDistribTerm n)) -> ((P x1) -> (P (primOL x1)))) -> (((x1 x2 : (OpRingoidWithMultAntiDistribTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpRingoidWithMultAntiDistribTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv p*ol pprimol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol pprimol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol pprimol p+ol x1) (inductionOpB {_} {p} pv p*ol pprimol p+ol x2)) 
    inductionOpB {_} {p} pv p*ol pprimol p+ol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv p*ol pprimol p+ol x1)) 
    inductionOpB {_} {p} pv p*ol pprimol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol pprimol p+ol x1) (inductionOpB {_} {p} pv p*ol pprimol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRingoidWithMultAntiDistribTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRingoidWithMultAntiDistribTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 : (OpRingoidWithMultAntiDistribTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> (((x1 x2 : (OpRingoidWithMultAntiDistribTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpRingoidWithMultAntiDistribTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 pprimol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 pprimol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 pprimol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 pprimol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 pprimol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 pprimol2 p+ol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 pprimol2 p+ol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 pprimol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 pprimol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 pprimol2 p+ol2 x2)) 
    *L' : (RingoidWithMultAntiDistribTerm -> (RingoidWithMultAntiDistribTerm -> RingoidWithMultAntiDistribTerm))
    *L' x1 x2 = (*L x1 x2) 
    primL' : (RingoidWithMultAntiDistribTerm -> RingoidWithMultAntiDistribTerm)
    primL' x1 = (primL x1) 
    +L' : (RingoidWithMultAntiDistribTerm -> (RingoidWithMultAntiDistribTerm -> RingoidWithMultAntiDistribTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (RingoidWithMultAntiDistribTerm -> (Staged RingoidWithMultAntiDistribTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    *Cl' : {A : Set} -> ((ClRingoidWithMultAntiDistribTerm A) -> ((ClRingoidWithMultAntiDistribTerm A) -> (ClRingoidWithMultAntiDistribTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    primCl' : {A : Set} -> ((ClRingoidWithMultAntiDistribTerm A) -> (ClRingoidWithMultAntiDistribTerm A))
    primCl' x1 = (primCl x1) 
    +Cl' : {A : Set} -> ((ClRingoidWithMultAntiDistribTerm A) -> ((ClRingoidWithMultAntiDistribTerm A) -> (ClRingoidWithMultAntiDistribTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClRingoidWithMultAntiDistribTerm A) -> (Staged (ClRingoidWithMultAntiDistribTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    *OL' : {n : Nat} -> ((OpRingoidWithMultAntiDistribTerm n) -> ((OpRingoidWithMultAntiDistribTerm n) -> (OpRingoidWithMultAntiDistribTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    primOL' : {n : Nat} -> ((OpRingoidWithMultAntiDistribTerm n) -> (OpRingoidWithMultAntiDistribTerm n))
    primOL' x1 = (primOL x1) 
    +OL' : {n : Nat} -> ((OpRingoidWithMultAntiDistribTerm n) -> ((OpRingoidWithMultAntiDistribTerm n) -> (OpRingoidWithMultAntiDistribTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRingoidWithMultAntiDistribTerm n) -> (Staged (OpRingoidWithMultAntiDistribTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    *OL2' : {n : Nat} {A : Set} -> ((OpRingoidWithMultAntiDistribTerm2 n A) -> ((OpRingoidWithMultAntiDistribTerm2 n A) -> (OpRingoidWithMultAntiDistribTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    primOL2' : {n : Nat} {A : Set} -> ((OpRingoidWithMultAntiDistribTerm2 n A) -> (OpRingoidWithMultAntiDistribTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    +OL2' : {n : Nat} {A : Set} -> ((OpRingoidWithMultAntiDistribTerm2 n A) -> ((OpRingoidWithMultAntiDistribTerm2 n A) -> (OpRingoidWithMultAntiDistribTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRingoidWithMultAntiDistribTerm2 n A) -> (Staged (OpRingoidWithMultAntiDistribTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        primT : ((Repr A) -> (Repr A))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module Rng  where
    record Rng (A : Set) : Set where
      constructor RngC
      field
        + : (A -> (A -> A))
        0 : A
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        neg : (A -> A)
        leftInverse_inv_op_0 : {x : A} -> (+ x (neg x)) == 0
        rightInverse_inv_op_0 : {x : A} -> (+ (neg x) x) == 0
        * : (A -> (A -> A))
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        leftDistributive_*_+ : {x y z : A} -> (* x (+ y z)) == (+ (* x y) (* x z))
        rightDistributive_*_+ : {x y z : A} -> (* (+ y z) x) == (+ (* y x) (* z x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        +S : (AS -> (AS -> AS))
        0S : AS
        negS : (AS -> AS)
        *S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        0P : (Prod A A)
        negP : ((Prod A A) -> (Prod A A))
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        leftInverse_inv_op_0P : {xP : (Prod A A)} -> (+P xP (negP xP)) == 0P
        rightInverse_inv_op_0P : {xP : (Prod A A)} -> (+P (negP xP) xP) == 0P
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        leftDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P xP (+P yP zP)) == (+P (*P xP yP) (*P xP zP))
        rightDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P (+P yP zP) xP) == (+P (*P yP xP) (*P zP xP))
    record Hom {A1 : Set} {A2 : Set} (Rn1 : (Rng A1)) (Rn2 : (Rng A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Rn1) x1 x2)) == ((+ Rn2) (hom x1) (hom x2))
        pres-0 : (hom (0 Rn1)) == (0 Rn2)
        pres-neg : {x1 : A1} -> (hom ((neg Rn1) x1)) == ((neg Rn2) (hom x1))
        pres-* : {x1 x2 : A1} -> (hom ((* Rn1) x1 x2)) == ((* Rn2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Rn1 : (Rng A1)) (Rn2 : (Rng A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Rn1) x1 x2) ((+ Rn2) y1 y2))))
        interp-0 : (interp (0 Rn1) (0 Rn2))
        interp-neg : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((neg Rn1) x1) ((neg Rn2) y1)))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Rn1) x1 x2) ((* Rn2) y1 y2))))
    data RngTerm  : Set where
      +L : (RngTerm -> (RngTerm -> RngTerm))
      0L : RngTerm
      negL : (RngTerm -> RngTerm)
      *L : (RngTerm -> (RngTerm -> RngTerm))
    data ClRngTerm (A : Set) : Set where
      sing : (A -> (ClRngTerm A))
      +Cl : ((ClRngTerm A) -> ((ClRngTerm A) -> (ClRngTerm A)))
      0Cl : (ClRngTerm A)
      negCl : ((ClRngTerm A) -> (ClRngTerm A))
      *Cl : ((ClRngTerm A) -> ((ClRngTerm A) -> (ClRngTerm A)))
    data OpRngTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpRngTerm n))
      +OL : ((OpRngTerm n) -> ((OpRngTerm n) -> (OpRngTerm n)))
      0OL : (OpRngTerm n)
      negOL : ((OpRngTerm n) -> (OpRngTerm n))
      *OL : ((OpRngTerm n) -> ((OpRngTerm n) -> (OpRngTerm n)))
    data OpRngTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpRngTerm2 n A))
      sing2 : (A -> (OpRngTerm2 n A))
      +OL2 : ((OpRngTerm2 n A) -> ((OpRngTerm2 n A) -> (OpRngTerm2 n A)))
      0OL2 : (OpRngTerm2 n A)
      negOL2 : ((OpRngTerm2 n A) -> (OpRngTerm2 n A))
      *OL2 : ((OpRngTerm2 n A) -> ((OpRngTerm2 n A) -> (OpRngTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClRngTerm A) -> (ClRngTerm A))
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 0Cl = 0Cl 
    simplifyCl (negCl x1) = (negCl (simplifyCl x1)) 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpRngTerm n) -> (OpRngTerm n))
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 0OL = 0OL 
    simplifyOpB (negOL x1) = (negOL (simplifyOpB x1)) 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpRngTerm2 n A) -> (OpRngTerm2 n A))
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (negOL2 x1) = (negOL2 (simplifyOp x1)) 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Rng A) -> (RngTerm -> A))
    evalB Rn (+L x1 x2) = ((+ Rn) (evalB Rn x1) (evalB Rn x2)) 
    evalB Rn 0L = (0 Rn) 
    evalB Rn (negL x1) = ((neg Rn) (evalB Rn x1)) 
    evalB Rn (*L x1 x2) = ((* Rn) (evalB Rn x1) (evalB Rn x2)) 
    evalCl : {A : Set} -> ((Rng A) -> ((ClRngTerm A) -> A))
    evalCl Rn (sing x1) = x1 
    evalCl Rn (+Cl x1 x2) = ((+ Rn) (evalCl Rn x1) (evalCl Rn x2)) 
    evalCl Rn 0Cl = (0 Rn) 
    evalCl Rn (negCl x1) = ((neg Rn) (evalCl Rn x1)) 
    evalCl Rn (*Cl x1 x2) = ((* Rn) (evalCl Rn x1) (evalCl Rn x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Rng A) -> ((Vec A n) -> ((OpRngTerm n) -> A)))
    evalOpB Rn vars (v x1) = (lookup _ x1 vars) 
    evalOpB Rn vars (+OL x1 x2) = ((+ Rn) (evalOpB Rn vars x1) (evalOpB Rn vars x2)) 
    evalOpB Rn vars 0OL = (0 Rn) 
    evalOpB Rn vars (negOL x1) = ((neg Rn) (evalOpB Rn vars x1)) 
    evalOpB Rn vars (*OL x1 x2) = ((* Rn) (evalOpB Rn vars x1) (evalOpB Rn vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Rng A) -> ((Vec A n) -> ((OpRngTerm2 n A) -> A)))
    evalOp Rn vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Rn vars (sing2 x1) = x1 
    evalOp Rn vars (+OL2 x1 x2) = ((+ Rn) (evalOp Rn vars x1) (evalOp Rn vars x2)) 
    evalOp Rn vars 0OL2 = (0 Rn) 
    evalOp Rn vars (negOL2 x1) = ((neg Rn) (evalOp Rn vars x1)) 
    evalOp Rn vars (*OL2 x1 x2) = ((* Rn) (evalOp Rn vars x1) (evalOp Rn vars x2)) 
    inductionB : {P : (RngTerm -> Set)} -> (((x1 x2 : RngTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((P 0L) -> (((x1 : RngTerm) -> ((P x1) -> (P (negL x1)))) -> (((x1 x2 : RngTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((x : RngTerm) -> (P x))))))
    inductionB {p} p+l p0l pnegl p*l (+L x1 x2) = (p+l _ _ (inductionB {p} p+l p0l pnegl p*l x1) (inductionB {p} p+l p0l pnegl p*l x2)) 
    inductionB {p} p+l p0l pnegl p*l 0L = p0l 
    inductionB {p} p+l p0l pnegl p*l (negL x1) = (pnegl _ (inductionB {p} p+l p0l pnegl p*l x1)) 
    inductionB {p} p+l p0l pnegl p*l (*L x1 x2) = (p*l _ _ (inductionB {p} p+l p0l pnegl p*l x1) (inductionB {p} p+l p0l pnegl p*l x2)) 
    inductionCl : {A : Set} {P : ((ClRngTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClRngTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((P 0Cl) -> (((x1 : (ClRngTerm A)) -> ((P x1) -> (P (negCl x1)))) -> (((x1 x2 : (ClRngTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((x : (ClRngTerm A)) -> (P x)))))))
    inductionCl {_} {p} psing p+cl p0cl pnegcl p*cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p+cl p0cl pnegcl p*cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p+cl p0cl pnegcl p*cl x1) (inductionCl {_} {p} psing p+cl p0cl pnegcl p*cl x2)) 
    inductionCl {_} {p} psing p+cl p0cl pnegcl p*cl 0Cl = p0cl 
    inductionCl {_} {p} psing p+cl p0cl pnegcl p*cl (negCl x1) = (pnegcl _ (inductionCl {_} {p} psing p+cl p0cl pnegcl p*cl x1)) 
    inductionCl {_} {p} psing p+cl p0cl pnegcl p*cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p+cl p0cl pnegcl p*cl x1) (inductionCl {_} {p} psing p+cl p0cl pnegcl p*cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpRngTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpRngTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((P 0OL) -> (((x1 : (OpRngTerm n)) -> ((P x1) -> (P (negOL x1)))) -> (((x1 x2 : (OpRngTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((x : (OpRngTerm n)) -> (P x)))))))
    inductionOpB {_} {p} pv p+ol p0ol pnegol p*ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p+ol p0ol pnegol p*ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p+ol p0ol pnegol p*ol x1) (inductionOpB {_} {p} pv p+ol p0ol pnegol p*ol x2)) 
    inductionOpB {_} {p} pv p+ol p0ol pnegol p*ol 0OL = p0ol 
    inductionOpB {_} {p} pv p+ol p0ol pnegol p*ol (negOL x1) = (pnegol _ (inductionOpB {_} {p} pv p+ol p0ol pnegol p*ol x1)) 
    inductionOpB {_} {p} pv p+ol p0ol pnegol p*ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p+ol p0ol pnegol p*ol x1) (inductionOpB {_} {p} pv p+ol p0ol pnegol p*ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpRngTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpRngTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((P 0OL2) -> (((x1 : (OpRngTerm2 n A)) -> ((P x1) -> (P (negOL2 x1)))) -> (((x1 x2 : (OpRngTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((x : (OpRngTerm2 n A)) -> (P x))))))))
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 (negOL2 x1) = (pnegol2 _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 x2)) 
    +L' : (RngTerm -> (RngTerm -> RngTerm))
    +L' x1 x2 = (+L x1 x2) 
    0L' : RngTerm
    0L'  = 0L 
    negL' : (RngTerm -> RngTerm)
    negL' x1 = (negL x1) 
    *L' : (RngTerm -> (RngTerm -> RngTerm))
    *L' x1 x2 = (*L x1 x2) 
    stageB : (RngTerm -> (Staged RngTerm))
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB 0L = (Now 0L) 
    stageB (negL x1) = (stage1 negL' (codeLift1 negL') (stageB x1)) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    +Cl' : {A : Set} -> ((ClRngTerm A) -> ((ClRngTerm A) -> (ClRngTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    0Cl' : {A : Set} -> (ClRngTerm A)
    0Cl'  = 0Cl 
    negCl' : {A : Set} -> ((ClRngTerm A) -> (ClRngTerm A))
    negCl' x1 = (negCl x1) 
    *Cl' : {A : Set} -> ((ClRngTerm A) -> ((ClRngTerm A) -> (ClRngTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    stageCl : {A : Set} -> ((ClRngTerm A) -> (Staged (ClRngTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (negCl x1) = (stage1 negCl' (codeLift1 negCl') (stageCl x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    +OL' : {n : Nat} -> ((OpRngTerm n) -> ((OpRngTerm n) -> (OpRngTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    0OL' : {n : Nat} -> (OpRngTerm n)
    0OL'  = 0OL 
    negOL' : {n : Nat} -> ((OpRngTerm n) -> (OpRngTerm n))
    negOL' x1 = (negOL x1) 
    *OL' : {n : Nat} -> ((OpRngTerm n) -> ((OpRngTerm n) -> (OpRngTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpRngTerm n) -> (Staged (OpRngTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (negOL x1) = (stage1 negOL' (codeLift1 negOL') (stageOpB x1)) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    +OL2' : {n : Nat} {A : Set} -> ((OpRngTerm2 n A) -> ((OpRngTerm2 n A) -> (OpRngTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    0OL2' : {n : Nat} {A : Set} -> (OpRngTerm2 n A)
    0OL2'  = 0OL2 
    negOL2' : {n : Nat} {A : Set} -> ((OpRngTerm2 n A) -> (OpRngTerm2 n A))
    negOL2' x1 = (negOL2 x1) 
    *OL2' : {n : Nat} {A : Set} -> ((OpRngTerm2 n A) -> ((OpRngTerm2 n A) -> (OpRngTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpRngTerm2 n A) -> (Staged (OpRngTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (negOL2 x1) = (stage1 negOL2' (codeLift1 negOL2') (stageOp x1)) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        0T : (Repr A)
        negT : ((Repr A) -> (Repr A))
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module SemiRng  where
    record SemiRng (A : Set) : Set where
      constructor SemiRngC
      field
        * : (A -> (A -> A))
        + : (A -> (A -> A))
        0 : A
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        leftDistributive_*_+ : {x y z : A} -> (* x (+ y z)) == (+ (* x y) (* x z))
        rightDistributive_*_+ : {x y z : A} -> (* (+ y z) x) == (+ (* y x) (* z x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
        0S : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        0P : (Prod A A)
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        leftDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P xP (+P yP zP)) == (+P (*P xP yP) (*P xP zP))
        rightDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P (+P yP zP) xP) == (+P (*P yP xP) (*P zP xP))
    record Hom {A1 : Set} {A2 : Set} (Se1 : (SemiRng A1)) (Se2 : (SemiRng A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Se1) x1 x2)) == ((* Se2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Se1) x1 x2)) == ((+ Se2) (hom x1) (hom x2))
        pres-0 : (hom (0 Se1)) == (0 Se2)
    record RelInterp {A1 : Set} {A2 : Set} (Se1 : (SemiRng A1)) (Se2 : (SemiRng A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Se1) x1 x2) ((* Se2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Se1) x1 x2) ((+ Se2) y1 y2))))
        interp-0 : (interp (0 Se1) (0 Se2))
    data SemiRngTerm  : Set where
      *L : (SemiRngTerm -> (SemiRngTerm -> SemiRngTerm))
      +L : (SemiRngTerm -> (SemiRngTerm -> SemiRngTerm))
      0L : SemiRngTerm
    data ClSemiRngTerm (A : Set) : Set where
      sing : (A -> (ClSemiRngTerm A))
      *Cl : ((ClSemiRngTerm A) -> ((ClSemiRngTerm A) -> (ClSemiRngTerm A)))
      +Cl : ((ClSemiRngTerm A) -> ((ClSemiRngTerm A) -> (ClSemiRngTerm A)))
      0Cl : (ClSemiRngTerm A)
    data OpSemiRngTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpSemiRngTerm n))
      *OL : ((OpSemiRngTerm n) -> ((OpSemiRngTerm n) -> (OpSemiRngTerm n)))
      +OL : ((OpSemiRngTerm n) -> ((OpSemiRngTerm n) -> (OpSemiRngTerm n)))
      0OL : (OpSemiRngTerm n)
    data OpSemiRngTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpSemiRngTerm2 n A))
      sing2 : (A -> (OpSemiRngTerm2 n A))
      *OL2 : ((OpSemiRngTerm2 n A) -> ((OpSemiRngTerm2 n A) -> (OpSemiRngTerm2 n A)))
      +OL2 : ((OpSemiRngTerm2 n A) -> ((OpSemiRngTerm2 n A) -> (OpSemiRngTerm2 n A)))
      0OL2 : (OpSemiRngTerm2 n A)
    simplifyCl : {A : Set} -> ((ClSemiRngTerm A) -> (ClSemiRngTerm A))
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 0Cl = 0Cl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpSemiRngTerm n) -> (OpSemiRngTerm n))
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 0OL = 0OL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpSemiRngTerm2 n A) -> (OpSemiRngTerm2 n A))
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((SemiRng A) -> (SemiRngTerm -> A))
    evalB Se (*L x1 x2) = ((* Se) (evalB Se x1) (evalB Se x2)) 
    evalB Se (+L x1 x2) = ((+ Se) (evalB Se x1) (evalB Se x2)) 
    evalB Se 0L = (0 Se) 
    evalCl : {A : Set} -> ((SemiRng A) -> ((ClSemiRngTerm A) -> A))
    evalCl Se (sing x1) = x1 
    evalCl Se (*Cl x1 x2) = ((* Se) (evalCl Se x1) (evalCl Se x2)) 
    evalCl Se (+Cl x1 x2) = ((+ Se) (evalCl Se x1) (evalCl Se x2)) 
    evalCl Se 0Cl = (0 Se) 
    evalOpB : {A : Set} {n : Nat} -> ((SemiRng A) -> ((Vec A n) -> ((OpSemiRngTerm n) -> A)))
    evalOpB Se vars (v x1) = (lookup _ x1 vars) 
    evalOpB Se vars (*OL x1 x2) = ((* Se) (evalOpB Se vars x1) (evalOpB Se vars x2)) 
    evalOpB Se vars (+OL x1 x2) = ((+ Se) (evalOpB Se vars x1) (evalOpB Se vars x2)) 
    evalOpB Se vars 0OL = (0 Se) 
    evalOp : {A : Set} {n : Nat} -> ((SemiRng A) -> ((Vec A n) -> ((OpSemiRngTerm2 n A) -> A)))
    evalOp Se vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Se vars (sing2 x1) = x1 
    evalOp Se vars (*OL2 x1 x2) = ((* Se) (evalOp Se vars x1) (evalOp Se vars x2)) 
    evalOp Se vars (+OL2 x1 x2) = ((+ Se) (evalOp Se vars x1) (evalOp Se vars x2)) 
    evalOp Se vars 0OL2 = (0 Se) 
    inductionB : {P : (SemiRngTerm -> Set)} -> (((x1 x2 : SemiRngTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : SemiRngTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((P 0L) -> ((x : SemiRngTerm) -> (P x)))))
    inductionB {p} p*l p+l p0l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p+l p0l x1) (inductionB {p} p*l p+l p0l x2)) 
    inductionB {p} p*l p+l p0l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p+l p0l x1) (inductionB {p} p*l p+l p0l x2)) 
    inductionB {p} p*l p+l p0l 0L = p0l 
    inductionCl : {A : Set} {P : ((ClSemiRngTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClSemiRngTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClSemiRngTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((P 0Cl) -> ((x : (ClSemiRngTerm A)) -> (P x))))))
    inductionCl {_} {p} psing p*cl p+cl p0cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p+cl p0cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p+cl p0cl x1) (inductionCl {_} {p} psing p*cl p+cl p0cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl p0cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p+cl p0cl x1) (inductionCl {_} {p} psing p*cl p+cl p0cl x2)) 
    inductionCl {_} {p} psing p*cl p+cl p0cl 0Cl = p0cl 
    inductionOpB : {n : Nat} {P : ((OpSemiRngTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpSemiRngTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpSemiRngTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((P 0OL) -> ((x : (OpSemiRngTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv p*ol p+ol p0ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p+ol p0ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p+ol p0ol x1) (inductionOpB {_} {p} pv p*ol p+ol p0ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol p0ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p+ol p0ol x1) (inductionOpB {_} {p} pv p*ol p+ol p0ol x2)) 
    inductionOpB {_} {p} pv p*ol p+ol p0ol 0OL = p0ol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpSemiRngTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpSemiRngTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpSemiRngTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((P 0OL2) -> ((x : (OpSemiRngTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p+ol2 p0ol2 0OL2 = p0ol2 
    *L' : (SemiRngTerm -> (SemiRngTerm -> SemiRngTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (SemiRngTerm -> (SemiRngTerm -> SemiRngTerm))
    +L' x1 x2 = (+L x1 x2) 
    0L' : SemiRngTerm
    0L'  = 0L 
    stageB : (SemiRngTerm -> (Staged SemiRngTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB 0L = (Now 0L) 
    *Cl' : {A : Set} -> ((ClSemiRngTerm A) -> ((ClSemiRngTerm A) -> (ClSemiRngTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClSemiRngTerm A) -> ((ClSemiRngTerm A) -> (ClSemiRngTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    0Cl' : {A : Set} -> (ClSemiRngTerm A)
    0Cl'  = 0Cl 
    stageCl : {A : Set} -> ((ClSemiRngTerm A) -> (Staged (ClSemiRngTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl 0Cl = (Now 0Cl) 
    *OL' : {n : Nat} -> ((OpSemiRngTerm n) -> ((OpSemiRngTerm n) -> (OpSemiRngTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpSemiRngTerm n) -> ((OpSemiRngTerm n) -> (OpSemiRngTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    0OL' : {n : Nat} -> (OpSemiRngTerm n)
    0OL'  = 0OL 
    stageOpB : {n : Nat} -> ((OpSemiRngTerm n) -> (Staged (OpSemiRngTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 0OL = (Now 0OL) 
    *OL2' : {n : Nat} {A : Set} -> ((OpSemiRngTerm2 n A) -> ((OpSemiRngTerm2 n A) -> (OpSemiRngTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpSemiRngTerm2 n A) -> ((OpSemiRngTerm2 n A) -> (OpSemiRngTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    0OL2' : {n : Nat} {A : Set} -> (OpSemiRngTerm2 n A)
    0OL2'  = 0OL2 
    stageOp : {n : Nat} {A : Set} -> ((OpSemiRngTerm2 n A) -> (Staged (OpSemiRngTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp 0OL2 = (Now 0OL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        0T : (Repr A)
  module SemiRngWithUnit  where
    record SemiRngWithUnit (A : Set) : Set where
      constructor SemiRngWithUnitC
      field
        * : (A -> (A -> A))
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        1 : A
        lunit_1 : {x : A} -> (* 1 x) == x
        runit_1 : {x : A} -> (* x 1) == x
        + : (A -> (A -> A))
        0 : A
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        leftDistributive_*_+ : {x y z : A} -> (* x (+ y z)) == (+ (* x y) (* x z))
        rightDistributive_*_+ : {x y z : A} -> (* (+ y z) x) == (+ (* y x) (* z x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        *S : (AS -> (AS -> AS))
        1S : AS
        +S : (AS -> (AS -> AS))
        0S : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        1P : (Prod A A)
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        0P : (Prod A A)
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        lunit_1P : {xP : (Prod A A)} -> (*P 1P xP) == xP
        runit_1P : {xP : (Prod A A)} -> (*P xP 1P) == xP
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        leftDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P xP (+P yP zP)) == (+P (*P xP yP) (*P xP zP))
        rightDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P (+P yP zP) xP) == (+P (*P yP xP) (*P zP xP))
    record Hom {A1 : Set} {A2 : Set} (Se1 : (SemiRngWithUnit A1)) (Se2 : (SemiRngWithUnit A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-* : {x1 x2 : A1} -> (hom ((* Se1) x1 x2)) == ((* Se2) (hom x1) (hom x2))
        pres-1 : (hom (1 Se1)) == (1 Se2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Se1) x1 x2)) == ((+ Se2) (hom x1) (hom x2))
        pres-0 : (hom (0 Se1)) == (0 Se2)
    record RelInterp {A1 : Set} {A2 : Set} (Se1 : (SemiRngWithUnit A1)) (Se2 : (SemiRngWithUnit A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Se1) x1 x2) ((* Se2) y1 y2))))
        interp-1 : (interp (1 Se1) (1 Se2))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Se1) x1 x2) ((+ Se2) y1 y2))))
        interp-0 : (interp (0 Se1) (0 Se2))
    data SemiRngWithUnitTerm  : Set where
      *L : (SemiRngWithUnitTerm -> (SemiRngWithUnitTerm -> SemiRngWithUnitTerm))
      1L : SemiRngWithUnitTerm
      +L : (SemiRngWithUnitTerm -> (SemiRngWithUnitTerm -> SemiRngWithUnitTerm))
      0L : SemiRngWithUnitTerm
    data ClSemiRngWithUnitTerm (A : Set) : Set where
      sing : (A -> (ClSemiRngWithUnitTerm A))
      *Cl : ((ClSemiRngWithUnitTerm A) -> ((ClSemiRngWithUnitTerm A) -> (ClSemiRngWithUnitTerm A)))
      1Cl : (ClSemiRngWithUnitTerm A)
      +Cl : ((ClSemiRngWithUnitTerm A) -> ((ClSemiRngWithUnitTerm A) -> (ClSemiRngWithUnitTerm A)))
      0Cl : (ClSemiRngWithUnitTerm A)
    data OpSemiRngWithUnitTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpSemiRngWithUnitTerm n))
      *OL : ((OpSemiRngWithUnitTerm n) -> ((OpSemiRngWithUnitTerm n) -> (OpSemiRngWithUnitTerm n)))
      1OL : (OpSemiRngWithUnitTerm n)
      +OL : ((OpSemiRngWithUnitTerm n) -> ((OpSemiRngWithUnitTerm n) -> (OpSemiRngWithUnitTerm n)))
      0OL : (OpSemiRngWithUnitTerm n)
    data OpSemiRngWithUnitTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpSemiRngWithUnitTerm2 n A))
      sing2 : (A -> (OpSemiRngWithUnitTerm2 n A))
      *OL2 : ((OpSemiRngWithUnitTerm2 n A) -> ((OpSemiRngWithUnitTerm2 n A) -> (OpSemiRngWithUnitTerm2 n A)))
      1OL2 : (OpSemiRngWithUnitTerm2 n A)
      +OL2 : ((OpSemiRngWithUnitTerm2 n A) -> ((OpSemiRngWithUnitTerm2 n A) -> (OpSemiRngWithUnitTerm2 n A)))
      0OL2 : (OpSemiRngWithUnitTerm2 n A)
    simplifyCl : {A : Set} -> ((ClSemiRngWithUnitTerm A) -> (ClSemiRngWithUnitTerm A))
    simplifyCl (*Cl 1Cl x) = x 
    simplifyCl (*Cl x 1Cl) = x 
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 0Cl = 0Cl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpSemiRngWithUnitTerm n) -> (OpSemiRngWithUnitTerm n))
    simplifyOpB (*OL 1OL x) = x 
    simplifyOpB (*OL x 1OL) = x 
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 0OL = 0OL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpSemiRngWithUnitTerm2 n A) -> (OpSemiRngWithUnitTerm2 n A))
    simplifyOp (*OL2 1OL2 x) = x 
    simplifyOp (*OL2 x 1OL2) = x 
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((SemiRngWithUnit A) -> (SemiRngWithUnitTerm -> A))
    evalB Se (*L x1 x2) = ((* Se) (evalB Se x1) (evalB Se x2)) 
    evalB Se 1L = (1 Se) 
    evalB Se (+L x1 x2) = ((+ Se) (evalB Se x1) (evalB Se x2)) 
    evalB Se 0L = (0 Se) 
    evalCl : {A : Set} -> ((SemiRngWithUnit A) -> ((ClSemiRngWithUnitTerm A) -> A))
    evalCl Se (sing x1) = x1 
    evalCl Se (*Cl x1 x2) = ((* Se) (evalCl Se x1) (evalCl Se x2)) 
    evalCl Se 1Cl = (1 Se) 
    evalCl Se (+Cl x1 x2) = ((+ Se) (evalCl Se x1) (evalCl Se x2)) 
    evalCl Se 0Cl = (0 Se) 
    evalOpB : {A : Set} {n : Nat} -> ((SemiRngWithUnit A) -> ((Vec A n) -> ((OpSemiRngWithUnitTerm n) -> A)))
    evalOpB Se vars (v x1) = (lookup _ x1 vars) 
    evalOpB Se vars (*OL x1 x2) = ((* Se) (evalOpB Se vars x1) (evalOpB Se vars x2)) 
    evalOpB Se vars 1OL = (1 Se) 
    evalOpB Se vars (+OL x1 x2) = ((+ Se) (evalOpB Se vars x1) (evalOpB Se vars x2)) 
    evalOpB Se vars 0OL = (0 Se) 
    evalOp : {A : Set} {n : Nat} -> ((SemiRngWithUnit A) -> ((Vec A n) -> ((OpSemiRngWithUnitTerm2 n A) -> A)))
    evalOp Se vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Se vars (sing2 x1) = x1 
    evalOp Se vars (*OL2 x1 x2) = ((* Se) (evalOp Se vars x1) (evalOp Se vars x2)) 
    evalOp Se vars 1OL2 = (1 Se) 
    evalOp Se vars (+OL2 x1 x2) = ((+ Se) (evalOp Se vars x1) (evalOp Se vars x2)) 
    evalOp Se vars 0OL2 = (0 Se) 
    inductionB : {P : (SemiRngWithUnitTerm -> Set)} -> (((x1 x2 : SemiRngWithUnitTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((P 1L) -> (((x1 x2 : SemiRngWithUnitTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((P 0L) -> ((x : SemiRngWithUnitTerm) -> (P x))))))
    inductionB {p} p*l p1l p+l p0l (*L x1 x2) = (p*l _ _ (inductionB {p} p*l p1l p+l p0l x1) (inductionB {p} p*l p1l p+l p0l x2)) 
    inductionB {p} p*l p1l p+l p0l 1L = p1l 
    inductionB {p} p*l p1l p+l p0l (+L x1 x2) = (p+l _ _ (inductionB {p} p*l p1l p+l p0l x1) (inductionB {p} p*l p1l p+l p0l x2)) 
    inductionB {p} p*l p1l p+l p0l 0L = p0l 
    inductionCl : {A : Set} {P : ((ClSemiRngWithUnitTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClSemiRngWithUnitTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((P 1Cl) -> (((x1 x2 : (ClSemiRngWithUnitTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((P 0Cl) -> ((x : (ClSemiRngWithUnitTerm A)) -> (P x)))))))
    inductionCl {_} {p} psing p*cl p1cl p+cl p0cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p*cl p1cl p+cl p0cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p*cl p1cl p+cl p0cl x1) (inductionCl {_} {p} psing p*cl p1cl p+cl p0cl x2)) 
    inductionCl {_} {p} psing p*cl p1cl p+cl p0cl 1Cl = p1cl 
    inductionCl {_} {p} psing p*cl p1cl p+cl p0cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p*cl p1cl p+cl p0cl x1) (inductionCl {_} {p} psing p*cl p1cl p+cl p0cl x2)) 
    inductionCl {_} {p} psing p*cl p1cl p+cl p0cl 0Cl = p0cl 
    inductionOpB : {n : Nat} {P : ((OpSemiRngWithUnitTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpSemiRngWithUnitTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((P 1OL) -> (((x1 x2 : (OpSemiRngWithUnitTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((P 0OL) -> ((x : (OpSemiRngWithUnitTerm n)) -> (P x)))))))
    inductionOpB {_} {p} pv p*ol p1ol p+ol p0ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p*ol p1ol p+ol p0ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p*ol p1ol p+ol p0ol x1) (inductionOpB {_} {p} pv p*ol p1ol p+ol p0ol x2)) 
    inductionOpB {_} {p} pv p*ol p1ol p+ol p0ol 1OL = p1ol 
    inductionOpB {_} {p} pv p*ol p1ol p+ol p0ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p*ol p1ol p+ol p0ol x1) (inductionOpB {_} {p} pv p*ol p1ol p+ol p0ol x2)) 
    inductionOpB {_} {p} pv p*ol p1ol p+ol p0ol 0OL = p0ol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpSemiRngWithUnitTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpSemiRngWithUnitTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((P 1OL2) -> (((x1 x2 : (OpSemiRngWithUnitTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((P 0OL2) -> ((x : (OpSemiRngWithUnitTerm2 n A)) -> (P x))))))))
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 1OL2 = p1ol2 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 0OL2 = p0ol2 
    *L' : (SemiRngWithUnitTerm -> (SemiRngWithUnitTerm -> SemiRngWithUnitTerm))
    *L' x1 x2 = (*L x1 x2) 
    1L' : SemiRngWithUnitTerm
    1L'  = 1L 
    +L' : (SemiRngWithUnitTerm -> (SemiRngWithUnitTerm -> SemiRngWithUnitTerm))
    +L' x1 x2 = (+L x1 x2) 
    0L' : SemiRngWithUnitTerm
    0L'  = 0L 
    stageB : (SemiRngWithUnitTerm -> (Staged SemiRngWithUnitTerm))
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB 1L = (Now 1L) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB 0L = (Now 0L) 
    *Cl' : {A : Set} -> ((ClSemiRngWithUnitTerm A) -> ((ClSemiRngWithUnitTerm A) -> (ClSemiRngWithUnitTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    1Cl' : {A : Set} -> (ClSemiRngWithUnitTerm A)
    1Cl'  = 1Cl 
    +Cl' : {A : Set} -> ((ClSemiRngWithUnitTerm A) -> ((ClSemiRngWithUnitTerm A) -> (ClSemiRngWithUnitTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    0Cl' : {A : Set} -> (ClSemiRngWithUnitTerm A)
    0Cl'  = 0Cl 
    stageCl : {A : Set} -> ((ClSemiRngWithUnitTerm A) -> (Staged (ClSemiRngWithUnitTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl 1Cl = (Now 1Cl) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl 0Cl = (Now 0Cl) 
    *OL' : {n : Nat} -> ((OpSemiRngWithUnitTerm n) -> ((OpSemiRngWithUnitTerm n) -> (OpSemiRngWithUnitTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    1OL' : {n : Nat} -> (OpSemiRngWithUnitTerm n)
    1OL'  = 1OL 
    +OL' : {n : Nat} -> ((OpSemiRngWithUnitTerm n) -> ((OpSemiRngWithUnitTerm n) -> (OpSemiRngWithUnitTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    0OL' : {n : Nat} -> (OpSemiRngWithUnitTerm n)
    0OL'  = 0OL 
    stageOpB : {n : Nat} -> ((OpSemiRngWithUnitTerm n) -> (Staged (OpSemiRngWithUnitTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 1OL = (Now 1OL) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 0OL = (Now 0OL) 
    *OL2' : {n : Nat} {A : Set} -> ((OpSemiRngWithUnitTerm2 n A) -> ((OpSemiRngWithUnitTerm2 n A) -> (OpSemiRngWithUnitTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    1OL2' : {n : Nat} {A : Set} -> (OpSemiRngWithUnitTerm2 n A)
    1OL2'  = 1OL2 
    +OL2' : {n : Nat} {A : Set} -> ((OpSemiRngWithUnitTerm2 n A) -> ((OpSemiRngWithUnitTerm2 n A) -> (OpSemiRngWithUnitTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    0OL2' : {n : Nat} {A : Set} -> (OpSemiRngWithUnitTerm2 n A)
    0OL2'  = 0OL2 
    stageOp : {n : Nat} {A : Set} -> ((OpSemiRngWithUnitTerm2 n A) -> (Staged (OpSemiRngWithUnitTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp 1OL2 = (Now 1OL2) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp 0OL2 = (Now 0OL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        1T : (Repr A)
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        0T : (Repr A)
  module Semigroup  where
    record Semigroup (A : Set) : Set where
      constructor SemigroupC
      field
        op : (A -> (A -> A))
        associative_op : {x y z : A} -> (op (op x y) z) == (op x (op y z))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        associative_opP : {xP yP zP : (Prod A A)} -> (opP (opP xP yP) zP) == (opP xP (opP yP zP))
    record Hom {A1 : Set} {A2 : Set} (Se1 : (Semigroup A1)) (Se2 : (Semigroup A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Se1) x1 x2)) == ((op Se2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Se1 : (Semigroup A1)) (Se2 : (Semigroup A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Se1) x1 x2) ((op Se2) y1 y2))))
    data SemigroupTerm  : Set where
      opL : (SemigroupTerm -> (SemigroupTerm -> SemigroupTerm))
    data ClSemigroupTerm (A : Set) : Set where
      sing : (A -> (ClSemigroupTerm A))
      opCl : ((ClSemigroupTerm A) -> ((ClSemigroupTerm A) -> (ClSemigroupTerm A)))
    data OpSemigroupTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpSemigroupTerm n))
      opOL : ((OpSemigroupTerm n) -> ((OpSemigroupTerm n) -> (OpSemigroupTerm n)))
    data OpSemigroupTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpSemigroupTerm2 n A))
      sing2 : (A -> (OpSemigroupTerm2 n A))
      opOL2 : ((OpSemigroupTerm2 n A) -> ((OpSemigroupTerm2 n A) -> (OpSemigroupTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClSemigroupTerm A) -> (ClSemigroupTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpSemigroupTerm n) -> (OpSemigroupTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpSemigroupTerm2 n A) -> (OpSemigroupTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Semigroup A) -> (SemigroupTerm -> A))
    evalB Se (opL x1 x2) = ((op Se) (evalB Se x1) (evalB Se x2)) 
    evalCl : {A : Set} -> ((Semigroup A) -> ((ClSemigroupTerm A) -> A))
    evalCl Se (sing x1) = x1 
    evalCl Se (opCl x1 x2) = ((op Se) (evalCl Se x1) (evalCl Se x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Semigroup A) -> ((Vec A n) -> ((OpSemigroupTerm n) -> A)))
    evalOpB Se vars (v x1) = (lookup _ x1 vars) 
    evalOpB Se vars (opOL x1 x2) = ((op Se) (evalOpB Se vars x1) (evalOpB Se vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Semigroup A) -> ((Vec A n) -> ((OpSemigroupTerm2 n A) -> A)))
    evalOp Se vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Se vars (sing2 x1) = x1 
    evalOp Se vars (opOL2 x1 x2) = ((op Se) (evalOp Se vars x1) (evalOp Se vars x2)) 
    inductionB : {P : (SemigroupTerm -> Set)} -> (((x1 x2 : SemigroupTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : SemigroupTerm) -> (P x)))
    inductionB {p} popl (opL x1 x2) = (popl _ _ (inductionB {p} popl x1) (inductionB {p} popl x2)) 
    inductionCl : {A : Set} {P : ((ClSemigroupTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClSemigroupTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClSemigroupTerm A)) -> (P x))))
    inductionCl {_} {p} psing popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl x1) (inductionCl {_} {p} psing popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpSemigroupTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpSemigroupTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpSemigroupTerm n)) -> (P x))))
    inductionOpB {_} {p} pv popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol x1) (inductionOpB {_} {p} pv popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpSemigroupTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpSemigroupTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpSemigroupTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 x2)) 
    opL' : (SemigroupTerm -> (SemigroupTerm -> SemigroupTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (SemigroupTerm -> (Staged SemigroupTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClSemigroupTerm A) -> ((ClSemigroupTerm A) -> (ClSemigroupTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClSemigroupTerm A) -> (Staged (ClSemigroupTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpSemigroupTerm n) -> ((OpSemigroupTerm n) -> (OpSemigroupTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpSemigroupTerm n) -> (Staged (OpSemigroupTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpSemigroupTerm2 n A) -> ((OpSemigroupTerm2 n A) -> (OpSemigroupTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpSemigroupTerm2 n A) -> (Staged (OpSemigroupTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module Semiring  where
    record Semiring (A : Set) : Set where
      constructor SemiringC
      field
        0 : A
        + : (A -> (A -> A))
        * : (A -> (A -> A))
        associative_* : {x y z : A} -> (* (* x y) z) == (* x (* y z))
        1 : A
        lunit_1 : {x : A} -> (* 1 x) == x
        runit_1 : {x : A} -> (* x 1) == x
        lunit_0 : {x : A} -> (+ 0 x) == x
        runit_0 : {x : A} -> (+ x 0) == x
        associative_+ : {x y z : A} -> (+ (+ x y) z) == (+ x (+ y z))
        commutative_+ : {x y : A} -> (+ x y) == (+ y x)
        leftDistributive_*_+ : {x y z : A} -> (* x (+ y z)) == (+ (* x y) (* x z))
        rightDistributive_*_+ : {x y z : A} -> (* (+ y z) x) == (+ (* y x) (* z x))
        leftZero_op_0 : {x : A} -> (* 0 x) == 0
        rightZero_op_0 : {x : A} -> (* x 0) == 0
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        0S : AS
        +S : (AS -> (AS -> AS))
        *S : (AS -> (AS -> AS))
        1S : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        0P : (Prod A A)
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        1P : (Prod A A)
        associative_*P : {xP yP zP : (Prod A A)} -> (*P (*P xP yP) zP) == (*P xP (*P yP zP))
        lunit_1P : {xP : (Prod A A)} -> (*P 1P xP) == xP
        runit_1P : {xP : (Prod A A)} -> (*P xP 1P) == xP
        lunit_0P : {xP : (Prod A A)} -> (+P 0P xP) == xP
        runit_0P : {xP : (Prod A A)} -> (+P xP 0P) == xP
        associative_+P : {xP yP zP : (Prod A A)} -> (+P (+P xP yP) zP) == (+P xP (+P yP zP))
        commutative_+P : {xP yP : (Prod A A)} -> (+P xP yP) == (+P yP xP)
        leftDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P xP (+P yP zP)) == (+P (*P xP yP) (*P xP zP))
        rightDistributive_*_+P : {xP yP zP : (Prod A A)} -> (*P (+P yP zP) xP) == (+P (*P yP xP) (*P zP xP))
        leftZero_op_0P : {xP : (Prod A A)} -> (*P 0P xP) == 0P
        rightZero_op_0P : {xP : (Prod A A)} -> (*P xP 0P) == 0P
    record Hom {A1 : Set} {A2 : Set} (Se1 : (Semiring A1)) (Se2 : (Semiring A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-0 : (hom (0 Se1)) == (0 Se2)
        pres-+ : {x1 x2 : A1} -> (hom ((+ Se1) x1 x2)) == ((+ Se2) (hom x1) (hom x2))
        pres-* : {x1 x2 : A1} -> (hom ((* Se1) x1 x2)) == ((* Se2) (hom x1) (hom x2))
        pres-1 : (hom (1 Se1)) == (1 Se2)
    record RelInterp {A1 : Set} {A2 : Set} (Se1 : (Semiring A1)) (Se2 : (Semiring A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-0 : (interp (0 Se1) (0 Se2))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Se1) x1 x2) ((+ Se2) y1 y2))))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Se1) x1 x2) ((* Se2) y1 y2))))
        interp-1 : (interp (1 Se1) (1 Se2))
    data SemiringTerm  : Set where
      0L : SemiringTerm
      +L : (SemiringTerm -> (SemiringTerm -> SemiringTerm))
      *L : (SemiringTerm -> (SemiringTerm -> SemiringTerm))
      1L : SemiringTerm
    data ClSemiringTerm (A : Set) : Set where
      sing : (A -> (ClSemiringTerm A))
      0Cl : (ClSemiringTerm A)
      +Cl : ((ClSemiringTerm A) -> ((ClSemiringTerm A) -> (ClSemiringTerm A)))
      *Cl : ((ClSemiringTerm A) -> ((ClSemiringTerm A) -> (ClSemiringTerm A)))
      1Cl : (ClSemiringTerm A)
    data OpSemiringTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpSemiringTerm n))
      0OL : (OpSemiringTerm n)
      +OL : ((OpSemiringTerm n) -> ((OpSemiringTerm n) -> (OpSemiringTerm n)))
      *OL : ((OpSemiringTerm n) -> ((OpSemiringTerm n) -> (OpSemiringTerm n)))
      1OL : (OpSemiringTerm n)
    data OpSemiringTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpSemiringTerm2 n A))
      sing2 : (A -> (OpSemiringTerm2 n A))
      0OL2 : (OpSemiringTerm2 n A)
      +OL2 : ((OpSemiringTerm2 n A) -> ((OpSemiringTerm2 n A) -> (OpSemiringTerm2 n A)))
      *OL2 : ((OpSemiringTerm2 n A) -> ((OpSemiringTerm2 n A) -> (OpSemiringTerm2 n A)))
      1OL2 : (OpSemiringTerm2 n A)
    simplifyCl : {A : Set} -> ((ClSemiringTerm A) -> (ClSemiringTerm A))
    simplifyCl (*Cl 1Cl x) = x 
    simplifyCl (*Cl x 1Cl) = x 
    simplifyCl (+Cl 0Cl x) = x 
    simplifyCl (+Cl x 0Cl) = x 
    simplifyCl 0Cl = 0Cl 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl 1Cl = 1Cl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpSemiringTerm n) -> (OpSemiringTerm n))
    simplifyOpB (*OL 1OL x) = x 
    simplifyOpB (*OL x 1OL) = x 
    simplifyOpB (+OL 0OL x) = x 
    simplifyOpB (+OL x 0OL) = x 
    simplifyOpB 0OL = 0OL 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB 1OL = 1OL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpSemiringTerm2 n A) -> (OpSemiringTerm2 n A))
    simplifyOp (*OL2 1OL2 x) = x 
    simplifyOp (*OL2 x 1OL2) = x 
    simplifyOp (+OL2 0OL2 x) = x 
    simplifyOp (+OL2 x 0OL2) = x 
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp 1OL2 = 1OL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Semiring A) -> (SemiringTerm -> A))
    evalB Se 0L = (0 Se) 
    evalB Se (+L x1 x2) = ((+ Se) (evalB Se x1) (evalB Se x2)) 
    evalB Se (*L x1 x2) = ((* Se) (evalB Se x1) (evalB Se x2)) 
    evalB Se 1L = (1 Se) 
    evalCl : {A : Set} -> ((Semiring A) -> ((ClSemiringTerm A) -> A))
    evalCl Se (sing x1) = x1 
    evalCl Se 0Cl = (0 Se) 
    evalCl Se (+Cl x1 x2) = ((+ Se) (evalCl Se x1) (evalCl Se x2)) 
    evalCl Se (*Cl x1 x2) = ((* Se) (evalCl Se x1) (evalCl Se x2)) 
    evalCl Se 1Cl = (1 Se) 
    evalOpB : {A : Set} {n : Nat} -> ((Semiring A) -> ((Vec A n) -> ((OpSemiringTerm n) -> A)))
    evalOpB Se vars (v x1) = (lookup _ x1 vars) 
    evalOpB Se vars 0OL = (0 Se) 
    evalOpB Se vars (+OL x1 x2) = ((+ Se) (evalOpB Se vars x1) (evalOpB Se vars x2)) 
    evalOpB Se vars (*OL x1 x2) = ((* Se) (evalOpB Se vars x1) (evalOpB Se vars x2)) 
    evalOpB Se vars 1OL = (1 Se) 
    evalOp : {A : Set} {n : Nat} -> ((Semiring A) -> ((Vec A n) -> ((OpSemiringTerm2 n A) -> A)))
    evalOp Se vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Se vars (sing2 x1) = x1 
    evalOp Se vars 0OL2 = (0 Se) 
    evalOp Se vars (+OL2 x1 x2) = ((+ Se) (evalOp Se vars x1) (evalOp Se vars x2)) 
    evalOp Se vars (*OL2 x1 x2) = ((* Se) (evalOp Se vars x1) (evalOp Se vars x2)) 
    evalOp Se vars 1OL2 = (1 Se) 
    inductionB : {P : (SemiringTerm -> Set)} -> ((P 0L) -> (((x1 x2 : SemiringTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> (((x1 x2 : SemiringTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((P 1L) -> ((x : SemiringTerm) -> (P x))))))
    inductionB {p} p0l p+l p*l p1l 0L = p0l 
    inductionB {p} p0l p+l p*l p1l (+L x1 x2) = (p+l _ _ (inductionB {p} p0l p+l p*l p1l x1) (inductionB {p} p0l p+l p*l p1l x2)) 
    inductionB {p} p0l p+l p*l p1l (*L x1 x2) = (p*l _ _ (inductionB {p} p0l p+l p*l p1l x1) (inductionB {p} p0l p+l p*l p1l x2)) 
    inductionB {p} p0l p+l p*l p1l 1L = p1l 
    inductionCl : {A : Set} {P : ((ClSemiringTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 0Cl) -> (((x1 x2 : (ClSemiringTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> (((x1 x2 : (ClSemiringTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((P 1Cl) -> ((x : (ClSemiringTerm A)) -> (P x)))))))
    inductionCl {_} {p} psing p0cl p+cl p*cl p1cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p0cl p+cl p*cl p1cl 0Cl = p0cl 
    inductionCl {_} {p} psing p0cl p+cl p*cl p1cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p0cl p+cl p*cl p1cl x1) (inductionCl {_} {p} psing p0cl p+cl p*cl p1cl x2)) 
    inductionCl {_} {p} psing p0cl p+cl p*cl p1cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p0cl p+cl p*cl p1cl x1) (inductionCl {_} {p} psing p0cl p+cl p*cl p1cl x2)) 
    inductionCl {_} {p} psing p0cl p+cl p*cl p1cl 1Cl = p1cl 
    inductionOpB : {n : Nat} {P : ((OpSemiringTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 0OL) -> (((x1 x2 : (OpSemiringTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> (((x1 x2 : (OpSemiringTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((P 1OL) -> ((x : (OpSemiringTerm n)) -> (P x)))))))
    inductionOpB {_} {p} pv p0ol p+ol p*ol p1ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p0ol p+ol p*ol p1ol 0OL = p0ol 
    inductionOpB {_} {p} pv p0ol p+ol p*ol p1ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p0ol p+ol p*ol p1ol x1) (inductionOpB {_} {p} pv p0ol p+ol p*ol p1ol x2)) 
    inductionOpB {_} {p} pv p0ol p+ol p*ol p1ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p0ol p+ol p*ol p1ol x1) (inductionOpB {_} {p} pv p0ol p+ol p*ol p1ol x2)) 
    inductionOpB {_} {p} pv p0ol p+ol p*ol p1ol 1OL = p1ol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpSemiringTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 0OL2) -> (((x1 x2 : (OpSemiringTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> (((x1 x2 : (OpSemiringTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((P 1OL2) -> ((x : (OpSemiringTerm2 n A)) -> (P x))))))))
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 p1ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 p1ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 p1ol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 p1ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 p1ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 p1ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 p1ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 p1ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 p1ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p+ol2 p*ol2 p1ol2 1OL2 = p1ol2 
    0L' : SemiringTerm
    0L'  = 0L 
    +L' : (SemiringTerm -> (SemiringTerm -> SemiringTerm))
    +L' x1 x2 = (+L x1 x2) 
    *L' : (SemiringTerm -> (SemiringTerm -> SemiringTerm))
    *L' x1 x2 = (*L x1 x2) 
    1L' : SemiringTerm
    1L'  = 1L 
    stageB : (SemiringTerm -> (Staged SemiringTerm))
    stageB 0L = (Now 0L) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB 1L = (Now 1L) 
    0Cl' : {A : Set} -> (ClSemiringTerm A)
    0Cl'  = 0Cl 
    +Cl' : {A : Set} -> ((ClSemiringTerm A) -> ((ClSemiringTerm A) -> (ClSemiringTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    *Cl' : {A : Set} -> ((ClSemiringTerm A) -> ((ClSemiringTerm A) -> (ClSemiringTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    1Cl' : {A : Set} -> (ClSemiringTerm A)
    1Cl'  = 1Cl 
    stageCl : {A : Set} -> ((ClSemiringTerm A) -> (Staged (ClSemiringTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl 1Cl = (Now 1Cl) 
    0OL' : {n : Nat} -> (OpSemiringTerm n)
    0OL'  = 0OL 
    +OL' : {n : Nat} -> ((OpSemiringTerm n) -> ((OpSemiringTerm n) -> (OpSemiringTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    *OL' : {n : Nat} -> ((OpSemiringTerm n) -> ((OpSemiringTerm n) -> (OpSemiringTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    1OL' : {n : Nat} -> (OpSemiringTerm n)
    1OL'  = 1OL 
    stageOpB : {n : Nat} -> ((OpSemiringTerm n) -> (Staged (OpSemiringTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB 1OL = (Now 1OL) 
    0OL2' : {n : Nat} {A : Set} -> (OpSemiringTerm2 n A)
    0OL2'  = 0OL2 
    +OL2' : {n : Nat} {A : Set} -> ((OpSemiringTerm2 n A) -> ((OpSemiringTerm2 n A) -> (OpSemiringTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    *OL2' : {n : Nat} {A : Set} -> ((OpSemiringTerm2 n A) -> ((OpSemiringTerm2 n A) -> (OpSemiringTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    1OL2' : {n : Nat} {A : Set} -> (OpSemiringTerm2 n A)
    1OL2'  = 1OL2 
    stageOp : {n : Nat} {A : Set} -> ((OpSemiringTerm2 n A) -> (Staged (OpSemiringTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp 1OL2 = (Now 1OL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        0T : (Repr A)
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        1T : (Repr A)
  module Shelf  where
    record Shelf (A : Set) : Set where
      constructor ShelfC
      field
        |> : (A -> (A -> A))
        <| : (A -> (A -> A))
        leftDistributive : {x y z : A} -> (|> x (|> y z)) == (|> (|> x y) (|> x z))
        rightDistributive : {x y z : A} -> (<| (<| y z) x) == (<| (<| y x) (<| z x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        |>S : (AS -> (AS -> AS))
        <|S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        |>P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        <|P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftDistributiveP : {xP yP zP : (Prod A A)} -> (|>P xP (|>P yP zP)) == (|>P (|>P xP yP) (|>P xP zP))
        rightDistributiveP : {xP yP zP : (Prod A A)} -> (<|P (<|P yP zP) xP) == (<|P (<|P yP xP) (<|P zP xP))
    record Hom {A1 : Set} {A2 : Set} (Sh1 : (Shelf A1)) (Sh2 : (Shelf A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-|> : {x1 x2 : A1} -> (hom ((|> Sh1) x1 x2)) == ((|> Sh2) (hom x1) (hom x2))
        pres-<| : {x1 x2 : A1} -> (hom ((<| Sh1) x1 x2)) == ((<| Sh2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Sh1 : (Shelf A1)) (Sh2 : (Shelf A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-|> : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((|> Sh1) x1 x2) ((|> Sh2) y1 y2))))
        interp-<| : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((<| Sh1) x1 x2) ((<| Sh2) y1 y2))))
    data ShelfTerm  : Set where
      |>L : (ShelfTerm -> (ShelfTerm -> ShelfTerm))
      <|L : (ShelfTerm -> (ShelfTerm -> ShelfTerm))
    data ClShelfTerm (A : Set) : Set where
      sing : (A -> (ClShelfTerm A))
      |>Cl : ((ClShelfTerm A) -> ((ClShelfTerm A) -> (ClShelfTerm A)))
      <|Cl : ((ClShelfTerm A) -> ((ClShelfTerm A) -> (ClShelfTerm A)))
    data OpShelfTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpShelfTerm n))
      |>OL : ((OpShelfTerm n) -> ((OpShelfTerm n) -> (OpShelfTerm n)))
      <|OL : ((OpShelfTerm n) -> ((OpShelfTerm n) -> (OpShelfTerm n)))
    data OpShelfTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpShelfTerm2 n A))
      sing2 : (A -> (OpShelfTerm2 n A))
      |>OL2 : ((OpShelfTerm2 n A) -> ((OpShelfTerm2 n A) -> (OpShelfTerm2 n A)))
      <|OL2 : ((OpShelfTerm2 n A) -> ((OpShelfTerm2 n A) -> (OpShelfTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClShelfTerm A) -> (ClShelfTerm A))
    simplifyCl (|>Cl x1 x2) = (|>Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (<|Cl x1 x2) = (<|Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpShelfTerm n) -> (OpShelfTerm n))
    simplifyOpB (|>OL x1 x2) = (|>OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (<|OL x1 x2) = (<|OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpShelfTerm2 n A) -> (OpShelfTerm2 n A))
    simplifyOp (|>OL2 x1 x2) = (|>OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (<|OL2 x1 x2) = (<|OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Shelf A) -> (ShelfTerm -> A))
    evalB Sh (|>L x1 x2) = ((|> Sh) (evalB Sh x1) (evalB Sh x2)) 
    evalB Sh (<|L x1 x2) = ((<| Sh) (evalB Sh x1) (evalB Sh x2)) 
    evalCl : {A : Set} -> ((Shelf A) -> ((ClShelfTerm A) -> A))
    evalCl Sh (sing x1) = x1 
    evalCl Sh (|>Cl x1 x2) = ((|> Sh) (evalCl Sh x1) (evalCl Sh x2)) 
    evalCl Sh (<|Cl x1 x2) = ((<| Sh) (evalCl Sh x1) (evalCl Sh x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Shelf A) -> ((Vec A n) -> ((OpShelfTerm n) -> A)))
    evalOpB Sh vars (v x1) = (lookup _ x1 vars) 
    evalOpB Sh vars (|>OL x1 x2) = ((|> Sh) (evalOpB Sh vars x1) (evalOpB Sh vars x2)) 
    evalOpB Sh vars (<|OL x1 x2) = ((<| Sh) (evalOpB Sh vars x1) (evalOpB Sh vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Shelf A) -> ((Vec A n) -> ((OpShelfTerm2 n A) -> A)))
    evalOp Sh vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Sh vars (sing2 x1) = x1 
    evalOp Sh vars (|>OL2 x1 x2) = ((|> Sh) (evalOp Sh vars x1) (evalOp Sh vars x2)) 
    evalOp Sh vars (<|OL2 x1 x2) = ((<| Sh) (evalOp Sh vars x1) (evalOp Sh vars x2)) 
    inductionB : {P : (ShelfTerm -> Set)} -> (((x1 x2 : ShelfTerm) -> ((P x1) -> ((P x2) -> (P (|>L x1 x2))))) -> (((x1 x2 : ShelfTerm) -> ((P x1) -> ((P x2) -> (P (<|L x1 x2))))) -> ((x : ShelfTerm) -> (P x))))
    inductionB {p} p|>l p<|l (|>L x1 x2) = (p|>l _ _ (inductionB {p} p|>l p<|l x1) (inductionB {p} p|>l p<|l x2)) 
    inductionB {p} p|>l p<|l (<|L x1 x2) = (p<|l _ _ (inductionB {p} p|>l p<|l x1) (inductionB {p} p|>l p<|l x2)) 
    inductionCl : {A : Set} {P : ((ClShelfTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClShelfTerm A)) -> ((P x1) -> ((P x2) -> (P (|>Cl x1 x2))))) -> (((x1 x2 : (ClShelfTerm A)) -> ((P x1) -> ((P x2) -> (P (<|Cl x1 x2))))) -> ((x : (ClShelfTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p|>cl p<|cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p|>cl p<|cl (|>Cl x1 x2) = (p|>cl _ _ (inductionCl {_} {p} psing p|>cl p<|cl x1) (inductionCl {_} {p} psing p|>cl p<|cl x2)) 
    inductionCl {_} {p} psing p|>cl p<|cl (<|Cl x1 x2) = (p<|cl _ _ (inductionCl {_} {p} psing p|>cl p<|cl x1) (inductionCl {_} {p} psing p|>cl p<|cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpShelfTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpShelfTerm n)) -> ((P x1) -> ((P x2) -> (P (|>OL x1 x2))))) -> (((x1 x2 : (OpShelfTerm n)) -> ((P x1) -> ((P x2) -> (P (<|OL x1 x2))))) -> ((x : (OpShelfTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p|>ol p<|ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p|>ol p<|ol (|>OL x1 x2) = (p|>ol _ _ (inductionOpB {_} {p} pv p|>ol p<|ol x1) (inductionOpB {_} {p} pv p|>ol p<|ol x2)) 
    inductionOpB {_} {p} pv p|>ol p<|ol (<|OL x1 x2) = (p<|ol _ _ (inductionOpB {_} {p} pv p|>ol p<|ol x1) (inductionOpB {_} {p} pv p|>ol p<|ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpShelfTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpShelfTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (|>OL2 x1 x2))))) -> (((x1 x2 : (OpShelfTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (<|OL2 x1 x2))))) -> ((x : (OpShelfTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (|>OL2 x1 x2) = (p|>ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (<|OL2 x1 x2) = (p<|ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x2)) 
    |>L' : (ShelfTerm -> (ShelfTerm -> ShelfTerm))
    |>L' x1 x2 = (|>L x1 x2) 
    <|L' : (ShelfTerm -> (ShelfTerm -> ShelfTerm))
    <|L' x1 x2 = (<|L x1 x2) 
    stageB : (ShelfTerm -> (Staged ShelfTerm))
    stageB (|>L x1 x2) = (stage2 |>L' (codeLift2 |>L') (stageB x1) (stageB x2)) 
    stageB (<|L x1 x2) = (stage2 <|L' (codeLift2 <|L') (stageB x1) (stageB x2)) 
    |>Cl' : {A : Set} -> ((ClShelfTerm A) -> ((ClShelfTerm A) -> (ClShelfTerm A)))
    |>Cl' x1 x2 = (|>Cl x1 x2) 
    <|Cl' : {A : Set} -> ((ClShelfTerm A) -> ((ClShelfTerm A) -> (ClShelfTerm A)))
    <|Cl' x1 x2 = (<|Cl x1 x2) 
    stageCl : {A : Set} -> ((ClShelfTerm A) -> (Staged (ClShelfTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (|>Cl x1 x2) = (stage2 |>Cl' (codeLift2 |>Cl') (stageCl x1) (stageCl x2)) 
    stageCl (<|Cl x1 x2) = (stage2 <|Cl' (codeLift2 <|Cl') (stageCl x1) (stageCl x2)) 
    |>OL' : {n : Nat} -> ((OpShelfTerm n) -> ((OpShelfTerm n) -> (OpShelfTerm n)))
    |>OL' x1 x2 = (|>OL x1 x2) 
    <|OL' : {n : Nat} -> ((OpShelfTerm n) -> ((OpShelfTerm n) -> (OpShelfTerm n)))
    <|OL' x1 x2 = (<|OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpShelfTerm n) -> (Staged (OpShelfTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (|>OL x1 x2) = (stage2 |>OL' (codeLift2 |>OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (<|OL x1 x2) = (stage2 <|OL' (codeLift2 <|OL') (stageOpB x1) (stageOpB x2)) 
    |>OL2' : {n : Nat} {A : Set} -> ((OpShelfTerm2 n A) -> ((OpShelfTerm2 n A) -> (OpShelfTerm2 n A)))
    |>OL2' x1 x2 = (|>OL2 x1 x2) 
    <|OL2' : {n : Nat} {A : Set} -> ((OpShelfTerm2 n A) -> ((OpShelfTerm2 n A) -> (OpShelfTerm2 n A)))
    <|OL2' x1 x2 = (<|OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpShelfTerm2 n A) -> (Staged (OpShelfTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (|>OL2 x1 x2) = (stage2 |>OL2' (codeLift2 |>OL2') (stageOp x1) (stageOp x2)) 
    stageOp (<|OL2 x1 x2) = (stage2 <|OL2' (codeLift2 <|OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        |>T : ((Repr A) -> ((Repr A) -> (Repr A)))
        <|T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module ShelfSig  where
    record ShelfSig (A : Set) : Set where
      constructor ShelfSigC
      field
        |> : (A -> (A -> A))
        <| : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        |>S : (AS -> (AS -> AS))
        <|S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        |>P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        <|P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
    record Hom {A1 : Set} {A2 : Set} (Sh1 : (ShelfSig A1)) (Sh2 : (ShelfSig A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-|> : {x1 x2 : A1} -> (hom ((|> Sh1) x1 x2)) == ((|> Sh2) (hom x1) (hom x2))
        pres-<| : {x1 x2 : A1} -> (hom ((<| Sh1) x1 x2)) == ((<| Sh2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Sh1 : (ShelfSig A1)) (Sh2 : (ShelfSig A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-|> : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((|> Sh1) x1 x2) ((|> Sh2) y1 y2))))
        interp-<| : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((<| Sh1) x1 x2) ((<| Sh2) y1 y2))))
    data ShelfSigTerm  : Set where
      |>L : (ShelfSigTerm -> (ShelfSigTerm -> ShelfSigTerm))
      <|L : (ShelfSigTerm -> (ShelfSigTerm -> ShelfSigTerm))
    data ClShelfSigTerm (A : Set) : Set where
      sing : (A -> (ClShelfSigTerm A))
      |>Cl : ((ClShelfSigTerm A) -> ((ClShelfSigTerm A) -> (ClShelfSigTerm A)))
      <|Cl : ((ClShelfSigTerm A) -> ((ClShelfSigTerm A) -> (ClShelfSigTerm A)))
    data OpShelfSigTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpShelfSigTerm n))
      |>OL : ((OpShelfSigTerm n) -> ((OpShelfSigTerm n) -> (OpShelfSigTerm n)))
      <|OL : ((OpShelfSigTerm n) -> ((OpShelfSigTerm n) -> (OpShelfSigTerm n)))
    data OpShelfSigTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpShelfSigTerm2 n A))
      sing2 : (A -> (OpShelfSigTerm2 n A))
      |>OL2 : ((OpShelfSigTerm2 n A) -> ((OpShelfSigTerm2 n A) -> (OpShelfSigTerm2 n A)))
      <|OL2 : ((OpShelfSigTerm2 n A) -> ((OpShelfSigTerm2 n A) -> (OpShelfSigTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClShelfSigTerm A) -> (ClShelfSigTerm A))
    simplifyCl (|>Cl x1 x2) = (|>Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (<|Cl x1 x2) = (<|Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpShelfSigTerm n) -> (OpShelfSigTerm n))
    simplifyOpB (|>OL x1 x2) = (|>OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (<|OL x1 x2) = (<|OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpShelfSigTerm2 n A) -> (OpShelfSigTerm2 n A))
    simplifyOp (|>OL2 x1 x2) = (|>OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (<|OL2 x1 x2) = (<|OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((ShelfSig A) -> (ShelfSigTerm -> A))
    evalB Sh (|>L x1 x2) = ((|> Sh) (evalB Sh x1) (evalB Sh x2)) 
    evalB Sh (<|L x1 x2) = ((<| Sh) (evalB Sh x1) (evalB Sh x2)) 
    evalCl : {A : Set} -> ((ShelfSig A) -> ((ClShelfSigTerm A) -> A))
    evalCl Sh (sing x1) = x1 
    evalCl Sh (|>Cl x1 x2) = ((|> Sh) (evalCl Sh x1) (evalCl Sh x2)) 
    evalCl Sh (<|Cl x1 x2) = ((<| Sh) (evalCl Sh x1) (evalCl Sh x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((ShelfSig A) -> ((Vec A n) -> ((OpShelfSigTerm n) -> A)))
    evalOpB Sh vars (v x1) = (lookup _ x1 vars) 
    evalOpB Sh vars (|>OL x1 x2) = ((|> Sh) (evalOpB Sh vars x1) (evalOpB Sh vars x2)) 
    evalOpB Sh vars (<|OL x1 x2) = ((<| Sh) (evalOpB Sh vars x1) (evalOpB Sh vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((ShelfSig A) -> ((Vec A n) -> ((OpShelfSigTerm2 n A) -> A)))
    evalOp Sh vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Sh vars (sing2 x1) = x1 
    evalOp Sh vars (|>OL2 x1 x2) = ((|> Sh) (evalOp Sh vars x1) (evalOp Sh vars x2)) 
    evalOp Sh vars (<|OL2 x1 x2) = ((<| Sh) (evalOp Sh vars x1) (evalOp Sh vars x2)) 
    inductionB : {P : (ShelfSigTerm -> Set)} -> (((x1 x2 : ShelfSigTerm) -> ((P x1) -> ((P x2) -> (P (|>L x1 x2))))) -> (((x1 x2 : ShelfSigTerm) -> ((P x1) -> ((P x2) -> (P (<|L x1 x2))))) -> ((x : ShelfSigTerm) -> (P x))))
    inductionB {p} p|>l p<|l (|>L x1 x2) = (p|>l _ _ (inductionB {p} p|>l p<|l x1) (inductionB {p} p|>l p<|l x2)) 
    inductionB {p} p|>l p<|l (<|L x1 x2) = (p<|l _ _ (inductionB {p} p|>l p<|l x1) (inductionB {p} p|>l p<|l x2)) 
    inductionCl : {A : Set} {P : ((ClShelfSigTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClShelfSigTerm A)) -> ((P x1) -> ((P x2) -> (P (|>Cl x1 x2))))) -> (((x1 x2 : (ClShelfSigTerm A)) -> ((P x1) -> ((P x2) -> (P (<|Cl x1 x2))))) -> ((x : (ClShelfSigTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p|>cl p<|cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p|>cl p<|cl (|>Cl x1 x2) = (p|>cl _ _ (inductionCl {_} {p} psing p|>cl p<|cl x1) (inductionCl {_} {p} psing p|>cl p<|cl x2)) 
    inductionCl {_} {p} psing p|>cl p<|cl (<|Cl x1 x2) = (p<|cl _ _ (inductionCl {_} {p} psing p|>cl p<|cl x1) (inductionCl {_} {p} psing p|>cl p<|cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpShelfSigTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpShelfSigTerm n)) -> ((P x1) -> ((P x2) -> (P (|>OL x1 x2))))) -> (((x1 x2 : (OpShelfSigTerm n)) -> ((P x1) -> ((P x2) -> (P (<|OL x1 x2))))) -> ((x : (OpShelfSigTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p|>ol p<|ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p|>ol p<|ol (|>OL x1 x2) = (p|>ol _ _ (inductionOpB {_} {p} pv p|>ol p<|ol x1) (inductionOpB {_} {p} pv p|>ol p<|ol x2)) 
    inductionOpB {_} {p} pv p|>ol p<|ol (<|OL x1 x2) = (p<|ol _ _ (inductionOpB {_} {p} pv p|>ol p<|ol x1) (inductionOpB {_} {p} pv p|>ol p<|ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpShelfSigTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpShelfSigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (|>OL2 x1 x2))))) -> (((x1 x2 : (OpShelfSigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (<|OL2 x1 x2))))) -> ((x : (OpShelfSigTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (|>OL2 x1 x2) = (p|>ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (<|OL2 x1 x2) = (p<|ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x2)) 
    |>L' : (ShelfSigTerm -> (ShelfSigTerm -> ShelfSigTerm))
    |>L' x1 x2 = (|>L x1 x2) 
    <|L' : (ShelfSigTerm -> (ShelfSigTerm -> ShelfSigTerm))
    <|L' x1 x2 = (<|L x1 x2) 
    stageB : (ShelfSigTerm -> (Staged ShelfSigTerm))
    stageB (|>L x1 x2) = (stage2 |>L' (codeLift2 |>L') (stageB x1) (stageB x2)) 
    stageB (<|L x1 x2) = (stage2 <|L' (codeLift2 <|L') (stageB x1) (stageB x2)) 
    |>Cl' : {A : Set} -> ((ClShelfSigTerm A) -> ((ClShelfSigTerm A) -> (ClShelfSigTerm A)))
    |>Cl' x1 x2 = (|>Cl x1 x2) 
    <|Cl' : {A : Set} -> ((ClShelfSigTerm A) -> ((ClShelfSigTerm A) -> (ClShelfSigTerm A)))
    <|Cl' x1 x2 = (<|Cl x1 x2) 
    stageCl : {A : Set} -> ((ClShelfSigTerm A) -> (Staged (ClShelfSigTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (|>Cl x1 x2) = (stage2 |>Cl' (codeLift2 |>Cl') (stageCl x1) (stageCl x2)) 
    stageCl (<|Cl x1 x2) = (stage2 <|Cl' (codeLift2 <|Cl') (stageCl x1) (stageCl x2)) 
    |>OL' : {n : Nat} -> ((OpShelfSigTerm n) -> ((OpShelfSigTerm n) -> (OpShelfSigTerm n)))
    |>OL' x1 x2 = (|>OL x1 x2) 
    <|OL' : {n : Nat} -> ((OpShelfSigTerm n) -> ((OpShelfSigTerm n) -> (OpShelfSigTerm n)))
    <|OL' x1 x2 = (<|OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpShelfSigTerm n) -> (Staged (OpShelfSigTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (|>OL x1 x2) = (stage2 |>OL' (codeLift2 |>OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (<|OL x1 x2) = (stage2 <|OL' (codeLift2 <|OL') (stageOpB x1) (stageOpB x2)) 
    |>OL2' : {n : Nat} {A : Set} -> ((OpShelfSigTerm2 n A) -> ((OpShelfSigTerm2 n A) -> (OpShelfSigTerm2 n A)))
    |>OL2' x1 x2 = (|>OL2 x1 x2) 
    <|OL2' : {n : Nat} {A : Set} -> ((OpShelfSigTerm2 n A) -> ((OpShelfSigTerm2 n A) -> (OpShelfSigTerm2 n A)))
    <|OL2' x1 x2 = (<|OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpShelfSigTerm2 n A) -> (Staged (OpShelfSigTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (|>OL2 x1 x2) = (stage2 |>OL2' (codeLift2 |>OL2') (stageOp x1) (stageOp x2)) 
    stageOp (<|OL2 x1 x2) = (stage2 <|OL2' (codeLift2 <|OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        |>T : ((Repr A) -> ((Repr A) -> (Repr A)))
        <|T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module Sloop  where
    record Sloop (A : Set) : Set where
      constructor SloopC
      field
        e : A
        op : (A -> (A -> A))
        commutative_op : {x y : A} -> (op x y) == (op y x)
        antiAbsorbent : {x y : A} -> (op x (op x y)) == y
        unipotence : {x : A} -> (op x x) == e
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        eS : AS
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        eP : (Prod A A)
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        commutative_opP : {xP yP : (Prod A A)} -> (opP xP yP) == (opP yP xP)
        antiAbsorbentP : {xP yP : (Prod A A)} -> (opP xP (opP xP yP)) == yP
        unipotenceP : {xP : (Prod A A)} -> (opP xP xP) == eP
    record Hom {A1 : Set} {A2 : Set} (Sl1 : (Sloop A1)) (Sl2 : (Sloop A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-e : (hom (e Sl1)) == (e Sl2)
        pres-op : {x1 x2 : A1} -> (hom ((op Sl1) x1 x2)) == ((op Sl2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Sl1 : (Sloop A1)) (Sl2 : (Sloop A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-e : (interp (e Sl1) (e Sl2))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Sl1) x1 x2) ((op Sl2) y1 y2))))
    data SloopLTerm  : Set where
      eL : SloopLTerm
      opL : (SloopLTerm -> (SloopLTerm -> SloopLTerm))
    data ClSloopClTerm (A : Set) : Set where
      sing : (A -> (ClSloopClTerm A))
      eCl : (ClSloopClTerm A)
      opCl : ((ClSloopClTerm A) -> ((ClSloopClTerm A) -> (ClSloopClTerm A)))
    data OpSloopOLTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpSloopOLTerm n))
      eOL : (OpSloopOLTerm n)
      opOL : ((OpSloopOLTerm n) -> ((OpSloopOLTerm n) -> (OpSloopOLTerm n)))
    data OpSloopOL2Term2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpSloopOL2Term2 n A))
      sing2 : (A -> (OpSloopOL2Term2 n A))
      eOL2 : (OpSloopOL2Term2 n A)
      opOL2 : ((OpSloopOL2Term2 n A) -> ((OpSloopOL2Term2 n A) -> (OpSloopOL2Term2 n A)))
    simplifyCl : {A : Set} -> ((ClSloopClTerm A) -> (ClSloopClTerm A))
    simplifyCl eCl = eCl 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpSloopOLTerm n) -> (OpSloopOLTerm n))
    simplifyOpB eOL = eOL 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpSloopOL2Term2 n A) -> (OpSloopOL2Term2 n A))
    simplifyOp eOL2 = eOL2 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Sloop A) -> (SloopLTerm -> A))
    evalB Sl eL = (e Sl) 
    evalB Sl (opL x1 x2) = ((op Sl) (evalB Sl x1) (evalB Sl x2)) 
    evalCl : {A : Set} -> ((Sloop A) -> ((ClSloopClTerm A) -> A))
    evalCl Sl (sing x1) = x1 
    evalCl Sl eCl = (e Sl) 
    evalCl Sl (opCl x1 x2) = ((op Sl) (evalCl Sl x1) (evalCl Sl x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Sloop A) -> ((Vec A n) -> ((OpSloopOLTerm n) -> A)))
    evalOpB Sl vars (v x1) = (lookup _ x1 vars) 
    evalOpB Sl vars eOL = (e Sl) 
    evalOpB Sl vars (opOL x1 x2) = ((op Sl) (evalOpB Sl vars x1) (evalOpB Sl vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Sloop A) -> ((Vec A n) -> ((OpSloopOL2Term2 n A) -> A)))
    evalOp Sl vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Sl vars (sing2 x1) = x1 
    evalOp Sl vars eOL2 = (e Sl) 
    evalOp Sl vars (opOL2 x1 x2) = ((op Sl) (evalOp Sl vars x1) (evalOp Sl vars x2)) 
    inductionB : {P : (SloopLTerm -> Set)} -> ((P eL) -> (((x1 x2 : SloopLTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : SloopLTerm) -> (P x))))
    inductionB {p} pel popl eL = pel 
    inductionB {p} pel popl (opL x1 x2) = (popl _ _ (inductionB {p} pel popl x1) (inductionB {p} pel popl x2)) 
    inductionCl : {A : Set} {P : ((ClSloopClTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P eCl) -> (((x1 x2 : (ClSloopClTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClSloopClTerm A)) -> (P x)))))
    inductionCl {_} {p} psing pecl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pecl popcl eCl = pecl 
    inductionCl {_} {p} psing pecl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing pecl popcl x1) (inductionCl {_} {p} psing pecl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpSloopOLTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P eOL) -> (((x1 x2 : (OpSloopOLTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpSloopOLTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv peol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv peol popol eOL = peol 
    inductionOpB {_} {p} pv peol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv peol popol x1) (inductionOpB {_} {p} pv peol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpSloopOL2Term2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P eOL2) -> (((x1 x2 : (OpSloopOL2Term2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpSloopOL2Term2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 eOL2 = peol2 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 x2)) 
    eL' : SloopLTerm
    eL'  = eL 
    opL' : (SloopLTerm -> (SloopLTerm -> SloopLTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (SloopLTerm -> (Staged SloopLTerm))
    stageB eL = (Now eL) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    eCl' : {A : Set} -> (ClSloopClTerm A)
    eCl'  = eCl 
    opCl' : {A : Set} -> ((ClSloopClTerm A) -> ((ClSloopClTerm A) -> (ClSloopClTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClSloopClTerm A) -> (Staged (ClSloopClTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl eCl = (Now eCl) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    eOL' : {n : Nat} -> (OpSloopOLTerm n)
    eOL'  = eOL 
    opOL' : {n : Nat} -> ((OpSloopOLTerm n) -> ((OpSloopOLTerm n) -> (OpSloopOLTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpSloopOLTerm n) -> (Staged (OpSloopOLTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB eOL = (Now eOL) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    eOL2' : {n : Nat} {A : Set} -> (OpSloopOL2Term2 n A)
    eOL2'  = eOL2 
    opOL2' : {n : Nat} {A : Set} -> ((OpSloopOL2Term2 n A) -> ((OpSloopOL2Term2 n A) -> (OpSloopOL2Term2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpSloopOL2Term2 n A) -> (Staged (OpSloopOL2Term2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp eOL2 = (Now eOL2) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        eT : (Repr A)
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module Spindle  where
    record Spindle (A : Set) : Set where
      constructor SpindleC
      field
        |> : (A -> (A -> A))
        <| : (A -> (A -> A))
        leftDistributive : {x y z : A} -> (|> x (|> y z)) == (|> (|> x y) (|> x z))
        rightDistributive : {x y z : A} -> (<| (<| y z) x) == (<| (<| y x) (<| z x))
        idempotent_|> : {x : A} -> (|> x x) == x
        idempotent_<| : {x : A} -> (<| x x) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        |>S : (AS -> (AS -> AS))
        <|S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        |>P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        <|P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftDistributiveP : {xP yP zP : (Prod A A)} -> (|>P xP (|>P yP zP)) == (|>P (|>P xP yP) (|>P xP zP))
        rightDistributiveP : {xP yP zP : (Prod A A)} -> (<|P (<|P yP zP) xP) == (<|P (<|P yP xP) (<|P zP xP))
        idempotent_|>P : {xP : (Prod A A)} -> (|>P xP xP) == xP
        idempotent_<|P : {xP : (Prod A A)} -> (<|P xP xP) == xP
    record Hom {A1 : Set} {A2 : Set} (Sp1 : (Spindle A1)) (Sp2 : (Spindle A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-|> : {x1 x2 : A1} -> (hom ((|> Sp1) x1 x2)) == ((|> Sp2) (hom x1) (hom x2))
        pres-<| : {x1 x2 : A1} -> (hom ((<| Sp1) x1 x2)) == ((<| Sp2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Sp1 : (Spindle A1)) (Sp2 : (Spindle A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-|> : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((|> Sp1) x1 x2) ((|> Sp2) y1 y2))))
        interp-<| : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((<| Sp1) x1 x2) ((<| Sp2) y1 y2))))
    data SpindleTerm  : Set where
      |>L : (SpindleTerm -> (SpindleTerm -> SpindleTerm))
      <|L : (SpindleTerm -> (SpindleTerm -> SpindleTerm))
    data ClSpindleTerm (A : Set) : Set where
      sing : (A -> (ClSpindleTerm A))
      |>Cl : ((ClSpindleTerm A) -> ((ClSpindleTerm A) -> (ClSpindleTerm A)))
      <|Cl : ((ClSpindleTerm A) -> ((ClSpindleTerm A) -> (ClSpindleTerm A)))
    data OpSpindleTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpSpindleTerm n))
      |>OL : ((OpSpindleTerm n) -> ((OpSpindleTerm n) -> (OpSpindleTerm n)))
      <|OL : ((OpSpindleTerm n) -> ((OpSpindleTerm n) -> (OpSpindleTerm n)))
    data OpSpindleTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpSpindleTerm2 n A))
      sing2 : (A -> (OpSpindleTerm2 n A))
      |>OL2 : ((OpSpindleTerm2 n A) -> ((OpSpindleTerm2 n A) -> (OpSpindleTerm2 n A)))
      <|OL2 : ((OpSpindleTerm2 n A) -> ((OpSpindleTerm2 n A) -> (OpSpindleTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClSpindleTerm A) -> (ClSpindleTerm A))
    simplifyCl (|>Cl x1 x2) = (|>Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (<|Cl x1 x2) = (<|Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpSpindleTerm n) -> (OpSpindleTerm n))
    simplifyOpB (|>OL x1 x2) = (|>OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (<|OL x1 x2) = (<|OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpSpindleTerm2 n A) -> (OpSpindleTerm2 n A))
    simplifyOp (|>OL2 x1 x2) = (|>OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (<|OL2 x1 x2) = (<|OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Spindle A) -> (SpindleTerm -> A))
    evalB Sp (|>L x1 x2) = ((|> Sp) (evalB Sp x1) (evalB Sp x2)) 
    evalB Sp (<|L x1 x2) = ((<| Sp) (evalB Sp x1) (evalB Sp x2)) 
    evalCl : {A : Set} -> ((Spindle A) -> ((ClSpindleTerm A) -> A))
    evalCl Sp (sing x1) = x1 
    evalCl Sp (|>Cl x1 x2) = ((|> Sp) (evalCl Sp x1) (evalCl Sp x2)) 
    evalCl Sp (<|Cl x1 x2) = ((<| Sp) (evalCl Sp x1) (evalCl Sp x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Spindle A) -> ((Vec A n) -> ((OpSpindleTerm n) -> A)))
    evalOpB Sp vars (v x1) = (lookup _ x1 vars) 
    evalOpB Sp vars (|>OL x1 x2) = ((|> Sp) (evalOpB Sp vars x1) (evalOpB Sp vars x2)) 
    evalOpB Sp vars (<|OL x1 x2) = ((<| Sp) (evalOpB Sp vars x1) (evalOpB Sp vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Spindle A) -> ((Vec A n) -> ((OpSpindleTerm2 n A) -> A)))
    evalOp Sp vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Sp vars (sing2 x1) = x1 
    evalOp Sp vars (|>OL2 x1 x2) = ((|> Sp) (evalOp Sp vars x1) (evalOp Sp vars x2)) 
    evalOp Sp vars (<|OL2 x1 x2) = ((<| Sp) (evalOp Sp vars x1) (evalOp Sp vars x2)) 
    inductionB : {P : (SpindleTerm -> Set)} -> (((x1 x2 : SpindleTerm) -> ((P x1) -> ((P x2) -> (P (|>L x1 x2))))) -> (((x1 x2 : SpindleTerm) -> ((P x1) -> ((P x2) -> (P (<|L x1 x2))))) -> ((x : SpindleTerm) -> (P x))))
    inductionB {p} p|>l p<|l (|>L x1 x2) = (p|>l _ _ (inductionB {p} p|>l p<|l x1) (inductionB {p} p|>l p<|l x2)) 
    inductionB {p} p|>l p<|l (<|L x1 x2) = (p<|l _ _ (inductionB {p} p|>l p<|l x1) (inductionB {p} p|>l p<|l x2)) 
    inductionCl : {A : Set} {P : ((ClSpindleTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClSpindleTerm A)) -> ((P x1) -> ((P x2) -> (P (|>Cl x1 x2))))) -> (((x1 x2 : (ClSpindleTerm A)) -> ((P x1) -> ((P x2) -> (P (<|Cl x1 x2))))) -> ((x : (ClSpindleTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p|>cl p<|cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p|>cl p<|cl (|>Cl x1 x2) = (p|>cl _ _ (inductionCl {_} {p} psing p|>cl p<|cl x1) (inductionCl {_} {p} psing p|>cl p<|cl x2)) 
    inductionCl {_} {p} psing p|>cl p<|cl (<|Cl x1 x2) = (p<|cl _ _ (inductionCl {_} {p} psing p|>cl p<|cl x1) (inductionCl {_} {p} psing p|>cl p<|cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpSpindleTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpSpindleTerm n)) -> ((P x1) -> ((P x2) -> (P (|>OL x1 x2))))) -> (((x1 x2 : (OpSpindleTerm n)) -> ((P x1) -> ((P x2) -> (P (<|OL x1 x2))))) -> ((x : (OpSpindleTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p|>ol p<|ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p|>ol p<|ol (|>OL x1 x2) = (p|>ol _ _ (inductionOpB {_} {p} pv p|>ol p<|ol x1) (inductionOpB {_} {p} pv p|>ol p<|ol x2)) 
    inductionOpB {_} {p} pv p|>ol p<|ol (<|OL x1 x2) = (p<|ol _ _ (inductionOpB {_} {p} pv p|>ol p<|ol x1) (inductionOpB {_} {p} pv p|>ol p<|ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpSpindleTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpSpindleTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (|>OL2 x1 x2))))) -> (((x1 x2 : (OpSpindleTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (<|OL2 x1 x2))))) -> ((x : (OpSpindleTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (|>OL2 x1 x2) = (p|>ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 (<|OL2 x1 x2) = (p<|ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p|>ol2 p<|ol2 x2)) 
    |>L' : (SpindleTerm -> (SpindleTerm -> SpindleTerm))
    |>L' x1 x2 = (|>L x1 x2) 
    <|L' : (SpindleTerm -> (SpindleTerm -> SpindleTerm))
    <|L' x1 x2 = (<|L x1 x2) 
    stageB : (SpindleTerm -> (Staged SpindleTerm))
    stageB (|>L x1 x2) = (stage2 |>L' (codeLift2 |>L') (stageB x1) (stageB x2)) 
    stageB (<|L x1 x2) = (stage2 <|L' (codeLift2 <|L') (stageB x1) (stageB x2)) 
    |>Cl' : {A : Set} -> ((ClSpindleTerm A) -> ((ClSpindleTerm A) -> (ClSpindleTerm A)))
    |>Cl' x1 x2 = (|>Cl x1 x2) 
    <|Cl' : {A : Set} -> ((ClSpindleTerm A) -> ((ClSpindleTerm A) -> (ClSpindleTerm A)))
    <|Cl' x1 x2 = (<|Cl x1 x2) 
    stageCl : {A : Set} -> ((ClSpindleTerm A) -> (Staged (ClSpindleTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (|>Cl x1 x2) = (stage2 |>Cl' (codeLift2 |>Cl') (stageCl x1) (stageCl x2)) 
    stageCl (<|Cl x1 x2) = (stage2 <|Cl' (codeLift2 <|Cl') (stageCl x1) (stageCl x2)) 
    |>OL' : {n : Nat} -> ((OpSpindleTerm n) -> ((OpSpindleTerm n) -> (OpSpindleTerm n)))
    |>OL' x1 x2 = (|>OL x1 x2) 
    <|OL' : {n : Nat} -> ((OpSpindleTerm n) -> ((OpSpindleTerm n) -> (OpSpindleTerm n)))
    <|OL' x1 x2 = (<|OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpSpindleTerm n) -> (Staged (OpSpindleTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (|>OL x1 x2) = (stage2 |>OL' (codeLift2 |>OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (<|OL x1 x2) = (stage2 <|OL' (codeLift2 <|OL') (stageOpB x1) (stageOpB x2)) 
    |>OL2' : {n : Nat} {A : Set} -> ((OpSpindleTerm2 n A) -> ((OpSpindleTerm2 n A) -> (OpSpindleTerm2 n A)))
    |>OL2' x1 x2 = (|>OL2 x1 x2) 
    <|OL2' : {n : Nat} {A : Set} -> ((OpSpindleTerm2 n A) -> ((OpSpindleTerm2 n A) -> (OpSpindleTerm2 n A)))
    <|OL2' x1 x2 = (<|OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpSpindleTerm2 n A) -> (Staged (OpSpindleTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (|>OL2 x1 x2) = (stage2 |>OL2' (codeLift2 |>OL2') (stageOp x1) (stageOp x2)) 
    stageOp (<|OL2 x1 x2) = (stage2 <|OL2' (codeLift2 <|OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        |>T : ((Repr A) -> ((Repr A) -> (Repr A)))
        <|T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module Squag  where
    record Squag (A : Set) : Set where
      constructor SquagC
      field
        op : (A -> (A -> A))
        commutative_op : {x y : A} -> (op x y) == (op y x)
        antiAbsorbent : {x y : A} -> (op x (op x y)) == y
        idempotent_op : {x : A} -> (op x x) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        commutative_opP : {xP yP : (Prod A A)} -> (opP xP yP) == (opP yP xP)
        antiAbsorbentP : {xP yP : (Prod A A)} -> (opP xP (opP xP yP)) == yP
        idempotent_opP : {xP : (Prod A A)} -> (opP xP xP) == xP
    record Hom {A1 : Set} {A2 : Set} (Sq1 : (Squag A1)) (Sq2 : (Squag A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op Sq1) x1 x2)) == ((op Sq2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Sq1 : (Squag A1)) (Sq2 : (Squag A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Sq1) x1 x2) ((op Sq2) y1 y2))))
    data SquagTerm  : Set where
      opL : (SquagTerm -> (SquagTerm -> SquagTerm))
    data ClSquagTerm (A : Set) : Set where
      sing : (A -> (ClSquagTerm A))
      opCl : ((ClSquagTerm A) -> ((ClSquagTerm A) -> (ClSquagTerm A)))
    data OpSquagTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpSquagTerm n))
      opOL : ((OpSquagTerm n) -> ((OpSquagTerm n) -> (OpSquagTerm n)))
    data OpSquagTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpSquagTerm2 n A))
      sing2 : (A -> (OpSquagTerm2 n A))
      opOL2 : ((OpSquagTerm2 n A) -> ((OpSquagTerm2 n A) -> (OpSquagTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClSquagTerm A) -> (ClSquagTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpSquagTerm n) -> (OpSquagTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpSquagTerm2 n A) -> (OpSquagTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Squag A) -> (SquagTerm -> A))
    evalB Sq (opL x1 x2) = ((op Sq) (evalB Sq x1) (evalB Sq x2)) 
    evalCl : {A : Set} -> ((Squag A) -> ((ClSquagTerm A) -> A))
    evalCl Sq (sing x1) = x1 
    evalCl Sq (opCl x1 x2) = ((op Sq) (evalCl Sq x1) (evalCl Sq x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Squag A) -> ((Vec A n) -> ((OpSquagTerm n) -> A)))
    evalOpB Sq vars (v x1) = (lookup _ x1 vars) 
    evalOpB Sq vars (opOL x1 x2) = ((op Sq) (evalOpB Sq vars x1) (evalOpB Sq vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Squag A) -> ((Vec A n) -> ((OpSquagTerm2 n A) -> A)))
    evalOp Sq vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Sq vars (sing2 x1) = x1 
    evalOp Sq vars (opOL2 x1 x2) = ((op Sq) (evalOp Sq vars x1) (evalOp Sq vars x2)) 
    inductionB : {P : (SquagTerm -> Set)} -> (((x1 x2 : SquagTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : SquagTerm) -> (P x)))
    inductionB {p} popl (opL x1 x2) = (popl _ _ (inductionB {p} popl x1) (inductionB {p} popl x2)) 
    inductionCl : {A : Set} {P : ((ClSquagTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClSquagTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClSquagTerm A)) -> (P x))))
    inductionCl {_} {p} psing popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl x1) (inductionCl {_} {p} psing popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpSquagTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpSquagTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpSquagTerm n)) -> (P x))))
    inductionOpB {_} {p} pv popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol x1) (inductionOpB {_} {p} pv popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpSquagTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpSquagTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpSquagTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 x2)) 
    opL' : (SquagTerm -> (SquagTerm -> SquagTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (SquagTerm -> (Staged SquagTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClSquagTerm A) -> ((ClSquagTerm A) -> (ClSquagTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClSquagTerm A) -> (Staged (ClSquagTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpSquagTerm n) -> ((OpSquagTerm n) -> (OpSquagTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpSquagTerm n) -> (Staged (OpSquagTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpSquagTerm2 n A) -> ((OpSquagTerm2 n A) -> (OpSquagTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpSquagTerm2 n A) -> (Staged (OpSquagTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module SteinerMagma  where
    record SteinerMagma (A : Set) : Set where
      constructor SteinerMagmaC
      field
        op : (A -> (A -> A))
        commutative_op : {x y : A} -> (op x y) == (op y x)
        antiAbsorbent : {x y : A} -> (op x (op x y)) == y
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        commutative_opP : {xP yP : (Prod A A)} -> (opP xP yP) == (opP yP xP)
        antiAbsorbentP : {xP yP : (Prod A A)} -> (opP xP (opP xP yP)) == yP
    record Hom {A1 : Set} {A2 : Set} (St1 : (SteinerMagma A1)) (St2 : (SteinerMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-op : {x1 x2 : A1} -> (hom ((op St1) x1 x2)) == ((op St2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (St1 : (SteinerMagma A1)) (St2 : (SteinerMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op St1) x1 x2) ((op St2) y1 y2))))
    data SteinerMagmaTerm  : Set where
      opL : (SteinerMagmaTerm -> (SteinerMagmaTerm -> SteinerMagmaTerm))
    data ClSteinerMagmaTerm (A : Set) : Set where
      sing : (A -> (ClSteinerMagmaTerm A))
      opCl : ((ClSteinerMagmaTerm A) -> ((ClSteinerMagmaTerm A) -> (ClSteinerMagmaTerm A)))
    data OpSteinerMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpSteinerMagmaTerm n))
      opOL : ((OpSteinerMagmaTerm n) -> ((OpSteinerMagmaTerm n) -> (OpSteinerMagmaTerm n)))
    data OpSteinerMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpSteinerMagmaTerm2 n A))
      sing2 : (A -> (OpSteinerMagmaTerm2 n A))
      opOL2 : ((OpSteinerMagmaTerm2 n A) -> ((OpSteinerMagmaTerm2 n A) -> (OpSteinerMagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClSteinerMagmaTerm A) -> (ClSteinerMagmaTerm A))
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpSteinerMagmaTerm n) -> (OpSteinerMagmaTerm n))
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpSteinerMagmaTerm2 n A) -> (OpSteinerMagmaTerm2 n A))
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((SteinerMagma A) -> (SteinerMagmaTerm -> A))
    evalB St (opL x1 x2) = ((op St) (evalB St x1) (evalB St x2)) 
    evalCl : {A : Set} -> ((SteinerMagma A) -> ((ClSteinerMagmaTerm A) -> A))
    evalCl St (sing x1) = x1 
    evalCl St (opCl x1 x2) = ((op St) (evalCl St x1) (evalCl St x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((SteinerMagma A) -> ((Vec A n) -> ((OpSteinerMagmaTerm n) -> A)))
    evalOpB St vars (v x1) = (lookup _ x1 vars) 
    evalOpB St vars (opOL x1 x2) = ((op St) (evalOpB St vars x1) (evalOpB St vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((SteinerMagma A) -> ((Vec A n) -> ((OpSteinerMagmaTerm2 n A) -> A)))
    evalOp St vars (v2 x1) = (lookup _ x1 vars) 
    evalOp St vars (sing2 x1) = x1 
    evalOp St vars (opOL2 x1 x2) = ((op St) (evalOp St vars x1) (evalOp St vars x2)) 
    inductionB : {P : (SteinerMagmaTerm -> Set)} -> (((x1 x2 : SteinerMagmaTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : SteinerMagmaTerm) -> (P x)))
    inductionB {p} popl (opL x1 x2) = (popl _ _ (inductionB {p} popl x1) (inductionB {p} popl x2)) 
    inductionCl : {A : Set} {P : ((ClSteinerMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 x2 : (ClSteinerMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClSteinerMagmaTerm A)) -> (P x))))
    inductionCl {_} {p} psing popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing popcl x1) (inductionCl {_} {p} psing popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpSteinerMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 x2 : (OpSteinerMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpSteinerMagmaTerm n)) -> (P x))))
    inductionOpB {_} {p} pv popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv popol x1) (inductionOpB {_} {p} pv popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpSteinerMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 x2 : (OpSteinerMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpSteinerMagmaTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 popol2 x2)) 
    opL' : (SteinerMagmaTerm -> (SteinerMagmaTerm -> SteinerMagmaTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (SteinerMagmaTerm -> (Staged SteinerMagmaTerm))
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    opCl' : {A : Set} -> ((ClSteinerMagmaTerm A) -> ((ClSteinerMagmaTerm A) -> (ClSteinerMagmaTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClSteinerMagmaTerm A) -> (Staged (ClSteinerMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    opOL' : {n : Nat} -> ((OpSteinerMagmaTerm n) -> ((OpSteinerMagmaTerm n) -> (OpSteinerMagmaTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpSteinerMagmaTerm n) -> (Staged (OpSteinerMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    opOL2' : {n : Nat} {A : Set} -> ((OpSteinerMagmaTerm2 n A) -> ((OpSteinerMagmaTerm2 n A) -> (OpSteinerMagmaTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpSteinerMagmaTerm2 n A) -> (Staged (OpSteinerMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module TwoPointed  where
    record TwoPointed (A : Set) : Set where
      constructor TwoPointedC
      field
        e1 : A
        e2 : A
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        e1S : AS
        e2S : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        e1P : (Prod A A)
        e2P : (Prod A A)
    record Hom {A1 : Set} {A2 : Set} (Tw1 : (TwoPointed A1)) (Tw2 : (TwoPointed A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-e1 : (hom (e1 Tw1)) == (e1 Tw2)
        pres-e2 : (hom (e2 Tw1)) == (e2 Tw2)
    record RelInterp {A1 : Set} {A2 : Set} (Tw1 : (TwoPointed A1)) (Tw2 : (TwoPointed A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-e1 : (interp (e1 Tw1) (e1 Tw2))
        interp-e2 : (interp (e2 Tw1) (e2 Tw2))
    data TwoPointedTerm  : Set where
      e1L : TwoPointedTerm
      e2L : TwoPointedTerm
    data ClTwoPointedTerm (A : Set) : Set where
      sing : (A -> (ClTwoPointedTerm A))
      e1Cl : (ClTwoPointedTerm A)
      e2Cl : (ClTwoPointedTerm A)
    data OpTwoPointedTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpTwoPointedTerm n))
      e1OL : (OpTwoPointedTerm n)
      e2OL : (OpTwoPointedTerm n)
    data OpTwoPointedTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpTwoPointedTerm2 n A))
      sing2 : (A -> (OpTwoPointedTerm2 n A))
      e1OL2 : (OpTwoPointedTerm2 n A)
      e2OL2 : (OpTwoPointedTerm2 n A)
    simplifyCl : {A : Set} -> ((ClTwoPointedTerm A) -> (ClTwoPointedTerm A))
    simplifyCl e1Cl = e1Cl 
    simplifyCl e2Cl = e2Cl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpTwoPointedTerm n) -> (OpTwoPointedTerm n))
    simplifyOpB e1OL = e1OL 
    simplifyOpB e2OL = e2OL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpTwoPointedTerm2 n A) -> (OpTwoPointedTerm2 n A))
    simplifyOp e1OL2 = e1OL2 
    simplifyOp e2OL2 = e2OL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((TwoPointed A) -> (TwoPointedTerm -> A))
    evalB Tw e1L = (e1 Tw) 
    evalB Tw e2L = (e2 Tw) 
    evalCl : {A : Set} -> ((TwoPointed A) -> ((ClTwoPointedTerm A) -> A))
    evalCl Tw (sing x1) = x1 
    evalCl Tw e1Cl = (e1 Tw) 
    evalCl Tw e2Cl = (e2 Tw) 
    evalOpB : {A : Set} {n : Nat} -> ((TwoPointed A) -> ((Vec A n) -> ((OpTwoPointedTerm n) -> A)))
    evalOpB Tw vars (v x1) = (lookup _ x1 vars) 
    evalOpB Tw vars e1OL = (e1 Tw) 
    evalOpB Tw vars e2OL = (e2 Tw) 
    evalOp : {A : Set} {n : Nat} -> ((TwoPointed A) -> ((Vec A n) -> ((OpTwoPointedTerm2 n A) -> A)))
    evalOp Tw vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Tw vars (sing2 x1) = x1 
    evalOp Tw vars e1OL2 = (e1 Tw) 
    evalOp Tw vars e2OL2 = (e2 Tw) 
    inductionB : {P : (TwoPointedTerm -> Set)} -> ((P e1L) -> ((P e2L) -> ((x : TwoPointedTerm) -> (P x))))
    inductionB {p} pe1l pe2l e1L = pe1l 
    inductionB {p} pe1l pe2l e2L = pe2l 
    inductionCl : {A : Set} {P : ((ClTwoPointedTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P e1Cl) -> ((P e2Cl) -> ((x : (ClTwoPointedTerm A)) -> (P x)))))
    inductionCl {_} {p} psing pe1cl pe2cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pe1cl pe2cl e1Cl = pe1cl 
    inductionCl {_} {p} psing pe1cl pe2cl e2Cl = pe2cl 
    inductionOpB : {n : Nat} {P : ((OpTwoPointedTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P e1OL) -> ((P e2OL) -> ((x : (OpTwoPointedTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv pe1ol pe2ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pe1ol pe2ol e1OL = pe1ol 
    inductionOpB {_} {p} pv pe1ol pe2ol e2OL = pe2ol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpTwoPointedTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P e1OL2) -> ((P e2OL2) -> ((x : (OpTwoPointedTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 pe1ol2 pe2ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pe1ol2 pe2ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pe1ol2 pe2ol2 e1OL2 = pe1ol2 
    inductionOp {_} {_} {p} pv2 psing2 pe1ol2 pe2ol2 e2OL2 = pe2ol2 
    e1L' : TwoPointedTerm
    e1L'  = e1L 
    e2L' : TwoPointedTerm
    e2L'  = e2L 
    stageB : (TwoPointedTerm -> (Staged TwoPointedTerm))
    stageB e1L = (Now e1L) 
    stageB e2L = (Now e2L) 
    e1Cl' : {A : Set} -> (ClTwoPointedTerm A)
    e1Cl'  = e1Cl 
    e2Cl' : {A : Set} -> (ClTwoPointedTerm A)
    e2Cl'  = e2Cl 
    stageCl : {A : Set} -> ((ClTwoPointedTerm A) -> (Staged (ClTwoPointedTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl e1Cl = (Now e1Cl) 
    stageCl e2Cl = (Now e2Cl) 
    e1OL' : {n : Nat} -> (OpTwoPointedTerm n)
    e1OL'  = e1OL 
    e2OL' : {n : Nat} -> (OpTwoPointedTerm n)
    e2OL'  = e2OL 
    stageOpB : {n : Nat} -> ((OpTwoPointedTerm n) -> (Staged (OpTwoPointedTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB e1OL = (Now e1OL) 
    stageOpB e2OL = (Now e2OL) 
    e1OL2' : {n : Nat} {A : Set} -> (OpTwoPointedTerm2 n A)
    e1OL2'  = e1OL2 
    e2OL2' : {n : Nat} {A : Set} -> (OpTwoPointedTerm2 n A)
    e2OL2'  = e2OL2 
    stageOp : {n : Nat} {A : Set} -> ((OpTwoPointedTerm2 n A) -> (Staged (OpTwoPointedTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp e1OL2 = (Now e1OL2) 
    stageOp e2OL2 = (Now e2OL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        e1T : (Repr A)
        e2T : (Repr A)
  module TwoPointed01  where
    record TwoPointed01 (A : Set) : Set where
      constructor TwoPointed01C
      field
        e1 : A
        e2 : A
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        e1S : AS
        e2S : AS
    record Product (A : Set) : Set where
      constructor ProductC
      field
        e1P : (Prod A A)
        e2P : (Prod A A)
    record Hom {A1 : Set} {A2 : Set} (Tw1 : (TwoPointed01 A1)) (Tw2 : (TwoPointed01 A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-e1 : (hom (e1 Tw1)) == (e1 Tw2)
        pres-e2 : (hom (e2 Tw1)) == (e2 Tw2)
    record RelInterp {A1 : Set} {A2 : Set} (Tw1 : (TwoPointed01 A1)) (Tw2 : (TwoPointed01 A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-e1 : (interp (e1 Tw1) (e1 Tw2))
        interp-e2 : (interp (e2 Tw1) (e2 Tw2))
    data TwoPointed01Term  : Set where
      e1L : TwoPointed01Term
      e2L : TwoPointed01Term
    data ClTwoPointed01Term (A : Set) : Set where
      sing : (A -> (ClTwoPointed01Term A))
      e1Cl : (ClTwoPointed01Term A)
      e2Cl : (ClTwoPointed01Term A)
    data OpTwoPointed01Term (n : Nat) : Set where
      v : ((Fin n) -> (OpTwoPointed01Term n))
      e1OL : (OpTwoPointed01Term n)
      e2OL : (OpTwoPointed01Term n)
    data OpTwoPointed01Term2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpTwoPointed01Term2 n A))
      sing2 : (A -> (OpTwoPointed01Term2 n A))
      e1OL2 : (OpTwoPointed01Term2 n A)
      e2OL2 : (OpTwoPointed01Term2 n A)
    simplifyCl : {A : Set} -> ((ClTwoPointed01Term A) -> (ClTwoPointed01Term A))
    simplifyCl e1Cl = e1Cl 
    simplifyCl e2Cl = e2Cl 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpTwoPointed01Term n) -> (OpTwoPointed01Term n))
    simplifyOpB e1OL = e1OL 
    simplifyOpB e2OL = e2OL 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpTwoPointed01Term2 n A) -> (OpTwoPointed01Term2 n A))
    simplifyOp e1OL2 = e1OL2 
    simplifyOp e2OL2 = e2OL2 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((TwoPointed01 A) -> (TwoPointed01Term -> A))
    evalB Tw e1L = (e1 Tw) 
    evalB Tw e2L = (e2 Tw) 
    evalCl : {A : Set} -> ((TwoPointed01 A) -> ((ClTwoPointed01Term A) -> A))
    evalCl Tw (sing x1) = x1 
    evalCl Tw e1Cl = (e1 Tw) 
    evalCl Tw e2Cl = (e2 Tw) 
    evalOpB : {A : Set} {n : Nat} -> ((TwoPointed01 A) -> ((Vec A n) -> ((OpTwoPointed01Term n) -> A)))
    evalOpB Tw vars (v x1) = (lookup _ x1 vars) 
    evalOpB Tw vars e1OL = (e1 Tw) 
    evalOpB Tw vars e2OL = (e2 Tw) 
    evalOp : {A : Set} {n : Nat} -> ((TwoPointed01 A) -> ((Vec A n) -> ((OpTwoPointed01Term2 n A) -> A)))
    evalOp Tw vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Tw vars (sing2 x1) = x1 
    evalOp Tw vars e1OL2 = (e1 Tw) 
    evalOp Tw vars e2OL2 = (e2 Tw) 
    inductionB : {P : (TwoPointed01Term -> Set)} -> ((P e1L) -> ((P e2L) -> ((x : TwoPointed01Term) -> (P x))))
    inductionB {p} pe1l pe2l e1L = pe1l 
    inductionB {p} pe1l pe2l e2L = pe2l 
    inductionCl : {A : Set} {P : ((ClTwoPointed01Term A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P e1Cl) -> ((P e2Cl) -> ((x : (ClTwoPointed01Term A)) -> (P x)))))
    inductionCl {_} {p} psing pe1cl pe2cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pe1cl pe2cl e1Cl = pe1cl 
    inductionCl {_} {p} psing pe1cl pe2cl e2Cl = pe2cl 
    inductionOpB : {n : Nat} {P : ((OpTwoPointed01Term n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P e1OL) -> ((P e2OL) -> ((x : (OpTwoPointed01Term n)) -> (P x)))))
    inductionOpB {_} {p} pv pe1ol pe2ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pe1ol pe2ol e1OL = pe1ol 
    inductionOpB {_} {p} pv pe1ol pe2ol e2OL = pe2ol 
    inductionOp : {n : Nat} {A : Set} {P : ((OpTwoPointed01Term2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P e1OL2) -> ((P e2OL2) -> ((x : (OpTwoPointed01Term2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 pe1ol2 pe2ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pe1ol2 pe2ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pe1ol2 pe2ol2 e1OL2 = pe1ol2 
    inductionOp {_} {_} {p} pv2 psing2 pe1ol2 pe2ol2 e2OL2 = pe2ol2 
    e1L' : TwoPointed01Term
    e1L'  = e1L 
    e2L' : TwoPointed01Term
    e2L'  = e2L 
    stageB : (TwoPointed01Term -> (Staged TwoPointed01Term))
    stageB e1L = (Now e1L) 
    stageB e2L = (Now e2L) 
    e1Cl' : {A : Set} -> (ClTwoPointed01Term A)
    e1Cl'  = e1Cl 
    e2Cl' : {A : Set} -> (ClTwoPointed01Term A)
    e2Cl'  = e2Cl 
    stageCl : {A : Set} -> ((ClTwoPointed01Term A) -> (Staged (ClTwoPointed01Term A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl e1Cl = (Now e1Cl) 
    stageCl e2Cl = (Now e2Cl) 
    e1OL' : {n : Nat} -> (OpTwoPointed01Term n)
    e1OL'  = e1OL 
    e2OL' : {n : Nat} -> (OpTwoPointed01Term n)
    e2OL'  = e2OL 
    stageOpB : {n : Nat} -> ((OpTwoPointed01Term n) -> (Staged (OpTwoPointed01Term n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB e1OL = (Now e1OL) 
    stageOpB e2OL = (Now e2OL) 
    e1OL2' : {n : Nat} {A : Set} -> (OpTwoPointed01Term2 n A)
    e1OL2'  = e1OL2 
    e2OL2' : {n : Nat} {A : Set} -> (OpTwoPointed01Term2 n A)
    e2OL2'  = e2OL2 
    stageOp : {n : Nat} {A : Set} -> ((OpTwoPointed01Term2 n A) -> (Staged (OpTwoPointed01Term2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp e1OL2 = (Now e1OL2) 
    stageOp e2OL2 = (Now e2OL2) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        e1T : (Repr A)
        e2T : (Repr A)
  module UnaryAntiDistribution  where
    record UnaryAntiDistribution (A : Set) : Set where
      constructor UnaryAntiDistributionC
      field
        prim : (A -> A)
        op : (A -> (A -> A))
        antidis_prim_op : {x y : A} -> (prim (op x y)) == (op (prim y) (prim x))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        primS : (AS -> AS)
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        primP : ((Prod A A) -> (Prod A A))
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        antidis_prim_opP : {xP yP : (Prod A A)} -> (primP (opP xP yP)) == (opP (primP yP) (primP xP))
    record Hom {A1 : Set} {A2 : Set} (Un1 : (UnaryAntiDistribution A1)) (Un2 : (UnaryAntiDistribution A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-prim : {x1 : A1} -> (hom ((prim Un1) x1)) == ((prim Un2) (hom x1))
        pres-op : {x1 x2 : A1} -> (hom ((op Un1) x1 x2)) == ((op Un2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Un1 : (UnaryAntiDistribution A1)) (Un2 : (UnaryAntiDistribution A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim Un1) x1) ((prim Un2) y1)))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Un1) x1 x2) ((op Un2) y1 y2))))
    data UnaryAntiDistributionTerm  : Set where
      primL : (UnaryAntiDistributionTerm -> UnaryAntiDistributionTerm)
      opL : (UnaryAntiDistributionTerm -> (UnaryAntiDistributionTerm -> UnaryAntiDistributionTerm))
    data ClUnaryAntiDistributionTerm (A : Set) : Set where
      sing : (A -> (ClUnaryAntiDistributionTerm A))
      primCl : ((ClUnaryAntiDistributionTerm A) -> (ClUnaryAntiDistributionTerm A))
      opCl : ((ClUnaryAntiDistributionTerm A) -> ((ClUnaryAntiDistributionTerm A) -> (ClUnaryAntiDistributionTerm A)))
    data OpUnaryAntiDistributionTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpUnaryAntiDistributionTerm n))
      primOL : ((OpUnaryAntiDistributionTerm n) -> (OpUnaryAntiDistributionTerm n))
      opOL : ((OpUnaryAntiDistributionTerm n) -> ((OpUnaryAntiDistributionTerm n) -> (OpUnaryAntiDistributionTerm n)))
    data OpUnaryAntiDistributionTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpUnaryAntiDistributionTerm2 n A))
      sing2 : (A -> (OpUnaryAntiDistributionTerm2 n A))
      primOL2 : ((OpUnaryAntiDistributionTerm2 n A) -> (OpUnaryAntiDistributionTerm2 n A))
      opOL2 : ((OpUnaryAntiDistributionTerm2 n A) -> ((OpUnaryAntiDistributionTerm2 n A) -> (OpUnaryAntiDistributionTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClUnaryAntiDistributionTerm A) -> (ClUnaryAntiDistributionTerm A))
    simplifyCl (opCl (primCl y) (primCl x)) = (primCl (opCl x y)) 
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpUnaryAntiDistributionTerm n) -> (OpUnaryAntiDistributionTerm n))
    simplifyOpB (opOL (primOL y) (primOL x)) = (primOL (opOL x y)) 
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpUnaryAntiDistributionTerm2 n A) -> (OpUnaryAntiDistributionTerm2 n A))
    simplifyOp (opOL2 (primOL2 y) (primOL2 x)) = (primOL2 (opOL2 x y)) 
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((UnaryAntiDistribution A) -> (UnaryAntiDistributionTerm -> A))
    evalB Un (primL x1) = ((prim Un) (evalB Un x1)) 
    evalB Un (opL x1 x2) = ((op Un) (evalB Un x1) (evalB Un x2)) 
    evalCl : {A : Set} -> ((UnaryAntiDistribution A) -> ((ClUnaryAntiDistributionTerm A) -> A))
    evalCl Un (sing x1) = x1 
    evalCl Un (primCl x1) = ((prim Un) (evalCl Un x1)) 
    evalCl Un (opCl x1 x2) = ((op Un) (evalCl Un x1) (evalCl Un x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((UnaryAntiDistribution A) -> ((Vec A n) -> ((OpUnaryAntiDistributionTerm n) -> A)))
    evalOpB Un vars (v x1) = (lookup _ x1 vars) 
    evalOpB Un vars (primOL x1) = ((prim Un) (evalOpB Un vars x1)) 
    evalOpB Un vars (opOL x1 x2) = ((op Un) (evalOpB Un vars x1) (evalOpB Un vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((UnaryAntiDistribution A) -> ((Vec A n) -> ((OpUnaryAntiDistributionTerm2 n A) -> A)))
    evalOp Un vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Un vars (sing2 x1) = x1 
    evalOp Un vars (primOL2 x1) = ((prim Un) (evalOp Un vars x1)) 
    evalOp Un vars (opOL2 x1 x2) = ((op Un) (evalOp Un vars x1) (evalOp Un vars x2)) 
    inductionB : {P : (UnaryAntiDistributionTerm -> Set)} -> (((x1 : UnaryAntiDistributionTerm) -> ((P x1) -> (P (primL x1)))) -> (((x1 x2 : UnaryAntiDistributionTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : UnaryAntiDistributionTerm) -> (P x))))
    inductionB {p} ppriml popl (primL x1) = (ppriml _ (inductionB {p} ppriml popl x1)) 
    inductionB {p} ppriml popl (opL x1 x2) = (popl _ _ (inductionB {p} ppriml popl x1) (inductionB {p} ppriml popl x2)) 
    inductionCl : {A : Set} {P : ((ClUnaryAntiDistributionTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 : (ClUnaryAntiDistributionTerm A)) -> ((P x1) -> (P (primCl x1)))) -> (((x1 x2 : (ClUnaryAntiDistributionTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClUnaryAntiDistributionTerm A)) -> (P x)))))
    inductionCl {_} {p} psing pprimcl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pprimcl popcl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing pprimcl popcl x1)) 
    inductionCl {_} {p} psing pprimcl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing pprimcl popcl x1) (inductionCl {_} {p} psing pprimcl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpUnaryAntiDistributionTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 : (OpUnaryAntiDistributionTerm n)) -> ((P x1) -> (P (primOL x1)))) -> (((x1 x2 : (OpUnaryAntiDistributionTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpUnaryAntiDistributionTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv pprimol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pprimol popol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv pprimol popol x1)) 
    inductionOpB {_} {p} pv pprimol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv pprimol popol x1) (inductionOpB {_} {p} pv pprimol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpUnaryAntiDistributionTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 : (OpUnaryAntiDistributionTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> (((x1 x2 : (OpUnaryAntiDistributionTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpUnaryAntiDistributionTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 x2)) 
    primL' : (UnaryAntiDistributionTerm -> UnaryAntiDistributionTerm)
    primL' x1 = (primL x1) 
    opL' : (UnaryAntiDistributionTerm -> (UnaryAntiDistributionTerm -> UnaryAntiDistributionTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (UnaryAntiDistributionTerm -> (Staged UnaryAntiDistributionTerm))
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    primCl' : {A : Set} -> ((ClUnaryAntiDistributionTerm A) -> (ClUnaryAntiDistributionTerm A))
    primCl' x1 = (primCl x1) 
    opCl' : {A : Set} -> ((ClUnaryAntiDistributionTerm A) -> ((ClUnaryAntiDistributionTerm A) -> (ClUnaryAntiDistributionTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClUnaryAntiDistributionTerm A) -> (Staged (ClUnaryAntiDistributionTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    primOL' : {n : Nat} -> ((OpUnaryAntiDistributionTerm n) -> (OpUnaryAntiDistributionTerm n))
    primOL' x1 = (primOL x1) 
    opOL' : {n : Nat} -> ((OpUnaryAntiDistributionTerm n) -> ((OpUnaryAntiDistributionTerm n) -> (OpUnaryAntiDistributionTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpUnaryAntiDistributionTerm n) -> (Staged (OpUnaryAntiDistributionTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    primOL2' : {n : Nat} {A : Set} -> ((OpUnaryAntiDistributionTerm2 n A) -> (OpUnaryAntiDistributionTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    opOL2' : {n : Nat} {A : Set} -> ((OpUnaryAntiDistributionTerm2 n A) -> ((OpUnaryAntiDistributionTerm2 n A) -> (OpUnaryAntiDistributionTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpUnaryAntiDistributionTerm2 n A) -> (Staged (OpUnaryAntiDistributionTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        primT : ((Repr A) -> (Repr A))
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module UnaryDistributes  where
    record UnaryDistributes (A : Set) : Set where
      constructor UnaryDistributesC
      field
        prim : (A -> A)
        op : (A -> (A -> A))
        distribute_prim_op : {x y : A} -> (prim (op x y)) == (op (prim x) (prim y))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        primS : (AS -> AS)
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        primP : ((Prod A A) -> (Prod A A))
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        distribute_prim_opP : {xP yP : (Prod A A)} -> (primP (opP xP yP)) == (opP (primP xP) (primP yP))
    record Hom {A1 : Set} {A2 : Set} (Un1 : (UnaryDistributes A1)) (Un2 : (UnaryDistributes A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-prim : {x1 : A1} -> (hom ((prim Un1) x1)) == ((prim Un2) (hom x1))
        pres-op : {x1 x2 : A1} -> (hom ((op Un1) x1 x2)) == ((op Un2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Un1 : (UnaryDistributes A1)) (Un2 : (UnaryDistributes A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim Un1) x1) ((prim Un2) y1)))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Un1) x1 x2) ((op Un2) y1 y2))))
    data UnaryDistributesTerm  : Set where
      primL : (UnaryDistributesTerm -> UnaryDistributesTerm)
      opL : (UnaryDistributesTerm -> (UnaryDistributesTerm -> UnaryDistributesTerm))
    data ClUnaryDistributesTerm (A : Set) : Set where
      sing : (A -> (ClUnaryDistributesTerm A))
      primCl : ((ClUnaryDistributesTerm A) -> (ClUnaryDistributesTerm A))
      opCl : ((ClUnaryDistributesTerm A) -> ((ClUnaryDistributesTerm A) -> (ClUnaryDistributesTerm A)))
    data OpUnaryDistributesTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpUnaryDistributesTerm n))
      primOL : ((OpUnaryDistributesTerm n) -> (OpUnaryDistributesTerm n))
      opOL : ((OpUnaryDistributesTerm n) -> ((OpUnaryDistributesTerm n) -> (OpUnaryDistributesTerm n)))
    data OpUnaryDistributesTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpUnaryDistributesTerm2 n A))
      sing2 : (A -> (OpUnaryDistributesTerm2 n A))
      primOL2 : ((OpUnaryDistributesTerm2 n A) -> (OpUnaryDistributesTerm2 n A))
      opOL2 : ((OpUnaryDistributesTerm2 n A) -> ((OpUnaryDistributesTerm2 n A) -> (OpUnaryDistributesTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClUnaryDistributesTerm A) -> (ClUnaryDistributesTerm A))
    simplifyCl (opCl (primCl x) (primCl y)) = (primCl (opCl x y)) 
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpUnaryDistributesTerm n) -> (OpUnaryDistributesTerm n))
    simplifyOpB (opOL (primOL x) (primOL y)) = (primOL (opOL x y)) 
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpUnaryDistributesTerm2 n A) -> (OpUnaryDistributesTerm2 n A))
    simplifyOp (opOL2 (primOL2 x) (primOL2 y)) = (primOL2 (opOL2 x y)) 
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((UnaryDistributes A) -> (UnaryDistributesTerm -> A))
    evalB Un (primL x1) = ((prim Un) (evalB Un x1)) 
    evalB Un (opL x1 x2) = ((op Un) (evalB Un x1) (evalB Un x2)) 
    evalCl : {A : Set} -> ((UnaryDistributes A) -> ((ClUnaryDistributesTerm A) -> A))
    evalCl Un (sing x1) = x1 
    evalCl Un (primCl x1) = ((prim Un) (evalCl Un x1)) 
    evalCl Un (opCl x1 x2) = ((op Un) (evalCl Un x1) (evalCl Un x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((UnaryDistributes A) -> ((Vec A n) -> ((OpUnaryDistributesTerm n) -> A)))
    evalOpB Un vars (v x1) = (lookup _ x1 vars) 
    evalOpB Un vars (primOL x1) = ((prim Un) (evalOpB Un vars x1)) 
    evalOpB Un vars (opOL x1 x2) = ((op Un) (evalOpB Un vars x1) (evalOpB Un vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((UnaryDistributes A) -> ((Vec A n) -> ((OpUnaryDistributesTerm2 n A) -> A)))
    evalOp Un vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Un vars (sing2 x1) = x1 
    evalOp Un vars (primOL2 x1) = ((prim Un) (evalOp Un vars x1)) 
    evalOp Un vars (opOL2 x1 x2) = ((op Un) (evalOp Un vars x1) (evalOp Un vars x2)) 
    inductionB : {P : (UnaryDistributesTerm -> Set)} -> (((x1 : UnaryDistributesTerm) -> ((P x1) -> (P (primL x1)))) -> (((x1 x2 : UnaryDistributesTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : UnaryDistributesTerm) -> (P x))))
    inductionB {p} ppriml popl (primL x1) = (ppriml _ (inductionB {p} ppriml popl x1)) 
    inductionB {p} ppriml popl (opL x1 x2) = (popl _ _ (inductionB {p} ppriml popl x1) (inductionB {p} ppriml popl x2)) 
    inductionCl : {A : Set} {P : ((ClUnaryDistributesTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 : (ClUnaryDistributesTerm A)) -> ((P x1) -> (P (primCl x1)))) -> (((x1 x2 : (ClUnaryDistributesTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClUnaryDistributesTerm A)) -> (P x)))))
    inductionCl {_} {p} psing pprimcl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pprimcl popcl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing pprimcl popcl x1)) 
    inductionCl {_} {p} psing pprimcl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing pprimcl popcl x1) (inductionCl {_} {p} psing pprimcl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpUnaryDistributesTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 : (OpUnaryDistributesTerm n)) -> ((P x1) -> (P (primOL x1)))) -> (((x1 x2 : (OpUnaryDistributesTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpUnaryDistributesTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv pprimol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pprimol popol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv pprimol popol x1)) 
    inductionOpB {_} {p} pv pprimol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv pprimol popol x1) (inductionOpB {_} {p} pv pprimol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpUnaryDistributesTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 : (OpUnaryDistributesTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> (((x1 x2 : (OpUnaryDistributesTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpUnaryDistributesTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 x1)) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 pprimol2 popol2 x2)) 
    primL' : (UnaryDistributesTerm -> UnaryDistributesTerm)
    primL' x1 = (primL x1) 
    opL' : (UnaryDistributesTerm -> (UnaryDistributesTerm -> UnaryDistributesTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (UnaryDistributesTerm -> (Staged UnaryDistributesTerm))
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    primCl' : {A : Set} -> ((ClUnaryDistributesTerm A) -> (ClUnaryDistributesTerm A))
    primCl' x1 = (primCl x1) 
    opCl' : {A : Set} -> ((ClUnaryDistributesTerm A) -> ((ClUnaryDistributesTerm A) -> (ClUnaryDistributesTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClUnaryDistributesTerm A) -> (Staged (ClUnaryDistributesTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    primOL' : {n : Nat} -> ((OpUnaryDistributesTerm n) -> (OpUnaryDistributesTerm n))
    primOL' x1 = (primOL x1) 
    opOL' : {n : Nat} -> ((OpUnaryDistributesTerm n) -> ((OpUnaryDistributesTerm n) -> (OpUnaryDistributesTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpUnaryDistributesTerm n) -> (Staged (OpUnaryDistributesTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    primOL2' : {n : Nat} {A : Set} -> ((OpUnaryDistributesTerm2 n A) -> (OpUnaryDistributesTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    opOL2' : {n : Nat} {A : Set} -> ((OpUnaryDistributesTerm2 n A) -> ((OpUnaryDistributesTerm2 n A) -> (OpUnaryDistributesTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpUnaryDistributesTerm2 n A) -> (Staged (OpUnaryDistributesTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        primT : ((Repr A) -> (Repr A))
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module UnaryOperation  where
    record UnaryOperation (A : Set) : Set where
      constructor UnaryOperationC
      field
        prim : (A -> A)
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        primS : (AS -> AS)
    record Product (A : Set) : Set where
      constructor ProductC
      field
        primP : ((Prod A A) -> (Prod A A))
    record Hom {A1 : Set} {A2 : Set} (Un1 : (UnaryOperation A1)) (Un2 : (UnaryOperation A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-prim : {x1 : A1} -> (hom ((prim Un1) x1)) == ((prim Un2) (hom x1))
    record RelInterp {A1 : Set} {A2 : Set} (Un1 : (UnaryOperation A1)) (Un2 : (UnaryOperation A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-prim : {x1 : A1} {y1 : A2} -> ((interp x1 y1) -> (interp ((prim Un1) x1) ((prim Un2) y1)))
    data UnaryOperationTerm  : Set where
      primL : (UnaryOperationTerm -> UnaryOperationTerm)
    data ClUnaryOperationTerm (A : Set) : Set where
      sing : (A -> (ClUnaryOperationTerm A))
      primCl : ((ClUnaryOperationTerm A) -> (ClUnaryOperationTerm A))
    data OpUnaryOperationTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpUnaryOperationTerm n))
      primOL : ((OpUnaryOperationTerm n) -> (OpUnaryOperationTerm n))
    data OpUnaryOperationTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpUnaryOperationTerm2 n A))
      sing2 : (A -> (OpUnaryOperationTerm2 n A))
      primOL2 : ((OpUnaryOperationTerm2 n A) -> (OpUnaryOperationTerm2 n A))
    simplifyCl : {A : Set} -> ((ClUnaryOperationTerm A) -> (ClUnaryOperationTerm A))
    simplifyCl (primCl x1) = (primCl (simplifyCl x1)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpUnaryOperationTerm n) -> (OpUnaryOperationTerm n))
    simplifyOpB (primOL x1) = (primOL (simplifyOpB x1)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpUnaryOperationTerm2 n A) -> (OpUnaryOperationTerm2 n A))
    simplifyOp (primOL2 x1) = (primOL2 (simplifyOp x1)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((UnaryOperation A) -> (UnaryOperationTerm -> A))
    evalB Un (primL x1) = ((prim Un) (evalB Un x1)) 
    evalCl : {A : Set} -> ((UnaryOperation A) -> ((ClUnaryOperationTerm A) -> A))
    evalCl Un (sing x1) = x1 
    evalCl Un (primCl x1) = ((prim Un) (evalCl Un x1)) 
    evalOpB : {A : Set} {n : Nat} -> ((UnaryOperation A) -> ((Vec A n) -> ((OpUnaryOperationTerm n) -> A)))
    evalOpB Un vars (v x1) = (lookup _ x1 vars) 
    evalOpB Un vars (primOL x1) = ((prim Un) (evalOpB Un vars x1)) 
    evalOp : {A : Set} {n : Nat} -> ((UnaryOperation A) -> ((Vec A n) -> ((OpUnaryOperationTerm2 n A) -> A)))
    evalOp Un vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Un vars (sing2 x1) = x1 
    evalOp Un vars (primOL2 x1) = ((prim Un) (evalOp Un vars x1)) 
    inductionB : {P : (UnaryOperationTerm -> Set)} -> (((x1 : UnaryOperationTerm) -> ((P x1) -> (P (primL x1)))) -> ((x : UnaryOperationTerm) -> (P x)))
    inductionB {p} ppriml (primL x1) = (ppriml _ (inductionB {p} ppriml x1)) 
    inductionCl : {A : Set} {P : ((ClUnaryOperationTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> (((x1 : (ClUnaryOperationTerm A)) -> ((P x1) -> (P (primCl x1)))) -> ((x : (ClUnaryOperationTerm A)) -> (P x))))
    inductionCl {_} {p} psing pprimcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pprimcl (primCl x1) = (pprimcl _ (inductionCl {_} {p} psing pprimcl x1)) 
    inductionOpB : {n : Nat} {P : ((OpUnaryOperationTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> (((x1 : (OpUnaryOperationTerm n)) -> ((P x1) -> (P (primOL x1)))) -> ((x : (OpUnaryOperationTerm n)) -> (P x))))
    inductionOpB {_} {p} pv pprimol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv pprimol (primOL x1) = (pprimol _ (inductionOpB {_} {p} pv pprimol x1)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpUnaryOperationTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> (((x1 : (OpUnaryOperationTerm2 n A)) -> ((P x1) -> (P (primOL2 x1)))) -> ((x : (OpUnaryOperationTerm2 n A)) -> (P x)))))
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 pprimol2 (primOL2 x1) = (pprimol2 _ (inductionOp {_} {_} {p} pv2 psing2 pprimol2 x1)) 
    primL' : (UnaryOperationTerm -> UnaryOperationTerm)
    primL' x1 = (primL x1) 
    stageB : (UnaryOperationTerm -> (Staged UnaryOperationTerm))
    stageB (primL x1) = (stage1 primL' (codeLift1 primL') (stageB x1)) 
    primCl' : {A : Set} -> ((ClUnaryOperationTerm A) -> (ClUnaryOperationTerm A))
    primCl' x1 = (primCl x1) 
    stageCl : {A : Set} -> ((ClUnaryOperationTerm A) -> (Staged (ClUnaryOperationTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl (primCl x1) = (stage1 primCl' (codeLift1 primCl') (stageCl x1)) 
    primOL' : {n : Nat} -> ((OpUnaryOperationTerm n) -> (OpUnaryOperationTerm n))
    primOL' x1 = (primOL x1) 
    stageOpB : {n : Nat} -> ((OpUnaryOperationTerm n) -> (Staged (OpUnaryOperationTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB (primOL x1) = (stage1 primOL' (codeLift1 primOL') (stageOpB x1)) 
    primOL2' : {n : Nat} {A : Set} -> ((OpUnaryOperationTerm2 n A) -> (OpUnaryOperationTerm2 n A))
    primOL2' x1 = (primOL2 x1) 
    stageOp : {n : Nat} {A : Set} -> ((OpUnaryOperationTerm2 n A) -> (Staged (OpUnaryOperationTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp (primOL2 x1) = (stage1 primOL2' (codeLift1 primOL2') (stageOp x1)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        primT : ((Repr A) -> (Repr A))
  module UnipotentPointedMagma  where
    record UnipotentPointedMagma (A : Set) : Set where
      constructor UnipotentPointedMagmaC
      field
        e : A
        op : (A -> (A -> A))
        unipotence : {x : A} -> (op x x) == e
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        eS : AS
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        eP : (Prod A A)
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        unipotenceP : {xP : (Prod A A)} -> (opP xP xP) == eP
    record Hom {A1 : Set} {A2 : Set} (Un1 : (UnipotentPointedMagma A1)) (Un2 : (UnipotentPointedMagma A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-e : (hom (e Un1)) == (e Un2)
        pres-op : {x1 x2 : A1} -> (hom ((op Un1) x1 x2)) == ((op Un2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Un1 : (UnipotentPointedMagma A1)) (Un2 : (UnipotentPointedMagma A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-e : (interp (e Un1) (e Un2))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Un1) x1 x2) ((op Un2) y1 y2))))
    data UnipotentPointedMagmaTerm  : Set where
      eL : UnipotentPointedMagmaTerm
      opL : (UnipotentPointedMagmaTerm -> (UnipotentPointedMagmaTerm -> UnipotentPointedMagmaTerm))
    data ClUnipotentPointedMagmaTerm (A : Set) : Set where
      sing : (A -> (ClUnipotentPointedMagmaTerm A))
      eCl : (ClUnipotentPointedMagmaTerm A)
      opCl : ((ClUnipotentPointedMagmaTerm A) -> ((ClUnipotentPointedMagmaTerm A) -> (ClUnipotentPointedMagmaTerm A)))
    data OpUnipotentPointedMagmaTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpUnipotentPointedMagmaTerm n))
      eOL : (OpUnipotentPointedMagmaTerm n)
      opOL : ((OpUnipotentPointedMagmaTerm n) -> ((OpUnipotentPointedMagmaTerm n) -> (OpUnipotentPointedMagmaTerm n)))
    data OpUnipotentPointedMagmaTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpUnipotentPointedMagmaTerm2 n A))
      sing2 : (A -> (OpUnipotentPointedMagmaTerm2 n A))
      eOL2 : (OpUnipotentPointedMagmaTerm2 n A)
      opOL2 : ((OpUnipotentPointedMagmaTerm2 n A) -> ((OpUnipotentPointedMagmaTerm2 n A) -> (OpUnipotentPointedMagmaTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClUnipotentPointedMagmaTerm A) -> (ClUnipotentPointedMagmaTerm A))
    simplifyCl eCl = eCl 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpUnipotentPointedMagmaTerm n) -> (OpUnipotentPointedMagmaTerm n))
    simplifyOpB eOL = eOL 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpUnipotentPointedMagmaTerm2 n A) -> (OpUnipotentPointedMagmaTerm2 n A))
    simplifyOp eOL2 = eOL2 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((UnipotentPointedMagma A) -> (UnipotentPointedMagmaTerm -> A))
    evalB Un eL = (e Un) 
    evalB Un (opL x1 x2) = ((op Un) (evalB Un x1) (evalB Un x2)) 
    evalCl : {A : Set} -> ((UnipotentPointedMagma A) -> ((ClUnipotentPointedMagmaTerm A) -> A))
    evalCl Un (sing x1) = x1 
    evalCl Un eCl = (e Un) 
    evalCl Un (opCl x1 x2) = ((op Un) (evalCl Un x1) (evalCl Un x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((UnipotentPointedMagma A) -> ((Vec A n) -> ((OpUnipotentPointedMagmaTerm n) -> A)))
    evalOpB Un vars (v x1) = (lookup _ x1 vars) 
    evalOpB Un vars eOL = (e Un) 
    evalOpB Un vars (opOL x1 x2) = ((op Un) (evalOpB Un vars x1) (evalOpB Un vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((UnipotentPointedMagma A) -> ((Vec A n) -> ((OpUnipotentPointedMagmaTerm2 n A) -> A)))
    evalOp Un vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Un vars (sing2 x1) = x1 
    evalOp Un vars eOL2 = (e Un) 
    evalOp Un vars (opOL2 x1 x2) = ((op Un) (evalOp Un vars x1) (evalOp Un vars x2)) 
    inductionB : {P : (UnipotentPointedMagmaTerm -> Set)} -> ((P eL) -> (((x1 x2 : UnipotentPointedMagmaTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : UnipotentPointedMagmaTerm) -> (P x))))
    inductionB {p} pel popl eL = pel 
    inductionB {p} pel popl (opL x1 x2) = (popl _ _ (inductionB {p} pel popl x1) (inductionB {p} pel popl x2)) 
    inductionCl : {A : Set} {P : ((ClUnipotentPointedMagmaTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P eCl) -> (((x1 x2 : (ClUnipotentPointedMagmaTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClUnipotentPointedMagmaTerm A)) -> (P x)))))
    inductionCl {_} {p} psing pecl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pecl popcl eCl = pecl 
    inductionCl {_} {p} psing pecl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing pecl popcl x1) (inductionCl {_} {p} psing pecl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpUnipotentPointedMagmaTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P eOL) -> (((x1 x2 : (OpUnipotentPointedMagmaTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpUnipotentPointedMagmaTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv peol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv peol popol eOL = peol 
    inductionOpB {_} {p} pv peol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv peol popol x1) (inductionOpB {_} {p} pv peol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpUnipotentPointedMagmaTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P eOL2) -> (((x1 x2 : (OpUnipotentPointedMagmaTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpUnipotentPointedMagmaTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 eOL2 = peol2 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 x2)) 
    eL' : UnipotentPointedMagmaTerm
    eL'  = eL 
    opL' : (UnipotentPointedMagmaTerm -> (UnipotentPointedMagmaTerm -> UnipotentPointedMagmaTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (UnipotentPointedMagmaTerm -> (Staged UnipotentPointedMagmaTerm))
    stageB eL = (Now eL) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    eCl' : {A : Set} -> (ClUnipotentPointedMagmaTerm A)
    eCl'  = eCl 
    opCl' : {A : Set} -> ((ClUnipotentPointedMagmaTerm A) -> ((ClUnipotentPointedMagmaTerm A) -> (ClUnipotentPointedMagmaTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClUnipotentPointedMagmaTerm A) -> (Staged (ClUnipotentPointedMagmaTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl eCl = (Now eCl) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    eOL' : {n : Nat} -> (OpUnipotentPointedMagmaTerm n)
    eOL'  = eOL 
    opOL' : {n : Nat} -> ((OpUnipotentPointedMagmaTerm n) -> ((OpUnipotentPointedMagmaTerm n) -> (OpUnipotentPointedMagmaTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpUnipotentPointedMagmaTerm n) -> (Staged (OpUnipotentPointedMagmaTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB eOL = (Now eOL) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    eOL2' : {n : Nat} {A : Set} -> (OpUnipotentPointedMagmaTerm2 n A)
    eOL2'  = eOL2 
    opOL2' : {n : Nat} {A : Set} -> ((OpUnipotentPointedMagmaTerm2 n A) -> ((OpUnipotentPointedMagmaTerm2 n A) -> (OpUnipotentPointedMagmaTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpUnipotentPointedMagmaTerm2 n A) -> (Staged (OpUnipotentPointedMagmaTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp eOL2 = (Now eOL2) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        eT : (Repr A)
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module Unital  where
    record Unital (A : Set) : Set where
      constructor UnitalC
      field
        e : A
        op : (A -> (A -> A))
        lunit_e : {x : A} -> (op e x) == x
        runit_e : {x : A} -> (op x e) == x
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        eS : AS
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        eP : (Prod A A)
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        lunit_eP : {xP : (Prod A A)} -> (opP eP xP) == xP
        runit_eP : {xP : (Prod A A)} -> (opP xP eP) == xP
    record Hom {A1 : Set} {A2 : Set} (Un1 : (Unital A1)) (Un2 : (Unital A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-e : (hom (e Un1)) == (e Un2)
        pres-op : {x1 x2 : A1} -> (hom ((op Un1) x1 x2)) == ((op Un2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Un1 : (Unital A1)) (Un2 : (Unital A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-e : (interp (e Un1) (e Un2))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Un1) x1 x2) ((op Un2) y1 y2))))
    data UnitalTerm  : Set where
      eL : UnitalTerm
      opL : (UnitalTerm -> (UnitalTerm -> UnitalTerm))
    data ClUnitalTerm (A : Set) : Set where
      sing : (A -> (ClUnitalTerm A))
      eCl : (ClUnitalTerm A)
      opCl : ((ClUnitalTerm A) -> ((ClUnitalTerm A) -> (ClUnitalTerm A)))
    data OpUnitalTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpUnitalTerm n))
      eOL : (OpUnitalTerm n)
      opOL : ((OpUnitalTerm n) -> ((OpUnitalTerm n) -> (OpUnitalTerm n)))
    data OpUnitalTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpUnitalTerm2 n A))
      sing2 : (A -> (OpUnitalTerm2 n A))
      eOL2 : (OpUnitalTerm2 n A)
      opOL2 : ((OpUnitalTerm2 n A) -> ((OpUnitalTerm2 n A) -> (OpUnitalTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClUnitalTerm A) -> (ClUnitalTerm A))
    simplifyCl (opCl eCl x) = x 
    simplifyCl (opCl x eCl) = x 
    simplifyCl eCl = eCl 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpUnitalTerm n) -> (OpUnitalTerm n))
    simplifyOpB (opOL eOL x) = x 
    simplifyOpB (opOL x eOL) = x 
    simplifyOpB eOL = eOL 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpUnitalTerm2 n A) -> (OpUnitalTerm2 n A))
    simplifyOp (opOL2 eOL2 x) = x 
    simplifyOp (opOL2 x eOL2) = x 
    simplifyOp eOL2 = eOL2 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Unital A) -> (UnitalTerm -> A))
    evalB Un eL = (e Un) 
    evalB Un (opL x1 x2) = ((op Un) (evalB Un x1) (evalB Un x2)) 
    evalCl : {A : Set} -> ((Unital A) -> ((ClUnitalTerm A) -> A))
    evalCl Un (sing x1) = x1 
    evalCl Un eCl = (e Un) 
    evalCl Un (opCl x1 x2) = ((op Un) (evalCl Un x1) (evalCl Un x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Unital A) -> ((Vec A n) -> ((OpUnitalTerm n) -> A)))
    evalOpB Un vars (v x1) = (lookup _ x1 vars) 
    evalOpB Un vars eOL = (e Un) 
    evalOpB Un vars (opOL x1 x2) = ((op Un) (evalOpB Un vars x1) (evalOpB Un vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Unital A) -> ((Vec A n) -> ((OpUnitalTerm2 n A) -> A)))
    evalOp Un vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Un vars (sing2 x1) = x1 
    evalOp Un vars eOL2 = (e Un) 
    evalOp Un vars (opOL2 x1 x2) = ((op Un) (evalOp Un vars x1) (evalOp Un vars x2)) 
    inductionB : {P : (UnitalTerm -> Set)} -> ((P eL) -> (((x1 x2 : UnitalTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : UnitalTerm) -> (P x))))
    inductionB {p} pel popl eL = pel 
    inductionB {p} pel popl (opL x1 x2) = (popl _ _ (inductionB {p} pel popl x1) (inductionB {p} pel popl x2)) 
    inductionCl : {A : Set} {P : ((ClUnitalTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P eCl) -> (((x1 x2 : (ClUnitalTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClUnitalTerm A)) -> (P x)))))
    inductionCl {_} {p} psing pecl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pecl popcl eCl = pecl 
    inductionCl {_} {p} psing pecl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing pecl popcl x1) (inductionCl {_} {p} psing pecl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpUnitalTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P eOL) -> (((x1 x2 : (OpUnitalTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpUnitalTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv peol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv peol popol eOL = peol 
    inductionOpB {_} {p} pv peol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv peol popol x1) (inductionOpB {_} {p} pv peol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpUnitalTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P eOL2) -> (((x1 x2 : (OpUnitalTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpUnitalTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 eOL2 = peol2 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 x2)) 
    eL' : UnitalTerm
    eL'  = eL 
    opL' : (UnitalTerm -> (UnitalTerm -> UnitalTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (UnitalTerm -> (Staged UnitalTerm))
    stageB eL = (Now eL) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    eCl' : {A : Set} -> (ClUnitalTerm A)
    eCl'  = eCl 
    opCl' : {A : Set} -> ((ClUnitalTerm A) -> ((ClUnitalTerm A) -> (ClUnitalTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClUnitalTerm A) -> (Staged (ClUnitalTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl eCl = (Now eCl) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    eOL' : {n : Nat} -> (OpUnitalTerm n)
    eOL'  = eOL 
    opOL' : {n : Nat} -> ((OpUnitalTerm n) -> ((OpUnitalTerm n) -> (OpUnitalTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpUnitalTerm n) -> (Staged (OpUnitalTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB eOL = (Now eOL) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    eOL2' : {n : Nat} {A : Set} -> (OpUnitalTerm2 n A)
    eOL2'  = eOL2 
    opOL2' : {n : Nat} {A : Set} -> ((OpUnitalTerm2 n A) -> ((OpUnitalTerm2 n A) -> (OpUnitalTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpUnitalTerm2 n A) -> (Staged (OpUnitalTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp eOL2 = (Now eOL2) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        eT : (Repr A)
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module Zero  where
    record Zero (A : Set) : Set where
      constructor ZeroC
      field
        e : A
        op : (A -> (A -> A))
        leftZero_op_e : {x : A} -> (op e x) == e
        rightZero_op_e : {x : A} -> (op x e) == e
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        eS : AS
        opS : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        eP : (Prod A A)
        opP : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftZero_op_eP : {xP : (Prod A A)} -> (opP eP xP) == eP
        rightZero_op_eP : {xP : (Prod A A)} -> (opP xP eP) == eP
    record Hom {A1 : Set} {A2 : Set} (Ze1 : (Zero A1)) (Ze2 : (Zero A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-e : (hom (e Ze1)) == (e Ze2)
        pres-op : {x1 x2 : A1} -> (hom ((op Ze1) x1 x2)) == ((op Ze2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ze1 : (Zero A1)) (Ze2 : (Zero A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-e : (interp (e Ze1) (e Ze2))
        interp-op : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((op Ze1) x1 x2) ((op Ze2) y1 y2))))
    data ZeroTerm  : Set where
      eL : ZeroTerm
      opL : (ZeroTerm -> (ZeroTerm -> ZeroTerm))
    data ClZeroTerm (A : Set) : Set where
      sing : (A -> (ClZeroTerm A))
      eCl : (ClZeroTerm A)
      opCl : ((ClZeroTerm A) -> ((ClZeroTerm A) -> (ClZeroTerm A)))
    data OpZeroTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpZeroTerm n))
      eOL : (OpZeroTerm n)
      opOL : ((OpZeroTerm n) -> ((OpZeroTerm n) -> (OpZeroTerm n)))
    data OpZeroTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpZeroTerm2 n A))
      sing2 : (A -> (OpZeroTerm2 n A))
      eOL2 : (OpZeroTerm2 n A)
      opOL2 : ((OpZeroTerm2 n A) -> ((OpZeroTerm2 n A) -> (OpZeroTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClZeroTerm A) -> (ClZeroTerm A))
    simplifyCl eCl = eCl 
    simplifyCl (opCl x1 x2) = (opCl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpZeroTerm n) -> (OpZeroTerm n))
    simplifyOpB eOL = eOL 
    simplifyOpB (opOL x1 x2) = (opOL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpZeroTerm2 n A) -> (OpZeroTerm2 n A))
    simplifyOp eOL2 = eOL2 
    simplifyOp (opOL2 x1 x2) = (opOL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Zero A) -> (ZeroTerm -> A))
    evalB Ze eL = (e Ze) 
    evalB Ze (opL x1 x2) = ((op Ze) (evalB Ze x1) (evalB Ze x2)) 
    evalCl : {A : Set} -> ((Zero A) -> ((ClZeroTerm A) -> A))
    evalCl Ze (sing x1) = x1 
    evalCl Ze eCl = (e Ze) 
    evalCl Ze (opCl x1 x2) = ((op Ze) (evalCl Ze x1) (evalCl Ze x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Zero A) -> ((Vec A n) -> ((OpZeroTerm n) -> A)))
    evalOpB Ze vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ze vars eOL = (e Ze) 
    evalOpB Ze vars (opOL x1 x2) = ((op Ze) (evalOpB Ze vars x1) (evalOpB Ze vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Zero A) -> ((Vec A n) -> ((OpZeroTerm2 n A) -> A)))
    evalOp Ze vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ze vars (sing2 x1) = x1 
    evalOp Ze vars eOL2 = (e Ze) 
    evalOp Ze vars (opOL2 x1 x2) = ((op Ze) (evalOp Ze vars x1) (evalOp Ze vars x2)) 
    inductionB : {P : (ZeroTerm -> Set)} -> ((P eL) -> (((x1 x2 : ZeroTerm) -> ((P x1) -> ((P x2) -> (P (opL x1 x2))))) -> ((x : ZeroTerm) -> (P x))))
    inductionB {p} pel popl eL = pel 
    inductionB {p} pel popl (opL x1 x2) = (popl _ _ (inductionB {p} pel popl x1) (inductionB {p} pel popl x2)) 
    inductionCl : {A : Set} {P : ((ClZeroTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P eCl) -> (((x1 x2 : (ClZeroTerm A)) -> ((P x1) -> ((P x2) -> (P (opCl x1 x2))))) -> ((x : (ClZeroTerm A)) -> (P x)))))
    inductionCl {_} {p} psing pecl popcl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing pecl popcl eCl = pecl 
    inductionCl {_} {p} psing pecl popcl (opCl x1 x2) = (popcl _ _ (inductionCl {_} {p} psing pecl popcl x1) (inductionCl {_} {p} psing pecl popcl x2)) 
    inductionOpB : {n : Nat} {P : ((OpZeroTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P eOL) -> (((x1 x2 : (OpZeroTerm n)) -> ((P x1) -> ((P x2) -> (P (opOL x1 x2))))) -> ((x : (OpZeroTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv peol popol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv peol popol eOL = peol 
    inductionOpB {_} {p} pv peol popol (opOL x1 x2) = (popol _ _ (inductionOpB {_} {p} pv peol popol x1) (inductionOpB {_} {p} pv peol popol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpZeroTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P eOL2) -> (((x1 x2 : (OpZeroTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (opOL2 x1 x2))))) -> ((x : (OpZeroTerm2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 eOL2 = peol2 
    inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 (opOL2 x1 x2) = (popol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 x1) (inductionOp {_} {_} {p} pv2 psing2 peol2 popol2 x2)) 
    eL' : ZeroTerm
    eL'  = eL 
    opL' : (ZeroTerm -> (ZeroTerm -> ZeroTerm))
    opL' x1 x2 = (opL x1 x2) 
    stageB : (ZeroTerm -> (Staged ZeroTerm))
    stageB eL = (Now eL) 
    stageB (opL x1 x2) = (stage2 opL' (codeLift2 opL') (stageB x1) (stageB x2)) 
    eCl' : {A : Set} -> (ClZeroTerm A)
    eCl'  = eCl 
    opCl' : {A : Set} -> ((ClZeroTerm A) -> ((ClZeroTerm A) -> (ClZeroTerm A)))
    opCl' x1 x2 = (opCl x1 x2) 
    stageCl : {A : Set} -> ((ClZeroTerm A) -> (Staged (ClZeroTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl eCl = (Now eCl) 
    stageCl (opCl x1 x2) = (stage2 opCl' (codeLift2 opCl') (stageCl x1) (stageCl x2)) 
    eOL' : {n : Nat} -> (OpZeroTerm n)
    eOL'  = eOL 
    opOL' : {n : Nat} -> ((OpZeroTerm n) -> ((OpZeroTerm n) -> (OpZeroTerm n)))
    opOL' x1 x2 = (opOL x1 x2) 
    stageOpB : {n : Nat} -> ((OpZeroTerm n) -> (Staged (OpZeroTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB eOL = (Now eOL) 
    stageOpB (opOL x1 x2) = (stage2 opOL' (codeLift2 opOL') (stageOpB x1) (stageOpB x2)) 
    eOL2' : {n : Nat} {A : Set} -> (OpZeroTerm2 n A)
    eOL2'  = eOL2 
    opOL2' : {n : Nat} {A : Set} -> ((OpZeroTerm2 n A) -> ((OpZeroTerm2 n A) -> (OpZeroTerm2 n A)))
    opOL2' x1 x2 = (opOL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpZeroTerm2 n A) -> (Staged (OpZeroTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp eOL2 = (Now eOL2) 
    stageOp (opOL2 x1 x2) = (stage2 opOL2' (codeLift2 opOL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        eT : (Repr A)
        opT : ((Repr A) -> ((Repr A) -> (Repr A)))
  module Zero0  where
    record Zero0 (A : Set) : Set where
      constructor Zero0C
      field
        0 : A
        * : (A -> (A -> A))
        leftZero_op_0 : {x : A} -> (* 0 x) == 0
        rightZero_op_0 : {x : A} -> (* x 0) == 0
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        0S : AS
        *S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        0P : (Prod A A)
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftZero_op_0P : {xP : (Prod A A)} -> (*P 0P xP) == 0P
        rightZero_op_0P : {xP : (Prod A A)} -> (*P xP 0P) == 0P
    record Hom {A1 : Set} {A2 : Set} (Ze1 : (Zero0 A1)) (Ze2 : (Zero0 A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-0 : (hom (0 Ze1)) == (0 Ze2)
        pres-* : {x1 x2 : A1} -> (hom ((* Ze1) x1 x2)) == ((* Ze2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ze1 : (Zero0 A1)) (Ze2 : (Zero0 A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-0 : (interp (0 Ze1) (0 Ze2))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Ze1) x1 x2) ((* Ze2) y1 y2))))
    data Zero0LTerm  : Set where
      0L : Zero0LTerm
      *L : (Zero0LTerm -> (Zero0LTerm -> Zero0LTerm))
    data ClZero0ClTerm (A : Set) : Set where
      sing : (A -> (ClZero0ClTerm A))
      0Cl : (ClZero0ClTerm A)
      *Cl : ((ClZero0ClTerm A) -> ((ClZero0ClTerm A) -> (ClZero0ClTerm A)))
    data OpZero0OLTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpZero0OLTerm n))
      0OL : (OpZero0OLTerm n)
      *OL : ((OpZero0OLTerm n) -> ((OpZero0OLTerm n) -> (OpZero0OLTerm n)))
    data OpZero0OL2Term2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpZero0OL2Term2 n A))
      sing2 : (A -> (OpZero0OL2Term2 n A))
      0OL2 : (OpZero0OL2Term2 n A)
      *OL2 : ((OpZero0OL2Term2 n A) -> ((OpZero0OL2Term2 n A) -> (OpZero0OL2Term2 n A)))
    simplifyCl : {A : Set} -> ((ClZero0ClTerm A) -> (ClZero0ClTerm A))
    simplifyCl 0Cl = 0Cl 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpZero0OLTerm n) -> (OpZero0OLTerm n))
    simplifyOpB 0OL = 0OL 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpZero0OL2Term2 n A) -> (OpZero0OL2Term2 n A))
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Zero0 A) -> (Zero0LTerm -> A))
    evalB Ze 0L = (0 Ze) 
    evalB Ze (*L x1 x2) = ((* Ze) (evalB Ze x1) (evalB Ze x2)) 
    evalCl : {A : Set} -> ((Zero0 A) -> ((ClZero0ClTerm A) -> A))
    evalCl Ze (sing x1) = x1 
    evalCl Ze 0Cl = (0 Ze) 
    evalCl Ze (*Cl x1 x2) = ((* Ze) (evalCl Ze x1) (evalCl Ze x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Zero0 A) -> ((Vec A n) -> ((OpZero0OLTerm n) -> A)))
    evalOpB Ze vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ze vars 0OL = (0 Ze) 
    evalOpB Ze vars (*OL x1 x2) = ((* Ze) (evalOpB Ze vars x1) (evalOpB Ze vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Zero0 A) -> ((Vec A n) -> ((OpZero0OL2Term2 n A) -> A)))
    evalOp Ze vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ze vars (sing2 x1) = x1 
    evalOp Ze vars 0OL2 = (0 Ze) 
    evalOp Ze vars (*OL2 x1 x2) = ((* Ze) (evalOp Ze vars x1) (evalOp Ze vars x2)) 
    inductionB : {P : (Zero0LTerm -> Set)} -> ((P 0L) -> (((x1 x2 : Zero0LTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> ((x : Zero0LTerm) -> (P x))))
    inductionB {p} p0l p*l 0L = p0l 
    inductionB {p} p0l p*l (*L x1 x2) = (p*l _ _ (inductionB {p} p0l p*l x1) (inductionB {p} p0l p*l x2)) 
    inductionCl : {A : Set} {P : ((ClZero0ClTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 0Cl) -> (((x1 x2 : (ClZero0ClTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> ((x : (ClZero0ClTerm A)) -> (P x)))))
    inductionCl {_} {p} psing p0cl p*cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p0cl p*cl 0Cl = p0cl 
    inductionCl {_} {p} psing p0cl p*cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p0cl p*cl x1) (inductionCl {_} {p} psing p0cl p*cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpZero0OLTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 0OL) -> (((x1 x2 : (OpZero0OLTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> ((x : (OpZero0OLTerm n)) -> (P x)))))
    inductionOpB {_} {p} pv p0ol p*ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p0ol p*ol 0OL = p0ol 
    inductionOpB {_} {p} pv p0ol p*ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p0ol p*ol x1) (inductionOpB {_} {p} pv p0ol p*ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpZero0OL2Term2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 0OL2) -> (((x1 x2 : (OpZero0OL2Term2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> ((x : (OpZero0OL2Term2 n A)) -> (P x))))))
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p*ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p*ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p*ol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p*ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p*ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p*ol2 x2)) 
    0L' : Zero0LTerm
    0L'  = 0L 
    *L' : (Zero0LTerm -> (Zero0LTerm -> Zero0LTerm))
    *L' x1 x2 = (*L x1 x2) 
    stageB : (Zero0LTerm -> (Staged Zero0LTerm))
    stageB 0L = (Now 0L) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    0Cl' : {A : Set} -> (ClZero0ClTerm A)
    0Cl'  = 0Cl 
    *Cl' : {A : Set} -> ((ClZero0ClTerm A) -> ((ClZero0ClTerm A) -> (ClZero0ClTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    stageCl : {A : Set} -> ((ClZero0ClTerm A) -> (Staged (ClZero0ClTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    0OL' : {n : Nat} -> (OpZero0OLTerm n)
    0OL'  = 0OL 
    *OL' : {n : Nat} -> ((OpZero0OLTerm n) -> ((OpZero0OLTerm n) -> (OpZero0OLTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpZero0OLTerm n) -> (Staged (OpZero0OLTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    0OL2' : {n : Nat} {A : Set} -> (OpZero0OL2Term2 n A)
    0OL2'  = 0OL2 
    *OL2' : {n : Nat} {A : Set} -> ((OpZero0OL2Term2 n A) -> ((OpZero0OL2Term2 n A) -> (OpZero0OL2Term2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpZero0OL2Term2 n A) -> (Staged (OpZero0OL2Term2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        0T : (Repr A)
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
  module Zero_Ringoid0Sig  where
    record Zero_Ringoid0Sig (A : Set) : Set where
      constructor Zero_Ringoid0SigC
      field
        0 : A
        * : (A -> (A -> A))
        leftZero_op_0 : {x : A} -> (* 0 x) == 0
        rightZero_op_0 : {x : A} -> (* x 0) == 0
        + : (A -> (A -> A))
    record Sig (AS : Set) : Set where
      constructor SigSigC
      field
        0S : AS
        *S : (AS -> (AS -> AS))
        +S : (AS -> (AS -> AS))
    record Product (A : Set) : Set where
      constructor ProductC
      field
        0P : (Prod A A)
        *P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        +P : ((Prod A A) -> ((Prod A A) -> (Prod A A)))
        leftZero_op_0P : {xP : (Prod A A)} -> (*P 0P xP) == 0P
        rightZero_op_0P : {xP : (Prod A A)} -> (*P xP 0P) == 0P
    record Hom {A1 : Set} {A2 : Set} (Ze1 : (Zero_Ringoid0Sig A1)) (Ze2 : (Zero_Ringoid0Sig A2)) : Set where
      constructor HomC
      field
        hom : (A1 -> A2)
        pres-0 : (hom (0 Ze1)) == (0 Ze2)
        pres-* : {x1 x2 : A1} -> (hom ((* Ze1) x1 x2)) == ((* Ze2) (hom x1) (hom x2))
        pres-+ : {x1 x2 : A1} -> (hom ((+ Ze1) x1 x2)) == ((+ Ze2) (hom x1) (hom x2))
    record RelInterp {A1 : Set} {A2 : Set} (Ze1 : (Zero_Ringoid0Sig A1)) (Ze2 : (Zero_Ringoid0Sig A2)) : Set where
      constructor RelInterpC
      field
        interp : (A1 -> (A2 -> Set))
        interp-0 : (interp (0 Ze1) (0 Ze2))
        interp-* : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((* Ze1) x1 x2) ((* Ze2) y1 y2))))
        interp-+ : {x1 x2 : A1} {y1 y2 : A2} -> ((interp x1 y1) -> ((interp x2 y2) -> (interp ((+ Ze1) x1 x2) ((+ Ze2) y1 y2))))
    data Zero_Ringoid0SigTerm  : Set where
      0L : Zero_Ringoid0SigTerm
      *L : (Zero_Ringoid0SigTerm -> (Zero_Ringoid0SigTerm -> Zero_Ringoid0SigTerm))
      +L : (Zero_Ringoid0SigTerm -> (Zero_Ringoid0SigTerm -> Zero_Ringoid0SigTerm))
    data ClZero_Ringoid0SigTerm (A : Set) : Set where
      sing : (A -> (ClZero_Ringoid0SigTerm A))
      0Cl : (ClZero_Ringoid0SigTerm A)
      *Cl : ((ClZero_Ringoid0SigTerm A) -> ((ClZero_Ringoid0SigTerm A) -> (ClZero_Ringoid0SigTerm A)))
      +Cl : ((ClZero_Ringoid0SigTerm A) -> ((ClZero_Ringoid0SigTerm A) -> (ClZero_Ringoid0SigTerm A)))
    data OpZero_Ringoid0SigTerm (n : Nat) : Set where
      v : ((Fin n) -> (OpZero_Ringoid0SigTerm n))
      0OL : (OpZero_Ringoid0SigTerm n)
      *OL : ((OpZero_Ringoid0SigTerm n) -> ((OpZero_Ringoid0SigTerm n) -> (OpZero_Ringoid0SigTerm n)))
      +OL : ((OpZero_Ringoid0SigTerm n) -> ((OpZero_Ringoid0SigTerm n) -> (OpZero_Ringoid0SigTerm n)))
    data OpZero_Ringoid0SigTerm2 (n : Nat) (A : Set) : Set where
      v2 : ((Fin n) -> (OpZero_Ringoid0SigTerm2 n A))
      sing2 : (A -> (OpZero_Ringoid0SigTerm2 n A))
      0OL2 : (OpZero_Ringoid0SigTerm2 n A)
      *OL2 : ((OpZero_Ringoid0SigTerm2 n A) -> ((OpZero_Ringoid0SigTerm2 n A) -> (OpZero_Ringoid0SigTerm2 n A)))
      +OL2 : ((OpZero_Ringoid0SigTerm2 n A) -> ((OpZero_Ringoid0SigTerm2 n A) -> (OpZero_Ringoid0SigTerm2 n A)))
    simplifyCl : {A : Set} -> ((ClZero_Ringoid0SigTerm A) -> (ClZero_Ringoid0SigTerm A))
    simplifyCl 0Cl = 0Cl 
    simplifyCl (*Cl x1 x2) = (*Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (+Cl x1 x2) = (+Cl (simplifyCl x1) (simplifyCl x2)) 
    simplifyCl (sing x1) = (sing x1) 
    simplifyOpB : {n : Nat} -> ((OpZero_Ringoid0SigTerm n) -> (OpZero_Ringoid0SigTerm n))
    simplifyOpB 0OL = 0OL 
    simplifyOpB (*OL x1 x2) = (*OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (+OL x1 x2) = (+OL (simplifyOpB x1) (simplifyOpB x2)) 
    simplifyOpB (v x1) = (v x1) 
    simplifyOp : {n : Nat} {A : Set} -> ((OpZero_Ringoid0SigTerm2 n A) -> (OpZero_Ringoid0SigTerm2 n A))
    simplifyOp 0OL2 = 0OL2 
    simplifyOp (*OL2 x1 x2) = (*OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (+OL2 x1 x2) = (+OL2 (simplifyOp x1) (simplifyOp x2)) 
    simplifyOp (v2 x1) = (v2 x1) 
    simplifyOp (sing2 x1) = (sing2 x1) 
    evalB : {A : Set} -> ((Zero_Ringoid0Sig A) -> (Zero_Ringoid0SigTerm -> A))
    evalB Ze 0L = (0 Ze) 
    evalB Ze (*L x1 x2) = ((* Ze) (evalB Ze x1) (evalB Ze x2)) 
    evalB Ze (+L x1 x2) = ((+ Ze) (evalB Ze x1) (evalB Ze x2)) 
    evalCl : {A : Set} -> ((Zero_Ringoid0Sig A) -> ((ClZero_Ringoid0SigTerm A) -> A))
    evalCl Ze (sing x1) = x1 
    evalCl Ze 0Cl = (0 Ze) 
    evalCl Ze (*Cl x1 x2) = ((* Ze) (evalCl Ze x1) (evalCl Ze x2)) 
    evalCl Ze (+Cl x1 x2) = ((+ Ze) (evalCl Ze x1) (evalCl Ze x2)) 
    evalOpB : {A : Set} {n : Nat} -> ((Zero_Ringoid0Sig A) -> ((Vec A n) -> ((OpZero_Ringoid0SigTerm n) -> A)))
    evalOpB Ze vars (v x1) = (lookup _ x1 vars) 
    evalOpB Ze vars 0OL = (0 Ze) 
    evalOpB Ze vars (*OL x1 x2) = ((* Ze) (evalOpB Ze vars x1) (evalOpB Ze vars x2)) 
    evalOpB Ze vars (+OL x1 x2) = ((+ Ze) (evalOpB Ze vars x1) (evalOpB Ze vars x2)) 
    evalOp : {A : Set} {n : Nat} -> ((Zero_Ringoid0Sig A) -> ((Vec A n) -> ((OpZero_Ringoid0SigTerm2 n A) -> A)))
    evalOp Ze vars (v2 x1) = (lookup _ x1 vars) 
    evalOp Ze vars (sing2 x1) = x1 
    evalOp Ze vars 0OL2 = (0 Ze) 
    evalOp Ze vars (*OL2 x1 x2) = ((* Ze) (evalOp Ze vars x1) (evalOp Ze vars x2)) 
    evalOp Ze vars (+OL2 x1 x2) = ((+ Ze) (evalOp Ze vars x1) (evalOp Ze vars x2)) 
    inductionB : {P : (Zero_Ringoid0SigTerm -> Set)} -> ((P 0L) -> (((x1 x2 : Zero_Ringoid0SigTerm) -> ((P x1) -> ((P x2) -> (P (*L x1 x2))))) -> (((x1 x2 : Zero_Ringoid0SigTerm) -> ((P x1) -> ((P x2) -> (P (+L x1 x2))))) -> ((x : Zero_Ringoid0SigTerm) -> (P x)))))
    inductionB {p} p0l p*l p+l 0L = p0l 
    inductionB {p} p0l p*l p+l (*L x1 x2) = (p*l _ _ (inductionB {p} p0l p*l p+l x1) (inductionB {p} p0l p*l p+l x2)) 
    inductionB {p} p0l p*l p+l (+L x1 x2) = (p+l _ _ (inductionB {p} p0l p*l p+l x1) (inductionB {p} p0l p*l p+l x2)) 
    inductionCl : {A : Set} {P : ((ClZero_Ringoid0SigTerm A) -> Set)} -> (((x1 : A) -> (P (sing x1))) -> ((P 0Cl) -> (((x1 x2 : (ClZero_Ringoid0SigTerm A)) -> ((P x1) -> ((P x2) -> (P (*Cl x1 x2))))) -> (((x1 x2 : (ClZero_Ringoid0SigTerm A)) -> ((P x1) -> ((P x2) -> (P (+Cl x1 x2))))) -> ((x : (ClZero_Ringoid0SigTerm A)) -> (P x))))))
    inductionCl {_} {p} psing p0cl p*cl p+cl (sing x1) = (psing x1) 
    inductionCl {_} {p} psing p0cl p*cl p+cl 0Cl = p0cl 
    inductionCl {_} {p} psing p0cl p*cl p+cl (*Cl x1 x2) = (p*cl _ _ (inductionCl {_} {p} psing p0cl p*cl p+cl x1) (inductionCl {_} {p} psing p0cl p*cl p+cl x2)) 
    inductionCl {_} {p} psing p0cl p*cl p+cl (+Cl x1 x2) = (p+cl _ _ (inductionCl {_} {p} psing p0cl p*cl p+cl x1) (inductionCl {_} {p} psing p0cl p*cl p+cl x2)) 
    inductionOpB : {n : Nat} {P : ((OpZero_Ringoid0SigTerm n) -> Set)} -> (((fin : (Fin n)) -> (P (v fin))) -> ((P 0OL) -> (((x1 x2 : (OpZero_Ringoid0SigTerm n)) -> ((P x1) -> ((P x2) -> (P (*OL x1 x2))))) -> (((x1 x2 : (OpZero_Ringoid0SigTerm n)) -> ((P x1) -> ((P x2) -> (P (+OL x1 x2))))) -> ((x : (OpZero_Ringoid0SigTerm n)) -> (P x))))))
    inductionOpB {_} {p} pv p0ol p*ol p+ol (v x1) = (pv x1) 
    inductionOpB {_} {p} pv p0ol p*ol p+ol 0OL = p0ol 
    inductionOpB {_} {p} pv p0ol p*ol p+ol (*OL x1 x2) = (p*ol _ _ (inductionOpB {_} {p} pv p0ol p*ol p+ol x1) (inductionOpB {_} {p} pv p0ol p*ol p+ol x2)) 
    inductionOpB {_} {p} pv p0ol p*ol p+ol (+OL x1 x2) = (p+ol _ _ (inductionOpB {_} {p} pv p0ol p*ol p+ol x1) (inductionOpB {_} {p} pv p0ol p*ol p+ol x2)) 
    inductionOp : {n : Nat} {A : Set} {P : ((OpZero_Ringoid0SigTerm2 n A) -> Set)} -> (((fin : (Fin n)) -> (P (v2 fin))) -> (((x1 : A) -> (P (sing2 x1))) -> ((P 0OL2) -> (((x1 x2 : (OpZero_Ringoid0SigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (*OL2 x1 x2))))) -> (((x1 x2 : (OpZero_Ringoid0SigTerm2 n A)) -> ((P x1) -> ((P x2) -> (P (+OL2 x1 x2))))) -> ((x : (OpZero_Ringoid0SigTerm2 n A)) -> (P x)))))))
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p*ol2 p+ol2 (v2 x1) = (pv2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p*ol2 p+ol2 (sing2 x1) = (psing2 x1) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p*ol2 p+ol2 0OL2 = p0ol2 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p*ol2 p+ol2 (*OL2 x1 x2) = (p*ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p*ol2 p+ol2 x2)) 
    inductionOp {_} {_} {p} pv2 psing2 p0ol2 p*ol2 p+ol2 (+OL2 x1 x2) = (p+ol2 _ _ (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p*ol2 p+ol2 x1) (inductionOp {_} {_} {p} pv2 psing2 p0ol2 p*ol2 p+ol2 x2)) 
    0L' : Zero_Ringoid0SigTerm
    0L'  = 0L 
    *L' : (Zero_Ringoid0SigTerm -> (Zero_Ringoid0SigTerm -> Zero_Ringoid0SigTerm))
    *L' x1 x2 = (*L x1 x2) 
    +L' : (Zero_Ringoid0SigTerm -> (Zero_Ringoid0SigTerm -> Zero_Ringoid0SigTerm))
    +L' x1 x2 = (+L x1 x2) 
    stageB : (Zero_Ringoid0SigTerm -> (Staged Zero_Ringoid0SigTerm))
    stageB 0L = (Now 0L) 
    stageB (*L x1 x2) = (stage2 *L' (codeLift2 *L') (stageB x1) (stageB x2)) 
    stageB (+L x1 x2) = (stage2 +L' (codeLift2 +L') (stageB x1) (stageB x2)) 
    0Cl' : {A : Set} -> (ClZero_Ringoid0SigTerm A)
    0Cl'  = 0Cl 
    *Cl' : {A : Set} -> ((ClZero_Ringoid0SigTerm A) -> ((ClZero_Ringoid0SigTerm A) -> (ClZero_Ringoid0SigTerm A)))
    *Cl' x1 x2 = (*Cl x1 x2) 
    +Cl' : {A : Set} -> ((ClZero_Ringoid0SigTerm A) -> ((ClZero_Ringoid0SigTerm A) -> (ClZero_Ringoid0SigTerm A)))
    +Cl' x1 x2 = (+Cl x1 x2) 
    stageCl : {A : Set} -> ((ClZero_Ringoid0SigTerm A) -> (Staged (ClZero_Ringoid0SigTerm A)))
    stageCl (sing x1) = (Now (sing x1)) 
    stageCl 0Cl = (Now 0Cl) 
    stageCl (*Cl x1 x2) = (stage2 *Cl' (codeLift2 *Cl') (stageCl x1) (stageCl x2)) 
    stageCl (+Cl x1 x2) = (stage2 +Cl' (codeLift2 +Cl') (stageCl x1) (stageCl x2)) 
    0OL' : {n : Nat} -> (OpZero_Ringoid0SigTerm n)
    0OL'  = 0OL 
    *OL' : {n : Nat} -> ((OpZero_Ringoid0SigTerm n) -> ((OpZero_Ringoid0SigTerm n) -> (OpZero_Ringoid0SigTerm n)))
    *OL' x1 x2 = (*OL x1 x2) 
    +OL' : {n : Nat} -> ((OpZero_Ringoid0SigTerm n) -> ((OpZero_Ringoid0SigTerm n) -> (OpZero_Ringoid0SigTerm n)))
    +OL' x1 x2 = (+OL x1 x2) 
    stageOpB : {n : Nat} -> ((OpZero_Ringoid0SigTerm n) -> (Staged (OpZero_Ringoid0SigTerm n)))
    stageOpB (v x1) = (const (code (v x1))) 
    stageOpB 0OL = (Now 0OL) 
    stageOpB (*OL x1 x2) = (stage2 *OL' (codeLift2 *OL') (stageOpB x1) (stageOpB x2)) 
    stageOpB (+OL x1 x2) = (stage2 +OL' (codeLift2 +OL') (stageOpB x1) (stageOpB x2)) 
    0OL2' : {n : Nat} {A : Set} -> (OpZero_Ringoid0SigTerm2 n A)
    0OL2'  = 0OL2 
    *OL2' : {n : Nat} {A : Set} -> ((OpZero_Ringoid0SigTerm2 n A) -> ((OpZero_Ringoid0SigTerm2 n A) -> (OpZero_Ringoid0SigTerm2 n A)))
    *OL2' x1 x2 = (*OL2 x1 x2) 
    +OL2' : {n : Nat} {A : Set} -> ((OpZero_Ringoid0SigTerm2 n A) -> ((OpZero_Ringoid0SigTerm2 n A) -> (OpZero_Ringoid0SigTerm2 n A)))
    +OL2' x1 x2 = (+OL2 x1 x2) 
    stageOp : {n : Nat} {A : Set} -> ((OpZero_Ringoid0SigTerm2 n A) -> (Staged (OpZero_Ringoid0SigTerm2 n A)))
    stageOp (sing2 x1) = (Now (sing2 x1)) 
    stageOp (v2 x1) = (const (code (v2 x1))) 
    stageOp 0OL2 = (Now 0OL2) 
    stageOp (*OL2 x1 x2) = (stage2 *OL2' (codeLift2 *OL2') (stageOp x1) (stageOp x2)) 
    stageOp (+OL2 x1 x2) = (stage2 +OL2' (codeLift2 +OL2') (stageOp x1) (stageOp x2)) 
    record StagedRepr (A : Set) (Repr : (Set -> Set)) : Set where
      constructor repr
      field
        0T : (Repr A)
        *T : ((Repr A) -> ((Repr A) -> (Repr A)))
        +T : ((Repr A) -> ((Repr A) -> (Repr A)))
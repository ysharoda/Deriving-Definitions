------------------------------------------------------------------------
-- Checking declarations
------------------------------------------------------------------------
-- Solved Metas: 272374
-- Unsolved Metas: 0
------------------------------------------------------------------------
-- Unsolved problems: 0
------------------------------------------------------------------------
module MathScheme where
  data Prod
    (A : Set) (B : Set) : Set where
    
  module NatNums where
    
  
  data Nat : Set where
    zero : Nat
    suc : Nat -> Nat
  module Prelude where
    
  
  data Fin (n : Nat) : Set where
    fzero :
      (m : Nat) (p : n == suc m) ->
      Fin n
    fsuc :
      (m : Nat) (p : n == suc m)
      (i : Fin m) -> Fin n
  pred : Nat -> Nat
  pred (zero) = zero
  pred (suc n) = n
  data Vec
    (A : Set) (n : Nat) : Set where
    nil : n == zero -> Vec A n
    cons :
      (m : Nat) (p : n == suc m)
      (x : A)
      (xs : Vec A m) -> Vec A n
  data Unit : Set where
    unit : Unit
  EmptyT : Set
  EmptyT = (A : Set) -> A
  subst :
    (A : Set) (x : A) (y : A)
    (P : A -> Set) ->
    x == y -> P x -> P y
  subst _ _ _ P =
    J _ _ _ (\ x y _ -> P x -> P y)
      (\ x p -> p)
  sym :
    (A : Set) (x : A) (y : A) ->
    x == y -> y == x
  sym A x y p =
    subst _ _ _ (\ y -> y == x) p
      refl
  cong :
    (A : Set) (B : Set) (x : A)
    (y : A)
    (f : A -> B) ->
    x == y -> f x == f y
  cong _ _ _ _ f p =
    subst _ _ _ (\ y -> f _ == f y)
      p
      refl
  IsZero : Nat -> Set
  IsZero (zero) = Unit
  IsZero (suc n) = EmptyT
  zeroNOTsuc :
    (n : Nat) ->
    zero == suc n -> EmptyT
  zeroNOTsuc _ p =
    subst _ _ _ IsZero p unit
  trans :
    (A : Set) (x : A) (y : A)
    (z : A) ->
    x == y -> y == z -> x == z
  trans A x _ _ p q =
    subst _ _ _ (\ y -> x == y) q p
  lemma :
    (n : Nat) (m : Nat) ->
    n == suc m ->
    n == zero -> EmptyT
  lemma _ _ p q =
    zeroNOTsuc _
      (trans _ _ _ _ (sym _ _ _ q) p)
  sucInj :
    (n : Nat) (m : Nat) ->
    suc n == suc m -> n == m
  sucInj _ _ p =
    cong _ _ _ _ pred p
  lookup :
    (A : Set) (n : Nat) (i : Fin n)
    (v : Vec A n) -> A
  lookup A n (fzero m p) (nil q) =
    lemma _ _ p q A
  lookup A n (fzero m p) (cons
                          l
                          q
                          x
                          xs) = x
  lookup A n (fsuc m p i) (nil
                           q) = lemma _ _ p q A
  lookup A n (fsuc m p i) (cons
                           l
                           q
                           x
                           xs) =
    lookup _ m i
      (subst _ _ _ (Vec A)
         (sucInj _ _
            (trans _ _ _ _ (sym _ _ _ q) p))
         xs)
  module Code where
    
  
  open NatNums
  data Wrap (A : Set) : Set where
    Q : A -> Wrap A
  data Stage : Set where
    s0 : Stage
    s1 : Stage
  CodeRep :
    (A : Set) (s : Stage) -> Set
  CodeRep A (s0) = A
  CodeRep A (s1) =
    Wrap (CodeRep A s0)
  uncode :
    (A : Set) ->
    CodeRep A s1 -> CodeRep A s0
  uncode _ (Q x) = x
  code :
    (A : Set) ->
    CodeRep A s0 -> CodeRep A s1
  code _ x = Q x
  run :
    (A : Set) -> CodeRep A s1 -> A
  run _ (Q x) = x
  module Staging where
    
  
  open Code
  data Choice : Set where
    Expr : Choice
    Const : Choice
  data Comp
    (A : Set) (s : Stage) :
    Set where
    Computation :
      Choice ->
      CodeRep A s -> Comp A s
  data Staged
    (A : Set) : Set where
    Now : A -> Staged A
    Later : Comp A s1 -> Staged A
  expr :
    (A : Set) ->
    CodeRep A s1 -> Staged A
  expr _ x =
    Later (Computation Expr x)
  const :
    (A : Set) ->
    CodeRep A s1 -> Staged A
  const _ x =
    Later (Computation Const x)
  stage0 :
    (A : Set) -> A -> Staged A
  stage0 _ x = Now x
  stage1 :
    (A : Set) (B : Set) ->
    (A -> B) ->
    (CodeRep A s1 ->
     CodeRep B s1) ->
    Staged A -> Staged B
  stage1 _ _ f g (Now x) =
    Now (f x)
  stage1 _ _ f g (Later
                  (Computation _ x)) =
    expr _ (g x)
  stage2 :
    (A : Set) (B : Set) (C : Set) ->
    (A -> B -> C) ->
    (CodeRep A s1 ->
     CodeRep B s1 -> CodeRep C s1) ->
    Staged A -> Staged B -> Staged C
  stage2 _ _ _ f _ (Now x) (Now
                            y) = stage0 _ (f x y)
  stage2 _ _ _ _ g (Now x) (Later
                            (Computation _ y)) =
    expr _ (g (code _ x) y)
  stage2 _ _ _ _ g (Later
                    (Computation _ x)) (Now y) =
    expr _ (g x (code _ y))
  stage2 _ _ _ _ g (Later
                    (Computation _ x)) (Later
                                        (Computation _ y)) =
    expr _ (g x y)
  codeLift1 :
    (A : Set) (B : Set) ->
    (A -> B) ->
    CodeRep A s1 -> CodeRep B s1
  codeLift1 _ _ f (Q x) = Q (f x)
  codeLift2 :
    (A : Set) (B : Set) (C : Set) ->
    (A -> B -> C) ->
    CodeRep A s1 ->
    CodeRep B s1 -> CodeRep C s1
  codeLift2 _ _ _ f (Q x) (Q y) =
    Q (f x y)
  module AbelianAdditiveGroup where
    record AbelianAdditiveGroup
      (A : Set) : Set where
      constructor AbelianAdditiveGroupC
      field
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
    record AbelianAdditiveGroupSig
      (AS : Set) : Set where
      constructor AbelianAdditiveGroupSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
    record AbelianAdditiveGroupProd
      (AP : Set) : Set where
      constructor AbelianAdditiveGroupProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
    record AbelianAdditiveGroupHom
      (A1 : Set) (A2 : Set)
      (Ab1 : AbelianAdditiveGroup A1)
      (Ab2 : AbelianAdditiveGroup
         A2) : Set where
      constructor AbelianAdditiveGroupHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ab1 x1 x2) ==
            + Ab2 (hom x1) (hom x2)
        pres-0 : hom (0 Ab1) == 0 Ab2
        pres-neg :
          (x1 : A1) ->
          hom (neg Ab1 x1) ==
            neg Ab2 (hom x1)
    record AbelianAdditiveGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ab1 : AbelianAdditiveGroup A1)
      (Ab2 : AbelianAdditiveGroup
         A2) : Set where
      constructor AbelianAdditiveGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ab1 x1 x2)
            (+ Ab2 y1 y2)
        interp-0 :
          interp (0 Ab1) (0 Ab2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Ab1 x1) (neg Ab2 y1)
    data AbelianAdditiveGroupLang
      : Set where
      +L :
        AbelianAdditiveGroupLang ->
        AbelianAdditiveGroupLang ->
        AbelianAdditiveGroupLang
      0L : AbelianAdditiveGroupLang
      negL :
        AbelianAdditiveGroupLang ->
        AbelianAdditiveGroupLang
    data AbelianAdditiveGroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AbelianAdditiveGroupOpenLang n
      +OL :
        AbelianAdditiveGroupOpenLang
          n ->
        AbelianAdditiveGroupOpenLang
          n ->
        AbelianAdditiveGroupOpenLang n
      0OL :
        AbelianAdditiveGroupOpenLang n
      negOL :
        AbelianAdditiveGroupOpenLang
          n ->
        AbelianAdditiveGroupOpenLang n
    evalTerm :
      (A : Set) ->
      AbelianAdditiveGroup A ->
      AbelianAdditiveGroupLang -> A
    evalTerm _ Ab (+L x1 x2) =
      + Ab (evalTerm _ Ab x1)
        (evalTerm _ Ab x2)
    evalTerm _ Ab (0L) = 0 Ab
    evalTerm _ Ab (negL x1) =
      neg Ab (evalTerm _ Ab x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AbelianAdditiveGroup A ->
      AbelianAdditiveGroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ab (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ab (+OL
                         x1
                         x2) vars =
      + ab
        (evalOpenTerm _ n ab x1 vars)
        (evalOpenTerm _ n ab x2 vars)
    evalOpenTerm _ n ab (0OL) vars =
      0 ab
    evalOpenTerm _ n ab (negOL
                         x1) vars =
      neg ab
        (evalOpenTerm _ n ab x1 vars)
    simplify :
      AbelianAdditiveGroupLang ->
      AbelianAdditiveGroupLang
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (+L x (negL x)) = 0L
    simplify (+L (negL x) x) = 0L
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (0L) = 0L
    simplify (negL x1) =
      negL (simplify x1)
    liftAbelianAdditiveGroupLang :
      AbelianAdditiveGroupLang ->
      Staged AbelianAdditiveGroupLang
    liftAbelianAdditiveGroupLang x =
      Now x
    +OL' :
      (n : Nat) ->
      AbelianAdditiveGroupOpenLang
        n ->
      AbelianAdditiveGroupOpenLang
        n ->
      AbelianAdditiveGroupOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      AbelianAdditiveGroupOpenLang n
    0OL' _ = 0OL
    negOL' :
      (n : Nat) ->
      AbelianAdditiveGroupOpenLang
        n ->
      AbelianAdditiveGroupOpenLang n
    negOL' _ x1 = negOL x1
    liftAbelianAdditiveGroupOpenLang :
      (n : Nat) ->
      AbelianAdditiveGroupOpenLang
        n ->
      Staged
        (AbelianAdditiveGroupOpenLang n)
    liftAbelianAdditiveGroupOpenLang _ (v
                                        fin) = const _ (code _ (v fin))
    liftAbelianAdditiveGroupOpenLang _ (+OL
                                        x1
                                        x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftAbelianAdditiveGroupOpenLang
           _
           x1)
        (liftAbelianAdditiveGroupOpenLang
           _
           x2)
    liftAbelianAdditiveGroupOpenLang _ (0OL) =
      Now 0OL
    liftAbelianAdditiveGroupOpenLang _ (negOL
                                        x1) =
      stage1 _ _ (negOL' _)
        (codeLift1 _ _ (negOL' _))
        (liftAbelianAdditiveGroupOpenLang
           _
           x1)
  
  module AbelianGroup where
    record AbelianGroup
      (A : Set) : Set where
      constructor AbelianGroupC
      field
        1 : A
        * : A -> A -> A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        inv : A -> A
        leftInverse_inv_op_1 :
          (x : A) -> * x (inv x) == 1
        rightInverse_inv_op_1 :
          (x : A) -> * (inv x) x == 1
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
    record AbelianGroupSig
      (AS : Set) : Set where
      constructor AbelianGroupSigSigC
      field
        1S : AS
        *S : AS -> AS -> AS
        invS : AS -> AS
    record AbelianGroupProd
      (AP : Set) : Set where
      constructor AbelianGroupProdC
      field
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P xP (invP xP) == 1P
        rightInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P (invP xP) xP == 1P
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
    record AbelianGroupHom
      (A1 : Set) (A2 : Set)
      (Ab1 : AbelianGroup A1)
      (Ab2 : AbelianGroup A2) :
      Set where
      constructor AbelianGroupHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Ab1) == 1 Ab2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ab1 x1 x2) ==
            * Ab2 (hom x1) (hom x2)
        pres-inv :
          (x1 : A1) ->
          hom (inv Ab1 x1) ==
            inv Ab2 (hom x1)
    record AbelianGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ab1 : AbelianGroup A1)
      (Ab2 : AbelianGroup A2) :
      Set where
      constructor AbelianGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Ab1) (1 Ab2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ab1 x1 x2)
            (* Ab2 y1 y2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Ab1 x1) (inv Ab2 y1)
    data AbelianGroupLang
      : Set where
      1L : AbelianGroupLang
      *L :
        AbelianGroupLang ->
        AbelianGroupLang ->
        AbelianGroupLang
      invL :
        AbelianGroupLang ->
        AbelianGroupLang
    data AbelianGroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> AbelianGroupOpenLang n
      1OL : AbelianGroupOpenLang n
      *OL :
        AbelianGroupOpenLang n ->
        AbelianGroupOpenLang n ->
        AbelianGroupOpenLang n
      invOL :
        AbelianGroupOpenLang n ->
        AbelianGroupOpenLang n
    evalTerm :
      (A : Set) ->
      AbelianGroup A ->
      AbelianGroupLang -> A
    evalTerm _ Ab (1L) = 1 Ab
    evalTerm _ Ab (*L x1 x2) =
      * Ab (evalTerm _ Ab x1)
        (evalTerm _ Ab x2)
    evalTerm _ Ab (invL x1) =
      inv Ab (evalTerm _ Ab x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AbelianGroup A ->
      AbelianGroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ab (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ab (1OL) vars =
      1 ab
    evalOpenTerm _ n ab (*OL
                         x1
                         x2) vars =
      * ab
        (evalOpenTerm _ n ab x1 vars)
        (evalOpenTerm _ n ab x2 vars)
    evalOpenTerm _ n ab (invOL
                         x1) vars =
      inv ab
        (evalOpenTerm _ n ab x1 vars)
    simplify :
      AbelianGroupLang ->
      AbelianGroupLang
    simplify (*L (1L) x) = x
    simplify (*L x (1L)) = x
    simplify (*L x (invL x)) = 1L
    simplify (*L (invL x) x) = 1L
    simplify (1L) = 1L
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (invL x1) =
      invL (simplify x1)
    liftAbelianGroupLang :
      AbelianGroupLang ->
      Staged AbelianGroupLang
    liftAbelianGroupLang x = Now x
    1OL' :
      (n : Nat) ->
      AbelianGroupOpenLang n
    1OL' _ = 1OL
    *OL' :
      (n : Nat) ->
      AbelianGroupOpenLang n ->
      AbelianGroupOpenLang n ->
      AbelianGroupOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    invOL' :
      (n : Nat) ->
      AbelianGroupOpenLang n ->
      AbelianGroupOpenLang n
    invOL' _ x1 = invOL x1
    liftAbelianGroupOpenLang :
      (n : Nat) ->
      AbelianGroupOpenLang n ->
      Staged (AbelianGroupOpenLang n)
    liftAbelianGroupOpenLang _ (v
                                fin) = const _ (code _ (v fin))
    liftAbelianGroupOpenLang _ (1OL) =
      Now 1OL
    liftAbelianGroupOpenLang _ (*OL
                                x1
                                x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftAbelianGroupOpenLang _ x1)
        (liftAbelianGroupOpenLang _ x2)
    liftAbelianGroupOpenLang _ (invOL
                                x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (liftAbelianGroupOpenLang _ x1)
  
  module Absorption where
    record Absorption
      (A : Set) : Set where
      constructor AbsorptionC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
    record AbsorptionSig
      (AS : Set) : Set where
      constructor AbsorptionSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record AbsorptionProd
      (AP : Set) : Set where
      constructor AbsorptionProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
    record AbsorptionHom
      (A1 : Set) (A2 : Set)
      (Ab1 : Absorption A1)
      (Ab2 : Absorption A2) :
      Set where
      constructor AbsorptionHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ab1 x1 x2) ==
            * Ab2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ab1 x1 x2) ==
            + Ab2 (hom x1) (hom x2)
    record AbsorptionRelInterp
      (A1 : Set) (A2 : Set)
      (Ab1 : Absorption A1)
      (Ab2 : Absorption A2) :
      Set where
      constructor AbsorptionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ab1 x1 x2)
            (* Ab2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ab1 x1 x2)
            (+ Ab2 y1 y2)
    data AbsorptionLang : Set where
      *L :
        AbsorptionLang ->
        AbsorptionLang -> AbsorptionLang
      +L :
        AbsorptionLang ->
        AbsorptionLang -> AbsorptionLang
    data AbsorptionOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> AbsorptionOpenLang n
      *OL :
        AbsorptionOpenLang n ->
        AbsorptionOpenLang n ->
        AbsorptionOpenLang n
      +OL :
        AbsorptionOpenLang n ->
        AbsorptionOpenLang n ->
        AbsorptionOpenLang n
    evalTerm :
      (A : Set) ->
      Absorption A ->
      AbsorptionLang -> A
    evalTerm _ Ab (*L x1 x2) =
      * Ab (evalTerm _ Ab x1)
        (evalTerm _ Ab x2)
    evalTerm _ Ab (+L x1 x2) =
      + Ab (evalTerm _ Ab x1)
        (evalTerm _ Ab x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Absorption A ->
      AbsorptionOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ab (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ab (*OL
                         x1
                         x2) vars =
      * ab
        (evalOpenTerm _ n ab x1 vars)
        (evalOpenTerm _ n ab x2 vars)
    evalOpenTerm _ n ab (+OL
                         x1
                         x2) vars =
      + ab
        (evalOpenTerm _ n ab x1 vars)
        (evalOpenTerm _ n ab x2 vars)
    simplify :
      AbsorptionLang -> AbsorptionLang
    simplify (*L x (+L x y)) = x
    simplify (+L x (*L x y)) = x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftAbsorptionLang :
      AbsorptionLang ->
      Staged AbsorptionLang
    liftAbsorptionLang x = Now x
    *OL' :
      (n : Nat) ->
      AbsorptionOpenLang n ->
      AbsorptionOpenLang n ->
      AbsorptionOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      AbsorptionOpenLang n ->
      AbsorptionOpenLang n ->
      AbsorptionOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftAbsorptionOpenLang :
      (n : Nat) ->
      AbsorptionOpenLang n ->
      Staged (AbsorptionOpenLang n)
    liftAbsorptionOpenLang _ (v
                              fin) = const _ (code _ (v fin))
    liftAbsorptionOpenLang _ (*OL
                              x1
                              x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftAbsorptionOpenLang _ x1)
        (liftAbsorptionOpenLang _ x2)
    liftAbsorptionOpenLang _ (+OL
                              x1
                              x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftAbsorptionOpenLang _ x1)
        (liftAbsorptionOpenLang _ x2)
  
  module AddCommMonWithMultMagma where
    record AddCommMonWithMultMagma
      (A : Set) : Set where
      constructor AddCommMonWithMultMagmaC
      field
        0 : A
        + : A -> A -> A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        * : A -> A -> A
    record AddCommMonWithMultMagmaSig
      (AS : Set) : Set where
      constructor AddCommMonWithMultMagmaSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
    record AddCommMonWithMultMagmaProd
      (AP : Set) : Set where
      constructor AddCommMonWithMultMagmaProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
    record AddCommMonWithMultMagmaHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AddCommMonWithMultMagma
         A1)
      (Ad2 : AddCommMonWithMultMagma
         A2) : Set where
      constructor AddCommMonWithMultMagmaHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ad1 x1 x2) ==
            * Ad2 (hom x1) (hom x2)
    record AddCommMonWithMultMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AddCommMonWithMultMagma
         A1)
      (Ad2 : AddCommMonWithMultMagma
         A2) : Set where
      constructor AddCommMonWithMultMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ad1 x1 x2)
            (* Ad2 y1 y2)
    data AddCommMonWithMultMagmaLang
      : Set where
      0L :
        AddCommMonWithMultMagmaLang
      +L :
        AddCommMonWithMultMagmaLang ->
        AddCommMonWithMultMagmaLang ->
        AddCommMonWithMultMagmaLang
      *L :
        AddCommMonWithMultMagmaLang ->
        AddCommMonWithMultMagmaLang ->
        AddCommMonWithMultMagmaLang
    data AddCommMonWithMultMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AddCommMonWithMultMagmaOpenLang
          n
      0OL :
        AddCommMonWithMultMagmaOpenLang
          n
      +OL :
        AddCommMonWithMultMagmaOpenLang
          n ->
        AddCommMonWithMultMagmaOpenLang
          n ->
        AddCommMonWithMultMagmaOpenLang
          n
      *OL :
        AddCommMonWithMultMagmaOpenLang
          n ->
        AddCommMonWithMultMagmaOpenLang
          n ->
        AddCommMonWithMultMagmaOpenLang
          n
    evalTerm :
      (A : Set) ->
      AddCommMonWithMultMagma A ->
      AddCommMonWithMultMagmaLang -> A
    evalTerm _ Ad (0L) = 0 Ad
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalTerm _ Ad (*L x1 x2) =
      * Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AddCommMonWithMultMagma A ->
      AddCommMonWithMultMagmaOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (0OL) vars =
      0 ad
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    evalOpenTerm _ n ad (*OL
                         x1
                         x2) vars =
      * ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    simplify :
      AddCommMonWithMultMagmaLang ->
      AddCommMonWithMultMagmaLang
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (0L) = 0L
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    liftAddCommMonWithMultMagmaLang :
      AddCommMonWithMultMagmaLang ->
      Staged
        AddCommMonWithMultMagmaLang
    liftAddCommMonWithMultMagmaLang x =
      Now x
    0OL' :
      (n : Nat) ->
      AddCommMonWithMultMagmaOpenLang
        n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      AddCommMonWithMultMagmaOpenLang
        n ->
      AddCommMonWithMultMagmaOpenLang
        n ->
      AddCommMonWithMultMagmaOpenLang
        n
    +OL' _ x1 x2 = +OL x1 x2
    *OL' :
      (n : Nat) ->
      AddCommMonWithMultMagmaOpenLang
        n ->
      AddCommMonWithMultMagmaOpenLang
        n ->
      AddCommMonWithMultMagmaOpenLang
        n
    *OL' _ x1 x2 = *OL x1 x2
    liftAddCommMonWithMultMagmaOpenLang :
      (n : Nat) ->
      AddCommMonWithMultMagmaOpenLang
        n ->
      Staged
        (AddCommMonWithMultMagmaOpenLang
           n)
    liftAddCommMonWithMultMagmaOpenLang _ (v
                                           fin) = const _ (code _ (v fin))
    liftAddCommMonWithMultMagmaOpenLang _ (0OL) =
      Now 0OL
    liftAddCommMonWithMultMagmaOpenLang _ (+OL
                                           x1
                                           x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftAddCommMonWithMultMagmaOpenLang
           _
           x1)
        (liftAddCommMonWithMultMagmaOpenLang
           _
           x2)
    liftAddCommMonWithMultMagmaOpenLang _ (*OL
                                           x1
                                           x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftAddCommMonWithMultMagmaOpenLang
           _
           x1)
        (liftAddCommMonWithMultMagmaOpenLang
           _
           x2)
  
  module AddCommMonWithMultSemigroup where
    record AddCommMonWithMultSemigroup
      (A : Set) : Set where
      constructor AddCommMonWithMultSemigroupC
      field
        * : A -> A -> A
        0 : A
        + : A -> A -> A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
    record AddCommMonWithMultSemigroupSig
      (AS : Set) : Set where
      constructor AddCommMonWithMultSemigroupSigSigC
      field
        *S : AS -> AS -> AS
        0S : AS
        +S : AS -> AS -> AS
    record AddCommMonWithMultSemigroupProd
      (AP : Set) : Set where
      constructor AddCommMonWithMultSemigroupProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
    record AddCommMonWithMultSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AddCommMonWithMultSemigroup
         A1)
      (Ad2 : AddCommMonWithMultSemigroup
         A2) : Set where
      constructor AddCommMonWithMultSemigroupHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ad1 x1 x2) ==
            * Ad2 (hom x1) (hom x2)
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AddCommMonWithMultSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AddCommMonWithMultSemigroup
         A1)
      (Ad2 : AddCommMonWithMultSemigroup
         A2) : Set where
      constructor AddCommMonWithMultSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ad1 x1 x2)
            (* Ad2 y1 y2)
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AddCommMonWithMultSemigroupLang
      : Set where
      *L :
        AddCommMonWithMultSemigroupLang ->
        AddCommMonWithMultSemigroupLang ->
        AddCommMonWithMultSemigroupLang
      0L :
        AddCommMonWithMultSemigroupLang
      +L :
        AddCommMonWithMultSemigroupLang ->
        AddCommMonWithMultSemigroupLang ->
        AddCommMonWithMultSemigroupLang
    data AddCommMonWithMultSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AddCommMonWithMultSemigroupOpenLang
          n
      *OL :
        AddCommMonWithMultSemigroupOpenLang
          n ->
        AddCommMonWithMultSemigroupOpenLang
          n ->
        AddCommMonWithMultSemigroupOpenLang
          n
      0OL :
        AddCommMonWithMultSemigroupOpenLang
          n
      +OL :
        AddCommMonWithMultSemigroupOpenLang
          n ->
        AddCommMonWithMultSemigroupOpenLang
          n ->
        AddCommMonWithMultSemigroupOpenLang
          n
    evalTerm :
      (A : Set) ->
      AddCommMonWithMultSemigroup A ->
      AddCommMonWithMultSemigroupLang ->
      A
    evalTerm _ Ad (*L x1 x2) =
      * Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalTerm _ Ad (0L) = 0 Ad
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AddCommMonWithMultSemigroup A ->
      AddCommMonWithMultSemigroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (*OL
                         x1
                         x2) vars =
      * ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    evalOpenTerm _ n ad (0OL) vars =
      0 ad
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    simplify :
      AddCommMonWithMultSemigroupLang ->
      AddCommMonWithMultSemigroupLang
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (0L) = 0L
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftAddCommMonWithMultSemigroupLang :
      AddCommMonWithMultSemigroupLang ->
      Staged
        AddCommMonWithMultSemigroupLang
    liftAddCommMonWithMultSemigroupLang x =
      Now x
    *OL' :
      (n : Nat) ->
      AddCommMonWithMultSemigroupOpenLang
        n ->
      AddCommMonWithMultSemigroupOpenLang
        n ->
      AddCommMonWithMultSemigroupOpenLang
        n
    *OL' _ x1 x2 = *OL x1 x2
    0OL' :
      (n : Nat) ->
      AddCommMonWithMultSemigroupOpenLang
        n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      AddCommMonWithMultSemigroupOpenLang
        n ->
      AddCommMonWithMultSemigroupOpenLang
        n ->
      AddCommMonWithMultSemigroupOpenLang
        n
    +OL' _ x1 x2 = +OL x1 x2
    liftAddCommMonWithMultSemigroupOpenLang :
      (n : Nat) ->
      AddCommMonWithMultSemigroupOpenLang
        n ->
      Staged
        (AddCommMonWithMultSemigroupOpenLang
           n)
    liftAddCommMonWithMultSemigroupOpenLang _ (v
                                               fin) = const _ (code _ (v fin))
    liftAddCommMonWithMultSemigroupOpenLang _ (*OL
                                               x1
                                               x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftAddCommMonWithMultSemigroupOpenLang
           _
           x1)
        (liftAddCommMonWithMultSemigroupOpenLang
           _
           x2)
    liftAddCommMonWithMultSemigroupOpenLang _ (0OL) =
      Now 0OL
    liftAddCommMonWithMultSemigroupOpenLang _ (+OL
                                               x1
                                               x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftAddCommMonWithMultSemigroupOpenLang
           _
           x1)
        (liftAddCommMonWithMultSemigroupOpenLang
           _
           x2)
  
  module AddGroup_RingoidSig where
    record AddGroup_RingoidSig
      (A : Set) : Set where
      constructor AddGroup_RingoidSigC
      field
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        * : A -> A -> A
    record AddGroup_RingoidSigSig
      (AS : Set) : Set where
      constructor AddGroup_RingoidSigSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
        *S : AS -> AS -> AS
    record AddGroup_RingoidSigProd
      (AP : Set) : Set where
      constructor AddGroup_RingoidSigProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
    record AddGroup_RingoidSigHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AddGroup_RingoidSig A1)
      (Ad2 : AddGroup_RingoidSig A2) :
      Set where
      constructor AddGroup_RingoidSigHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-neg :
          (x1 : A1) ->
          hom (neg Ad1 x1) ==
            neg Ad2 (hom x1)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ad1 x1 x2) ==
            * Ad2 (hom x1) (hom x2)
    record AddGroup_RingoidSigRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AddGroup_RingoidSig A1)
      (Ad2 : AddGroup_RingoidSig A2) :
      Set where
      constructor AddGroup_RingoidSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Ad1 x1) (neg Ad2 y1)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ad1 x1 x2)
            (* Ad2 y1 y2)
    data AddGroup_RingoidSigLang
      : Set where
      +L :
        AddGroup_RingoidSigLang ->
        AddGroup_RingoidSigLang ->
        AddGroup_RingoidSigLang
      0L : AddGroup_RingoidSigLang
      negL :
        AddGroup_RingoidSigLang ->
        AddGroup_RingoidSigLang
      *L :
        AddGroup_RingoidSigLang ->
        AddGroup_RingoidSigLang ->
        AddGroup_RingoidSigLang
    data AddGroup_RingoidSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AddGroup_RingoidSigOpenLang n
      +OL :
        AddGroup_RingoidSigOpenLang n ->
        AddGroup_RingoidSigOpenLang n ->
        AddGroup_RingoidSigOpenLang n
      0OL :
        AddGroup_RingoidSigOpenLang n
      negOL :
        AddGroup_RingoidSigOpenLang n ->
        AddGroup_RingoidSigOpenLang n
      *OL :
        AddGroup_RingoidSigOpenLang n ->
        AddGroup_RingoidSigOpenLang n ->
        AddGroup_RingoidSigOpenLang n
    evalTerm :
      (A : Set) ->
      AddGroup_RingoidSig A ->
      AddGroup_RingoidSigLang -> A
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalTerm _ Ad (0L) = 0 Ad
    evalTerm _ Ad (negL x1) =
      neg Ad (evalTerm _ Ad x1)
    evalTerm _ Ad (*L x1 x2) =
      * Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AddGroup_RingoidSig A ->
      AddGroup_RingoidSigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    evalOpenTerm _ n ad (0OL) vars =
      0 ad
    evalOpenTerm _ n ad (negOL
                         x1) vars =
      neg ad
        (evalOpenTerm _ n ad x1 vars)
    evalOpenTerm _ n ad (*OL
                         x1
                         x2) vars =
      * ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    simplify :
      AddGroup_RingoidSigLang ->
      AddGroup_RingoidSigLang
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (+L x (negL x)) = 0L
    simplify (+L (negL x) x) = 0L
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (0L) = 0L
    simplify (negL x1) =
      negL (simplify x1)
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    liftAddGroup_RingoidSigLang :
      AddGroup_RingoidSigLang ->
      Staged AddGroup_RingoidSigLang
    liftAddGroup_RingoidSigLang x =
      Now x
    +OL' :
      (n : Nat) ->
      AddGroup_RingoidSigOpenLang n ->
      AddGroup_RingoidSigOpenLang n ->
      AddGroup_RingoidSigOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      AddGroup_RingoidSigOpenLang n
    0OL' _ = 0OL
    negOL' :
      (n : Nat) ->
      AddGroup_RingoidSigOpenLang n ->
      AddGroup_RingoidSigOpenLang n
    negOL' _ x1 = negOL x1
    *OL' :
      (n : Nat) ->
      AddGroup_RingoidSigOpenLang n ->
      AddGroup_RingoidSigOpenLang n ->
      AddGroup_RingoidSigOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    liftAddGroup_RingoidSigOpenLang :
      (n : Nat) ->
      AddGroup_RingoidSigOpenLang n ->
      Staged
        (AddGroup_RingoidSigOpenLang n)
    liftAddGroup_RingoidSigOpenLang _ (v
                                       fin) = const _ (code _ (v fin))
    liftAddGroup_RingoidSigOpenLang _ (+OL
                                       x1
                                       x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftAddGroup_RingoidSigOpenLang
           _
           x1)
        (liftAddGroup_RingoidSigOpenLang
           _
           x2)
    liftAddGroup_RingoidSigOpenLang _ (0OL) =
      Now 0OL
    liftAddGroup_RingoidSigOpenLang _ (negOL
                                       x1) =
      stage1 _ _ (negOL' _)
        (codeLift1 _ _ (negOL' _))
        (liftAddGroup_RingoidSigOpenLang
           _
           x1)
    liftAddGroup_RingoidSigOpenLang _ (*OL
                                       x1
                                       x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftAddGroup_RingoidSigOpenLang
           _
           x1)
        (liftAddGroup_RingoidSigOpenLang
           _
           x2)
  
  module AdditiveCommutativeMonoid where
    record AdditiveCommutativeMonoid
      (A : Set) : Set where
      constructor AdditiveCommutativeMonoidC
      field
        0 : A
        + : A -> A -> A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
    record AdditiveCommutativeMonoidSig
      (AS : Set) : Set where
      constructor AdditiveCommutativeMonoidSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
    record AdditiveCommutativeMonoidProd
      (AP : Set) : Set where
      constructor AdditiveCommutativeMonoidProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
    record AdditiveCommutativeMonoidHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveCommutativeMonoid
         A1)
      (Ad2 : AdditiveCommutativeMonoid
         A2) : Set where
      constructor AdditiveCommutativeMonoidHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveCommutativeMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveCommutativeMonoid
         A1)
      (Ad2 : AdditiveCommutativeMonoid
         A2) : Set where
      constructor AdditiveCommutativeMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveCommutativeMonoidLang
      : Set where
      0L :
        AdditiveCommutativeMonoidLang
      +L :
        AdditiveCommutativeMonoidLang ->
        AdditiveCommutativeMonoidLang ->
        AdditiveCommutativeMonoidLang
    data AdditiveCommutativeMonoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AdditiveCommutativeMonoidOpenLang
          n
      0OL :
        AdditiveCommutativeMonoidOpenLang
          n
      +OL :
        AdditiveCommutativeMonoidOpenLang
          n ->
        AdditiveCommutativeMonoidOpenLang
          n ->
        AdditiveCommutativeMonoidOpenLang
          n
    evalTerm :
      (A : Set) ->
      AdditiveCommutativeMonoid A ->
      AdditiveCommutativeMonoidLang ->
      A
    evalTerm _ Ad (0L) = 0 Ad
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditiveCommutativeMonoid A ->
      AdditiveCommutativeMonoidOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (0OL) vars =
      0 ad
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    simplify :
      AdditiveCommutativeMonoidLang ->
      AdditiveCommutativeMonoidLang
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (0L) = 0L
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftAdditiveCommutativeMonoidLang :
      AdditiveCommutativeMonoidLang ->
      Staged
        AdditiveCommutativeMonoidLang
    liftAdditiveCommutativeMonoidLang x =
      Now x
    0OL' :
      (n : Nat) ->
      AdditiveCommutativeMonoidOpenLang
        n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      AdditiveCommutativeMonoidOpenLang
        n ->
      AdditiveCommutativeMonoidOpenLang
        n ->
      AdditiveCommutativeMonoidOpenLang
        n
    +OL' _ x1 x2 = +OL x1 x2
    liftAdditiveCommutativeMonoidOpenLang :
      (n : Nat) ->
      AdditiveCommutativeMonoidOpenLang
        n ->
      Staged
        (AdditiveCommutativeMonoidOpenLang
           n)
    liftAdditiveCommutativeMonoidOpenLang _ (v
                                             fin) = const _ (code _ (v fin))
    liftAdditiveCommutativeMonoidOpenLang _ (0OL) =
      Now 0OL
    liftAdditiveCommutativeMonoidOpenLang _ (+OL
                                             x1
                                             x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftAdditiveCommutativeMonoidOpenLang
           _
           x1)
        (liftAdditiveCommutativeMonoidOpenLang
           _
           x2)
  
  module AdditiveCommutativeSemigroup where
    record AdditiveCommutativeSemigroup
      (A : Set) : Set where
      constructor AdditiveCommutativeSemigroupC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record AdditiveCommutativeSemigroupSig
      (AS : Set) : Set where
      constructor AdditiveCommutativeSemigroupSigSigC
      field
        +S : AS -> AS -> AS
    record AdditiveCommutativeSemigroupProd
      (AP : Set) : Set where
      constructor AdditiveCommutativeSemigroupProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record AdditiveCommutativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveCommutativeSemigroup
         A1)
      (Ad2 : AdditiveCommutativeSemigroup
         A2) : Set where
      constructor AdditiveCommutativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveCommutativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveCommutativeSemigroup
         A1)
      (Ad2 : AdditiveCommutativeSemigroup
         A2) : Set where
      constructor AdditiveCommutativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveCommutativeSemigroupLang
      : Set where
      +L :
        AdditiveCommutativeSemigroupLang ->
        AdditiveCommutativeSemigroupLang ->
        AdditiveCommutativeSemigroupLang
    data AdditiveCommutativeSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AdditiveCommutativeSemigroupOpenLang
          n
      +OL :
        AdditiveCommutativeSemigroupOpenLang
          n ->
        AdditiveCommutativeSemigroupOpenLang
          n ->
        AdditiveCommutativeSemigroupOpenLang
          n
    evalTerm :
      (A : Set) ->
      AdditiveCommutativeSemigroup
        A ->
      AdditiveCommutativeSemigroupLang ->
      A
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditiveCommutativeSemigroup
        A ->
      AdditiveCommutativeSemigroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    simplify :
      AdditiveCommutativeSemigroupLang ->
      AdditiveCommutativeSemigroupLang
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftAdditiveCommutativeSemigroupLang :
      AdditiveCommutativeSemigroupLang ->
      Staged
        AdditiveCommutativeSemigroupLang
    liftAdditiveCommutativeSemigroupLang x =
      Now x
    +OL' :
      (n : Nat) ->
      AdditiveCommutativeSemigroupOpenLang
        n ->
      AdditiveCommutativeSemigroupOpenLang
        n ->
      AdditiveCommutativeSemigroupOpenLang
        n
    +OL' _ x1 x2 = +OL x1 x2
    liftAdditiveCommutativeSemigroupOpenLang :
      (n : Nat) ->
      AdditiveCommutativeSemigroupOpenLang
        n ->
      Staged
        (AdditiveCommutativeSemigroupOpenLang
           n)
    liftAdditiveCommutativeSemigroupOpenLang _ (v
                                                fin) = const _ (code _ (v fin))
    liftAdditiveCommutativeSemigroupOpenLang _ (+OL
                                                x1
                                                x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftAdditiveCommutativeSemigroupOpenLang
           _
           x1)
        (liftAdditiveCommutativeSemigroupOpenLang
           _
           x2)
  
  module AdditiveGroup where
    record AdditiveGroup
      (A : Set) : Set where
      constructor AdditiveGroupC
      field
        0 : A
        + : A -> A -> A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
    record AdditiveGroupSig
      (AS : Set) : Set where
      constructor AdditiveGroupSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        negS : AS -> AS
    record AdditiveGroupProd
      (AP : Set) : Set where
      constructor AdditiveGroupProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
    record AdditiveGroupHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveGroup A1)
      (Ad2 : AdditiveGroup A2) :
      Set where
      constructor AdditiveGroupHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
        pres-neg :
          (x1 : A1) ->
          hom (neg Ad1 x1) ==
            neg Ad2 (hom x1)
    record AdditiveGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveGroup A1)
      (Ad2 : AdditiveGroup A2) :
      Set where
      constructor AdditiveGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Ad1 x1) (neg Ad2 y1)
    data AdditiveGroupLang
      : Set where
      0L : AdditiveGroupLang
      +L :
        AdditiveGroupLang ->
        AdditiveGroupLang ->
        AdditiveGroupLang
      negL :
        AdditiveGroupLang ->
        AdditiveGroupLang
    data AdditiveGroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> AdditiveGroupOpenLang n
      0OL : AdditiveGroupOpenLang n
      +OL :
        AdditiveGroupOpenLang n ->
        AdditiveGroupOpenLang n ->
        AdditiveGroupOpenLang n
      negOL :
        AdditiveGroupOpenLang n ->
        AdditiveGroupOpenLang n
    evalTerm :
      (A : Set) ->
      AdditiveGroup A ->
      AdditiveGroupLang -> A
    evalTerm _ Ad (0L) = 0 Ad
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalTerm _ Ad (negL x1) =
      neg Ad (evalTerm _ Ad x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditiveGroup A ->
      AdditiveGroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (0OL) vars =
      0 ad
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    evalOpenTerm _ n ad (negOL
                         x1) vars =
      neg ad
        (evalOpenTerm _ n ad x1 vars)
    simplify :
      AdditiveGroupLang ->
      AdditiveGroupLang
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (+L x (negL x)) = 0L
    simplify (+L (negL x) x) = 0L
    simplify (0L) = 0L
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (negL x1) =
      negL (simplify x1)
    liftAdditiveGroupLang :
      AdditiveGroupLang ->
      Staged AdditiveGroupLang
    liftAdditiveGroupLang x = Now x
    0OL' :
      (n : Nat) ->
      AdditiveGroupOpenLang n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      AdditiveGroupOpenLang n ->
      AdditiveGroupOpenLang n ->
      AdditiveGroupOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    negOL' :
      (n : Nat) ->
      AdditiveGroupOpenLang n ->
      AdditiveGroupOpenLang n
    negOL' _ x1 = negOL x1
    liftAdditiveGroupOpenLang :
      (n : Nat) ->
      AdditiveGroupOpenLang n ->
      Staged (AdditiveGroupOpenLang n)
    liftAdditiveGroupOpenLang _ (v
                                 fin) = const _ (code _ (v fin))
    liftAdditiveGroupOpenLang _ (0OL) =
      Now 0OL
    liftAdditiveGroupOpenLang _ (+OL
                                 x1
                                 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftAdditiveGroupOpenLang _ x1)
        (liftAdditiveGroupOpenLang _ x2)
    liftAdditiveGroupOpenLang _ (negOL
                                 x1) =
      stage1 _ _ (negOL' _)
        (codeLift1 _ _ (negOL' _))
        (liftAdditiveGroupOpenLang _ x1)
  
  module AdditiveMagma where
    record AdditiveMagma
      (A : Set) : Set where
      constructor AdditiveMagmaC
      field
        + : A -> A -> A
    record AdditiveMagmaSig
      (AS : Set) : Set where
      constructor AdditiveMagmaSigSigC
      field
        +S : AS -> AS -> AS
    record AdditiveMagmaProd
      (AP : Set) : Set where
      constructor AdditiveMagmaProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record AdditiveMagmaHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveMagma A1)
      (Ad2 : AdditiveMagma A2) :
      Set where
      constructor AdditiveMagmaHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveMagma A1)
      (Ad2 : AdditiveMagma A2) :
      Set where
      constructor AdditiveMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveMagmaLang
      : Set where
      +L :
        AdditiveMagmaLang ->
        AdditiveMagmaLang ->
        AdditiveMagmaLang
    data AdditiveMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> AdditiveMagmaOpenLang n
      +OL :
        AdditiveMagmaOpenLang n ->
        AdditiveMagmaOpenLang n ->
        AdditiveMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      AdditiveMagma A ->
      AdditiveMagmaLang -> A
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditiveMagma A ->
      AdditiveMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    simplify :
      AdditiveMagmaLang ->
      AdditiveMagmaLang
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftAdditiveMagmaLang :
      AdditiveMagmaLang ->
      Staged AdditiveMagmaLang
    liftAdditiveMagmaLang x = Now x
    +OL' :
      (n : Nat) ->
      AdditiveMagmaOpenLang n ->
      AdditiveMagmaOpenLang n ->
      AdditiveMagmaOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftAdditiveMagmaOpenLang :
      (n : Nat) ->
      AdditiveMagmaOpenLang n ->
      Staged (AdditiveMagmaOpenLang n)
    liftAdditiveMagmaOpenLang _ (v
                                 fin) = const _ (code _ (v fin))
    liftAdditiveMagmaOpenLang _ (+OL
                                 x1
                                 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftAdditiveMagmaOpenLang _ x1)
        (liftAdditiveMagmaOpenLang _ x2)
  
  module AdditiveMonoid where
    record AdditiveMonoid
      (A : Set) : Set where
      constructor AdditiveMonoidC
      field
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
    record AdditiveMonoidSig
      (AS : Set) : Set where
      constructor AdditiveMonoidSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
    record AdditiveMonoidProd
      (AP : Set) : Set where
      constructor AdditiveMonoidProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
    record AdditiveMonoidHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveMonoid A1)
      (Ad2 : AdditiveMonoid A2) :
      Set where
      constructor AdditiveMonoidHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
        pres-0 : hom (0 Ad1) == 0 Ad2
    record AdditiveMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveMonoid A1)
      (Ad2 : AdditiveMonoid A2) :
      Set where
      constructor AdditiveMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
        interp-0 :
          interp (0 Ad1) (0 Ad2)
    data AdditiveMonoidLang
      : Set where
      +L :
        AdditiveMonoidLang ->
        AdditiveMonoidLang ->
        AdditiveMonoidLang
      0L : AdditiveMonoidLang
    data AdditiveMonoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AdditiveMonoidOpenLang n
      +OL :
        AdditiveMonoidOpenLang n ->
        AdditiveMonoidOpenLang n ->
        AdditiveMonoidOpenLang n
      0OL : AdditiveMonoidOpenLang n
    evalTerm :
      (A : Set) ->
      AdditiveMonoid A ->
      AdditiveMonoidLang -> A
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalTerm _ Ad (0L) = 0 Ad
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditiveMonoid A ->
      AdditiveMonoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    evalOpenTerm _ n ad (0OL) vars =
      0 ad
    simplify :
      AdditiveMonoidLang ->
      AdditiveMonoidLang
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (0L) = 0L
    liftAdditiveMonoidLang :
      AdditiveMonoidLang ->
      Staged AdditiveMonoidLang
    liftAdditiveMonoidLang x = Now x
    +OL' :
      (n : Nat) ->
      AdditiveMonoidOpenLang n ->
      AdditiveMonoidOpenLang n ->
      AdditiveMonoidOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      AdditiveMonoidOpenLang n
    0OL' _ = 0OL
    liftAdditiveMonoidOpenLang :
      (n : Nat) ->
      AdditiveMonoidOpenLang n ->
      Staged
        (AdditiveMonoidOpenLang n)
    liftAdditiveMonoidOpenLang _ (v
                                  fin) = const _ (code _ (v fin))
    liftAdditiveMonoidOpenLang _ (+OL
                                  x1
                                  x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftAdditiveMonoidOpenLang _
           x1)
        (liftAdditiveMonoidOpenLang _
           x2)
    liftAdditiveMonoidOpenLang _ (0OL) =
      Now 0OL
  
  module AdditivePointedMagma where
    record AdditivePointedMagma
      (A : Set) : Set where
      constructor AdditivePointedMagmaC
      field
        0 : A
        + : A -> A -> A
    record AdditivePointedMagmaSig
      (AS : Set) : Set where
      constructor AdditivePointedMagmaSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
    record AdditivePointedMagmaProd
      (AP : Set) : Set where
      constructor AdditivePointedMagmaProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record AdditivePointedMagmaHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditivePointedMagma A1)
      (Ad2 : AdditivePointedMagma
         A2) : Set where
      constructor AdditivePointedMagmaHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditivePointedMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditivePointedMagma A1)
      (Ad2 : AdditivePointedMagma
         A2) : Set where
      constructor AdditivePointedMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditivePointedMagmaLang
      : Set where
      0L : AdditivePointedMagmaLang
      +L :
        AdditivePointedMagmaLang ->
        AdditivePointedMagmaLang ->
        AdditivePointedMagmaLang
    data AdditivePointedMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AdditivePointedMagmaOpenLang n
      0OL :
        AdditivePointedMagmaOpenLang n
      +OL :
        AdditivePointedMagmaOpenLang
          n ->
        AdditivePointedMagmaOpenLang
          n ->
        AdditivePointedMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      AdditivePointedMagma A ->
      AdditivePointedMagmaLang -> A
    evalTerm _ Ad (0L) = 0 Ad
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditivePointedMagma A ->
      AdditivePointedMagmaOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (0OL) vars =
      0 ad
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    simplify :
      AdditivePointedMagmaLang ->
      AdditivePointedMagmaLang
    simplify (0L) = 0L
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftAdditivePointedMagmaLang :
      AdditivePointedMagmaLang ->
      Staged AdditivePointedMagmaLang
    liftAdditivePointedMagmaLang x =
      Now x
    0OL' :
      (n : Nat) ->
      AdditivePointedMagmaOpenLang n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      AdditivePointedMagmaOpenLang
        n ->
      AdditivePointedMagmaOpenLang
        n ->
      AdditivePointedMagmaOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftAdditivePointedMagmaOpenLang :
      (n : Nat) ->
      AdditivePointedMagmaOpenLang
        n ->
      Staged
        (AdditivePointedMagmaOpenLang n)
    liftAdditivePointedMagmaOpenLang _ (v
                                        fin) = const _ (code _ (v fin))
    liftAdditivePointedMagmaOpenLang _ (0OL) =
      Now 0OL
    liftAdditivePointedMagmaOpenLang _ (+OL
                                        x1
                                        x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftAdditivePointedMagmaOpenLang
           _
           x1)
        (liftAdditivePointedMagmaOpenLang
           _
           x2)
  
  module AdditivePointedSemigroup where
    record AdditivePointedSemigroup
      (A : Set) : Set where
      constructor AdditivePointedSemigroupC
      field
        0 : A
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record AdditivePointedSemigroupSig
      (AS : Set) : Set where
      constructor AdditivePointedSemigroupSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
    record AdditivePointedSemigroupProd
      (AP : Set) : Set where
      constructor AdditivePointedSemigroupProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record AdditivePointedSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditivePointedSemigroup
         A1)
      (Ad2 : AdditivePointedSemigroup
         A2) : Set where
      constructor AdditivePointedSemigroupHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditivePointedSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditivePointedSemigroup
         A1)
      (Ad2 : AdditivePointedSemigroup
         A2) : Set where
      constructor AdditivePointedSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditivePointedSemigroupLang
      : Set where
      0L :
        AdditivePointedSemigroupLang
      +L :
        AdditivePointedSemigroupLang ->
        AdditivePointedSemigroupLang ->
        AdditivePointedSemigroupLang
    data AdditivePointedSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AdditivePointedSemigroupOpenLang
          n
      0OL :
        AdditivePointedSemigroupOpenLang
          n
      +OL :
        AdditivePointedSemigroupOpenLang
          n ->
        AdditivePointedSemigroupOpenLang
          n ->
        AdditivePointedSemigroupOpenLang
          n
    evalTerm :
      (A : Set) ->
      AdditivePointedSemigroup A ->
      AdditivePointedSemigroupLang ->
      A
    evalTerm _ Ad (0L) = 0 Ad
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditivePointedSemigroup A ->
      AdditivePointedSemigroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (0OL) vars =
      0 ad
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    simplify :
      AdditivePointedSemigroupLang ->
      AdditivePointedSemigroupLang
    simplify (0L) = 0L
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftAdditivePointedSemigroupLang :
      AdditivePointedSemigroupLang ->
      Staged
        AdditivePointedSemigroupLang
    liftAdditivePointedSemigroupLang x =
      Now x
    0OL' :
      (n : Nat) ->
      AdditivePointedSemigroupOpenLang
        n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      AdditivePointedSemigroupOpenLang
        n ->
      AdditivePointedSemigroupOpenLang
        n ->
      AdditivePointedSemigroupOpenLang
        n
    +OL' _ x1 x2 = +OL x1 x2
    liftAdditivePointedSemigroupOpenLang :
      (n : Nat) ->
      AdditivePointedSemigroupOpenLang
        n ->
      Staged
        (AdditivePointedSemigroupOpenLang
           n)
    liftAdditivePointedSemigroupOpenLang _ (v
                                            fin) = const _ (code _ (v fin))
    liftAdditivePointedSemigroupOpenLang _ (0OL) =
      Now 0OL
    liftAdditivePointedSemigroupOpenLang _ (+OL
                                            x1
                                            x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftAdditivePointedSemigroupOpenLang
           _
           x1)
        (liftAdditivePointedSemigroupOpenLang
           _
           x2)
  
  module AdditiveSemigroup where
    record AdditiveSemigroup
      (A : Set) : Set where
      constructor AdditiveSemigroupC
      field
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record AdditiveSemigroupSig
      (AS : Set) : Set where
      constructor AdditiveSemigroupSigSigC
      field
        +S : AS -> AS -> AS
    record AdditiveSemigroupProd
      (AP : Set) : Set where
      constructor AdditiveSemigroupProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record AdditiveSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveSemigroup A1)
      (Ad2 : AdditiveSemigroup A2) :
      Set where
      constructor AdditiveSemigroupHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveSemigroup A1)
      (Ad2 : AdditiveSemigroup A2) :
      Set where
      constructor AdditiveSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveSemigroupLang
      : Set where
      +L :
        AdditiveSemigroupLang ->
        AdditiveSemigroupLang ->
        AdditiveSemigroupLang
    data AdditiveSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AdditiveSemigroupOpenLang n
      +OL :
        AdditiveSemigroupOpenLang n ->
        AdditiveSemigroupOpenLang n ->
        AdditiveSemigroupOpenLang n
    evalTerm :
      (A : Set) ->
      AdditiveSemigroup A ->
      AdditiveSemigroupLang -> A
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditiveSemigroup A ->
      AdditiveSemigroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    simplify :
      AdditiveSemigroupLang ->
      AdditiveSemigroupLang
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftAdditiveSemigroupLang :
      AdditiveSemigroupLang ->
      Staged AdditiveSemigroupLang
    liftAdditiveSemigroupLang x =
      Now x
    +OL' :
      (n : Nat) ->
      AdditiveSemigroupOpenLang n ->
      AdditiveSemigroupOpenLang n ->
      AdditiveSemigroupOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftAdditiveSemigroupOpenLang :
      (n : Nat) ->
      AdditiveSemigroupOpenLang n ->
      Staged
        (AdditiveSemigroupOpenLang n)
    liftAdditiveSemigroupOpenLang _ (v
                                     fin) = const _ (code _ (v fin))
    liftAdditiveSemigroupOpenLang _ (+OL
                                     x1
                                     x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftAdditiveSemigroupOpenLang _
           x1)
        (liftAdditiveSemigroupOpenLang _
           x2)
  
  module AdditiveUnaryAntiDistribution where
    record AdditiveUnaryAntiDistribution
      (A : Set) : Set where
      constructor AdditiveUnaryAntiDistributionC
      field
        prim : A -> A
        + : A -> A -> A
        antidis_prim_+ :
          (x : A) (y : A) ->
          prim (+ x y) ==
            + (prim y) (prim x)
    record AdditiveUnaryAntiDistributionSig
      (AS : Set) : Set where
      constructor AdditiveUnaryAntiDistributionSigSigC
      field
        primS : AS -> AS
        +S : AS -> AS -> AS
    record AdditiveUnaryAntiDistributionProd
      (AP : Set) : Set where
      constructor AdditiveUnaryAntiDistributionProdC
      field
        primP : Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        antidis_prim_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (+P xP yP) ==
            +P (primP yP) (primP xP)
    record AdditiveUnaryAntiDistributionHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveUnaryAntiDistribution
         A1)
      (Ad2 : AdditiveUnaryAntiDistribution
         A2) : Set where
      constructor AdditiveUnaryAntiDistributionHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Ad1 x1) ==
            prim Ad2 (hom x1)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveUnaryAntiDistributionRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveUnaryAntiDistribution
         A1)
      (Ad2 : AdditiveUnaryAntiDistribution
         A2) : Set where
      constructor AdditiveUnaryAntiDistributionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Ad1 x1)
            (prim Ad2 y1)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveUnaryAntiDistributionLang
      : Set where
      primL :
        AdditiveUnaryAntiDistributionLang ->
        AdditiveUnaryAntiDistributionLang
      +L :
        AdditiveUnaryAntiDistributionLang ->
        AdditiveUnaryAntiDistributionLang ->
        AdditiveUnaryAntiDistributionLang
    data AdditiveUnaryAntiDistributionOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AdditiveUnaryAntiDistributionOpenLang
          n
      primOL :
        AdditiveUnaryAntiDistributionOpenLang
          n ->
        AdditiveUnaryAntiDistributionOpenLang
          n
      +OL :
        AdditiveUnaryAntiDistributionOpenLang
          n ->
        AdditiveUnaryAntiDistributionOpenLang
          n ->
        AdditiveUnaryAntiDistributionOpenLang
          n
    evalTerm :
      (A : Set) ->
      AdditiveUnaryAntiDistribution
        A ->
      AdditiveUnaryAntiDistributionLang ->
      A
    evalTerm _ Ad (primL x1) =
      prim Ad (evalTerm _ Ad x1)
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditiveUnaryAntiDistribution
        A ->
      AdditiveUnaryAntiDistributionOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (primOL
                         x1) vars =
      prim ad
        (evalOpenTerm _ n ad x1 vars)
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    simplify :
      AdditiveUnaryAntiDistributionLang ->
      AdditiveUnaryAntiDistributionLang
    simplify (+L
              (primL y)
              (primL x)) = primL (+L x y)
    simplify (primL x1) =
      primL (simplify x1)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftAdditiveUnaryAntiDistributionLang :
      AdditiveUnaryAntiDistributionLang ->
      Staged
        AdditiveUnaryAntiDistributionLang
    liftAdditiveUnaryAntiDistributionLang x =
      Now x
    primOL' :
      (n : Nat) ->
      AdditiveUnaryAntiDistributionOpenLang
        n ->
      AdditiveUnaryAntiDistributionOpenLang
        n
    primOL' _ x1 = primOL x1
    +OL' :
      (n : Nat) ->
      AdditiveUnaryAntiDistributionOpenLang
        n ->
      AdditiveUnaryAntiDistributionOpenLang
        n ->
      AdditiveUnaryAntiDistributionOpenLang
        n
    +OL' _ x1 x2 = +OL x1 x2
    liftAdditiveUnaryAntiDistributionOpenLang :
      (n : Nat) ->
      AdditiveUnaryAntiDistributionOpenLang
        n ->
      Staged
        (AdditiveUnaryAntiDistributionOpenLang
           n)
    liftAdditiveUnaryAntiDistributionOpenLang _ (v
                                                 fin) = const _ (code _ (v fin))
    liftAdditiveUnaryAntiDistributionOpenLang _ (primOL
                                                 x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftAdditiveUnaryAntiDistributionOpenLang
           _
           x1)
    liftAdditiveUnaryAntiDistributionOpenLang _ (+OL
                                                 x1
                                                 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftAdditiveUnaryAntiDistributionOpenLang
           _
           x1)
        (liftAdditiveUnaryAntiDistributionOpenLang
           _
           x2)
  
  module AdditiveUnital where
    record AdditiveUnital
      (A : Set) : Set where
      constructor AdditiveUnitalC
      field
        0 : A
        + : A -> A -> A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
    record AdditiveUnitalSig
      (AS : Set) : Set where
      constructor AdditiveUnitalSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
    record AdditiveUnitalProd
      (AP : Set) : Set where
      constructor AdditiveUnitalProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
    record AdditiveUnitalHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveUnital A1)
      (Ad2 : AdditiveUnital A2) :
      Set where
      constructor AdditiveUnitalHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveUnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveUnital A1)
      (Ad2 : AdditiveUnital A2) :
      Set where
      constructor AdditiveUnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveUnitalLang
      : Set where
      0L : AdditiveUnitalLang
      +L :
        AdditiveUnitalLang ->
        AdditiveUnitalLang ->
        AdditiveUnitalLang
    data AdditiveUnitalOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AdditiveUnitalOpenLang n
      0OL : AdditiveUnitalOpenLang n
      +OL :
        AdditiveUnitalOpenLang n ->
        AdditiveUnitalOpenLang n ->
        AdditiveUnitalOpenLang n
    evalTerm :
      (A : Set) ->
      AdditiveUnital A ->
      AdditiveUnitalLang -> A
    evalTerm _ Ad (0L) = 0 Ad
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditiveUnital A ->
      AdditiveUnitalOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (0OL) vars =
      0 ad
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    simplify :
      AdditiveUnitalLang ->
      AdditiveUnitalLang
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (0L) = 0L
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftAdditiveUnitalLang :
      AdditiveUnitalLang ->
      Staged AdditiveUnitalLang
    liftAdditiveUnitalLang x = Now x
    0OL' :
      (n : Nat) ->
      AdditiveUnitalOpenLang n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      AdditiveUnitalOpenLang n ->
      AdditiveUnitalOpenLang n ->
      AdditiveUnitalOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftAdditiveUnitalOpenLang :
      (n : Nat) ->
      AdditiveUnitalOpenLang n ->
      Staged
        (AdditiveUnitalOpenLang n)
    liftAdditiveUnitalOpenLang _ (v
                                  fin) = const _ (code _ (v fin))
    liftAdditiveUnitalOpenLang _ (0OL) =
      Now 0OL
    liftAdditiveUnitalOpenLang _ (+OL
                                  x1
                                  x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftAdditiveUnitalOpenLang _
           x1)
        (liftAdditiveUnitalOpenLang _
           x2)
  
  module AndDeMorgan where
    record AndDeMorgan
      (A : Set) : Set where
      constructor AndDeMorganC
      field
        * : A -> A -> A
        + : A -> A -> A
        prim : A -> A
        andDeMorgan_*_+_prim :
          (x : A) (y : A) (z : A) ->
          prim (* x y) ==
            + (prim x) (prim y)
    record AndDeMorganSig
      (AS : Set) : Set where
      constructor AndDeMorganSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        primS : AS -> AS
    record AndDeMorganProd
      (AP : Set) : Set where
      constructor AndDeMorganProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        andDeMorgan_*_+_primP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          primP (*P xP yP) ==
            +P (primP xP) (primP yP)
    record AndDeMorganHom
      (A1 : Set) (A2 : Set)
      (An1 : AndDeMorgan A1)
      (An2 : AndDeMorgan A2) :
      Set where
      constructor AndDeMorganHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* An1 x1 x2) ==
            * An2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ An1 x1 x2) ==
            + An2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim An1 x1) ==
            prim An2 (hom x1)
    record AndDeMorganRelInterp
      (A1 : Set) (A2 : Set)
      (An1 : AndDeMorgan A1)
      (An2 : AndDeMorgan A2) :
      Set where
      constructor AndDeMorganRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* An1 x1 x2)
            (* An2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ An1 x1 x2)
            (+ An2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim An1 x1)
            (prim An2 y1)
    data AndDeMorganLang : Set where
      *L :
        AndDeMorganLang ->
        AndDeMorganLang ->
        AndDeMorganLang
      +L :
        AndDeMorganLang ->
        AndDeMorganLang ->
        AndDeMorganLang
      primL :
        AndDeMorganLang ->
        AndDeMorganLang
    data AndDeMorganOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> AndDeMorganOpenLang n
      *OL :
        AndDeMorganOpenLang n ->
        AndDeMorganOpenLang n ->
        AndDeMorganOpenLang n
      +OL :
        AndDeMorganOpenLang n ->
        AndDeMorganOpenLang n ->
        AndDeMorganOpenLang n
      primOL :
        AndDeMorganOpenLang n ->
        AndDeMorganOpenLang n
    evalTerm :
      (A : Set) ->
      AndDeMorgan A ->
      AndDeMorganLang -> A
    evalTerm _ An (*L x1 x2) =
      * An (evalTerm _ An x1)
        (evalTerm _ An x2)
    evalTerm _ An (+L x1 x2) =
      + An (evalTerm _ An x1)
        (evalTerm _ An x2)
    evalTerm _ An (primL x1) =
      prim An (evalTerm _ An x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AndDeMorgan A ->
      AndDeMorganOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n an (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n an (*OL
                         x1
                         x2) vars =
      * an
        (evalOpenTerm _ n an x1 vars)
        (evalOpenTerm _ n an x2 vars)
    evalOpenTerm _ n an (+OL
                         x1
                         x2) vars =
      + an
        (evalOpenTerm _ n an x1 vars)
        (evalOpenTerm _ n an x2 vars)
    evalOpenTerm _ n an (primOL
                         x1) vars =
      prim an
        (evalOpenTerm _ n an x1 vars)
    simplify :
      AndDeMorganLang ->
      AndDeMorganLang
    simplify (+L
              (primL x)
              (primL y)) = primL (*L x y)
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (primL x1) =
      primL (simplify x1)
    liftAndDeMorganLang :
      AndDeMorganLang ->
      Staged AndDeMorganLang
    liftAndDeMorganLang x = Now x
    *OL' :
      (n : Nat) ->
      AndDeMorganOpenLang n ->
      AndDeMorganOpenLang n ->
      AndDeMorganOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      AndDeMorganOpenLang n ->
      AndDeMorganOpenLang n ->
      AndDeMorganOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    primOL' :
      (n : Nat) ->
      AndDeMorganOpenLang n ->
      AndDeMorganOpenLang n
    primOL' _ x1 = primOL x1
    liftAndDeMorganOpenLang :
      (n : Nat) ->
      AndDeMorganOpenLang n ->
      Staged (AndDeMorganOpenLang n)
    liftAndDeMorganOpenLang _ (v
                               fin) = const _ (code _ (v fin))
    liftAndDeMorganOpenLang _ (*OL
                               x1
                               x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftAndDeMorganOpenLang _ x1)
        (liftAndDeMorganOpenLang _ x2)
    liftAndDeMorganOpenLang _ (+OL
                               x1
                               x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftAndDeMorganOpenLang _ x1)
        (liftAndDeMorganOpenLang _ x2)
    liftAndDeMorganOpenLang _ (primOL
                               x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftAndDeMorganOpenLang _ x1)
  
  module AntiAbsorbent where
    record AntiAbsorbent
      (A : Set) : Set where
      constructor AntiAbsorbentC
      field
        op : A -> A -> A
        antiAbsorbent :
          (x : A) (y : A) ->
          op x (op x y) == y
    record AntiAbsorbentSig
      (AS : Set) : Set where
      constructor AntiAbsorbentSigSigC
      field
        opS : AS -> AS -> AS
    record AntiAbsorbentProd
      (AP : Set) : Set where
      constructor AntiAbsorbentProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        antiAbsorbentP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (opP xP yP) == yP
    record AntiAbsorbentHom
      (A1 : Set) (A2 : Set)
      (An1 : AntiAbsorbent A1)
      (An2 : AntiAbsorbent A2) :
      Set where
      constructor AntiAbsorbentHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op An1 x1 x2) ==
            op An2 (hom x1) (hom x2)
    record AntiAbsorbentRelInterp
      (A1 : Set) (A2 : Set)
      (An1 : AntiAbsorbent A1)
      (An2 : AntiAbsorbent A2) :
      Set where
      constructor AntiAbsorbentRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op An1 x1 x2)
            (op An2 y1 y2)
    data AntiAbsorbentLang
      : Set where
      opL :
        AntiAbsorbentLang ->
        AntiAbsorbentLang ->
        AntiAbsorbentLang
    data AntiAbsorbentOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> AntiAbsorbentOpenLang n
      opOL :
        AntiAbsorbentOpenLang n ->
        AntiAbsorbentOpenLang n ->
        AntiAbsorbentOpenLang n
    evalTerm :
      (A : Set) ->
      AntiAbsorbent A ->
      AntiAbsorbentLang -> A
    evalTerm _ An (opL x1 x2) =
      op An (evalTerm _ An x1)
        (evalTerm _ An x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AntiAbsorbent A ->
      AntiAbsorbentOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n an (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n an (opOL
                         x1
                         x2) vars =
      op an
        (evalOpenTerm _ n an x1 vars)
        (evalOpenTerm _ n an x2 vars)
    simplify :
      AntiAbsorbentLang ->
      AntiAbsorbentLang
    simplify (opL x (opL x y)) = y
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftAntiAbsorbentLang :
      AntiAbsorbentLang ->
      Staged AntiAbsorbentLang
    liftAntiAbsorbentLang x = Now x
    opOL' :
      (n : Nat) ->
      AntiAbsorbentOpenLang n ->
      AntiAbsorbentOpenLang n ->
      AntiAbsorbentOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftAntiAbsorbentOpenLang :
      (n : Nat) ->
      AntiAbsorbentOpenLang n ->
      Staged (AntiAbsorbentOpenLang n)
    liftAntiAbsorbentOpenLang _ (v
                                 fin) = const _ (code _ (v fin))
    liftAntiAbsorbentOpenLang _ (opOL
                                 x1
                                 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftAntiAbsorbentOpenLang _ x1)
        (liftAntiAbsorbentOpenLang _ x2)
  
  module AntiCommutativeRing where
    record AntiCommutativeRing
      (A : Set) : Set where
      constructor AntiCommutativeRingC
      field
        * : A -> A -> A
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
        antiCommutative :
          (x : A) (y : A) ->
          * x y == neg (* y x)
    record AntiCommutativeRingSig
      (AS : Set) : Set where
      constructor AntiCommutativeRingSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
        1S : AS
    record AntiCommutativeRingProd
      (AP : Set) : Set where
      constructor AntiCommutativeRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
        antiCommutativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == negP (*P yP xP)
    record AntiCommutativeRingHom
      (A1 : Set) (A2 : Set)
      (An1 : AntiCommutativeRing A1)
      (An2 : AntiCommutativeRing A2) :
      Set where
      constructor AntiCommutativeRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* An1 x1 x2) ==
            * An2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ An1 x1 x2) ==
            + An2 (hom x1) (hom x2)
        pres-0 : hom (0 An1) == 0 An2
        pres-neg :
          (x1 : A1) ->
          hom (neg An1 x1) ==
            neg An2 (hom x1)
        pres-1 : hom (1 An1) == 1 An2
    record AntiCommutativeRingRelInterp
      (A1 : Set) (A2 : Set)
      (An1 : AntiCommutativeRing A1)
      (An2 : AntiCommutativeRing A2) :
      Set where
      constructor AntiCommutativeRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* An1 x1 x2)
            (* An2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ An1 x1 x2)
            (+ An2 y1 y2)
        interp-0 :
          interp (0 An1) (0 An2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg An1 x1) (neg An2 y1)
        interp-1 :
          interp (1 An1) (1 An2)
    data AntiCommutativeRingLang
      : Set where
      *L :
        AntiCommutativeRingLang ->
        AntiCommutativeRingLang ->
        AntiCommutativeRingLang
      +L :
        AntiCommutativeRingLang ->
        AntiCommutativeRingLang ->
        AntiCommutativeRingLang
      0L : AntiCommutativeRingLang
      negL :
        AntiCommutativeRingLang ->
        AntiCommutativeRingLang
      1L : AntiCommutativeRingLang
    data AntiCommutativeRingOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AntiCommutativeRingOpenLang n
      *OL :
        AntiCommutativeRingOpenLang n ->
        AntiCommutativeRingOpenLang n ->
        AntiCommutativeRingOpenLang n
      +OL :
        AntiCommutativeRingOpenLang n ->
        AntiCommutativeRingOpenLang n ->
        AntiCommutativeRingOpenLang n
      0OL :
        AntiCommutativeRingOpenLang n
      negOL :
        AntiCommutativeRingOpenLang n ->
        AntiCommutativeRingOpenLang n
      1OL :
        AntiCommutativeRingOpenLang n
    evalTerm :
      (A : Set) ->
      AntiCommutativeRing A ->
      AntiCommutativeRingLang -> A
    evalTerm _ An (*L x1 x2) =
      * An (evalTerm _ An x1)
        (evalTerm _ An x2)
    evalTerm _ An (+L x1 x2) =
      + An (evalTerm _ An x1)
        (evalTerm _ An x2)
    evalTerm _ An (0L) = 0 An
    evalTerm _ An (negL x1) =
      neg An (evalTerm _ An x1)
    evalTerm _ An (1L) = 1 An
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AntiCommutativeRing A ->
      AntiCommutativeRingOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n an (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n an (*OL
                         x1
                         x2) vars =
      * an
        (evalOpenTerm _ n an x1 vars)
        (evalOpenTerm _ n an x2 vars)
    evalOpenTerm _ n an (+OL
                         x1
                         x2) vars =
      + an
        (evalOpenTerm _ n an x1 vars)
        (evalOpenTerm _ n an x2 vars)
    evalOpenTerm _ n an (0OL) vars =
      0 an
    evalOpenTerm _ n an (negOL
                         x1) vars =
      neg an
        (evalOpenTerm _ n an x1 vars)
    evalOpenTerm _ n an (1OL) vars =
      1 an
    simplify :
      AntiCommutativeRingLang ->
      AntiCommutativeRingLang
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (+L
              (*L x y)
              (*L x z)) = *L x (+L y z)
    simplify (+L
              (*L y x)
              (*L z x)) = *L (+L y z) x
    simplify (+L x (negL x)) = 0L
    simplify (+L (negL x) x) = 0L
    simplify (*L (1L) x) = x
    simplify (*L x (1L)) = x
    simplify (*L (0L) x) = 0L
    simplify (*L x (0L)) = 0L
    simplify (negL (*L y x)) =
      *L x y
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (0L) = 0L
    simplify (negL x1) =
      negL (simplify x1)
    simplify (1L) = 1L
    liftAntiCommutativeRingLang :
      AntiCommutativeRingLang ->
      Staged AntiCommutativeRingLang
    liftAntiCommutativeRingLang x =
      Now x
    *OL' :
      (n : Nat) ->
      AntiCommutativeRingOpenLang n ->
      AntiCommutativeRingOpenLang n ->
      AntiCommutativeRingOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      AntiCommutativeRingOpenLang n ->
      AntiCommutativeRingOpenLang n ->
      AntiCommutativeRingOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      AntiCommutativeRingOpenLang n
    0OL' _ = 0OL
    negOL' :
      (n : Nat) ->
      AntiCommutativeRingOpenLang n ->
      AntiCommutativeRingOpenLang n
    negOL' _ x1 = negOL x1
    1OL' :
      (n : Nat) ->
      AntiCommutativeRingOpenLang n
    1OL' _ = 1OL
    liftAntiCommutativeRingOpenLang :
      (n : Nat) ->
      AntiCommutativeRingOpenLang n ->
      Staged
        (AntiCommutativeRingOpenLang n)
    liftAntiCommutativeRingOpenLang _ (v
                                       fin) = const _ (code _ (v fin))
    liftAntiCommutativeRingOpenLang _ (*OL
                                       x1
                                       x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftAntiCommutativeRingOpenLang
           _
           x1)
        (liftAntiCommutativeRingOpenLang
           _
           x2)
    liftAntiCommutativeRingOpenLang _ (+OL
                                       x1
                                       x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftAntiCommutativeRingOpenLang
           _
           x1)
        (liftAntiCommutativeRingOpenLang
           _
           x2)
    liftAntiCommutativeRingOpenLang _ (0OL) =
      Now 0OL
    liftAntiCommutativeRingOpenLang _ (negOL
                                       x1) =
      stage1 _ _ (negOL' _)
        (codeLift1 _ _ (negOL' _))
        (liftAntiCommutativeRingOpenLang
           _
           x1)
    liftAntiCommutativeRingOpenLang _ (1OL) =
      Now 1OL
  
  module AssocPlusRingoid where
    record AssocPlusRingoid
      (A : Set) : Set where
      constructor AssocPlusRingoidC
      field
        + : A -> A -> A
        * : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record AssocPlusRingoidSig
      (AS : Set) : Set where
      constructor AssocPlusRingoidSigSigC
      field
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
    record AssocPlusRingoidProd
      (AP : Set) : Set where
      constructor AssocPlusRingoidProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record AssocPlusRingoidHom
      (A1 : Set) (A2 : Set)
      (As1 : AssocPlusRingoid A1)
      (As2 : AssocPlusRingoid A2) :
      Set where
      constructor AssocPlusRingoidHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ As1 x1 x2) ==
            + As2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* As1 x1 x2) ==
            * As2 (hom x1) (hom x2)
    record AssocPlusRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (As1 : AssocPlusRingoid A1)
      (As2 : AssocPlusRingoid A2) :
      Set where
      constructor AssocPlusRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ As1 x1 x2)
            (+ As2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* As1 x1 x2)
            (* As2 y1 y2)
    data AssocPlusRingoidLang
      : Set where
      +L :
        AssocPlusRingoidLang ->
        AssocPlusRingoidLang ->
        AssocPlusRingoidLang
      *L :
        AssocPlusRingoidLang ->
        AssocPlusRingoidLang ->
        AssocPlusRingoidLang
    data AssocPlusRingoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AssocPlusRingoidOpenLang n
      +OL :
        AssocPlusRingoidOpenLang n ->
        AssocPlusRingoidOpenLang n ->
        AssocPlusRingoidOpenLang n
      *OL :
        AssocPlusRingoidOpenLang n ->
        AssocPlusRingoidOpenLang n ->
        AssocPlusRingoidOpenLang n
    evalTerm :
      (A : Set) ->
      AssocPlusRingoid A ->
      AssocPlusRingoidLang -> A
    evalTerm _ As (+L x1 x2) =
      + As (evalTerm _ As x1)
        (evalTerm _ As x2)
    evalTerm _ As (*L x1 x2) =
      * As (evalTerm _ As x1)
        (evalTerm _ As x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AssocPlusRingoid A ->
      AssocPlusRingoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n as (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n as (+OL
                         x1
                         x2) vars =
      + as
        (evalOpenTerm _ n as x1 vars)
        (evalOpenTerm _ n as x2 vars)
    evalOpenTerm _ n as (*OL
                         x1
                         x2) vars =
      * as
        (evalOpenTerm _ n as x1 vars)
        (evalOpenTerm _ n as x2 vars)
    simplify :
      AssocPlusRingoidLang ->
      AssocPlusRingoidLang
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    liftAssocPlusRingoidLang :
      AssocPlusRingoidLang ->
      Staged AssocPlusRingoidLang
    liftAssocPlusRingoidLang x =
      Now x
    +OL' :
      (n : Nat) ->
      AssocPlusRingoidOpenLang n ->
      AssocPlusRingoidOpenLang n ->
      AssocPlusRingoidOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    *OL' :
      (n : Nat) ->
      AssocPlusRingoidOpenLang n ->
      AssocPlusRingoidOpenLang n ->
      AssocPlusRingoidOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    liftAssocPlusRingoidOpenLang :
      (n : Nat) ->
      AssocPlusRingoidOpenLang n ->
      Staged
        (AssocPlusRingoidOpenLang n)
    liftAssocPlusRingoidOpenLang _ (v
                                    fin) = const _ (code _ (v fin))
    liftAssocPlusRingoidOpenLang _ (+OL
                                    x1
                                    x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftAssocPlusRingoidOpenLang _
           x1)
        (liftAssocPlusRingoidOpenLang _
           x2)
    liftAssocPlusRingoidOpenLang _ (*OL
                                    x1
                                    x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftAssocPlusRingoidOpenLang _
           x1)
        (liftAssocPlusRingoidOpenLang _
           x2)
  
  module AssocTimesRingoid where
    record AssocTimesRingoid
      (A : Set) : Set where
      constructor AssocTimesRingoidC
      field
        * : A -> A -> A
        + : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
    record AssocTimesRingoidSig
      (AS : Set) : Set where
      constructor AssocTimesRingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record AssocTimesRingoidProd
      (AP : Set) : Set where
      constructor AssocTimesRingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
    record AssocTimesRingoidHom
      (A1 : Set) (A2 : Set)
      (As1 : AssocTimesRingoid A1)
      (As2 : AssocTimesRingoid A2) :
      Set where
      constructor AssocTimesRingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* As1 x1 x2) ==
            * As2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ As1 x1 x2) ==
            + As2 (hom x1) (hom x2)
    record AssocTimesRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (As1 : AssocTimesRingoid A1)
      (As2 : AssocTimesRingoid A2) :
      Set where
      constructor AssocTimesRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* As1 x1 x2)
            (* As2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ As1 x1 x2)
            (+ As2 y1 y2)
    data AssocTimesRingoidLang
      : Set where
      *L :
        AssocTimesRingoidLang ->
        AssocTimesRingoidLang ->
        AssocTimesRingoidLang
      +L :
        AssocTimesRingoidLang ->
        AssocTimesRingoidLang ->
        AssocTimesRingoidLang
    data AssocTimesRingoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AssocTimesRingoidOpenLang n
      *OL :
        AssocTimesRingoidOpenLang n ->
        AssocTimesRingoidOpenLang n ->
        AssocTimesRingoidOpenLang n
      +OL :
        AssocTimesRingoidOpenLang n ->
        AssocTimesRingoidOpenLang n ->
        AssocTimesRingoidOpenLang n
    evalTerm :
      (A : Set) ->
      AssocTimesRingoid A ->
      AssocTimesRingoidLang -> A
    evalTerm _ As (*L x1 x2) =
      * As (evalTerm _ As x1)
        (evalTerm _ As x2)
    evalTerm _ As (+L x1 x2) =
      + As (evalTerm _ As x1)
        (evalTerm _ As x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AssocTimesRingoid A ->
      AssocTimesRingoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n as (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n as (*OL
                         x1
                         x2) vars =
      * as
        (evalOpenTerm _ n as x1 vars)
        (evalOpenTerm _ n as x2 vars)
    evalOpenTerm _ n as (+OL
                         x1
                         x2) vars =
      + as
        (evalOpenTerm _ n as x1 vars)
        (evalOpenTerm _ n as x2 vars)
    simplify :
      AssocTimesRingoidLang ->
      AssocTimesRingoidLang
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftAssocTimesRingoidLang :
      AssocTimesRingoidLang ->
      Staged AssocTimesRingoidLang
    liftAssocTimesRingoidLang x =
      Now x
    *OL' :
      (n : Nat) ->
      AssocTimesRingoidOpenLang n ->
      AssocTimesRingoidOpenLang n ->
      AssocTimesRingoidOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      AssocTimesRingoidOpenLang n ->
      AssocTimesRingoidOpenLang n ->
      AssocTimesRingoidOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftAssocTimesRingoidOpenLang :
      (n : Nat) ->
      AssocTimesRingoidOpenLang n ->
      Staged
        (AssocTimesRingoidOpenLang n)
    liftAssocTimesRingoidOpenLang _ (v
                                     fin) = const _ (code _ (v fin))
    liftAssocTimesRingoidOpenLang _ (*OL
                                     x1
                                     x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftAssocTimesRingoidOpenLang _
           x1)
        (liftAssocTimesRingoidOpenLang _
           x2)
    liftAssocTimesRingoidOpenLang _ (+OL
                                     x1
                                     x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftAssocTimesRingoidOpenLang _
           x1)
        (liftAssocTimesRingoidOpenLang _
           x2)
  
  module AssociativeLeftRingoid where
    record AssociativeLeftRingoid
      (A : Set) : Set where
      constructor AssociativeLeftRingoidC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
    record AssociativeLeftRingoidSig
      (AS : Set) : Set where
      constructor AssociativeLeftRingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record AssociativeLeftRingoidProd
      (AP : Set) : Set where
      constructor AssociativeLeftRingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
    record AssociativeLeftRingoidHom
      (A1 : Set) (A2 : Set)
      (As1 : AssociativeLeftRingoid
         A1)
      (As2 : AssociativeLeftRingoid
         A2) : Set where
      constructor AssociativeLeftRingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* As1 x1 x2) ==
            * As2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ As1 x1 x2) ==
            + As2 (hom x1) (hom x2)
    record AssociativeLeftRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (As1 : AssociativeLeftRingoid
         A1)
      (As2 : AssociativeLeftRingoid
         A2) : Set where
      constructor AssociativeLeftRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* As1 x1 x2)
            (* As2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ As1 x1 x2)
            (+ As2 y1 y2)
    data AssociativeLeftRingoidLang
      : Set where
      *L :
        AssociativeLeftRingoidLang ->
        AssociativeLeftRingoidLang ->
        AssociativeLeftRingoidLang
      +L :
        AssociativeLeftRingoidLang ->
        AssociativeLeftRingoidLang ->
        AssociativeLeftRingoidLang
    data AssociativeLeftRingoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AssociativeLeftRingoidOpenLang n
      *OL :
        AssociativeLeftRingoidOpenLang
          n ->
        AssociativeLeftRingoidOpenLang
          n ->
        AssociativeLeftRingoidOpenLang n
      +OL :
        AssociativeLeftRingoidOpenLang
          n ->
        AssociativeLeftRingoidOpenLang
          n ->
        AssociativeLeftRingoidOpenLang n
    evalTerm :
      (A : Set) ->
      AssociativeLeftRingoid A ->
      AssociativeLeftRingoidLang -> A
    evalTerm _ As (*L x1 x2) =
      * As (evalTerm _ As x1)
        (evalTerm _ As x2)
    evalTerm _ As (+L x1 x2) =
      + As (evalTerm _ As x1)
        (evalTerm _ As x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AssociativeLeftRingoid A ->
      AssociativeLeftRingoidOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n as (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n as (*OL
                         x1
                         x2) vars =
      * as
        (evalOpenTerm _ n as x1 vars)
        (evalOpenTerm _ n as x2 vars)
    evalOpenTerm _ n as (+OL
                         x1
                         x2) vars =
      + as
        (evalOpenTerm _ n as x1 vars)
        (evalOpenTerm _ n as x2 vars)
    simplify :
      AssociativeLeftRingoidLang ->
      AssociativeLeftRingoidLang
    simplify (+L
              (*L x y)
              (*L x z)) = *L x (+L y z)
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftAssociativeLeftRingoidLang :
      AssociativeLeftRingoidLang ->
      Staged
        AssociativeLeftRingoidLang
    liftAssociativeLeftRingoidLang x =
      Now x
    *OL' :
      (n : Nat) ->
      AssociativeLeftRingoidOpenLang
        n ->
      AssociativeLeftRingoidOpenLang
        n ->
      AssociativeLeftRingoidOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      AssociativeLeftRingoidOpenLang
        n ->
      AssociativeLeftRingoidOpenLang
        n ->
      AssociativeLeftRingoidOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftAssociativeLeftRingoidOpenLang :
      (n : Nat) ->
      AssociativeLeftRingoidOpenLang
        n ->
      Staged
        (AssociativeLeftRingoidOpenLang
           n)
    liftAssociativeLeftRingoidOpenLang _ (v
                                          fin) = const _ (code _ (v fin))
    liftAssociativeLeftRingoidOpenLang _ (*OL
                                          x1
                                          x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftAssociativeLeftRingoidOpenLang
           _
           x1)
        (liftAssociativeLeftRingoidOpenLang
           _
           x2)
    liftAssociativeLeftRingoidOpenLang _ (+OL
                                          x1
                                          x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftAssociativeLeftRingoidOpenLang
           _
           x1)
        (liftAssociativeLeftRingoidOpenLang
           _
           x2)
  
  module AssociativeNonDistributiveRingoid where
    record AssociativeNonDistributiveRingoid
      (A : Set) : Set where
      constructor AssociativeNonDistributiveRingoidC
      field
        * : A -> A -> A
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
    record AssociativeNonDistributiveRingoidSig
      (AS : Set) : Set where
      constructor AssociativeNonDistributiveRingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record AssociativeNonDistributiveRingoidProd
      (AP : Set) : Set where
      constructor AssociativeNonDistributiveRingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
    record AssociativeNonDistributiveRingoidHom
      (A1 : Set) (A2 : Set)
      (As1 : AssociativeNonDistributiveRingoid
         A1)
      (As2 : AssociativeNonDistributiveRingoid
         A2) : Set where
      constructor AssociativeNonDistributiveRingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* As1 x1 x2) ==
            * As2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ As1 x1 x2) ==
            + As2 (hom x1) (hom x2)
    record AssociativeNonDistributiveRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (As1 : AssociativeNonDistributiveRingoid
         A1)
      (As2 : AssociativeNonDistributiveRingoid
         A2) : Set where
      constructor AssociativeNonDistributiveRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* As1 x1 x2)
            (* As2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ As1 x1 x2)
            (+ As2 y1 y2)
    data AssociativeNonDistributiveRingoidLang
      : Set where
      *L :
        AssociativeNonDistributiveRingoidLang ->
        AssociativeNonDistributiveRingoidLang ->
        AssociativeNonDistributiveRingoidLang
      +L :
        AssociativeNonDistributiveRingoidLang ->
        AssociativeNonDistributiveRingoidLang ->
        AssociativeNonDistributiveRingoidLang
    data AssociativeNonDistributiveRingoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AssociativeNonDistributiveRingoidOpenLang
          n
      *OL :
        AssociativeNonDistributiveRingoidOpenLang
          n ->
        AssociativeNonDistributiveRingoidOpenLang
          n ->
        AssociativeNonDistributiveRingoidOpenLang
          n
      +OL :
        AssociativeNonDistributiveRingoidOpenLang
          n ->
        AssociativeNonDistributiveRingoidOpenLang
          n ->
        AssociativeNonDistributiveRingoidOpenLang
          n
    evalTerm :
      (A : Set) ->
      AssociativeNonDistributiveRingoid
        A ->
      AssociativeNonDistributiveRingoidLang ->
      A
    evalTerm _ As (*L x1 x2) =
      * As (evalTerm _ As x1)
        (evalTerm _ As x2)
    evalTerm _ As (+L x1 x2) =
      + As (evalTerm _ As x1)
        (evalTerm _ As x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AssociativeNonDistributiveRingoid
        A ->
      AssociativeNonDistributiveRingoidOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n as (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n as (*OL
                         x1
                         x2) vars =
      * as
        (evalOpenTerm _ n as x1 vars)
        (evalOpenTerm _ n as x2 vars)
    evalOpenTerm _ n as (+OL
                         x1
                         x2) vars =
      + as
        (evalOpenTerm _ n as x1 vars)
        (evalOpenTerm _ n as x2 vars)
    simplify :
      AssociativeNonDistributiveRingoidLang ->
      AssociativeNonDistributiveRingoidLang
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftAssociativeNonDistributiveRingoidLang :
      AssociativeNonDistributiveRingoidLang ->
      Staged
        AssociativeNonDistributiveRingoidLang
    liftAssociativeNonDistributiveRingoidLang x =
      Now x
    *OL' :
      (n : Nat) ->
      AssociativeNonDistributiveRingoidOpenLang
        n ->
      AssociativeNonDistributiveRingoidOpenLang
        n ->
      AssociativeNonDistributiveRingoidOpenLang
        n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      AssociativeNonDistributiveRingoidOpenLang
        n ->
      AssociativeNonDistributiveRingoidOpenLang
        n ->
      AssociativeNonDistributiveRingoidOpenLang
        n
    +OL' _ x1 x2 = +OL x1 x2
    liftAssociativeNonDistributiveRingoidOpenLang :
      (n : Nat) ->
      AssociativeNonDistributiveRingoidOpenLang
        n ->
      Staged
        (AssociativeNonDistributiveRingoidOpenLang
           n)
    liftAssociativeNonDistributiveRingoidOpenLang _ (v
                                                     fin) =
      const _ (code _ (v fin))
    liftAssociativeNonDistributiveRingoidOpenLang _ (*OL
                                                     x1
                                                     x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftAssociativeNonDistributiveRingoidOpenLang
           _
           x1)
        (liftAssociativeNonDistributiveRingoidOpenLang
           _
           x2)
    liftAssociativeNonDistributiveRingoidOpenLang _ (+OL
                                                     x1
                                                     x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftAssociativeNonDistributiveRingoidOpenLang
           _
           x1)
        (liftAssociativeNonDistributiveRingoidOpenLang
           _
           x2)
  
  module AssociativeRightRingoid where
    record AssociativeRightRingoid
      (A : Set) : Set where
      constructor AssociativeRightRingoidC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        + : A -> A -> A
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record AssociativeRightRingoidSig
      (AS : Set) : Set where
      constructor AssociativeRightRingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record AssociativeRightRingoidProd
      (AP : Set) : Set where
      constructor AssociativeRightRingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record AssociativeRightRingoidHom
      (A1 : Set) (A2 : Set)
      (As1 : AssociativeRightRingoid
         A1)
      (As2 : AssociativeRightRingoid
         A2) : Set where
      constructor AssociativeRightRingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* As1 x1 x2) ==
            * As2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ As1 x1 x2) ==
            + As2 (hom x1) (hom x2)
    record AssociativeRightRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (As1 : AssociativeRightRingoid
         A1)
      (As2 : AssociativeRightRingoid
         A2) : Set where
      constructor AssociativeRightRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* As1 x1 x2)
            (* As2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ As1 x1 x2)
            (+ As2 y1 y2)
    data AssociativeRightRingoidLang
      : Set where
      *L :
        AssociativeRightRingoidLang ->
        AssociativeRightRingoidLang ->
        AssociativeRightRingoidLang
      +L :
        AssociativeRightRingoidLang ->
        AssociativeRightRingoidLang ->
        AssociativeRightRingoidLang
    data AssociativeRightRingoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AssociativeRightRingoidOpenLang
          n
      *OL :
        AssociativeRightRingoidOpenLang
          n ->
        AssociativeRightRingoidOpenLang
          n ->
        AssociativeRightRingoidOpenLang
          n
      +OL :
        AssociativeRightRingoidOpenLang
          n ->
        AssociativeRightRingoidOpenLang
          n ->
        AssociativeRightRingoidOpenLang
          n
    evalTerm :
      (A : Set) ->
      AssociativeRightRingoid A ->
      AssociativeRightRingoidLang -> A
    evalTerm _ As (*L x1 x2) =
      * As (evalTerm _ As x1)
        (evalTerm _ As x2)
    evalTerm _ As (+L x1 x2) =
      + As (evalTerm _ As x1)
        (evalTerm _ As x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AssociativeRightRingoid A ->
      AssociativeRightRingoidOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n as (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n as (*OL
                         x1
                         x2) vars =
      * as
        (evalOpenTerm _ n as x1 vars)
        (evalOpenTerm _ n as x2 vars)
    evalOpenTerm _ n as (+OL
                         x1
                         x2) vars =
      + as
        (evalOpenTerm _ n as x1 vars)
        (evalOpenTerm _ n as x2 vars)
    simplify :
      AssociativeRightRingoidLang ->
      AssociativeRightRingoidLang
    simplify (+L
              (*L y x)
              (*L z x)) = *L (+L y z) x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftAssociativeRightRingoidLang :
      AssociativeRightRingoidLang ->
      Staged
        AssociativeRightRingoidLang
    liftAssociativeRightRingoidLang x =
      Now x
    *OL' :
      (n : Nat) ->
      AssociativeRightRingoidOpenLang
        n ->
      AssociativeRightRingoidOpenLang
        n ->
      AssociativeRightRingoidOpenLang
        n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      AssociativeRightRingoidOpenLang
        n ->
      AssociativeRightRingoidOpenLang
        n ->
      AssociativeRightRingoidOpenLang
        n
    +OL' _ x1 x2 = +OL x1 x2
    liftAssociativeRightRingoidOpenLang :
      (n : Nat) ->
      AssociativeRightRingoidOpenLang
        n ->
      Staged
        (AssociativeRightRingoidOpenLang
           n)
    liftAssociativeRightRingoidOpenLang _ (v
                                           fin) = const _ (code _ (v fin))
    liftAssociativeRightRingoidOpenLang _ (*OL
                                           x1
                                           x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftAssociativeRightRingoidOpenLang
           _
           x1)
        (liftAssociativeRightRingoidOpenLang
           _
           x2)
    liftAssociativeRightRingoidOpenLang _ (+OL
                                           x1
                                           x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftAssociativeRightRingoidOpenLang
           _
           x1)
        (liftAssociativeRightRingoidOpenLang
           _
           x2)
  
  module Band where
    record Band
      (A : Set) : Set where
      constructor BandC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        idempotent_op :
          (x : A) -> op x x == x
    record BandSig
      (AS : Set) : Set where
      constructor BandSigSigC
      field
        opS : AS -> AS -> AS
    record BandProd
      (AP : Set) : Set where
      constructor BandProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        idempotent_opP :
          (xP : Prod AP AP) ->
          opP xP xP == xP
    record BandHom
      (A1 : Set) (A2 : Set)
      (Ba1 : Band A1)
      (Ba2 : Band A2) : Set where
      constructor BandHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ba1 x1 x2) ==
            op Ba2 (hom x1) (hom x2)
    record BandRelInterp
      (A1 : Set) (A2 : Set)
      (Ba1 : Band A1)
      (Ba2 : Band A2) : Set where
      constructor BandRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ba1 x1 x2)
            (op Ba2 y1 y2)
    data BandLang : Set where
      opL :
        BandLang -> BandLang -> BandLang
    data BandOpenLang
      (n : Nat) : Set where
      v : Fin n -> BandOpenLang n
      opOL :
        BandOpenLang n ->
        BandOpenLang n -> BandOpenLang n
    evalTerm :
      (A : Set) ->
      Band A -> BandLang -> A
    evalTerm _ Ba (opL x1 x2) =
      op Ba (evalTerm _ Ba x1)
        (evalTerm _ Ba x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Band A ->
      BandOpenLang n -> Vec A n -> A
    evalOpenTerm _ n ba (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ba (opOL
                         x1
                         x2) vars =
      op ba
        (evalOpenTerm _ n ba x1 vars)
        (evalOpenTerm _ n ba x2 vars)
    simplify : BandLang -> BandLang
    simplify (opL x x) = x
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftBandLang :
      BandLang -> Staged BandLang
    liftBandLang x = Now x
    opOL' :
      (n : Nat) ->
      BandOpenLang n ->
      BandOpenLang n -> BandOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftBandOpenLang :
      (n : Nat) ->
      BandOpenLang n ->
      Staged (BandOpenLang n)
    liftBandOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftBandOpenLang _ (opOL
                        x1
                        x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftBandOpenLang _ x1)
        (liftBandOpenLang _ x2)
  
  module BinaryInverse where
    record BinaryInverse
      (A : Set) : Set where
      constructor BinaryInverseC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftInverse :
          (x : A) (y : A) ->
          <| (|> x y) x == y
        rightInverse :
          (x : A) (y : A) ->
          |> x (<| y x) == y
    record BinaryInverseSig
      (AS : Set) : Set where
      constructor BinaryInverseSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record BinaryInverseProd
      (AP : Set) : Set where
      constructor BinaryInverseProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          <|P (|>P xP yP) xP == yP
        rightInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          |>P xP (<|P yP xP) == yP
    record BinaryInverseHom
      (A1 : Set) (A2 : Set)
      (Bi1 : BinaryInverse A1)
      (Bi2 : BinaryInverse A2) :
      Set where
      constructor BinaryInverseHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Bi1 x1 x2) ==
            |> Bi2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Bi1 x1 x2) ==
            <| Bi2 (hom x1) (hom x2)
    record BinaryInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Bi1 : BinaryInverse A1)
      (Bi2 : BinaryInverse A2) :
      Set where
      constructor BinaryInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Bi1 x1 x2)
            (|> Bi2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Bi1 x1 x2)
            (<| Bi2 y1 y2)
    data BinaryInverseLang
      : Set where
      |>L :
        BinaryInverseLang ->
        BinaryInverseLang ->
        BinaryInverseLang
      <|L :
        BinaryInverseLang ->
        BinaryInverseLang ->
        BinaryInverseLang
    data BinaryInverseOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> BinaryInverseOpenLang n
      |>OL :
        BinaryInverseOpenLang n ->
        BinaryInverseOpenLang n ->
        BinaryInverseOpenLang n
      <|OL :
        BinaryInverseOpenLang n ->
        BinaryInverseOpenLang n ->
        BinaryInverseOpenLang n
    evalTerm :
      (A : Set) ->
      BinaryInverse A ->
      BinaryInverseLang -> A
    evalTerm _ Bi (|>L x1 x2) =
      |> Bi (evalTerm _ Bi x1)
        (evalTerm _ Bi x2)
    evalTerm _ Bi (<|L x1 x2) =
      <| Bi (evalTerm _ Bi x1)
        (evalTerm _ Bi x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      BinaryInverse A ->
      BinaryInverseOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n bi (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n bi (|>OL
                         x1
                         x2) vars =
      |> bi
        (evalOpenTerm _ n bi x1 vars)
        (evalOpenTerm _ n bi x2 vars)
    evalOpenTerm _ n bi (<|OL
                         x1
                         x2) vars =
      <| bi
        (evalOpenTerm _ n bi x1 vars)
        (evalOpenTerm _ n bi x2 vars)
    simplify :
      BinaryInverseLang ->
      BinaryInverseLang
    simplify (<|L (|>L x y) x) = y
    simplify (|>L x (<|L y x)) = y
    simplify (|>L x1 x2) =
      |>L (simplify x1) (simplify x2)
    simplify (<|L x1 x2) =
      <|L (simplify x1) (simplify x2)
    liftBinaryInverseLang :
      BinaryInverseLang ->
      Staged BinaryInverseLang
    liftBinaryInverseLang x = Now x
    |>OL' :
      (n : Nat) ->
      BinaryInverseOpenLang n ->
      BinaryInverseOpenLang n ->
      BinaryInverseOpenLang n
    |>OL' _ x1 x2 = |>OL x1 x2
    <|OL' :
      (n : Nat) ->
      BinaryInverseOpenLang n ->
      BinaryInverseOpenLang n ->
      BinaryInverseOpenLang n
    <|OL' _ x1 x2 = <|OL x1 x2
    liftBinaryInverseOpenLang :
      (n : Nat) ->
      BinaryInverseOpenLang n ->
      Staged (BinaryInverseOpenLang n)
    liftBinaryInverseOpenLang _ (v
                                 fin) = const _ (code _ (v fin))
    liftBinaryInverseOpenLang _ (|>OL
                                 x1
                                 x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (liftBinaryInverseOpenLang _ x1)
        (liftBinaryInverseOpenLang _ x2)
    liftBinaryInverseOpenLang _ (<|OL
                                 x1
                                 x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (liftBinaryInverseOpenLang _ x1)
        (liftBinaryInverseOpenLang _ x2)
  
  module BooleanGroup where
    record BooleanGroup
      (A : Set) : Set where
      constructor BooleanGroupC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        unipotence :
          (x : A) -> op x x == e
    record BooleanGroupSig
      (AS : Set) : Set where
      constructor BooleanGroupSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record BooleanGroupProd
      (AP : Set) : Set where
      constructor BooleanGroupProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        unipotenceP :
          (xP : Prod AP AP) ->
          opP xP xP == eP
    record BooleanGroupHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BooleanGroup A1)
      (Bo2 : BooleanGroup A2) :
      Set where
      constructor BooleanGroupHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Bo1) == e Bo2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Bo1 x1 x2) ==
            op Bo2 (hom x1) (hom x2)
    record BooleanGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BooleanGroup A1)
      (Bo2 : BooleanGroup A2) :
      Set where
      constructor BooleanGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Bo1) (e Bo2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Bo1 x1 x2)
            (op Bo2 y1 y2)
    data BooleanGroupLang
      : Set where
      eL : BooleanGroupLang
      opL :
        BooleanGroupLang ->
        BooleanGroupLang ->
        BooleanGroupLang
    data BooleanGroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> BooleanGroupOpenLang n
      eOL : BooleanGroupOpenLang n
      opOL :
        BooleanGroupOpenLang n ->
        BooleanGroupOpenLang n ->
        BooleanGroupOpenLang n
    evalTerm :
      (A : Set) ->
      BooleanGroup A ->
      BooleanGroupLang -> A
    evalTerm _ Bo (eL) = e Bo
    evalTerm _ Bo (opL x1 x2) =
      op Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      BooleanGroup A ->
      BooleanGroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n bo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n bo (eOL) vars =
      e bo
    evalOpenTerm _ n bo (opOL
                         x1
                         x2) vars =
      op bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    simplify :
      BooleanGroupLang ->
      BooleanGroupLang
    simplify (opL (eL) x) = x
    simplify (opL x (eL)) = x
    simplify (opL x x) = eL
    simplify (eL) = eL
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftBooleanGroupLang :
      BooleanGroupLang ->
      Staged BooleanGroupLang
    liftBooleanGroupLang x = Now x
    eOL' :
      (n : Nat) ->
      BooleanGroupOpenLang n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      BooleanGroupOpenLang n ->
      BooleanGroupOpenLang n ->
      BooleanGroupOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftBooleanGroupOpenLang :
      (n : Nat) ->
      BooleanGroupOpenLang n ->
      Staged (BooleanGroupOpenLang n)
    liftBooleanGroupOpenLang _ (v
                                fin) = const _ (code _ (v fin))
    liftBooleanGroupOpenLang _ (eOL) =
      Now eOL
    liftBooleanGroupOpenLang _ (opOL
                                x1
                                x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftBooleanGroupOpenLang _ x1)
        (liftBooleanGroupOpenLang _ x2)
  
  module BooleanRing where
    record BooleanRing
      (A : Set) : Set where
      constructor BooleanRingC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
        idempotent_* :
          (x : A) -> * x x == x
    record BooleanRingSig
      (AS : Set) : Set where
      constructor BooleanRingSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
    record BooleanRingProd
      (AP : Set) : Set where
      constructor BooleanRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
    record BooleanRingHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BooleanRing A1)
      (Bo2 : BooleanRing A2) :
      Set where
      constructor BooleanRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
        pres-1 : hom (1 Bo1) == 1 Bo2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
        pres-0 : hom (0 Bo1) == 0 Bo2
        pres-neg :
          (x1 : A1) ->
          hom (neg Bo1 x1) ==
            neg Bo2 (hom x1)
    record BooleanRingRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BooleanRing A1)
      (Bo2 : BooleanRing A2) :
      Set where
      constructor BooleanRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
        interp-1 :
          interp (1 Bo1) (1 Bo2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
        interp-0 :
          interp (0 Bo1) (0 Bo2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Bo1 x1) (neg Bo2 y1)
    data BooleanRingLang : Set where
      *L :
        BooleanRingLang ->
        BooleanRingLang ->
        BooleanRingLang
      1L : BooleanRingLang
      +L :
        BooleanRingLang ->
        BooleanRingLang ->
        BooleanRingLang
      0L : BooleanRingLang
      negL :
        BooleanRingLang ->
        BooleanRingLang
    data BooleanRingOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> BooleanRingOpenLang n
      *OL :
        BooleanRingOpenLang n ->
        BooleanRingOpenLang n ->
        BooleanRingOpenLang n
      1OL : BooleanRingOpenLang n
      +OL :
        BooleanRingOpenLang n ->
        BooleanRingOpenLang n ->
        BooleanRingOpenLang n
      0OL : BooleanRingOpenLang n
      negOL :
        BooleanRingOpenLang n ->
        BooleanRingOpenLang n
    evalTerm :
      (A : Set) ->
      BooleanRing A ->
      BooleanRingLang -> A
    evalTerm _ Bo (*L x1 x2) =
      * Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalTerm _ Bo (1L) = 1 Bo
    evalTerm _ Bo (+L x1 x2) =
      + Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalTerm _ Bo (0L) = 0 Bo
    evalTerm _ Bo (negL x1) =
      neg Bo (evalTerm _ Bo x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      BooleanRing A ->
      BooleanRingOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n bo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n bo (*OL
                         x1
                         x2) vars =
      * bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    evalOpenTerm _ n bo (1OL) vars =
      1 bo
    evalOpenTerm _ n bo (+OL
                         x1
                         x2) vars =
      + bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    evalOpenTerm _ n bo (0OL) vars =
      0 bo
    evalOpenTerm _ n bo (negOL
                         x1) vars =
      neg bo
        (evalOpenTerm _ n bo x1 vars)
    simplify :
      BooleanRingLang ->
      BooleanRingLang
    simplify (*L (1L) x) = x
    simplify (*L x (1L)) = x
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (+L
              (*L x y)
              (*L x z)) = *L x (+L y z)
    simplify (+L
              (*L y x)
              (*L z x)) = *L (+L y z) x
    simplify (+L x (negL x)) = 0L
    simplify (+L (negL x) x) = 0L
    simplify (*L (0L) x) = 0L
    simplify (*L x (0L)) = 0L
    simplify (*L x x) = x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (1L) = 1L
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (0L) = 0L
    simplify (negL x1) =
      negL (simplify x1)
    liftBooleanRingLang :
      BooleanRingLang ->
      Staged BooleanRingLang
    liftBooleanRingLang x = Now x
    *OL' :
      (n : Nat) ->
      BooleanRingOpenLang n ->
      BooleanRingOpenLang n ->
      BooleanRingOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    1OL' :
      (n : Nat) ->
      BooleanRingOpenLang n
    1OL' _ = 1OL
    +OL' :
      (n : Nat) ->
      BooleanRingOpenLang n ->
      BooleanRingOpenLang n ->
      BooleanRingOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      BooleanRingOpenLang n
    0OL' _ = 0OL
    negOL' :
      (n : Nat) ->
      BooleanRingOpenLang n ->
      BooleanRingOpenLang n
    negOL' _ x1 = negOL x1
    liftBooleanRingOpenLang :
      (n : Nat) ->
      BooleanRingOpenLang n ->
      Staged (BooleanRingOpenLang n)
    liftBooleanRingOpenLang _ (v
                               fin) = const _ (code _ (v fin))
    liftBooleanRingOpenLang _ (*OL
                               x1
                               x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftBooleanRingOpenLang _ x1)
        (liftBooleanRingOpenLang _ x2)
    liftBooleanRingOpenLang _ (1OL) =
      Now 1OL
    liftBooleanRingOpenLang _ (+OL
                               x1
                               x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftBooleanRingOpenLang _ x1)
        (liftBooleanRingOpenLang _ x2)
    liftBooleanRingOpenLang _ (0OL) =
      Now 0OL
    liftBooleanRingOpenLang _ (negOL
                               x1) =
      stage1 _ _ (negOL' _)
        (codeLift1 _ _ (negOL' _))
        (liftBooleanRingOpenLang _ x1)
  
  module BoundedDistributiveLattice where
    record BoundedDistributiveLattice
      (A : Set) : Set where
      constructor BoundedDistributiveLatticeC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
        leftModular_*_+ :
          (x : A) (y : A) (z : A) ->
          + (* x y) (* x z) ==
            * x (+ y (* x z))
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
    record BoundedDistributiveLatticeSig
      (AS : Set) : Set where
      constructor BoundedDistributiveLatticeSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        1S : AS
    record BoundedDistributiveLatticeProd
      (AP : Set) : Set where
      constructor BoundedDistributiveLatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        1P : Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
        leftModular_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (*P xP yP) (*P xP zP) ==
            *P xP (+P yP (*P xP zP))
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
    record BoundedDistributiveLatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedDistributiveLattice
         A1)
      (Bo2 : BoundedDistributiveLattice
         A2) : Set where
      constructor BoundedDistributiveLatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
        pres-0 : hom (0 Bo1) == 0 Bo2
        pres-1 : hom (1 Bo1) == 1 Bo2
    record BoundedDistributiveLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedDistributiveLattice
         A1)
      (Bo2 : BoundedDistributiveLattice
         A2) : Set where
      constructor BoundedDistributiveLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
        interp-0 :
          interp (0 Bo1) (0 Bo2)
        interp-1 :
          interp (1 Bo1) (1 Bo2)
    data BoundedDistributiveLatticeLang
      : Set where
      *L :
        BoundedDistributiveLatticeLang ->
        BoundedDistributiveLatticeLang ->
        BoundedDistributiveLatticeLang
      +L :
        BoundedDistributiveLatticeLang ->
        BoundedDistributiveLatticeLang ->
        BoundedDistributiveLatticeLang
      0L :
        BoundedDistributiveLatticeLang
      1L :
        BoundedDistributiveLatticeLang
    data BoundedDistributiveLatticeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        BoundedDistributiveLatticeOpenLang
          n
      *OL :
        BoundedDistributiveLatticeOpenLang
          n ->
        BoundedDistributiveLatticeOpenLang
          n ->
        BoundedDistributiveLatticeOpenLang
          n
      +OL :
        BoundedDistributiveLatticeOpenLang
          n ->
        BoundedDistributiveLatticeOpenLang
          n ->
        BoundedDistributiveLatticeOpenLang
          n
      0OL :
        BoundedDistributiveLatticeOpenLang
          n
      1OL :
        BoundedDistributiveLatticeOpenLang
          n
    evalTerm :
      (A : Set) ->
      BoundedDistributiveLattice A ->
      BoundedDistributiveLatticeLang ->
      A
    evalTerm _ Bo (*L x1 x2) =
      * Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalTerm _ Bo (+L x1 x2) =
      + Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalTerm _ Bo (0L) = 0 Bo
    evalTerm _ Bo (1L) = 1 Bo
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      BoundedDistributiveLattice A ->
      BoundedDistributiveLatticeOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n bo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n bo (*OL
                         x1
                         x2) vars =
      * bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    evalOpenTerm _ n bo (+OL
                         x1
                         x2) vars =
      + bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    evalOpenTerm _ n bo (0OL) vars =
      0 bo
    evalOpenTerm _ n bo (1OL) vars =
      1 bo
    simplify :
      BoundedDistributiveLatticeLang ->
      BoundedDistributiveLatticeLang
    simplify (*L x x) = x
    simplify (+L x x) = x
    simplify (*L x (+L x y)) = x
    simplify (+L x (*L x y)) = x
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (*L (1L) x) = x
    simplify (*L x (1L)) = x
    simplify (+L
              (*L x y)
              (*L x z)) = *L x (+L y z)
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (0L) = 0L
    simplify (1L) = 1L
    liftBoundedDistributiveLatticeLang :
      BoundedDistributiveLatticeLang ->
      Staged
        BoundedDistributiveLatticeLang
    liftBoundedDistributiveLatticeLang x =
      Now x
    *OL' :
      (n : Nat) ->
      BoundedDistributiveLatticeOpenLang
        n ->
      BoundedDistributiveLatticeOpenLang
        n ->
      BoundedDistributiveLatticeOpenLang
        n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      BoundedDistributiveLatticeOpenLang
        n ->
      BoundedDistributiveLatticeOpenLang
        n ->
      BoundedDistributiveLatticeOpenLang
        n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      BoundedDistributiveLatticeOpenLang
        n
    0OL' _ = 0OL
    1OL' :
      (n : Nat) ->
      BoundedDistributiveLatticeOpenLang
        n
    1OL' _ = 1OL
    liftBoundedDistributiveLatticeOpenLang :
      (n : Nat) ->
      BoundedDistributiveLatticeOpenLang
        n ->
      Staged
        (BoundedDistributiveLatticeOpenLang
           n)
    liftBoundedDistributiveLatticeOpenLang _ (v
                                              fin) = const _ (code _ (v fin))
    liftBoundedDistributiveLatticeOpenLang _ (*OL
                                              x1
                                              x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftBoundedDistributiveLatticeOpenLang
           _
           x1)
        (liftBoundedDistributiveLatticeOpenLang
           _
           x2)
    liftBoundedDistributiveLatticeOpenLang _ (+OL
                                              x1
                                              x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftBoundedDistributiveLatticeOpenLang
           _
           x1)
        (liftBoundedDistributiveLatticeOpenLang
           _
           x2)
    liftBoundedDistributiveLatticeOpenLang _ (0OL) =
      Now 0OL
    liftBoundedDistributiveLatticeOpenLang _ (1OL) =
      Now 1OL
  
  module BoundedJoinLattice where
    record BoundedJoinLattice
      (A : Set) : Set where
      constructor BoundedJoinLatticeC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        * : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
    record BoundedJoinLatticeSig
      (AS : Set) : Set where
      constructor BoundedJoinLatticeSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
        *S : AS -> AS -> AS
    record BoundedJoinLatticeProd
      (AP : Set) : Set where
      constructor BoundedJoinLatticeProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
    record BoundedJoinLatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedJoinLattice A1)
      (Bo2 : BoundedJoinLattice A2) :
      Set where
      constructor BoundedJoinLatticeHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
        pres-0 : hom (0 Bo1) == 0 Bo2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
    record BoundedJoinLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedJoinLattice A1)
      (Bo2 : BoundedJoinLattice A2) :
      Set where
      constructor BoundedJoinLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
        interp-0 :
          interp (0 Bo1) (0 Bo2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
    data BoundedJoinLatticeLang
      : Set where
      +L :
        BoundedJoinLatticeLang ->
        BoundedJoinLatticeLang ->
        BoundedJoinLatticeLang
      0L : BoundedJoinLatticeLang
      *L :
        BoundedJoinLatticeLang ->
        BoundedJoinLatticeLang ->
        BoundedJoinLatticeLang
    data BoundedJoinLatticeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        BoundedJoinLatticeOpenLang n
      +OL :
        BoundedJoinLatticeOpenLang n ->
        BoundedJoinLatticeOpenLang n ->
        BoundedJoinLatticeOpenLang n
      0OL :
        BoundedJoinLatticeOpenLang n
      *OL :
        BoundedJoinLatticeOpenLang n ->
        BoundedJoinLatticeOpenLang n ->
        BoundedJoinLatticeOpenLang n
    evalTerm :
      (A : Set) ->
      BoundedJoinLattice A ->
      BoundedJoinLatticeLang -> A
    evalTerm _ Bo (+L x1 x2) =
      + Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalTerm _ Bo (0L) = 0 Bo
    evalTerm _ Bo (*L x1 x2) =
      * Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      BoundedJoinLattice A ->
      BoundedJoinLatticeOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n bo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n bo (+OL
                         x1
                         x2) vars =
      + bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    evalOpenTerm _ n bo (0OL) vars =
      0 bo
    evalOpenTerm _ n bo (*OL
                         x1
                         x2) vars =
      * bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    simplify :
      BoundedJoinLatticeLang ->
      BoundedJoinLatticeLang
    simplify (+L x x) = x
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (*L x x) = x
    simplify (*L x (+L x y)) = x
    simplify (+L x (*L x y)) = x
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (0L) = 0L
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    liftBoundedJoinLatticeLang :
      BoundedJoinLatticeLang ->
      Staged BoundedJoinLatticeLang
    liftBoundedJoinLatticeLang x =
      Now x
    +OL' :
      (n : Nat) ->
      BoundedJoinLatticeOpenLang n ->
      BoundedJoinLatticeOpenLang n ->
      BoundedJoinLatticeOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      BoundedJoinLatticeOpenLang n
    0OL' _ = 0OL
    *OL' :
      (n : Nat) ->
      BoundedJoinLatticeOpenLang n ->
      BoundedJoinLatticeOpenLang n ->
      BoundedJoinLatticeOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    liftBoundedJoinLatticeOpenLang :
      (n : Nat) ->
      BoundedJoinLatticeOpenLang n ->
      Staged
        (BoundedJoinLatticeOpenLang n)
    liftBoundedJoinLatticeOpenLang _ (v
                                      fin) = const _ (code _ (v fin))
    liftBoundedJoinLatticeOpenLang _ (+OL
                                      x1
                                      x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftBoundedJoinLatticeOpenLang
           _
           x1)
        (liftBoundedJoinLatticeOpenLang
           _
           x2)
    liftBoundedJoinLatticeOpenLang _ (0OL) =
      Now 0OL
    liftBoundedJoinLatticeOpenLang _ (*OL
                                      x1
                                      x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftBoundedJoinLatticeOpenLang
           _
           x1)
        (liftBoundedJoinLatticeOpenLang
           _
           x2)
  
  module BoundedJoinSemilattice where
    record BoundedJoinSemilattice
      (A : Set) : Set where
      constructor BoundedJoinSemilatticeC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        idempotent_+ :
          (x : A) -> + x x == x
    record BoundedJoinSemilatticeSig
      (AS : Set) : Set where
      constructor BoundedJoinSemilatticeSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
    record BoundedJoinSemilatticeProd
      (AP : Set) : Set where
      constructor BoundedJoinSemilatticeProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record BoundedJoinSemilatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedJoinSemilattice
         A1)
      (Bo2 : BoundedJoinSemilattice
         A2) : Set where
      constructor BoundedJoinSemilatticeHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
        pres-0 : hom (0 Bo1) == 0 Bo2
    record BoundedJoinSemilatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedJoinSemilattice
         A1)
      (Bo2 : BoundedJoinSemilattice
         A2) : Set where
      constructor BoundedJoinSemilatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
        interp-0 :
          interp (0 Bo1) (0 Bo2)
    data BoundedJoinSemilatticeLang
      : Set where
      +L :
        BoundedJoinSemilatticeLang ->
        BoundedJoinSemilatticeLang ->
        BoundedJoinSemilatticeLang
      0L : BoundedJoinSemilatticeLang
    data BoundedJoinSemilatticeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        BoundedJoinSemilatticeOpenLang n
      +OL :
        BoundedJoinSemilatticeOpenLang
          n ->
        BoundedJoinSemilatticeOpenLang
          n ->
        BoundedJoinSemilatticeOpenLang n
      0OL :
        BoundedJoinSemilatticeOpenLang n
    evalTerm :
      (A : Set) ->
      BoundedJoinSemilattice A ->
      BoundedJoinSemilatticeLang -> A
    evalTerm _ Bo (+L x1 x2) =
      + Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalTerm _ Bo (0L) = 0 Bo
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      BoundedJoinSemilattice A ->
      BoundedJoinSemilatticeOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n bo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n bo (+OL
                         x1
                         x2) vars =
      + bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    evalOpenTerm _ n bo (0OL) vars =
      0 bo
    simplify :
      BoundedJoinSemilatticeLang ->
      BoundedJoinSemilatticeLang
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (+L x x) = x
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (0L) = 0L
    liftBoundedJoinSemilatticeLang :
      BoundedJoinSemilatticeLang ->
      Staged
        BoundedJoinSemilatticeLang
    liftBoundedJoinSemilatticeLang x =
      Now x
    +OL' :
      (n : Nat) ->
      BoundedJoinSemilatticeOpenLang
        n ->
      BoundedJoinSemilatticeOpenLang
        n ->
      BoundedJoinSemilatticeOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      BoundedJoinSemilatticeOpenLang n
    0OL' _ = 0OL
    liftBoundedJoinSemilatticeOpenLang :
      (n : Nat) ->
      BoundedJoinSemilatticeOpenLang
        n ->
      Staged
        (BoundedJoinSemilatticeOpenLang
           n)
    liftBoundedJoinSemilatticeOpenLang _ (v
                                          fin) = const _ (code _ (v fin))
    liftBoundedJoinSemilatticeOpenLang _ (+OL
                                          x1
                                          x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftBoundedJoinSemilatticeOpenLang
           _
           x1)
        (liftBoundedJoinSemilatticeOpenLang
           _
           x2)
    liftBoundedJoinSemilatticeOpenLang _ (0OL) =
      Now 0OL
  
  module BoundedLattice where
    record BoundedLattice
      (A : Set) : Set where
      constructor BoundedLatticeC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
    record BoundedLatticeSig
      (AS : Set) : Set where
      constructor BoundedLatticeSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        1S : AS
    record BoundedLatticeProd
      (AP : Set) : Set where
      constructor BoundedLatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        1P : Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
    record BoundedLatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedLattice A1)
      (Bo2 : BoundedLattice A2) :
      Set where
      constructor BoundedLatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
        pres-0 : hom (0 Bo1) == 0 Bo2
        pres-1 : hom (1 Bo1) == 1 Bo2
    record BoundedLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedLattice A1)
      (Bo2 : BoundedLattice A2) :
      Set where
      constructor BoundedLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
        interp-0 :
          interp (0 Bo1) (0 Bo2)
        interp-1 :
          interp (1 Bo1) (1 Bo2)
    data BoundedLatticeLang
      : Set where
      *L :
        BoundedLatticeLang ->
        BoundedLatticeLang ->
        BoundedLatticeLang
      +L :
        BoundedLatticeLang ->
        BoundedLatticeLang ->
        BoundedLatticeLang
      0L : BoundedLatticeLang
      1L : BoundedLatticeLang
    data BoundedLatticeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        BoundedLatticeOpenLang n
      *OL :
        BoundedLatticeOpenLang n ->
        BoundedLatticeOpenLang n ->
        BoundedLatticeOpenLang n
      +OL :
        BoundedLatticeOpenLang n ->
        BoundedLatticeOpenLang n ->
        BoundedLatticeOpenLang n
      0OL : BoundedLatticeOpenLang n
      1OL : BoundedLatticeOpenLang n
    evalTerm :
      (A : Set) ->
      BoundedLattice A ->
      BoundedLatticeLang -> A
    evalTerm _ Bo (*L x1 x2) =
      * Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalTerm _ Bo (+L x1 x2) =
      + Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalTerm _ Bo (0L) = 0 Bo
    evalTerm _ Bo (1L) = 1 Bo
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      BoundedLattice A ->
      BoundedLatticeOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n bo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n bo (*OL
                         x1
                         x2) vars =
      * bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    evalOpenTerm _ n bo (+OL
                         x1
                         x2) vars =
      + bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    evalOpenTerm _ n bo (0OL) vars =
      0 bo
    evalOpenTerm _ n bo (1OL) vars =
      1 bo
    simplify :
      BoundedLatticeLang ->
      BoundedLatticeLang
    simplify (*L x x) = x
    simplify (+L x x) = x
    simplify (*L x (+L x y)) = x
    simplify (+L x (*L x y)) = x
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (*L (1L) x) = x
    simplify (*L x (1L)) = x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (0L) = 0L
    simplify (1L) = 1L
    liftBoundedLatticeLang :
      BoundedLatticeLang ->
      Staged BoundedLatticeLang
    liftBoundedLatticeLang x = Now x
    *OL' :
      (n : Nat) ->
      BoundedLatticeOpenLang n ->
      BoundedLatticeOpenLang n ->
      BoundedLatticeOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      BoundedLatticeOpenLang n ->
      BoundedLatticeOpenLang n ->
      BoundedLatticeOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      BoundedLatticeOpenLang n
    0OL' _ = 0OL
    1OL' :
      (n : Nat) ->
      BoundedLatticeOpenLang n
    1OL' _ = 1OL
    liftBoundedLatticeOpenLang :
      (n : Nat) ->
      BoundedLatticeOpenLang n ->
      Staged
        (BoundedLatticeOpenLang n)
    liftBoundedLatticeOpenLang _ (v
                                  fin) = const _ (code _ (v fin))
    liftBoundedLatticeOpenLang _ (*OL
                                  x1
                                  x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftBoundedLatticeOpenLang _
           x1)
        (liftBoundedLatticeOpenLang _
           x2)
    liftBoundedLatticeOpenLang _ (+OL
                                  x1
                                  x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftBoundedLatticeOpenLang _
           x1)
        (liftBoundedLatticeOpenLang _
           x2)
    liftBoundedLatticeOpenLang _ (0OL) =
      Now 0OL
    liftBoundedLatticeOpenLang _ (1OL) =
      Now 1OL
  
  module BoundedMeetLattice where
    record BoundedMeetLattice
      (A : Set) : Set where
      constructor BoundedMeetLatticeC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
    record BoundedMeetLatticeSig
      (AS : Set) : Set where
      constructor BoundedMeetLatticeSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
        +S : AS -> AS -> AS
    record BoundedMeetLatticeProd
      (AP : Set) : Set where
      constructor BoundedMeetLatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
    record BoundedMeetLatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedMeetLattice A1)
      (Bo2 : BoundedMeetLattice A2) :
      Set where
      constructor BoundedMeetLatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
        pres-1 : hom (1 Bo1) == 1 Bo2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
    record BoundedMeetLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedMeetLattice A1)
      (Bo2 : BoundedMeetLattice A2) :
      Set where
      constructor BoundedMeetLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
        interp-1 :
          interp (1 Bo1) (1 Bo2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
    data BoundedMeetLatticeLang
      : Set where
      *L :
        BoundedMeetLatticeLang ->
        BoundedMeetLatticeLang ->
        BoundedMeetLatticeLang
      1L : BoundedMeetLatticeLang
      +L :
        BoundedMeetLatticeLang ->
        BoundedMeetLatticeLang ->
        BoundedMeetLatticeLang
    data BoundedMeetLatticeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        BoundedMeetLatticeOpenLang n
      *OL :
        BoundedMeetLatticeOpenLang n ->
        BoundedMeetLatticeOpenLang n ->
        BoundedMeetLatticeOpenLang n
      1OL :
        BoundedMeetLatticeOpenLang n
      +OL :
        BoundedMeetLatticeOpenLang n ->
        BoundedMeetLatticeOpenLang n ->
        BoundedMeetLatticeOpenLang n
    evalTerm :
      (A : Set) ->
      BoundedMeetLattice A ->
      BoundedMeetLatticeLang -> A
    evalTerm _ Bo (*L x1 x2) =
      * Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalTerm _ Bo (1L) = 1 Bo
    evalTerm _ Bo (+L x1 x2) =
      + Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      BoundedMeetLattice A ->
      BoundedMeetLatticeOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n bo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n bo (*OL
                         x1
                         x2) vars =
      * bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    evalOpenTerm _ n bo (1OL) vars =
      1 bo
    evalOpenTerm _ n bo (+OL
                         x1
                         x2) vars =
      + bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    simplify :
      BoundedMeetLatticeLang ->
      BoundedMeetLatticeLang
    simplify (*L x x) = x
    simplify (*L (1L) x) = x
    simplify (*L x (1L)) = x
    simplify (+L x x) = x
    simplify (*L x (+L x y)) = x
    simplify (+L x (*L x y)) = x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (1L) = 1L
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftBoundedMeetLatticeLang :
      BoundedMeetLatticeLang ->
      Staged BoundedMeetLatticeLang
    liftBoundedMeetLatticeLang x =
      Now x
    *OL' :
      (n : Nat) ->
      BoundedMeetLatticeOpenLang n ->
      BoundedMeetLatticeOpenLang n ->
      BoundedMeetLatticeOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    1OL' :
      (n : Nat) ->
      BoundedMeetLatticeOpenLang n
    1OL' _ = 1OL
    +OL' :
      (n : Nat) ->
      BoundedMeetLatticeOpenLang n ->
      BoundedMeetLatticeOpenLang n ->
      BoundedMeetLatticeOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftBoundedMeetLatticeOpenLang :
      (n : Nat) ->
      BoundedMeetLatticeOpenLang n ->
      Staged
        (BoundedMeetLatticeOpenLang n)
    liftBoundedMeetLatticeOpenLang _ (v
                                      fin) = const _ (code _ (v fin))
    liftBoundedMeetLatticeOpenLang _ (*OL
                                      x1
                                      x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftBoundedMeetLatticeOpenLang
           _
           x1)
        (liftBoundedMeetLatticeOpenLang
           _
           x2)
    liftBoundedMeetLatticeOpenLang _ (1OL) =
      Now 1OL
    liftBoundedMeetLatticeOpenLang _ (+OL
                                      x1
                                      x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftBoundedMeetLatticeOpenLang
           _
           x1)
        (liftBoundedMeetLatticeOpenLang
           _
           x2)
  
  module BoundedMeetSemilattice where
    record BoundedMeetSemilattice
      (A : Set) : Set where
      constructor BoundedMeetSemilatticeC
      field
        * : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        idempotent_* :
          (x : A) -> * x x == x
    record BoundedMeetSemilatticeSig
      (AS : Set) : Set where
      constructor BoundedMeetSemilatticeSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
    record BoundedMeetSemilatticeProd
      (AP : Set) : Set where
      constructor BoundedMeetSemilatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
    record BoundedMeetSemilatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedMeetSemilattice
         A1)
      (Bo2 : BoundedMeetSemilattice
         A2) : Set where
      constructor BoundedMeetSemilatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
        pres-1 : hom (1 Bo1) == 1 Bo2
    record BoundedMeetSemilatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedMeetSemilattice
         A1)
      (Bo2 : BoundedMeetSemilattice
         A2) : Set where
      constructor BoundedMeetSemilatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
        interp-1 :
          interp (1 Bo1) (1 Bo2)
    data BoundedMeetSemilatticeLang
      : Set where
      *L :
        BoundedMeetSemilatticeLang ->
        BoundedMeetSemilatticeLang ->
        BoundedMeetSemilatticeLang
      1L : BoundedMeetSemilatticeLang
    data BoundedMeetSemilatticeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        BoundedMeetSemilatticeOpenLang n
      *OL :
        BoundedMeetSemilatticeOpenLang
          n ->
        BoundedMeetSemilatticeOpenLang
          n ->
        BoundedMeetSemilatticeOpenLang n
      1OL :
        BoundedMeetSemilatticeOpenLang n
    evalTerm :
      (A : Set) ->
      BoundedMeetSemilattice A ->
      BoundedMeetSemilatticeLang -> A
    evalTerm _ Bo (*L x1 x2) =
      * Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalTerm _ Bo (1L) = 1 Bo
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      BoundedMeetSemilattice A ->
      BoundedMeetSemilatticeOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n bo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n bo (*OL
                         x1
                         x2) vars =
      * bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    evalOpenTerm _ n bo (1OL) vars =
      1 bo
    simplify :
      BoundedMeetSemilatticeLang ->
      BoundedMeetSemilatticeLang
    simplify (*L (1L) x) = x
    simplify (*L x (1L)) = x
    simplify (*L x x) = x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (1L) = 1L
    liftBoundedMeetSemilatticeLang :
      BoundedMeetSemilatticeLang ->
      Staged
        BoundedMeetSemilatticeLang
    liftBoundedMeetSemilatticeLang x =
      Now x
    *OL' :
      (n : Nat) ->
      BoundedMeetSemilatticeOpenLang
        n ->
      BoundedMeetSemilatticeOpenLang
        n ->
      BoundedMeetSemilatticeOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    1OL' :
      (n : Nat) ->
      BoundedMeetSemilatticeOpenLang n
    1OL' _ = 1OL
    liftBoundedMeetSemilatticeOpenLang :
      (n : Nat) ->
      BoundedMeetSemilatticeOpenLang
        n ->
      Staged
        (BoundedMeetSemilatticeOpenLang
           n)
    liftBoundedMeetSemilatticeOpenLang _ (v
                                          fin) = const _ (code _ (v fin))
    liftBoundedMeetSemilatticeOpenLang _ (*OL
                                          x1
                                          x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftBoundedMeetSemilatticeOpenLang
           _
           x1)
        (liftBoundedMeetSemilatticeOpenLang
           _
           x2)
    liftBoundedMeetSemilatticeOpenLang _ (1OL) =
      Now 1OL
  
  module BoundedModularLattice where
    record BoundedModularLattice
      (A : Set) : Set where
      constructor BoundedModularLatticeC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        leftModular_*_+ :
          (x : A) (y : A) (z : A) ->
          + (* x y) (* x z) ==
            * x (+ y (* x z))
    record BoundedModularLatticeSig
      (AS : Set) : Set where
      constructor BoundedModularLatticeSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        1S : AS
    record BoundedModularLatticeProd
      (AP : Set) : Set where
      constructor BoundedModularLatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        1P : Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        leftModular_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (*P xP yP) (*P xP zP) ==
            *P xP (+P yP (*P xP zP))
    record BoundedModularLatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedModularLattice A1)
      (Bo2 : BoundedModularLattice
         A2) : Set where
      constructor BoundedModularLatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
        pres-0 : hom (0 Bo1) == 0 Bo2
        pres-1 : hom (1 Bo1) == 1 Bo2
    record BoundedModularLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedModularLattice A1)
      (Bo2 : BoundedModularLattice
         A2) : Set where
      constructor BoundedModularLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
        interp-0 :
          interp (0 Bo1) (0 Bo2)
        interp-1 :
          interp (1 Bo1) (1 Bo2)
    data BoundedModularLatticeLang
      : Set where
      *L :
        BoundedModularLatticeLang ->
        BoundedModularLatticeLang ->
        BoundedModularLatticeLang
      +L :
        BoundedModularLatticeLang ->
        BoundedModularLatticeLang ->
        BoundedModularLatticeLang
      0L : BoundedModularLatticeLang
      1L : BoundedModularLatticeLang
    data BoundedModularLatticeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        BoundedModularLatticeOpenLang n
      *OL :
        BoundedModularLatticeOpenLang
          n ->
        BoundedModularLatticeOpenLang
          n ->
        BoundedModularLatticeOpenLang n
      +OL :
        BoundedModularLatticeOpenLang
          n ->
        BoundedModularLatticeOpenLang
          n ->
        BoundedModularLatticeOpenLang n
      0OL :
        BoundedModularLatticeOpenLang n
      1OL :
        BoundedModularLatticeOpenLang n
    evalTerm :
      (A : Set) ->
      BoundedModularLattice A ->
      BoundedModularLatticeLang -> A
    evalTerm _ Bo (*L x1 x2) =
      * Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalTerm _ Bo (+L x1 x2) =
      + Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalTerm _ Bo (0L) = 0 Bo
    evalTerm _ Bo (1L) = 1 Bo
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      BoundedModularLattice A ->
      BoundedModularLatticeOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n bo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n bo (*OL
                         x1
                         x2) vars =
      * bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    evalOpenTerm _ n bo (+OL
                         x1
                         x2) vars =
      + bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    evalOpenTerm _ n bo (0OL) vars =
      0 bo
    evalOpenTerm _ n bo (1OL) vars =
      1 bo
    simplify :
      BoundedModularLatticeLang ->
      BoundedModularLatticeLang
    simplify (*L x x) = x
    simplify (+L x x) = x
    simplify (*L x (+L x y)) = x
    simplify (+L x (*L x y)) = x
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (*L (1L) x) = x
    simplify (*L x (1L)) = x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (0L) = 0L
    simplify (1L) = 1L
    liftBoundedModularLatticeLang :
      BoundedModularLatticeLang ->
      Staged BoundedModularLatticeLang
    liftBoundedModularLatticeLang x =
      Now x
    *OL' :
      (n : Nat) ->
      BoundedModularLatticeOpenLang
        n ->
      BoundedModularLatticeOpenLang
        n ->
      BoundedModularLatticeOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      BoundedModularLatticeOpenLang
        n ->
      BoundedModularLatticeOpenLang
        n ->
      BoundedModularLatticeOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      BoundedModularLatticeOpenLang n
    0OL' _ = 0OL
    1OL' :
      (n : Nat) ->
      BoundedModularLatticeOpenLang n
    1OL' _ = 1OL
    liftBoundedModularLatticeOpenLang :
      (n : Nat) ->
      BoundedModularLatticeOpenLang
        n ->
      Staged
        (BoundedModularLatticeOpenLang
           n)
    liftBoundedModularLatticeOpenLang _ (v
                                         fin) = const _ (code _ (v fin))
    liftBoundedModularLatticeOpenLang _ (*OL
                                         x1
                                         x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftBoundedModularLatticeOpenLang
           _
           x1)
        (liftBoundedModularLatticeOpenLang
           _
           x2)
    liftBoundedModularLatticeOpenLang _ (+OL
                                         x1
                                         x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftBoundedModularLatticeOpenLang
           _
           x1)
        (liftBoundedModularLatticeOpenLang
           _
           x2)
    liftBoundedModularLatticeOpenLang _ (0OL) =
      Now 0OL
    liftBoundedModularLatticeOpenLang _ (1OL) =
      Now 1OL
  
  module CancellativeCommutativeMonoid where
    record CancellativeCommutativeMonoid
      (A : Set) : Set where
      constructor CancellativeCommutativeMonoidC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CancellativeCommutativeMonoidSig
      (AS : Set) : Set where
      constructor CancellativeCommutativeMonoidSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record CancellativeCommutativeMonoidProd
      (AP : Set) : Set where
      constructor CancellativeCommutativeMonoidProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CancellativeCommutativeMonoidHom
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeCommutativeMonoid
         A1)
      (Ca2 : CancellativeCommutativeMonoid
         A2) : Set where
      constructor CancellativeCommutativeMonoidHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Ca1) == e Ca2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ca1 x1 x2) ==
            op Ca2 (hom x1) (hom x2)
    record CancellativeCommutativeMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeCommutativeMonoid
         A1)
      (Ca2 : CancellativeCommutativeMonoid
         A2) : Set where
      constructor CancellativeCommutativeMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Ca1) (e Ca2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ca1 x1 x2)
            (op Ca2 y1 y2)
    data CancellativeCommutativeMonoidLang
      : Set where
      eL :
        CancellativeCommutativeMonoidLang
      opL :
        CancellativeCommutativeMonoidLang ->
        CancellativeCommutativeMonoidLang ->
        CancellativeCommutativeMonoidLang
    data CancellativeCommutativeMonoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CancellativeCommutativeMonoidOpenLang
          n
      eOL :
        CancellativeCommutativeMonoidOpenLang
          n
      opOL :
        CancellativeCommutativeMonoidOpenLang
          n ->
        CancellativeCommutativeMonoidOpenLang
          n ->
        CancellativeCommutativeMonoidOpenLang
          n
    evalTerm :
      (A : Set) ->
      CancellativeCommutativeMonoid
        A ->
      CancellativeCommutativeMonoidLang ->
      A
    evalTerm _ Ca (eL) = e Ca
    evalTerm _ Ca (opL x1 x2) =
      op Ca (evalTerm _ Ca x1)
        (evalTerm _ Ca x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CancellativeCommutativeMonoid
        A ->
      CancellativeCommutativeMonoidOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ca (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ca (eOL) vars =
      e ca
    evalOpenTerm _ n ca (opOL
                         x1
                         x2) vars =
      op ca
        (evalOpenTerm _ n ca x1 vars)
        (evalOpenTerm _ n ca x2 vars)
    simplify :
      CancellativeCommutativeMonoidLang ->
      CancellativeCommutativeMonoidLang
    simplify (opL (eL) x) = x
    simplify (opL x (eL)) = x
    simplify (eL) = eL
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftCancellativeCommutativeMonoidLang :
      CancellativeCommutativeMonoidLang ->
      Staged
        CancellativeCommutativeMonoidLang
    liftCancellativeCommutativeMonoidLang x =
      Now x
    eOL' :
      (n : Nat) ->
      CancellativeCommutativeMonoidOpenLang
        n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      CancellativeCommutativeMonoidOpenLang
        n ->
      CancellativeCommutativeMonoidOpenLang
        n ->
      CancellativeCommutativeMonoidOpenLang
        n
    opOL' _ x1 x2 = opOL x1 x2
    liftCancellativeCommutativeMonoidOpenLang :
      (n : Nat) ->
      CancellativeCommutativeMonoidOpenLang
        n ->
      Staged
        (CancellativeCommutativeMonoidOpenLang
           n)
    liftCancellativeCommutativeMonoidOpenLang _ (v
                                                 fin) = const _ (code _ (v fin))
    liftCancellativeCommutativeMonoidOpenLang _ (eOL) =
      Now eOL
    liftCancellativeCommutativeMonoidOpenLang _ (opOL
                                                 x1
                                                 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftCancellativeCommutativeMonoidOpenLang
           _
           x1)
        (liftCancellativeCommutativeMonoidOpenLang
           _
           x2)
  
  module CancellativeCommutativeSemigroup where
    record CancellativeCommutativeSemigroup
      (A : Set) : Set where
      constructor CancellativeCommutativeSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
    record CancellativeCommutativeSemigroupSig
      (AS : Set) : Set where
      constructor CancellativeCommutativeSemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record CancellativeCommutativeSemigroupProd
      (AP : Set) : Set where
      constructor CancellativeCommutativeSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
    record CancellativeCommutativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeCommutativeSemigroup
         A1)
      (Ca2 : CancellativeCommutativeSemigroup
         A2) : Set where
      constructor CancellativeCommutativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ca1 x1 x2) ==
            op Ca2 (hom x1) (hom x2)
    record CancellativeCommutativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeCommutativeSemigroup
         A1)
      (Ca2 : CancellativeCommutativeSemigroup
         A2) : Set where
      constructor CancellativeCommutativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ca1 x1 x2)
            (op Ca2 y1 y2)
    data CancellativeCommutativeSemigroupLang
      : Set where
      opL :
        CancellativeCommutativeSemigroupLang ->
        CancellativeCommutativeSemigroupLang ->
        CancellativeCommutativeSemigroupLang
    data CancellativeCommutativeSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CancellativeCommutativeSemigroupOpenLang
          n
      opOL :
        CancellativeCommutativeSemigroupOpenLang
          n ->
        CancellativeCommutativeSemigroupOpenLang
          n ->
        CancellativeCommutativeSemigroupOpenLang
          n
    evalTerm :
      (A : Set) ->
      CancellativeCommutativeSemigroup
        A ->
      CancellativeCommutativeSemigroupLang ->
      A
    evalTerm _ Ca (opL x1 x2) =
      op Ca (evalTerm _ Ca x1)
        (evalTerm _ Ca x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CancellativeCommutativeSemigroup
        A ->
      CancellativeCommutativeSemigroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ca (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ca (opOL
                         x1
                         x2) vars =
      op ca
        (evalOpenTerm _ n ca x1 vars)
        (evalOpenTerm _ n ca x2 vars)
    simplify :
      CancellativeCommutativeSemigroupLang ->
      CancellativeCommutativeSemigroupLang
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftCancellativeCommutativeSemigroupLang :
      CancellativeCommutativeSemigroupLang ->
      Staged
        CancellativeCommutativeSemigroupLang
    liftCancellativeCommutativeSemigroupLang x =
      Now x
    opOL' :
      (n : Nat) ->
      CancellativeCommutativeSemigroupOpenLang
        n ->
      CancellativeCommutativeSemigroupOpenLang
        n ->
      CancellativeCommutativeSemigroupOpenLang
        n
    opOL' _ x1 x2 = opOL x1 x2
    liftCancellativeCommutativeSemigroupOpenLang :
      (n : Nat) ->
      CancellativeCommutativeSemigroupOpenLang
        n ->
      Staged
        (CancellativeCommutativeSemigroupOpenLang
           n)
    liftCancellativeCommutativeSemigroupOpenLang _ (v
                                                    fin) =
      const _ (code _ (v fin))
    liftCancellativeCommutativeSemigroupOpenLang _ (opOL
                                                    x1
                                                    x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftCancellativeCommutativeSemigroupOpenLang
           _
           x1)
        (liftCancellativeCommutativeSemigroupOpenLang
           _
           x2)
  
  module CancellativeMagma where
    record CancellativeMagma
      (A : Set) : Set where
      constructor CancellativeMagmaC
      field
        op : A -> A -> A
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
    record CancellativeMagmaSig
      (AS : Set) : Set where
      constructor CancellativeMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record CancellativeMagmaProd
      (AP : Set) : Set where
      constructor CancellativeMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
    record CancellativeMagmaHom
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeMagma A1)
      (Ca2 : CancellativeMagma A2) :
      Set where
      constructor CancellativeMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ca1 x1 x2) ==
            op Ca2 (hom x1) (hom x2)
    record CancellativeMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeMagma A1)
      (Ca2 : CancellativeMagma A2) :
      Set where
      constructor CancellativeMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ca1 x1 x2)
            (op Ca2 y1 y2)
    data CancellativeMagmaLang
      : Set where
      opL :
        CancellativeMagmaLang ->
        CancellativeMagmaLang ->
        CancellativeMagmaLang
    data CancellativeMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CancellativeMagmaOpenLang n
      opOL :
        CancellativeMagmaOpenLang n ->
        CancellativeMagmaOpenLang n ->
        CancellativeMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      CancellativeMagma A ->
      CancellativeMagmaLang -> A
    evalTerm _ Ca (opL x1 x2) =
      op Ca (evalTerm _ Ca x1)
        (evalTerm _ Ca x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CancellativeMagma A ->
      CancellativeMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ca (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ca (opOL
                         x1
                         x2) vars =
      op ca
        (evalOpenTerm _ n ca x1 vars)
        (evalOpenTerm _ n ca x2 vars)
    simplify :
      CancellativeMagmaLang ->
      CancellativeMagmaLang
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftCancellativeMagmaLang :
      CancellativeMagmaLang ->
      Staged CancellativeMagmaLang
    liftCancellativeMagmaLang x =
      Now x
    opOL' :
      (n : Nat) ->
      CancellativeMagmaOpenLang n ->
      CancellativeMagmaOpenLang n ->
      CancellativeMagmaOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftCancellativeMagmaOpenLang :
      (n : Nat) ->
      CancellativeMagmaOpenLang n ->
      Staged
        (CancellativeMagmaOpenLang n)
    liftCancellativeMagmaOpenLang _ (v
                                     fin) = const _ (code _ (v fin))
    liftCancellativeMagmaOpenLang _ (opOL
                                     x1
                                     x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftCancellativeMagmaOpenLang _
           x1)
        (liftCancellativeMagmaOpenLang _
           x2)
  
  module CancellativeMonoid where
    record CancellativeMonoid
      (A : Set) : Set where
      constructor CancellativeMonoidC
      field
        op : A -> A -> A
        e : A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
    record CancellativeMonoidSig
      (AS : Set) : Set where
      constructor CancellativeMonoidSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record CancellativeMonoidProd
      (AP : Set) : Set where
      constructor CancellativeMonoidProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
    record CancellativeMonoidHom
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeMonoid A1)
      (Ca2 : CancellativeMonoid A2) :
      Set where
      constructor CancellativeMonoidHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ca1 x1 x2) ==
            op Ca2 (hom x1) (hom x2)
        pres-e : hom (e Ca1) == e Ca2
    record CancellativeMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeMonoid A1)
      (Ca2 : CancellativeMonoid A2) :
      Set where
      constructor CancellativeMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ca1 x1 x2)
            (op Ca2 y1 y2)
        interp-e :
          interp (e Ca1) (e Ca2)
    data CancellativeMonoidLang
      : Set where
      opL :
        CancellativeMonoidLang ->
        CancellativeMonoidLang ->
        CancellativeMonoidLang
      eL : CancellativeMonoidLang
    data CancellativeMonoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CancellativeMonoidOpenLang n
      opOL :
        CancellativeMonoidOpenLang n ->
        CancellativeMonoidOpenLang n ->
        CancellativeMonoidOpenLang n
      eOL :
        CancellativeMonoidOpenLang n
    evalTerm :
      (A : Set) ->
      CancellativeMonoid A ->
      CancellativeMonoidLang -> A
    evalTerm _ Ca (opL x1 x2) =
      op Ca (evalTerm _ Ca x1)
        (evalTerm _ Ca x2)
    evalTerm _ Ca (eL) = e Ca
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CancellativeMonoid A ->
      CancellativeMonoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ca (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ca (opOL
                         x1
                         x2) vars =
      op ca
        (evalOpenTerm _ n ca x1 vars)
        (evalOpenTerm _ n ca x2 vars)
    evalOpenTerm _ n ca (eOL) vars =
      e ca
    simplify :
      CancellativeMonoidLang ->
      CancellativeMonoidLang
    simplify (opL (eL) x) = x
    simplify (opL x (eL)) = x
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (eL) = eL
    liftCancellativeMonoidLang :
      CancellativeMonoidLang ->
      Staged CancellativeMonoidLang
    liftCancellativeMonoidLang x =
      Now x
    opOL' :
      (n : Nat) ->
      CancellativeMonoidOpenLang n ->
      CancellativeMonoidOpenLang n ->
      CancellativeMonoidOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    eOL' :
      (n : Nat) ->
      CancellativeMonoidOpenLang n
    eOL' _ = eOL
    liftCancellativeMonoidOpenLang :
      (n : Nat) ->
      CancellativeMonoidOpenLang n ->
      Staged
        (CancellativeMonoidOpenLang n)
    liftCancellativeMonoidOpenLang _ (v
                                      fin) = const _ (code _ (v fin))
    liftCancellativeMonoidOpenLang _ (opOL
                                      x1
                                      x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftCancellativeMonoidOpenLang
           _
           x1)
        (liftCancellativeMonoidOpenLang
           _
           x2)
    liftCancellativeMonoidOpenLang _ (eOL) =
      Now eOL
  
  module CancellativeSemigroup where
    record CancellativeSemigroup
      (A : Set) : Set where
      constructor CancellativeSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
    record CancellativeSemigroupSig
      (AS : Set) : Set where
      constructor CancellativeSemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record CancellativeSemigroupProd
      (AP : Set) : Set where
      constructor CancellativeSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
    record CancellativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeSemigroup A1)
      (Ca2 : CancellativeSemigroup
         A2) : Set where
      constructor CancellativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ca1 x1 x2) ==
            op Ca2 (hom x1) (hom x2)
    record CancellativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeSemigroup A1)
      (Ca2 : CancellativeSemigroup
         A2) : Set where
      constructor CancellativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ca1 x1 x2)
            (op Ca2 y1 y2)
    data CancellativeSemigroupLang
      : Set where
      opL :
        CancellativeSemigroupLang ->
        CancellativeSemigroupLang ->
        CancellativeSemigroupLang
    data CancellativeSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CancellativeSemigroupOpenLang n
      opOL :
        CancellativeSemigroupOpenLang
          n ->
        CancellativeSemigroupOpenLang
          n ->
        CancellativeSemigroupOpenLang n
    evalTerm :
      (A : Set) ->
      CancellativeSemigroup A ->
      CancellativeSemigroupLang -> A
    evalTerm _ Ca (opL x1 x2) =
      op Ca (evalTerm _ Ca x1)
        (evalTerm _ Ca x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CancellativeSemigroup A ->
      CancellativeSemigroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ca (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ca (opOL
                         x1
                         x2) vars =
      op ca
        (evalOpenTerm _ n ca x1 vars)
        (evalOpenTerm _ n ca x2 vars)
    simplify :
      CancellativeSemigroupLang ->
      CancellativeSemigroupLang
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftCancellativeSemigroupLang :
      CancellativeSemigroupLang ->
      Staged CancellativeSemigroupLang
    liftCancellativeSemigroupLang x =
      Now x
    opOL' :
      (n : Nat) ->
      CancellativeSemigroupOpenLang
        n ->
      CancellativeSemigroupOpenLang
        n ->
      CancellativeSemigroupOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftCancellativeSemigroupOpenLang :
      (n : Nat) ->
      CancellativeSemigroupOpenLang
        n ->
      Staged
        (CancellativeSemigroupOpenLang
           n)
    liftCancellativeSemigroupOpenLang _ (v
                                         fin) = const _ (code _ (v fin))
    liftCancellativeSemigroupOpenLang _ (opOL
                                         x1
                                         x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftCancellativeSemigroupOpenLang
           _
           x1)
        (liftCancellativeSemigroupOpenLang
           _
           x2)
  
  module Carrier where
    record Carrier
      (A : Set) : Set where
      constructor CarrierC
      field
        
    record CarrierSig
      (AS : Set) : Set where
      constructor CarrierSigSigC
      field
        
    record CarrierProd
      (AP : Set) : Set where
      constructor CarrierProdC
      field
        
    record CarrierHom
      (A1 : Set) (A2 : Set)
      (Ca1 : Carrier A1)
      (Ca2 : Carrier A2) : Set where
      constructor CarrierHomC
      field
        hom : A1 -> A2
    record CarrierRelInterp
      (A1 : Set) (A2 : Set)
      (Ca1 : Carrier A1)
      (Ca2 : Carrier A2) : Set where
      constructor CarrierRelInterpC
      field
        interp : A1 -> A2 -> Set
    data CarrierLang : Set where
      
    data CarrierOpenLang
      (n : Nat) : Set where
      v : Fin n -> CarrierOpenLang n
    evalTerm :
      (A : Set) ->
      Carrier A -> CarrierLang -> A
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Carrier A ->
      CarrierOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ca (v
                         fin) vars = lookup _ n fin vars
    simplify :
      CarrierLang -> CarrierLang
    liftCarrierLang :
      CarrierLang ->
      Staged CarrierLang
    liftCarrierLang x = Now x
    liftCarrierOpenLang :
      (n : Nat) ->
      CarrierOpenLang n ->
      Staged (CarrierOpenLang n)
    liftCarrierOpenLang _ (v fin) =
      const _ (code _ (v fin))
  
  module CommutativeAdditiveMagma where
    record CommutativeAdditiveMagma
      (A : Set) : Set where
      constructor CommutativeAdditiveMagmaC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
    record CommutativeAdditiveMagmaSig
      (AS : Set) : Set where
      constructor CommutativeAdditiveMagmaSigSigC
      field
        +S : AS -> AS -> AS
    record CommutativeAdditiveMagmaProd
      (AP : Set) : Set where
      constructor CommutativeAdditiveMagmaProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
    record CommutativeAdditiveMagmaHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeAdditiveMagma
         A1)
      (Co2 : CommutativeAdditiveMagma
         A2) : Set where
      constructor CommutativeAdditiveMagmaHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Co1 x1 x2) ==
            + Co2 (hom x1) (hom x2)
    record CommutativeAdditiveMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeAdditiveMagma
         A1)
      (Co2 : CommutativeAdditiveMagma
         A2) : Set where
      constructor CommutativeAdditiveMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Co1 x1 x2)
            (+ Co2 y1 y2)
    data CommutativeAdditiveMagmaLang
      : Set where
      +L :
        CommutativeAdditiveMagmaLang ->
        CommutativeAdditiveMagmaLang ->
        CommutativeAdditiveMagmaLang
    data CommutativeAdditiveMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CommutativeAdditiveMagmaOpenLang
          n
      +OL :
        CommutativeAdditiveMagmaOpenLang
          n ->
        CommutativeAdditiveMagmaOpenLang
          n ->
        CommutativeAdditiveMagmaOpenLang
          n
    evalTerm :
      (A : Set) ->
      CommutativeAdditiveMagma A ->
      CommutativeAdditiveMagmaLang ->
      A
    evalTerm _ Co (+L x1 x2) =
      + Co (evalTerm _ Co x1)
        (evalTerm _ Co x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CommutativeAdditiveMagma A ->
      CommutativeAdditiveMagmaOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n co (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n co (+OL
                         x1
                         x2) vars =
      + co
        (evalOpenTerm _ n co x1 vars)
        (evalOpenTerm _ n co x2 vars)
    simplify :
      CommutativeAdditiveMagmaLang ->
      CommutativeAdditiveMagmaLang
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftCommutativeAdditiveMagmaLang :
      CommutativeAdditiveMagmaLang ->
      Staged
        CommutativeAdditiveMagmaLang
    liftCommutativeAdditiveMagmaLang x =
      Now x
    +OL' :
      (n : Nat) ->
      CommutativeAdditiveMagmaOpenLang
        n ->
      CommutativeAdditiveMagmaOpenLang
        n ->
      CommutativeAdditiveMagmaOpenLang
        n
    +OL' _ x1 x2 = +OL x1 x2
    liftCommutativeAdditiveMagmaOpenLang :
      (n : Nat) ->
      CommutativeAdditiveMagmaOpenLang
        n ->
      Staged
        (CommutativeAdditiveMagmaOpenLang
           n)
    liftCommutativeAdditiveMagmaOpenLang _ (v
                                            fin) = const _ (code _ (v fin))
    liftCommutativeAdditiveMagmaOpenLang _ (+OL
                                            x1
                                            x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftCommutativeAdditiveMagmaOpenLang
           _
           x1)
        (liftCommutativeAdditiveMagmaOpenLang
           _
           x2)
  
  module CommutativeGroup where
    record CommutativeGroup
      (A : Set) : Set where
      constructor CommutativeGroupC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        inv : A -> A
        leftInverse_inv_op_e :
          (x : A) -> op x (inv x) == e
        rightInverse_inv_op_e :
          (x : A) -> op (inv x) x == e
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CommutativeGroupSig
      (AS : Set) : Set where
      constructor CommutativeGroupSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
        invS : AS -> AS
    record CommutativeGroupProd
      (AP : Set) : Set where
      constructor CommutativeGroupProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP xP (invP xP) == eP
        rightInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (invP xP) xP == eP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CommutativeGroupHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeGroup A1)
      (Co2 : CommutativeGroup A2) :
      Set where
      constructor CommutativeGroupHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Co1) == e Co2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
        pres-inv :
          (x1 : A1) ->
          hom (inv Co1 x1) ==
            inv Co2 (hom x1)
    record CommutativeGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeGroup A1)
      (Co2 : CommutativeGroup A2) :
      Set where
      constructor CommutativeGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Co1) (e Co2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Co1 x1) (inv Co2 y1)
    data CommutativeGroupLang
      : Set where
      eL : CommutativeGroupLang
      opL :
        CommutativeGroupLang ->
        CommutativeGroupLang ->
        CommutativeGroupLang
      invL :
        CommutativeGroupLang ->
        CommutativeGroupLang
    data CommutativeGroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CommutativeGroupOpenLang n
      eOL : CommutativeGroupOpenLang n
      opOL :
        CommutativeGroupOpenLang n ->
        CommutativeGroupOpenLang n ->
        CommutativeGroupOpenLang n
      invOL :
        CommutativeGroupOpenLang n ->
        CommutativeGroupOpenLang n
    evalTerm :
      (A : Set) ->
      CommutativeGroup A ->
      CommutativeGroupLang -> A
    evalTerm _ Co (eL) = e Co
    evalTerm _ Co (opL x1 x2) =
      op Co (evalTerm _ Co x1)
        (evalTerm _ Co x2)
    evalTerm _ Co (invL x1) =
      inv Co (evalTerm _ Co x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CommutativeGroup A ->
      CommutativeGroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n co (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n co (eOL) vars =
      e co
    evalOpenTerm _ n co (opOL
                         x1
                         x2) vars =
      op co
        (evalOpenTerm _ n co x1 vars)
        (evalOpenTerm _ n co x2 vars)
    evalOpenTerm _ n co (invOL
                         x1) vars =
      inv co
        (evalOpenTerm _ n co x1 vars)
    simplify :
      CommutativeGroupLang ->
      CommutativeGroupLang
    simplify (opL (eL) x) = x
    simplify (opL x (eL)) = x
    simplify (opL x (invL x)) = eL
    simplify (opL (invL x) x) = eL
    simplify (eL) = eL
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (invL x1) =
      invL (simplify x1)
    liftCommutativeGroupLang :
      CommutativeGroupLang ->
      Staged CommutativeGroupLang
    liftCommutativeGroupLang x =
      Now x
    eOL' :
      (n : Nat) ->
      CommutativeGroupOpenLang n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      CommutativeGroupOpenLang n ->
      CommutativeGroupOpenLang n ->
      CommutativeGroupOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    invOL' :
      (n : Nat) ->
      CommutativeGroupOpenLang n ->
      CommutativeGroupOpenLang n
    invOL' _ x1 = invOL x1
    liftCommutativeGroupOpenLang :
      (n : Nat) ->
      CommutativeGroupOpenLang n ->
      Staged
        (CommutativeGroupOpenLang n)
    liftCommutativeGroupOpenLang _ (v
                                    fin) = const _ (code _ (v fin))
    liftCommutativeGroupOpenLang _ (eOL) =
      Now eOL
    liftCommutativeGroupOpenLang _ (opOL
                                    x1
                                    x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftCommutativeGroupOpenLang _
           x1)
        (liftCommutativeGroupOpenLang _
           x2)
    liftCommutativeGroupOpenLang _ (invOL
                                    x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (liftCommutativeGroupOpenLang _
           x1)
  
  module CommutativeMagma where
    record CommutativeMagma
      (A : Set) : Set where
      constructor CommutativeMagmaC
      field
        op : A -> A -> A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CommutativeMagmaSig
      (AS : Set) : Set where
      constructor CommutativeMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record CommutativeMagmaProd
      (AP : Set) : Set where
      constructor CommutativeMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CommutativeMagmaHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMagma A1)
      (Co2 : CommutativeMagma A2) :
      Set where
      constructor CommutativeMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
    record CommutativeMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMagma A1)
      (Co2 : CommutativeMagma A2) :
      Set where
      constructor CommutativeMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
    data CommutativeMagmaLang
      : Set where
      opL :
        CommutativeMagmaLang ->
        CommutativeMagmaLang ->
        CommutativeMagmaLang
    data CommutativeMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CommutativeMagmaOpenLang n
      opOL :
        CommutativeMagmaOpenLang n ->
        CommutativeMagmaOpenLang n ->
        CommutativeMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      CommutativeMagma A ->
      CommutativeMagmaLang -> A
    evalTerm _ Co (opL x1 x2) =
      op Co (evalTerm _ Co x1)
        (evalTerm _ Co x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CommutativeMagma A ->
      CommutativeMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n co (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n co (opOL
                         x1
                         x2) vars =
      op co
        (evalOpenTerm _ n co x1 vars)
        (evalOpenTerm _ n co x2 vars)
    simplify :
      CommutativeMagmaLang ->
      CommutativeMagmaLang
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftCommutativeMagmaLang :
      CommutativeMagmaLang ->
      Staged CommutativeMagmaLang
    liftCommutativeMagmaLang x =
      Now x
    opOL' :
      (n : Nat) ->
      CommutativeMagmaOpenLang n ->
      CommutativeMagmaOpenLang n ->
      CommutativeMagmaOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftCommutativeMagmaOpenLang :
      (n : Nat) ->
      CommutativeMagmaOpenLang n ->
      Staged
        (CommutativeMagmaOpenLang n)
    liftCommutativeMagmaOpenLang _ (v
                                    fin) = const _ (code _ (v fin))
    liftCommutativeMagmaOpenLang _ (opOL
                                    x1
                                    x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftCommutativeMagmaOpenLang _
           x1)
        (liftCommutativeMagmaOpenLang _
           x2)
  
  module CommutativeMonoid where
    record CommutativeMonoid
      (A : Set) : Set where
      constructor CommutativeMonoidC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        e : A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CommutativeMonoidSig
      (AS : Set) : Set where
      constructor CommutativeMonoidSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record CommutativeMonoidProd
      (AP : Set) : Set where
      constructor CommutativeMonoidProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CommutativeMonoidHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMonoid A1)
      (Co2 : CommutativeMonoid A2) :
      Set where
      constructor CommutativeMonoidHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
        pres-e : hom (e Co1) == e Co2
    record CommutativeMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMonoid A1)
      (Co2 : CommutativeMonoid A2) :
      Set where
      constructor CommutativeMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
        interp-e :
          interp (e Co1) (e Co2)
    data CommutativeMonoidLang
      : Set where
      opL :
        CommutativeMonoidLang ->
        CommutativeMonoidLang ->
        CommutativeMonoidLang
      eL : CommutativeMonoidLang
    data CommutativeMonoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CommutativeMonoidOpenLang n
      opOL :
        CommutativeMonoidOpenLang n ->
        CommutativeMonoidOpenLang n ->
        CommutativeMonoidOpenLang n
      eOL :
        CommutativeMonoidOpenLang n
    evalTerm :
      (A : Set) ->
      CommutativeMonoid A ->
      CommutativeMonoidLang -> A
    evalTerm _ Co (opL x1 x2) =
      op Co (evalTerm _ Co x1)
        (evalTerm _ Co x2)
    evalTerm _ Co (eL) = e Co
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CommutativeMonoid A ->
      CommutativeMonoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n co (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n co (opOL
                         x1
                         x2) vars =
      op co
        (evalOpenTerm _ n co x1 vars)
        (evalOpenTerm _ n co x2 vars)
    evalOpenTerm _ n co (eOL) vars =
      e co
    simplify :
      CommutativeMonoidLang ->
      CommutativeMonoidLang
    simplify (opL (eL) x) = x
    simplify (opL x (eL)) = x
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (eL) = eL
    liftCommutativeMonoidLang :
      CommutativeMonoidLang ->
      Staged CommutativeMonoidLang
    liftCommutativeMonoidLang x =
      Now x
    opOL' :
      (n : Nat) ->
      CommutativeMonoidOpenLang n ->
      CommutativeMonoidOpenLang n ->
      CommutativeMonoidOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    eOL' :
      (n : Nat) ->
      CommutativeMonoidOpenLang n
    eOL' _ = eOL
    liftCommutativeMonoidOpenLang :
      (n : Nat) ->
      CommutativeMonoidOpenLang n ->
      Staged
        (CommutativeMonoidOpenLang n)
    liftCommutativeMonoidOpenLang _ (v
                                     fin) = const _ (code _ (v fin))
    liftCommutativeMonoidOpenLang _ (opOL
                                     x1
                                     x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftCommutativeMonoidOpenLang _
           x1)
        (liftCommutativeMonoidOpenLang _
           x2)
    liftCommutativeMonoidOpenLang _ (eOL) =
      Now eOL
  
  module CommutativeMonoid1 where
    record CommutativeMonoid1
      (A : Set) : Set where
      constructor CommutativeMonoid1C
      field
        1 : A
        op : A -> A -> A
        lunit_1 : (x : A) -> op 1 x == x
        runit_1 : (x : A) -> op x 1 == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CommutativeMonoid1Sig
      (AS : Set) : Set where
      constructor CommutativeMonoid1SigSigC
      field
        1S : AS
        opS : AS -> AS -> AS
    record CommutativeMonoid1Prod
      (AP : Set) : Set where
      constructor CommutativeMonoid1ProdC
      field
        1P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          opP 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          opP xP 1P == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CommutativeMonoid1Hom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMonoid1 A1)
      (Co2 : CommutativeMonoid1 A2) :
      Set where
      constructor CommutativeMonoid1HomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Co1) == 1 Co2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
    record CommutativeMonoid1RelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMonoid1 A1)
      (Co2 : CommutativeMonoid1 A2) :
      Set where
      constructor CommutativeMonoid1RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Co1) (1 Co2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
    data CommutativeMonoid1Lang
      : Set where
      1L : CommutativeMonoid1Lang
      opL :
        CommutativeMonoid1Lang ->
        CommutativeMonoid1Lang ->
        CommutativeMonoid1Lang
    data CommutativeMonoid1OpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CommutativeMonoid1OpenLang n
      1OL :
        CommutativeMonoid1OpenLang n
      opOL :
        CommutativeMonoid1OpenLang n ->
        CommutativeMonoid1OpenLang n ->
        CommutativeMonoid1OpenLang n
    evalTerm :
      (A : Set) ->
      CommutativeMonoid1 A ->
      CommutativeMonoid1Lang -> A
    evalTerm _ Co (1L) = 1 Co
    evalTerm _ Co (opL x1 x2) =
      op Co (evalTerm _ Co x1)
        (evalTerm _ Co x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CommutativeMonoid1 A ->
      CommutativeMonoid1OpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n co (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n co (1OL) vars =
      1 co
    evalOpenTerm _ n co (opOL
                         x1
                         x2) vars =
      op co
        (evalOpenTerm _ n co x1 vars)
        (evalOpenTerm _ n co x2 vars)
    simplify :
      CommutativeMonoid1Lang ->
      CommutativeMonoid1Lang
    simplify (opL (1L) x) = x
    simplify (opL x (1L)) = x
    simplify (1L) = 1L
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftCommutativeMonoid1Lang :
      CommutativeMonoid1Lang ->
      Staged CommutativeMonoid1Lang
    liftCommutativeMonoid1Lang x =
      Now x
    1OL' :
      (n : Nat) ->
      CommutativeMonoid1OpenLang n
    1OL' _ = 1OL
    opOL' :
      (n : Nat) ->
      CommutativeMonoid1OpenLang n ->
      CommutativeMonoid1OpenLang n ->
      CommutativeMonoid1OpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftCommutativeMonoid1OpenLang :
      (n : Nat) ->
      CommutativeMonoid1OpenLang n ->
      Staged
        (CommutativeMonoid1OpenLang n)
    liftCommutativeMonoid1OpenLang _ (v
                                      fin) = const _ (code _ (v fin))
    liftCommutativeMonoid1OpenLang _ (1OL) =
      Now 1OL
    liftCommutativeMonoid1OpenLang _ (opOL
                                      x1
                                      x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftCommutativeMonoid1OpenLang
           _
           x1)
        (liftCommutativeMonoid1OpenLang
           _
           x2)
  
  module CommutativePointedMagma where
    record CommutativePointedMagma
      (A : Set) : Set where
      constructor CommutativePointedMagmaC
      field
        op : A -> A -> A
        e : A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CommutativePointedMagmaSig
      (AS : Set) : Set where
      constructor CommutativePointedMagmaSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record CommutativePointedMagmaProd
      (AP : Set) : Set where
      constructor CommutativePointedMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CommutativePointedMagmaHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativePointedMagma
         A1)
      (Co2 : CommutativePointedMagma
         A2) : Set where
      constructor CommutativePointedMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
        pres-e : hom (e Co1) == e Co2
    record CommutativePointedMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativePointedMagma
         A1)
      (Co2 : CommutativePointedMagma
         A2) : Set where
      constructor CommutativePointedMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
        interp-e :
          interp (e Co1) (e Co2)
    data CommutativePointedMagmaLang
      : Set where
      opL :
        CommutativePointedMagmaLang ->
        CommutativePointedMagmaLang ->
        CommutativePointedMagmaLang
      eL : CommutativePointedMagmaLang
    data CommutativePointedMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CommutativePointedMagmaOpenLang
          n
      opOL :
        CommutativePointedMagmaOpenLang
          n ->
        CommutativePointedMagmaOpenLang
          n ->
        CommutativePointedMagmaOpenLang
          n
      eOL :
        CommutativePointedMagmaOpenLang
          n
    evalTerm :
      (A : Set) ->
      CommutativePointedMagma A ->
      CommutativePointedMagmaLang -> A
    evalTerm _ Co (opL x1 x2) =
      op Co (evalTerm _ Co x1)
        (evalTerm _ Co x2)
    evalTerm _ Co (eL) = e Co
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CommutativePointedMagma A ->
      CommutativePointedMagmaOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n co (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n co (opOL
                         x1
                         x2) vars =
      op co
        (evalOpenTerm _ n co x1 vars)
        (evalOpenTerm _ n co x2 vars)
    evalOpenTerm _ n co (eOL) vars =
      e co
    simplify :
      CommutativePointedMagmaLang ->
      CommutativePointedMagmaLang
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (eL) = eL
    liftCommutativePointedMagmaLang :
      CommutativePointedMagmaLang ->
      Staged
        CommutativePointedMagmaLang
    liftCommutativePointedMagmaLang x =
      Now x
    opOL' :
      (n : Nat) ->
      CommutativePointedMagmaOpenLang
        n ->
      CommutativePointedMagmaOpenLang
        n ->
      CommutativePointedMagmaOpenLang
        n
    opOL' _ x1 x2 = opOL x1 x2
    eOL' :
      (n : Nat) ->
      CommutativePointedMagmaOpenLang
        n
    eOL' _ = eOL
    liftCommutativePointedMagmaOpenLang :
      (n : Nat) ->
      CommutativePointedMagmaOpenLang
        n ->
      Staged
        (CommutativePointedMagmaOpenLang
           n)
    liftCommutativePointedMagmaOpenLang _ (v
                                           fin) = const _ (code _ (v fin))
    liftCommutativePointedMagmaOpenLang _ (opOL
                                           x1
                                           x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftCommutativePointedMagmaOpenLang
           _
           x1)
        (liftCommutativePointedMagmaOpenLang
           _
           x2)
    liftCommutativePointedMagmaOpenLang _ (eOL) =
      Now eOL
  
  module CommutativeRing where
    record CommutativeRing
      (A : Set) : Set where
      constructor CommutativeRingC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
    record CommutativeRingSig
      (AS : Set) : Set where
      constructor CommutativeRingSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
    record CommutativeRingProd
      (AP : Set) : Set where
      constructor CommutativeRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
    record CommutativeRingHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeRing A1)
      (Co2 : CommutativeRing A2) :
      Set where
      constructor CommutativeRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Co1 x1 x2) ==
            * Co2 (hom x1) (hom x2)
        pres-1 : hom (1 Co1) == 1 Co2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Co1 x1 x2) ==
            + Co2 (hom x1) (hom x2)
        pres-0 : hom (0 Co1) == 0 Co2
        pres-neg :
          (x1 : A1) ->
          hom (neg Co1 x1) ==
            neg Co2 (hom x1)
    record CommutativeRingRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeRing A1)
      (Co2 : CommutativeRing A2) :
      Set where
      constructor CommutativeRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Co1 x1 x2)
            (* Co2 y1 y2)
        interp-1 :
          interp (1 Co1) (1 Co2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Co1 x1 x2)
            (+ Co2 y1 y2)
        interp-0 :
          interp (0 Co1) (0 Co2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Co1 x1) (neg Co2 y1)
    data CommutativeRingLang
      : Set where
      *L :
        CommutativeRingLang ->
        CommutativeRingLang ->
        CommutativeRingLang
      1L : CommutativeRingLang
      +L :
        CommutativeRingLang ->
        CommutativeRingLang ->
        CommutativeRingLang
      0L : CommutativeRingLang
      negL :
        CommutativeRingLang ->
        CommutativeRingLang
    data CommutativeRingOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CommutativeRingOpenLang n
      *OL :
        CommutativeRingOpenLang n ->
        CommutativeRingOpenLang n ->
        CommutativeRingOpenLang n
      1OL : CommutativeRingOpenLang n
      +OL :
        CommutativeRingOpenLang n ->
        CommutativeRingOpenLang n ->
        CommutativeRingOpenLang n
      0OL : CommutativeRingOpenLang n
      negOL :
        CommutativeRingOpenLang n ->
        CommutativeRingOpenLang n
    evalTerm :
      (A : Set) ->
      CommutativeRing A ->
      CommutativeRingLang -> A
    evalTerm _ Co (*L x1 x2) =
      * Co (evalTerm _ Co x1)
        (evalTerm _ Co x2)
    evalTerm _ Co (1L) = 1 Co
    evalTerm _ Co (+L x1 x2) =
      + Co (evalTerm _ Co x1)
        (evalTerm _ Co x2)
    evalTerm _ Co (0L) = 0 Co
    evalTerm _ Co (negL x1) =
      neg Co (evalTerm _ Co x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CommutativeRing A ->
      CommutativeRingOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n co (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n co (*OL
                         x1
                         x2) vars =
      * co
        (evalOpenTerm _ n co x1 vars)
        (evalOpenTerm _ n co x2 vars)
    evalOpenTerm _ n co (1OL) vars =
      1 co
    evalOpenTerm _ n co (+OL
                         x1
                         x2) vars =
      + co
        (evalOpenTerm _ n co x1 vars)
        (evalOpenTerm _ n co x2 vars)
    evalOpenTerm _ n co (0OL) vars =
      0 co
    evalOpenTerm _ n co (negOL
                         x1) vars =
      neg co
        (evalOpenTerm _ n co x1 vars)
    simplify :
      CommutativeRingLang ->
      CommutativeRingLang
    simplify (*L (1L) x) = x
    simplify (*L x (1L)) = x
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (+L
              (*L x y)
              (*L x z)) = *L x (+L y z)
    simplify (+L
              (*L y x)
              (*L z x)) = *L (+L y z) x
    simplify (+L x (negL x)) = 0L
    simplify (+L (negL x) x) = 0L
    simplify (*L (0L) x) = 0L
    simplify (*L x (0L)) = 0L
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (1L) = 1L
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (0L) = 0L
    simplify (negL x1) =
      negL (simplify x1)
    liftCommutativeRingLang :
      CommutativeRingLang ->
      Staged CommutativeRingLang
    liftCommutativeRingLang x =
      Now x
    *OL' :
      (n : Nat) ->
      CommutativeRingOpenLang n ->
      CommutativeRingOpenLang n ->
      CommutativeRingOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    1OL' :
      (n : Nat) ->
      CommutativeRingOpenLang n
    1OL' _ = 1OL
    +OL' :
      (n : Nat) ->
      CommutativeRingOpenLang n ->
      CommutativeRingOpenLang n ->
      CommutativeRingOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      CommutativeRingOpenLang n
    0OL' _ = 0OL
    negOL' :
      (n : Nat) ->
      CommutativeRingOpenLang n ->
      CommutativeRingOpenLang n
    negOL' _ x1 = negOL x1
    liftCommutativeRingOpenLang :
      (n : Nat) ->
      CommutativeRingOpenLang n ->
      Staged
        (CommutativeRingOpenLang n)
    liftCommutativeRingOpenLang _ (v
                                   fin) = const _ (code _ (v fin))
    liftCommutativeRingOpenLang _ (*OL
                                   x1
                                   x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftCommutativeRingOpenLang _
           x1)
        (liftCommutativeRingOpenLang _
           x2)
    liftCommutativeRingOpenLang _ (1OL) =
      Now 1OL
    liftCommutativeRingOpenLang _ (+OL
                                   x1
                                   x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftCommutativeRingOpenLang _
           x1)
        (liftCommutativeRingOpenLang _
           x2)
    liftCommutativeRingOpenLang _ (0OL) =
      Now 0OL
    liftCommutativeRingOpenLang _ (negOL
                                   x1) =
      stage1 _ _ (negOL' _)
        (codeLift1 _ _ (negOL' _))
        (liftCommutativeRingOpenLang _
           x1)
  
  module CommutativeSemigroup where
    record CommutativeSemigroup
      (A : Set) : Set where
      constructor CommutativeSemigroupC
      field
        op : A -> A -> A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record CommutativeSemigroupSig
      (AS : Set) : Set where
      constructor CommutativeSemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record CommutativeSemigroupProd
      (AP : Set) : Set where
      constructor CommutativeSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record CommutativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeSemigroup A1)
      (Co2 : CommutativeSemigroup
         A2) : Set where
      constructor CommutativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
    record CommutativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeSemigroup A1)
      (Co2 : CommutativeSemigroup
         A2) : Set where
      constructor CommutativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
    data CommutativeSemigroupLang
      : Set where
      opL :
        CommutativeSemigroupLang ->
        CommutativeSemigroupLang ->
        CommutativeSemigroupLang
    data CommutativeSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CommutativeSemigroupOpenLang n
      opOL :
        CommutativeSemigroupOpenLang
          n ->
        CommutativeSemigroupOpenLang
          n ->
        CommutativeSemigroupOpenLang n
    evalTerm :
      (A : Set) ->
      CommutativeSemigroup A ->
      CommutativeSemigroupLang -> A
    evalTerm _ Co (opL x1 x2) =
      op Co (evalTerm _ Co x1)
        (evalTerm _ Co x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CommutativeSemigroup A ->
      CommutativeSemigroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n co (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n co (opOL
                         x1
                         x2) vars =
      op co
        (evalOpenTerm _ n co x1 vars)
        (evalOpenTerm _ n co x2 vars)
    simplify :
      CommutativeSemigroupLang ->
      CommutativeSemigroupLang
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftCommutativeSemigroupLang :
      CommutativeSemigroupLang ->
      Staged CommutativeSemigroupLang
    liftCommutativeSemigroupLang x =
      Now x
    opOL' :
      (n : Nat) ->
      CommutativeSemigroupOpenLang
        n ->
      CommutativeSemigroupOpenLang
        n ->
      CommutativeSemigroupOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftCommutativeSemigroupOpenLang :
      (n : Nat) ->
      CommutativeSemigroupOpenLang
        n ->
      Staged
        (CommutativeSemigroupOpenLang n)
    liftCommutativeSemigroupOpenLang _ (v
                                        fin) = const _ (code _ (v fin))
    liftCommutativeSemigroupOpenLang _ (opOL
                                        x1
                                        x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftCommutativeSemigroupOpenLang
           _
           x1)
        (liftCommutativeSemigroupOpenLang
           _
           x2)
  
  module ComplementSig where
    record ComplementSig
      (A : Set) : Set where
      constructor ComplementSigC
      field
        compl : A -> A
    record ComplementSigSig
      (AS : Set) : Set where
      constructor ComplementSigSigSigC
      field
        complS : AS -> AS
    record ComplementSigProd
      (AP : Set) : Set where
      constructor ComplementSigProdC
      field
        complP :
          Prod AP AP -> Prod AP AP
    record ComplementSigHom
      (A1 : Set) (A2 : Set)
      (Co1 : ComplementSig A1)
      (Co2 : ComplementSig A2) :
      Set where
      constructor ComplementSigHomC
      field
        hom : A1 -> A2
        pres-compl :
          (x1 : A1) ->
          hom (compl Co1 x1) ==
            compl Co2 (hom x1)
    record ComplementSigRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : ComplementSig A1)
      (Co2 : ComplementSig A2) :
      Set where
      constructor ComplementSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-compl :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (compl Co1 x1)
            (compl Co2 y1)
    data ComplementSigLang
      : Set where
      complL :
        ComplementSigLang ->
        ComplementSigLang
    data ComplementSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> ComplementSigOpenLang n
      complOL :
        ComplementSigOpenLang n ->
        ComplementSigOpenLang n
    evalTerm :
      (A : Set) ->
      ComplementSig A ->
      ComplementSigLang -> A
    evalTerm _ Co (complL x1) =
      compl Co (evalTerm _ Co x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      ComplementSig A ->
      ComplementSigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n co (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n co (complOL
                         x1) vars =
      compl co
        (evalOpenTerm _ n co x1 vars)
    simplify :
      ComplementSigLang ->
      ComplementSigLang
    simplify (complL x1) =
      complL (simplify x1)
    liftComplementSigLang :
      ComplementSigLang ->
      Staged ComplementSigLang
    liftComplementSigLang x = Now x
    complOL' :
      (n : Nat) ->
      ComplementSigOpenLang n ->
      ComplementSigOpenLang n
    complOL' _ x1 = complOL x1
    liftComplementSigOpenLang :
      (n : Nat) ->
      ComplementSigOpenLang n ->
      Staged (ComplementSigOpenLang n)
    liftComplementSigOpenLang _ (v
                                 fin) = const _ (code _ (v fin))
    liftComplementSigOpenLang _ (complOL
                                 x1) =
      stage1 _ _ (complOL' _)
        (codeLift1 _ _ (complOL' _))
        (liftComplementSigOpenLang _ x1)
  
  module DistributiveLattice where
    record DistributiveLattice
      (A : Set) : Set where
      constructor DistributiveLatticeC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
        leftModular_*_+ :
          (x : A) (y : A) (z : A) ->
          + (* x y) (* x z) ==
            * x (+ y (* x z))
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
    record DistributiveLatticeSig
      (AS : Set) : Set where
      constructor DistributiveLatticeSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record DistributiveLatticeProd
      (AP : Set) : Set where
      constructor DistributiveLatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
        leftModular_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (*P xP yP) (*P xP zP) ==
            *P xP (+P yP (*P xP zP))
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
    record DistributiveLatticeHom
      (A1 : Set) (A2 : Set)
      (Di1 : DistributiveLattice A1)
      (Di2 : DistributiveLattice A2) :
      Set where
      constructor DistributiveLatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Di1 x1 x2) ==
            * Di2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Di1 x1 x2) ==
            + Di2 (hom x1) (hom x2)
    record DistributiveLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Di1 : DistributiveLattice A1)
      (Di2 : DistributiveLattice A2) :
      Set where
      constructor DistributiveLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Di1 x1 x2)
            (* Di2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Di1 x1 x2)
            (+ Di2 y1 y2)
    data DistributiveLatticeLang
      : Set where
      *L :
        DistributiveLatticeLang ->
        DistributiveLatticeLang ->
        DistributiveLatticeLang
      +L :
        DistributiveLatticeLang ->
        DistributiveLatticeLang ->
        DistributiveLatticeLang
    data DistributiveLatticeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        DistributiveLatticeOpenLang n
      *OL :
        DistributiveLatticeOpenLang n ->
        DistributiveLatticeOpenLang n ->
        DistributiveLatticeOpenLang n
      +OL :
        DistributiveLatticeOpenLang n ->
        DistributiveLatticeOpenLang n ->
        DistributiveLatticeOpenLang n
    evalTerm :
      (A : Set) ->
      DistributiveLattice A ->
      DistributiveLatticeLang -> A
    evalTerm _ Di (*L x1 x2) =
      * Di (evalTerm _ Di x1)
        (evalTerm _ Di x2)
    evalTerm _ Di (+L x1 x2) =
      + Di (evalTerm _ Di x1)
        (evalTerm _ Di x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      DistributiveLattice A ->
      DistributiveLatticeOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n di (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n di (*OL
                         x1
                         x2) vars =
      * di
        (evalOpenTerm _ n di x1 vars)
        (evalOpenTerm _ n di x2 vars)
    evalOpenTerm _ n di (+OL
                         x1
                         x2) vars =
      + di
        (evalOpenTerm _ n di x1 vars)
        (evalOpenTerm _ n di x2 vars)
    simplify :
      DistributiveLatticeLang ->
      DistributiveLatticeLang
    simplify (*L x x) = x
    simplify (+L x x) = x
    simplify (*L x (+L x y)) = x
    simplify (+L x (*L x y)) = x
    simplify (+L
              (*L x y)
              (*L x z)) = *L x (+L y z)
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftDistributiveLatticeLang :
      DistributiveLatticeLang ->
      Staged DistributiveLatticeLang
    liftDistributiveLatticeLang x =
      Now x
    *OL' :
      (n : Nat) ->
      DistributiveLatticeOpenLang n ->
      DistributiveLatticeOpenLang n ->
      DistributiveLatticeOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      DistributiveLatticeOpenLang n ->
      DistributiveLatticeOpenLang n ->
      DistributiveLatticeOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftDistributiveLatticeOpenLang :
      (n : Nat) ->
      DistributiveLatticeOpenLang n ->
      Staged
        (DistributiveLatticeOpenLang n)
    liftDistributiveLatticeOpenLang _ (v
                                       fin) = const _ (code _ (v fin))
    liftDistributiveLatticeOpenLang _ (*OL
                                       x1
                                       x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftDistributiveLatticeOpenLang
           _
           x1)
        (liftDistributiveLatticeOpenLang
           _
           x2)
    liftDistributiveLatticeOpenLang _ (+OL
                                       x1
                                       x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftDistributiveLatticeOpenLang
           _
           x1)
        (liftDistributiveLatticeOpenLang
           _
           x2)
  
  module DoubleMonoid where
    record DoubleMonoid
      (A : Set) : Set where
      constructor DoubleMonoidC
      field
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
    record DoubleMonoidSig
      (AS : Set) : Set where
      constructor DoubleMonoidSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
        *S : AS -> AS -> AS
        1S : AS
    record DoubleMonoidProd
      (AP : Set) : Set where
      constructor DoubleMonoidProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
    record DoubleMonoidHom
      (A1 : Set) (A2 : Set)
      (Do1 : DoubleMonoid A1)
      (Do2 : DoubleMonoid A2) :
      Set where
      constructor DoubleMonoidHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Do1 x1 x2) ==
            + Do2 (hom x1) (hom x2)
        pres-0 : hom (0 Do1) == 0 Do2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Do1 x1 x2) ==
            * Do2 (hom x1) (hom x2)
        pres-1 : hom (1 Do1) == 1 Do2
    record DoubleMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Do1 : DoubleMonoid A1)
      (Do2 : DoubleMonoid A2) :
      Set where
      constructor DoubleMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Do1 x1 x2)
            (+ Do2 y1 y2)
        interp-0 :
          interp (0 Do1) (0 Do2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Do1 x1 x2)
            (* Do2 y1 y2)
        interp-1 :
          interp (1 Do1) (1 Do2)
    data DoubleMonoidLang
      : Set where
      +L :
        DoubleMonoidLang ->
        DoubleMonoidLang ->
        DoubleMonoidLang
      0L : DoubleMonoidLang
      *L :
        DoubleMonoidLang ->
        DoubleMonoidLang ->
        DoubleMonoidLang
      1L : DoubleMonoidLang
    data DoubleMonoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> DoubleMonoidOpenLang n
      +OL :
        DoubleMonoidOpenLang n ->
        DoubleMonoidOpenLang n ->
        DoubleMonoidOpenLang n
      0OL : DoubleMonoidOpenLang n
      *OL :
        DoubleMonoidOpenLang n ->
        DoubleMonoidOpenLang n ->
        DoubleMonoidOpenLang n
      1OL : DoubleMonoidOpenLang n
    evalTerm :
      (A : Set) ->
      DoubleMonoid A ->
      DoubleMonoidLang -> A
    evalTerm _ Do (+L x1 x2) =
      + Do (evalTerm _ Do x1)
        (evalTerm _ Do x2)
    evalTerm _ Do (0L) = 0 Do
    evalTerm _ Do (*L x1 x2) =
      * Do (evalTerm _ Do x1)
        (evalTerm _ Do x2)
    evalTerm _ Do (1L) = 1 Do
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      DoubleMonoid A ->
      DoubleMonoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n do (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n do (+OL
                         x1
                         x2) vars =
      + do
        (evalOpenTerm _ n do x1 vars)
        (evalOpenTerm _ n do x2 vars)
    evalOpenTerm _ n do (0OL) vars =
      0 do
    evalOpenTerm _ n do (*OL
                         x1
                         x2) vars =
      * do
        (evalOpenTerm _ n do x1 vars)
        (evalOpenTerm _ n do x2 vars)
    evalOpenTerm _ n do (1OL) vars =
      1 do
    simplify :
      DoubleMonoidLang ->
      DoubleMonoidLang
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (*L (1L) x) = x
    simplify (*L x (1L)) = x
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (0L) = 0L
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (1L) = 1L
    liftDoubleMonoidLang :
      DoubleMonoidLang ->
      Staged DoubleMonoidLang
    liftDoubleMonoidLang x = Now x
    +OL' :
      (n : Nat) ->
      DoubleMonoidOpenLang n ->
      DoubleMonoidOpenLang n ->
      DoubleMonoidOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      DoubleMonoidOpenLang n
    0OL' _ = 0OL
    *OL' :
      (n : Nat) ->
      DoubleMonoidOpenLang n ->
      DoubleMonoidOpenLang n ->
      DoubleMonoidOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    1OL' :
      (n : Nat) ->
      DoubleMonoidOpenLang n
    1OL' _ = 1OL
    liftDoubleMonoidOpenLang :
      (n : Nat) ->
      DoubleMonoidOpenLang n ->
      Staged (DoubleMonoidOpenLang n)
    liftDoubleMonoidOpenLang _ (v
                                fin) = const _ (code _ (v fin))
    liftDoubleMonoidOpenLang _ (+OL
                                x1
                                x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftDoubleMonoidOpenLang _ x1)
        (liftDoubleMonoidOpenLang _ x2)
    liftDoubleMonoidOpenLang _ (0OL) =
      Now 0OL
    liftDoubleMonoidOpenLang _ (*OL
                                x1
                                x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftDoubleMonoidOpenLang _ x1)
        (liftDoubleMonoidOpenLang _ x2)
    liftDoubleMonoidOpenLang _ (1OL) =
      Now 1OL
  
  module DualDeMorgan where
    record DualDeMorgan
      (A : Set) : Set where
      constructor DualDeMorganC
      field
        * : A -> A -> A
        + : A -> A -> A
        prim : A -> A
        andDeMorgan_*_+_prim :
          (x : A) (y : A) (z : A) ->
          prim (* x y) ==
            + (prim x) (prim y)
        orDeMorgan_+_*_prim :
          (x : A) (y : A) (z : A) ->
          prim (+ x y) ==
            * (prim x) (prim y)
    record DualDeMorganSig
      (AS : Set) : Set where
      constructor DualDeMorganSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        primS : AS -> AS
    record DualDeMorganProd
      (AP : Set) : Set where
      constructor DualDeMorganProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        andDeMorgan_*_+_primP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          primP (*P xP yP) ==
            +P (primP xP) (primP yP)
        orDeMorgan_+_*_primP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          primP (+P xP yP) ==
            *P (primP xP) (primP yP)
    record DualDeMorganHom
      (A1 : Set) (A2 : Set)
      (Du1 : DualDeMorgan A1)
      (Du2 : DualDeMorgan A2) :
      Set where
      constructor DualDeMorganHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Du1 x1 x2) ==
            * Du2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Du1 x1 x2) ==
            + Du2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Du1 x1) ==
            prim Du2 (hom x1)
    record DualDeMorganRelInterp
      (A1 : Set) (A2 : Set)
      (Du1 : DualDeMorgan A1)
      (Du2 : DualDeMorgan A2) :
      Set where
      constructor DualDeMorganRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Du1 x1 x2)
            (* Du2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Du1 x1 x2)
            (+ Du2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Du1 x1)
            (prim Du2 y1)
    data DualDeMorganLang
      : Set where
      *L :
        DualDeMorganLang ->
        DualDeMorganLang ->
        DualDeMorganLang
      +L :
        DualDeMorganLang ->
        DualDeMorganLang ->
        DualDeMorganLang
      primL :
        DualDeMorganLang ->
        DualDeMorganLang
    data DualDeMorganOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> DualDeMorganOpenLang n
      *OL :
        DualDeMorganOpenLang n ->
        DualDeMorganOpenLang n ->
        DualDeMorganOpenLang n
      +OL :
        DualDeMorganOpenLang n ->
        DualDeMorganOpenLang n ->
        DualDeMorganOpenLang n
      primOL :
        DualDeMorganOpenLang n ->
        DualDeMorganOpenLang n
    evalTerm :
      (A : Set) ->
      DualDeMorgan A ->
      DualDeMorganLang -> A
    evalTerm _ Du (*L x1 x2) =
      * Du (evalTerm _ Du x1)
        (evalTerm _ Du x2)
    evalTerm _ Du (+L x1 x2) =
      + Du (evalTerm _ Du x1)
        (evalTerm _ Du x2)
    evalTerm _ Du (primL x1) =
      prim Du (evalTerm _ Du x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      DualDeMorgan A ->
      DualDeMorganOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n du (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n du (*OL
                         x1
                         x2) vars =
      * du
        (evalOpenTerm _ n du x1 vars)
        (evalOpenTerm _ n du x2 vars)
    evalOpenTerm _ n du (+OL
                         x1
                         x2) vars =
      + du
        (evalOpenTerm _ n du x1 vars)
        (evalOpenTerm _ n du x2 vars)
    evalOpenTerm _ n du (primOL
                         x1) vars =
      prim du
        (evalOpenTerm _ n du x1 vars)
    simplify :
      DualDeMorganLang ->
      DualDeMorganLang
    simplify (+L
              (primL x)
              (primL y)) = primL (*L x y)
    simplify (*L
              (primL x)
              (primL y)) = primL (+L x y)
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (primL x1) =
      primL (simplify x1)
    liftDualDeMorganLang :
      DualDeMorganLang ->
      Staged DualDeMorganLang
    liftDualDeMorganLang x = Now x
    *OL' :
      (n : Nat) ->
      DualDeMorganOpenLang n ->
      DualDeMorganOpenLang n ->
      DualDeMorganOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      DualDeMorganOpenLang n ->
      DualDeMorganOpenLang n ->
      DualDeMorganOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    primOL' :
      (n : Nat) ->
      DualDeMorganOpenLang n ->
      DualDeMorganOpenLang n
    primOL' _ x1 = primOL x1
    liftDualDeMorganOpenLang :
      (n : Nat) ->
      DualDeMorganOpenLang n ->
      Staged (DualDeMorganOpenLang n)
    liftDualDeMorganOpenLang _ (v
                                fin) = const _ (code _ (v fin))
    liftDualDeMorganOpenLang _ (*OL
                                x1
                                x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftDualDeMorganOpenLang _ x1)
        (liftDualDeMorganOpenLang _ x2)
    liftDualDeMorganOpenLang _ (+OL
                                x1
                                x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftDualDeMorganOpenLang _ x1)
        (liftDualDeMorganOpenLang _ x2)
    liftDualDeMorganOpenLang _ (primOL
                                x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftDualDeMorganOpenLang _ x1)
  
  module DualSemilattices where
    record DualSemilattices
      (A : Set) : Set where
      constructor DualSemilatticesC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
    record DualSemilatticesSig
      (AS : Set) : Set where
      constructor DualSemilatticesSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record DualSemilatticesProd
      (AP : Set) : Set where
      constructor DualSemilatticesProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record DualSemilatticesHom
      (A1 : Set) (A2 : Set)
      (Du1 : DualSemilattices A1)
      (Du2 : DualSemilattices A2) :
      Set where
      constructor DualSemilatticesHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Du1 x1 x2) ==
            * Du2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Du1 x1 x2) ==
            + Du2 (hom x1) (hom x2)
    record DualSemilatticesRelInterp
      (A1 : Set) (A2 : Set)
      (Du1 : DualSemilattices A1)
      (Du2 : DualSemilattices A2) :
      Set where
      constructor DualSemilatticesRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Du1 x1 x2)
            (* Du2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Du1 x1 x2)
            (+ Du2 y1 y2)
    data DualSemilatticesLang
      : Set where
      *L :
        DualSemilatticesLang ->
        DualSemilatticesLang ->
        DualSemilatticesLang
      +L :
        DualSemilatticesLang ->
        DualSemilatticesLang ->
        DualSemilatticesLang
    data DualSemilatticesOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        DualSemilatticesOpenLang n
      *OL :
        DualSemilatticesOpenLang n ->
        DualSemilatticesOpenLang n ->
        DualSemilatticesOpenLang n
      +OL :
        DualSemilatticesOpenLang n ->
        DualSemilatticesOpenLang n ->
        DualSemilatticesOpenLang n
    evalTerm :
      (A : Set) ->
      DualSemilattices A ->
      DualSemilatticesLang -> A
    evalTerm _ Du (*L x1 x2) =
      * Du (evalTerm _ Du x1)
        (evalTerm _ Du x2)
    evalTerm _ Du (+L x1 x2) =
      + Du (evalTerm _ Du x1)
        (evalTerm _ Du x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      DualSemilattices A ->
      DualSemilatticesOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n du (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n du (*OL
                         x1
                         x2) vars =
      * du
        (evalOpenTerm _ n du x1 vars)
        (evalOpenTerm _ n du x2 vars)
    evalOpenTerm _ n du (+OL
                         x1
                         x2) vars =
      + du
        (evalOpenTerm _ n du x1 vars)
        (evalOpenTerm _ n du x2 vars)
    simplify :
      DualSemilatticesLang ->
      DualSemilatticesLang
    simplify (*L x x) = x
    simplify (+L x x) = x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftDualSemilatticesLang :
      DualSemilatticesLang ->
      Staged DualSemilatticesLang
    liftDualSemilatticesLang x =
      Now x
    *OL' :
      (n : Nat) ->
      DualSemilatticesOpenLang n ->
      DualSemilatticesOpenLang n ->
      DualSemilatticesOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      DualSemilatticesOpenLang n ->
      DualSemilatticesOpenLang n ->
      DualSemilatticesOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftDualSemilatticesOpenLang :
      (n : Nat) ->
      DualSemilatticesOpenLang n ->
      Staged
        (DualSemilatticesOpenLang n)
    liftDualSemilatticesOpenLang _ (v
                                    fin) = const _ (code _ (v fin))
    liftDualSemilatticesOpenLang _ (*OL
                                    x1
                                    x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftDualSemilatticesOpenLang _
           x1)
        (liftDualSemilatticesOpenLang _
           x2)
    liftDualSemilatticesOpenLang _ (+OL
                                    x1
                                    x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftDualSemilatticesOpenLang _
           x1)
        (liftDualSemilatticesOpenLang _
           x2)
  
  module Empty where
    record Empty : Set where
      constructor EmptyC
      field
        
  
  module FixedPoint where
    record FixedPoint
      (A : Set) : Set where
      constructor FixedPointC
      field
        prim : A -> A
        e : A
        fixes_prim_e : prim e == e
    record FixedPointSig
      (AS : Set) : Set where
      constructor FixedPointSigSigC
      field
        primS : AS -> AS
        eS : AS
    record FixedPointProd
      (AP : Set) : Set where
      constructor FixedPointProdC
      field
        primP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        fixes_prim_eP : primP eP == eP
    record FixedPointHom
      (A1 : Set) (A2 : Set)
      (Fi1 : FixedPoint A1)
      (Fi2 : FixedPoint A2) :
      Set where
      constructor FixedPointHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Fi1 x1) ==
            prim Fi2 (hom x1)
        pres-e : hom (e Fi1) == e Fi2
    record FixedPointRelInterp
      (A1 : Set) (A2 : Set)
      (Fi1 : FixedPoint A1)
      (Fi2 : FixedPoint A2) :
      Set where
      constructor FixedPointRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Fi1 x1)
            (prim Fi2 y1)
        interp-e :
          interp (e Fi1) (e Fi2)
    data FixedPointLang : Set where
      primL :
        FixedPointLang -> FixedPointLang
      eL : FixedPointLang
    data FixedPointOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> FixedPointOpenLang n
      primOL :
        FixedPointOpenLang n ->
        FixedPointOpenLang n
      eOL : FixedPointOpenLang n
    evalTerm :
      (A : Set) ->
      FixedPoint A ->
      FixedPointLang -> A
    evalTerm _ Fi (primL x1) =
      prim Fi (evalTerm _ Fi x1)
    evalTerm _ Fi (eL) = e Fi
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      FixedPoint A ->
      FixedPointOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n fi (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n fi (primOL
                         x1) vars =
      prim fi
        (evalOpenTerm _ n fi x1 vars)
    evalOpenTerm _ n fi (eOL) vars =
      e fi
    simplify :
      FixedPointLang -> FixedPointLang
    simplify (primL (eL)) = eL
    simplify (primL x1) =
      primL (simplify x1)
    simplify (eL) = eL
    liftFixedPointLang :
      FixedPointLang ->
      Staged FixedPointLang
    liftFixedPointLang x = Now x
    primOL' :
      (n : Nat) ->
      FixedPointOpenLang n ->
      FixedPointOpenLang n
    primOL' _ x1 = primOL x1
    eOL' :
      (n : Nat) ->
      FixedPointOpenLang n
    eOL' _ = eOL
    liftFixedPointOpenLang :
      (n : Nat) ->
      FixedPointOpenLang n ->
      Staged (FixedPointOpenLang n)
    liftFixedPointOpenLang _ (v
                              fin) = const _ (code _ (v fin))
    liftFixedPointOpenLang _ (primOL
                              x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftFixedPointOpenLang _ x1)
    liftFixedPointOpenLang _ (eOL) =
      Now eOL
  
  module Group where
    record Group
      (A : Set) : Set where
      constructor GroupC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        inv : A -> A
        leftInverse_inv_op_e :
          (x : A) -> op x (inv x) == e
        rightInverse_inv_op_e :
          (x : A) -> op (inv x) x == e
    record GroupSig
      (AS : Set) : Set where
      constructor GroupSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
        invS : AS -> AS
    record GroupProd
      (AP : Set) : Set where
      constructor GroupProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP xP (invP xP) == eP
        rightInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (invP xP) xP == eP
    record GroupHom
      (A1 : Set) (A2 : Set)
      (Gr1 : Group A1)
      (Gr2 : Group A2) : Set where
      constructor GroupHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Gr1) == e Gr2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Gr1 x1 x2) ==
            op Gr2 (hom x1) (hom x2)
        pres-inv :
          (x1 : A1) ->
          hom (inv Gr1 x1) ==
            inv Gr2 (hom x1)
    record GroupRelInterp
      (A1 : Set) (A2 : Set)
      (Gr1 : Group A1)
      (Gr2 : Group A2) : Set where
      constructor GroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Gr1) (e Gr2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Gr1 x1 x2)
            (op Gr2 y1 y2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Gr1 x1) (inv Gr2 y1)
    data GroupLang : Set where
      eL : GroupLang
      opL :
        GroupLang ->
        GroupLang -> GroupLang
      invL : GroupLang -> GroupLang
    data GroupOpenLang
      (n : Nat) : Set where
      v : Fin n -> GroupOpenLang n
      eOL : GroupOpenLang n
      opOL :
        GroupOpenLang n ->
        GroupOpenLang n ->
        GroupOpenLang n
      invOL :
        GroupOpenLang n ->
        GroupOpenLang n
    evalTerm :
      (A : Set) ->
      Group A -> GroupLang -> A
    evalTerm _ Gr (eL) = e Gr
    evalTerm _ Gr (opL x1 x2) =
      op Gr (evalTerm _ Gr x1)
        (evalTerm _ Gr x2)
    evalTerm _ Gr (invL x1) =
      inv Gr (evalTerm _ Gr x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Group A ->
      GroupOpenLang n -> Vec A n -> A
    evalOpenTerm _ n gr (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n gr (eOL) vars =
      e gr
    evalOpenTerm _ n gr (opOL
                         x1
                         x2) vars =
      op gr
        (evalOpenTerm _ n gr x1 vars)
        (evalOpenTerm _ n gr x2 vars)
    evalOpenTerm _ n gr (invOL
                         x1) vars =
      inv gr
        (evalOpenTerm _ n gr x1 vars)
    simplify :
      GroupLang -> GroupLang
    simplify (opL (eL) x) = x
    simplify (opL x (eL)) = x
    simplify (opL x (invL x)) = eL
    simplify (opL (invL x) x) = eL
    simplify (eL) = eL
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (invL x1) =
      invL (simplify x1)
    liftGroupLang :
      GroupLang -> Staged GroupLang
    liftGroupLang x = Now x
    eOL' :
      (n : Nat) -> GroupOpenLang n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      GroupOpenLang n ->
      GroupOpenLang n ->
      GroupOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    invOL' :
      (n : Nat) ->
      GroupOpenLang n ->
      GroupOpenLang n
    invOL' _ x1 = invOL x1
    liftGroupOpenLang :
      (n : Nat) ->
      GroupOpenLang n ->
      Staged (GroupOpenLang n)
    liftGroupOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftGroupOpenLang _ (eOL) =
      Now eOL
    liftGroupOpenLang _ (opOL
                         x1
                         x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftGroupOpenLang _ x1)
        (liftGroupOpenLang _ x2)
    liftGroupOpenLang _ (invOL x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (liftGroupOpenLang _ x1)
  
  module Group1 where
    record Group1
      (A : Set) : Set where
      constructor Group1C
      field
        1 : A
        op : A -> A -> A
        lunit_1 : (x : A) -> op 1 x == x
        runit_1 : (x : A) -> op x 1 == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        inv : A -> A
        leftInverse_inv_op_1 :
          (x : A) -> op x (inv x) == 1
        rightInverse_inv_op_1 :
          (x : A) -> op (inv x) x == 1
    record Group1Sig
      (AS : Set) : Set where
      constructor Group1SigSigC
      field
        1S : AS
        opS : AS -> AS -> AS
        invS : AS -> AS
    record Group1Prod
      (AP : Set) : Set where
      constructor Group1ProdC
      field
        1P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          opP 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          opP xP 1P == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          opP xP (invP xP) == 1P
        rightInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          opP (invP xP) xP == 1P
    record Group1Hom
      (A1 : Set) (A2 : Set)
      (Gr1 : Group1 A1)
      (Gr2 : Group1 A2) : Set where
      constructor Group1HomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Gr1) == 1 Gr2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Gr1 x1 x2) ==
            op Gr2 (hom x1) (hom x2)
        pres-inv :
          (x1 : A1) ->
          hom (inv Gr1 x1) ==
            inv Gr2 (hom x1)
    record Group1RelInterp
      (A1 : Set) (A2 : Set)
      (Gr1 : Group1 A1)
      (Gr2 : Group1 A2) : Set where
      constructor Group1RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Gr1) (1 Gr2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Gr1 x1 x2)
            (op Gr2 y1 y2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Gr1 x1) (inv Gr2 y1)
    data Group1Lang : Set where
      1L : Group1Lang
      opL :
        Group1Lang ->
        Group1Lang -> Group1Lang
      invL : Group1Lang -> Group1Lang
    data Group1OpenLang
      (n : Nat) : Set where
      v : Fin n -> Group1OpenLang n
      1OL : Group1OpenLang n
      opOL :
        Group1OpenLang n ->
        Group1OpenLang n ->
        Group1OpenLang n
      invOL :
        Group1OpenLang n ->
        Group1OpenLang n
    evalTerm :
      (A : Set) ->
      Group1 A -> Group1Lang -> A
    evalTerm _ Gr (1L) = 1 Gr
    evalTerm _ Gr (opL x1 x2) =
      op Gr (evalTerm _ Gr x1)
        (evalTerm _ Gr x2)
    evalTerm _ Gr (invL x1) =
      inv Gr (evalTerm _ Gr x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Group1 A ->
      Group1OpenLang n -> Vec A n -> A
    evalOpenTerm _ n gr (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n gr (1OL) vars =
      1 gr
    evalOpenTerm _ n gr (opOL
                         x1
                         x2) vars =
      op gr
        (evalOpenTerm _ n gr x1 vars)
        (evalOpenTerm _ n gr x2 vars)
    evalOpenTerm _ n gr (invOL
                         x1) vars =
      inv gr
        (evalOpenTerm _ n gr x1 vars)
    simplify :
      Group1Lang -> Group1Lang
    simplify (opL (1L) x) = x
    simplify (opL x (1L)) = x
    simplify (opL x (invL x)) = 1L
    simplify (opL (invL x) x) = 1L
    simplify (1L) = 1L
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (invL x1) =
      invL (simplify x1)
    liftGroup1Lang :
      Group1Lang -> Staged Group1Lang
    liftGroup1Lang x = Now x
    1OL' :
      (n : Nat) -> Group1OpenLang n
    1OL' _ = 1OL
    opOL' :
      (n : Nat) ->
      Group1OpenLang n ->
      Group1OpenLang n ->
      Group1OpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    invOL' :
      (n : Nat) ->
      Group1OpenLang n ->
      Group1OpenLang n
    invOL' _ x1 = invOL x1
    liftGroup1OpenLang :
      (n : Nat) ->
      Group1OpenLang n ->
      Staged (Group1OpenLang n)
    liftGroup1OpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftGroup1OpenLang _ (1OL) =
      Now 1OL
    liftGroup1OpenLang _ (opOL
                          x1
                          x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftGroup1OpenLang _ x1)
        (liftGroup1OpenLang _ x2)
    liftGroup1OpenLang _ (invOL
                          x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (liftGroup1OpenLang _ x1)
  
  module IdempotentAdditiveMagma where
    record IdempotentAdditiveMagma
      (A : Set) : Set where
      constructor IdempotentAdditiveMagmaC
      field
        + : A -> A -> A
        idempotent_+ :
          (x : A) -> + x x == x
    record IdempotentAdditiveMagmaSig
      (AS : Set) : Set where
      constructor IdempotentAdditiveMagmaSigSigC
      field
        +S : AS -> AS -> AS
    record IdempotentAdditiveMagmaProd
      (AP : Set) : Set where
      constructor IdempotentAdditiveMagmaProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record IdempotentAdditiveMagmaHom
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentAdditiveMagma
         A1)
      (Id2 : IdempotentAdditiveMagma
         A2) : Set where
      constructor IdempotentAdditiveMagmaHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Id1 x1 x2) ==
            + Id2 (hom x1) (hom x2)
    record IdempotentAdditiveMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentAdditiveMagma
         A1)
      (Id2 : IdempotentAdditiveMagma
         A2) : Set where
      constructor IdempotentAdditiveMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Id1 x1 x2)
            (+ Id2 y1 y2)
    data IdempotentAdditiveMagmaLang
      : Set where
      +L :
        IdempotentAdditiveMagmaLang ->
        IdempotentAdditiveMagmaLang ->
        IdempotentAdditiveMagmaLang
    data IdempotentAdditiveMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        IdempotentAdditiveMagmaOpenLang
          n
      +OL :
        IdempotentAdditiveMagmaOpenLang
          n ->
        IdempotentAdditiveMagmaOpenLang
          n ->
        IdempotentAdditiveMagmaOpenLang
          n
    evalTerm :
      (A : Set) ->
      IdempotentAdditiveMagma A ->
      IdempotentAdditiveMagmaLang -> A
    evalTerm _ Id (+L x1 x2) =
      + Id (evalTerm _ Id x1)
        (evalTerm _ Id x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      IdempotentAdditiveMagma A ->
      IdempotentAdditiveMagmaOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n id (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n id (+OL
                         x1
                         x2) vars =
      + id
        (evalOpenTerm _ n id x1 vars)
        (evalOpenTerm _ n id x2 vars)
    simplify :
      IdempotentAdditiveMagmaLang ->
      IdempotentAdditiveMagmaLang
    simplify (+L x x) = x
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftIdempotentAdditiveMagmaLang :
      IdempotentAdditiveMagmaLang ->
      Staged
        IdempotentAdditiveMagmaLang
    liftIdempotentAdditiveMagmaLang x =
      Now x
    +OL' :
      (n : Nat) ->
      IdempotentAdditiveMagmaOpenLang
        n ->
      IdempotentAdditiveMagmaOpenLang
        n ->
      IdempotentAdditiveMagmaOpenLang
        n
    +OL' _ x1 x2 = +OL x1 x2
    liftIdempotentAdditiveMagmaOpenLang :
      (n : Nat) ->
      IdempotentAdditiveMagmaOpenLang
        n ->
      Staged
        (IdempotentAdditiveMagmaOpenLang
           n)
    liftIdempotentAdditiveMagmaOpenLang _ (v
                                           fin) = const _ (code _ (v fin))
    liftIdempotentAdditiveMagmaOpenLang _ (+OL
                                           x1
                                           x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftIdempotentAdditiveMagmaOpenLang
           _
           x1)
        (liftIdempotentAdditiveMagmaOpenLang
           _
           x2)
  
  module IdempotentMagma where
    record IdempotentMagma
      (A : Set) : Set where
      constructor IdempotentMagmaC
      field
        op : A -> A -> A
        idempotent_op :
          (x : A) -> op x x == x
    record IdempotentMagmaSig
      (AS : Set) : Set where
      constructor IdempotentMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record IdempotentMagmaProd
      (AP : Set) : Set where
      constructor IdempotentMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        idempotent_opP :
          (xP : Prod AP AP) ->
          opP xP xP == xP
    record IdempotentMagmaHom
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentMagma A1)
      (Id2 : IdempotentMagma A2) :
      Set where
      constructor IdempotentMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Id1 x1 x2) ==
            op Id2 (hom x1) (hom x2)
    record IdempotentMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentMagma A1)
      (Id2 : IdempotentMagma A2) :
      Set where
      constructor IdempotentMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Id1 x1 x2)
            (op Id2 y1 y2)
    data IdempotentMagmaLang
      : Set where
      opL :
        IdempotentMagmaLang ->
        IdempotentMagmaLang ->
        IdempotentMagmaLang
    data IdempotentMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        IdempotentMagmaOpenLang n
      opOL :
        IdempotentMagmaOpenLang n ->
        IdempotentMagmaOpenLang n ->
        IdempotentMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      IdempotentMagma A ->
      IdempotentMagmaLang -> A
    evalTerm _ Id (opL x1 x2) =
      op Id (evalTerm _ Id x1)
        (evalTerm _ Id x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      IdempotentMagma A ->
      IdempotentMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n id (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n id (opOL
                         x1
                         x2) vars =
      op id
        (evalOpenTerm _ n id x1 vars)
        (evalOpenTerm _ n id x2 vars)
    simplify :
      IdempotentMagmaLang ->
      IdempotentMagmaLang
    simplify (opL x x) = x
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftIdempotentMagmaLang :
      IdempotentMagmaLang ->
      Staged IdempotentMagmaLang
    liftIdempotentMagmaLang x =
      Now x
    opOL' :
      (n : Nat) ->
      IdempotentMagmaOpenLang n ->
      IdempotentMagmaOpenLang n ->
      IdempotentMagmaOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftIdempotentMagmaOpenLang :
      (n : Nat) ->
      IdempotentMagmaOpenLang n ->
      Staged
        (IdempotentMagmaOpenLang n)
    liftIdempotentMagmaOpenLang _ (v
                                   fin) = const _ (code _ (v fin))
    liftIdempotentMagmaOpenLang _ (opOL
                                   x1
                                   x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftIdempotentMagmaOpenLang _
           x1)
        (liftIdempotentMagmaOpenLang _
           x2)
  
  module IdempotentMultMagma where
    record IdempotentMultMagma
      (A : Set) : Set where
      constructor IdempotentMultMagmaC
      field
        * : A -> A -> A
        idempotent_* :
          (x : A) -> * x x == x
    record IdempotentMultMagmaSig
      (AS : Set) : Set where
      constructor IdempotentMultMagmaSigSigC
      field
        *S : AS -> AS -> AS
    record IdempotentMultMagmaProd
      (AP : Set) : Set where
      constructor IdempotentMultMagmaProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
    record IdempotentMultMagmaHom
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentMultMagma A1)
      (Id2 : IdempotentMultMagma A2) :
      Set where
      constructor IdempotentMultMagmaHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Id1 x1 x2) ==
            * Id2 (hom x1) (hom x2)
    record IdempotentMultMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentMultMagma A1)
      (Id2 : IdempotentMultMagma A2) :
      Set where
      constructor IdempotentMultMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Id1 x1 x2)
            (* Id2 y1 y2)
    data IdempotentMultMagmaLang
      : Set where
      *L :
        IdempotentMultMagmaLang ->
        IdempotentMultMagmaLang ->
        IdempotentMultMagmaLang
    data IdempotentMultMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        IdempotentMultMagmaOpenLang n
      *OL :
        IdempotentMultMagmaOpenLang n ->
        IdempotentMultMagmaOpenLang n ->
        IdempotentMultMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      IdempotentMultMagma A ->
      IdempotentMultMagmaLang -> A
    evalTerm _ Id (*L x1 x2) =
      * Id (evalTerm _ Id x1)
        (evalTerm _ Id x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      IdempotentMultMagma A ->
      IdempotentMultMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n id (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n id (*OL
                         x1
                         x2) vars =
      * id
        (evalOpenTerm _ n id x1 vars)
        (evalOpenTerm _ n id x2 vars)
    simplify :
      IdempotentMultMagmaLang ->
      IdempotentMultMagmaLang
    simplify (*L x x) = x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    liftIdempotentMultMagmaLang :
      IdempotentMultMagmaLang ->
      Staged IdempotentMultMagmaLang
    liftIdempotentMultMagmaLang x =
      Now x
    *OL' :
      (n : Nat) ->
      IdempotentMultMagmaOpenLang n ->
      IdempotentMultMagmaOpenLang n ->
      IdempotentMultMagmaOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    liftIdempotentMultMagmaOpenLang :
      (n : Nat) ->
      IdempotentMultMagmaOpenLang n ->
      Staged
        (IdempotentMultMagmaOpenLang n)
    liftIdempotentMultMagmaOpenLang _ (v
                                       fin) = const _ (code _ (v fin))
    liftIdempotentMultMagmaOpenLang _ (*OL
                                       x1
                                       x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftIdempotentMultMagmaOpenLang
           _
           x1)
        (liftIdempotentMultMagmaOpenLang
           _
           x2)
  
  module IdempotentSemiRng where
    record IdempotentSemiRng
      (A : Set) : Set where
      constructor IdempotentSemiRngC
      field
        + : A -> A -> A
        * : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        idempotent_+ :
          (x : A) -> + x x == x
    record IdempotentSemiRngSig
      (AS : Set) : Set where
      constructor IdempotentSemiRngSigSigC
      field
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
        0S : AS
    record IdempotentSemiRngProd
      (AP : Set) : Set where
      constructor IdempotentSemiRngProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record IdempotentSemiRngHom
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentSemiRng A1)
      (Id2 : IdempotentSemiRng A2) :
      Set where
      constructor IdempotentSemiRngHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Id1 x1 x2) ==
            + Id2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Id1 x1 x2) ==
            * Id2 (hom x1) (hom x2)
        pres-0 : hom (0 Id1) == 0 Id2
    record IdempotentSemiRngRelInterp
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentSemiRng A1)
      (Id2 : IdempotentSemiRng A2) :
      Set where
      constructor IdempotentSemiRngRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Id1 x1 x2)
            (+ Id2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Id1 x1 x2)
            (* Id2 y1 y2)
        interp-0 :
          interp (0 Id1) (0 Id2)
    data IdempotentSemiRngLang
      : Set where
      +L :
        IdempotentSemiRngLang ->
        IdempotentSemiRngLang ->
        IdempotentSemiRngLang
      *L :
        IdempotentSemiRngLang ->
        IdempotentSemiRngLang ->
        IdempotentSemiRngLang
      0L : IdempotentSemiRngLang
    data IdempotentSemiRngOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        IdempotentSemiRngOpenLang n
      +OL :
        IdempotentSemiRngOpenLang n ->
        IdempotentSemiRngOpenLang n ->
        IdempotentSemiRngOpenLang n
      *OL :
        IdempotentSemiRngOpenLang n ->
        IdempotentSemiRngOpenLang n ->
        IdempotentSemiRngOpenLang n
      0OL :
        IdempotentSemiRngOpenLang n
    evalTerm :
      (A : Set) ->
      IdempotentSemiRng A ->
      IdempotentSemiRngLang -> A
    evalTerm _ Id (+L x1 x2) =
      + Id (evalTerm _ Id x1)
        (evalTerm _ Id x2)
    evalTerm _ Id (*L x1 x2) =
      * Id (evalTerm _ Id x1)
        (evalTerm _ Id x2)
    evalTerm _ Id (0L) = 0 Id
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      IdempotentSemiRng A ->
      IdempotentSemiRngOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n id (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n id (+OL
                         x1
                         x2) vars =
      + id
        (evalOpenTerm _ n id x1 vars)
        (evalOpenTerm _ n id x2 vars)
    evalOpenTerm _ n id (*OL
                         x1
                         x2) vars =
      * id
        (evalOpenTerm _ n id x1 vars)
        (evalOpenTerm _ n id x2 vars)
    evalOpenTerm _ n id (0OL) vars =
      0 id
    simplify :
      IdempotentSemiRngLang ->
      IdempotentSemiRngLang
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (+L
              (*L x y)
              (*L x z)) = *L x (+L y z)
    simplify (+L
              (*L y x)
              (*L z x)) = *L (+L y z) x
    simplify (+L x x) = x
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (0L) = 0L
    liftIdempotentSemiRngLang :
      IdempotentSemiRngLang ->
      Staged IdempotentSemiRngLang
    liftIdempotentSemiRngLang x =
      Now x
    +OL' :
      (n : Nat) ->
      IdempotentSemiRngOpenLang n ->
      IdempotentSemiRngOpenLang n ->
      IdempotentSemiRngOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    *OL' :
      (n : Nat) ->
      IdempotentSemiRngOpenLang n ->
      IdempotentSemiRngOpenLang n ->
      IdempotentSemiRngOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    0OL' :
      (n : Nat) ->
      IdempotentSemiRngOpenLang n
    0OL' _ = 0OL
    liftIdempotentSemiRngOpenLang :
      (n : Nat) ->
      IdempotentSemiRngOpenLang n ->
      Staged
        (IdempotentSemiRngOpenLang n)
    liftIdempotentSemiRngOpenLang _ (v
                                     fin) = const _ (code _ (v fin))
    liftIdempotentSemiRngOpenLang _ (+OL
                                     x1
                                     x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftIdempotentSemiRngOpenLang _
           x1)
        (liftIdempotentSemiRngOpenLang _
           x2)
    liftIdempotentSemiRngOpenLang _ (*OL
                                     x1
                                     x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftIdempotentSemiRngOpenLang _
           x1)
        (liftIdempotentSemiRngOpenLang _
           x2)
    liftIdempotentSemiRngOpenLang _ (0OL) =
      Now 0OL
  
  module IdempotentSemiring where
    record IdempotentSemiring
      (A : Set) : Set where
      constructor IdempotentSemiringC
      field
        + : A -> A -> A
        0 : A
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
        idempotent_+ :
          (x : A) -> + x x == x
    record IdempotentSemiringSig
      (AS : Set) : Set where
      constructor IdempotentSemiringSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
        *S : AS -> AS -> AS
        1S : AS
    record IdempotentSemiringProd
      (AP : Set) : Set where
      constructor IdempotentSemiringProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record IdempotentSemiringHom
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentSemiring A1)
      (Id2 : IdempotentSemiring A2) :
      Set where
      constructor IdempotentSemiringHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Id1 x1 x2) ==
            + Id2 (hom x1) (hom x2)
        pres-0 : hom (0 Id1) == 0 Id2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Id1 x1 x2) ==
            * Id2 (hom x1) (hom x2)
        pres-1 : hom (1 Id1) == 1 Id2
    record IdempotentSemiringRelInterp
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentSemiring A1)
      (Id2 : IdempotentSemiring A2) :
      Set where
      constructor IdempotentSemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Id1 x1 x2)
            (+ Id2 y1 y2)
        interp-0 :
          interp (0 Id1) (0 Id2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Id1 x1 x2)
            (* Id2 y1 y2)
        interp-1 :
          interp (1 Id1) (1 Id2)
    data IdempotentSemiringLang
      : Set where
      +L :
        IdempotentSemiringLang ->
        IdempotentSemiringLang ->
        IdempotentSemiringLang
      0L : IdempotentSemiringLang
      *L :
        IdempotentSemiringLang ->
        IdempotentSemiringLang ->
        IdempotentSemiringLang
      1L : IdempotentSemiringLang
    data IdempotentSemiringOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        IdempotentSemiringOpenLang n
      +OL :
        IdempotentSemiringOpenLang n ->
        IdempotentSemiringOpenLang n ->
        IdempotentSemiringOpenLang n
      0OL :
        IdempotentSemiringOpenLang n
      *OL :
        IdempotentSemiringOpenLang n ->
        IdempotentSemiringOpenLang n ->
        IdempotentSemiringOpenLang n
      1OL :
        IdempotentSemiringOpenLang n
    evalTerm :
      (A : Set) ->
      IdempotentSemiring A ->
      IdempotentSemiringLang -> A
    evalTerm _ Id (+L x1 x2) =
      + Id (evalTerm _ Id x1)
        (evalTerm _ Id x2)
    evalTerm _ Id (0L) = 0 Id
    evalTerm _ Id (*L x1 x2) =
      * Id (evalTerm _ Id x1)
        (evalTerm _ Id x2)
    evalTerm _ Id (1L) = 1 Id
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      IdempotentSemiring A ->
      IdempotentSemiringOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n id (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n id (+OL
                         x1
                         x2) vars =
      + id
        (evalOpenTerm _ n id x1 vars)
        (evalOpenTerm _ n id x2 vars)
    evalOpenTerm _ n id (0OL) vars =
      0 id
    evalOpenTerm _ n id (*OL
                         x1
                         x2) vars =
      * id
        (evalOpenTerm _ n id x1 vars)
        (evalOpenTerm _ n id x2 vars)
    evalOpenTerm _ n id (1OL) vars =
      1 id
    simplify :
      IdempotentSemiringLang ->
      IdempotentSemiringLang
    simplify (*L (1L) x) = x
    simplify (*L x (1L)) = x
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (+L
              (*L x y)
              (*L x z)) = *L x (+L y z)
    simplify (+L
              (*L y x)
              (*L z x)) = *L (+L y z) x
    simplify (*L (0L) x) = 0L
    simplify (*L x (0L)) = 0L
    simplify (+L x x) = x
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (0L) = 0L
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (1L) = 1L
    liftIdempotentSemiringLang :
      IdempotentSemiringLang ->
      Staged IdempotentSemiringLang
    liftIdempotentSemiringLang x =
      Now x
    +OL' :
      (n : Nat) ->
      IdempotentSemiringOpenLang n ->
      IdempotentSemiringOpenLang n ->
      IdempotentSemiringOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      IdempotentSemiringOpenLang n
    0OL' _ = 0OL
    *OL' :
      (n : Nat) ->
      IdempotentSemiringOpenLang n ->
      IdempotentSemiringOpenLang n ->
      IdempotentSemiringOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    1OL' :
      (n : Nat) ->
      IdempotentSemiringOpenLang n
    1OL' _ = 1OL
    liftIdempotentSemiringOpenLang :
      (n : Nat) ->
      IdempotentSemiringOpenLang n ->
      Staged
        (IdempotentSemiringOpenLang n)
    liftIdempotentSemiringOpenLang _ (v
                                      fin) = const _ (code _ (v fin))
    liftIdempotentSemiringOpenLang _ (+OL
                                      x1
                                      x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftIdempotentSemiringOpenLang
           _
           x1)
        (liftIdempotentSemiringOpenLang
           _
           x2)
    liftIdempotentSemiringOpenLang _ (0OL) =
      Now 0OL
    liftIdempotentSemiringOpenLang _ (*OL
                                      x1
                                      x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftIdempotentSemiringOpenLang
           _
           x1)
        (liftIdempotentSemiringOpenLang
           _
           x2)
    liftIdempotentSemiringOpenLang _ (1OL) =
      Now 1OL
  
  module IdempotentUnary where
    record IdempotentUnary
      (A : Set) : Set where
      constructor IdempotentUnaryC
      field
        prim : A -> A
        idempotent_prim :
          (x : A) ->
          prim (prim x) == prim x
    record IdempotentUnarySig
      (AS : Set) : Set where
      constructor IdempotentUnarySigSigC
      field
        primS : AS -> AS
    record IdempotentUnaryProd
      (AP : Set) : Set where
      constructor IdempotentUnaryProdC
      field
        primP : Prod AP AP -> Prod AP AP
        idempotent_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == primP xP
    record IdempotentUnaryHom
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentUnary A1)
      (Id2 : IdempotentUnary A2) :
      Set where
      constructor IdempotentUnaryHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Id1 x1) ==
            prim Id2 (hom x1)
    record IdempotentUnaryRelInterp
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentUnary A1)
      (Id2 : IdempotentUnary A2) :
      Set where
      constructor IdempotentUnaryRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Id1 x1)
            (prim Id2 y1)
    data IdempotentUnaryLang
      : Set where
      primL :
        IdempotentUnaryLang ->
        IdempotentUnaryLang
    data IdempotentUnaryOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        IdempotentUnaryOpenLang n
      primOL :
        IdempotentUnaryOpenLang n ->
        IdempotentUnaryOpenLang n
    evalTerm :
      (A : Set) ->
      IdempotentUnary A ->
      IdempotentUnaryLang -> A
    evalTerm _ Id (primL x1) =
      prim Id (evalTerm _ Id x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      IdempotentUnary A ->
      IdempotentUnaryOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n id (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n id (primOL
                         x1) vars =
      prim id
        (evalOpenTerm _ n id x1 vars)
    simplify :
      IdempotentUnaryLang ->
      IdempotentUnaryLang
    simplify (primL (primL x)) =
      primL x
    simplify (primL x1) =
      primL (simplify x1)
    liftIdempotentUnaryLang :
      IdempotentUnaryLang ->
      Staged IdempotentUnaryLang
    liftIdempotentUnaryLang x =
      Now x
    primOL' :
      (n : Nat) ->
      IdempotentUnaryOpenLang n ->
      IdempotentUnaryOpenLang n
    primOL' _ x1 = primOL x1
    liftIdempotentUnaryOpenLang :
      (n : Nat) ->
      IdempotentUnaryOpenLang n ->
      Staged
        (IdempotentUnaryOpenLang n)
    liftIdempotentUnaryOpenLang _ (v
                                   fin) = const _ (code _ (v fin))
    liftIdempotentUnaryOpenLang _ (primOL
                                   x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftIdempotentUnaryOpenLang _
           x1)
  
  module Inverse where
    record Inverse
      (A : Set) : Set where
      constructor InverseC
      field
        inv : A -> A
        e : A
        op : A -> A -> A
        leftInverse_inv_op_e :
          (x : A) -> op x (inv x) == e
        rightInverse_inv_op_e :
          (x : A) -> op (inv x) x == e
    record InverseSig
      (AS : Set) : Set where
      constructor InverseSigSigC
      field
        invS : AS -> AS
        eS : AS
        opS : AS -> AS -> AS
    record InverseProd
      (AP : Set) : Set where
      constructor InverseProdC
      field
        invP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP xP (invP xP) == eP
        rightInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (invP xP) xP == eP
    record InverseHom
      (A1 : Set) (A2 : Set)
      (In1 : Inverse A1)
      (In2 : Inverse A2) : Set where
      constructor InverseHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv In1 x1) ==
            inv In2 (hom x1)
        pres-e : hom (e In1) == e In2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
    record InverseRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : Inverse A1)
      (In2 : Inverse A2) : Set where
      constructor InverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv In1 x1) (inv In2 y1)
        interp-e :
          interp (e In1) (e In2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
    data InverseLang : Set where
      invL :
        InverseLang -> InverseLang
      eL : InverseLang
      opL :
        InverseLang ->
        InverseLang -> InverseLang
    data InverseOpenLang
      (n : Nat) : Set where
      v : Fin n -> InverseOpenLang n
      invOL :
        InverseOpenLang n ->
        InverseOpenLang n
      eOL : InverseOpenLang n
      opOL :
        InverseOpenLang n ->
        InverseOpenLang n ->
        InverseOpenLang n
    evalTerm :
      (A : Set) ->
      Inverse A -> InverseLang -> A
    evalTerm _ In (invL x1) =
      inv In (evalTerm _ In x1)
    evalTerm _ In (eL) = e In
    evalTerm _ In (opL x1 x2) =
      op In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Inverse A ->
      InverseOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (invOL
                         x1) vars =
      inv in
        (evalOpenTerm _ n in x1 vars)
    evalOpenTerm _ n in (eOL) vars =
      e in
    evalOpenTerm _ n in (opOL
                         x1
                         x2) vars =
      op in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    simplify :
      InverseLang -> InverseLang
    simplify (opL x (invL x)) = eL
    simplify (opL (invL x) x) = eL
    simplify (invL x1) =
      invL (simplify x1)
    simplify (eL) = eL
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftInverseLang :
      InverseLang ->
      Staged InverseLang
    liftInverseLang x = Now x
    invOL' :
      (n : Nat) ->
      InverseOpenLang n ->
      InverseOpenLang n
    invOL' _ x1 = invOL x1
    eOL' :
      (n : Nat) -> InverseOpenLang n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      InverseOpenLang n ->
      InverseOpenLang n ->
      InverseOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftInverseOpenLang :
      (n : Nat) ->
      InverseOpenLang n ->
      Staged (InverseOpenLang n)
    liftInverseOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftInverseOpenLang _ (invOL
                           x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (liftInverseOpenLang _ x1)
    liftInverseOpenLang _ (eOL) =
      Now eOL
    liftInverseOpenLang _ (opOL
                           x1
                           x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftInverseOpenLang _ x1)
        (liftInverseOpenLang _ x2)
  
  module InverseSig where
    record InverseSig
      (A : Set) : Set where
      constructor InverseSigC
      field
        inv : A -> A
        e : A
        op : A -> A -> A
    record InverseSigSig
      (AS : Set) : Set where
      constructor InverseSigSigSigC
      field
        invS : AS -> AS
        eS : AS
        opS : AS -> AS -> AS
    record InverseSigProd
      (AP : Set) : Set where
      constructor InverseSigProdC
      field
        invP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record InverseSigHom
      (A1 : Set) (A2 : Set)
      (In1 : InverseSig A1)
      (In2 : InverseSig A2) :
      Set where
      constructor InverseSigHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv In1 x1) ==
            inv In2 (hom x1)
        pres-e : hom (e In1) == e In2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
    record InverseSigRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InverseSig A1)
      (In2 : InverseSig A2) :
      Set where
      constructor InverseSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv In1 x1) (inv In2 y1)
        interp-e :
          interp (e In1) (e In2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
    data InverseSigLang : Set where
      invL :
        InverseSigLang -> InverseSigLang
      eL : InverseSigLang
      opL :
        InverseSigLang ->
        InverseSigLang -> InverseSigLang
    data InverseSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> InverseSigOpenLang n
      invOL :
        InverseSigOpenLang n ->
        InverseSigOpenLang n
      eOL : InverseSigOpenLang n
      opOL :
        InverseSigOpenLang n ->
        InverseSigOpenLang n ->
        InverseSigOpenLang n
    evalTerm :
      (A : Set) ->
      InverseSig A ->
      InverseSigLang -> A
    evalTerm _ In (invL x1) =
      inv In (evalTerm _ In x1)
    evalTerm _ In (eL) = e In
    evalTerm _ In (opL x1 x2) =
      op In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InverseSig A ->
      InverseSigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (invOL
                         x1) vars =
      inv in
        (evalOpenTerm _ n in x1 vars)
    evalOpenTerm _ n in (eOL) vars =
      e in
    evalOpenTerm _ n in (opOL
                         x1
                         x2) vars =
      op in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    simplify :
      InverseSigLang -> InverseSigLang
    simplify (invL x1) =
      invL (simplify x1)
    simplify (eL) = eL
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftInverseSigLang :
      InverseSigLang ->
      Staged InverseSigLang
    liftInverseSigLang x = Now x
    invOL' :
      (n : Nat) ->
      InverseSigOpenLang n ->
      InverseSigOpenLang n
    invOL' _ x1 = invOL x1
    eOL' :
      (n : Nat) ->
      InverseSigOpenLang n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      InverseSigOpenLang n ->
      InverseSigOpenLang n ->
      InverseSigOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftInverseSigOpenLang :
      (n : Nat) ->
      InverseSigOpenLang n ->
      Staged (InverseSigOpenLang n)
    liftInverseSigOpenLang _ (v
                              fin) = const _ (code _ (v fin))
    liftInverseSigOpenLang _ (invOL
                              x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (liftInverseSigOpenLang _ x1)
    liftInverseSigOpenLang _ (eOL) =
      Now eOL
    liftInverseSigOpenLang _ (opOL
                              x1
                              x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftInverseSigOpenLang _ x1)
        (liftInverseSigOpenLang _ x2)
  
  module InverseUnaryOperation where
    record InverseUnaryOperation
      (A : Set) : Set where
      constructor InverseUnaryOperationC
      field
        inv : A -> A
    record InverseUnaryOperationSig
      (AS : Set) : Set where
      constructor InverseUnaryOperationSigSigC
      field
        invS : AS -> AS
    record InverseUnaryOperationProd
      (AP : Set) : Set where
      constructor InverseUnaryOperationProdC
      field
        invP : Prod AP AP -> Prod AP AP
    record InverseUnaryOperationHom
      (A1 : Set) (A2 : Set)
      (In1 : InverseUnaryOperation A1)
      (In2 : InverseUnaryOperation
         A2) : Set where
      constructor InverseUnaryOperationHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv In1 x1) ==
            inv In2 (hom x1)
    record InverseUnaryOperationRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InverseUnaryOperation A1)
      (In2 : InverseUnaryOperation
         A2) : Set where
      constructor InverseUnaryOperationRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv In1 x1) (inv In2 y1)
    data InverseUnaryOperationLang
      : Set where
      invL :
        InverseUnaryOperationLang ->
        InverseUnaryOperationLang
    data InverseUnaryOperationOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InverseUnaryOperationOpenLang n
      invOL :
        InverseUnaryOperationOpenLang
          n ->
        InverseUnaryOperationOpenLang n
    evalTerm :
      (A : Set) ->
      InverseUnaryOperation A ->
      InverseUnaryOperationLang -> A
    evalTerm _ In (invL x1) =
      inv In (evalTerm _ In x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InverseUnaryOperation A ->
      InverseUnaryOperationOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (invOL
                         x1) vars =
      inv in
        (evalOpenTerm _ n in x1 vars)
    simplify :
      InverseUnaryOperationLang ->
      InverseUnaryOperationLang
    simplify (invL x1) =
      invL (simplify x1)
    liftInverseUnaryOperationLang :
      InverseUnaryOperationLang ->
      Staged InverseUnaryOperationLang
    liftInverseUnaryOperationLang x =
      Now x
    invOL' :
      (n : Nat) ->
      InverseUnaryOperationOpenLang
        n ->
      InverseUnaryOperationOpenLang n
    invOL' _ x1 = invOL x1
    liftInverseUnaryOperationOpenLang :
      (n : Nat) ->
      InverseUnaryOperationOpenLang
        n ->
      Staged
        (InverseUnaryOperationOpenLang
           n)
    liftInverseUnaryOperationOpenLang _ (v
                                         fin) = const _ (code _ (v fin))
    liftInverseUnaryOperationOpenLang _ (invOL
                                         x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (liftInverseUnaryOperationOpenLang
           _
           x1)
  
  module Involution where
    record Involution
      (A : Set) : Set where
      constructor InvolutionC
      field
        prim : A -> A
        involutive_prim :
          (x : A) -> prim (prim x) == x
    record InvolutionSig
      (AS : Set) : Set where
      constructor InvolutionSigSigC
      field
        primS : AS -> AS
    record InvolutionProd
      (AP : Set) : Set where
      constructor InvolutionProdC
      field
        primP : Prod AP AP -> Prod AP AP
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
    record InvolutionHom
      (A1 : Set) (A2 : Set)
      (In1 : Involution A1)
      (In2 : Involution A2) :
      Set where
      constructor InvolutionHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutionRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : Involution A1)
      (In2 : Involution A2) :
      Set where
      constructor InvolutionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutionLang : Set where
      primL :
        InvolutionLang -> InvolutionLang
    data InvolutionOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> InvolutionOpenLang n
      primOL :
        InvolutionOpenLang n ->
        InvolutionOpenLang n
    evalTerm :
      (A : Set) ->
      Involution A ->
      InvolutionLang -> A
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Involution A ->
      InvolutionOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
    simplify :
      InvolutionLang -> InvolutionLang
    simplify (primL (primL x)) = x
    simplify (primL x1) =
      primL (simplify x1)
    liftInvolutionLang :
      InvolutionLang ->
      Staged InvolutionLang
    liftInvolutionLang x = Now x
    primOL' :
      (n : Nat) ->
      InvolutionOpenLang n ->
      InvolutionOpenLang n
    primOL' _ x1 = primOL x1
    liftInvolutionOpenLang :
      (n : Nat) ->
      InvolutionOpenLang n ->
      Staged (InvolutionOpenLang n)
    liftInvolutionOpenLang _ (v
                              fin) = const _ (code _ (v fin))
    liftInvolutionOpenLang _ (primOL
                              x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftInvolutionOpenLang _ x1)
  
  module InvolutiveAddMagmaSig where
    record InvolutiveAddMagmaSig
      (A : Set) : Set where
      constructor InvolutiveAddMagmaSigC
      field
        + : A -> A -> A
        prim : A -> A
    record InvolutiveAddMagmaSigSig
      (AS : Set) : Set where
      constructor InvolutiveAddMagmaSigSigSigC
      field
        +S : AS -> AS -> AS
        primS : AS -> AS
    record InvolutiveAddMagmaSigProd
      (AP : Set) : Set where
      constructor InvolutiveAddMagmaSigProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
    record InvolutiveAddMagmaSigHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveAddMagmaSig A1)
      (In2 : InvolutiveAddMagmaSig
         A2) : Set where
      constructor InvolutiveAddMagmaSigHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ In1 x1 x2) ==
            + In2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutiveAddMagmaSigRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveAddMagmaSig A1)
      (In2 : InvolutiveAddMagmaSig
         A2) : Set where
      constructor InvolutiveAddMagmaSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ In1 x1 x2)
            (+ In2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutiveAddMagmaSigLang
      : Set where
      +L :
        InvolutiveAddMagmaSigLang ->
        InvolutiveAddMagmaSigLang ->
        InvolutiveAddMagmaSigLang
      primL :
        InvolutiveAddMagmaSigLang ->
        InvolutiveAddMagmaSigLang
    data InvolutiveAddMagmaSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InvolutiveAddMagmaSigOpenLang n
      +OL :
        InvolutiveAddMagmaSigOpenLang
          n ->
        InvolutiveAddMagmaSigOpenLang
          n ->
        InvolutiveAddMagmaSigOpenLang n
      primOL :
        InvolutiveAddMagmaSigOpenLang
          n ->
        InvolutiveAddMagmaSigOpenLang n
    evalTerm :
      (A : Set) ->
      InvolutiveAddMagmaSig A ->
      InvolutiveAddMagmaSigLang -> A
    evalTerm _ In (+L x1 x2) =
      + In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InvolutiveAddMagmaSig A ->
      InvolutiveAddMagmaSigOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (+OL
                         x1
                         x2) vars =
      + in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
    simplify :
      InvolutiveAddMagmaSigLang ->
      InvolutiveAddMagmaSigLang
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (primL x1) =
      primL (simplify x1)
    liftInvolutiveAddMagmaSigLang :
      InvolutiveAddMagmaSigLang ->
      Staged InvolutiveAddMagmaSigLang
    liftInvolutiveAddMagmaSigLang x =
      Now x
    +OL' :
      (n : Nat) ->
      InvolutiveAddMagmaSigOpenLang
        n ->
      InvolutiveAddMagmaSigOpenLang
        n ->
      InvolutiveAddMagmaSigOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    primOL' :
      (n : Nat) ->
      InvolutiveAddMagmaSigOpenLang
        n ->
      InvolutiveAddMagmaSigOpenLang n
    primOL' _ x1 = primOL x1
    liftInvolutiveAddMagmaSigOpenLang :
      (n : Nat) ->
      InvolutiveAddMagmaSigOpenLang
        n ->
      Staged
        (InvolutiveAddMagmaSigOpenLang
           n)
    liftInvolutiveAddMagmaSigOpenLang _ (v
                                         fin) = const _ (code _ (v fin))
    liftInvolutiveAddMagmaSigOpenLang _ (+OL
                                         x1
                                         x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftInvolutiveAddMagmaSigOpenLang
           _
           x1)
        (liftInvolutiveAddMagmaSigOpenLang
           _
           x2)
    liftInvolutiveAddMagmaSigOpenLang _ (primOL
                                         x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftInvolutiveAddMagmaSigOpenLang
           _
           x1)
  
  module InvolutiveFixedPoint where
    record InvolutiveFixedPoint
      (A : Set) : Set where
      constructor InvolutiveFixedPointC
      field
        prim : A -> A
        1 : A
        fixes_prim_1 : prim 1 == 1
        involutive_prim :
          (x : A) -> prim (prim x) == x
    record InvolutiveFixedPointSig
      (AS : Set) : Set where
      constructor InvolutiveFixedPointSigSigC
      field
        primS : AS -> AS
        1S : AS
    record InvolutiveFixedPointProd
      (AP : Set) : Set where
      constructor InvolutiveFixedPointProdC
      field
        primP : Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        fixes_prim_1P : primP 1P == 1P
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
    record InvolutiveFixedPointHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveFixedPoint A1)
      (In2 : InvolutiveFixedPoint
         A2) : Set where
      constructor InvolutiveFixedPointHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-1 : hom (1 In1) == 1 In2
    record InvolutiveFixedPointRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveFixedPoint A1)
      (In2 : InvolutiveFixedPoint
         A2) : Set where
      constructor InvolutiveFixedPointRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-1 :
          interp (1 In1) (1 In2)
    data InvolutiveFixedPointLang
      : Set where
      primL :
        InvolutiveFixedPointLang ->
        InvolutiveFixedPointLang
      1L : InvolutiveFixedPointLang
    data InvolutiveFixedPointOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InvolutiveFixedPointOpenLang n
      primOL :
        InvolutiveFixedPointOpenLang
          n ->
        InvolutiveFixedPointOpenLang n
      1OL :
        InvolutiveFixedPointOpenLang n
    evalTerm :
      (A : Set) ->
      InvolutiveFixedPoint A ->
      InvolutiveFixedPointLang -> A
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalTerm _ In (1L) = 1 In
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InvolutiveFixedPoint A ->
      InvolutiveFixedPointOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
    evalOpenTerm _ n in (1OL) vars =
      1 in
    simplify :
      InvolutiveFixedPointLang ->
      InvolutiveFixedPointLang
    simplify (primL (1L)) = 1L
    simplify (primL (primL x)) = x
    simplify (primL x1) =
      primL (simplify x1)
    simplify (1L) = 1L
    liftInvolutiveFixedPointLang :
      InvolutiveFixedPointLang ->
      Staged InvolutiveFixedPointLang
    liftInvolutiveFixedPointLang x =
      Now x
    primOL' :
      (n : Nat) ->
      InvolutiveFixedPointOpenLang
        n ->
      InvolutiveFixedPointOpenLang n
    primOL' _ x1 = primOL x1
    1OL' :
      (n : Nat) ->
      InvolutiveFixedPointOpenLang n
    1OL' _ = 1OL
    liftInvolutiveFixedPointOpenLang :
      (n : Nat) ->
      InvolutiveFixedPointOpenLang
        n ->
      Staged
        (InvolutiveFixedPointOpenLang n)
    liftInvolutiveFixedPointOpenLang _ (v
                                        fin) = const _ (code _ (v fin))
    liftInvolutiveFixedPointOpenLang _ (primOL
                                        x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftInvolutiveFixedPointOpenLang
           _
           x1)
    liftInvolutiveFixedPointOpenLang _ (1OL) =
      Now 1OL
  
  module InvolutiveFixes where
    record InvolutiveFixes
      (A : Set) : Set where
      constructor InvolutiveFixesC
      field
        1 : A
        prim : A -> A
        fixes_prim_1 : prim 1 == 1
    record InvolutiveFixesSig
      (AS : Set) : Set where
      constructor InvolutiveFixesSigSigC
      field
        1S : AS
        primS : AS -> AS
    record InvolutiveFixesProd
      (AP : Set) : Set where
      constructor InvolutiveFixesProdC
      field
        1P : Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        fixes_prim_1P : primP 1P == 1P
    record InvolutiveFixesHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveFixes A1)
      (In2 : InvolutiveFixes A2) :
      Set where
      constructor InvolutiveFixesHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 In1) == 1 In2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutiveFixesRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveFixes A1)
      (In2 : InvolutiveFixes A2) :
      Set where
      constructor InvolutiveFixesRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 In1) (1 In2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutiveFixesLang
      : Set where
      1L : InvolutiveFixesLang
      primL :
        InvolutiveFixesLang ->
        InvolutiveFixesLang
    data InvolutiveFixesOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InvolutiveFixesOpenLang n
      1OL : InvolutiveFixesOpenLang n
      primOL :
        InvolutiveFixesOpenLang n ->
        InvolutiveFixesOpenLang n
    evalTerm :
      (A : Set) ->
      InvolutiveFixes A ->
      InvolutiveFixesLang -> A
    evalTerm _ In (1L) = 1 In
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InvolutiveFixes A ->
      InvolutiveFixesOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (1OL) vars =
      1 in
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
    simplify :
      InvolutiveFixesLang ->
      InvolutiveFixesLang
    simplify (primL (1L)) = 1L
    simplify (1L) = 1L
    simplify (primL x1) =
      primL (simplify x1)
    liftInvolutiveFixesLang :
      InvolutiveFixesLang ->
      Staged InvolutiveFixesLang
    liftInvolutiveFixesLang x =
      Now x
    1OL' :
      (n : Nat) ->
      InvolutiveFixesOpenLang n
    1OL' _ = 1OL
    primOL' :
      (n : Nat) ->
      InvolutiveFixesOpenLang n ->
      InvolutiveFixesOpenLang n
    primOL' _ x1 = primOL x1
    liftInvolutiveFixesOpenLang :
      (n : Nat) ->
      InvolutiveFixesOpenLang n ->
      Staged
        (InvolutiveFixesOpenLang n)
    liftInvolutiveFixesOpenLang _ (v
                                   fin) = const _ (code _ (v fin))
    liftInvolutiveFixesOpenLang _ (1OL) =
      Now 1OL
    liftInvolutiveFixesOpenLang _ (primOL
                                   x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftInvolutiveFixesOpenLang _
           x1)
  
  module InvolutiveMagma where
    record InvolutiveMagma
      (A : Set) : Set where
      constructor InvolutiveMagmaC
      field
        prim : A -> A
        involutive_prim :
          (x : A) -> prim (prim x) == x
        op : A -> A -> A
        antidis_prim_op :
          (x : A) (y : A) ->
          prim (op x y) ==
            op (prim y) (prim x)
    record InvolutiveMagmaSig
      (AS : Set) : Set where
      constructor InvolutiveMagmaSigSigC
      field
        primS : AS -> AS
        opS : AS -> AS -> AS
    record InvolutiveMagmaProd
      (AP : Set) : Set where
      constructor InvolutiveMagmaProdC
      field
        primP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
        antidis_prim_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (opP xP yP) ==
            opP (primP yP) (primP xP)
    record InvolutiveMagmaHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveMagma A1)
      (In2 : InvolutiveMagma A2) :
      Set where
      constructor InvolutiveMagmaHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
    record InvolutiveMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveMagma A1)
      (In2 : InvolutiveMagma A2) :
      Set where
      constructor InvolutiveMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
    data InvolutiveMagmaLang
      : Set where
      primL :
        InvolutiveMagmaLang ->
        InvolutiveMagmaLang
      opL :
        InvolutiveMagmaLang ->
        InvolutiveMagmaLang ->
        InvolutiveMagmaLang
    data InvolutiveMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InvolutiveMagmaOpenLang n
      primOL :
        InvolutiveMagmaOpenLang n ->
        InvolutiveMagmaOpenLang n
      opOL :
        InvolutiveMagmaOpenLang n ->
        InvolutiveMagmaOpenLang n ->
        InvolutiveMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      InvolutiveMagma A ->
      InvolutiveMagmaLang -> A
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalTerm _ In (opL x1 x2) =
      op In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InvolutiveMagma A ->
      InvolutiveMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
    evalOpenTerm _ n in (opOL
                         x1
                         x2) vars =
      op in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    simplify :
      InvolutiveMagmaLang ->
      InvolutiveMagmaLang
    simplify (primL (primL x)) = x
    simplify (opL
              (primL y)
              (primL x)) = primL (opL x y)
    simplify (primL x1) =
      primL (simplify x1)
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftInvolutiveMagmaLang :
      InvolutiveMagmaLang ->
      Staged InvolutiveMagmaLang
    liftInvolutiveMagmaLang x =
      Now x
    primOL' :
      (n : Nat) ->
      InvolutiveMagmaOpenLang n ->
      InvolutiveMagmaOpenLang n
    primOL' _ x1 = primOL x1
    opOL' :
      (n : Nat) ->
      InvolutiveMagmaOpenLang n ->
      InvolutiveMagmaOpenLang n ->
      InvolutiveMagmaOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftInvolutiveMagmaOpenLang :
      (n : Nat) ->
      InvolutiveMagmaOpenLang n ->
      Staged
        (InvolutiveMagmaOpenLang n)
    liftInvolutiveMagmaOpenLang _ (v
                                   fin) = const _ (code _ (v fin))
    liftInvolutiveMagmaOpenLang _ (primOL
                                   x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftInvolutiveMagmaOpenLang _
           x1)
    liftInvolutiveMagmaOpenLang _ (opOL
                                   x1
                                   x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftInvolutiveMagmaOpenLang _
           x1)
        (liftInvolutiveMagmaOpenLang _
           x2)
  
  module InvolutiveMagmaSig where
    record InvolutiveMagmaSig
      (A : Set) : Set where
      constructor InvolutiveMagmaSigC
      field
        prim : A -> A
        op : A -> A -> A
    record InvolutiveMagmaSigSig
      (AS : Set) : Set where
      constructor InvolutiveMagmaSigSigSigC
      field
        primS : AS -> AS
        opS : AS -> AS -> AS
    record InvolutiveMagmaSigProd
      (AP : Set) : Set where
      constructor InvolutiveMagmaSigProdC
      field
        primP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record InvolutiveMagmaSigHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveMagmaSig A1)
      (In2 : InvolutiveMagmaSig A2) :
      Set where
      constructor InvolutiveMagmaSigHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
    record InvolutiveMagmaSigRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveMagmaSig A1)
      (In2 : InvolutiveMagmaSig A2) :
      Set where
      constructor InvolutiveMagmaSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
    data InvolutiveMagmaSigLang
      : Set where
      primL :
        InvolutiveMagmaSigLang ->
        InvolutiveMagmaSigLang
      opL :
        InvolutiveMagmaSigLang ->
        InvolutiveMagmaSigLang ->
        InvolutiveMagmaSigLang
    data InvolutiveMagmaSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InvolutiveMagmaSigOpenLang n
      primOL :
        InvolutiveMagmaSigOpenLang n ->
        InvolutiveMagmaSigOpenLang n
      opOL :
        InvolutiveMagmaSigOpenLang n ->
        InvolutiveMagmaSigOpenLang n ->
        InvolutiveMagmaSigOpenLang n
    evalTerm :
      (A : Set) ->
      InvolutiveMagmaSig A ->
      InvolutiveMagmaSigLang -> A
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalTerm _ In (opL x1 x2) =
      op In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InvolutiveMagmaSig A ->
      InvolutiveMagmaSigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
    evalOpenTerm _ n in (opOL
                         x1
                         x2) vars =
      op in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    simplify :
      InvolutiveMagmaSigLang ->
      InvolutiveMagmaSigLang
    simplify (primL x1) =
      primL (simplify x1)
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftInvolutiveMagmaSigLang :
      InvolutiveMagmaSigLang ->
      Staged InvolutiveMagmaSigLang
    liftInvolutiveMagmaSigLang x =
      Now x
    primOL' :
      (n : Nat) ->
      InvolutiveMagmaSigOpenLang n ->
      InvolutiveMagmaSigOpenLang n
    primOL' _ x1 = primOL x1
    opOL' :
      (n : Nat) ->
      InvolutiveMagmaSigOpenLang n ->
      InvolutiveMagmaSigOpenLang n ->
      InvolutiveMagmaSigOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftInvolutiveMagmaSigOpenLang :
      (n : Nat) ->
      InvolutiveMagmaSigOpenLang n ->
      Staged
        (InvolutiveMagmaSigOpenLang n)
    liftInvolutiveMagmaSigOpenLang _ (v
                                      fin) = const _ (code _ (v fin))
    liftInvolutiveMagmaSigOpenLang _ (primOL
                                      x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftInvolutiveMagmaSigOpenLang
           _
           x1)
    liftInvolutiveMagmaSigOpenLang _ (opOL
                                      x1
                                      x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftInvolutiveMagmaSigOpenLang
           _
           x1)
        (liftInvolutiveMagmaSigOpenLang
           _
           x2)
  
  module InvolutiveMultMagmaSig where
    record InvolutiveMultMagmaSig
      (A : Set) : Set where
      constructor InvolutiveMultMagmaSigC
      field
        * : A -> A -> A
        prim : A -> A
    record InvolutiveMultMagmaSigSig
      (AS : Set) : Set where
      constructor InvolutiveMultMagmaSigSigSigC
      field
        *S : AS -> AS -> AS
        primS : AS -> AS
    record InvolutiveMultMagmaSigProd
      (AP : Set) : Set where
      constructor InvolutiveMultMagmaSigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
    record InvolutiveMultMagmaSigHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveMultMagmaSig
         A1)
      (In2 : InvolutiveMultMagmaSig
         A2) : Set where
      constructor InvolutiveMultMagmaSigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* In1 x1 x2) ==
            * In2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutiveMultMagmaSigRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveMultMagmaSig
         A1)
      (In2 : InvolutiveMultMagmaSig
         A2) : Set where
      constructor InvolutiveMultMagmaSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* In1 x1 x2)
            (* In2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutiveMultMagmaSigLang
      : Set where
      *L :
        InvolutiveMultMagmaSigLang ->
        InvolutiveMultMagmaSigLang ->
        InvolutiveMultMagmaSigLang
      primL :
        InvolutiveMultMagmaSigLang ->
        InvolutiveMultMagmaSigLang
    data InvolutiveMultMagmaSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InvolutiveMultMagmaSigOpenLang n
      *OL :
        InvolutiveMultMagmaSigOpenLang
          n ->
        InvolutiveMultMagmaSigOpenLang
          n ->
        InvolutiveMultMagmaSigOpenLang n
      primOL :
        InvolutiveMultMagmaSigOpenLang
          n ->
        InvolutiveMultMagmaSigOpenLang n
    evalTerm :
      (A : Set) ->
      InvolutiveMultMagmaSig A ->
      InvolutiveMultMagmaSigLang -> A
    evalTerm _ In (*L x1 x2) =
      * In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InvolutiveMultMagmaSig A ->
      InvolutiveMultMagmaSigOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (*OL
                         x1
                         x2) vars =
      * in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
    simplify :
      InvolutiveMultMagmaSigLang ->
      InvolutiveMultMagmaSigLang
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (primL x1) =
      primL (simplify x1)
    liftInvolutiveMultMagmaSigLang :
      InvolutiveMultMagmaSigLang ->
      Staged
        InvolutiveMultMagmaSigLang
    liftInvolutiveMultMagmaSigLang x =
      Now x
    *OL' :
      (n : Nat) ->
      InvolutiveMultMagmaSigOpenLang
        n ->
      InvolutiveMultMagmaSigOpenLang
        n ->
      InvolutiveMultMagmaSigOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    primOL' :
      (n : Nat) ->
      InvolutiveMultMagmaSigOpenLang
        n ->
      InvolutiveMultMagmaSigOpenLang n
    primOL' _ x1 = primOL x1
    liftInvolutiveMultMagmaSigOpenLang :
      (n : Nat) ->
      InvolutiveMultMagmaSigOpenLang
        n ->
      Staged
        (InvolutiveMultMagmaSigOpenLang
           n)
    liftInvolutiveMultMagmaSigOpenLang _ (v
                                          fin) = const _ (code _ (v fin))
    liftInvolutiveMultMagmaSigOpenLang _ (*OL
                                          x1
                                          x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftInvolutiveMultMagmaSigOpenLang
           _
           x1)
        (liftInvolutiveMultMagmaSigOpenLang
           _
           x2)
    liftInvolutiveMultMagmaSigOpenLang _ (primOL
                                          x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftInvolutiveMultMagmaSigOpenLang
           _
           x1)
  
  module InvolutivePointedMagmaSig where
    record InvolutivePointedMagmaSig
      (A : Set) : Set where
      constructor InvolutivePointedMagmaSigC
      field
        prim : A -> A
        e : A
        op : A -> A -> A
    record InvolutivePointedMagmaSigSig
      (AS : Set) : Set where
      constructor InvolutivePointedMagmaSigSigSigC
      field
        primS : AS -> AS
        eS : AS
        opS : AS -> AS -> AS
    record InvolutivePointedMagmaSigProd
      (AP : Set) : Set where
      constructor InvolutivePointedMagmaSigProdC
      field
        primP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record InvolutivePointedMagmaSigHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutivePointedMagmaSig
         A1)
      (In2 : InvolutivePointedMagmaSig
         A2) : Set where
      constructor InvolutivePointedMagmaSigHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-e : hom (e In1) == e In2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
    record InvolutivePointedMagmaSigRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutivePointedMagmaSig
         A1)
      (In2 : InvolutivePointedMagmaSig
         A2) : Set where
      constructor InvolutivePointedMagmaSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-e :
          interp (e In1) (e In2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
    data InvolutivePointedMagmaSigLang
      : Set where
      primL :
        InvolutivePointedMagmaSigLang ->
        InvolutivePointedMagmaSigLang
      eL :
        InvolutivePointedMagmaSigLang
      opL :
        InvolutivePointedMagmaSigLang ->
        InvolutivePointedMagmaSigLang ->
        InvolutivePointedMagmaSigLang
    data InvolutivePointedMagmaSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InvolutivePointedMagmaSigOpenLang
          n
      primOL :
        InvolutivePointedMagmaSigOpenLang
          n ->
        InvolutivePointedMagmaSigOpenLang
          n
      eOL :
        InvolutivePointedMagmaSigOpenLang
          n
      opOL :
        InvolutivePointedMagmaSigOpenLang
          n ->
        InvolutivePointedMagmaSigOpenLang
          n ->
        InvolutivePointedMagmaSigOpenLang
          n
    evalTerm :
      (A : Set) ->
      InvolutivePointedMagmaSig A ->
      InvolutivePointedMagmaSigLang ->
      A
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalTerm _ In (eL) = e In
    evalTerm _ In (opL x1 x2) =
      op In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InvolutivePointedMagmaSig A ->
      InvolutivePointedMagmaSigOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
    evalOpenTerm _ n in (eOL) vars =
      e in
    evalOpenTerm _ n in (opOL
                         x1
                         x2) vars =
      op in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    simplify :
      InvolutivePointedMagmaSigLang ->
      InvolutivePointedMagmaSigLang
    simplify (primL x1) =
      primL (simplify x1)
    simplify (eL) = eL
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftInvolutivePointedMagmaSigLang :
      InvolutivePointedMagmaSigLang ->
      Staged
        InvolutivePointedMagmaSigLang
    liftInvolutivePointedMagmaSigLang x =
      Now x
    primOL' :
      (n : Nat) ->
      InvolutivePointedMagmaSigOpenLang
        n ->
      InvolutivePointedMagmaSigOpenLang
        n
    primOL' _ x1 = primOL x1
    eOL' :
      (n : Nat) ->
      InvolutivePointedMagmaSigOpenLang
        n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      InvolutivePointedMagmaSigOpenLang
        n ->
      InvolutivePointedMagmaSigOpenLang
        n ->
      InvolutivePointedMagmaSigOpenLang
        n
    opOL' _ x1 x2 = opOL x1 x2
    liftInvolutivePointedMagmaSigOpenLang :
      (n : Nat) ->
      InvolutivePointedMagmaSigOpenLang
        n ->
      Staged
        (InvolutivePointedMagmaSigOpenLang
           n)
    liftInvolutivePointedMagmaSigOpenLang _ (v
                                             fin) = const _ (code _ (v fin))
    liftInvolutivePointedMagmaSigOpenLang _ (primOL
                                             x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftInvolutivePointedMagmaSigOpenLang
           _
           x1)
    liftInvolutivePointedMagmaSigOpenLang _ (eOL) =
      Now eOL
    liftInvolutivePointedMagmaSigOpenLang _ (opOL
                                             x1
                                             x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftInvolutivePointedMagmaSigOpenLang
           _
           x1)
        (liftInvolutivePointedMagmaSigOpenLang
           _
           x2)
  
  module InvolutivePointedSemigroup where
    record InvolutivePointedSemigroup
      (A : Set) : Set where
      constructor InvolutivePointedSemigroupC
      field
        op : A -> A -> A
        e : A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        prim : A -> A
        involutive_prim :
          (x : A) -> prim (prim x) == x
        antidis_prim_op :
          (x : A) (y : A) ->
          prim (op x y) ==
            op (prim y) (prim x)
    record InvolutivePointedSemigroupSig
      (AS : Set) : Set where
      constructor InvolutivePointedSemigroupSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
        primS : AS -> AS
    record InvolutivePointedSemigroupProd
      (AP : Set) : Set where
      constructor InvolutivePointedSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
        antidis_prim_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (opP xP yP) ==
            opP (primP yP) (primP xP)
    record InvolutivePointedSemigroupHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutivePointedSemigroup
         A1)
      (In2 : InvolutivePointedSemigroup
         A2) : Set where
      constructor InvolutivePointedSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
        pres-e : hom (e In1) == e In2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutivePointedSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutivePointedSemigroup
         A1)
      (In2 : InvolutivePointedSemigroup
         A2) : Set where
      constructor InvolutivePointedSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
        interp-e :
          interp (e In1) (e In2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutivePointedSemigroupLang
      : Set where
      opL :
        InvolutivePointedSemigroupLang ->
        InvolutivePointedSemigroupLang ->
        InvolutivePointedSemigroupLang
      eL :
        InvolutivePointedSemigroupLang
      primL :
        InvolutivePointedSemigroupLang ->
        InvolutivePointedSemigroupLang
    data InvolutivePointedSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InvolutivePointedSemigroupOpenLang
          n
      opOL :
        InvolutivePointedSemigroupOpenLang
          n ->
        InvolutivePointedSemigroupOpenLang
          n ->
        InvolutivePointedSemigroupOpenLang
          n
      eOL :
        InvolutivePointedSemigroupOpenLang
          n
      primOL :
        InvolutivePointedSemigroupOpenLang
          n ->
        InvolutivePointedSemigroupOpenLang
          n
    evalTerm :
      (A : Set) ->
      InvolutivePointedSemigroup A ->
      InvolutivePointedSemigroupLang ->
      A
    evalTerm _ In (opL x1 x2) =
      op In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalTerm _ In (eL) = e In
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InvolutivePointedSemigroup A ->
      InvolutivePointedSemigroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (opOL
                         x1
                         x2) vars =
      op in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    evalOpenTerm _ n in (eOL) vars =
      e in
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
    simplify :
      InvolutivePointedSemigroupLang ->
      InvolutivePointedSemigroupLang
    simplify (primL (primL x)) = x
    simplify (opL
              (primL y)
              (primL x)) = primL (opL x y)
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (eL) = eL
    simplify (primL x1) =
      primL (simplify x1)
    liftInvolutivePointedSemigroupLang :
      InvolutivePointedSemigroupLang ->
      Staged
        InvolutivePointedSemigroupLang
    liftInvolutivePointedSemigroupLang x =
      Now x
    opOL' :
      (n : Nat) ->
      InvolutivePointedSemigroupOpenLang
        n ->
      InvolutivePointedSemigroupOpenLang
        n ->
      InvolutivePointedSemigroupOpenLang
        n
    opOL' _ x1 x2 = opOL x1 x2
    eOL' :
      (n : Nat) ->
      InvolutivePointedSemigroupOpenLang
        n
    eOL' _ = eOL
    primOL' :
      (n : Nat) ->
      InvolutivePointedSemigroupOpenLang
        n ->
      InvolutivePointedSemigroupOpenLang
        n
    primOL' _ x1 = primOL x1
    liftInvolutivePointedSemigroupOpenLang :
      (n : Nat) ->
      InvolutivePointedSemigroupOpenLang
        n ->
      Staged
        (InvolutivePointedSemigroupOpenLang
           n)
    liftInvolutivePointedSemigroupOpenLang _ (v
                                              fin) = const _ (code _ (v fin))
    liftInvolutivePointedSemigroupOpenLang _ (opOL
                                              x1
                                              x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftInvolutivePointedSemigroupOpenLang
           _
           x1)
        (liftInvolutivePointedSemigroupOpenLang
           _
           x2)
    liftInvolutivePointedSemigroupOpenLang _ (eOL) =
      Now eOL
    liftInvolutivePointedSemigroupOpenLang _ (primOL
                                              x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftInvolutivePointedSemigroupOpenLang
           _
           x1)
  
  module InvolutiveRing where
    record InvolutiveRing
      (A : Set) : Set where
      constructor InvolutiveRingC
      field
        * : A -> A -> A
        + : A -> A -> A
        1 : A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        prim : A -> A
        fixes_prim_1 : prim 1 == 1
        involutive_prim :
          (x : A) -> prim (prim x) == x
        antidis_prim_+ :
          (x : A) (y : A) ->
          prim (+ x y) ==
            + (prim y) (prim x)
        antidis_prim_* :
          (x : A) (y : A) ->
          prim (* x y) ==
            * (prim y) (prim x)
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
    record InvolutiveRingSig
      (AS : Set) : Set where
      constructor InvolutiveRingSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        1S : AS
        primS : AS -> AS
        0S : AS
        negS : AS -> AS
    record InvolutiveRingProd
      (AP : Set) : Set where
      constructor InvolutiveRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        fixes_prim_1P : primP 1P == 1P
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
        antidis_prim_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (+P xP yP) ==
            +P (primP yP) (primP xP)
        antidis_prim_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (*P xP yP) ==
            *P (primP yP) (primP xP)
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
    record InvolutiveRingHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRing A1)
      (In2 : InvolutiveRing A2) :
      Set where
      constructor InvolutiveRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* In1 x1 x2) ==
            * In2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ In1 x1 x2) ==
            + In2 (hom x1) (hom x2)
        pres-1 : hom (1 In1) == 1 In2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-0 : hom (0 In1) == 0 In2
        pres-neg :
          (x1 : A1) ->
          hom (neg In1 x1) ==
            neg In2 (hom x1)
    record InvolutiveRingRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRing A1)
      (In2 : InvolutiveRing A2) :
      Set where
      constructor InvolutiveRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* In1 x1 x2)
            (* In2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ In1 x1 x2)
            (+ In2 y1 y2)
        interp-1 :
          interp (1 In1) (1 In2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-0 :
          interp (0 In1) (0 In2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg In1 x1) (neg In2 y1)
    data InvolutiveRingLang
      : Set where
      *L :
        InvolutiveRingLang ->
        InvolutiveRingLang ->
        InvolutiveRingLang
      +L :
        InvolutiveRingLang ->
        InvolutiveRingLang ->
        InvolutiveRingLang
      1L : InvolutiveRingLang
      primL :
        InvolutiveRingLang ->
        InvolutiveRingLang
      0L : InvolutiveRingLang
      negL :
        InvolutiveRingLang ->
        InvolutiveRingLang
    data InvolutiveRingOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InvolutiveRingOpenLang n
      *OL :
        InvolutiveRingOpenLang n ->
        InvolutiveRingOpenLang n ->
        InvolutiveRingOpenLang n
      +OL :
        InvolutiveRingOpenLang n ->
        InvolutiveRingOpenLang n ->
        InvolutiveRingOpenLang n
      1OL : InvolutiveRingOpenLang n
      primOL :
        InvolutiveRingOpenLang n ->
        InvolutiveRingOpenLang n
      0OL : InvolutiveRingOpenLang n
      negOL :
        InvolutiveRingOpenLang n ->
        InvolutiveRingOpenLang n
    evalTerm :
      (A : Set) ->
      InvolutiveRing A ->
      InvolutiveRingLang -> A
    evalTerm _ In (*L x1 x2) =
      * In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalTerm _ In (+L x1 x2) =
      + In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalTerm _ In (1L) = 1 In
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalTerm _ In (0L) = 0 In
    evalTerm _ In (negL x1) =
      neg In (evalTerm _ In x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InvolutiveRing A ->
      InvolutiveRingOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (*OL
                         x1
                         x2) vars =
      * in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    evalOpenTerm _ n in (+OL
                         x1
                         x2) vars =
      + in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    evalOpenTerm _ n in (1OL) vars =
      1 in
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
    evalOpenTerm _ n in (0OL) vars =
      0 in
    evalOpenTerm _ n in (negOL
                         x1) vars =
      neg in
        (evalOpenTerm _ n in x1 vars)
    simplify :
      InvolutiveRingLang ->
      InvolutiveRingLang
    simplify (+L
              (*L x y)
              (*L x z)) = *L x (+L y z)
    simplify (+L
              (*L y x)
              (*L z x)) = *L (+L y z) x
    simplify (primL (1L)) = 1L
    simplify (primL (primL x)) = x
    simplify (+L
              (primL y)
              (primL x)) = primL (+L x y)
    simplify (*L
              (primL y)
              (primL x)) = primL (*L x y)
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (+L x (negL x)) = 0L
    simplify (+L (negL x) x) = 0L
    simplify (*L (1L) x) = x
    simplify (*L x (1L)) = x
    simplify (*L (0L) x) = 0L
    simplify (*L x (0L)) = 0L
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (1L) = 1L
    simplify (primL x1) =
      primL (simplify x1)
    simplify (0L) = 0L
    simplify (negL x1) =
      negL (simplify x1)
    liftInvolutiveRingLang :
      InvolutiveRingLang ->
      Staged InvolutiveRingLang
    liftInvolutiveRingLang x = Now x
    *OL' :
      (n : Nat) ->
      InvolutiveRingOpenLang n ->
      InvolutiveRingOpenLang n ->
      InvolutiveRingOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      InvolutiveRingOpenLang n ->
      InvolutiveRingOpenLang n ->
      InvolutiveRingOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    1OL' :
      (n : Nat) ->
      InvolutiveRingOpenLang n
    1OL' _ = 1OL
    primOL' :
      (n : Nat) ->
      InvolutiveRingOpenLang n ->
      InvolutiveRingOpenLang n
    primOL' _ x1 = primOL x1
    0OL' :
      (n : Nat) ->
      InvolutiveRingOpenLang n
    0OL' _ = 0OL
    negOL' :
      (n : Nat) ->
      InvolutiveRingOpenLang n ->
      InvolutiveRingOpenLang n
    negOL' _ x1 = negOL x1
    liftInvolutiveRingOpenLang :
      (n : Nat) ->
      InvolutiveRingOpenLang n ->
      Staged
        (InvolutiveRingOpenLang n)
    liftInvolutiveRingOpenLang _ (v
                                  fin) = const _ (code _ (v fin))
    liftInvolutiveRingOpenLang _ (*OL
                                  x1
                                  x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftInvolutiveRingOpenLang _
           x1)
        (liftInvolutiveRingOpenLang _
           x2)
    liftInvolutiveRingOpenLang _ (+OL
                                  x1
                                  x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftInvolutiveRingOpenLang _
           x1)
        (liftInvolutiveRingOpenLang _
           x2)
    liftInvolutiveRingOpenLang _ (1OL) =
      Now 1OL
    liftInvolutiveRingOpenLang _ (primOL
                                  x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftInvolutiveRingOpenLang _
           x1)
    liftInvolutiveRingOpenLang _ (0OL) =
      Now 0OL
    liftInvolutiveRingOpenLang _ (negOL
                                  x1) =
      stage1 _ _ (negOL' _)
        (codeLift1 _ _ (negOL' _))
        (liftInvolutiveRingOpenLang _
           x1)
  
  module InvolutiveRingoid where
    record InvolutiveRingoid
      (A : Set) : Set where
      constructor InvolutiveRingoidC
      field
        prim : A -> A
        1 : A
        fixes_prim_1 : prim 1 == 1
        involutive_prim :
          (x : A) -> prim (prim x) == x
        * : A -> A -> A
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        antidis_prim_+ :
          (x : A) (y : A) ->
          prim (+ x y) ==
            + (prim y) (prim x)
        antidis_prim_* :
          (x : A) (y : A) ->
          prim (* x y) ==
            * (prim y) (prim x)
    record InvolutiveRingoidSig
      (AS : Set) : Set where
      constructor InvolutiveRingoidSigSigC
      field
        primS : AS -> AS
        1S : AS
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record InvolutiveRingoidProd
      (AP : Set) : Set where
      constructor InvolutiveRingoidProdC
      field
        primP : Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        fixes_prim_1P : primP 1P == 1P
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        antidis_prim_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (+P xP yP) ==
            +P (primP yP) (primP xP)
        antidis_prim_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (*P xP yP) ==
            *P (primP yP) (primP xP)
    record InvolutiveRingoidHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRingoid A1)
      (In2 : InvolutiveRingoid A2) :
      Set where
      constructor InvolutiveRingoidHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-1 : hom (1 In1) == 1 In2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* In1 x1 x2) ==
            * In2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ In1 x1 x2) ==
            + In2 (hom x1) (hom x2)
    record InvolutiveRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRingoid A1)
      (In2 : InvolutiveRingoid A2) :
      Set where
      constructor InvolutiveRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-1 :
          interp (1 In1) (1 In2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* In1 x1 x2)
            (* In2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ In1 x1 x2)
            (+ In2 y1 y2)
    data InvolutiveRingoidLang
      : Set where
      primL :
        InvolutiveRingoidLang ->
        InvolutiveRingoidLang
      1L : InvolutiveRingoidLang
      *L :
        InvolutiveRingoidLang ->
        InvolutiveRingoidLang ->
        InvolutiveRingoidLang
      +L :
        InvolutiveRingoidLang ->
        InvolutiveRingoidLang ->
        InvolutiveRingoidLang
    data InvolutiveRingoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InvolutiveRingoidOpenLang n
      primOL :
        InvolutiveRingoidOpenLang n ->
        InvolutiveRingoidOpenLang n
      1OL :
        InvolutiveRingoidOpenLang n
      *OL :
        InvolutiveRingoidOpenLang n ->
        InvolutiveRingoidOpenLang n ->
        InvolutiveRingoidOpenLang n
      +OL :
        InvolutiveRingoidOpenLang n ->
        InvolutiveRingoidOpenLang n ->
        InvolutiveRingoidOpenLang n
    evalTerm :
      (A : Set) ->
      InvolutiveRingoid A ->
      InvolutiveRingoidLang -> A
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalTerm _ In (1L) = 1 In
    evalTerm _ In (*L x1 x2) =
      * In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalTerm _ In (+L x1 x2) =
      + In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InvolutiveRingoid A ->
      InvolutiveRingoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
    evalOpenTerm _ n in (1OL) vars =
      1 in
    evalOpenTerm _ n in (*OL
                         x1
                         x2) vars =
      * in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    evalOpenTerm _ n in (+OL
                         x1
                         x2) vars =
      + in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    simplify :
      InvolutiveRingoidLang ->
      InvolutiveRingoidLang
    simplify (primL (1L)) = 1L
    simplify (primL (primL x)) = x
    simplify (+L
              (*L x y)
              (*L x z)) = *L x (+L y z)
    simplify (+L
              (*L y x)
              (*L z x)) = *L (+L y z) x
    simplify (+L
              (primL y)
              (primL x)) = primL (+L x y)
    simplify (*L
              (primL y)
              (primL x)) = primL (*L x y)
    simplify (primL x1) =
      primL (simplify x1)
    simplify (1L) = 1L
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftInvolutiveRingoidLang :
      InvolutiveRingoidLang ->
      Staged InvolutiveRingoidLang
    liftInvolutiveRingoidLang x =
      Now x
    primOL' :
      (n : Nat) ->
      InvolutiveRingoidOpenLang n ->
      InvolutiveRingoidOpenLang n
    primOL' _ x1 = primOL x1
    1OL' :
      (n : Nat) ->
      InvolutiveRingoidOpenLang n
    1OL' _ = 1OL
    *OL' :
      (n : Nat) ->
      InvolutiveRingoidOpenLang n ->
      InvolutiveRingoidOpenLang n ->
      InvolutiveRingoidOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      InvolutiveRingoidOpenLang n ->
      InvolutiveRingoidOpenLang n ->
      InvolutiveRingoidOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftInvolutiveRingoidOpenLang :
      (n : Nat) ->
      InvolutiveRingoidOpenLang n ->
      Staged
        (InvolutiveRingoidOpenLang n)
    liftInvolutiveRingoidOpenLang _ (v
                                     fin) = const _ (code _ (v fin))
    liftInvolutiveRingoidOpenLang _ (primOL
                                     x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftInvolutiveRingoidOpenLang _
           x1)
    liftInvolutiveRingoidOpenLang _ (1OL) =
      Now 1OL
    liftInvolutiveRingoidOpenLang _ (*OL
                                     x1
                                     x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftInvolutiveRingoidOpenLang _
           x1)
        (liftInvolutiveRingoidOpenLang _
           x2)
    liftInvolutiveRingoidOpenLang _ (+OL
                                     x1
                                     x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftInvolutiveRingoidOpenLang _
           x1)
        (liftInvolutiveRingoidOpenLang _
           x2)
  
  module InvolutiveRingoidSig where
    record InvolutiveRingoidSig
      (A : Set) : Set where
      constructor InvolutiveRingoidSigC
      field
        prim : A -> A
        * : A -> A -> A
        + : A -> A -> A
    record InvolutiveRingoidSigSig
      (AS : Set) : Set where
      constructor InvolutiveRingoidSigSigSigC
      field
        primS : AS -> AS
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record InvolutiveRingoidSigProd
      (AP : Set) : Set where
      constructor InvolutiveRingoidSigProdC
      field
        primP : Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record InvolutiveRingoidSigHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRingoidSig A1)
      (In2 : InvolutiveRingoidSig
         A2) : Set where
      constructor InvolutiveRingoidSigHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* In1 x1 x2) ==
            * In2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ In1 x1 x2) ==
            + In2 (hom x1) (hom x2)
    record InvolutiveRingoidSigRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRingoidSig A1)
      (In2 : InvolutiveRingoidSig
         A2) : Set where
      constructor InvolutiveRingoidSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* In1 x1 x2)
            (* In2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ In1 x1 x2)
            (+ In2 y1 y2)
    data InvolutiveRingoidSigLang
      : Set where
      primL :
        InvolutiveRingoidSigLang ->
        InvolutiveRingoidSigLang
      *L :
        InvolutiveRingoidSigLang ->
        InvolutiveRingoidSigLang ->
        InvolutiveRingoidSigLang
      +L :
        InvolutiveRingoidSigLang ->
        InvolutiveRingoidSigLang ->
        InvolutiveRingoidSigLang
    data InvolutiveRingoidSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InvolutiveRingoidSigOpenLang n
      primOL :
        InvolutiveRingoidSigOpenLang
          n ->
        InvolutiveRingoidSigOpenLang n
      *OL :
        InvolutiveRingoidSigOpenLang
          n ->
        InvolutiveRingoidSigOpenLang
          n ->
        InvolutiveRingoidSigOpenLang n
      +OL :
        InvolutiveRingoidSigOpenLang
          n ->
        InvolutiveRingoidSigOpenLang
          n ->
        InvolutiveRingoidSigOpenLang n
    evalTerm :
      (A : Set) ->
      InvolutiveRingoidSig A ->
      InvolutiveRingoidSigLang -> A
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalTerm _ In (*L x1 x2) =
      * In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalTerm _ In (+L x1 x2) =
      + In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InvolutiveRingoidSig A ->
      InvolutiveRingoidSigOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
    evalOpenTerm _ n in (*OL
                         x1
                         x2) vars =
      * in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    evalOpenTerm _ n in (+OL
                         x1
                         x2) vars =
      + in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    simplify :
      InvolutiveRingoidSigLang ->
      InvolutiveRingoidSigLang
    simplify (primL x1) =
      primL (simplify x1)
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftInvolutiveRingoidSigLang :
      InvolutiveRingoidSigLang ->
      Staged InvolutiveRingoidSigLang
    liftInvolutiveRingoidSigLang x =
      Now x
    primOL' :
      (n : Nat) ->
      InvolutiveRingoidSigOpenLang
        n ->
      InvolutiveRingoidSigOpenLang n
    primOL' _ x1 = primOL x1
    *OL' :
      (n : Nat) ->
      InvolutiveRingoidSigOpenLang
        n ->
      InvolutiveRingoidSigOpenLang
        n ->
      InvolutiveRingoidSigOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      InvolutiveRingoidSigOpenLang
        n ->
      InvolutiveRingoidSigOpenLang
        n ->
      InvolutiveRingoidSigOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftInvolutiveRingoidSigOpenLang :
      (n : Nat) ->
      InvolutiveRingoidSigOpenLang
        n ->
      Staged
        (InvolutiveRingoidSigOpenLang n)
    liftInvolutiveRingoidSigOpenLang _ (v
                                        fin) = const _ (code _ (v fin))
    liftInvolutiveRingoidSigOpenLang _ (primOL
                                        x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftInvolutiveRingoidSigOpenLang
           _
           x1)
    liftInvolutiveRingoidSigOpenLang _ (*OL
                                        x1
                                        x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftInvolutiveRingoidSigOpenLang
           _
           x1)
        (liftInvolutiveRingoidSigOpenLang
           _
           x2)
    liftInvolutiveRingoidSigOpenLang _ (+OL
                                        x1
                                        x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftInvolutiveRingoidSigOpenLang
           _
           x1)
        (liftInvolutiveRingoidSigOpenLang
           _
           x2)
  
  module InvolutiveRingoidWithAntiDistrib where
    record InvolutiveRingoidWithAntiDistrib
      (A : Set) : Set where
      constructor InvolutiveRingoidWithAntiDistribC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        prim : A -> A
        antidis_prim_+ :
          (x : A) (y : A) ->
          prim (+ x y) ==
            + (prim y) (prim x)
        antidis_prim_* :
          (x : A) (y : A) ->
          prim (* x y) ==
            * (prim y) (prim x)
    record InvolutiveRingoidWithAntiDistribSig
      (AS : Set) : Set where
      constructor InvolutiveRingoidWithAntiDistribSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        primS : AS -> AS
    record InvolutiveRingoidWithAntiDistribProd
      (AP : Set) : Set where
      constructor InvolutiveRingoidWithAntiDistribProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        antidis_prim_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (+P xP yP) ==
            +P (primP yP) (primP xP)
        antidis_prim_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (*P xP yP) ==
            *P (primP yP) (primP xP)
    record InvolutiveRingoidWithAntiDistribHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRingoidWithAntiDistrib
         A1)
      (In2 : InvolutiveRingoidWithAntiDistrib
         A2) : Set where
      constructor InvolutiveRingoidWithAntiDistribHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* In1 x1 x2) ==
            * In2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ In1 x1 x2) ==
            + In2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutiveRingoidWithAntiDistribRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRingoidWithAntiDistrib
         A1)
      (In2 : InvolutiveRingoidWithAntiDistrib
         A2) : Set where
      constructor InvolutiveRingoidWithAntiDistribRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* In1 x1 x2)
            (* In2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ In1 x1 x2)
            (+ In2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutiveRingoidWithAntiDistribLang
      : Set where
      *L :
        InvolutiveRingoidWithAntiDistribLang ->
        InvolutiveRingoidWithAntiDistribLang ->
        InvolutiveRingoidWithAntiDistribLang
      +L :
        InvolutiveRingoidWithAntiDistribLang ->
        InvolutiveRingoidWithAntiDistribLang ->
        InvolutiveRingoidWithAntiDistribLang
      primL :
        InvolutiveRingoidWithAntiDistribLang ->
        InvolutiveRingoidWithAntiDistribLang
    data InvolutiveRingoidWithAntiDistribOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InvolutiveRingoidWithAntiDistribOpenLang
          n
      *OL :
        InvolutiveRingoidWithAntiDistribOpenLang
          n ->
        InvolutiveRingoidWithAntiDistribOpenLang
          n ->
        InvolutiveRingoidWithAntiDistribOpenLang
          n
      +OL :
        InvolutiveRingoidWithAntiDistribOpenLang
          n ->
        InvolutiveRingoidWithAntiDistribOpenLang
          n ->
        InvolutiveRingoidWithAntiDistribOpenLang
          n
      primOL :
        InvolutiveRingoidWithAntiDistribOpenLang
          n ->
        InvolutiveRingoidWithAntiDistribOpenLang
          n
    evalTerm :
      (A : Set) ->
      InvolutiveRingoidWithAntiDistrib
        A ->
      InvolutiveRingoidWithAntiDistribLang ->
      A
    evalTerm _ In (*L x1 x2) =
      * In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalTerm _ In (+L x1 x2) =
      + In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InvolutiveRingoidWithAntiDistrib
        A ->
      InvolutiveRingoidWithAntiDistribOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (*OL
                         x1
                         x2) vars =
      * in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    evalOpenTerm _ n in (+OL
                         x1
                         x2) vars =
      + in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
    simplify :
      InvolutiveRingoidWithAntiDistribLang ->
      InvolutiveRingoidWithAntiDistribLang
    simplify (+L
              (*L x y)
              (*L x z)) = *L x (+L y z)
    simplify (+L
              (*L y x)
              (*L z x)) = *L (+L y z) x
    simplify (+L
              (primL y)
              (primL x)) = primL (+L x y)
    simplify (*L
              (primL y)
              (primL x)) = primL (*L x y)
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (primL x1) =
      primL (simplify x1)
    liftInvolutiveRingoidWithAntiDistribLang :
      InvolutiveRingoidWithAntiDistribLang ->
      Staged
        InvolutiveRingoidWithAntiDistribLang
    liftInvolutiveRingoidWithAntiDistribLang x =
      Now x
    *OL' :
      (n : Nat) ->
      InvolutiveRingoidWithAntiDistribOpenLang
        n ->
      InvolutiveRingoidWithAntiDistribOpenLang
        n ->
      InvolutiveRingoidWithAntiDistribOpenLang
        n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      InvolutiveRingoidWithAntiDistribOpenLang
        n ->
      InvolutiveRingoidWithAntiDistribOpenLang
        n ->
      InvolutiveRingoidWithAntiDistribOpenLang
        n
    +OL' _ x1 x2 = +OL x1 x2
    primOL' :
      (n : Nat) ->
      InvolutiveRingoidWithAntiDistribOpenLang
        n ->
      InvolutiveRingoidWithAntiDistribOpenLang
        n
    primOL' _ x1 = primOL x1
    liftInvolutiveRingoidWithAntiDistribOpenLang :
      (n : Nat) ->
      InvolutiveRingoidWithAntiDistribOpenLang
        n ->
      Staged
        (InvolutiveRingoidWithAntiDistribOpenLang
           n)
    liftInvolutiveRingoidWithAntiDistribOpenLang _ (v
                                                    fin) =
      const _ (code _ (v fin))
    liftInvolutiveRingoidWithAntiDistribOpenLang _ (*OL
                                                    x1
                                                    x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftInvolutiveRingoidWithAntiDistribOpenLang
           _
           x1)
        (liftInvolutiveRingoidWithAntiDistribOpenLang
           _
           x2)
    liftInvolutiveRingoidWithAntiDistribOpenLang _ (+OL
                                                    x1
                                                    x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftInvolutiveRingoidWithAntiDistribOpenLang
           _
           x1)
        (liftInvolutiveRingoidWithAntiDistribOpenLang
           _
           x2)
    liftInvolutiveRingoidWithAntiDistribOpenLang _ (primOL
                                                    x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftInvolutiveRingoidWithAntiDistribOpenLang
           _
           x1)
  
  module InvolutiveSemigroup where
    record InvolutiveSemigroup
      (A : Set) : Set where
      constructor InvolutiveSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        prim : A -> A
        involutive_prim :
          (x : A) -> prim (prim x) == x
        antidis_prim_op :
          (x : A) (y : A) ->
          prim (op x y) ==
            op (prim y) (prim x)
    record InvolutiveSemigroupSig
      (AS : Set) : Set where
      constructor InvolutiveSemigroupSigSigC
      field
        opS : AS -> AS -> AS
        primS : AS -> AS
    record InvolutiveSemigroupProd
      (AP : Set) : Set where
      constructor InvolutiveSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
        antidis_prim_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (opP xP yP) ==
            opP (primP yP) (primP xP)
    record InvolutiveSemigroupHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveSemigroup A1)
      (In2 : InvolutiveSemigroup A2) :
      Set where
      constructor InvolutiveSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutiveSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveSemigroup A1)
      (In2 : InvolutiveSemigroup A2) :
      Set where
      constructor InvolutiveSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutiveSemigroupLang
      : Set where
      opL :
        InvolutiveSemigroupLang ->
        InvolutiveSemigroupLang ->
        InvolutiveSemigroupLang
      primL :
        InvolutiveSemigroupLang ->
        InvolutiveSemigroupLang
    data InvolutiveSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InvolutiveSemigroupOpenLang n
      opOL :
        InvolutiveSemigroupOpenLang n ->
        InvolutiveSemigroupOpenLang n ->
        InvolutiveSemigroupOpenLang n
      primOL :
        InvolutiveSemigroupOpenLang n ->
        InvolutiveSemigroupOpenLang n
    evalTerm :
      (A : Set) ->
      InvolutiveSemigroup A ->
      InvolutiveSemigroupLang -> A
    evalTerm _ In (opL x1 x2) =
      op In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InvolutiveSemigroup A ->
      InvolutiveSemigroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (opOL
                         x1
                         x2) vars =
      op in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
    simplify :
      InvolutiveSemigroupLang ->
      InvolutiveSemigroupLang
    simplify (primL (primL x)) = x
    simplify (opL
              (primL y)
              (primL x)) = primL (opL x y)
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (primL x1) =
      primL (simplify x1)
    liftInvolutiveSemigroupLang :
      InvolutiveSemigroupLang ->
      Staged InvolutiveSemigroupLang
    liftInvolutiveSemigroupLang x =
      Now x
    opOL' :
      (n : Nat) ->
      InvolutiveSemigroupOpenLang n ->
      InvolutiveSemigroupOpenLang n ->
      InvolutiveSemigroupOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    primOL' :
      (n : Nat) ->
      InvolutiveSemigroupOpenLang n ->
      InvolutiveSemigroupOpenLang n
    primOL' _ x1 = primOL x1
    liftInvolutiveSemigroupOpenLang :
      (n : Nat) ->
      InvolutiveSemigroupOpenLang n ->
      Staged
        (InvolutiveSemigroupOpenLang n)
    liftInvolutiveSemigroupOpenLang _ (v
                                       fin) = const _ (code _ (v fin))
    liftInvolutiveSemigroupOpenLang _ (opOL
                                       x1
                                       x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftInvolutiveSemigroupOpenLang
           _
           x1)
        (liftInvolutiveSemigroupOpenLang
           _
           x2)
    liftInvolutiveSemigroupOpenLang _ (primOL
                                       x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftInvolutiveSemigroupOpenLang
           _
           x1)
  
  module JacobianIdentity where
    record JacobianIdentity
      (A : Set) : Set where
      constructor JacobianIdentityC
      field
        0 : A
        + : A -> A -> A
        * : A -> A -> A
        jacobian_*_+ :
          (x : A) (y : A) (z : A) ->
          +
            (+ (* x (* y z)) (* y (* z x)))
            (* z (* x y)) == 0
    record JacobianIdentitySig
      (AS : Set) : Set where
      constructor JacobianIdentitySigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
    record JacobianIdentityProd
      (AP : Set) : Set where
      constructor JacobianIdentityProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        jacobian_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P
            (+P (*P xP (*P yP zP))
               (*P yP (*P zP xP)))
            (*P zP (*P xP yP)) == 0P
    record JacobianIdentityHom
      (A1 : Set) (A2 : Set)
      (Ja1 : JacobianIdentity A1)
      (Ja2 : JacobianIdentity A2) :
      Set where
      constructor JacobianIdentityHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ja1) == 0 Ja2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ja1 x1 x2) ==
            + Ja2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ja1 x1 x2) ==
            * Ja2 (hom x1) (hom x2)
    record JacobianIdentityRelInterp
      (A1 : Set) (A2 : Set)
      (Ja1 : JacobianIdentity A1)
      (Ja2 : JacobianIdentity A2) :
      Set where
      constructor JacobianIdentityRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ja1) (0 Ja2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ja1 x1 x2)
            (+ Ja2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ja1 x1 x2)
            (* Ja2 y1 y2)
    data JacobianIdentityLang
      : Set where
      0L : JacobianIdentityLang
      +L :
        JacobianIdentityLang ->
        JacobianIdentityLang ->
        JacobianIdentityLang
      *L :
        JacobianIdentityLang ->
        JacobianIdentityLang ->
        JacobianIdentityLang
    data JacobianIdentityOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        JacobianIdentityOpenLang n
      0OL : JacobianIdentityOpenLang n
      +OL :
        JacobianIdentityOpenLang n ->
        JacobianIdentityOpenLang n ->
        JacobianIdentityOpenLang n
      *OL :
        JacobianIdentityOpenLang n ->
        JacobianIdentityOpenLang n ->
        JacobianIdentityOpenLang n
    evalTerm :
      (A : Set) ->
      JacobianIdentity A ->
      JacobianIdentityLang -> A
    evalTerm _ Ja (0L) = 0 Ja
    evalTerm _ Ja (+L x1 x2) =
      + Ja (evalTerm _ Ja x1)
        (evalTerm _ Ja x2)
    evalTerm _ Ja (*L x1 x2) =
      * Ja (evalTerm _ Ja x1)
        (evalTerm _ Ja x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      JacobianIdentity A ->
      JacobianIdentityOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ja (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ja (0OL) vars =
      0 ja
    evalOpenTerm _ n ja (+OL
                         x1
                         x2) vars =
      + ja
        (evalOpenTerm _ n ja x1 vars)
        (evalOpenTerm _ n ja x2 vars)
    evalOpenTerm _ n ja (*OL
                         x1
                         x2) vars =
      * ja
        (evalOpenTerm _ n ja x1 vars)
        (evalOpenTerm _ n ja x2 vars)
    simplify :
      JacobianIdentityLang ->
      JacobianIdentityLang
    simplify (+L
              (+L
               (*L x (*L y z))
               (*L y (*L z x)))
              (*L z (*L x y))) = 0L
    simplify (0L) = 0L
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    liftJacobianIdentityLang :
      JacobianIdentityLang ->
      Staged JacobianIdentityLang
    liftJacobianIdentityLang x =
      Now x
    0OL' :
      (n : Nat) ->
      JacobianIdentityOpenLang n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      JacobianIdentityOpenLang n ->
      JacobianIdentityOpenLang n ->
      JacobianIdentityOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    *OL' :
      (n : Nat) ->
      JacobianIdentityOpenLang n ->
      JacobianIdentityOpenLang n ->
      JacobianIdentityOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    liftJacobianIdentityOpenLang :
      (n : Nat) ->
      JacobianIdentityOpenLang n ->
      Staged
        (JacobianIdentityOpenLang n)
    liftJacobianIdentityOpenLang _ (v
                                    fin) = const _ (code _ (v fin))
    liftJacobianIdentityOpenLang _ (0OL) =
      Now 0OL
    liftJacobianIdentityOpenLang _ (+OL
                                    x1
                                    x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftJacobianIdentityOpenLang _
           x1)
        (liftJacobianIdentityOpenLang _
           x2)
    liftJacobianIdentityOpenLang _ (*OL
                                    x1
                                    x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftJacobianIdentityOpenLang _
           x1)
        (liftJacobianIdentityOpenLang _
           x2)
  
  module JoinSemilattice where
    record JoinSemilattice
      (A : Set) : Set where
      constructor JoinSemilatticeC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
    record JoinSemilatticeSig
      (AS : Set) : Set where
      constructor JoinSemilatticeSigSigC
      field
        +S : AS -> AS -> AS
    record JoinSemilatticeProd
      (AP : Set) : Set where
      constructor JoinSemilatticeProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record JoinSemilatticeHom
      (A1 : Set) (A2 : Set)
      (Jo1 : JoinSemilattice A1)
      (Jo2 : JoinSemilattice A2) :
      Set where
      constructor JoinSemilatticeHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Jo1 x1 x2) ==
            + Jo2 (hom x1) (hom x2)
    record JoinSemilatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Jo1 : JoinSemilattice A1)
      (Jo2 : JoinSemilattice A2) :
      Set where
      constructor JoinSemilatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Jo1 x1 x2)
            (+ Jo2 y1 y2)
    data JoinSemilatticeLang
      : Set where
      +L :
        JoinSemilatticeLang ->
        JoinSemilatticeLang ->
        JoinSemilatticeLang
    data JoinSemilatticeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        JoinSemilatticeOpenLang n
      +OL :
        JoinSemilatticeOpenLang n ->
        JoinSemilatticeOpenLang n ->
        JoinSemilatticeOpenLang n
    evalTerm :
      (A : Set) ->
      JoinSemilattice A ->
      JoinSemilatticeLang -> A
    evalTerm _ Jo (+L x1 x2) =
      + Jo (evalTerm _ Jo x1)
        (evalTerm _ Jo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      JoinSemilattice A ->
      JoinSemilatticeOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n jo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n jo (+OL
                         x1
                         x2) vars =
      + jo
        (evalOpenTerm _ n jo x1 vars)
        (evalOpenTerm _ n jo x2 vars)
    simplify :
      JoinSemilatticeLang ->
      JoinSemilatticeLang
    simplify (+L x x) = x
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftJoinSemilatticeLang :
      JoinSemilatticeLang ->
      Staged JoinSemilatticeLang
    liftJoinSemilatticeLang x =
      Now x
    +OL' :
      (n : Nat) ->
      JoinSemilatticeOpenLang n ->
      JoinSemilatticeOpenLang n ->
      JoinSemilatticeOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftJoinSemilatticeOpenLang :
      (n : Nat) ->
      JoinSemilatticeOpenLang n ->
      Staged
        (JoinSemilatticeOpenLang n)
    liftJoinSemilatticeOpenLang _ (v
                                   fin) = const _ (code _ (v fin))
    liftJoinSemilatticeOpenLang _ (+OL
                                   x1
                                   x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftJoinSemilatticeOpenLang _
           x1)
        (liftJoinSemilatticeOpenLang _
           x2)
  
  module JoinSemilattice_RingoidSig where
    record JoinSemilattice_RingoidSig
      (A : Set) : Set where
      constructor JoinSemilattice_RingoidSigC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        * : A -> A -> A
    record JoinSemilattice_RingoidSigSig
      (AS : Set) : Set where
      constructor JoinSemilattice_RingoidSigSigSigC
      field
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
    record JoinSemilattice_RingoidSigProd
      (AP : Set) : Set where
      constructor JoinSemilattice_RingoidSigProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record JoinSemilattice_RingoidSigHom
      (A1 : Set) (A2 : Set)
      (Jo1 : JoinSemilattice_RingoidSig
         A1)
      (Jo2 : JoinSemilattice_RingoidSig
         A2) : Set where
      constructor JoinSemilattice_RingoidSigHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Jo1 x1 x2) ==
            + Jo2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Jo1 x1 x2) ==
            * Jo2 (hom x1) (hom x2)
    record JoinSemilattice_RingoidSigRelInterp
      (A1 : Set) (A2 : Set)
      (Jo1 : JoinSemilattice_RingoidSig
         A1)
      (Jo2 : JoinSemilattice_RingoidSig
         A2) : Set where
      constructor JoinSemilattice_RingoidSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Jo1 x1 x2)
            (+ Jo2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Jo1 x1 x2)
            (* Jo2 y1 y2)
    data JoinSemilattice_RingoidSigLang
      : Set where
      +L :
        JoinSemilattice_RingoidSigLang ->
        JoinSemilattice_RingoidSigLang ->
        JoinSemilattice_RingoidSigLang
      *L :
        JoinSemilattice_RingoidSigLang ->
        JoinSemilattice_RingoidSigLang ->
        JoinSemilattice_RingoidSigLang
    data JoinSemilattice_RingoidSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        JoinSemilattice_RingoidSigOpenLang
          n
      +OL :
        JoinSemilattice_RingoidSigOpenLang
          n ->
        JoinSemilattice_RingoidSigOpenLang
          n ->
        JoinSemilattice_RingoidSigOpenLang
          n
      *OL :
        JoinSemilattice_RingoidSigOpenLang
          n ->
        JoinSemilattice_RingoidSigOpenLang
          n ->
        JoinSemilattice_RingoidSigOpenLang
          n
    evalTerm :
      (A : Set) ->
      JoinSemilattice_RingoidSig A ->
      JoinSemilattice_RingoidSigLang ->
      A
    evalTerm _ Jo (+L x1 x2) =
      + Jo (evalTerm _ Jo x1)
        (evalTerm _ Jo x2)
    evalTerm _ Jo (*L x1 x2) =
      * Jo (evalTerm _ Jo x1)
        (evalTerm _ Jo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      JoinSemilattice_RingoidSig A ->
      JoinSemilattice_RingoidSigOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n jo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n jo (+OL
                         x1
                         x2) vars =
      + jo
        (evalOpenTerm _ n jo x1 vars)
        (evalOpenTerm _ n jo x2 vars)
    evalOpenTerm _ n jo (*OL
                         x1
                         x2) vars =
      * jo
        (evalOpenTerm _ n jo x1 vars)
        (evalOpenTerm _ n jo x2 vars)
    simplify :
      JoinSemilattice_RingoidSigLang ->
      JoinSemilattice_RingoidSigLang
    simplify (+L x x) = x
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    liftJoinSemilattice_RingoidSigLang :
      JoinSemilattice_RingoidSigLang ->
      Staged
        JoinSemilattice_RingoidSigLang
    liftJoinSemilattice_RingoidSigLang x =
      Now x
    +OL' :
      (n : Nat) ->
      JoinSemilattice_RingoidSigOpenLang
        n ->
      JoinSemilattice_RingoidSigOpenLang
        n ->
      JoinSemilattice_RingoidSigOpenLang
        n
    +OL' _ x1 x2 = +OL x1 x2
    *OL' :
      (n : Nat) ->
      JoinSemilattice_RingoidSigOpenLang
        n ->
      JoinSemilattice_RingoidSigOpenLang
        n ->
      JoinSemilattice_RingoidSigOpenLang
        n
    *OL' _ x1 x2 = *OL x1 x2
    liftJoinSemilattice_RingoidSigOpenLang :
      (n : Nat) ->
      JoinSemilattice_RingoidSigOpenLang
        n ->
      Staged
        (JoinSemilattice_RingoidSigOpenLang
           n)
    liftJoinSemilattice_RingoidSigOpenLang _ (v
                                              fin) = const _ (code _ (v fin))
    liftJoinSemilattice_RingoidSigOpenLang _ (+OL
                                              x1
                                              x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftJoinSemilattice_RingoidSigOpenLang
           _
           x1)
        (liftJoinSemilattice_RingoidSigOpenLang
           _
           x2)
    liftJoinSemilattice_RingoidSigOpenLang _ (*OL
                                              x1
                                              x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftJoinSemilattice_RingoidSigOpenLang
           _
           x1)
        (liftJoinSemilattice_RingoidSigOpenLang
           _
           x2)
  
  module Kei where
    record Kei (A : Set) : Set where
      constructor KeiC
      field
        |> : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        idempotent_|> :
          (x : A) -> |> x x == x
        rightSelfInverse_|> :
          (x : A) (y : A) ->
          |> (|> x y) y == x
    record KeiSig
      (AS : Set) : Set where
      constructor KeiSigSigC
      field
        |>S : AS -> AS -> AS
    record KeiProd
      (AP : Set) : Set where
      constructor KeiProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
        rightSelfInverse_|>P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          |>P (|>P xP yP) yP == xP
    record KeiHom
      (A1 : Set) (A2 : Set)
      (Ke1 : Kei A1)
      (Ke2 : Kei A2) : Set where
      constructor KeiHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ke1 x1 x2) ==
            |> Ke2 (hom x1) (hom x2)
    record KeiRelInterp
      (A1 : Set) (A2 : Set)
      (Ke1 : Kei A1)
      (Ke2 : Kei A2) : Set where
      constructor KeiRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ke1 x1 x2)
            (|> Ke2 y1 y2)
    data KeiLang : Set where
      |>L :
        KeiLang -> KeiLang -> KeiLang
    data KeiOpenLang
      (n : Nat) : Set where
      v : Fin n -> KeiOpenLang n
      |>OL :
        KeiOpenLang n ->
        KeiOpenLang n -> KeiOpenLang n
    evalTerm :
      (A : Set) ->
      Kei A -> KeiLang -> A
    evalTerm _ Ke (|>L x1 x2) =
      |> Ke (evalTerm _ Ke x1)
        (evalTerm _ Ke x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Kei A ->
      KeiOpenLang n -> Vec A n -> A
    evalOpenTerm _ n ke (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ke (|>OL
                         x1
                         x2) vars =
      |> ke
        (evalOpenTerm _ n ke x1 vars)
        (evalOpenTerm _ n ke x2 vars)
    simplify : KeiLang -> KeiLang
    simplify (|>L
              (|>L x y)
              (|>L x z)) = |>L x (|>L y z)
    simplify (|>L x x) = x
    simplify (|>L (|>L x y) y) = x
    simplify (|>L x1 x2) =
      |>L (simplify x1) (simplify x2)
    liftKeiLang :
      KeiLang -> Staged KeiLang
    liftKeiLang x = Now x
    |>OL' :
      (n : Nat) ->
      KeiOpenLang n ->
      KeiOpenLang n -> KeiOpenLang n
    |>OL' _ x1 x2 = |>OL x1 x2
    liftKeiOpenLang :
      (n : Nat) ->
      KeiOpenLang n ->
      Staged (KeiOpenLang n)
    liftKeiOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftKeiOpenLang _ (|>OL x1 x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (liftKeiOpenLang _ x1)
        (liftKeiOpenLang _ x2)
  
  module Lattice where
    record Lattice
      (A : Set) : Set where
      constructor LatticeC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
    record LatticeSig
      (AS : Set) : Set where
      constructor LatticeSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record LatticeProd
      (AP : Set) : Set where
      constructor LatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
    record LatticeHom
      (A1 : Set) (A2 : Set)
      (La1 : Lattice A1)
      (La2 : Lattice A2) : Set where
      constructor LatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* La1 x1 x2) ==
            * La2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ La1 x1 x2) ==
            + La2 (hom x1) (hom x2)
    record LatticeRelInterp
      (A1 : Set) (A2 : Set)
      (La1 : Lattice A1)
      (La2 : Lattice A2) : Set where
      constructor LatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* La1 x1 x2)
            (* La2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ La1 x1 x2)
            (+ La2 y1 y2)
    data LatticeLang : Set where
      *L :
        LatticeLang ->
        LatticeLang -> LatticeLang
      +L :
        LatticeLang ->
        LatticeLang -> LatticeLang
    data LatticeOpenLang
      (n : Nat) : Set where
      v : Fin n -> LatticeOpenLang n
      *OL :
        LatticeOpenLang n ->
        LatticeOpenLang n ->
        LatticeOpenLang n
      +OL :
        LatticeOpenLang n ->
        LatticeOpenLang n ->
        LatticeOpenLang n
    evalTerm :
      (A : Set) ->
      Lattice A -> LatticeLang -> A
    evalTerm _ La (*L x1 x2) =
      * La (evalTerm _ La x1)
        (evalTerm _ La x2)
    evalTerm _ La (+L x1 x2) =
      + La (evalTerm _ La x1)
        (evalTerm _ La x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Lattice A ->
      LatticeOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n la (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n la (*OL
                         x1
                         x2) vars =
      * la
        (evalOpenTerm _ n la x1 vars)
        (evalOpenTerm _ n la x2 vars)
    evalOpenTerm _ n la (+OL
                         x1
                         x2) vars =
      + la
        (evalOpenTerm _ n la x1 vars)
        (evalOpenTerm _ n la x2 vars)
    simplify :
      LatticeLang -> LatticeLang
    simplify (*L x x) = x
    simplify (+L x x) = x
    simplify (*L x (+L x y)) = x
    simplify (+L x (*L x y)) = x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftLatticeLang :
      LatticeLang ->
      Staged LatticeLang
    liftLatticeLang x = Now x
    *OL' :
      (n : Nat) ->
      LatticeOpenLang n ->
      LatticeOpenLang n ->
      LatticeOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      LatticeOpenLang n ->
      LatticeOpenLang n ->
      LatticeOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftLatticeOpenLang :
      (n : Nat) ->
      LatticeOpenLang n ->
      Staged (LatticeOpenLang n)
    liftLatticeOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftLatticeOpenLang _ (*OL
                           x1
                           x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftLatticeOpenLang _ x1)
        (liftLatticeOpenLang _ x2)
    liftLatticeOpenLang _ (+OL
                           x1
                           x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftLatticeOpenLang _ x1)
        (liftLatticeOpenLang _ x2)
  
  module Left0 where
    record Left0
      (A : Set) : Set where
      constructor Left0C
      field
        0 : A
        op : A -> A -> A
        leftZero_op_0 :
          (x : A) -> op 0 x == 0
    record Left0Sig
      (AS : Set) : Set where
      constructor Left0SigSigC
      field
        0S : AS
        opS : AS -> AS -> AS
    record Left0Prod
      (AP : Set) : Set where
      constructor Left0ProdC
      field
        0P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          opP 0P xP == 0P
    record Left0Hom
      (A1 : Set) (A2 : Set)
      (Le1 : Left0 A1)
      (Le2 : Left0 A2) : Set where
      constructor Left0HomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Le1) == 0 Le2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record Left0RelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : Left0 A1)
      (Le2 : Left0 A2) : Set where
      constructor Left0RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Le1) (0 Le2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data Left0Lang : Set where
      0L : Left0Lang
      opL :
        Left0Lang ->
        Left0Lang -> Left0Lang
    data Left0OpenLang
      (n : Nat) : Set where
      v : Fin n -> Left0OpenLang n
      0OL : Left0OpenLang n
      opOL :
        Left0OpenLang n ->
        Left0OpenLang n ->
        Left0OpenLang n
    evalTerm :
      (A : Set) ->
      Left0 A -> Left0Lang -> A
    evalTerm _ Le (0L) = 0 Le
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Left0 A ->
      Left0OpenLang n -> Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (0OL) vars =
      0 le
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    simplify :
      Left0Lang -> Left0Lang
    simplify (opL (0L) x) = 0L
    simplify (0L) = 0L
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftLeft0Lang :
      Left0Lang -> Staged Left0Lang
    liftLeft0Lang x = Now x
    0OL' :
      (n : Nat) -> Left0OpenLang n
    0OL' _ = 0OL
    opOL' :
      (n : Nat) ->
      Left0OpenLang n ->
      Left0OpenLang n ->
      Left0OpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftLeft0OpenLang :
      (n : Nat) ->
      Left0OpenLang n ->
      Staged (Left0OpenLang n)
    liftLeft0OpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftLeft0OpenLang _ (0OL) =
      Now 0OL
    liftLeft0OpenLang _ (opOL
                         x1
                         x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftLeft0OpenLang _ x1)
        (liftLeft0OpenLang _ x2)
  
  module LeftAbsorption where
    record LeftAbsorption
      (A : Set) : Set where
      constructor LeftAbsorptionC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
    record LeftAbsorptionSig
      (AS : Set) : Set where
      constructor LeftAbsorptionSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record LeftAbsorptionProd
      (AP : Set) : Set where
      constructor LeftAbsorptionProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
    record LeftAbsorptionHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftAbsorption A1)
      (Le2 : LeftAbsorption A2) :
      Set where
      constructor LeftAbsorptionHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Le1 x1 x2) ==
            * Le2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Le1 x1 x2) ==
            + Le2 (hom x1) (hom x2)
    record LeftAbsorptionRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftAbsorption A1)
      (Le2 : LeftAbsorption A2) :
      Set where
      constructor LeftAbsorptionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Le1 x1 x2)
            (* Le2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Le1 x1 x2)
            (+ Le2 y1 y2)
    data LeftAbsorptionLang
      : Set where
      *L :
        LeftAbsorptionLang ->
        LeftAbsorptionLang ->
        LeftAbsorptionLang
      +L :
        LeftAbsorptionLang ->
        LeftAbsorptionLang ->
        LeftAbsorptionLang
    data LeftAbsorptionOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftAbsorptionOpenLang n
      *OL :
        LeftAbsorptionOpenLang n ->
        LeftAbsorptionOpenLang n ->
        LeftAbsorptionOpenLang n
      +OL :
        LeftAbsorptionOpenLang n ->
        LeftAbsorptionOpenLang n ->
        LeftAbsorptionOpenLang n
    evalTerm :
      (A : Set) ->
      LeftAbsorption A ->
      LeftAbsorptionLang -> A
    evalTerm _ Le (*L x1 x2) =
      * Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (+L x1 x2) =
      + Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftAbsorption A ->
      LeftAbsorptionOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (*OL
                         x1
                         x2) vars =
      * le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (+OL
                         x1
                         x2) vars =
      + le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    simplify :
      LeftAbsorptionLang ->
      LeftAbsorptionLang
    simplify (*L x (+L x y)) = x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftLeftAbsorptionLang :
      LeftAbsorptionLang ->
      Staged LeftAbsorptionLang
    liftLeftAbsorptionLang x = Now x
    *OL' :
      (n : Nat) ->
      LeftAbsorptionOpenLang n ->
      LeftAbsorptionOpenLang n ->
      LeftAbsorptionOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      LeftAbsorptionOpenLang n ->
      LeftAbsorptionOpenLang n ->
      LeftAbsorptionOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftLeftAbsorptionOpenLang :
      (n : Nat) ->
      LeftAbsorptionOpenLang n ->
      Staged
        (LeftAbsorptionOpenLang n)
    liftLeftAbsorptionOpenLang _ (v
                                  fin) = const _ (code _ (v fin))
    liftLeftAbsorptionOpenLang _ (*OL
                                  x1
                                  x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftLeftAbsorptionOpenLang _
           x1)
        (liftLeftAbsorptionOpenLang _
           x2)
    liftLeftAbsorptionOpenLang _ (+OL
                                  x1
                                  x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftLeftAbsorptionOpenLang _
           x1)
        (liftLeftAbsorptionOpenLang _
           x2)
  
  module LeftAbsorptionOp where
    record LeftAbsorptionOp
      (A : Set) : Set where
      constructor LeftAbsorptionOpC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
    record LeftAbsorptionOpSig
      (AS : Set) : Set where
      constructor LeftAbsorptionOpSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record LeftAbsorptionOpProd
      (AP : Set) : Set where
      constructor LeftAbsorptionOpProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
    record LeftAbsorptionOpHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftAbsorptionOp A1)
      (Le2 : LeftAbsorptionOp A2) :
      Set where
      constructor LeftAbsorptionOpHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Le1 x1 x2) ==
            * Le2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Le1 x1 x2) ==
            + Le2 (hom x1) (hom x2)
    record LeftAbsorptionOpRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftAbsorptionOp A1)
      (Le2 : LeftAbsorptionOp A2) :
      Set where
      constructor LeftAbsorptionOpRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Le1 x1 x2)
            (* Le2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Le1 x1 x2)
            (+ Le2 y1 y2)
    data LeftAbsorptionOpLang
      : Set where
      *L :
        LeftAbsorptionOpLang ->
        LeftAbsorptionOpLang ->
        LeftAbsorptionOpLang
      +L :
        LeftAbsorptionOpLang ->
        LeftAbsorptionOpLang ->
        LeftAbsorptionOpLang
    data LeftAbsorptionOpOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftAbsorptionOpOpenLang n
      *OL :
        LeftAbsorptionOpOpenLang n ->
        LeftAbsorptionOpOpenLang n ->
        LeftAbsorptionOpOpenLang n
      +OL :
        LeftAbsorptionOpOpenLang n ->
        LeftAbsorptionOpOpenLang n ->
        LeftAbsorptionOpOpenLang n
    evalTerm :
      (A : Set) ->
      LeftAbsorptionOp A ->
      LeftAbsorptionOpLang -> A
    evalTerm _ Le (*L x1 x2) =
      * Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (+L x1 x2) =
      + Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftAbsorptionOp A ->
      LeftAbsorptionOpOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (*OL
                         x1
                         x2) vars =
      * le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (+OL
                         x1
                         x2) vars =
      + le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    simplify :
      LeftAbsorptionOpLang ->
      LeftAbsorptionOpLang
    simplify (+L x (*L x y)) = x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftLeftAbsorptionOpLang :
      LeftAbsorptionOpLang ->
      Staged LeftAbsorptionOpLang
    liftLeftAbsorptionOpLang x =
      Now x
    *OL' :
      (n : Nat) ->
      LeftAbsorptionOpOpenLang n ->
      LeftAbsorptionOpOpenLang n ->
      LeftAbsorptionOpOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      LeftAbsorptionOpOpenLang n ->
      LeftAbsorptionOpOpenLang n ->
      LeftAbsorptionOpOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftLeftAbsorptionOpOpenLang :
      (n : Nat) ->
      LeftAbsorptionOpOpenLang n ->
      Staged
        (LeftAbsorptionOpOpenLang n)
    liftLeftAbsorptionOpOpenLang _ (v
                                    fin) = const _ (code _ (v fin))
    liftLeftAbsorptionOpOpenLang _ (*OL
                                    x1
                                    x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftLeftAbsorptionOpOpenLang _
           x1)
        (liftLeftAbsorptionOpOpenLang _
           x2)
    liftLeftAbsorptionOpOpenLang _ (+OL
                                    x1
                                    x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftLeftAbsorptionOpOpenLang _
           x1)
        (liftLeftAbsorptionOpOpenLang _
           x2)
  
  module LeftBiMagma where
    record LeftBiMagma
      (A : Set) : Set where
      constructor LeftBiMagmaC
      field
        op : A -> A -> A
        linv : A -> A -> A
    record LeftBiMagmaSig
      (AS : Set) : Set where
      constructor LeftBiMagmaSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
    record LeftBiMagmaProd
      (AP : Set) : Set where
      constructor LeftBiMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record LeftBiMagmaHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftBiMagma A1)
      (Le2 : LeftBiMagma A2) :
      Set where
      constructor LeftBiMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Le1 x1 x2) ==
            linv Le2 (hom x1) (hom x2)
    record LeftBiMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftBiMagma A1)
      (Le2 : LeftBiMagma A2) :
      Set where
      constructor LeftBiMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Le1 x1 x2)
            (linv Le2 y1 y2)
    data LeftBiMagmaLang : Set where
      opL :
        LeftBiMagmaLang ->
        LeftBiMagmaLang ->
        LeftBiMagmaLang
      linvL :
        LeftBiMagmaLang ->
        LeftBiMagmaLang ->
        LeftBiMagmaLang
    data LeftBiMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> LeftBiMagmaOpenLang n
      opOL :
        LeftBiMagmaOpenLang n ->
        LeftBiMagmaOpenLang n ->
        LeftBiMagmaOpenLang n
      linvOL :
        LeftBiMagmaOpenLang n ->
        LeftBiMagmaOpenLang n ->
        LeftBiMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      LeftBiMagma A ->
      LeftBiMagmaLang -> A
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (linvL x1 x2) =
      linv Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftBiMagma A ->
      LeftBiMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (linvOL
                         x1
                         x2) vars =
      linv le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    simplify :
      LeftBiMagmaLang ->
      LeftBiMagmaLang
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (linvL x1 x2) =
      linvL (simplify x1)
        (simplify x2)
    liftLeftBiMagmaLang :
      LeftBiMagmaLang ->
      Staged LeftBiMagmaLang
    liftLeftBiMagmaLang x = Now x
    opOL' :
      (n : Nat) ->
      LeftBiMagmaOpenLang n ->
      LeftBiMagmaOpenLang n ->
      LeftBiMagmaOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    linvOL' :
      (n : Nat) ->
      LeftBiMagmaOpenLang n ->
      LeftBiMagmaOpenLang n ->
      LeftBiMagmaOpenLang n
    linvOL' _ x1 x2 = linvOL x1 x2
    liftLeftBiMagmaOpenLang :
      (n : Nat) ->
      LeftBiMagmaOpenLang n ->
      Staged (LeftBiMagmaOpenLang n)
    liftLeftBiMagmaOpenLang _ (v
                               fin) = const _ (code _ (v fin))
    liftLeftBiMagmaOpenLang _ (opOL
                               x1
                               x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftLeftBiMagmaOpenLang _ x1)
        (liftLeftBiMagmaOpenLang _ x2)
    liftLeftBiMagmaOpenLang _ (linvOL
                               x1
                               x2) =
      stage2 _ _ _ (linvOL' _)
        (codeLift2 _ _ _ (linvOL' _))
        (liftLeftBiMagmaOpenLang _ x1)
        (liftLeftBiMagmaOpenLang _ x2)
  
  module LeftBinaryInverse where
    record LeftBinaryInverse
      (A : Set) : Set where
      constructor LeftBinaryInverseC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftInverse :
          (x : A) (y : A) ->
          <| (|> x y) x == y
    record LeftBinaryInverseSig
      (AS : Set) : Set where
      constructor LeftBinaryInverseSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record LeftBinaryInverseProd
      (AP : Set) : Set where
      constructor LeftBinaryInverseProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          <|P (|>P xP yP) xP == yP
    record LeftBinaryInverseHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftBinaryInverse A1)
      (Le2 : LeftBinaryInverse A2) :
      Set where
      constructor LeftBinaryInverseHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Le1 x1 x2) ==
            <| Le2 (hom x1) (hom x2)
    record LeftBinaryInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftBinaryInverse A1)
      (Le2 : LeftBinaryInverse A2) :
      Set where
      constructor LeftBinaryInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Le1 x1 x2)
            (<| Le2 y1 y2)
    data LeftBinaryInverseLang
      : Set where
      |>L :
        LeftBinaryInverseLang ->
        LeftBinaryInverseLang ->
        LeftBinaryInverseLang
      <|L :
        LeftBinaryInverseLang ->
        LeftBinaryInverseLang ->
        LeftBinaryInverseLang
    data LeftBinaryInverseOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftBinaryInverseOpenLang n
      |>OL :
        LeftBinaryInverseOpenLang n ->
        LeftBinaryInverseOpenLang n ->
        LeftBinaryInverseOpenLang n
      <|OL :
        LeftBinaryInverseOpenLang n ->
        LeftBinaryInverseOpenLang n ->
        LeftBinaryInverseOpenLang n
    evalTerm :
      (A : Set) ->
      LeftBinaryInverse A ->
      LeftBinaryInverseLang -> A
    evalTerm _ Le (|>L x1 x2) =
      |> Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (<|L x1 x2) =
      <| Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftBinaryInverse A ->
      LeftBinaryInverseOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (|>OL
                         x1
                         x2) vars =
      |> le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (<|OL
                         x1
                         x2) vars =
      <| le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    simplify :
      LeftBinaryInverseLang ->
      LeftBinaryInverseLang
    simplify (<|L (|>L x y) x) = y
    simplify (|>L x1 x2) =
      |>L (simplify x1) (simplify x2)
    simplify (<|L x1 x2) =
      <|L (simplify x1) (simplify x2)
    liftLeftBinaryInverseLang :
      LeftBinaryInverseLang ->
      Staged LeftBinaryInverseLang
    liftLeftBinaryInverseLang x =
      Now x
    |>OL' :
      (n : Nat) ->
      LeftBinaryInverseOpenLang n ->
      LeftBinaryInverseOpenLang n ->
      LeftBinaryInverseOpenLang n
    |>OL' _ x1 x2 = |>OL x1 x2
    <|OL' :
      (n : Nat) ->
      LeftBinaryInverseOpenLang n ->
      LeftBinaryInverseOpenLang n ->
      LeftBinaryInverseOpenLang n
    <|OL' _ x1 x2 = <|OL x1 x2
    liftLeftBinaryInverseOpenLang :
      (n : Nat) ->
      LeftBinaryInverseOpenLang n ->
      Staged
        (LeftBinaryInverseOpenLang n)
    liftLeftBinaryInverseOpenLang _ (v
                                     fin) = const _ (code _ (v fin))
    liftLeftBinaryInverseOpenLang _ (|>OL
                                     x1
                                     x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (liftLeftBinaryInverseOpenLang _
           x1)
        (liftLeftBinaryInverseOpenLang _
           x2)
    liftLeftBinaryInverseOpenLang _ (<|OL
                                     x1
                                     x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (liftLeftBinaryInverseOpenLang _
           x1)
        (liftLeftBinaryInverseOpenLang _
           x2)
  
  module LeftCancellative where
    record LeftCancellative
      (A : Set) : Set where
      constructor LeftCancellativeC
      field
        op : A -> A -> A
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
    record LeftCancellativeSig
      (AS : Set) : Set where
      constructor LeftCancellativeSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
    record LeftCancellativeProd
      (AP : Set) : Set where
      constructor LeftCancellativeProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
    record LeftCancellativeHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellative A1)
      (Le2 : LeftCancellative A2) :
      Set where
      constructor LeftCancellativeHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Le1 x1 x2) ==
            linv Le2 (hom x1) (hom x2)
    record LeftCancellativeRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellative A1)
      (Le2 : LeftCancellative A2) :
      Set where
      constructor LeftCancellativeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Le1 x1 x2)
            (linv Le2 y1 y2)
    data LeftCancellativeLang
      : Set where
      opL :
        LeftCancellativeLang ->
        LeftCancellativeLang ->
        LeftCancellativeLang
      linvL :
        LeftCancellativeLang ->
        LeftCancellativeLang ->
        LeftCancellativeLang
    data LeftCancellativeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftCancellativeOpenLang n
      opOL :
        LeftCancellativeOpenLang n ->
        LeftCancellativeOpenLang n ->
        LeftCancellativeOpenLang n
      linvOL :
        LeftCancellativeOpenLang n ->
        LeftCancellativeOpenLang n ->
        LeftCancellativeOpenLang n
    evalTerm :
      (A : Set) ->
      LeftCancellative A ->
      LeftCancellativeLang -> A
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (linvL x1 x2) =
      linv Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftCancellative A ->
      LeftCancellativeOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (linvOL
                         x1
                         x2) vars =
      linv le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    simplify :
      LeftCancellativeLang ->
      LeftCancellativeLang
    simplify (opL x (linvL x y)) = y
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (linvL x1 x2) =
      linvL (simplify x1)
        (simplify x2)
    liftLeftCancellativeLang :
      LeftCancellativeLang ->
      Staged LeftCancellativeLang
    liftLeftCancellativeLang x =
      Now x
    opOL' :
      (n : Nat) ->
      LeftCancellativeOpenLang n ->
      LeftCancellativeOpenLang n ->
      LeftCancellativeOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    linvOL' :
      (n : Nat) ->
      LeftCancellativeOpenLang n ->
      LeftCancellativeOpenLang n ->
      LeftCancellativeOpenLang n
    linvOL' _ x1 x2 = linvOL x1 x2
    liftLeftCancellativeOpenLang :
      (n : Nat) ->
      LeftCancellativeOpenLang n ->
      Staged
        (LeftCancellativeOpenLang n)
    liftLeftCancellativeOpenLang _ (v
                                    fin) = const _ (code _ (v fin))
    liftLeftCancellativeOpenLang _ (opOL
                                    x1
                                    x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftLeftCancellativeOpenLang _
           x1)
        (liftLeftCancellativeOpenLang _
           x2)
    liftLeftCancellativeOpenLang _ (linvOL
                                    x1
                                    x2) =
      stage2 _ _ _ (linvOL' _)
        (codeLift2 _ _ _ (linvOL' _))
        (liftLeftCancellativeOpenLang _
           x1)
        (liftLeftCancellativeOpenLang _
           x2)
  
  module LeftCancellativeMagma where
    record LeftCancellativeMagma
      (A : Set) : Set where
      constructor LeftCancellativeMagmaC
      field
        op : A -> A -> A
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
    record LeftCancellativeMagmaSig
      (AS : Set) : Set where
      constructor LeftCancellativeMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record LeftCancellativeMagmaProd
      (AP : Set) : Set where
      constructor LeftCancellativeMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
    record LeftCancellativeMagmaHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellativeMagma A1)
      (Le2 : LeftCancellativeMagma
         A2) : Set where
      constructor LeftCancellativeMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record LeftCancellativeMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellativeMagma A1)
      (Le2 : LeftCancellativeMagma
         A2) : Set where
      constructor LeftCancellativeMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data LeftCancellativeMagmaLang
      : Set where
      opL :
        LeftCancellativeMagmaLang ->
        LeftCancellativeMagmaLang ->
        LeftCancellativeMagmaLang
    data LeftCancellativeMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftCancellativeMagmaOpenLang n
      opOL :
        LeftCancellativeMagmaOpenLang
          n ->
        LeftCancellativeMagmaOpenLang
          n ->
        LeftCancellativeMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      LeftCancellativeMagma A ->
      LeftCancellativeMagmaLang -> A
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftCancellativeMagma A ->
      LeftCancellativeMagmaOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    simplify :
      LeftCancellativeMagmaLang ->
      LeftCancellativeMagmaLang
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftLeftCancellativeMagmaLang :
      LeftCancellativeMagmaLang ->
      Staged LeftCancellativeMagmaLang
    liftLeftCancellativeMagmaLang x =
      Now x
    opOL' :
      (n : Nat) ->
      LeftCancellativeMagmaOpenLang
        n ->
      LeftCancellativeMagmaOpenLang
        n ->
      LeftCancellativeMagmaOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftLeftCancellativeMagmaOpenLang :
      (n : Nat) ->
      LeftCancellativeMagmaOpenLang
        n ->
      Staged
        (LeftCancellativeMagmaOpenLang
           n)
    liftLeftCancellativeMagmaOpenLang _ (v
                                         fin) = const _ (code _ (v fin))
    liftLeftCancellativeMagmaOpenLang _ (opOL
                                         x1
                                         x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftLeftCancellativeMagmaOpenLang
           _
           x1)
        (liftLeftCancellativeMagmaOpenLang
           _
           x2)
  
  module LeftCancellativeOp where
    record LeftCancellativeOp
      (A : Set) : Set where
      constructor LeftCancellativeOpC
      field
        op : A -> A -> A
        linv : A -> A -> A
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
    record LeftCancellativeOpSig
      (AS : Set) : Set where
      constructor LeftCancellativeOpSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
    record LeftCancellativeOpProd
      (AP : Set) : Set where
      constructor LeftCancellativeOpProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
    record LeftCancellativeOpHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellativeOp A1)
      (Le2 : LeftCancellativeOp A2) :
      Set where
      constructor LeftCancellativeOpHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Le1 x1 x2) ==
            linv Le2 (hom x1) (hom x2)
    record LeftCancellativeOpRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellativeOp A1)
      (Le2 : LeftCancellativeOp A2) :
      Set where
      constructor LeftCancellativeOpRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Le1 x1 x2)
            (linv Le2 y1 y2)
    data LeftCancellativeOpLang
      : Set where
      opL :
        LeftCancellativeOpLang ->
        LeftCancellativeOpLang ->
        LeftCancellativeOpLang
      linvL :
        LeftCancellativeOpLang ->
        LeftCancellativeOpLang ->
        LeftCancellativeOpLang
    data LeftCancellativeOpOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftCancellativeOpOpenLang n
      opOL :
        LeftCancellativeOpOpenLang n ->
        LeftCancellativeOpOpenLang n ->
        LeftCancellativeOpOpenLang n
      linvOL :
        LeftCancellativeOpOpenLang n ->
        LeftCancellativeOpOpenLang n ->
        LeftCancellativeOpOpenLang n
    evalTerm :
      (A : Set) ->
      LeftCancellativeOp A ->
      LeftCancellativeOpLang -> A
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (linvL x1 x2) =
      linv Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftCancellativeOp A ->
      LeftCancellativeOpOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (linvOL
                         x1
                         x2) vars =
      linv le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    simplify :
      LeftCancellativeOpLang ->
      LeftCancellativeOpLang
    simplify (linvL x (opL x y)) = y
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (linvL x1 x2) =
      linvL (simplify x1)
        (simplify x2)
    liftLeftCancellativeOpLang :
      LeftCancellativeOpLang ->
      Staged LeftCancellativeOpLang
    liftLeftCancellativeOpLang x =
      Now x
    opOL' :
      (n : Nat) ->
      LeftCancellativeOpOpenLang n ->
      LeftCancellativeOpOpenLang n ->
      LeftCancellativeOpOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    linvOL' :
      (n : Nat) ->
      LeftCancellativeOpOpenLang n ->
      LeftCancellativeOpOpenLang n ->
      LeftCancellativeOpOpenLang n
    linvOL' _ x1 x2 = linvOL x1 x2
    liftLeftCancellativeOpOpenLang :
      (n : Nat) ->
      LeftCancellativeOpOpenLang n ->
      Staged
        (LeftCancellativeOpOpenLang n)
    liftLeftCancellativeOpOpenLang _ (v
                                      fin) = const _ (code _ (v fin))
    liftLeftCancellativeOpOpenLang _ (opOL
                                      x1
                                      x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftLeftCancellativeOpOpenLang
           _
           x1)
        (liftLeftCancellativeOpOpenLang
           _
           x2)
    liftLeftCancellativeOpOpenLang _ (linvOL
                                      x1
                                      x2) =
      stage2 _ _ _ (linvOL' _)
        (codeLift2 _ _ _ (linvOL' _))
        (liftLeftCancellativeOpOpenLang
           _
           x1)
        (liftLeftCancellativeOpOpenLang
           _
           x2)
  
  module LeftCancellativeSemigroup where
    record LeftCancellativeSemigroup
      (A : Set) : Set where
      constructor LeftCancellativeSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
    record LeftCancellativeSemigroupSig
      (AS : Set) : Set where
      constructor LeftCancellativeSemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record LeftCancellativeSemigroupProd
      (AP : Set) : Set where
      constructor LeftCancellativeSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
    record LeftCancellativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellativeSemigroup
         A1)
      (Le2 : LeftCancellativeSemigroup
         A2) : Set where
      constructor LeftCancellativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record LeftCancellativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellativeSemigroup
         A1)
      (Le2 : LeftCancellativeSemigroup
         A2) : Set where
      constructor LeftCancellativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data LeftCancellativeSemigroupLang
      : Set where
      opL :
        LeftCancellativeSemigroupLang ->
        LeftCancellativeSemigroupLang ->
        LeftCancellativeSemigroupLang
    data LeftCancellativeSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftCancellativeSemigroupOpenLang
          n
      opOL :
        LeftCancellativeSemigroupOpenLang
          n ->
        LeftCancellativeSemigroupOpenLang
          n ->
        LeftCancellativeSemigroupOpenLang
          n
    evalTerm :
      (A : Set) ->
      LeftCancellativeSemigroup A ->
      LeftCancellativeSemigroupLang ->
      A
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftCancellativeSemigroup A ->
      LeftCancellativeSemigroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    simplify :
      LeftCancellativeSemigroupLang ->
      LeftCancellativeSemigroupLang
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftLeftCancellativeSemigroupLang :
      LeftCancellativeSemigroupLang ->
      Staged
        LeftCancellativeSemigroupLang
    liftLeftCancellativeSemigroupLang x =
      Now x
    opOL' :
      (n : Nat) ->
      LeftCancellativeSemigroupOpenLang
        n ->
      LeftCancellativeSemigroupOpenLang
        n ->
      LeftCancellativeSemigroupOpenLang
        n
    opOL' _ x1 x2 = opOL x1 x2
    liftLeftCancellativeSemigroupOpenLang :
      (n : Nat) ->
      LeftCancellativeSemigroupOpenLang
        n ->
      Staged
        (LeftCancellativeSemigroupOpenLang
           n)
    liftLeftCancellativeSemigroupOpenLang _ (v
                                             fin) = const _ (code _ (v fin))
    liftLeftCancellativeSemigroupOpenLang _ (opOL
                                             x1
                                             x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftLeftCancellativeSemigroupOpenLang
           _
           x1)
        (liftLeftCancellativeSemigroupOpenLang
           _
           x2)
  
  module LeftDistributiveMagma where
    record LeftDistributiveMagma
      (A : Set) : Set where
      constructor LeftDistributiveMagmaC
      field
        op : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          op x (op y z) ==
            op (op x y) (op x z)
    record LeftDistributiveMagmaSig
      (AS : Set) : Set where
      constructor LeftDistributiveMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record LeftDistributiveMagmaProd
      (AP : Set) : Set where
      constructor LeftDistributiveMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP (opP yP zP) ==
            opP (opP xP yP) (opP xP zP)
    record LeftDistributiveMagmaHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftDistributiveMagma A1)
      (Le2 : LeftDistributiveMagma
         A2) : Set where
      constructor LeftDistributiveMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record LeftDistributiveMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftDistributiveMagma A1)
      (Le2 : LeftDistributiveMagma
         A2) : Set where
      constructor LeftDistributiveMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data LeftDistributiveMagmaLang
      : Set where
      opL :
        LeftDistributiveMagmaLang ->
        LeftDistributiveMagmaLang ->
        LeftDistributiveMagmaLang
    data LeftDistributiveMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftDistributiveMagmaOpenLang n
      opOL :
        LeftDistributiveMagmaOpenLang
          n ->
        LeftDistributiveMagmaOpenLang
          n ->
        LeftDistributiveMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      LeftDistributiveMagma A ->
      LeftDistributiveMagmaLang -> A
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftDistributiveMagma A ->
      LeftDistributiveMagmaOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    simplify :
      LeftDistributiveMagmaLang ->
      LeftDistributiveMagmaLang
    simplify (opL
              (opL x y)
              (opL x z)) = opL x (opL y z)
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftLeftDistributiveMagmaLang :
      LeftDistributiveMagmaLang ->
      Staged LeftDistributiveMagmaLang
    liftLeftDistributiveMagmaLang x =
      Now x
    opOL' :
      (n : Nat) ->
      LeftDistributiveMagmaOpenLang
        n ->
      LeftDistributiveMagmaOpenLang
        n ->
      LeftDistributiveMagmaOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftLeftDistributiveMagmaOpenLang :
      (n : Nat) ->
      LeftDistributiveMagmaOpenLang
        n ->
      Staged
        (LeftDistributiveMagmaOpenLang
           n)
    liftLeftDistributiveMagmaOpenLang _ (v
                                         fin) = const _ (code _ (v fin))
    liftLeftDistributiveMagmaOpenLang _ (opOL
                                         x1
                                         x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftLeftDistributiveMagmaOpenLang
           _
           x1)
        (liftLeftDistributiveMagmaOpenLang
           _
           x2)
  
  module LeftIdempotence where
    record LeftIdempotence
      (A : Set) : Set where
      constructor LeftIdempotenceC
      field
        |> : A -> A -> A
        idempotent_|> :
          (x : A) -> |> x x == x
    record LeftIdempotenceSig
      (AS : Set) : Set where
      constructor LeftIdempotenceSigSigC
      field
        |>S : AS -> AS -> AS
    record LeftIdempotenceProd
      (AP : Set) : Set where
      constructor LeftIdempotenceProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
    record LeftIdempotenceHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftIdempotence A1)
      (Le2 : LeftIdempotence A2) :
      Set where
      constructor LeftIdempotenceHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
    record LeftIdempotenceRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftIdempotence A1)
      (Le2 : LeftIdempotence A2) :
      Set where
      constructor LeftIdempotenceRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
    data LeftIdempotenceLang
      : Set where
      |>L :
        LeftIdempotenceLang ->
        LeftIdempotenceLang ->
        LeftIdempotenceLang
    data LeftIdempotenceOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftIdempotenceOpenLang n
      |>OL :
        LeftIdempotenceOpenLang n ->
        LeftIdempotenceOpenLang n ->
        LeftIdempotenceOpenLang n
    evalTerm :
      (A : Set) ->
      LeftIdempotence A ->
      LeftIdempotenceLang -> A
    evalTerm _ Le (|>L x1 x2) =
      |> Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftIdempotence A ->
      LeftIdempotenceOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (|>OL
                         x1
                         x2) vars =
      |> le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    simplify :
      LeftIdempotenceLang ->
      LeftIdempotenceLang
    simplify (|>L x x) = x
    simplify (|>L x1 x2) =
      |>L (simplify x1) (simplify x2)
    liftLeftIdempotenceLang :
      LeftIdempotenceLang ->
      Staged LeftIdempotenceLang
    liftLeftIdempotenceLang x =
      Now x
    |>OL' :
      (n : Nat) ->
      LeftIdempotenceOpenLang n ->
      LeftIdempotenceOpenLang n ->
      LeftIdempotenceOpenLang n
    |>OL' _ x1 x2 = |>OL x1 x2
    liftLeftIdempotenceOpenLang :
      (n : Nat) ->
      LeftIdempotenceOpenLang n ->
      Staged
        (LeftIdempotenceOpenLang n)
    liftLeftIdempotenceOpenLang _ (v
                                   fin) = const _ (code _ (v fin))
    liftLeftIdempotenceOpenLang _ (|>OL
                                   x1
                                   x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (liftLeftIdempotenceOpenLang _
           x1)
        (liftLeftIdempotenceOpenLang _
           x2)
  
  module LeftInverse where
    record LeftInverse
      (A : Set) : Set where
      constructor LeftInverseC
      field
        inv : A -> A
        e : A
        op : A -> A -> A
        leftInverse_inv_op_e :
          (x : A) -> op x (inv x) == e
    record LeftInverseSig
      (AS : Set) : Set where
      constructor LeftInverseSigSigC
      field
        invS : AS -> AS
        eS : AS
        opS : AS -> AS -> AS
    record LeftInverseProd
      (AP : Set) : Set where
      constructor LeftInverseProdC
      field
        invP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP xP (invP xP) == eP
    record LeftInverseHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftInverse A1)
      (Le2 : LeftInverse A2) :
      Set where
      constructor LeftInverseHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv Le1 x1) ==
            inv Le2 (hom x1)
        pres-e : hom (e Le1) == e Le2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record LeftInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftInverse A1)
      (Le2 : LeftInverse A2) :
      Set where
      constructor LeftInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Le1 x1) (inv Le2 y1)
        interp-e :
          interp (e Le1) (e Le2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data LeftInverseLang : Set where
      invL :
        LeftInverseLang ->
        LeftInverseLang
      eL : LeftInverseLang
      opL :
        LeftInverseLang ->
        LeftInverseLang ->
        LeftInverseLang
    data LeftInverseOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> LeftInverseOpenLang n
      invOL :
        LeftInverseOpenLang n ->
        LeftInverseOpenLang n
      eOL : LeftInverseOpenLang n
      opOL :
        LeftInverseOpenLang n ->
        LeftInverseOpenLang n ->
        LeftInverseOpenLang n
    evalTerm :
      (A : Set) ->
      LeftInverse A ->
      LeftInverseLang -> A
    evalTerm _ Le (invL x1) =
      inv Le (evalTerm _ Le x1)
    evalTerm _ Le (eL) = e Le
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftInverse A ->
      LeftInverseOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (invOL
                         x1) vars =
      inv le
        (evalOpenTerm _ n le x1 vars)
    evalOpenTerm _ n le (eOL) vars =
      e le
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    simplify :
      LeftInverseLang ->
      LeftInverseLang
    simplify (opL x (invL x)) = eL
    simplify (invL x1) =
      invL (simplify x1)
    simplify (eL) = eL
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftLeftInverseLang :
      LeftInverseLang ->
      Staged LeftInverseLang
    liftLeftInverseLang x = Now x
    invOL' :
      (n : Nat) ->
      LeftInverseOpenLang n ->
      LeftInverseOpenLang n
    invOL' _ x1 = invOL x1
    eOL' :
      (n : Nat) ->
      LeftInverseOpenLang n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      LeftInverseOpenLang n ->
      LeftInverseOpenLang n ->
      LeftInverseOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftLeftInverseOpenLang :
      (n : Nat) ->
      LeftInverseOpenLang n ->
      Staged (LeftInverseOpenLang n)
    liftLeftInverseOpenLang _ (v
                               fin) = const _ (code _ (v fin))
    liftLeftInverseOpenLang _ (invOL
                               x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (liftLeftInverseOpenLang _ x1)
    liftLeftInverseOpenLang _ (eOL) =
      Now eOL
    liftLeftInverseOpenLang _ (opOL
                               x1
                               x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftLeftInverseOpenLang _ x1)
        (liftLeftInverseOpenLang _ x2)
  
  module LeftInverseMagma where
    record LeftInverseMagma
      (A : Set) : Set where
      constructor LeftInverseMagmaC
      field
        linv : A -> A -> A
    record LeftInverseMagmaSig
      (AS : Set) : Set where
      constructor LeftInverseMagmaSigSigC
      field
        linvS : AS -> AS -> AS
    record LeftInverseMagmaProd
      (AP : Set) : Set where
      constructor LeftInverseMagmaProdC
      field
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record LeftInverseMagmaHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftInverseMagma A1)
      (Le2 : LeftInverseMagma A2) :
      Set where
      constructor LeftInverseMagmaHomC
      field
        hom : A1 -> A2
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Le1 x1 x2) ==
            linv Le2 (hom x1) (hom x2)
    record LeftInverseMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftInverseMagma A1)
      (Le2 : LeftInverseMagma A2) :
      Set where
      constructor LeftInverseMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Le1 x1 x2)
            (linv Le2 y1 y2)
    data LeftInverseMagmaLang
      : Set where
      linvL :
        LeftInverseMagmaLang ->
        LeftInverseMagmaLang ->
        LeftInverseMagmaLang
    data LeftInverseMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftInverseMagmaOpenLang n
      linvOL :
        LeftInverseMagmaOpenLang n ->
        LeftInverseMagmaOpenLang n ->
        LeftInverseMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      LeftInverseMagma A ->
      LeftInverseMagmaLang -> A
    evalTerm _ Le (linvL x1 x2) =
      linv Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftInverseMagma A ->
      LeftInverseMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (linvOL
                         x1
                         x2) vars =
      linv le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    simplify :
      LeftInverseMagmaLang ->
      LeftInverseMagmaLang
    simplify (linvL x1 x2) =
      linvL (simplify x1)
        (simplify x2)
    liftLeftInverseMagmaLang :
      LeftInverseMagmaLang ->
      Staged LeftInverseMagmaLang
    liftLeftInverseMagmaLang x =
      Now x
    linvOL' :
      (n : Nat) ->
      LeftInverseMagmaOpenLang n ->
      LeftInverseMagmaOpenLang n ->
      LeftInverseMagmaOpenLang n
    linvOL' _ x1 x2 = linvOL x1 x2
    liftLeftInverseMagmaOpenLang :
      (n : Nat) ->
      LeftInverseMagmaOpenLang n ->
      Staged
        (LeftInverseMagmaOpenLang n)
    liftLeftInverseMagmaOpenLang _ (v
                                    fin) = const _ (code _ (v fin))
    liftLeftInverseMagmaOpenLang _ (linvOL
                                    x1
                                    x2) =
      stage2 _ _ _ (linvOL' _)
        (codeLift2 _ _ _ (linvOL' _))
        (liftLeftInverseMagmaOpenLang _
           x1)
        (liftLeftInverseMagmaOpenLang _
           x2)
  
  module LeftLoop where
    record LeftLoop
      (A : Set) : Set where
      constructor LeftLoopC
      field
        op : A -> A -> A
        e : A
        runit_e : (x : A) -> op x e == x
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
    record LeftLoopSig
      (AS : Set) : Set where
      constructor LeftLoopSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
        linvS : AS -> AS -> AS
    record LeftLoopProd
      (AP : Set) : Set where
      constructor LeftLoopProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
    record LeftLoopHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftLoop A1)
      (Le2 : LeftLoop A2) : Set where
      constructor LeftLoopHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
        pres-e : hom (e Le1) == e Le2
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Le1 x1 x2) ==
            linv Le2 (hom x1) (hom x2)
    record LeftLoopRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftLoop A1)
      (Le2 : LeftLoop A2) : Set where
      constructor LeftLoopRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
        interp-e :
          interp (e Le1) (e Le2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Le1 x1 x2)
            (linv Le2 y1 y2)
    data LeftLoopLang : Set where
      opL :
        LeftLoopLang ->
        LeftLoopLang -> LeftLoopLang
      eL : LeftLoopLang
      linvL :
        LeftLoopLang ->
        LeftLoopLang -> LeftLoopLang
    data LeftLoopOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> LeftLoopOpenLang n
      opOL :
        LeftLoopOpenLang n ->
        LeftLoopOpenLang n ->
        LeftLoopOpenLang n
      eOL : LeftLoopOpenLang n
      linvOL :
        LeftLoopOpenLang n ->
        LeftLoopOpenLang n ->
        LeftLoopOpenLang n
    evalTerm :
      (A : Set) ->
      LeftLoop A -> LeftLoopLang -> A
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (eL) = e Le
    evalTerm _ Le (linvL x1 x2) =
      linv Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftLoop A ->
      LeftLoopOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (eOL) vars =
      e le
    evalOpenTerm _ n le (linvOL
                         x1
                         x2) vars =
      linv le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    simplify :
      LeftLoopLang -> LeftLoopLang
    simplify (opL x (eL)) = x
    simplify (opL x (linvL x y)) = y
    simplify (linvL x (opL x y)) = y
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (eL) = eL
    simplify (linvL x1 x2) =
      linvL (simplify x1)
        (simplify x2)
    liftLeftLoopLang :
      LeftLoopLang ->
      Staged LeftLoopLang
    liftLeftLoopLang x = Now x
    opOL' :
      (n : Nat) ->
      LeftLoopOpenLang n ->
      LeftLoopOpenLang n ->
      LeftLoopOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    eOL' :
      (n : Nat) -> LeftLoopOpenLang n
    eOL' _ = eOL
    linvOL' :
      (n : Nat) ->
      LeftLoopOpenLang n ->
      LeftLoopOpenLang n ->
      LeftLoopOpenLang n
    linvOL' _ x1 x2 = linvOL x1 x2
    liftLeftLoopOpenLang :
      (n : Nat) ->
      LeftLoopOpenLang n ->
      Staged (LeftLoopOpenLang n)
    liftLeftLoopOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftLeftLoopOpenLang _ (opOL
                            x1
                            x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftLeftLoopOpenLang _ x1)
        (liftLeftLoopOpenLang _ x2)
    liftLeftLoopOpenLang _ (eOL) =
      Now eOL
    liftLeftLoopOpenLang _ (linvOL
                            x1
                            x2) =
      stage2 _ _ _ (linvOL' _)
        (codeLift2 _ _ _ (linvOL' _))
        (liftLeftLoopOpenLang _ x1)
        (liftLeftLoopOpenLang _ x2)
  
  module LeftMonoid where
    record LeftMonoid
      (A : Set) : Set where
      constructor LeftMonoidC
      field
        op : A -> A -> A
        e : A
        lunit_e : (x : A) -> op e x == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record LeftMonoidSig
      (AS : Set) : Set where
      constructor LeftMonoidSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record LeftMonoidProd
      (AP : Set) : Set where
      constructor LeftMonoidProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record LeftMonoidHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftMonoid A1)
      (Le2 : LeftMonoid A2) :
      Set where
      constructor LeftMonoidHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
        pres-e : hom (e Le1) == e Le2
    record LeftMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftMonoid A1)
      (Le2 : LeftMonoid A2) :
      Set where
      constructor LeftMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
        interp-e :
          interp (e Le1) (e Le2)
    data LeftMonoidLang : Set where
      opL :
        LeftMonoidLang ->
        LeftMonoidLang -> LeftMonoidLang
      eL : LeftMonoidLang
    data LeftMonoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> LeftMonoidOpenLang n
      opOL :
        LeftMonoidOpenLang n ->
        LeftMonoidOpenLang n ->
        LeftMonoidOpenLang n
      eOL : LeftMonoidOpenLang n
    evalTerm :
      (A : Set) ->
      LeftMonoid A ->
      LeftMonoidLang -> A
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (eL) = e Le
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftMonoid A ->
      LeftMonoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (eOL) vars =
      e le
    simplify :
      LeftMonoidLang -> LeftMonoidLang
    simplify (opL (eL) x) = x
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (eL) = eL
    liftLeftMonoidLang :
      LeftMonoidLang ->
      Staged LeftMonoidLang
    liftLeftMonoidLang x = Now x
    opOL' :
      (n : Nat) ->
      LeftMonoidOpenLang n ->
      LeftMonoidOpenLang n ->
      LeftMonoidOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    eOL' :
      (n : Nat) ->
      LeftMonoidOpenLang n
    eOL' _ = eOL
    liftLeftMonoidOpenLang :
      (n : Nat) ->
      LeftMonoidOpenLang n ->
      Staged (LeftMonoidOpenLang n)
    liftLeftMonoidOpenLang _ (v
                              fin) = const _ (code _ (v fin))
    liftLeftMonoidOpenLang _ (opOL
                              x1
                              x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftLeftMonoidOpenLang _ x1)
        (liftLeftMonoidOpenLang _ x2)
    liftLeftMonoidOpenLang _ (eOL) =
      Now eOL
  
  module LeftPreSemiring where
    record LeftPreSemiring
      (A : Set) : Set where
      constructor LeftPreSemiringC
      field
        * : A -> A -> A
        + : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record LeftPreSemiringSig
      (AS : Set) : Set where
      constructor LeftPreSemiringSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record LeftPreSemiringProd
      (AP : Set) : Set where
      constructor LeftPreSemiringProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record LeftPreSemiringHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftPreSemiring A1)
      (Le2 : LeftPreSemiring A2) :
      Set where
      constructor LeftPreSemiringHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Le1 x1 x2) ==
            * Le2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Le1 x1 x2) ==
            + Le2 (hom x1) (hom x2)
    record LeftPreSemiringRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftPreSemiring A1)
      (Le2 : LeftPreSemiring A2) :
      Set where
      constructor LeftPreSemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Le1 x1 x2)
            (* Le2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Le1 x1 x2)
            (+ Le2 y1 y2)
    data LeftPreSemiringLang
      : Set where
      *L :
        LeftPreSemiringLang ->
        LeftPreSemiringLang ->
        LeftPreSemiringLang
      +L :
        LeftPreSemiringLang ->
        LeftPreSemiringLang ->
        LeftPreSemiringLang
    data LeftPreSemiringOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftPreSemiringOpenLang n
      *OL :
        LeftPreSemiringOpenLang n ->
        LeftPreSemiringOpenLang n ->
        LeftPreSemiringOpenLang n
      +OL :
        LeftPreSemiringOpenLang n ->
        LeftPreSemiringOpenLang n ->
        LeftPreSemiringOpenLang n
    evalTerm :
      (A : Set) ->
      LeftPreSemiring A ->
      LeftPreSemiringLang -> A
    evalTerm _ Le (*L x1 x2) =
      * Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (+L x1 x2) =
      + Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftPreSemiring A ->
      LeftPreSemiringOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (*OL
                         x1
                         x2) vars =
      * le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (+OL
                         x1
                         x2) vars =
      + le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    simplify :
      LeftPreSemiringLang ->
      LeftPreSemiringLang
    simplify (+L
              (*L x y)
              (*L x z)) = *L x (+L y z)
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftLeftPreSemiringLang :
      LeftPreSemiringLang ->
      Staged LeftPreSemiringLang
    liftLeftPreSemiringLang x =
      Now x
    *OL' :
      (n : Nat) ->
      LeftPreSemiringOpenLang n ->
      LeftPreSemiringOpenLang n ->
      LeftPreSemiringOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      LeftPreSemiringOpenLang n ->
      LeftPreSemiringOpenLang n ->
      LeftPreSemiringOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftLeftPreSemiringOpenLang :
      (n : Nat) ->
      LeftPreSemiringOpenLang n ->
      Staged
        (LeftPreSemiringOpenLang n)
    liftLeftPreSemiringOpenLang _ (v
                                   fin) = const _ (code _ (v fin))
    liftLeftPreSemiringOpenLang _ (*OL
                                   x1
                                   x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftLeftPreSemiringOpenLang _
           x1)
        (liftLeftPreSemiringOpenLang _
           x2)
    liftLeftPreSemiringOpenLang _ (+OL
                                   x1
                                   x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftLeftPreSemiringOpenLang _
           x1)
        (liftLeftPreSemiringOpenLang _
           x2)
  
  module LeftQuasiGroup where
    record LeftQuasiGroup
      (A : Set) : Set where
      constructor LeftQuasiGroupC
      field
        op : A -> A -> A
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
    record LeftQuasiGroupSig
      (AS : Set) : Set where
      constructor LeftQuasiGroupSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
    record LeftQuasiGroupProd
      (AP : Set) : Set where
      constructor LeftQuasiGroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
    record LeftQuasiGroupHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftQuasiGroup A1)
      (Le2 : LeftQuasiGroup A2) :
      Set where
      constructor LeftQuasiGroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Le1 x1 x2) ==
            linv Le2 (hom x1) (hom x2)
    record LeftQuasiGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftQuasiGroup A1)
      (Le2 : LeftQuasiGroup A2) :
      Set where
      constructor LeftQuasiGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Le1 x1 x2)
            (linv Le2 y1 y2)
    data LeftQuasiGroupLang
      : Set where
      opL :
        LeftQuasiGroupLang ->
        LeftQuasiGroupLang ->
        LeftQuasiGroupLang
      linvL :
        LeftQuasiGroupLang ->
        LeftQuasiGroupLang ->
        LeftQuasiGroupLang
    data LeftQuasiGroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftQuasiGroupOpenLang n
      opOL :
        LeftQuasiGroupOpenLang n ->
        LeftQuasiGroupOpenLang n ->
        LeftQuasiGroupOpenLang n
      linvOL :
        LeftQuasiGroupOpenLang n ->
        LeftQuasiGroupOpenLang n ->
        LeftQuasiGroupOpenLang n
    evalTerm :
      (A : Set) ->
      LeftQuasiGroup A ->
      LeftQuasiGroupLang -> A
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (linvL x1 x2) =
      linv Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftQuasiGroup A ->
      LeftQuasiGroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (linvOL
                         x1
                         x2) vars =
      linv le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    simplify :
      LeftQuasiGroupLang ->
      LeftQuasiGroupLang
    simplify (opL x (linvL x y)) = y
    simplify (linvL x (opL x y)) = y
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (linvL x1 x2) =
      linvL (simplify x1)
        (simplify x2)
    liftLeftQuasiGroupLang :
      LeftQuasiGroupLang ->
      Staged LeftQuasiGroupLang
    liftLeftQuasiGroupLang x = Now x
    opOL' :
      (n : Nat) ->
      LeftQuasiGroupOpenLang n ->
      LeftQuasiGroupOpenLang n ->
      LeftQuasiGroupOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    linvOL' :
      (n : Nat) ->
      LeftQuasiGroupOpenLang n ->
      LeftQuasiGroupOpenLang n ->
      LeftQuasiGroupOpenLang n
    linvOL' _ x1 x2 = linvOL x1 x2
    liftLeftQuasiGroupOpenLang :
      (n : Nat) ->
      LeftQuasiGroupOpenLang n ->
      Staged
        (LeftQuasiGroupOpenLang n)
    liftLeftQuasiGroupOpenLang _ (v
                                  fin) = const _ (code _ (v fin))
    liftLeftQuasiGroupOpenLang _ (opOL
                                  x1
                                  x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftLeftQuasiGroupOpenLang _
           x1)
        (liftLeftQuasiGroupOpenLang _
           x2)
    liftLeftQuasiGroupOpenLang _ (linvOL
                                  x1
                                  x2) =
      stage2 _ _ _ (linvOL' _)
        (codeLift2 _ _ _ (linvOL' _))
        (liftLeftQuasiGroupOpenLang _
           x1)
        (liftLeftQuasiGroupOpenLang _
           x2)
  
  module LeftRack where
    record LeftRack
      (A : Set) : Set where
      constructor LeftRackC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
    record LeftRackSig
      (AS : Set) : Set where
      constructor LeftRackSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record LeftRackProd
      (AP : Set) : Set where
      constructor LeftRackProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
    record LeftRackHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftRack A1)
      (Le2 : LeftRack A2) : Set where
      constructor LeftRackHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Le1 x1 x2) ==
            <| Le2 (hom x1) (hom x2)
    record LeftRackRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftRack A1)
      (Le2 : LeftRack A2) : Set where
      constructor LeftRackRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Le1 x1 x2)
            (<| Le2 y1 y2)
    data LeftRackLang : Set where
      |>L :
        LeftRackLang ->
        LeftRackLang -> LeftRackLang
      <|L :
        LeftRackLang ->
        LeftRackLang -> LeftRackLang
    data LeftRackOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> LeftRackOpenLang n
      |>OL :
        LeftRackOpenLang n ->
        LeftRackOpenLang n ->
        LeftRackOpenLang n
      <|OL :
        LeftRackOpenLang n ->
        LeftRackOpenLang n ->
        LeftRackOpenLang n
    evalTerm :
      (A : Set) ->
      LeftRack A -> LeftRackLang -> A
    evalTerm _ Le (|>L x1 x2) =
      |> Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (<|L x1 x2) =
      <| Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftRack A ->
      LeftRackOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (|>OL
                         x1
                         x2) vars =
      |> le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (<|OL
                         x1
                         x2) vars =
      <| le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    simplify :
      LeftRackLang -> LeftRackLang
    simplify (|>L
              (|>L x y)
              (|>L x z)) = |>L x (|>L y z)
    simplify (|>L x1 x2) =
      |>L (simplify x1) (simplify x2)
    simplify (<|L x1 x2) =
      <|L (simplify x1) (simplify x2)
    liftLeftRackLang :
      LeftRackLang ->
      Staged LeftRackLang
    liftLeftRackLang x = Now x
    |>OL' :
      (n : Nat) ->
      LeftRackOpenLang n ->
      LeftRackOpenLang n ->
      LeftRackOpenLang n
    |>OL' _ x1 x2 = |>OL x1 x2
    <|OL' :
      (n : Nat) ->
      LeftRackOpenLang n ->
      LeftRackOpenLang n ->
      LeftRackOpenLang n
    <|OL' _ x1 x2 = <|OL x1 x2
    liftLeftRackOpenLang :
      (n : Nat) ->
      LeftRackOpenLang n ->
      Staged (LeftRackOpenLang n)
    liftLeftRackOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftLeftRackOpenLang _ (|>OL
                            x1
                            x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (liftLeftRackOpenLang _ x1)
        (liftLeftRackOpenLang _ x2)
    liftLeftRackOpenLang _ (<|OL
                            x1
                            x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (liftLeftRackOpenLang _ x1)
        (liftLeftRackOpenLang _ x2)
  
  module LeftRingoid where
    record LeftRingoid
      (A : Set) : Set where
      constructor LeftRingoidC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
    record LeftRingoidSig
      (AS : Set) : Set where
      constructor LeftRingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record LeftRingoidProd
      (AP : Set) : Set where
      constructor LeftRingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
    record LeftRingoidHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftRingoid A1)
      (Le2 : LeftRingoid A2) :
      Set where
      constructor LeftRingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Le1 x1 x2) ==
            * Le2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Le1 x1 x2) ==
            + Le2 (hom x1) (hom x2)
    record LeftRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftRingoid A1)
      (Le2 : LeftRingoid A2) :
      Set where
      constructor LeftRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Le1 x1 x2)
            (* Le2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Le1 x1 x2)
            (+ Le2 y1 y2)
    data LeftRingoidLang : Set where
      *L :
        LeftRingoidLang ->
        LeftRingoidLang ->
        LeftRingoidLang
      +L :
        LeftRingoidLang ->
        LeftRingoidLang ->
        LeftRingoidLang
    data LeftRingoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> LeftRingoidOpenLang n
      *OL :
        LeftRingoidOpenLang n ->
        LeftRingoidOpenLang n ->
        LeftRingoidOpenLang n
      +OL :
        LeftRingoidOpenLang n ->
        LeftRingoidOpenLang n ->
        LeftRingoidOpenLang n
    evalTerm :
      (A : Set) ->
      LeftRingoid A ->
      LeftRingoidLang -> A
    evalTerm _ Le (*L x1 x2) =
      * Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (+L x1 x2) =
      + Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftRingoid A ->
      LeftRingoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (*OL
                         x1
                         x2) vars =
      * le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (+OL
                         x1
                         x2) vars =
      + le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    simplify :
      LeftRingoidLang ->
      LeftRingoidLang
    simplify (+L
              (*L x y)
              (*L x z)) = *L x (+L y z)
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftLeftRingoidLang :
      LeftRingoidLang ->
      Staged LeftRingoidLang
    liftLeftRingoidLang x = Now x
    *OL' :
      (n : Nat) ->
      LeftRingoidOpenLang n ->
      LeftRingoidOpenLang n ->
      LeftRingoidOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      LeftRingoidOpenLang n ->
      LeftRingoidOpenLang n ->
      LeftRingoidOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftLeftRingoidOpenLang :
      (n : Nat) ->
      LeftRingoidOpenLang n ->
      Staged (LeftRingoidOpenLang n)
    liftLeftRingoidOpenLang _ (v
                               fin) = const _ (code _ (v fin))
    liftLeftRingoidOpenLang _ (*OL
                               x1
                               x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftLeftRingoidOpenLang _ x1)
        (liftLeftRingoidOpenLang _ x2)
    liftLeftRingoidOpenLang _ (+OL
                               x1
                               x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftLeftRingoidOpenLang _ x1)
        (liftLeftRingoidOpenLang _ x2)
  
  module LeftShelf where
    record LeftShelf
      (A : Set) : Set where
      constructor LeftShelfC
      field
        |> : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
    record LeftShelfSig
      (AS : Set) : Set where
      constructor LeftShelfSigSigC
      field
        |>S : AS -> AS -> AS
    record LeftShelfProd
      (AP : Set) : Set where
      constructor LeftShelfProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
    record LeftShelfHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftShelf A1)
      (Le2 : LeftShelf A2) : Set where
      constructor LeftShelfHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
    record LeftShelfRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftShelf A1)
      (Le2 : LeftShelf A2) : Set where
      constructor LeftShelfRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
    data LeftShelfLang : Set where
      |>L :
        LeftShelfLang ->
        LeftShelfLang -> LeftShelfLang
    data LeftShelfOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> LeftShelfOpenLang n
      |>OL :
        LeftShelfOpenLang n ->
        LeftShelfOpenLang n ->
        LeftShelfOpenLang n
    evalTerm :
      (A : Set) ->
      LeftShelf A ->
      LeftShelfLang -> A
    evalTerm _ Le (|>L x1 x2) =
      |> Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftShelf A ->
      LeftShelfOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (|>OL
                         x1
                         x2) vars =
      |> le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    simplify :
      LeftShelfLang -> LeftShelfLang
    simplify (|>L
              (|>L x y)
              (|>L x z)) = |>L x (|>L y z)
    simplify (|>L x1 x2) =
      |>L (simplify x1) (simplify x2)
    liftLeftShelfLang :
      LeftShelfLang ->
      Staged LeftShelfLang
    liftLeftShelfLang x = Now x
    |>OL' :
      (n : Nat) ->
      LeftShelfOpenLang n ->
      LeftShelfOpenLang n ->
      LeftShelfOpenLang n
    |>OL' _ x1 x2 = |>OL x1 x2
    liftLeftShelfOpenLang :
      (n : Nat) ->
      LeftShelfOpenLang n ->
      Staged (LeftShelfOpenLang n)
    liftLeftShelfOpenLang _ (v
                             fin) = const _ (code _ (v fin))
    liftLeftShelfOpenLang _ (|>OL
                             x1
                             x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (liftLeftShelfOpenLang _ x1)
        (liftLeftShelfOpenLang _ x2)
  
  module LeftShelfSig where
    record LeftShelfSig
      (A : Set) : Set where
      constructor LeftShelfSigC
      field
        |> : A -> A -> A
    record LeftShelfSigSig
      (AS : Set) : Set where
      constructor LeftShelfSigSigSigC
      field
        |>S : AS -> AS -> AS
    record LeftShelfSigProd
      (AP : Set) : Set where
      constructor LeftShelfSigProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record LeftShelfSigHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftShelfSig A1)
      (Le2 : LeftShelfSig A2) :
      Set where
      constructor LeftShelfSigHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
    record LeftShelfSigRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftShelfSig A1)
      (Le2 : LeftShelfSig A2) :
      Set where
      constructor LeftShelfSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
    data LeftShelfSigLang
      : Set where
      |>L :
        LeftShelfSigLang ->
        LeftShelfSigLang ->
        LeftShelfSigLang
    data LeftShelfSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> LeftShelfSigOpenLang n
      |>OL :
        LeftShelfSigOpenLang n ->
        LeftShelfSigOpenLang n ->
        LeftShelfSigOpenLang n
    evalTerm :
      (A : Set) ->
      LeftShelfSig A ->
      LeftShelfSigLang -> A
    evalTerm _ Le (|>L x1 x2) =
      |> Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftShelfSig A ->
      LeftShelfSigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (|>OL
                         x1
                         x2) vars =
      |> le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    simplify :
      LeftShelfSigLang ->
      LeftShelfSigLang
    simplify (|>L x1 x2) =
      |>L (simplify x1) (simplify x2)
    liftLeftShelfSigLang :
      LeftShelfSigLang ->
      Staged LeftShelfSigLang
    liftLeftShelfSigLang x = Now x
    |>OL' :
      (n : Nat) ->
      LeftShelfSigOpenLang n ->
      LeftShelfSigOpenLang n ->
      LeftShelfSigOpenLang n
    |>OL' _ x1 x2 = |>OL x1 x2
    liftLeftShelfSigOpenLang :
      (n : Nat) ->
      LeftShelfSigOpenLang n ->
      Staged (LeftShelfSigOpenLang n)
    liftLeftShelfSigOpenLang _ (v
                                fin) = const _ (code _ (v fin))
    liftLeftShelfSigOpenLang _ (|>OL
                                x1
                                x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (liftLeftShelfSigOpenLang _ x1)
        (liftLeftShelfSigOpenLang _ x2)
  
  module LeftSpindle where
    record LeftSpindle
      (A : Set) : Set where
      constructor LeftSpindleC
      field
        |> : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        idempotent_|> :
          (x : A) -> |> x x == x
    record LeftSpindleSig
      (AS : Set) : Set where
      constructor LeftSpindleSigSigC
      field
        |>S : AS -> AS -> AS
    record LeftSpindleProd
      (AP : Set) : Set where
      constructor LeftSpindleProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
    record LeftSpindleHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftSpindle A1)
      (Le2 : LeftSpindle A2) :
      Set where
      constructor LeftSpindleHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
    record LeftSpindleRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftSpindle A1)
      (Le2 : LeftSpindle A2) :
      Set where
      constructor LeftSpindleRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
    data LeftSpindleLang : Set where
      |>L :
        LeftSpindleLang ->
        LeftSpindleLang ->
        LeftSpindleLang
    data LeftSpindleOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> LeftSpindleOpenLang n
      |>OL :
        LeftSpindleOpenLang n ->
        LeftSpindleOpenLang n ->
        LeftSpindleOpenLang n
    evalTerm :
      (A : Set) ->
      LeftSpindle A ->
      LeftSpindleLang -> A
    evalTerm _ Le (|>L x1 x2) =
      |> Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftSpindle A ->
      LeftSpindleOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (|>OL
                         x1
                         x2) vars =
      |> le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    simplify :
      LeftSpindleLang ->
      LeftSpindleLang
    simplify (|>L
              (|>L x y)
              (|>L x z)) = |>L x (|>L y z)
    simplify (|>L x x) = x
    simplify (|>L x1 x2) =
      |>L (simplify x1) (simplify x2)
    liftLeftSpindleLang :
      LeftSpindleLang ->
      Staged LeftSpindleLang
    liftLeftSpindleLang x = Now x
    |>OL' :
      (n : Nat) ->
      LeftSpindleOpenLang n ->
      LeftSpindleOpenLang n ->
      LeftSpindleOpenLang n
    |>OL' _ x1 x2 = |>OL x1 x2
    liftLeftSpindleOpenLang :
      (n : Nat) ->
      LeftSpindleOpenLang n ->
      Staged (LeftSpindleOpenLang n)
    liftLeftSpindleOpenLang _ (v
                               fin) = const _ (code _ (v fin))
    liftLeftSpindleOpenLang _ (|>OL
                               x1
                               x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (liftLeftSpindleOpenLang _ x1)
        (liftLeftSpindleOpenLang _ x2)
  
  module LeftSpindle_Shelf where
    record LeftSpindle_Shelf
      (A : Set) : Set where
      constructor LeftSpindle_ShelfC
      field
        |> : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        idempotent_|> :
          (x : A) -> |> x x == x
        <| : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
    record LeftSpindle_ShelfSig
      (AS : Set) : Set where
      constructor LeftSpindle_ShelfSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record LeftSpindle_ShelfProd
      (AP : Set) : Set where
      constructor LeftSpindle_ShelfProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
    record LeftSpindle_ShelfHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftSpindle_Shelf A1)
      (Le2 : LeftSpindle_Shelf A2) :
      Set where
      constructor LeftSpindle_ShelfHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Le1 x1 x2) ==
            <| Le2 (hom x1) (hom x2)
    record LeftSpindle_ShelfRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftSpindle_Shelf A1)
      (Le2 : LeftSpindle_Shelf A2) :
      Set where
      constructor LeftSpindle_ShelfRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Le1 x1 x2)
            (<| Le2 y1 y2)
    data LeftSpindle_ShelfLang
      : Set where
      |>L :
        LeftSpindle_ShelfLang ->
        LeftSpindle_ShelfLang ->
        LeftSpindle_ShelfLang
      <|L :
        LeftSpindle_ShelfLang ->
        LeftSpindle_ShelfLang ->
        LeftSpindle_ShelfLang
    data LeftSpindle_ShelfOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftSpindle_ShelfOpenLang n
      |>OL :
        LeftSpindle_ShelfOpenLang n ->
        LeftSpindle_ShelfOpenLang n ->
        LeftSpindle_ShelfOpenLang n
      <|OL :
        LeftSpindle_ShelfOpenLang n ->
        LeftSpindle_ShelfOpenLang n ->
        LeftSpindle_ShelfOpenLang n
    evalTerm :
      (A : Set) ->
      LeftSpindle_Shelf A ->
      LeftSpindle_ShelfLang -> A
    evalTerm _ Le (|>L x1 x2) =
      |> Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (<|L x1 x2) =
      <| Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftSpindle_Shelf A ->
      LeftSpindle_ShelfOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (|>OL
                         x1
                         x2) vars =
      |> le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (<|OL
                         x1
                         x2) vars =
      <| le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    simplify :
      LeftSpindle_ShelfLang ->
      LeftSpindle_ShelfLang
    simplify (|>L
              (|>L x y)
              (|>L x z)) = |>L x (|>L y z)
    simplify (|>L x x) = x
    simplify (<|L
              (<|L y x)
              (<|L z x)) = <|L (<|L y z) x
    simplify (|>L x1 x2) =
      |>L (simplify x1) (simplify x2)
    simplify (<|L x1 x2) =
      <|L (simplify x1) (simplify x2)
    liftLeftSpindle_ShelfLang :
      LeftSpindle_ShelfLang ->
      Staged LeftSpindle_ShelfLang
    liftLeftSpindle_ShelfLang x =
      Now x
    |>OL' :
      (n : Nat) ->
      LeftSpindle_ShelfOpenLang n ->
      LeftSpindle_ShelfOpenLang n ->
      LeftSpindle_ShelfOpenLang n
    |>OL' _ x1 x2 = |>OL x1 x2
    <|OL' :
      (n : Nat) ->
      LeftSpindle_ShelfOpenLang n ->
      LeftSpindle_ShelfOpenLang n ->
      LeftSpindle_ShelfOpenLang n
    <|OL' _ x1 x2 = <|OL x1 x2
    liftLeftSpindle_ShelfOpenLang :
      (n : Nat) ->
      LeftSpindle_ShelfOpenLang n ->
      Staged
        (LeftSpindle_ShelfOpenLang n)
    liftLeftSpindle_ShelfOpenLang _ (v
                                     fin) = const _ (code _ (v fin))
    liftLeftSpindle_ShelfOpenLang _ (|>OL
                                     x1
                                     x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (liftLeftSpindle_ShelfOpenLang _
           x1)
        (liftLeftSpindle_ShelfOpenLang _
           x2)
    liftLeftSpindle_ShelfOpenLang _ (<|OL
                                     x1
                                     x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (liftLeftSpindle_ShelfOpenLang _
           x1)
        (liftLeftSpindle_ShelfOpenLang _
           x2)
  
  module LeftSpindle_ShelfSig where
    record LeftSpindle_ShelfSig
      (A : Set) : Set where
      constructor LeftSpindle_ShelfSigC
      field
        |> : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        idempotent_|> :
          (x : A) -> |> x x == x
        <| : A -> A -> A
    record LeftSpindle_ShelfSigSig
      (AS : Set) : Set where
      constructor LeftSpindle_ShelfSigSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record LeftSpindle_ShelfSigProd
      (AP : Set) : Set where
      constructor LeftSpindle_ShelfSigProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
    record LeftSpindle_ShelfSigHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftSpindle_ShelfSig A1)
      (Le2 : LeftSpindle_ShelfSig
         A2) : Set where
      constructor LeftSpindle_ShelfSigHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Le1 x1 x2) ==
            <| Le2 (hom x1) (hom x2)
    record LeftSpindle_ShelfSigRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftSpindle_ShelfSig A1)
      (Le2 : LeftSpindle_ShelfSig
         A2) : Set where
      constructor LeftSpindle_ShelfSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Le1 x1 x2)
            (<| Le2 y1 y2)
    data LeftSpindle_ShelfSigLang
      : Set where
      |>L :
        LeftSpindle_ShelfSigLang ->
        LeftSpindle_ShelfSigLang ->
        LeftSpindle_ShelfSigLang
      <|L :
        LeftSpindle_ShelfSigLang ->
        LeftSpindle_ShelfSigLang ->
        LeftSpindle_ShelfSigLang
    data LeftSpindle_ShelfSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftSpindle_ShelfSigOpenLang n
      |>OL :
        LeftSpindle_ShelfSigOpenLang
          n ->
        LeftSpindle_ShelfSigOpenLang
          n ->
        LeftSpindle_ShelfSigOpenLang n
      <|OL :
        LeftSpindle_ShelfSigOpenLang
          n ->
        LeftSpindle_ShelfSigOpenLang
          n ->
        LeftSpindle_ShelfSigOpenLang n
    evalTerm :
      (A : Set) ->
      LeftSpindle_ShelfSig A ->
      LeftSpindle_ShelfSigLang -> A
    evalTerm _ Le (|>L x1 x2) =
      |> Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (<|L x1 x2) =
      <| Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftSpindle_ShelfSig A ->
      LeftSpindle_ShelfSigOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (|>OL
                         x1
                         x2) vars =
      |> le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (<|OL
                         x1
                         x2) vars =
      <| le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    simplify :
      LeftSpindle_ShelfSigLang ->
      LeftSpindle_ShelfSigLang
    simplify (|>L
              (|>L x y)
              (|>L x z)) = |>L x (|>L y z)
    simplify (|>L x x) = x
    simplify (|>L x1 x2) =
      |>L (simplify x1) (simplify x2)
    simplify (<|L x1 x2) =
      <|L (simplify x1) (simplify x2)
    liftLeftSpindle_ShelfSigLang :
      LeftSpindle_ShelfSigLang ->
      Staged LeftSpindle_ShelfSigLang
    liftLeftSpindle_ShelfSigLang x =
      Now x
    |>OL' :
      (n : Nat) ->
      LeftSpindle_ShelfSigOpenLang
        n ->
      LeftSpindle_ShelfSigOpenLang
        n ->
      LeftSpindle_ShelfSigOpenLang n
    |>OL' _ x1 x2 = |>OL x1 x2
    <|OL' :
      (n : Nat) ->
      LeftSpindle_ShelfSigOpenLang
        n ->
      LeftSpindle_ShelfSigOpenLang
        n ->
      LeftSpindle_ShelfSigOpenLang n
    <|OL' _ x1 x2 = <|OL x1 x2
    liftLeftSpindle_ShelfSigOpenLang :
      (n : Nat) ->
      LeftSpindle_ShelfSigOpenLang
        n ->
      Staged
        (LeftSpindle_ShelfSigOpenLang n)
    liftLeftSpindle_ShelfSigOpenLang _ (v
                                        fin) = const _ (code _ (v fin))
    liftLeftSpindle_ShelfSigOpenLang _ (|>OL
                                        x1
                                        x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (liftLeftSpindle_ShelfSigOpenLang
           _
           x1)
        (liftLeftSpindle_ShelfSigOpenLang
           _
           x2)
    liftLeftSpindle_ShelfSigOpenLang _ (<|OL
                                        x1
                                        x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (liftLeftSpindle_ShelfSigOpenLang
           _
           x1)
        (liftLeftSpindle_ShelfSigOpenLang
           _
           x2)
  
  module LeftUnital where
    record LeftUnital
      (A : Set) : Set where
      constructor LeftUnitalC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
    record LeftUnitalSig
      (AS : Set) : Set where
      constructor LeftUnitalSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record LeftUnitalProd
      (AP : Set) : Set where
      constructor LeftUnitalProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
    record LeftUnitalHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftUnital A1)
      (Le2 : LeftUnital A2) :
      Set where
      constructor LeftUnitalHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Le1) == e Le2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record LeftUnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftUnital A1)
      (Le2 : LeftUnital A2) :
      Set where
      constructor LeftUnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Le1) (e Le2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data LeftUnitalLang : Set where
      eL : LeftUnitalLang
      opL :
        LeftUnitalLang ->
        LeftUnitalLang -> LeftUnitalLang
    data LeftUnitalOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> LeftUnitalOpenLang n
      eOL : LeftUnitalOpenLang n
      opOL :
        LeftUnitalOpenLang n ->
        LeftUnitalOpenLang n ->
        LeftUnitalOpenLang n
    evalTerm :
      (A : Set) ->
      LeftUnital A ->
      LeftUnitalLang -> A
    evalTerm _ Le (eL) = e Le
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftUnital A ->
      LeftUnitalOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (eOL) vars =
      e le
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    simplify :
      LeftUnitalLang -> LeftUnitalLang
    simplify (opL (eL) x) = x
    simplify (eL) = eL
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftLeftUnitalLang :
      LeftUnitalLang ->
      Staged LeftUnitalLang
    liftLeftUnitalLang x = Now x
    eOL' :
      (n : Nat) ->
      LeftUnitalOpenLang n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      LeftUnitalOpenLang n ->
      LeftUnitalOpenLang n ->
      LeftUnitalOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftLeftUnitalOpenLang :
      (n : Nat) ->
      LeftUnitalOpenLang n ->
      Staged (LeftUnitalOpenLang n)
    liftLeftUnitalOpenLang _ (v
                              fin) = const _ (code _ (v fin))
    liftLeftUnitalOpenLang _ (eOL) =
      Now eOL
    liftLeftUnitalOpenLang _ (opOL
                              x1
                              x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftLeftUnitalOpenLang _ x1)
        (liftLeftUnitalOpenLang _ x2)
  
  module LeftZero where
    record LeftZero
      (A : Set) : Set where
      constructor LeftZeroC
      field
        e : A
        op : A -> A -> A
        leftZero_op_e :
          (x : A) -> op e x == e
    record LeftZeroSig
      (AS : Set) : Set where
      constructor LeftZeroSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record LeftZeroProd
      (AP : Set) : Set where
      constructor LeftZeroProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftZero_op_eP :
          (xP : Prod AP AP) ->
          opP eP xP == eP
    record LeftZeroHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftZero A1)
      (Le2 : LeftZero A2) : Set where
      constructor LeftZeroHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Le1) == e Le2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record LeftZeroRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftZero A1)
      (Le2 : LeftZero A2) : Set where
      constructor LeftZeroRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Le1) (e Le2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data LeftZeroLang : Set where
      eL : LeftZeroLang
      opL :
        LeftZeroLang ->
        LeftZeroLang -> LeftZeroLang
    data LeftZeroOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> LeftZeroOpenLang n
      eOL : LeftZeroOpenLang n
      opOL :
        LeftZeroOpenLang n ->
        LeftZeroOpenLang n ->
        LeftZeroOpenLang n
    evalTerm :
      (A : Set) ->
      LeftZero A -> LeftZeroLang -> A
    evalTerm _ Le (eL) = e Le
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftZero A ->
      LeftZeroOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (eOL) vars =
      e le
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    simplify :
      LeftZeroLang -> LeftZeroLang
    simplify (opL (eL) x) = eL
    simplify (eL) = eL
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftLeftZeroLang :
      LeftZeroLang ->
      Staged LeftZeroLang
    liftLeftZeroLang x = Now x
    eOL' :
      (n : Nat) -> LeftZeroOpenLang n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      LeftZeroOpenLang n ->
      LeftZeroOpenLang n ->
      LeftZeroOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftLeftZeroOpenLang :
      (n : Nat) ->
      LeftZeroOpenLang n ->
      Staged (LeftZeroOpenLang n)
    liftLeftZeroOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftLeftZeroOpenLang _ (eOL) =
      Now eOL
    liftLeftZeroOpenLang _ (opOL
                            x1
                            x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftLeftZeroOpenLang _ x1)
        (liftLeftZeroOpenLang _ x2)
  
  module LieRing where
    record LieRing
      (A : Set) : Set where
      constructor LieRingC
      field
        0 : A
        + : A -> A -> A
        * : A -> A -> A
        jacobian_*_+ :
          (x : A) (y : A) (z : A) ->
          +
            (+ (* x (* y z)) (* y (* z x)))
            (* z (* x y)) == 0
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
        antiCommutative :
          (x : A) (y : A) ->
          * x y == neg (* y x)
    record LieRingSig
      (AS : Set) : Set where
      constructor LieRingSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
        negS : AS -> AS
        1S : AS
    record LieRingProd
      (AP : Set) : Set where
      constructor LieRingProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        jacobian_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P
            (+P (*P xP (*P yP zP))
               (*P yP (*P zP xP)))
            (*P zP (*P xP yP)) == 0P
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
        antiCommutativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == negP (*P yP xP)
    record LieRingHom
      (A1 : Set) (A2 : Set)
      (Li1 : LieRing A1)
      (Li2 : LieRing A2) : Set where
      constructor LieRingHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Li1) == 0 Li2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Li1 x1 x2) ==
            + Li2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Li1 x1 x2) ==
            * Li2 (hom x1) (hom x2)
        pres-neg :
          (x1 : A1) ->
          hom (neg Li1 x1) ==
            neg Li2 (hom x1)
        pres-1 : hom (1 Li1) == 1 Li2
    record LieRingRelInterp
      (A1 : Set) (A2 : Set)
      (Li1 : LieRing A1)
      (Li2 : LieRing A2) : Set where
      constructor LieRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Li1) (0 Li2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Li1 x1 x2)
            (+ Li2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Li1 x1 x2)
            (* Li2 y1 y2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Li1 x1) (neg Li2 y1)
        interp-1 :
          interp (1 Li1) (1 Li2)
    data LieRingLang : Set where
      0L : LieRingLang
      +L :
        LieRingLang ->
        LieRingLang -> LieRingLang
      *L :
        LieRingLang ->
        LieRingLang -> LieRingLang
      negL :
        LieRingLang -> LieRingLang
      1L : LieRingLang
    data LieRingOpenLang
      (n : Nat) : Set where
      v : Fin n -> LieRingOpenLang n
      0OL : LieRingOpenLang n
      +OL :
        LieRingOpenLang n ->
        LieRingOpenLang n ->
        LieRingOpenLang n
      *OL :
        LieRingOpenLang n ->
        LieRingOpenLang n ->
        LieRingOpenLang n
      negOL :
        LieRingOpenLang n ->
        LieRingOpenLang n
      1OL : LieRingOpenLang n
    evalTerm :
      (A : Set) ->
      LieRing A -> LieRingLang -> A
    evalTerm _ Li (0L) = 0 Li
    evalTerm _ Li (+L x1 x2) =
      + Li (evalTerm _ Li x1)
        (evalTerm _ Li x2)
    evalTerm _ Li (*L x1 x2) =
      * Li (evalTerm _ Li x1)
        (evalTerm _ Li x2)
    evalTerm _ Li (negL x1) =
      neg Li (evalTerm _ Li x1)
    evalTerm _ Li (1L) = 1 Li
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LieRing A ->
      LieRingOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n li (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n li (0OL) vars =
      0 li
    evalOpenTerm _ n li (+OL
                         x1
                         x2) vars =
      + li
        (evalOpenTerm _ n li x1 vars)
        (evalOpenTerm _ n li x2 vars)
    evalOpenTerm _ n li (*OL
                         x1
                         x2) vars =
      * li
        (evalOpenTerm _ n li x1 vars)
        (evalOpenTerm _ n li x2 vars)
    evalOpenTerm _ n li (negOL
                         x1) vars =
      neg li
        (evalOpenTerm _ n li x1 vars)
    evalOpenTerm _ n li (1OL) vars =
      1 li
    simplify :
      LieRingLang -> LieRingLang
    simplify (+L
              (+L
               (*L x (*L y z))
               (*L y (*L z x)))
              (*L z (*L x y))) = 0L
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (+L
              (*L x y)
              (*L x z)) = *L x (+L y z)
    simplify (+L
              (*L y x)
              (*L z x)) = *L (+L y z) x
    simplify (+L x (negL x)) = 0L
    simplify (+L (negL x) x) = 0L
    simplify (*L (1L) x) = x
    simplify (*L x (1L)) = x
    simplify (*L (0L) x) = 0L
    simplify (*L x (0L)) = 0L
    simplify (negL (*L y x)) =
      *L x y
    simplify (0L) = 0L
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (negL x1) =
      negL (simplify x1)
    simplify (1L) = 1L
    liftLieRingLang :
      LieRingLang ->
      Staged LieRingLang
    liftLieRingLang x = Now x
    0OL' :
      (n : Nat) -> LieRingOpenLang n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      LieRingOpenLang n ->
      LieRingOpenLang n ->
      LieRingOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    *OL' :
      (n : Nat) ->
      LieRingOpenLang n ->
      LieRingOpenLang n ->
      LieRingOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    negOL' :
      (n : Nat) ->
      LieRingOpenLang n ->
      LieRingOpenLang n
    negOL' _ x1 = negOL x1
    1OL' :
      (n : Nat) -> LieRingOpenLang n
    1OL' _ = 1OL
    liftLieRingOpenLang :
      (n : Nat) ->
      LieRingOpenLang n ->
      Staged (LieRingOpenLang n)
    liftLieRingOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftLieRingOpenLang _ (0OL) =
      Now 0OL
    liftLieRingOpenLang _ (+OL
                           x1
                           x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftLieRingOpenLang _ x1)
        (liftLieRingOpenLang _ x2)
    liftLieRingOpenLang _ (*OL
                           x1
                           x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftLieRingOpenLang _ x1)
        (liftLieRingOpenLang _ x2)
    liftLieRingOpenLang _ (negOL
                           x1) =
      stage1 _ _ (negOL' _)
        (codeLift1 _ _ (negOL' _))
        (liftLieRingOpenLang _ x1)
    liftLieRingOpenLang _ (1OL) =
      Now 1OL
  
  module Loop where
    record Loop
      (A : Set) : Set where
      constructor LoopC
      field
        op : A -> A -> A
        e : A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
    record LoopSig
      (AS : Set) : Set where
      constructor LoopSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
        linvS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record LoopProd
      (AP : Set) : Set where
      constructor LoopProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
    record LoopHom
      (A1 : Set) (A2 : Set)
      (Lo1 : Loop A1)
      (Lo2 : Loop A2) : Set where
      constructor LoopHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Lo1 x1 x2) ==
            op Lo2 (hom x1) (hom x2)
        pres-e : hom (e Lo1) == e Lo2
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Lo1 x1 x2) ==
            linv Lo2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Lo1 x1 x2) ==
            rinv Lo2 (hom x1) (hom x2)
    record LoopRelInterp
      (A1 : Set) (A2 : Set)
      (Lo1 : Loop A1)
      (Lo2 : Loop A2) : Set where
      constructor LoopRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Lo1 x1 x2)
            (op Lo2 y1 y2)
        interp-e :
          interp (e Lo1) (e Lo2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Lo1 x1 x2)
            (linv Lo2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Lo1 x1 x2)
            (rinv Lo2 y1 y2)
    data LoopLang : Set where
      opL :
        LoopLang -> LoopLang -> LoopLang
      eL : LoopLang
      linvL :
        LoopLang -> LoopLang -> LoopLang
      rinvL :
        LoopLang -> LoopLang -> LoopLang
    data LoopOpenLang
      (n : Nat) : Set where
      v : Fin n -> LoopOpenLang n
      opOL :
        LoopOpenLang n ->
        LoopOpenLang n -> LoopOpenLang n
      eOL : LoopOpenLang n
      linvOL :
        LoopOpenLang n ->
        LoopOpenLang n -> LoopOpenLang n
      rinvOL :
        LoopOpenLang n ->
        LoopOpenLang n -> LoopOpenLang n
    evalTerm :
      (A : Set) ->
      Loop A -> LoopLang -> A
    evalTerm _ Lo (opL x1 x2) =
      op Lo (evalTerm _ Lo x1)
        (evalTerm _ Lo x2)
    evalTerm _ Lo (eL) = e Lo
    evalTerm _ Lo (linvL x1 x2) =
      linv Lo (evalTerm _ Lo x1)
        (evalTerm _ Lo x2)
    evalTerm _ Lo (rinvL x1 x2) =
      rinv Lo (evalTerm _ Lo x1)
        (evalTerm _ Lo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Loop A ->
      LoopOpenLang n -> Vec A n -> A
    evalOpenTerm _ n lo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n lo (opOL
                         x1
                         x2) vars =
      op lo
        (evalOpenTerm _ n lo x1 vars)
        (evalOpenTerm _ n lo x2 vars)
    evalOpenTerm _ n lo (eOL) vars =
      e lo
    evalOpenTerm _ n lo (linvOL
                         x1
                         x2) vars =
      linv lo
        (evalOpenTerm _ n lo x1 vars)
        (evalOpenTerm _ n lo x2 vars)
    evalOpenTerm _ n lo (rinvOL
                         x1
                         x2) vars =
      rinv lo
        (evalOpenTerm _ n lo x1 vars)
        (evalOpenTerm _ n lo x2 vars)
    simplify : LoopLang -> LoopLang
    simplify (opL (eL) x) = x
    simplify (opL x (eL)) = x
    simplify (opL x (linvL x y)) = y
    simplify (linvL x (opL x y)) = y
    simplify (opL (rinvL y x) x) = y
    simplify (rinvL (opL y x) x) = y
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (eL) = eL
    simplify (linvL x1 x2) =
      linvL (simplify x1)
        (simplify x2)
    simplify (rinvL x1 x2) =
      rinvL (simplify x1)
        (simplify x2)
    liftLoopLang :
      LoopLang -> Staged LoopLang
    liftLoopLang x = Now x
    opOL' :
      (n : Nat) ->
      LoopOpenLang n ->
      LoopOpenLang n -> LoopOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    eOL' :
      (n : Nat) -> LoopOpenLang n
    eOL' _ = eOL
    linvOL' :
      (n : Nat) ->
      LoopOpenLang n ->
      LoopOpenLang n -> LoopOpenLang n
    linvOL' _ x1 x2 = linvOL x1 x2
    rinvOL' :
      (n : Nat) ->
      LoopOpenLang n ->
      LoopOpenLang n -> LoopOpenLang n
    rinvOL' _ x1 x2 = rinvOL x1 x2
    liftLoopOpenLang :
      (n : Nat) ->
      LoopOpenLang n ->
      Staged (LoopOpenLang n)
    liftLoopOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftLoopOpenLang _ (opOL
                        x1
                        x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftLoopOpenLang _ x1)
        (liftLoopOpenLang _ x2)
    liftLoopOpenLang _ (eOL) =
      Now eOL
    liftLoopOpenLang _ (linvOL
                        x1
                        x2) =
      stage2 _ _ _ (linvOL' _)
        (codeLift2 _ _ _ (linvOL' _))
        (liftLoopOpenLang _ x1)
        (liftLoopOpenLang _ x2)
    liftLoopOpenLang _ (rinvOL
                        x1
                        x2) =
      stage2 _ _ _ (rinvOL' _)
        (codeLift2 _ _ _ (rinvOL' _))
        (liftLoopOpenLang _ x1)
        (liftLoopOpenLang _ x2)
  
  module Magma where
    record Magma
      (A : Set) : Set where
      constructor MagmaC
      field
        op : A -> A -> A
    record MagmaSig
      (AS : Set) : Set where
      constructor MagmaSigSigC
      field
        opS : AS -> AS -> AS
    record MagmaProd
      (AP : Set) : Set where
      constructor MagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record MagmaHom
      (A1 : Set) (A2 : Set)
      (Ma1 : Magma A1)
      (Ma2 : Magma A2) : Set where
      constructor MagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ma1 x1 x2) ==
            op Ma2 (hom x1) (hom x2)
    record MagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ma1 : Magma A1)
      (Ma2 : Magma A2) : Set where
      constructor MagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ma1 x1 x2)
            (op Ma2 y1 y2)
    data MagmaLang : Set where
      opL :
        MagmaLang ->
        MagmaLang -> MagmaLang
    data MagmaOpenLang
      (n : Nat) : Set where
      v : Fin n -> MagmaOpenLang n
      opOL :
        MagmaOpenLang n ->
        MagmaOpenLang n ->
        MagmaOpenLang n
    evalTerm :
      (A : Set) ->
      Magma A -> MagmaLang -> A
    evalTerm _ Ma (opL x1 x2) =
      op Ma (evalTerm _ Ma x1)
        (evalTerm _ Ma x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Magma A ->
      MagmaOpenLang n -> Vec A n -> A
    evalOpenTerm _ n ma (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ma (opOL
                         x1
                         x2) vars =
      op ma
        (evalOpenTerm _ n ma x1 vars)
        (evalOpenTerm _ n ma x2 vars)
    simplify :
      MagmaLang -> MagmaLang
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftMagmaLang :
      MagmaLang -> Staged MagmaLang
    liftMagmaLang x = Now x
    opOL' :
      (n : Nat) ->
      MagmaOpenLang n ->
      MagmaOpenLang n ->
      MagmaOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftMagmaOpenLang :
      (n : Nat) ->
      MagmaOpenLang n ->
      Staged (MagmaOpenLang n)
    liftMagmaOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftMagmaOpenLang _ (opOL
                         x1
                         x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftMagmaOpenLang _ x1)
        (liftMagmaOpenLang _ x2)
  
  module MedialMagma where
    record MedialMagma
      (A : Set) : Set where
      constructor MedialMagmaC
      field
        op : A -> A -> A
        mediates :
          (w : A) (x : A) (y : A)
          (z : A) ->
          op (op x y) (op z w) ==
            op (op x z) (op y w)
    record MedialMagmaSig
      (AS : Set) : Set where
      constructor MedialMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record MedialMagmaProd
      (AP : Set) : Set where
      constructor MedialMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        mediatesP :
          (wP : Prod AP AP)
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) (opP zP wP) ==
            opP (opP xP zP) (opP yP wP)
    record MedialMagmaHom
      (A1 : Set) (A2 : Set)
      (Me1 : MedialMagma A1)
      (Me2 : MedialMagma A2) :
      Set where
      constructor MedialMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Me1 x1 x2) ==
            op Me2 (hom x1) (hom x2)
    record MedialMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Me1 : MedialMagma A1)
      (Me2 : MedialMagma A2) :
      Set where
      constructor MedialMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Me1 x1 x2)
            (op Me2 y1 y2)
    data MedialMagmaLang : Set where
      opL :
        MedialMagmaLang ->
        MedialMagmaLang ->
        MedialMagmaLang
    data MedialMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> MedialMagmaOpenLang n
      opOL :
        MedialMagmaOpenLang n ->
        MedialMagmaOpenLang n ->
        MedialMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      MedialMagma A ->
      MedialMagmaLang -> A
    evalTerm _ Me (opL x1 x2) =
      op Me (evalTerm _ Me x1)
        (evalTerm _ Me x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MedialMagma A ->
      MedialMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n me (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n me (opOL
                         x1
                         x2) vars =
      op me
        (evalOpenTerm _ n me x1 vars)
        (evalOpenTerm _ n me x2 vars)
    simplify :
      MedialMagmaLang ->
      MedialMagmaLang
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftMedialMagmaLang :
      MedialMagmaLang ->
      Staged MedialMagmaLang
    liftMedialMagmaLang x = Now x
    opOL' :
      (n : Nat) ->
      MedialMagmaOpenLang n ->
      MedialMagmaOpenLang n ->
      MedialMagmaOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftMedialMagmaOpenLang :
      (n : Nat) ->
      MedialMagmaOpenLang n ->
      Staged (MedialMagmaOpenLang n)
    liftMedialMagmaOpenLang _ (v
                               fin) = const _ (code _ (v fin))
    liftMedialMagmaOpenLang _ (opOL
                               x1
                               x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftMedialMagmaOpenLang _ x1)
        (liftMedialMagmaOpenLang _ x2)
  
  module MedialQuasiGroup where
    record MedialQuasiGroup
      (A : Set) : Set where
      constructor MedialQuasiGroupC
      field
        op : A -> A -> A
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
        mediates :
          (w : A) (x : A) (y : A)
          (z : A) ->
          op (op x y) (op z w) ==
            op (op x z) (op y w)
    record MedialQuasiGroupSig
      (AS : Set) : Set where
      constructor MedialQuasiGroupSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record MedialQuasiGroupProd
      (AP : Set) : Set where
      constructor MedialQuasiGroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
        mediatesP :
          (wP : Prod AP AP)
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) (opP zP wP) ==
            opP (opP xP zP) (opP yP wP)
    record MedialQuasiGroupHom
      (A1 : Set) (A2 : Set)
      (Me1 : MedialQuasiGroup A1)
      (Me2 : MedialQuasiGroup A2) :
      Set where
      constructor MedialQuasiGroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Me1 x1 x2) ==
            op Me2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Me1 x1 x2) ==
            linv Me2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Me1 x1 x2) ==
            rinv Me2 (hom x1) (hom x2)
    record MedialQuasiGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Me1 : MedialQuasiGroup A1)
      (Me2 : MedialQuasiGroup A2) :
      Set where
      constructor MedialQuasiGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Me1 x1 x2)
            (op Me2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Me1 x1 x2)
            (linv Me2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Me1 x1 x2)
            (rinv Me2 y1 y2)
    data MedialQuasiGroupLang
      : Set where
      opL :
        MedialQuasiGroupLang ->
        MedialQuasiGroupLang ->
        MedialQuasiGroupLang
      linvL :
        MedialQuasiGroupLang ->
        MedialQuasiGroupLang ->
        MedialQuasiGroupLang
      rinvL :
        MedialQuasiGroupLang ->
        MedialQuasiGroupLang ->
        MedialQuasiGroupLang
    data MedialQuasiGroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        MedialQuasiGroupOpenLang n
      opOL :
        MedialQuasiGroupOpenLang n ->
        MedialQuasiGroupOpenLang n ->
        MedialQuasiGroupOpenLang n
      linvOL :
        MedialQuasiGroupOpenLang n ->
        MedialQuasiGroupOpenLang n ->
        MedialQuasiGroupOpenLang n
      rinvOL :
        MedialQuasiGroupOpenLang n ->
        MedialQuasiGroupOpenLang n ->
        MedialQuasiGroupOpenLang n
    evalTerm :
      (A : Set) ->
      MedialQuasiGroup A ->
      MedialQuasiGroupLang -> A
    evalTerm _ Me (opL x1 x2) =
      op Me (evalTerm _ Me x1)
        (evalTerm _ Me x2)
    evalTerm _ Me (linvL x1 x2) =
      linv Me (evalTerm _ Me x1)
        (evalTerm _ Me x2)
    evalTerm _ Me (rinvL x1 x2) =
      rinv Me (evalTerm _ Me x1)
        (evalTerm _ Me x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MedialQuasiGroup A ->
      MedialQuasiGroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n me (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n me (opOL
                         x1
                         x2) vars =
      op me
        (evalOpenTerm _ n me x1 vars)
        (evalOpenTerm _ n me x2 vars)
    evalOpenTerm _ n me (linvOL
                         x1
                         x2) vars =
      linv me
        (evalOpenTerm _ n me x1 vars)
        (evalOpenTerm _ n me x2 vars)
    evalOpenTerm _ n me (rinvOL
                         x1
                         x2) vars =
      rinv me
        (evalOpenTerm _ n me x1 vars)
        (evalOpenTerm _ n me x2 vars)
    simplify :
      MedialQuasiGroupLang ->
      MedialQuasiGroupLang
    simplify (opL x (linvL x y)) = y
    simplify (linvL x (opL x y)) = y
    simplify (opL (rinvL y x) x) = y
    simplify (rinvL (opL y x) x) = y
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (linvL x1 x2) =
      linvL (simplify x1)
        (simplify x2)
    simplify (rinvL x1 x2) =
      rinvL (simplify x1)
        (simplify x2)
    liftMedialQuasiGroupLang :
      MedialQuasiGroupLang ->
      Staged MedialQuasiGroupLang
    liftMedialQuasiGroupLang x =
      Now x
    opOL' :
      (n : Nat) ->
      MedialQuasiGroupOpenLang n ->
      MedialQuasiGroupOpenLang n ->
      MedialQuasiGroupOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    linvOL' :
      (n : Nat) ->
      MedialQuasiGroupOpenLang n ->
      MedialQuasiGroupOpenLang n ->
      MedialQuasiGroupOpenLang n
    linvOL' _ x1 x2 = linvOL x1 x2
    rinvOL' :
      (n : Nat) ->
      MedialQuasiGroupOpenLang n ->
      MedialQuasiGroupOpenLang n ->
      MedialQuasiGroupOpenLang n
    rinvOL' _ x1 x2 = rinvOL x1 x2
    liftMedialQuasiGroupOpenLang :
      (n : Nat) ->
      MedialQuasiGroupOpenLang n ->
      Staged
        (MedialQuasiGroupOpenLang n)
    liftMedialQuasiGroupOpenLang _ (v
                                    fin) = const _ (code _ (v fin))
    liftMedialQuasiGroupOpenLang _ (opOL
                                    x1
                                    x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftMedialQuasiGroupOpenLang _
           x1)
        (liftMedialQuasiGroupOpenLang _
           x2)
    liftMedialQuasiGroupOpenLang _ (linvOL
                                    x1
                                    x2) =
      stage2 _ _ _ (linvOL' _)
        (codeLift2 _ _ _ (linvOL' _))
        (liftMedialQuasiGroupOpenLang _
           x1)
        (liftMedialQuasiGroupOpenLang _
           x2)
    liftMedialQuasiGroupOpenLang _ (rinvOL
                                    x1
                                    x2) =
      stage2 _ _ _ (rinvOL' _)
        (codeLift2 _ _ _ (rinvOL' _))
        (liftMedialQuasiGroupOpenLang _
           x1)
        (liftMedialQuasiGroupOpenLang _
           x2)
  
  module MeetSemilattice where
    record MeetSemilattice
      (A : Set) : Set where
      constructor MeetSemilatticeC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        idempotent_op :
          (x : A) -> op x x == x
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record MeetSemilatticeSig
      (AS : Set) : Set where
      constructor MeetSemilatticeSigSigC
      field
        opS : AS -> AS -> AS
    record MeetSemilatticeProd
      (AP : Set) : Set where
      constructor MeetSemilatticeProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        idempotent_opP :
          (xP : Prod AP AP) ->
          opP xP xP == xP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record MeetSemilatticeHom
      (A1 : Set) (A2 : Set)
      (Me1 : MeetSemilattice A1)
      (Me2 : MeetSemilattice A2) :
      Set where
      constructor MeetSemilatticeHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Me1 x1 x2) ==
            op Me2 (hom x1) (hom x2)
    record MeetSemilatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Me1 : MeetSemilattice A1)
      (Me2 : MeetSemilattice A2) :
      Set where
      constructor MeetSemilatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Me1 x1 x2)
            (op Me2 y1 y2)
    data MeetSemilatticeLang
      : Set where
      opL :
        MeetSemilatticeLang ->
        MeetSemilatticeLang ->
        MeetSemilatticeLang
    data MeetSemilatticeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        MeetSemilatticeOpenLang n
      opOL :
        MeetSemilatticeOpenLang n ->
        MeetSemilatticeOpenLang n ->
        MeetSemilatticeOpenLang n
    evalTerm :
      (A : Set) ->
      MeetSemilattice A ->
      MeetSemilatticeLang -> A
    evalTerm _ Me (opL x1 x2) =
      op Me (evalTerm _ Me x1)
        (evalTerm _ Me x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MeetSemilattice A ->
      MeetSemilatticeOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n me (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n me (opOL
                         x1
                         x2) vars =
      op me
        (evalOpenTerm _ n me x1 vars)
        (evalOpenTerm _ n me x2 vars)
    simplify :
      MeetSemilatticeLang ->
      MeetSemilatticeLang
    simplify (opL x x) = x
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftMeetSemilatticeLang :
      MeetSemilatticeLang ->
      Staged MeetSemilatticeLang
    liftMeetSemilatticeLang x =
      Now x
    opOL' :
      (n : Nat) ->
      MeetSemilatticeOpenLang n ->
      MeetSemilatticeOpenLang n ->
      MeetSemilatticeOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftMeetSemilatticeOpenLang :
      (n : Nat) ->
      MeetSemilatticeOpenLang n ->
      Staged
        (MeetSemilatticeOpenLang n)
    liftMeetSemilatticeOpenLang _ (v
                                   fin) = const _ (code _ (v fin))
    liftMeetSemilatticeOpenLang _ (opOL
                                   x1
                                   x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftMeetSemilatticeOpenLang _
           x1)
        (liftMeetSemilatticeOpenLang _
           x2)
  
  module MiddleAbsorption where
    record MiddleAbsorption
      (A : Set) : Set where
      constructor MiddleAbsorptionC
      field
        op : A -> A -> A
        middleAbsorb_* :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x z
    record MiddleAbsorptionSig
      (AS : Set) : Set where
      constructor MiddleAbsorptionSigSigC
      field
        opS : AS -> AS -> AS
    record MiddleAbsorptionProd
      (AP : Set) : Set where
      constructor MiddleAbsorptionProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        middleAbsorb_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP == opP xP zP
    record MiddleAbsorptionHom
      (A1 : Set) (A2 : Set)
      (Mi1 : MiddleAbsorption A1)
      (Mi2 : MiddleAbsorption A2) :
      Set where
      constructor MiddleAbsorptionHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mi1 x1 x2) ==
            op Mi2 (hom x1) (hom x2)
    record MiddleAbsorptionRelInterp
      (A1 : Set) (A2 : Set)
      (Mi1 : MiddleAbsorption A1)
      (Mi2 : MiddleAbsorption A2) :
      Set where
      constructor MiddleAbsorptionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mi1 x1 x2)
            (op Mi2 y1 y2)
    data MiddleAbsorptionLang
      : Set where
      opL :
        MiddleAbsorptionLang ->
        MiddleAbsorptionLang ->
        MiddleAbsorptionLang
    data MiddleAbsorptionOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        MiddleAbsorptionOpenLang n
      opOL :
        MiddleAbsorptionOpenLang n ->
        MiddleAbsorptionOpenLang n ->
        MiddleAbsorptionOpenLang n
    evalTerm :
      (A : Set) ->
      MiddleAbsorption A ->
      MiddleAbsorptionLang -> A
    evalTerm _ Mi (opL x1 x2) =
      op Mi (evalTerm _ Mi x1)
        (evalTerm _ Mi x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MiddleAbsorption A ->
      MiddleAbsorptionOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mi (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mi (opOL
                         x1
                         x2) vars =
      op mi
        (evalOpenTerm _ n mi x1 vars)
        (evalOpenTerm _ n mi x2 vars)
    simplify :
      MiddleAbsorptionLang ->
      MiddleAbsorptionLang
    simplify (opL (opL x y) z) =
      opL x z
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftMiddleAbsorptionLang :
      MiddleAbsorptionLang ->
      Staged MiddleAbsorptionLang
    liftMiddleAbsorptionLang x =
      Now x
    opOL' :
      (n : Nat) ->
      MiddleAbsorptionOpenLang n ->
      MiddleAbsorptionOpenLang n ->
      MiddleAbsorptionOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftMiddleAbsorptionOpenLang :
      (n : Nat) ->
      MiddleAbsorptionOpenLang n ->
      Staged
        (MiddleAbsorptionOpenLang n)
    liftMiddleAbsorptionOpenLang _ (v
                                    fin) = const _ (code _ (v fin))
    liftMiddleAbsorptionOpenLang _ (opOL
                                    x1
                                    x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftMiddleAbsorptionOpenLang _
           x1)
        (liftMiddleAbsorptionOpenLang _
           x2)
  
  module MiddleCommute where
    record MiddleCommute
      (A : Set) : Set where
      constructor MiddleCommuteC
      field
        op : A -> A -> A
        middleCommute_* :
          (x : A) (y : A) (z : A) ->
          op (op (op x y) z) x ==
            op (op (op x z) y) x
    record MiddleCommuteSig
      (AS : Set) : Set where
      constructor MiddleCommuteSigSigC
      field
        opS : AS -> AS -> AS
    record MiddleCommuteProd
      (AP : Set) : Set where
      constructor MiddleCommuteProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        middleCommute_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP (opP xP yP) zP) xP ==
            opP (opP (opP xP zP) yP) xP
    record MiddleCommuteHom
      (A1 : Set) (A2 : Set)
      (Mi1 : MiddleCommute A1)
      (Mi2 : MiddleCommute A2) :
      Set where
      constructor MiddleCommuteHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mi1 x1 x2) ==
            op Mi2 (hom x1) (hom x2)
    record MiddleCommuteRelInterp
      (A1 : Set) (A2 : Set)
      (Mi1 : MiddleCommute A1)
      (Mi2 : MiddleCommute A2) :
      Set where
      constructor MiddleCommuteRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mi1 x1 x2)
            (op Mi2 y1 y2)
    data MiddleCommuteLang
      : Set where
      opL :
        MiddleCommuteLang ->
        MiddleCommuteLang ->
        MiddleCommuteLang
    data MiddleCommuteOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> MiddleCommuteOpenLang n
      opOL :
        MiddleCommuteOpenLang n ->
        MiddleCommuteOpenLang n ->
        MiddleCommuteOpenLang n
    evalTerm :
      (A : Set) ->
      MiddleCommute A ->
      MiddleCommuteLang -> A
    evalTerm _ Mi (opL x1 x2) =
      op Mi (evalTerm _ Mi x1)
        (evalTerm _ Mi x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MiddleCommute A ->
      MiddleCommuteOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mi (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mi (opOL
                         x1
                         x2) vars =
      op mi
        (evalOpenTerm _ n mi x1 vars)
        (evalOpenTerm _ n mi x2 vars)
    simplify :
      MiddleCommuteLang ->
      MiddleCommuteLang
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftMiddleCommuteLang :
      MiddleCommuteLang ->
      Staged MiddleCommuteLang
    liftMiddleCommuteLang x = Now x
    opOL' :
      (n : Nat) ->
      MiddleCommuteOpenLang n ->
      MiddleCommuteOpenLang n ->
      MiddleCommuteOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftMiddleCommuteOpenLang :
      (n : Nat) ->
      MiddleCommuteOpenLang n ->
      Staged (MiddleCommuteOpenLang n)
    liftMiddleCommuteOpenLang _ (v
                                 fin) = const _ (code _ (v fin))
    liftMiddleCommuteOpenLang _ (opOL
                                 x1
                                 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftMiddleCommuteOpenLang _ x1)
        (liftMiddleCommuteOpenLang _ x2)
  
  module ModularLattice where
    record ModularLattice
      (A : Set) : Set where
      constructor ModularLatticeC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
        leftModular_*_+ :
          (x : A) (y : A) (z : A) ->
          + (* x y) (* x z) ==
            * x (+ y (* x z))
    record ModularLatticeSig
      (AS : Set) : Set where
      constructor ModularLatticeSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record ModularLatticeProd
      (AP : Set) : Set where
      constructor ModularLatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
        leftModular_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (*P xP yP) (*P xP zP) ==
            *P xP (+P yP (*P xP zP))
    record ModularLatticeHom
      (A1 : Set) (A2 : Set)
      (Mo1 : ModularLattice A1)
      (Mo2 : ModularLattice A2) :
      Set where
      constructor ModularLatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mo1 x1 x2) ==
            * Mo2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Mo1 x1 x2) ==
            + Mo2 (hom x1) (hom x2)
    record ModularLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : ModularLattice A1)
      (Mo2 : ModularLattice A2) :
      Set where
      constructor ModularLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mo1 x1 x2)
            (* Mo2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Mo1 x1 x2)
            (+ Mo2 y1 y2)
    data ModularLatticeLang
      : Set where
      *L :
        ModularLatticeLang ->
        ModularLatticeLang ->
        ModularLatticeLang
      +L :
        ModularLatticeLang ->
        ModularLatticeLang ->
        ModularLatticeLang
    data ModularLatticeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        ModularLatticeOpenLang n
      *OL :
        ModularLatticeOpenLang n ->
        ModularLatticeOpenLang n ->
        ModularLatticeOpenLang n
      +OL :
        ModularLatticeOpenLang n ->
        ModularLatticeOpenLang n ->
        ModularLatticeOpenLang n
    evalTerm :
      (A : Set) ->
      ModularLattice A ->
      ModularLatticeLang -> A
    evalTerm _ Mo (*L x1 x2) =
      * Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalTerm _ Mo (+L x1 x2) =
      + Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      ModularLattice A ->
      ModularLatticeOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mo (*OL
                         x1
                         x2) vars =
      * mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
    evalOpenTerm _ n mo (+OL
                         x1
                         x2) vars =
      + mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
    simplify :
      ModularLatticeLang ->
      ModularLatticeLang
    simplify (*L x x) = x
    simplify (+L x x) = x
    simplify (*L x (+L x y)) = x
    simplify (+L x (*L x y)) = x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftModularLatticeLang :
      ModularLatticeLang ->
      Staged ModularLatticeLang
    liftModularLatticeLang x = Now x
    *OL' :
      (n : Nat) ->
      ModularLatticeOpenLang n ->
      ModularLatticeOpenLang n ->
      ModularLatticeOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      ModularLatticeOpenLang n ->
      ModularLatticeOpenLang n ->
      ModularLatticeOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftModularLatticeOpenLang :
      (n : Nat) ->
      ModularLatticeOpenLang n ->
      Staged
        (ModularLatticeOpenLang n)
    liftModularLatticeOpenLang _ (v
                                  fin) = const _ (code _ (v fin))
    liftModularLatticeOpenLang _ (*OL
                                  x1
                                  x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftModularLatticeOpenLang _
           x1)
        (liftModularLatticeOpenLang _
           x2)
    liftModularLatticeOpenLang _ (+OL
                                  x1
                                  x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftModularLatticeOpenLang _
           x1)
        (liftModularLatticeOpenLang _
           x2)
  
  module Modularity where
    record Modularity
      (A : Set) : Set where
      constructor ModularityC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftModular_*_+ :
          (x : A) (y : A) (z : A) ->
          + (* x y) (* x z) ==
            * x (+ y (* x z))
    record ModularitySig
      (AS : Set) : Set where
      constructor ModularitySigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record ModularityProd
      (AP : Set) : Set where
      constructor ModularityProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftModular_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (*P xP yP) (*P xP zP) ==
            *P xP (+P yP (*P xP zP))
    record ModularityHom
      (A1 : Set) (A2 : Set)
      (Mo1 : Modularity A1)
      (Mo2 : Modularity A2) :
      Set where
      constructor ModularityHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mo1 x1 x2) ==
            * Mo2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Mo1 x1 x2) ==
            + Mo2 (hom x1) (hom x2)
    record ModularityRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : Modularity A1)
      (Mo2 : Modularity A2) :
      Set where
      constructor ModularityRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mo1 x1 x2)
            (* Mo2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Mo1 x1 x2)
            (+ Mo2 y1 y2)
    data ModularityLang : Set where
      *L :
        ModularityLang ->
        ModularityLang -> ModularityLang
      +L :
        ModularityLang ->
        ModularityLang -> ModularityLang
    data ModularityOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> ModularityOpenLang n
      *OL :
        ModularityOpenLang n ->
        ModularityOpenLang n ->
        ModularityOpenLang n
      +OL :
        ModularityOpenLang n ->
        ModularityOpenLang n ->
        ModularityOpenLang n
    evalTerm :
      (A : Set) ->
      Modularity A ->
      ModularityLang -> A
    evalTerm _ Mo (*L x1 x2) =
      * Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalTerm _ Mo (+L x1 x2) =
      + Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Modularity A ->
      ModularityOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mo (*OL
                         x1
                         x2) vars =
      * mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
    evalOpenTerm _ n mo (+OL
                         x1
                         x2) vars =
      + mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
    simplify :
      ModularityLang -> ModularityLang
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftModularityLang :
      ModularityLang ->
      Staged ModularityLang
    liftModularityLang x = Now x
    *OL' :
      (n : Nat) ->
      ModularityOpenLang n ->
      ModularityOpenLang n ->
      ModularityOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      ModularityOpenLang n ->
      ModularityOpenLang n ->
      ModularityOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftModularityOpenLang :
      (n : Nat) ->
      ModularityOpenLang n ->
      Staged (ModularityOpenLang n)
    liftModularityOpenLang _ (v
                              fin) = const _ (code _ (v fin))
    liftModularityOpenLang _ (*OL
                              x1
                              x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftModularityOpenLang _ x1)
        (liftModularityOpenLang _ x2)
    liftModularityOpenLang _ (+OL
                              x1
                              x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftModularityOpenLang _ x1)
        (liftModularityOpenLang _ x2)
  
  module Monoid where
    record Monoid
      (A : Set) : Set where
      constructor MonoidC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record MonoidSig
      (AS : Set) : Set where
      constructor MonoidSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record MonoidProd
      (AP : Set) : Set where
      constructor MonoidProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record MonoidHom
      (A1 : Set) (A2 : Set)
      (Mo1 : Monoid A1)
      (Mo2 : Monoid A2) : Set where
      constructor MonoidHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Mo1) == e Mo2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mo1 x1 x2) ==
            op Mo2 (hom x1) (hom x2)
    record MonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : Monoid A1)
      (Mo2 : Monoid A2) : Set where
      constructor MonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Mo1) (e Mo2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mo1 x1 x2)
            (op Mo2 y1 y2)
    data MonoidLang : Set where
      eL : MonoidLang
      opL :
        MonoidLang ->
        MonoidLang -> MonoidLang
    data MonoidOpenLang
      (n : Nat) : Set where
      v : Fin n -> MonoidOpenLang n
      eOL : MonoidOpenLang n
      opOL :
        MonoidOpenLang n ->
        MonoidOpenLang n ->
        MonoidOpenLang n
    evalTerm :
      (A : Set) ->
      Monoid A -> MonoidLang -> A
    evalTerm _ Mo (eL) = e Mo
    evalTerm _ Mo (opL x1 x2) =
      op Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Monoid A ->
      MonoidOpenLang n -> Vec A n -> A
    evalOpenTerm _ n mo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mo (eOL) vars =
      e mo
    evalOpenTerm _ n mo (opOL
                         x1
                         x2) vars =
      op mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
    simplify :
      MonoidLang -> MonoidLang
    simplify (opL (eL) x) = x
    simplify (opL x (eL)) = x
    simplify (eL) = eL
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftMonoidLang :
      MonoidLang -> Staged MonoidLang
    liftMonoidLang x = Now x
    eOL' :
      (n : Nat) -> MonoidOpenLang n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      MonoidOpenLang n ->
      MonoidOpenLang n ->
      MonoidOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftMonoidOpenLang :
      (n : Nat) ->
      MonoidOpenLang n ->
      Staged (MonoidOpenLang n)
    liftMonoidOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftMonoidOpenLang _ (eOL) =
      Now eOL
    liftMonoidOpenLang _ (opOL
                          x1
                          x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftMonoidOpenLang _ x1)
        (liftMonoidOpenLang _ x2)
  
  module Monoid1 where
    record Monoid1
      (A : Set) : Set where
      constructor Monoid1C
      field
        1 : A
        op : A -> A -> A
        lunit_1 : (x : A) -> op 1 x == x
        runit_1 : (x : A) -> op x 1 == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record Monoid1Sig
      (AS : Set) : Set where
      constructor Monoid1SigSigC
      field
        1S : AS
        opS : AS -> AS -> AS
    record Monoid1Prod
      (AP : Set) : Set where
      constructor Monoid1ProdC
      field
        1P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          opP 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          opP xP 1P == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record Monoid1Hom
      (A1 : Set) (A2 : Set)
      (Mo1 : Monoid1 A1)
      (Mo2 : Monoid1 A2) : Set where
      constructor Monoid1HomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Mo1) == 1 Mo2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mo1 x1 x2) ==
            op Mo2 (hom x1) (hom x2)
    record Monoid1RelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : Monoid1 A1)
      (Mo2 : Monoid1 A2) : Set where
      constructor Monoid1RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Mo1) (1 Mo2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mo1 x1 x2)
            (op Mo2 y1 y2)
    data Monoid1Lang : Set where
      1L : Monoid1Lang
      opL :
        Monoid1Lang ->
        Monoid1Lang -> Monoid1Lang
    data Monoid1OpenLang
      (n : Nat) : Set where
      v : Fin n -> Monoid1OpenLang n
      1OL : Monoid1OpenLang n
      opOL :
        Monoid1OpenLang n ->
        Monoid1OpenLang n ->
        Monoid1OpenLang n
    evalTerm :
      (A : Set) ->
      Monoid1 A -> Monoid1Lang -> A
    evalTerm _ Mo (1L) = 1 Mo
    evalTerm _ Mo (opL x1 x2) =
      op Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Monoid1 A ->
      Monoid1OpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mo (1OL) vars =
      1 mo
    evalOpenTerm _ n mo (opOL
                         x1
                         x2) vars =
      op mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
    simplify :
      Monoid1Lang -> Monoid1Lang
    simplify (opL (1L) x) = x
    simplify (opL x (1L)) = x
    simplify (1L) = 1L
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftMonoid1Lang :
      Monoid1Lang ->
      Staged Monoid1Lang
    liftMonoid1Lang x = Now x
    1OL' :
      (n : Nat) -> Monoid1OpenLang n
    1OL' _ = 1OL
    opOL' :
      (n : Nat) ->
      Monoid1OpenLang n ->
      Monoid1OpenLang n ->
      Monoid1OpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftMonoid1OpenLang :
      (n : Nat) ->
      Monoid1OpenLang n ->
      Staged (Monoid1OpenLang n)
    liftMonoid1OpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftMonoid1OpenLang _ (1OL) =
      Now 1OL
    liftMonoid1OpenLang _ (opOL
                           x1
                           x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftMonoid1OpenLang _ x1)
        (liftMonoid1OpenLang _ x2)
  
  module MoufangIdentity where
    record MoufangIdentity
      (A : Set) : Set where
      constructor MoufangIdentityC
      field
        op : A -> A -> A
        moufangId :
          (x : A) (y : A) (z : A) ->
          op (op z x) (op y z) ==
            op (op z (op x y)) z
    record MoufangIdentitySig
      (AS : Set) : Set where
      constructor MoufangIdentitySigSigC
      field
        opS : AS -> AS -> AS
    record MoufangIdentityProd
      (AP : Set) : Set where
      constructor MoufangIdentityProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        moufangIdP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP zP xP) (opP yP zP) ==
            opP (opP zP (opP xP yP)) zP
    record MoufangIdentityHom
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangIdentity A1)
      (Mo2 : MoufangIdentity A2) :
      Set where
      constructor MoufangIdentityHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mo1 x1 x2) ==
            op Mo2 (hom x1) (hom x2)
    record MoufangIdentityRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangIdentity A1)
      (Mo2 : MoufangIdentity A2) :
      Set where
      constructor MoufangIdentityRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mo1 x1 x2)
            (op Mo2 y1 y2)
    data MoufangIdentityLang
      : Set where
      opL :
        MoufangIdentityLang ->
        MoufangIdentityLang ->
        MoufangIdentityLang
    data MoufangIdentityOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        MoufangIdentityOpenLang n
      opOL :
        MoufangIdentityOpenLang n ->
        MoufangIdentityOpenLang n ->
        MoufangIdentityOpenLang n
    evalTerm :
      (A : Set) ->
      MoufangIdentity A ->
      MoufangIdentityLang -> A
    evalTerm _ Mo (opL x1 x2) =
      op Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MoufangIdentity A ->
      MoufangIdentityOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mo (opOL
                         x1
                         x2) vars =
      op mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
    simplify :
      MoufangIdentityLang ->
      MoufangIdentityLang
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftMoufangIdentityLang :
      MoufangIdentityLang ->
      Staged MoufangIdentityLang
    liftMoufangIdentityLang x =
      Now x
    opOL' :
      (n : Nat) ->
      MoufangIdentityOpenLang n ->
      MoufangIdentityOpenLang n ->
      MoufangIdentityOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftMoufangIdentityOpenLang :
      (n : Nat) ->
      MoufangIdentityOpenLang n ->
      Staged
        (MoufangIdentityOpenLang n)
    liftMoufangIdentityOpenLang _ (v
                                   fin) = const _ (code _ (v fin))
    liftMoufangIdentityOpenLang _ (opOL
                                   x1
                                   x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftMoufangIdentityOpenLang _
           x1)
        (liftMoufangIdentityOpenLang _
           x2)
  
  module MoufangLaw where
    record MoufangLaw
      (A : Set) : Set where
      constructor MoufangLawC
      field
        op : A -> A -> A
        moufangLaw :
          (e : A) (x : A) (y : A)
          (z : A) ->
          op y e == y ->
          op (op (op x y) z) x ==
            op x (op y (op (op e z) x))
    record MoufangLawSig
      (AS : Set) : Set where
      constructor MoufangLawSigSigC
      field
        opS : AS -> AS -> AS
    record MoufangLawProd
      (AP : Set) : Set where
      constructor MoufangLawProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        moufangLawP :
          (eP : Prod AP AP)
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP yP eP == yP ->
          opP (opP (opP xP yP) zP) xP ==
            opP xP
              (opP yP (opP (opP eP zP) xP))
    record MoufangLawHom
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangLaw A1)
      (Mo2 : MoufangLaw A2) :
      Set where
      constructor MoufangLawHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mo1 x1 x2) ==
            op Mo2 (hom x1) (hom x2)
    record MoufangLawRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangLaw A1)
      (Mo2 : MoufangLaw A2) :
      Set where
      constructor MoufangLawRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mo1 x1 x2)
            (op Mo2 y1 y2)
    data MoufangLawLang : Set where
      opL :
        MoufangLawLang ->
        MoufangLawLang -> MoufangLawLang
    data MoufangLawOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> MoufangLawOpenLang n
      opOL :
        MoufangLawOpenLang n ->
        MoufangLawOpenLang n ->
        MoufangLawOpenLang n
    evalTerm :
      (A : Set) ->
      MoufangLaw A ->
      MoufangLawLang -> A
    evalTerm _ Mo (opL x1 x2) =
      op Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MoufangLaw A ->
      MoufangLawOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mo (opOL
                         x1
                         x2) vars =
      op mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
    simplify :
      MoufangLawLang -> MoufangLawLang
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftMoufangLawLang :
      MoufangLawLang ->
      Staged MoufangLawLang
    liftMoufangLawLang x = Now x
    opOL' :
      (n : Nat) ->
      MoufangLawOpenLang n ->
      MoufangLawOpenLang n ->
      MoufangLawOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftMoufangLawOpenLang :
      (n : Nat) ->
      MoufangLawOpenLang n ->
      Staged (MoufangLawOpenLang n)
    liftMoufangLawOpenLang _ (v
                              fin) = const _ (code _ (v fin))
    liftMoufangLawOpenLang _ (opOL
                              x1
                              x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftMoufangLawOpenLang _ x1)
        (liftMoufangLawOpenLang _ x2)
  
  module MoufangLoop where
    record MoufangLoop
      (A : Set) : Set where
      constructor MoufangLoopC
      field
        op : A -> A -> A
        e : A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
        moufangId :
          (x : A) (y : A) (z : A) ->
          op (op z x) (op y z) ==
            op (op z (op x y)) z
    record MoufangLoopSig
      (AS : Set) : Set where
      constructor MoufangLoopSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
        linvS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record MoufangLoopProd
      (AP : Set) : Set where
      constructor MoufangLoopProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
        moufangIdP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP zP xP) (opP yP zP) ==
            opP (opP zP (opP xP yP)) zP
    record MoufangLoopHom
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangLoop A1)
      (Mo2 : MoufangLoop A2) :
      Set where
      constructor MoufangLoopHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mo1 x1 x2) ==
            op Mo2 (hom x1) (hom x2)
        pres-e : hom (e Mo1) == e Mo2
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Mo1 x1 x2) ==
            linv Mo2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Mo1 x1 x2) ==
            rinv Mo2 (hom x1) (hom x2)
    record MoufangLoopRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangLoop A1)
      (Mo2 : MoufangLoop A2) :
      Set where
      constructor MoufangLoopRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mo1 x1 x2)
            (op Mo2 y1 y2)
        interp-e :
          interp (e Mo1) (e Mo2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Mo1 x1 x2)
            (linv Mo2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Mo1 x1 x2)
            (rinv Mo2 y1 y2)
    data MoufangLoopLang : Set where
      opL :
        MoufangLoopLang ->
        MoufangLoopLang ->
        MoufangLoopLang
      eL : MoufangLoopLang
      linvL :
        MoufangLoopLang ->
        MoufangLoopLang ->
        MoufangLoopLang
      rinvL :
        MoufangLoopLang ->
        MoufangLoopLang ->
        MoufangLoopLang
    data MoufangLoopOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> MoufangLoopOpenLang n
      opOL :
        MoufangLoopOpenLang n ->
        MoufangLoopOpenLang n ->
        MoufangLoopOpenLang n
      eOL : MoufangLoopOpenLang n
      linvOL :
        MoufangLoopOpenLang n ->
        MoufangLoopOpenLang n ->
        MoufangLoopOpenLang n
      rinvOL :
        MoufangLoopOpenLang n ->
        MoufangLoopOpenLang n ->
        MoufangLoopOpenLang n
    evalTerm :
      (A : Set) ->
      MoufangLoop A ->
      MoufangLoopLang -> A
    evalTerm _ Mo (opL x1 x2) =
      op Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalTerm _ Mo (eL) = e Mo
    evalTerm _ Mo (linvL x1 x2) =
      linv Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalTerm _ Mo (rinvL x1 x2) =
      rinv Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MoufangLoop A ->
      MoufangLoopOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mo (opOL
                         x1
                         x2) vars =
      op mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
    evalOpenTerm _ n mo (eOL) vars =
      e mo
    evalOpenTerm _ n mo (linvOL
                         x1
                         x2) vars =
      linv mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
    evalOpenTerm _ n mo (rinvOL
                         x1
                         x2) vars =
      rinv mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
    simplify :
      MoufangLoopLang ->
      MoufangLoopLang
    simplify (opL (eL) x) = x
    simplify (opL x (eL)) = x
    simplify (opL x (linvL x y)) = y
    simplify (linvL x (opL x y)) = y
    simplify (opL (rinvL y x) x) = y
    simplify (rinvL (opL y x) x) = y
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (eL) = eL
    simplify (linvL x1 x2) =
      linvL (simplify x1)
        (simplify x2)
    simplify (rinvL x1 x2) =
      rinvL (simplify x1)
        (simplify x2)
    liftMoufangLoopLang :
      MoufangLoopLang ->
      Staged MoufangLoopLang
    liftMoufangLoopLang x = Now x
    opOL' :
      (n : Nat) ->
      MoufangLoopOpenLang n ->
      MoufangLoopOpenLang n ->
      MoufangLoopOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    eOL' :
      (n : Nat) ->
      MoufangLoopOpenLang n
    eOL' _ = eOL
    linvOL' :
      (n : Nat) ->
      MoufangLoopOpenLang n ->
      MoufangLoopOpenLang n ->
      MoufangLoopOpenLang n
    linvOL' _ x1 x2 = linvOL x1 x2
    rinvOL' :
      (n : Nat) ->
      MoufangLoopOpenLang n ->
      MoufangLoopOpenLang n ->
      MoufangLoopOpenLang n
    rinvOL' _ x1 x2 = rinvOL x1 x2
    liftMoufangLoopOpenLang :
      (n : Nat) ->
      MoufangLoopOpenLang n ->
      Staged (MoufangLoopOpenLang n)
    liftMoufangLoopOpenLang _ (v
                               fin) = const _ (code _ (v fin))
    liftMoufangLoopOpenLang _ (opOL
                               x1
                               x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftMoufangLoopOpenLang _ x1)
        (liftMoufangLoopOpenLang _ x2)
    liftMoufangLoopOpenLang _ (eOL) =
      Now eOL
    liftMoufangLoopOpenLang _ (linvOL
                               x1
                               x2) =
      stage2 _ _ _ (linvOL' _)
        (codeLift2 _ _ _ (linvOL' _))
        (liftMoufangLoopOpenLang _ x1)
        (liftMoufangLoopOpenLang _ x2)
    liftMoufangLoopOpenLang _ (rinvOL
                               x1
                               x2) =
      stage2 _ _ _ (rinvOL' _)
        (codeLift2 _ _ _ (rinvOL' _))
        (liftMoufangLoopOpenLang _ x1)
        (liftMoufangLoopOpenLang _ x2)
  
  module MoufangQuasiGroup where
    record MoufangQuasiGroup
      (A : Set) : Set where
      constructor MoufangQuasiGroupC
      field
        op : A -> A -> A
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
        moufangLaw :
          (e : A) (x : A) (y : A)
          (z : A) ->
          op y e == y ->
          op (op (op x y) z) x ==
            op x (op y (op (op e z) x))
    record MoufangQuasiGroupSig
      (AS : Set) : Set where
      constructor MoufangQuasiGroupSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record MoufangQuasiGroupProd
      (AP : Set) : Set where
      constructor MoufangQuasiGroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
        moufangLawP :
          (eP : Prod AP AP)
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP yP eP == yP ->
          opP (opP (opP xP yP) zP) xP ==
            opP xP
              (opP yP (opP (opP eP zP) xP))
    record MoufangQuasiGroupHom
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangQuasiGroup A1)
      (Mo2 : MoufangQuasiGroup A2) :
      Set where
      constructor MoufangQuasiGroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mo1 x1 x2) ==
            op Mo2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Mo1 x1 x2) ==
            linv Mo2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Mo1 x1 x2) ==
            rinv Mo2 (hom x1) (hom x2)
    record MoufangQuasiGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangQuasiGroup A1)
      (Mo2 : MoufangQuasiGroup A2) :
      Set where
      constructor MoufangQuasiGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mo1 x1 x2)
            (op Mo2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Mo1 x1 x2)
            (linv Mo2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Mo1 x1 x2)
            (rinv Mo2 y1 y2)
    data MoufangQuasiGroupLang
      : Set where
      opL :
        MoufangQuasiGroupLang ->
        MoufangQuasiGroupLang ->
        MoufangQuasiGroupLang
      linvL :
        MoufangQuasiGroupLang ->
        MoufangQuasiGroupLang ->
        MoufangQuasiGroupLang
      rinvL :
        MoufangQuasiGroupLang ->
        MoufangQuasiGroupLang ->
        MoufangQuasiGroupLang
    data MoufangQuasiGroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        MoufangQuasiGroupOpenLang n
      opOL :
        MoufangQuasiGroupOpenLang n ->
        MoufangQuasiGroupOpenLang n ->
        MoufangQuasiGroupOpenLang n
      linvOL :
        MoufangQuasiGroupOpenLang n ->
        MoufangQuasiGroupOpenLang n ->
        MoufangQuasiGroupOpenLang n
      rinvOL :
        MoufangQuasiGroupOpenLang n ->
        MoufangQuasiGroupOpenLang n ->
        MoufangQuasiGroupOpenLang n
    evalTerm :
      (A : Set) ->
      MoufangQuasiGroup A ->
      MoufangQuasiGroupLang -> A
    evalTerm _ Mo (opL x1 x2) =
      op Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalTerm _ Mo (linvL x1 x2) =
      linv Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalTerm _ Mo (rinvL x1 x2) =
      rinv Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MoufangQuasiGroup A ->
      MoufangQuasiGroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mo (opOL
                         x1
                         x2) vars =
      op mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
    evalOpenTerm _ n mo (linvOL
                         x1
                         x2) vars =
      linv mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
    evalOpenTerm _ n mo (rinvOL
                         x1
                         x2) vars =
      rinv mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
    simplify :
      MoufangQuasiGroupLang ->
      MoufangQuasiGroupLang
    simplify (opL x (linvL x y)) = y
    simplify (linvL x (opL x y)) = y
    simplify (opL (rinvL y x) x) = y
    simplify (rinvL (opL y x) x) = y
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (linvL x1 x2) =
      linvL (simplify x1)
        (simplify x2)
    simplify (rinvL x1 x2) =
      rinvL (simplify x1)
        (simplify x2)
    liftMoufangQuasiGroupLang :
      MoufangQuasiGroupLang ->
      Staged MoufangQuasiGroupLang
    liftMoufangQuasiGroupLang x =
      Now x
    opOL' :
      (n : Nat) ->
      MoufangQuasiGroupOpenLang n ->
      MoufangQuasiGroupOpenLang n ->
      MoufangQuasiGroupOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    linvOL' :
      (n : Nat) ->
      MoufangQuasiGroupOpenLang n ->
      MoufangQuasiGroupOpenLang n ->
      MoufangQuasiGroupOpenLang n
    linvOL' _ x1 x2 = linvOL x1 x2
    rinvOL' :
      (n : Nat) ->
      MoufangQuasiGroupOpenLang n ->
      MoufangQuasiGroupOpenLang n ->
      MoufangQuasiGroupOpenLang n
    rinvOL' _ x1 x2 = rinvOL x1 x2
    liftMoufangQuasiGroupOpenLang :
      (n : Nat) ->
      MoufangQuasiGroupOpenLang n ->
      Staged
        (MoufangQuasiGroupOpenLang n)
    liftMoufangQuasiGroupOpenLang _ (v
                                     fin) = const _ (code _ (v fin))
    liftMoufangQuasiGroupOpenLang _ (opOL
                                     x1
                                     x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftMoufangQuasiGroupOpenLang _
           x1)
        (liftMoufangQuasiGroupOpenLang _
           x2)
    liftMoufangQuasiGroupOpenLang _ (linvOL
                                     x1
                                     x2) =
      stage2 _ _ _ (linvOL' _)
        (codeLift2 _ _ _ (linvOL' _))
        (liftMoufangQuasiGroupOpenLang _
           x1)
        (liftMoufangQuasiGroupOpenLang _
           x2)
    liftMoufangQuasiGroupOpenLang _ (rinvOL
                                     x1
                                     x2) =
      stage2 _ _ _ (rinvOL' _)
        (codeLift2 _ _ _ (rinvOL' _))
        (liftMoufangQuasiGroupOpenLang _
           x1)
        (liftMoufangQuasiGroupOpenLang _
           x2)
  
  module MultCommutativeMonoid where
    record MultCommutativeMonoid
      (A : Set) : Set where
      constructor MultCommutativeMonoidC
      field
        1 : A
        * : A -> A -> A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
    record MultCommutativeMonoidSig
      (AS : Set) : Set where
      constructor MultCommutativeMonoidSigSigC
      field
        1S : AS
        *S : AS -> AS -> AS
    record MultCommutativeMonoidProd
      (AP : Set) : Set where
      constructor MultCommutativeMonoidProdC
      field
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
    record MultCommutativeMonoidHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultCommutativeMonoid A1)
      (Mu2 : MultCommutativeMonoid
         A2) : Set where
      constructor MultCommutativeMonoidHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Mu1) == 1 Mu2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultCommutativeMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultCommutativeMonoid A1)
      (Mu2 : MultCommutativeMonoid
         A2) : Set where
      constructor MultCommutativeMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Mu1) (1 Mu2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultCommutativeMonoidLang
      : Set where
      1L : MultCommutativeMonoidLang
      *L :
        MultCommutativeMonoidLang ->
        MultCommutativeMonoidLang ->
        MultCommutativeMonoidLang
    data MultCommutativeMonoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        MultCommutativeMonoidOpenLang n
      1OL :
        MultCommutativeMonoidOpenLang n
      *OL :
        MultCommutativeMonoidOpenLang
          n ->
        MultCommutativeMonoidOpenLang
          n ->
        MultCommutativeMonoidOpenLang n
    evalTerm :
      (A : Set) ->
      MultCommutativeMonoid A ->
      MultCommutativeMonoidLang -> A
    evalTerm _ Mu (1L) = 1 Mu
    evalTerm _ Mu (*L x1 x2) =
      * Mu (evalTerm _ Mu x1)
        (evalTerm _ Mu x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MultCommutativeMonoid A ->
      MultCommutativeMonoidOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n mu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mu (1OL) vars =
      1 mu
    evalOpenTerm _ n mu (*OL
                         x1
                         x2) vars =
      * mu
        (evalOpenTerm _ n mu x1 vars)
        (evalOpenTerm _ n mu x2 vars)
    simplify :
      MultCommutativeMonoidLang ->
      MultCommutativeMonoidLang
    simplify (*L (1L) x) = x
    simplify (*L x (1L)) = x
    simplify (1L) = 1L
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    liftMultCommutativeMonoidLang :
      MultCommutativeMonoidLang ->
      Staged MultCommutativeMonoidLang
    liftMultCommutativeMonoidLang x =
      Now x
    1OL' :
      (n : Nat) ->
      MultCommutativeMonoidOpenLang n
    1OL' _ = 1OL
    *OL' :
      (n : Nat) ->
      MultCommutativeMonoidOpenLang
        n ->
      MultCommutativeMonoidOpenLang
        n ->
      MultCommutativeMonoidOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    liftMultCommutativeMonoidOpenLang :
      (n : Nat) ->
      MultCommutativeMonoidOpenLang
        n ->
      Staged
        (MultCommutativeMonoidOpenLang
           n)
    liftMultCommutativeMonoidOpenLang _ (v
                                         fin) = const _ (code _ (v fin))
    liftMultCommutativeMonoidOpenLang _ (1OL) =
      Now 1OL
    liftMultCommutativeMonoidOpenLang _ (*OL
                                         x1
                                         x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftMultCommutativeMonoidOpenLang
           _
           x1)
        (liftMultCommutativeMonoidOpenLang
           _
           x2)
  
  module MultCommutativeSemigroup where
    record MultCommutativeSemigroup
      (A : Set) : Set where
      constructor MultCommutativeSemigroupC
      field
        * : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
    record MultCommutativeSemigroupSig
      (AS : Set) : Set where
      constructor MultCommutativeSemigroupSigSigC
      field
        *S : AS -> AS -> AS
    record MultCommutativeSemigroupProd
      (AP : Set) : Set where
      constructor MultCommutativeSemigroupProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
    record MultCommutativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultCommutativeSemigroup
         A1)
      (Mu2 : MultCommutativeSemigroup
         A2) : Set where
      constructor MultCommutativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultCommutativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultCommutativeSemigroup
         A1)
      (Mu2 : MultCommutativeSemigroup
         A2) : Set where
      constructor MultCommutativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultCommutativeSemigroupLang
      : Set where
      *L :
        MultCommutativeSemigroupLang ->
        MultCommutativeSemigroupLang ->
        MultCommutativeSemigroupLang
    data MultCommutativeSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        MultCommutativeSemigroupOpenLang
          n
      *OL :
        MultCommutativeSemigroupOpenLang
          n ->
        MultCommutativeSemigroupOpenLang
          n ->
        MultCommutativeSemigroupOpenLang
          n
    evalTerm :
      (A : Set) ->
      MultCommutativeSemigroup A ->
      MultCommutativeSemigroupLang ->
      A
    evalTerm _ Mu (*L x1 x2) =
      * Mu (evalTerm _ Mu x1)
        (evalTerm _ Mu x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MultCommutativeSemigroup A ->
      MultCommutativeSemigroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n mu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mu (*OL
                         x1
                         x2) vars =
      * mu
        (evalOpenTerm _ n mu x1 vars)
        (evalOpenTerm _ n mu x2 vars)
    simplify :
      MultCommutativeSemigroupLang ->
      MultCommutativeSemigroupLang
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    liftMultCommutativeSemigroupLang :
      MultCommutativeSemigroupLang ->
      Staged
        MultCommutativeSemigroupLang
    liftMultCommutativeSemigroupLang x =
      Now x
    *OL' :
      (n : Nat) ->
      MultCommutativeSemigroupOpenLang
        n ->
      MultCommutativeSemigroupOpenLang
        n ->
      MultCommutativeSemigroupOpenLang
        n
    *OL' _ x1 x2 = *OL x1 x2
    liftMultCommutativeSemigroupOpenLang :
      (n : Nat) ->
      MultCommutativeSemigroupOpenLang
        n ->
      Staged
        (MultCommutativeSemigroupOpenLang
           n)
    liftMultCommutativeSemigroupOpenLang _ (v
                                            fin) = const _ (code _ (v fin))
    liftMultCommutativeSemigroupOpenLang _ (*OL
                                            x1
                                            x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftMultCommutativeSemigroupOpenLang
           _
           x1)
        (liftMultCommutativeSemigroupOpenLang
           _
           x2)
  
  module MultGroup where
    record MultGroup
      (A : Set) : Set where
      constructor MultGroupC
      field
        1 : A
        * : A -> A -> A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        inv : A -> A
        leftInverse_inv_op_1 :
          (x : A) -> * x (inv x) == 1
        rightInverse_inv_op_1 :
          (x : A) -> * (inv x) x == 1
    record MultGroupSig
      (AS : Set) : Set where
      constructor MultGroupSigSigC
      field
        1S : AS
        *S : AS -> AS -> AS
        invS : AS -> AS
    record MultGroupProd
      (AP : Set) : Set where
      constructor MultGroupProdC
      field
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P xP (invP xP) == 1P
        rightInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P (invP xP) xP == 1P
    record MultGroupHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultGroup A1)
      (Mu2 : MultGroup A2) : Set where
      constructor MultGroupHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Mu1) == 1 Mu2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
        pres-inv :
          (x1 : A1) ->
          hom (inv Mu1 x1) ==
            inv Mu2 (hom x1)
    record MultGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultGroup A1)
      (Mu2 : MultGroup A2) : Set where
      constructor MultGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Mu1) (1 Mu2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Mu1 x1) (inv Mu2 y1)
    data MultGroupLang : Set where
      1L : MultGroupLang
      *L :
        MultGroupLang ->
        MultGroupLang -> MultGroupLang
      invL :
        MultGroupLang -> MultGroupLang
    data MultGroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> MultGroupOpenLang n
      1OL : MultGroupOpenLang n
      *OL :
        MultGroupOpenLang n ->
        MultGroupOpenLang n ->
        MultGroupOpenLang n
      invOL :
        MultGroupOpenLang n ->
        MultGroupOpenLang n
    evalTerm :
      (A : Set) ->
      MultGroup A ->
      MultGroupLang -> A
    evalTerm _ Mu (1L) = 1 Mu
    evalTerm _ Mu (*L x1 x2) =
      * Mu (evalTerm _ Mu x1)
        (evalTerm _ Mu x2)
    evalTerm _ Mu (invL x1) =
      inv Mu (evalTerm _ Mu x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MultGroup A ->
      MultGroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mu (1OL) vars =
      1 mu
    evalOpenTerm _ n mu (*OL
                         x1
                         x2) vars =
      * mu
        (evalOpenTerm _ n mu x1 vars)
        (evalOpenTerm _ n mu x2 vars)
    evalOpenTerm _ n mu (invOL
                         x1) vars =
      inv mu
        (evalOpenTerm _ n mu x1 vars)
    simplify :
      MultGroupLang -> MultGroupLang
    simplify (*L (1L) x) = x
    simplify (*L x (1L)) = x
    simplify (*L x (invL x)) = 1L
    simplify (*L (invL x) x) = 1L
    simplify (1L) = 1L
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (invL x1) =
      invL (simplify x1)
    liftMultGroupLang :
      MultGroupLang ->
      Staged MultGroupLang
    liftMultGroupLang x = Now x
    1OL' :
      (n : Nat) -> MultGroupOpenLang n
    1OL' _ = 1OL
    *OL' :
      (n : Nat) ->
      MultGroupOpenLang n ->
      MultGroupOpenLang n ->
      MultGroupOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    invOL' :
      (n : Nat) ->
      MultGroupOpenLang n ->
      MultGroupOpenLang n
    invOL' _ x1 = invOL x1
    liftMultGroupOpenLang :
      (n : Nat) ->
      MultGroupOpenLang n ->
      Staged (MultGroupOpenLang n)
    liftMultGroupOpenLang _ (v
                             fin) = const _ (code _ (v fin))
    liftMultGroupOpenLang _ (1OL) =
      Now 1OL
    liftMultGroupOpenLang _ (*OL
                             x1
                             x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftMultGroupOpenLang _ x1)
        (liftMultGroupOpenLang _ x2)
    liftMultGroupOpenLang _ (invOL
                             x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (liftMultGroupOpenLang _ x1)
  
  module MultMagma where
    record MultMagma
      (A : Set) : Set where
      constructor MultMagmaC
      field
        * : A -> A -> A
    record MultMagmaSig
      (AS : Set) : Set where
      constructor MultMagmaSigSigC
      field
        *S : AS -> AS -> AS
    record MultMagmaProd
      (AP : Set) : Set where
      constructor MultMagmaProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record MultMagmaHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultMagma A1)
      (Mu2 : MultMagma A2) : Set where
      constructor MultMagmaHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultMagma A1)
      (Mu2 : MultMagma A2) : Set where
      constructor MultMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultMagmaLang : Set where
      *L :
        MultMagmaLang ->
        MultMagmaLang -> MultMagmaLang
    data MultMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> MultMagmaOpenLang n
      *OL :
        MultMagmaOpenLang n ->
        MultMagmaOpenLang n ->
        MultMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      MultMagma A ->
      MultMagmaLang -> A
    evalTerm _ Mu (*L x1 x2) =
      * Mu (evalTerm _ Mu x1)
        (evalTerm _ Mu x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MultMagma A ->
      MultMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mu (*OL
                         x1
                         x2) vars =
      * mu
        (evalOpenTerm _ n mu x1 vars)
        (evalOpenTerm _ n mu x2 vars)
    simplify :
      MultMagmaLang -> MultMagmaLang
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    liftMultMagmaLang :
      MultMagmaLang ->
      Staged MultMagmaLang
    liftMultMagmaLang x = Now x
    *OL' :
      (n : Nat) ->
      MultMagmaOpenLang n ->
      MultMagmaOpenLang n ->
      MultMagmaOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    liftMultMagmaOpenLang :
      (n : Nat) ->
      MultMagmaOpenLang n ->
      Staged (MultMagmaOpenLang n)
    liftMultMagmaOpenLang _ (v
                             fin) = const _ (code _ (v fin))
    liftMultMagmaOpenLang _ (*OL
                             x1
                             x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftMultMagmaOpenLang _ x1)
        (liftMultMagmaOpenLang _ x2)
  
  module MultMeetSemilattice where
    record MultMeetSemilattice
      (A : Set) : Set where
      constructor MultMeetSemilatticeC
      field
        * : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
    record MultMeetSemilatticeSig
      (AS : Set) : Set where
      constructor MultMeetSemilatticeSigSigC
      field
        *S : AS -> AS -> AS
    record MultMeetSemilatticeProd
      (AP : Set) : Set where
      constructor MultMeetSemilatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
    record MultMeetSemilatticeHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultMeetSemilattice A1)
      (Mu2 : MultMeetSemilattice A2) :
      Set where
      constructor MultMeetSemilatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultMeetSemilatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultMeetSemilattice A1)
      (Mu2 : MultMeetSemilattice A2) :
      Set where
      constructor MultMeetSemilatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultMeetSemilatticeLang
      : Set where
      *L :
        MultMeetSemilatticeLang ->
        MultMeetSemilatticeLang ->
        MultMeetSemilatticeLang
    data MultMeetSemilatticeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        MultMeetSemilatticeOpenLang n
      *OL :
        MultMeetSemilatticeOpenLang n ->
        MultMeetSemilatticeOpenLang n ->
        MultMeetSemilatticeOpenLang n
    evalTerm :
      (A : Set) ->
      MultMeetSemilattice A ->
      MultMeetSemilatticeLang -> A
    evalTerm _ Mu (*L x1 x2) =
      * Mu (evalTerm _ Mu x1)
        (evalTerm _ Mu x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MultMeetSemilattice A ->
      MultMeetSemilatticeOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mu (*OL
                         x1
                         x2) vars =
      * mu
        (evalOpenTerm _ n mu x1 vars)
        (evalOpenTerm _ n mu x2 vars)
    simplify :
      MultMeetSemilatticeLang ->
      MultMeetSemilatticeLang
    simplify (*L x x) = x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    liftMultMeetSemilatticeLang :
      MultMeetSemilatticeLang ->
      Staged MultMeetSemilatticeLang
    liftMultMeetSemilatticeLang x =
      Now x
    *OL' :
      (n : Nat) ->
      MultMeetSemilatticeOpenLang n ->
      MultMeetSemilatticeOpenLang n ->
      MultMeetSemilatticeOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    liftMultMeetSemilatticeOpenLang :
      (n : Nat) ->
      MultMeetSemilatticeOpenLang n ->
      Staged
        (MultMeetSemilatticeOpenLang n)
    liftMultMeetSemilatticeOpenLang _ (v
                                       fin) = const _ (code _ (v fin))
    liftMultMeetSemilatticeOpenLang _ (*OL
                                       x1
                                       x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftMultMeetSemilatticeOpenLang
           _
           x1)
        (liftMultMeetSemilatticeOpenLang
           _
           x2)
  
  module MultMonoid where
    record MultMonoid
      (A : Set) : Set where
      constructor MultMonoidC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
    record MultMonoidSig
      (AS : Set) : Set where
      constructor MultMonoidSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
    record MultMonoidProd
      (AP : Set) : Set where
      constructor MultMonoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
    record MultMonoidHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultMonoid A1)
      (Mu2 : MultMonoid A2) :
      Set where
      constructor MultMonoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
        pres-1 : hom (1 Mu1) == 1 Mu2
    record MultMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultMonoid A1)
      (Mu2 : MultMonoid A2) :
      Set where
      constructor MultMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
        interp-1 :
          interp (1 Mu1) (1 Mu2)
    data MultMonoidLang : Set where
      *L :
        MultMonoidLang ->
        MultMonoidLang -> MultMonoidLang
      1L : MultMonoidLang
    data MultMonoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> MultMonoidOpenLang n
      *OL :
        MultMonoidOpenLang n ->
        MultMonoidOpenLang n ->
        MultMonoidOpenLang n
      1OL : MultMonoidOpenLang n
    evalTerm :
      (A : Set) ->
      MultMonoid A ->
      MultMonoidLang -> A
    evalTerm _ Mu (*L x1 x2) =
      * Mu (evalTerm _ Mu x1)
        (evalTerm _ Mu x2)
    evalTerm _ Mu (1L) = 1 Mu
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MultMonoid A ->
      MultMonoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mu (*OL
                         x1
                         x2) vars =
      * mu
        (evalOpenTerm _ n mu x1 vars)
        (evalOpenTerm _ n mu x2 vars)
    evalOpenTerm _ n mu (1OL) vars =
      1 mu
    simplify :
      MultMonoidLang -> MultMonoidLang
    simplify (*L (1L) x) = x
    simplify (*L x (1L)) = x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (1L) = 1L
    liftMultMonoidLang :
      MultMonoidLang ->
      Staged MultMonoidLang
    liftMultMonoidLang x = Now x
    *OL' :
      (n : Nat) ->
      MultMonoidOpenLang n ->
      MultMonoidOpenLang n ->
      MultMonoidOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    1OL' :
      (n : Nat) ->
      MultMonoidOpenLang n
    1OL' _ = 1OL
    liftMultMonoidOpenLang :
      (n : Nat) ->
      MultMonoidOpenLang n ->
      Staged (MultMonoidOpenLang n)
    liftMultMonoidOpenLang _ (v
                              fin) = const _ (code _ (v fin))
    liftMultMonoidOpenLang _ (*OL
                              x1
                              x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftMultMonoidOpenLang _ x1)
        (liftMultMonoidOpenLang _ x2)
    liftMultMonoidOpenLang _ (1OL) =
      Now 1OL
  
  module MultPointedMagma where
    record MultPointedMagma
      (A : Set) : Set where
      constructor MultPointedMagmaC
      field
        1 : A
        * : A -> A -> A
    record MultPointedMagmaSig
      (AS : Set) : Set where
      constructor MultPointedMagmaSigSigC
      field
        1S : AS
        *S : AS -> AS -> AS
    record MultPointedMagmaProd
      (AP : Set) : Set where
      constructor MultPointedMagmaProdC
      field
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record MultPointedMagmaHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultPointedMagma A1)
      (Mu2 : MultPointedMagma A2) :
      Set where
      constructor MultPointedMagmaHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Mu1) == 1 Mu2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultPointedMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultPointedMagma A1)
      (Mu2 : MultPointedMagma A2) :
      Set where
      constructor MultPointedMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Mu1) (1 Mu2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultPointedMagmaLang
      : Set where
      1L : MultPointedMagmaLang
      *L :
        MultPointedMagmaLang ->
        MultPointedMagmaLang ->
        MultPointedMagmaLang
    data MultPointedMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        MultPointedMagmaOpenLang n
      1OL : MultPointedMagmaOpenLang n
      *OL :
        MultPointedMagmaOpenLang n ->
        MultPointedMagmaOpenLang n ->
        MultPointedMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      MultPointedMagma A ->
      MultPointedMagmaLang -> A
    evalTerm _ Mu (1L) = 1 Mu
    evalTerm _ Mu (*L x1 x2) =
      * Mu (evalTerm _ Mu x1)
        (evalTerm _ Mu x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MultPointedMagma A ->
      MultPointedMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mu (1OL) vars =
      1 mu
    evalOpenTerm _ n mu (*OL
                         x1
                         x2) vars =
      * mu
        (evalOpenTerm _ n mu x1 vars)
        (evalOpenTerm _ n mu x2 vars)
    simplify :
      MultPointedMagmaLang ->
      MultPointedMagmaLang
    simplify (1L) = 1L
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    liftMultPointedMagmaLang :
      MultPointedMagmaLang ->
      Staged MultPointedMagmaLang
    liftMultPointedMagmaLang x =
      Now x
    1OL' :
      (n : Nat) ->
      MultPointedMagmaOpenLang n
    1OL' _ = 1OL
    *OL' :
      (n : Nat) ->
      MultPointedMagmaOpenLang n ->
      MultPointedMagmaOpenLang n ->
      MultPointedMagmaOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    liftMultPointedMagmaOpenLang :
      (n : Nat) ->
      MultPointedMagmaOpenLang n ->
      Staged
        (MultPointedMagmaOpenLang n)
    liftMultPointedMagmaOpenLang _ (v
                                    fin) = const _ (code _ (v fin))
    liftMultPointedMagmaOpenLang _ (1OL) =
      Now 1OL
    liftMultPointedMagmaOpenLang _ (*OL
                                    x1
                                    x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftMultPointedMagmaOpenLang _
           x1)
        (liftMultPointedMagmaOpenLang _
           x2)
  
  module MultPointedSemigroup where
    record MultPointedSemigroup
      (A : Set) : Set where
      constructor MultPointedSemigroupC
      field
        1 : A
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
    record MultPointedSemigroupSig
      (AS : Set) : Set where
      constructor MultPointedSemigroupSigSigC
      field
        1S : AS
        *S : AS -> AS -> AS
    record MultPointedSemigroupProd
      (AP : Set) : Set where
      constructor MultPointedSemigroupProdC
      field
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
    record MultPointedSemigroupHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultPointedSemigroup A1)
      (Mu2 : MultPointedSemigroup
         A2) : Set where
      constructor MultPointedSemigroupHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Mu1) == 1 Mu2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultPointedSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultPointedSemigroup A1)
      (Mu2 : MultPointedSemigroup
         A2) : Set where
      constructor MultPointedSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Mu1) (1 Mu2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultPointedSemigroupLang
      : Set where
      1L : MultPointedSemigroupLang
      *L :
        MultPointedSemigroupLang ->
        MultPointedSemigroupLang ->
        MultPointedSemigroupLang
    data MultPointedSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        MultPointedSemigroupOpenLang n
      1OL :
        MultPointedSemigroupOpenLang n
      *OL :
        MultPointedSemigroupOpenLang
          n ->
        MultPointedSemigroupOpenLang
          n ->
        MultPointedSemigroupOpenLang n
    evalTerm :
      (A : Set) ->
      MultPointedSemigroup A ->
      MultPointedSemigroupLang -> A
    evalTerm _ Mu (1L) = 1 Mu
    evalTerm _ Mu (*L x1 x2) =
      * Mu (evalTerm _ Mu x1)
        (evalTerm _ Mu x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MultPointedSemigroup A ->
      MultPointedSemigroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n mu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mu (1OL) vars =
      1 mu
    evalOpenTerm _ n mu (*OL
                         x1
                         x2) vars =
      * mu
        (evalOpenTerm _ n mu x1 vars)
        (evalOpenTerm _ n mu x2 vars)
    simplify :
      MultPointedSemigroupLang ->
      MultPointedSemigroupLang
    simplify (1L) = 1L
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    liftMultPointedSemigroupLang :
      MultPointedSemigroupLang ->
      Staged MultPointedSemigroupLang
    liftMultPointedSemigroupLang x =
      Now x
    1OL' :
      (n : Nat) ->
      MultPointedSemigroupOpenLang n
    1OL' _ = 1OL
    *OL' :
      (n : Nat) ->
      MultPointedSemigroupOpenLang
        n ->
      MultPointedSemigroupOpenLang
        n ->
      MultPointedSemigroupOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    liftMultPointedSemigroupOpenLang :
      (n : Nat) ->
      MultPointedSemigroupOpenLang
        n ->
      Staged
        (MultPointedSemigroupOpenLang n)
    liftMultPointedSemigroupOpenLang _ (v
                                        fin) = const _ (code _ (v fin))
    liftMultPointedSemigroupOpenLang _ (1OL) =
      Now 1OL
    liftMultPointedSemigroupOpenLang _ (*OL
                                        x1
                                        x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftMultPointedSemigroupOpenLang
           _
           x1)
        (liftMultPointedSemigroupOpenLang
           _
           x2)
  
  module MultSemigroup where
    record MultSemigroup
      (A : Set) : Set where
      constructor MultSemigroupC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
    record MultSemigroupSig
      (AS : Set) : Set where
      constructor MultSemigroupSigSigC
      field
        *S : AS -> AS -> AS
    record MultSemigroupProd
      (AP : Set) : Set where
      constructor MultSemigroupProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
    record MultSemigroupHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultSemigroup A1)
      (Mu2 : MultSemigroup A2) :
      Set where
      constructor MultSemigroupHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultSemigroup A1)
      (Mu2 : MultSemigroup A2) :
      Set where
      constructor MultSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultSemigroupLang
      : Set where
      *L :
        MultSemigroupLang ->
        MultSemigroupLang ->
        MultSemigroupLang
    data MultSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> MultSemigroupOpenLang n
      *OL :
        MultSemigroupOpenLang n ->
        MultSemigroupOpenLang n ->
        MultSemigroupOpenLang n
    evalTerm :
      (A : Set) ->
      MultSemigroup A ->
      MultSemigroupLang -> A
    evalTerm _ Mu (*L x1 x2) =
      * Mu (evalTerm _ Mu x1)
        (evalTerm _ Mu x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MultSemigroup A ->
      MultSemigroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mu (*OL
                         x1
                         x2) vars =
      * mu
        (evalOpenTerm _ n mu x1 vars)
        (evalOpenTerm _ n mu x2 vars)
    simplify :
      MultSemigroupLang ->
      MultSemigroupLang
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    liftMultSemigroupLang :
      MultSemigroupLang ->
      Staged MultSemigroupLang
    liftMultSemigroupLang x = Now x
    *OL' :
      (n : Nat) ->
      MultSemigroupOpenLang n ->
      MultSemigroupOpenLang n ->
      MultSemigroupOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    liftMultSemigroupOpenLang :
      (n : Nat) ->
      MultSemigroupOpenLang n ->
      Staged (MultSemigroupOpenLang n)
    liftMultSemigroupOpenLang _ (v
                                 fin) = const _ (code _ (v fin))
    liftMultSemigroupOpenLang _ (*OL
                                 x1
                                 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftMultSemigroupOpenLang _ x1)
        (liftMultSemigroupOpenLang _ x2)
  
  module MultSemilattice_RingoidSig where
    record MultSemilattice_RingoidSig
      (A : Set) : Set where
      constructor MultSemilattice_RingoidSigC
      field
        * : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        + : A -> A -> A
    record MultSemilattice_RingoidSigSig
      (AS : Set) : Set where
      constructor MultSemilattice_RingoidSigSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record MultSemilattice_RingoidSigProd
      (AP : Set) : Set where
      constructor MultSemilattice_RingoidSigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
    record MultSemilattice_RingoidSigHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultSemilattice_RingoidSig
         A1)
      (Mu2 : MultSemilattice_RingoidSig
         A2) : Set where
      constructor MultSemilattice_RingoidSigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Mu1 x1 x2) ==
            + Mu2 (hom x1) (hom x2)
    record MultSemilattice_RingoidSigRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultSemilattice_RingoidSig
         A1)
      (Mu2 : MultSemilattice_RingoidSig
         A2) : Set where
      constructor MultSemilattice_RingoidSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Mu1 x1 x2)
            (+ Mu2 y1 y2)
    data MultSemilattice_RingoidSigLang
      : Set where
      *L :
        MultSemilattice_RingoidSigLang ->
        MultSemilattice_RingoidSigLang ->
        MultSemilattice_RingoidSigLang
      +L :
        MultSemilattice_RingoidSigLang ->
        MultSemilattice_RingoidSigLang ->
        MultSemilattice_RingoidSigLang
    data MultSemilattice_RingoidSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        MultSemilattice_RingoidSigOpenLang
          n
      *OL :
        MultSemilattice_RingoidSigOpenLang
          n ->
        MultSemilattice_RingoidSigOpenLang
          n ->
        MultSemilattice_RingoidSigOpenLang
          n
      +OL :
        MultSemilattice_RingoidSigOpenLang
          n ->
        MultSemilattice_RingoidSigOpenLang
          n ->
        MultSemilattice_RingoidSigOpenLang
          n
    evalTerm :
      (A : Set) ->
      MultSemilattice_RingoidSig A ->
      MultSemilattice_RingoidSigLang ->
      A
    evalTerm _ Mu (*L x1 x2) =
      * Mu (evalTerm _ Mu x1)
        (evalTerm _ Mu x2)
    evalTerm _ Mu (+L x1 x2) =
      + Mu (evalTerm _ Mu x1)
        (evalTerm _ Mu x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MultSemilattice_RingoidSig A ->
      MultSemilattice_RingoidSigOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n mu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mu (*OL
                         x1
                         x2) vars =
      * mu
        (evalOpenTerm _ n mu x1 vars)
        (evalOpenTerm _ n mu x2 vars)
    evalOpenTerm _ n mu (+OL
                         x1
                         x2) vars =
      + mu
        (evalOpenTerm _ n mu x1 vars)
        (evalOpenTerm _ n mu x2 vars)
    simplify :
      MultSemilattice_RingoidSigLang ->
      MultSemilattice_RingoidSigLang
    simplify (*L x x) = x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftMultSemilattice_RingoidSigLang :
      MultSemilattice_RingoidSigLang ->
      Staged
        MultSemilattice_RingoidSigLang
    liftMultSemilattice_RingoidSigLang x =
      Now x
    *OL' :
      (n : Nat) ->
      MultSemilattice_RingoidSigOpenLang
        n ->
      MultSemilattice_RingoidSigOpenLang
        n ->
      MultSemilattice_RingoidSigOpenLang
        n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      MultSemilattice_RingoidSigOpenLang
        n ->
      MultSemilattice_RingoidSigOpenLang
        n ->
      MultSemilattice_RingoidSigOpenLang
        n
    +OL' _ x1 x2 = +OL x1 x2
    liftMultSemilattice_RingoidSigOpenLang :
      (n : Nat) ->
      MultSemilattice_RingoidSigOpenLang
        n ->
      Staged
        (MultSemilattice_RingoidSigOpenLang
           n)
    liftMultSemilattice_RingoidSigOpenLang _ (v
                                              fin) = const _ (code _ (v fin))
    liftMultSemilattice_RingoidSigOpenLang _ (*OL
                                              x1
                                              x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftMultSemilattice_RingoidSigOpenLang
           _
           x1)
        (liftMultSemilattice_RingoidSigOpenLang
           _
           x2)
    liftMultSemilattice_RingoidSigOpenLang _ (+OL
                                              x1
                                              x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftMultSemilattice_RingoidSigOpenLang
           _
           x1)
        (liftMultSemilattice_RingoidSigOpenLang
           _
           x2)
  
  module MultUnaryAntiDistribution where
    record MultUnaryAntiDistribution
      (A : Set) : Set where
      constructor MultUnaryAntiDistributionC
      field
        prim : A -> A
        * : A -> A -> A
        antidis_prim_* :
          (x : A) (y : A) ->
          prim (* x y) ==
            * (prim y) (prim x)
    record MultUnaryAntiDistributionSig
      (AS : Set) : Set where
      constructor MultUnaryAntiDistributionSigSigC
      field
        primS : AS -> AS
        *S : AS -> AS -> AS
    record MultUnaryAntiDistributionProd
      (AP : Set) : Set where
      constructor MultUnaryAntiDistributionProdC
      field
        primP : Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        antidis_prim_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (*P xP yP) ==
            *P (primP yP) (primP xP)
    record MultUnaryAntiDistributionHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultUnaryAntiDistribution
         A1)
      (Mu2 : MultUnaryAntiDistribution
         A2) : Set where
      constructor MultUnaryAntiDistributionHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Mu1 x1) ==
            prim Mu2 (hom x1)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultUnaryAntiDistributionRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultUnaryAntiDistribution
         A1)
      (Mu2 : MultUnaryAntiDistribution
         A2) : Set where
      constructor MultUnaryAntiDistributionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Mu1 x1)
            (prim Mu2 y1)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultUnaryAntiDistributionLang
      : Set where
      primL :
        MultUnaryAntiDistributionLang ->
        MultUnaryAntiDistributionLang
      *L :
        MultUnaryAntiDistributionLang ->
        MultUnaryAntiDistributionLang ->
        MultUnaryAntiDistributionLang
    data MultUnaryAntiDistributionOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        MultUnaryAntiDistributionOpenLang
          n
      primOL :
        MultUnaryAntiDistributionOpenLang
          n ->
        MultUnaryAntiDistributionOpenLang
          n
      *OL :
        MultUnaryAntiDistributionOpenLang
          n ->
        MultUnaryAntiDistributionOpenLang
          n ->
        MultUnaryAntiDistributionOpenLang
          n
    evalTerm :
      (A : Set) ->
      MultUnaryAntiDistribution A ->
      MultUnaryAntiDistributionLang ->
      A
    evalTerm _ Mu (primL x1) =
      prim Mu (evalTerm _ Mu x1)
    evalTerm _ Mu (*L x1 x2) =
      * Mu (evalTerm _ Mu x1)
        (evalTerm _ Mu x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MultUnaryAntiDistribution A ->
      MultUnaryAntiDistributionOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n mu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mu (primOL
                         x1) vars =
      prim mu
        (evalOpenTerm _ n mu x1 vars)
    evalOpenTerm _ n mu (*OL
                         x1
                         x2) vars =
      * mu
        (evalOpenTerm _ n mu x1 vars)
        (evalOpenTerm _ n mu x2 vars)
    simplify :
      MultUnaryAntiDistributionLang ->
      MultUnaryAntiDistributionLang
    simplify (*L
              (primL y)
              (primL x)) = primL (*L x y)
    simplify (primL x1) =
      primL (simplify x1)
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    liftMultUnaryAntiDistributionLang :
      MultUnaryAntiDistributionLang ->
      Staged
        MultUnaryAntiDistributionLang
    liftMultUnaryAntiDistributionLang x =
      Now x
    primOL' :
      (n : Nat) ->
      MultUnaryAntiDistributionOpenLang
        n ->
      MultUnaryAntiDistributionOpenLang
        n
    primOL' _ x1 = primOL x1
    *OL' :
      (n : Nat) ->
      MultUnaryAntiDistributionOpenLang
        n ->
      MultUnaryAntiDistributionOpenLang
        n ->
      MultUnaryAntiDistributionOpenLang
        n
    *OL' _ x1 x2 = *OL x1 x2
    liftMultUnaryAntiDistributionOpenLang :
      (n : Nat) ->
      MultUnaryAntiDistributionOpenLang
        n ->
      Staged
        (MultUnaryAntiDistributionOpenLang
           n)
    liftMultUnaryAntiDistributionOpenLang _ (v
                                             fin) = const _ (code _ (v fin))
    liftMultUnaryAntiDistributionOpenLang _ (primOL
                                             x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftMultUnaryAntiDistributionOpenLang
           _
           x1)
    liftMultUnaryAntiDistributionOpenLang _ (*OL
                                             x1
                                             x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftMultUnaryAntiDistributionOpenLang
           _
           x1)
        (liftMultUnaryAntiDistributionOpenLang
           _
           x2)
  
  module MultUnital where
    record MultUnital
      (A : Set) : Set where
      constructor MultUnitalC
      field
        1 : A
        * : A -> A -> A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
    record MultUnitalSig
      (AS : Set) : Set where
      constructor MultUnitalSigSigC
      field
        1S : AS
        *S : AS -> AS -> AS
    record MultUnitalProd
      (AP : Set) : Set where
      constructor MultUnitalProdC
      field
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
    record MultUnitalHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultUnital A1)
      (Mu2 : MultUnital A2) :
      Set where
      constructor MultUnitalHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Mu1) == 1 Mu2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultUnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultUnital A1)
      (Mu2 : MultUnital A2) :
      Set where
      constructor MultUnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Mu1) (1 Mu2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultUnitalLang : Set where
      1L : MultUnitalLang
      *L :
        MultUnitalLang ->
        MultUnitalLang -> MultUnitalLang
    data MultUnitalOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> MultUnitalOpenLang n
      1OL : MultUnitalOpenLang n
      *OL :
        MultUnitalOpenLang n ->
        MultUnitalOpenLang n ->
        MultUnitalOpenLang n
    evalTerm :
      (A : Set) ->
      MultUnital A ->
      MultUnitalLang -> A
    evalTerm _ Mu (1L) = 1 Mu
    evalTerm _ Mu (*L x1 x2) =
      * Mu (evalTerm _ Mu x1)
        (evalTerm _ Mu x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MultUnital A ->
      MultUnitalOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mu (1OL) vars =
      1 mu
    evalOpenTerm _ n mu (*OL
                         x1
                         x2) vars =
      * mu
        (evalOpenTerm _ n mu x1 vars)
        (evalOpenTerm _ n mu x2 vars)
    simplify :
      MultUnitalLang -> MultUnitalLang
    simplify (*L (1L) x) = x
    simplify (*L x (1L)) = x
    simplify (1L) = 1L
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    liftMultUnitalLang :
      MultUnitalLang ->
      Staged MultUnitalLang
    liftMultUnitalLang x = Now x
    1OL' :
      (n : Nat) ->
      MultUnitalOpenLang n
    1OL' _ = 1OL
    *OL' :
      (n : Nat) ->
      MultUnitalOpenLang n ->
      MultUnitalOpenLang n ->
      MultUnitalOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    liftMultUnitalOpenLang :
      (n : Nat) ->
      MultUnitalOpenLang n ->
      Staged (MultUnitalOpenLang n)
    liftMultUnitalOpenLang _ (v
                              fin) = const _ (code _ (v fin))
    liftMultUnitalOpenLang _ (1OL) =
      Now 1OL
    liftMultUnitalOpenLang _ (*OL
                              x1
                              x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftMultUnitalOpenLang _ x1)
        (liftMultUnitalOpenLang _ x2)
  
  module NearRing where
    record NearRing
      (A : Set) : Set where
      constructor NearRingC
      field
        * : A -> A -> A
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record NearRingSig
      (AS : Set) : Set where
      constructor NearRingSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
    record NearRingProd
      (AP : Set) : Set where
      constructor NearRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record NearRingHom
      (A1 : Set) (A2 : Set)
      (Ne1 : NearRing A1)
      (Ne2 : NearRing A2) : Set where
      constructor NearRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ne1 x1 x2) ==
            * Ne2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ne1 x1 x2) ==
            + Ne2 (hom x1) (hom x2)
        pres-0 : hom (0 Ne1) == 0 Ne2
        pres-neg :
          (x1 : A1) ->
          hom (neg Ne1 x1) ==
            neg Ne2 (hom x1)
    record NearRingRelInterp
      (A1 : Set) (A2 : Set)
      (Ne1 : NearRing A1)
      (Ne2 : NearRing A2) : Set where
      constructor NearRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ne1 x1 x2)
            (* Ne2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ne1 x1 x2)
            (+ Ne2 y1 y2)
        interp-0 :
          interp (0 Ne1) (0 Ne2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Ne1 x1) (neg Ne2 y1)
    data NearRingLang : Set where
      *L :
        NearRingLang ->
        NearRingLang -> NearRingLang
      +L :
        NearRingLang ->
        NearRingLang -> NearRingLang
      0L : NearRingLang
      negL :
        NearRingLang -> NearRingLang
    data NearRingOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> NearRingOpenLang n
      *OL :
        NearRingOpenLang n ->
        NearRingOpenLang n ->
        NearRingOpenLang n
      +OL :
        NearRingOpenLang n ->
        NearRingOpenLang n ->
        NearRingOpenLang n
      0OL : NearRingOpenLang n
      negOL :
        NearRingOpenLang n ->
        NearRingOpenLang n
    evalTerm :
      (A : Set) ->
      NearRing A -> NearRingLang -> A
    evalTerm _ Ne (*L x1 x2) =
      * Ne (evalTerm _ Ne x1)
        (evalTerm _ Ne x2)
    evalTerm _ Ne (+L x1 x2) =
      + Ne (evalTerm _ Ne x1)
        (evalTerm _ Ne x2)
    evalTerm _ Ne (0L) = 0 Ne
    evalTerm _ Ne (negL x1) =
      neg Ne (evalTerm _ Ne x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      NearRing A ->
      NearRingOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ne (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ne (*OL
                         x1
                         x2) vars =
      * ne
        (evalOpenTerm _ n ne x1 vars)
        (evalOpenTerm _ n ne x2 vars)
    evalOpenTerm _ n ne (+OL
                         x1
                         x2) vars =
      + ne
        (evalOpenTerm _ n ne x1 vars)
        (evalOpenTerm _ n ne x2 vars)
    evalOpenTerm _ n ne (0OL) vars =
      0 ne
    evalOpenTerm _ n ne (negOL
                         x1) vars =
      neg ne
        (evalOpenTerm _ n ne x1 vars)
    simplify :
      NearRingLang -> NearRingLang
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (+L x (negL x)) = 0L
    simplify (+L (negL x) x) = 0L
    simplify (+L
              (*L y x)
              (*L z x)) = *L (+L y z) x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (0L) = 0L
    simplify (negL x1) =
      negL (simplify x1)
    liftNearRingLang :
      NearRingLang ->
      Staged NearRingLang
    liftNearRingLang x = Now x
    *OL' :
      (n : Nat) ->
      NearRingOpenLang n ->
      NearRingOpenLang n ->
      NearRingOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      NearRingOpenLang n ->
      NearRingOpenLang n ->
      NearRingOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) -> NearRingOpenLang n
    0OL' _ = 0OL
    negOL' :
      (n : Nat) ->
      NearRingOpenLang n ->
      NearRingOpenLang n
    negOL' _ x1 = negOL x1
    liftNearRingOpenLang :
      (n : Nat) ->
      NearRingOpenLang n ->
      Staged (NearRingOpenLang n)
    liftNearRingOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftNearRingOpenLang _ (*OL
                            x1
                            x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftNearRingOpenLang _ x1)
        (liftNearRingOpenLang _ x2)
    liftNearRingOpenLang _ (+OL
                            x1
                            x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftNearRingOpenLang _ x1)
        (liftNearRingOpenLang _ x2)
    liftNearRingOpenLang _ (0OL) =
      Now 0OL
    liftNearRingOpenLang _ (negOL
                            x1) =
      stage1 _ _ (negOL' _)
        (codeLift1 _ _ (negOL' _))
        (liftNearRingOpenLang _ x1)
  
  module NearSemiring where
    record NearSemiring
      (A : Set) : Set where
      constructor NearSemiringC
      field
        * : A -> A -> A
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record NearSemiringSig
      (AS : Set) : Set where
      constructor NearSemiringSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record NearSemiringProd
      (AP : Set) : Set where
      constructor NearSemiringProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record NearSemiringHom
      (A1 : Set) (A2 : Set)
      (Ne1 : NearSemiring A1)
      (Ne2 : NearSemiring A2) :
      Set where
      constructor NearSemiringHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ne1 x1 x2) ==
            * Ne2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ne1 x1 x2) ==
            + Ne2 (hom x1) (hom x2)
    record NearSemiringRelInterp
      (A1 : Set) (A2 : Set)
      (Ne1 : NearSemiring A1)
      (Ne2 : NearSemiring A2) :
      Set where
      constructor NearSemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ne1 x1 x2)
            (* Ne2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ne1 x1 x2)
            (+ Ne2 y1 y2)
    data NearSemiringLang
      : Set where
      *L :
        NearSemiringLang ->
        NearSemiringLang ->
        NearSemiringLang
      +L :
        NearSemiringLang ->
        NearSemiringLang ->
        NearSemiringLang
    data NearSemiringOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> NearSemiringOpenLang n
      *OL :
        NearSemiringOpenLang n ->
        NearSemiringOpenLang n ->
        NearSemiringOpenLang n
      +OL :
        NearSemiringOpenLang n ->
        NearSemiringOpenLang n ->
        NearSemiringOpenLang n
    evalTerm :
      (A : Set) ->
      NearSemiring A ->
      NearSemiringLang -> A
    evalTerm _ Ne (*L x1 x2) =
      * Ne (evalTerm _ Ne x1)
        (evalTerm _ Ne x2)
    evalTerm _ Ne (+L x1 x2) =
      + Ne (evalTerm _ Ne x1)
        (evalTerm _ Ne x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      NearSemiring A ->
      NearSemiringOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ne (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ne (*OL
                         x1
                         x2) vars =
      * ne
        (evalOpenTerm _ n ne x1 vars)
        (evalOpenTerm _ n ne x2 vars)
    evalOpenTerm _ n ne (+OL
                         x1
                         x2) vars =
      + ne
        (evalOpenTerm _ n ne x1 vars)
        (evalOpenTerm _ n ne x2 vars)
    simplify :
      NearSemiringLang ->
      NearSemiringLang
    simplify (+L
              (*L y x)
              (*L z x)) = *L (+L y z) x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftNearSemiringLang :
      NearSemiringLang ->
      Staged NearSemiringLang
    liftNearSemiringLang x = Now x
    *OL' :
      (n : Nat) ->
      NearSemiringOpenLang n ->
      NearSemiringOpenLang n ->
      NearSemiringOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      NearSemiringOpenLang n ->
      NearSemiringOpenLang n ->
      NearSemiringOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftNearSemiringOpenLang :
      (n : Nat) ->
      NearSemiringOpenLang n ->
      Staged (NearSemiringOpenLang n)
    liftNearSemiringOpenLang _ (v
                                fin) = const _ (code _ (v fin))
    liftNearSemiringOpenLang _ (*OL
                                x1
                                x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftNearSemiringOpenLang _ x1)
        (liftNearSemiringOpenLang _ x2)
    liftNearSemiringOpenLang _ (+OL
                                x1
                                x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftNearSemiringOpenLang _ x1)
        (liftNearSemiringOpenLang _ x2)
  
  module NonDistributiveAddPreSemiring where
    record NonDistributiveAddPreSemiring
      (A : Set) : Set where
      constructor NonDistributiveAddPreSemiringC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        * : A -> A -> A
    record NonDistributiveAddPreSemiringSig
      (AS : Set) : Set where
      constructor NonDistributiveAddPreSemiringSigSigC
      field
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
    record NonDistributiveAddPreSemiringProd
      (AP : Set) : Set where
      constructor NonDistributiveAddPreSemiringProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record NonDistributiveAddPreSemiringHom
      (A1 : Set) (A2 : Set)
      (No1 : NonDistributiveAddPreSemiring
         A1)
      (No2 : NonDistributiveAddPreSemiring
         A2) : Set where
      constructor NonDistributiveAddPreSemiringHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ No1 x1 x2) ==
            + No2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* No1 x1 x2) ==
            * No2 (hom x1) (hom x2)
    record NonDistributiveAddPreSemiringRelInterp
      (A1 : Set) (A2 : Set)
      (No1 : NonDistributiveAddPreSemiring
         A1)
      (No2 : NonDistributiveAddPreSemiring
         A2) : Set where
      constructor NonDistributiveAddPreSemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ No1 x1 x2)
            (+ No2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* No1 x1 x2)
            (* No2 y1 y2)
    data NonDistributiveAddPreSemiringLang
      : Set where
      +L :
        NonDistributiveAddPreSemiringLang ->
        NonDistributiveAddPreSemiringLang ->
        NonDistributiveAddPreSemiringLang
      *L :
        NonDistributiveAddPreSemiringLang ->
        NonDistributiveAddPreSemiringLang ->
        NonDistributiveAddPreSemiringLang
    data NonDistributiveAddPreSemiringOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        NonDistributiveAddPreSemiringOpenLang
          n
      +OL :
        NonDistributiveAddPreSemiringOpenLang
          n ->
        NonDistributiveAddPreSemiringOpenLang
          n ->
        NonDistributiveAddPreSemiringOpenLang
          n
      *OL :
        NonDistributiveAddPreSemiringOpenLang
          n ->
        NonDistributiveAddPreSemiringOpenLang
          n ->
        NonDistributiveAddPreSemiringOpenLang
          n
    evalTerm :
      (A : Set) ->
      NonDistributiveAddPreSemiring
        A ->
      NonDistributiveAddPreSemiringLang ->
      A
    evalTerm _ No (+L x1 x2) =
      + No (evalTerm _ No x1)
        (evalTerm _ No x2)
    evalTerm _ No (*L x1 x2) =
      * No (evalTerm _ No x1)
        (evalTerm _ No x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      NonDistributiveAddPreSemiring
        A ->
      NonDistributiveAddPreSemiringOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n no (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n no (+OL
                         x1
                         x2) vars =
      + no
        (evalOpenTerm _ n no x1 vars)
        (evalOpenTerm _ n no x2 vars)
    evalOpenTerm _ n no (*OL
                         x1
                         x2) vars =
      * no
        (evalOpenTerm _ n no x1 vars)
        (evalOpenTerm _ n no x2 vars)
    simplify :
      NonDistributiveAddPreSemiringLang ->
      NonDistributiveAddPreSemiringLang
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    liftNonDistributiveAddPreSemiringLang :
      NonDistributiveAddPreSemiringLang ->
      Staged
        NonDistributiveAddPreSemiringLang
    liftNonDistributiveAddPreSemiringLang x =
      Now x
    +OL' :
      (n : Nat) ->
      NonDistributiveAddPreSemiringOpenLang
        n ->
      NonDistributiveAddPreSemiringOpenLang
        n ->
      NonDistributiveAddPreSemiringOpenLang
        n
    +OL' _ x1 x2 = +OL x1 x2
    *OL' :
      (n : Nat) ->
      NonDistributiveAddPreSemiringOpenLang
        n ->
      NonDistributiveAddPreSemiringOpenLang
        n ->
      NonDistributiveAddPreSemiringOpenLang
        n
    *OL' _ x1 x2 = *OL x1 x2
    liftNonDistributiveAddPreSemiringOpenLang :
      (n : Nat) ->
      NonDistributiveAddPreSemiringOpenLang
        n ->
      Staged
        (NonDistributiveAddPreSemiringOpenLang
           n)
    liftNonDistributiveAddPreSemiringOpenLang _ (v
                                                 fin) = const _ (code _ (v fin))
    liftNonDistributiveAddPreSemiringOpenLang _ (+OL
                                                 x1
                                                 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftNonDistributiveAddPreSemiringOpenLang
           _
           x1)
        (liftNonDistributiveAddPreSemiringOpenLang
           _
           x2)
    liftNonDistributiveAddPreSemiringOpenLang _ (*OL
                                                 x1
                                                 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftNonDistributiveAddPreSemiringOpenLang
           _
           x1)
        (liftNonDistributiveAddPreSemiringOpenLang
           _
           x2)
  
  module NonassociativeNondistributiveRing where
    record NonassociativeNondistributiveRing
      (A : Set) : Set where
      constructor NonassociativeNondistributiveRingC
      field
        * : A -> A -> A
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        inv : A -> A
        leftInverse_inv_op_1 :
          (x : A) -> * x (inv x) == 1
        rightInverse_inv_op_1 :
          (x : A) -> * (inv x) x == 1
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        + : A -> A -> A
    record NonassociativeNondistributiveRingSig
      (AS : Set) : Set where
      constructor NonassociativeNondistributiveRingSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
        invS : AS -> AS
        +S : AS -> AS -> AS
    record NonassociativeNondistributiveRingProd
      (AP : Set) : Set where
      constructor NonassociativeNondistributiveRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P xP (invP xP) == 1P
        rightInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P (invP xP) xP == 1P
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
    record NonassociativeNondistributiveRingHom
      (A1 : Set) (A2 : Set)
      (No1 : NonassociativeNondistributiveRing
         A1)
      (No2 : NonassociativeNondistributiveRing
         A2) : Set where
      constructor NonassociativeNondistributiveRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* No1 x1 x2) ==
            * No2 (hom x1) (hom x2)
        pres-1 : hom (1 No1) == 1 No2
        pres-inv :
          (x1 : A1) ->
          hom (inv No1 x1) ==
            inv No2 (hom x1)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ No1 x1 x2) ==
            + No2 (hom x1) (hom x2)
    record NonassociativeNondistributiveRingRelInterp
      (A1 : Set) (A2 : Set)
      (No1 : NonassociativeNondistributiveRing
         A1)
      (No2 : NonassociativeNondistributiveRing
         A2) : Set where
      constructor NonassociativeNondistributiveRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* No1 x1 x2)
            (* No2 y1 y2)
        interp-1 :
          interp (1 No1) (1 No2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv No1 x1) (inv No2 y1)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ No1 x1 x2)
            (+ No2 y1 y2)
    data NonassociativeNondistributiveRingLang
      : Set where
      *L :
        NonassociativeNondistributiveRingLang ->
        NonassociativeNondistributiveRingLang ->
        NonassociativeNondistributiveRingLang
      1L :
        NonassociativeNondistributiveRingLang
      invL :
        NonassociativeNondistributiveRingLang ->
        NonassociativeNondistributiveRingLang
      +L :
        NonassociativeNondistributiveRingLang ->
        NonassociativeNondistributiveRingLang ->
        NonassociativeNondistributiveRingLang
    data NonassociativeNondistributiveRingOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        NonassociativeNondistributiveRingOpenLang
          n
      *OL :
        NonassociativeNondistributiveRingOpenLang
          n ->
        NonassociativeNondistributiveRingOpenLang
          n ->
        NonassociativeNondistributiveRingOpenLang
          n
      1OL :
        NonassociativeNondistributiveRingOpenLang
          n
      invOL :
        NonassociativeNondistributiveRingOpenLang
          n ->
        NonassociativeNondistributiveRingOpenLang
          n
      +OL :
        NonassociativeNondistributiveRingOpenLang
          n ->
        NonassociativeNondistributiveRingOpenLang
          n ->
        NonassociativeNondistributiveRingOpenLang
          n
    evalTerm :
      (A : Set) ->
      NonassociativeNondistributiveRing
        A ->
      NonassociativeNondistributiveRingLang ->
      A
    evalTerm _ No (*L x1 x2) =
      * No (evalTerm _ No x1)
        (evalTerm _ No x2)
    evalTerm _ No (1L) = 1 No
    evalTerm _ No (invL x1) =
      inv No (evalTerm _ No x1)
    evalTerm _ No (+L x1 x2) =
      + No (evalTerm _ No x1)
        (evalTerm _ No x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      NonassociativeNondistributiveRing
        A ->
      NonassociativeNondistributiveRingOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n no (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n no (*OL
                         x1
                         x2) vars =
      * no
        (evalOpenTerm _ n no x1 vars)
        (evalOpenTerm _ n no x2 vars)
    evalOpenTerm _ n no (1OL) vars =
      1 no
    evalOpenTerm _ n no (invOL
                         x1) vars =
      inv no
        (evalOpenTerm _ n no x1 vars)
    evalOpenTerm _ n no (+OL
                         x1
                         x2) vars =
      + no
        (evalOpenTerm _ n no x1 vars)
        (evalOpenTerm _ n no x2 vars)
    simplify :
      NonassociativeNondistributiveRingLang ->
      NonassociativeNondistributiveRingLang
    simplify (*L (1L) x) = x
    simplify (*L x (1L)) = x
    simplify (*L x (invL x)) = 1L
    simplify (*L (invL x) x) = 1L
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (1L) = 1L
    simplify (invL x1) =
      invL (simplify x1)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftNonassociativeNondistributiveRingLang :
      NonassociativeNondistributiveRingLang ->
      Staged
        NonassociativeNondistributiveRingLang
    liftNonassociativeNondistributiveRingLang x =
      Now x
    *OL' :
      (n : Nat) ->
      NonassociativeNondistributiveRingOpenLang
        n ->
      NonassociativeNondistributiveRingOpenLang
        n ->
      NonassociativeNondistributiveRingOpenLang
        n
    *OL' _ x1 x2 = *OL x1 x2
    1OL' :
      (n : Nat) ->
      NonassociativeNondistributiveRingOpenLang
        n
    1OL' _ = 1OL
    invOL' :
      (n : Nat) ->
      NonassociativeNondistributiveRingOpenLang
        n ->
      NonassociativeNondistributiveRingOpenLang
        n
    invOL' _ x1 = invOL x1
    +OL' :
      (n : Nat) ->
      NonassociativeNondistributiveRingOpenLang
        n ->
      NonassociativeNondistributiveRingOpenLang
        n ->
      NonassociativeNondistributiveRingOpenLang
        n
    +OL' _ x1 x2 = +OL x1 x2
    liftNonassociativeNondistributiveRingOpenLang :
      (n : Nat) ->
      NonassociativeNondistributiveRingOpenLang
        n ->
      Staged
        (NonassociativeNondistributiveRingOpenLang
           n)
    liftNonassociativeNondistributiveRingOpenLang _ (v
                                                     fin) =
      const _ (code _ (v fin))
    liftNonassociativeNondistributiveRingOpenLang _ (*OL
                                                     x1
                                                     x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftNonassociativeNondistributiveRingOpenLang
           _
           x1)
        (liftNonassociativeNondistributiveRingOpenLang
           _
           x2)
    liftNonassociativeNondistributiveRingOpenLang _ (1OL) =
      Now 1OL
    liftNonassociativeNondistributiveRingOpenLang _ (invOL
                                                     x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (liftNonassociativeNondistributiveRingOpenLang
           _
           x1)
    liftNonassociativeNondistributiveRingOpenLang _ (+OL
                                                     x1
                                                     x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftNonassociativeNondistributiveRingOpenLang
           _
           x1)
        (liftNonassociativeNondistributiveRingOpenLang
           _
           x2)
  
  module NonassociativeRing where
    record NonassociativeRing
      (A : Set) : Set where
      constructor NonassociativeRingC
      field
        * : A -> A -> A
        + : A -> A -> A
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        inv : A -> A
        leftInverse_inv_op_1 :
          (x : A) -> * x (inv x) == 1
        rightInverse_inv_op_1 :
          (x : A) -> * (inv x) x == 1
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record NonassociativeRingSig
      (AS : Set) : Set where
      constructor NonassociativeRingSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        1S : AS
        invS : AS -> AS
    record NonassociativeRingProd
      (AP : Set) : Set where
      constructor NonassociativeRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P xP (invP xP) == 1P
        rightInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P (invP xP) xP == 1P
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record NonassociativeRingHom
      (A1 : Set) (A2 : Set)
      (No1 : NonassociativeRing A1)
      (No2 : NonassociativeRing A2) :
      Set where
      constructor NonassociativeRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* No1 x1 x2) ==
            * No2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ No1 x1 x2) ==
            + No2 (hom x1) (hom x2)
        pres-1 : hom (1 No1) == 1 No2
        pres-inv :
          (x1 : A1) ->
          hom (inv No1 x1) ==
            inv No2 (hom x1)
    record NonassociativeRingRelInterp
      (A1 : Set) (A2 : Set)
      (No1 : NonassociativeRing A1)
      (No2 : NonassociativeRing A2) :
      Set where
      constructor NonassociativeRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* No1 x1 x2)
            (* No2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ No1 x1 x2)
            (+ No2 y1 y2)
        interp-1 :
          interp (1 No1) (1 No2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv No1 x1) (inv No2 y1)
    data NonassociativeRingLang
      : Set where
      *L :
        NonassociativeRingLang ->
        NonassociativeRingLang ->
        NonassociativeRingLang
      +L :
        NonassociativeRingLang ->
        NonassociativeRingLang ->
        NonassociativeRingLang
      1L : NonassociativeRingLang
      invL :
        NonassociativeRingLang ->
        NonassociativeRingLang
    data NonassociativeRingOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        NonassociativeRingOpenLang n
      *OL :
        NonassociativeRingOpenLang n ->
        NonassociativeRingOpenLang n ->
        NonassociativeRingOpenLang n
      +OL :
        NonassociativeRingOpenLang n ->
        NonassociativeRingOpenLang n ->
        NonassociativeRingOpenLang n
      1OL :
        NonassociativeRingOpenLang n
      invOL :
        NonassociativeRingOpenLang n ->
        NonassociativeRingOpenLang n
    evalTerm :
      (A : Set) ->
      NonassociativeRing A ->
      NonassociativeRingLang -> A
    evalTerm _ No (*L x1 x2) =
      * No (evalTerm _ No x1)
        (evalTerm _ No x2)
    evalTerm _ No (+L x1 x2) =
      + No (evalTerm _ No x1)
        (evalTerm _ No x2)
    evalTerm _ No (1L) = 1 No
    evalTerm _ No (invL x1) =
      inv No (evalTerm _ No x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      NonassociativeRing A ->
      NonassociativeRingOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n no (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n no (*OL
                         x1
                         x2) vars =
      * no
        (evalOpenTerm _ n no x1 vars)
        (evalOpenTerm _ n no x2 vars)
    evalOpenTerm _ n no (+OL
                         x1
                         x2) vars =
      + no
        (evalOpenTerm _ n no x1 vars)
        (evalOpenTerm _ n no x2 vars)
    evalOpenTerm _ n no (1OL) vars =
      1 no
    evalOpenTerm _ n no (invOL
                         x1) vars =
      inv no
        (evalOpenTerm _ n no x1 vars)
    simplify :
      NonassociativeRingLang ->
      NonassociativeRingLang
    simplify (*L (1L) x) = x
    simplify (*L x (1L)) = x
    simplify (*L x (invL x)) = 1L
    simplify (*L (invL x) x) = 1L
    simplify (+L
              (*L x y)
              (*L x z)) = *L x (+L y z)
    simplify (+L
              (*L y x)
              (*L z x)) = *L (+L y z) x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (1L) = 1L
    simplify (invL x1) =
      invL (simplify x1)
    liftNonassociativeRingLang :
      NonassociativeRingLang ->
      Staged NonassociativeRingLang
    liftNonassociativeRingLang x =
      Now x
    *OL' :
      (n : Nat) ->
      NonassociativeRingOpenLang n ->
      NonassociativeRingOpenLang n ->
      NonassociativeRingOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      NonassociativeRingOpenLang n ->
      NonassociativeRingOpenLang n ->
      NonassociativeRingOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    1OL' :
      (n : Nat) ->
      NonassociativeRingOpenLang n
    1OL' _ = 1OL
    invOL' :
      (n : Nat) ->
      NonassociativeRingOpenLang n ->
      NonassociativeRingOpenLang n
    invOL' _ x1 = invOL x1
    liftNonassociativeRingOpenLang :
      (n : Nat) ->
      NonassociativeRingOpenLang n ->
      Staged
        (NonassociativeRingOpenLang n)
    liftNonassociativeRingOpenLang _ (v
                                      fin) = const _ (code _ (v fin))
    liftNonassociativeRingOpenLang _ (*OL
                                      x1
                                      x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftNonassociativeRingOpenLang
           _
           x1)
        (liftNonassociativeRingOpenLang
           _
           x2)
    liftNonassociativeRingOpenLang _ (+OL
                                      x1
                                      x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftNonassociativeRingOpenLang
           _
           x1)
        (liftNonassociativeRingOpenLang
           _
           x2)
    liftNonassociativeRingOpenLang _ (1OL) =
      Now 1OL
    liftNonassociativeRingOpenLang _ (invOL
                                      x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (liftNonassociativeRingOpenLang
           _
           x1)
  
  module NormalBand where
    record NormalBand
      (A : Set) : Set where
      constructor NormalBandC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        idempotent_op :
          (x : A) -> op x x == x
        middleCommute_* :
          (x : A) (y : A) (z : A) ->
          op (op (op x y) z) x ==
            op (op (op x z) y) x
    record NormalBandSig
      (AS : Set) : Set where
      constructor NormalBandSigSigC
      field
        opS : AS -> AS -> AS
    record NormalBandProd
      (AP : Set) : Set where
      constructor NormalBandProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        idempotent_opP :
          (xP : Prod AP AP) ->
          opP xP xP == xP
        middleCommute_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP (opP xP yP) zP) xP ==
            opP (opP (opP xP zP) yP) xP
    record NormalBandHom
      (A1 : Set) (A2 : Set)
      (No1 : NormalBand A1)
      (No2 : NormalBand A2) :
      Set where
      constructor NormalBandHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op No1 x1 x2) ==
            op No2 (hom x1) (hom x2)
    record NormalBandRelInterp
      (A1 : Set) (A2 : Set)
      (No1 : NormalBand A1)
      (No2 : NormalBand A2) :
      Set where
      constructor NormalBandRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op No1 x1 x2)
            (op No2 y1 y2)
    data NormalBandLang : Set where
      opL :
        NormalBandLang ->
        NormalBandLang -> NormalBandLang
    data NormalBandOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> NormalBandOpenLang n
      opOL :
        NormalBandOpenLang n ->
        NormalBandOpenLang n ->
        NormalBandOpenLang n
    evalTerm :
      (A : Set) ->
      NormalBand A ->
      NormalBandLang -> A
    evalTerm _ No (opL x1 x2) =
      op No (evalTerm _ No x1)
        (evalTerm _ No x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      NormalBand A ->
      NormalBandOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n no (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n no (opOL
                         x1
                         x2) vars =
      op no
        (evalOpenTerm _ n no x1 vars)
        (evalOpenTerm _ n no x2 vars)
    simplify :
      NormalBandLang -> NormalBandLang
    simplify (opL x x) = x
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftNormalBandLang :
      NormalBandLang ->
      Staged NormalBandLang
    liftNormalBandLang x = Now x
    opOL' :
      (n : Nat) ->
      NormalBandOpenLang n ->
      NormalBandOpenLang n ->
      NormalBandOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftNormalBandOpenLang :
      (n : Nat) ->
      NormalBandOpenLang n ->
      Staged (NormalBandOpenLang n)
    liftNormalBandOpenLang _ (v
                              fin) = const _ (code _ (v fin))
    liftNormalBandOpenLang _ (opOL
                              x1
                              x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftNormalBandOpenLang _ x1)
        (liftNormalBandOpenLang _ x2)
  
  module OrDeMorgran where
    record OrDeMorgran
      (A : Set) : Set where
      constructor OrDeMorgranC
      field
        * : A -> A -> A
        + : A -> A -> A
        prim : A -> A
        orDeMorgan_+_*_prim :
          (x : A) (y : A) (z : A) ->
          prim (+ x y) ==
            * (prim x) (prim y)
    record OrDeMorgranSig
      (AS : Set) : Set where
      constructor OrDeMorgranSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        primS : AS -> AS
    record OrDeMorgranProd
      (AP : Set) : Set where
      constructor OrDeMorgranProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        orDeMorgan_+_*_primP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          primP (+P xP yP) ==
            *P (primP xP) (primP yP)
    record OrDeMorgranHom
      (A1 : Set) (A2 : Set)
      (Or1 : OrDeMorgran A1)
      (Or2 : OrDeMorgran A2) :
      Set where
      constructor OrDeMorgranHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Or1 x1 x2) ==
            * Or2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Or1 x1 x2) ==
            + Or2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Or1 x1) ==
            prim Or2 (hom x1)
    record OrDeMorgranRelInterp
      (A1 : Set) (A2 : Set)
      (Or1 : OrDeMorgran A1)
      (Or2 : OrDeMorgran A2) :
      Set where
      constructor OrDeMorgranRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Or1 x1 x2)
            (* Or2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Or1 x1 x2)
            (+ Or2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Or1 x1)
            (prim Or2 y1)
    data OrDeMorgranLang : Set where
      *L :
        OrDeMorgranLang ->
        OrDeMorgranLang ->
        OrDeMorgranLang
      +L :
        OrDeMorgranLang ->
        OrDeMorgranLang ->
        OrDeMorgranLang
      primL :
        OrDeMorgranLang ->
        OrDeMorgranLang
    data OrDeMorgranOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> OrDeMorgranOpenLang n
      *OL :
        OrDeMorgranOpenLang n ->
        OrDeMorgranOpenLang n ->
        OrDeMorgranOpenLang n
      +OL :
        OrDeMorgranOpenLang n ->
        OrDeMorgranOpenLang n ->
        OrDeMorgranOpenLang n
      primOL :
        OrDeMorgranOpenLang n ->
        OrDeMorgranOpenLang n
    evalTerm :
      (A : Set) ->
      OrDeMorgran A ->
      OrDeMorgranLang -> A
    evalTerm _ Or (*L x1 x2) =
      * Or (evalTerm _ Or x1)
        (evalTerm _ Or x2)
    evalTerm _ Or (+L x1 x2) =
      + Or (evalTerm _ Or x1)
        (evalTerm _ Or x2)
    evalTerm _ Or (primL x1) =
      prim Or (evalTerm _ Or x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      OrDeMorgran A ->
      OrDeMorgranOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n or (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n or (*OL
                         x1
                         x2) vars =
      * or
        (evalOpenTerm _ n or x1 vars)
        (evalOpenTerm _ n or x2 vars)
    evalOpenTerm _ n or (+OL
                         x1
                         x2) vars =
      + or
        (evalOpenTerm _ n or x1 vars)
        (evalOpenTerm _ n or x2 vars)
    evalOpenTerm _ n or (primOL
                         x1) vars =
      prim or
        (evalOpenTerm _ n or x1 vars)
    simplify :
      OrDeMorgranLang ->
      OrDeMorgranLang
    simplify (*L
              (primL x)
              (primL y)) = primL (+L x y)
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (primL x1) =
      primL (simplify x1)
    liftOrDeMorgranLang :
      OrDeMorgranLang ->
      Staged OrDeMorgranLang
    liftOrDeMorgranLang x = Now x
    *OL' :
      (n : Nat) ->
      OrDeMorgranOpenLang n ->
      OrDeMorgranOpenLang n ->
      OrDeMorgranOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OrDeMorgranOpenLang n ->
      OrDeMorgranOpenLang n ->
      OrDeMorgranOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    primOL' :
      (n : Nat) ->
      OrDeMorgranOpenLang n ->
      OrDeMorgranOpenLang n
    primOL' _ x1 = primOL x1
    liftOrDeMorgranOpenLang :
      (n : Nat) ->
      OrDeMorgranOpenLang n ->
      Staged (OrDeMorgranOpenLang n)
    liftOrDeMorgranOpenLang _ (v
                               fin) = const _ (code _ (v fin))
    liftOrDeMorgranOpenLang _ (*OL
                               x1
                               x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftOrDeMorgranOpenLang _ x1)
        (liftOrDeMorgranOpenLang _ x2)
    liftOrDeMorgranOpenLang _ (+OL
                               x1
                               x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftOrDeMorgranOpenLang _ x1)
        (liftOrDeMorgranOpenLang _ x2)
    liftOrDeMorgranOpenLang _ (primOL
                               x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftOrDeMorgranOpenLang _ x1)
  
  module Pointed where
    record Pointed
      (A : Set) : Set where
      constructor PointedC
      field
        e : A
    record PointedSig
      (AS : Set) : Set where
      constructor PointedSigSigC
      field
        eS : AS
    record PointedProd
      (AP : Set) : Set where
      constructor PointedProdC
      field
        eP : Prod AP AP
    record PointedHom
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed A1)
      (Po2 : Pointed A2) : Set where
      constructor PointedHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Po1) == e Po2
    record PointedRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed A1)
      (Po2 : Pointed A2) : Set where
      constructor PointedRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Po1) (e Po2)
    data PointedLang : Set where
      eL : PointedLang
    data PointedOpenLang
      (n : Nat) : Set where
      v : Fin n -> PointedOpenLang n
      eOL : PointedOpenLang n
    evalTerm :
      (A : Set) ->
      Pointed A -> PointedLang -> A
    evalTerm _ Po (eL) = e Po
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Pointed A ->
      PointedOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (eOL) vars =
      e po
    simplify :
      PointedLang -> PointedLang
    simplify (eL) = eL
    liftPointedLang :
      PointedLang ->
      Staged PointedLang
    liftPointedLang x = Now x
    eOL' :
      (n : Nat) -> PointedOpenLang n
    eOL' _ = eOL
    liftPointedOpenLang :
      (n : Nat) ->
      PointedOpenLang n ->
      Staged (PointedOpenLang n)
    liftPointedOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftPointedOpenLang _ (eOL) =
      Now eOL
  
  module Pointed0Magma where
    record Pointed0Magma
      (A : Set) : Set where
      constructor Pointed0MagmaC
      field
        0 : A
        op : A -> A -> A
    record Pointed0MagmaSig
      (AS : Set) : Set where
      constructor Pointed0MagmaSigSigC
      field
        0S : AS
        opS : AS -> AS -> AS
    record Pointed0MagmaProd
      (AP : Set) : Set where
      constructor Pointed0MagmaProdC
      field
        0P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record Pointed0MagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed0Magma A1)
      (Po2 : Pointed0Magma A2) :
      Set where
      constructor Pointed0MagmaHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Po1) == 0 Po2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Po1 x1 x2) ==
            op Po2 (hom x1) (hom x2)
    record Pointed0MagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed0Magma A1)
      (Po2 : Pointed0Magma A2) :
      Set where
      constructor Pointed0MagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Po1) (0 Po2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Po1 x1 x2)
            (op Po2 y1 y2)
    data Pointed0MagmaLang
      : Set where
      0L : Pointed0MagmaLang
      opL :
        Pointed0MagmaLang ->
        Pointed0MagmaLang ->
        Pointed0MagmaLang
    data Pointed0MagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> Pointed0MagmaOpenLang n
      0OL : Pointed0MagmaOpenLang n
      opOL :
        Pointed0MagmaOpenLang n ->
        Pointed0MagmaOpenLang n ->
        Pointed0MagmaOpenLang n
    evalTerm :
      (A : Set) ->
      Pointed0Magma A ->
      Pointed0MagmaLang -> A
    evalTerm _ Po (0L) = 0 Po
    evalTerm _ Po (opL x1 x2) =
      op Po (evalTerm _ Po x1)
        (evalTerm _ Po x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Pointed0Magma A ->
      Pointed0MagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (0OL) vars =
      0 po
    evalOpenTerm _ n po (opOL
                         x1
                         x2) vars =
      op po
        (evalOpenTerm _ n po x1 vars)
        (evalOpenTerm _ n po x2 vars)
    simplify :
      Pointed0MagmaLang ->
      Pointed0MagmaLang
    simplify (0L) = 0L
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftPointed0MagmaLang :
      Pointed0MagmaLang ->
      Staged Pointed0MagmaLang
    liftPointed0MagmaLang x = Now x
    0OL' :
      (n : Nat) ->
      Pointed0MagmaOpenLang n
    0OL' _ = 0OL
    opOL' :
      (n : Nat) ->
      Pointed0MagmaOpenLang n ->
      Pointed0MagmaOpenLang n ->
      Pointed0MagmaOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftPointed0MagmaOpenLang :
      (n : Nat) ->
      Pointed0MagmaOpenLang n ->
      Staged (Pointed0MagmaOpenLang n)
    liftPointed0MagmaOpenLang _ (v
                                 fin) = const _ (code _ (v fin))
    liftPointed0MagmaOpenLang _ (0OL) =
      Now 0OL
    liftPointed0MagmaOpenLang _ (opOL
                                 x1
                                 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftPointed0MagmaOpenLang _ x1)
        (liftPointed0MagmaOpenLang _ x2)
  
  module Pointed1Magma where
    record Pointed1Magma
      (A : Set) : Set where
      constructor Pointed1MagmaC
      field
        1 : A
        op : A -> A -> A
    record Pointed1MagmaSig
      (AS : Set) : Set where
      constructor Pointed1MagmaSigSigC
      field
        1S : AS
        opS : AS -> AS -> AS
    record Pointed1MagmaProd
      (AP : Set) : Set where
      constructor Pointed1MagmaProdC
      field
        1P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record Pointed1MagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed1Magma A1)
      (Po2 : Pointed1Magma A2) :
      Set where
      constructor Pointed1MagmaHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Po1) == 1 Po2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Po1 x1 x2) ==
            op Po2 (hom x1) (hom x2)
    record Pointed1MagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed1Magma A1)
      (Po2 : Pointed1Magma A2) :
      Set where
      constructor Pointed1MagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Po1) (1 Po2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Po1 x1 x2)
            (op Po2 y1 y2)
    data Pointed1MagmaLang
      : Set where
      1L : Pointed1MagmaLang
      opL :
        Pointed1MagmaLang ->
        Pointed1MagmaLang ->
        Pointed1MagmaLang
    data Pointed1MagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> Pointed1MagmaOpenLang n
      1OL : Pointed1MagmaOpenLang n
      opOL :
        Pointed1MagmaOpenLang n ->
        Pointed1MagmaOpenLang n ->
        Pointed1MagmaOpenLang n
    evalTerm :
      (A : Set) ->
      Pointed1Magma A ->
      Pointed1MagmaLang -> A
    evalTerm _ Po (1L) = 1 Po
    evalTerm _ Po (opL x1 x2) =
      op Po (evalTerm _ Po x1)
        (evalTerm _ Po x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Pointed1Magma A ->
      Pointed1MagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (1OL) vars =
      1 po
    evalOpenTerm _ n po (opOL
                         x1
                         x2) vars =
      op po
        (evalOpenTerm _ n po x1 vars)
        (evalOpenTerm _ n po x2 vars)
    simplify :
      Pointed1MagmaLang ->
      Pointed1MagmaLang
    simplify (1L) = 1L
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftPointed1MagmaLang :
      Pointed1MagmaLang ->
      Staged Pointed1MagmaLang
    liftPointed1MagmaLang x = Now x
    1OL' :
      (n : Nat) ->
      Pointed1MagmaOpenLang n
    1OL' _ = 1OL
    opOL' :
      (n : Nat) ->
      Pointed1MagmaOpenLang n ->
      Pointed1MagmaOpenLang n ->
      Pointed1MagmaOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftPointed1MagmaOpenLang :
      (n : Nat) ->
      Pointed1MagmaOpenLang n ->
      Staged (Pointed1MagmaOpenLang n)
    liftPointed1MagmaOpenLang _ (v
                                 fin) = const _ (code _ (v fin))
    liftPointed1MagmaOpenLang _ (1OL) =
      Now 1OL
    liftPointed1MagmaOpenLang _ (opOL
                                 x1
                                 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftPointed1MagmaOpenLang _ x1)
        (liftPointed1MagmaOpenLang _ x2)
  
  module PointedInvolutiveMagma0Sig where
    record PointedInvolutiveMagma0Sig
      (A : Set) : Set where
      constructor PointedInvolutiveMagma0SigC
      field
        * : A -> A -> A
        prim : A -> A
        0 : A
    record PointedInvolutiveMagma0SigSig
      (AS : Set) : Set where
      constructor PointedInvolutiveMagma0SigSigSigC
      field
        *S : AS -> AS -> AS
        primS : AS -> AS
        0S : AS
    record PointedInvolutiveMagma0SigProd
      (AP : Set) : Set where
      constructor PointedInvolutiveMagma0SigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        0P : Prod AP AP
    record PointedInvolutiveMagma0SigHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedInvolutiveMagma0Sig
         A1)
      (Po2 : PointedInvolutiveMagma0Sig
         A2) : Set where
      constructor PointedInvolutiveMagma0SigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Po1 x1 x2) ==
            * Po2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Po1 x1) ==
            prim Po2 (hom x1)
        pres-0 : hom (0 Po1) == 0 Po2
    record PointedInvolutiveMagma0SigRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedInvolutiveMagma0Sig
         A1)
      (Po2 : PointedInvolutiveMagma0Sig
         A2) : Set where
      constructor PointedInvolutiveMagma0SigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Po1 x1 x2)
            (* Po2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Po1 x1)
            (prim Po2 y1)
        interp-0 :
          interp (0 Po1) (0 Po2)
    data PointedInvolutiveMagma0SigLang
      : Set where
      *L :
        PointedInvolutiveMagma0SigLang ->
        PointedInvolutiveMagma0SigLang ->
        PointedInvolutiveMagma0SigLang
      primL :
        PointedInvolutiveMagma0SigLang ->
        PointedInvolutiveMagma0SigLang
      0L :
        PointedInvolutiveMagma0SigLang
    data PointedInvolutiveMagma0SigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        PointedInvolutiveMagma0SigOpenLang
          n
      *OL :
        PointedInvolutiveMagma0SigOpenLang
          n ->
        PointedInvolutiveMagma0SigOpenLang
          n ->
        PointedInvolutiveMagma0SigOpenLang
          n
      primOL :
        PointedInvolutiveMagma0SigOpenLang
          n ->
        PointedInvolutiveMagma0SigOpenLang
          n
      0OL :
        PointedInvolutiveMagma0SigOpenLang
          n
    evalTerm :
      (A : Set) ->
      PointedInvolutiveMagma0Sig A ->
      PointedInvolutiveMagma0SigLang ->
      A
    evalTerm _ Po (*L x1 x2) =
      * Po (evalTerm _ Po x1)
        (evalTerm _ Po x2)
    evalTerm _ Po (primL x1) =
      prim Po (evalTerm _ Po x1)
    evalTerm _ Po (0L) = 0 Po
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PointedInvolutiveMagma0Sig A ->
      PointedInvolutiveMagma0SigOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (*OL
                         x1
                         x2) vars =
      * po
        (evalOpenTerm _ n po x1 vars)
        (evalOpenTerm _ n po x2 vars)
    evalOpenTerm _ n po (primOL
                         x1) vars =
      prim po
        (evalOpenTerm _ n po x1 vars)
    evalOpenTerm _ n po (0OL) vars =
      0 po
    simplify :
      PointedInvolutiveMagma0SigLang ->
      PointedInvolutiveMagma0SigLang
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (primL x1) =
      primL (simplify x1)
    simplify (0L) = 0L
    liftPointedInvolutiveMagma0SigLang :
      PointedInvolutiveMagma0SigLang ->
      Staged
        PointedInvolutiveMagma0SigLang
    liftPointedInvolutiveMagma0SigLang x =
      Now x
    *OL' :
      (n : Nat) ->
      PointedInvolutiveMagma0SigOpenLang
        n ->
      PointedInvolutiveMagma0SigOpenLang
        n ->
      PointedInvolutiveMagma0SigOpenLang
        n
    *OL' _ x1 x2 = *OL x1 x2
    primOL' :
      (n : Nat) ->
      PointedInvolutiveMagma0SigOpenLang
        n ->
      PointedInvolutiveMagma0SigOpenLang
        n
    primOL' _ x1 = primOL x1
    0OL' :
      (n : Nat) ->
      PointedInvolutiveMagma0SigOpenLang
        n
    0OL' _ = 0OL
    liftPointedInvolutiveMagma0SigOpenLang :
      (n : Nat) ->
      PointedInvolutiveMagma0SigOpenLang
        n ->
      Staged
        (PointedInvolutiveMagma0SigOpenLang
           n)
    liftPointedInvolutiveMagma0SigOpenLang _ (v
                                              fin) = const _ (code _ (v fin))
    liftPointedInvolutiveMagma0SigOpenLang _ (*OL
                                              x1
                                              x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftPointedInvolutiveMagma0SigOpenLang
           _
           x1)
        (liftPointedInvolutiveMagma0SigOpenLang
           _
           x2)
    liftPointedInvolutiveMagma0SigOpenLang _ (primOL
                                              x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftPointedInvolutiveMagma0SigOpenLang
           _
           x1)
    liftPointedInvolutiveMagma0SigOpenLang _ (0OL) =
      Now 0OL
  
  module PointedMagma where
    record PointedMagma
      (A : Set) : Set where
      constructor PointedMagmaC
      field
        e : A
        op : A -> A -> A
    record PointedMagmaSig
      (AS : Set) : Set where
      constructor PointedMagmaSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record PointedMagmaProd
      (AP : Set) : Set where
      constructor PointedMagmaProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record PointedMagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedMagma A1)
      (Po2 : PointedMagma A2) :
      Set where
      constructor PointedMagmaHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Po1) == e Po2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Po1 x1 x2) ==
            op Po2 (hom x1) (hom x2)
    record PointedMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedMagma A1)
      (Po2 : PointedMagma A2) :
      Set where
      constructor PointedMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Po1) (e Po2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Po1 x1 x2)
            (op Po2 y1 y2)
    data PointedMagmaLang
      : Set where
      eL : PointedMagmaLang
      opL :
        PointedMagmaLang ->
        PointedMagmaLang ->
        PointedMagmaLang
    data PointedMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> PointedMagmaOpenLang n
      eOL : PointedMagmaOpenLang n
      opOL :
        PointedMagmaOpenLang n ->
        PointedMagmaOpenLang n ->
        PointedMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      PointedMagma A ->
      PointedMagmaLang -> A
    evalTerm _ Po (eL) = e Po
    evalTerm _ Po (opL x1 x2) =
      op Po (evalTerm _ Po x1)
        (evalTerm _ Po x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PointedMagma A ->
      PointedMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (eOL) vars =
      e po
    evalOpenTerm _ n po (opOL
                         x1
                         x2) vars =
      op po
        (evalOpenTerm _ n po x1 vars)
        (evalOpenTerm _ n po x2 vars)
    simplify :
      PointedMagmaLang ->
      PointedMagmaLang
    simplify (eL) = eL
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftPointedMagmaLang :
      PointedMagmaLang ->
      Staged PointedMagmaLang
    liftPointedMagmaLang x = Now x
    eOL' :
      (n : Nat) ->
      PointedMagmaOpenLang n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      PointedMagmaOpenLang n ->
      PointedMagmaOpenLang n ->
      PointedMagmaOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftPointedMagmaOpenLang :
      (n : Nat) ->
      PointedMagmaOpenLang n ->
      Staged (PointedMagmaOpenLang n)
    liftPointedMagmaOpenLang _ (v
                                fin) = const _ (code _ (v fin))
    liftPointedMagmaOpenLang _ (eOL) =
      Now eOL
    liftPointedMagmaOpenLang _ (opOL
                                x1
                                x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftPointedMagmaOpenLang _ x1)
        (liftPointedMagmaOpenLang _ x2)
  
  module PointedOne where
    record PointedOne
      (A : Set) : Set where
      constructor PointedOneC
      field
        1 : A
    record PointedOneSig
      (AS : Set) : Set where
      constructor PointedOneSigSigC
      field
        1S : AS
    record PointedOneProd
      (AP : Set) : Set where
      constructor PointedOneProdC
      field
        1P : Prod AP AP
    record PointedOneHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedOne A1)
      (Po2 : PointedOne A2) :
      Set where
      constructor PointedOneHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Po1) == 1 Po2
    record PointedOneRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedOne A1)
      (Po2 : PointedOne A2) :
      Set where
      constructor PointedOneRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Po1) (1 Po2)
    data PointedOneLang : Set where
      1L : PointedOneLang
    data PointedOneOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> PointedOneOpenLang n
      1OL : PointedOneOpenLang n
    evalTerm :
      (A : Set) ->
      PointedOne A ->
      PointedOneLang -> A
    evalTerm _ Po (1L) = 1 Po
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PointedOne A ->
      PointedOneOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (1OL) vars =
      1 po
    simplify :
      PointedOneLang -> PointedOneLang
    simplify (1L) = 1L
    liftPointedOneLang :
      PointedOneLang ->
      Staged PointedOneLang
    liftPointedOneLang x = Now x
    1OL' :
      (n : Nat) ->
      PointedOneOpenLang n
    1OL' _ = 1OL
    liftPointedOneOpenLang :
      (n : Nat) ->
      PointedOneOpenLang n ->
      Staged (PointedOneOpenLang n)
    liftPointedOneOpenLang _ (v
                              fin) = const _ (code _ (v fin))
    liftPointedOneOpenLang _ (1OL) =
      Now 1OL
  
  module PointedPlusMagma where
    record PointedPlusMagma
      (A : Set) : Set where
      constructor PointedPlusMagmaC
      field
        + : A -> A -> A
        e : A
    record PointedPlusMagmaSig
      (AS : Set) : Set where
      constructor PointedPlusMagmaSigSigC
      field
        +S : AS -> AS -> AS
        eS : AS
    record PointedPlusMagmaProd
      (AP : Set) : Set where
      constructor PointedPlusMagmaProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
    record PointedPlusMagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedPlusMagma A1)
      (Po2 : PointedPlusMagma A2) :
      Set where
      constructor PointedPlusMagmaHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Po1 x1 x2) ==
            + Po2 (hom x1) (hom x2)
        pres-e : hom (e Po1) == e Po2
    record PointedPlusMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedPlusMagma A1)
      (Po2 : PointedPlusMagma A2) :
      Set where
      constructor PointedPlusMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Po1 x1 x2)
            (+ Po2 y1 y2)
        interp-e :
          interp (e Po1) (e Po2)
    data PointedPlusMagmaLang
      : Set where
      +L :
        PointedPlusMagmaLang ->
        PointedPlusMagmaLang ->
        PointedPlusMagmaLang
      eL : PointedPlusMagmaLang
    data PointedPlusMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        PointedPlusMagmaOpenLang n
      +OL :
        PointedPlusMagmaOpenLang n ->
        PointedPlusMagmaOpenLang n ->
        PointedPlusMagmaOpenLang n
      eOL : PointedPlusMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      PointedPlusMagma A ->
      PointedPlusMagmaLang -> A
    evalTerm _ Po (+L x1 x2) =
      + Po (evalTerm _ Po x1)
        (evalTerm _ Po x2)
    evalTerm _ Po (eL) = e Po
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PointedPlusMagma A ->
      PointedPlusMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (+OL
                         x1
                         x2) vars =
      + po
        (evalOpenTerm _ n po x1 vars)
        (evalOpenTerm _ n po x2 vars)
    evalOpenTerm _ n po (eOL) vars =
      e po
    simplify :
      PointedPlusMagmaLang ->
      PointedPlusMagmaLang
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (eL) = eL
    liftPointedPlusMagmaLang :
      PointedPlusMagmaLang ->
      Staged PointedPlusMagmaLang
    liftPointedPlusMagmaLang x =
      Now x
    +OL' :
      (n : Nat) ->
      PointedPlusMagmaOpenLang n ->
      PointedPlusMagmaOpenLang n ->
      PointedPlusMagmaOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    eOL' :
      (n : Nat) ->
      PointedPlusMagmaOpenLang n
    eOL' _ = eOL
    liftPointedPlusMagmaOpenLang :
      (n : Nat) ->
      PointedPlusMagmaOpenLang n ->
      Staged
        (PointedPlusMagmaOpenLang n)
    liftPointedPlusMagmaOpenLang _ (v
                                    fin) = const _ (code _ (v fin))
    liftPointedPlusMagmaOpenLang _ (+OL
                                    x1
                                    x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftPointedPlusMagmaOpenLang _
           x1)
        (liftPointedPlusMagmaOpenLang _
           x2)
    liftPointedPlusMagmaOpenLang _ (eOL) =
      Now eOL
  
  module PointedSemigroup where
    record PointedSemigroup
      (A : Set) : Set where
      constructor PointedSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        e : A
    record PointedSemigroupSig
      (AS : Set) : Set where
      constructor PointedSemigroupSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record PointedSemigroupProd
      (AP : Set) : Set where
      constructor PointedSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record PointedSemigroupHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedSemigroup A1)
      (Po2 : PointedSemigroup A2) :
      Set where
      constructor PointedSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Po1 x1 x2) ==
            op Po2 (hom x1) (hom x2)
        pres-e : hom (e Po1) == e Po2
    record PointedSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedSemigroup A1)
      (Po2 : PointedSemigroup A2) :
      Set where
      constructor PointedSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Po1 x1 x2)
            (op Po2 y1 y2)
        interp-e :
          interp (e Po1) (e Po2)
    data PointedSemigroupLang
      : Set where
      opL :
        PointedSemigroupLang ->
        PointedSemigroupLang ->
        PointedSemigroupLang
      eL : PointedSemigroupLang
    data PointedSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        PointedSemigroupOpenLang n
      opOL :
        PointedSemigroupOpenLang n ->
        PointedSemigroupOpenLang n ->
        PointedSemigroupOpenLang n
      eOL : PointedSemigroupOpenLang n
    evalTerm :
      (A : Set) ->
      PointedSemigroup A ->
      PointedSemigroupLang -> A
    evalTerm _ Po (opL x1 x2) =
      op Po (evalTerm _ Po x1)
        (evalTerm _ Po x2)
    evalTerm _ Po (eL) = e Po
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PointedSemigroup A ->
      PointedSemigroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (opOL
                         x1
                         x2) vars =
      op po
        (evalOpenTerm _ n po x1 vars)
        (evalOpenTerm _ n po x2 vars)
    evalOpenTerm _ n po (eOL) vars =
      e po
    simplify :
      PointedSemigroupLang ->
      PointedSemigroupLang
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (eL) = eL
    liftPointedSemigroupLang :
      PointedSemigroupLang ->
      Staged PointedSemigroupLang
    liftPointedSemigroupLang x =
      Now x
    opOL' :
      (n : Nat) ->
      PointedSemigroupOpenLang n ->
      PointedSemigroupOpenLang n ->
      PointedSemigroupOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    eOL' :
      (n : Nat) ->
      PointedSemigroupOpenLang n
    eOL' _ = eOL
    liftPointedSemigroupOpenLang :
      (n : Nat) ->
      PointedSemigroupOpenLang n ->
      Staged
        (PointedSemigroupOpenLang n)
    liftPointedSemigroupOpenLang _ (v
                                    fin) = const _ (code _ (v fin))
    liftPointedSemigroupOpenLang _ (opOL
                                    x1
                                    x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftPointedSemigroupOpenLang _
           x1)
        (liftPointedSemigroupOpenLang _
           x2)
    liftPointedSemigroupOpenLang _ (eOL) =
      Now eOL
  
  module PointedSteinerMagma where
    record PointedSteinerMagma
      (A : Set) : Set where
      constructor PointedSteinerMagmaC
      field
        op : A -> A -> A
        e : A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
        antiAbsorbent :
          (x : A) (y : A) ->
          op x (op x y) == y
    record PointedSteinerMagmaSig
      (AS : Set) : Set where
      constructor PointedSteinerMagmaSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record PointedSteinerMagmaProd
      (AP : Set) : Set where
      constructor PointedSteinerMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
        antiAbsorbentP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (opP xP yP) == yP
    record PointedSteinerMagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedSteinerMagma A1)
      (Po2 : PointedSteinerMagma A2) :
      Set where
      constructor PointedSteinerMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Po1 x1 x2) ==
            op Po2 (hom x1) (hom x2)
        pres-e : hom (e Po1) == e Po2
    record PointedSteinerMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedSteinerMagma A1)
      (Po2 : PointedSteinerMagma A2) :
      Set where
      constructor PointedSteinerMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Po1 x1 x2)
            (op Po2 y1 y2)
        interp-e :
          interp (e Po1) (e Po2)
    data PointedSteinerMagmaLang
      : Set where
      opL :
        PointedSteinerMagmaLang ->
        PointedSteinerMagmaLang ->
        PointedSteinerMagmaLang
      eL : PointedSteinerMagmaLang
    data PointedSteinerMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        PointedSteinerMagmaOpenLang n
      opOL :
        PointedSteinerMagmaOpenLang n ->
        PointedSteinerMagmaOpenLang n ->
        PointedSteinerMagmaOpenLang n
      eOL :
        PointedSteinerMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      PointedSteinerMagma A ->
      PointedSteinerMagmaLang -> A
    evalTerm _ Po (opL x1 x2) =
      op Po (evalTerm _ Po x1)
        (evalTerm _ Po x2)
    evalTerm _ Po (eL) = e Po
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PointedSteinerMagma A ->
      PointedSteinerMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (opOL
                         x1
                         x2) vars =
      op po
        (evalOpenTerm _ n po x1 vars)
        (evalOpenTerm _ n po x2 vars)
    evalOpenTerm _ n po (eOL) vars =
      e po
    simplify :
      PointedSteinerMagmaLang ->
      PointedSteinerMagmaLang
    simplify (opL x (opL x y)) = y
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (eL) = eL
    liftPointedSteinerMagmaLang :
      PointedSteinerMagmaLang ->
      Staged PointedSteinerMagmaLang
    liftPointedSteinerMagmaLang x =
      Now x
    opOL' :
      (n : Nat) ->
      PointedSteinerMagmaOpenLang n ->
      PointedSteinerMagmaOpenLang n ->
      PointedSteinerMagmaOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    eOL' :
      (n : Nat) ->
      PointedSteinerMagmaOpenLang n
    eOL' _ = eOL
    liftPointedSteinerMagmaOpenLang :
      (n : Nat) ->
      PointedSteinerMagmaOpenLang n ->
      Staged
        (PointedSteinerMagmaOpenLang n)
    liftPointedSteinerMagmaOpenLang _ (v
                                       fin) = const _ (code _ (v fin))
    liftPointedSteinerMagmaOpenLang _ (opOL
                                       x1
                                       x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftPointedSteinerMagmaOpenLang
           _
           x1)
        (liftPointedSteinerMagmaOpenLang
           _
           x2)
    liftPointedSteinerMagmaOpenLang _ (eOL) =
      Now eOL
  
  module PointedTimesMagma where
    record PointedTimesMagma
      (A : Set) : Set where
      constructor PointedTimesMagmaC
      field
        * : A -> A -> A
        e : A
    record PointedTimesMagmaSig
      (AS : Set) : Set where
      constructor PointedTimesMagmaSigSigC
      field
        *S : AS -> AS -> AS
        eS : AS
    record PointedTimesMagmaProd
      (AP : Set) : Set where
      constructor PointedTimesMagmaProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
    record PointedTimesMagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedTimesMagma A1)
      (Po2 : PointedTimesMagma A2) :
      Set where
      constructor PointedTimesMagmaHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Po1 x1 x2) ==
            * Po2 (hom x1) (hom x2)
        pres-e : hom (e Po1) == e Po2
    record PointedTimesMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedTimesMagma A1)
      (Po2 : PointedTimesMagma A2) :
      Set where
      constructor PointedTimesMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Po1 x1 x2)
            (* Po2 y1 y2)
        interp-e :
          interp (e Po1) (e Po2)
    data PointedTimesMagmaLang
      : Set where
      *L :
        PointedTimesMagmaLang ->
        PointedTimesMagmaLang ->
        PointedTimesMagmaLang
      eL : PointedTimesMagmaLang
    data PointedTimesMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        PointedTimesMagmaOpenLang n
      *OL :
        PointedTimesMagmaOpenLang n ->
        PointedTimesMagmaOpenLang n ->
        PointedTimesMagmaOpenLang n
      eOL :
        PointedTimesMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      PointedTimesMagma A ->
      PointedTimesMagmaLang -> A
    evalTerm _ Po (*L x1 x2) =
      * Po (evalTerm _ Po x1)
        (evalTerm _ Po x2)
    evalTerm _ Po (eL) = e Po
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PointedTimesMagma A ->
      PointedTimesMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (*OL
                         x1
                         x2) vars =
      * po
        (evalOpenTerm _ n po x1 vars)
        (evalOpenTerm _ n po x2 vars)
    evalOpenTerm _ n po (eOL) vars =
      e po
    simplify :
      PointedTimesMagmaLang ->
      PointedTimesMagmaLang
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (eL) = eL
    liftPointedTimesMagmaLang :
      PointedTimesMagmaLang ->
      Staged PointedTimesMagmaLang
    liftPointedTimesMagmaLang x =
      Now x
    *OL' :
      (n : Nat) ->
      PointedTimesMagmaOpenLang n ->
      PointedTimesMagmaOpenLang n ->
      PointedTimesMagmaOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    eOL' :
      (n : Nat) ->
      PointedTimesMagmaOpenLang n
    eOL' _ = eOL
    liftPointedTimesMagmaOpenLang :
      (n : Nat) ->
      PointedTimesMagmaOpenLang n ->
      Staged
        (PointedTimesMagmaOpenLang n)
    liftPointedTimesMagmaOpenLang _ (v
                                     fin) = const _ (code _ (v fin))
    liftPointedTimesMagmaOpenLang _ (*OL
                                     x1
                                     x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftPointedTimesMagmaOpenLang _
           x1)
        (liftPointedTimesMagmaOpenLang _
           x2)
    liftPointedTimesMagmaOpenLang _ (eOL) =
      Now eOL
  
  module PointedTimesZeroMagma where
    record PointedTimesZeroMagma
      (A : Set) : Set where
      constructor PointedTimesZeroMagmaC
      field
        0 : A
        * : A -> A -> A
    record PointedTimesZeroMagmaSig
      (AS : Set) : Set where
      constructor PointedTimesZeroMagmaSigSigC
      field
        0S : AS
        *S : AS -> AS -> AS
    record PointedTimesZeroMagmaProd
      (AP : Set) : Set where
      constructor PointedTimesZeroMagmaProdC
      field
        0P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record PointedTimesZeroMagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedTimesZeroMagma A1)
      (Po2 : PointedTimesZeroMagma
         A2) : Set where
      constructor PointedTimesZeroMagmaHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Po1) == 0 Po2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Po1 x1 x2) ==
            * Po2 (hom x1) (hom x2)
    record PointedTimesZeroMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedTimesZeroMagma A1)
      (Po2 : PointedTimesZeroMagma
         A2) : Set where
      constructor PointedTimesZeroMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Po1) (0 Po2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Po1 x1 x2)
            (* Po2 y1 y2)
    data PointedTimesZeroMagmaLang
      : Set where
      0L : PointedTimesZeroMagmaLang
      *L :
        PointedTimesZeroMagmaLang ->
        PointedTimesZeroMagmaLang ->
        PointedTimesZeroMagmaLang
    data PointedTimesZeroMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        PointedTimesZeroMagmaOpenLang n
      0OL :
        PointedTimesZeroMagmaOpenLang n
      *OL :
        PointedTimesZeroMagmaOpenLang
          n ->
        PointedTimesZeroMagmaOpenLang
          n ->
        PointedTimesZeroMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      PointedTimesZeroMagma A ->
      PointedTimesZeroMagmaLang -> A
    evalTerm _ Po (0L) = 0 Po
    evalTerm _ Po (*L x1 x2) =
      * Po (evalTerm _ Po x1)
        (evalTerm _ Po x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PointedTimesZeroMagma A ->
      PointedTimesZeroMagmaOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (0OL) vars =
      0 po
    evalOpenTerm _ n po (*OL
                         x1
                         x2) vars =
      * po
        (evalOpenTerm _ n po x1 vars)
        (evalOpenTerm _ n po x2 vars)
    simplify :
      PointedTimesZeroMagmaLang ->
      PointedTimesZeroMagmaLang
    simplify (0L) = 0L
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    liftPointedTimesZeroMagmaLang :
      PointedTimesZeroMagmaLang ->
      Staged PointedTimesZeroMagmaLang
    liftPointedTimesZeroMagmaLang x =
      Now x
    0OL' :
      (n : Nat) ->
      PointedTimesZeroMagmaOpenLang n
    0OL' _ = 0OL
    *OL' :
      (n : Nat) ->
      PointedTimesZeroMagmaOpenLang
        n ->
      PointedTimesZeroMagmaOpenLang
        n ->
      PointedTimesZeroMagmaOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    liftPointedTimesZeroMagmaOpenLang :
      (n : Nat) ->
      PointedTimesZeroMagmaOpenLang
        n ->
      Staged
        (PointedTimesZeroMagmaOpenLang
           n)
    liftPointedTimesZeroMagmaOpenLang _ (v
                                         fin) = const _ (code _ (v fin))
    liftPointedTimesZeroMagmaOpenLang _ (0OL) =
      Now 0OL
    liftPointedTimesZeroMagmaOpenLang _ (*OL
                                         x1
                                         x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftPointedTimesZeroMagmaOpenLang
           _
           x1)
        (liftPointedTimesZeroMagmaOpenLang
           _
           x2)
  
  module PointedUnarySystem where
    record PointedUnarySystem
      (A : Set) : Set where
      constructor PointedUnarySystemC
      field
        prim : A -> A
        e : A
    record PointedUnarySystemSig
      (AS : Set) : Set where
      constructor PointedUnarySystemSigSigC
      field
        primS : AS -> AS
        eS : AS
    record PointedUnarySystemProd
      (AP : Set) : Set where
      constructor PointedUnarySystemProdC
      field
        primP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
    record PointedUnarySystemHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedUnarySystem A1)
      (Po2 : PointedUnarySystem A2) :
      Set where
      constructor PointedUnarySystemHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Po1 x1) ==
            prim Po2 (hom x1)
        pres-e : hom (e Po1) == e Po2
    record PointedUnarySystemRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedUnarySystem A1)
      (Po2 : PointedUnarySystem A2) :
      Set where
      constructor PointedUnarySystemRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Po1 x1)
            (prim Po2 y1)
        interp-e :
          interp (e Po1) (e Po2)
    data PointedUnarySystemLang
      : Set where
      primL :
        PointedUnarySystemLang ->
        PointedUnarySystemLang
      eL : PointedUnarySystemLang
    data PointedUnarySystemOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        PointedUnarySystemOpenLang n
      primOL :
        PointedUnarySystemOpenLang n ->
        PointedUnarySystemOpenLang n
      eOL :
        PointedUnarySystemOpenLang n
    evalTerm :
      (A : Set) ->
      PointedUnarySystem A ->
      PointedUnarySystemLang -> A
    evalTerm _ Po (primL x1) =
      prim Po (evalTerm _ Po x1)
    evalTerm _ Po (eL) = e Po
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PointedUnarySystem A ->
      PointedUnarySystemOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (primOL
                         x1) vars =
      prim po
        (evalOpenTerm _ n po x1 vars)
    evalOpenTerm _ n po (eOL) vars =
      e po
    simplify :
      PointedUnarySystemLang ->
      PointedUnarySystemLang
    simplify (primL x1) =
      primL (simplify x1)
    simplify (eL) = eL
    liftPointedUnarySystemLang :
      PointedUnarySystemLang ->
      Staged PointedUnarySystemLang
    liftPointedUnarySystemLang x =
      Now x
    primOL' :
      (n : Nat) ->
      PointedUnarySystemOpenLang n ->
      PointedUnarySystemOpenLang n
    primOL' _ x1 = primOL x1
    eOL' :
      (n : Nat) ->
      PointedUnarySystemOpenLang n
    eOL' _ = eOL
    liftPointedUnarySystemOpenLang :
      (n : Nat) ->
      PointedUnarySystemOpenLang n ->
      Staged
        (PointedUnarySystemOpenLang n)
    liftPointedUnarySystemOpenLang _ (v
                                      fin) = const _ (code _ (v fin))
    liftPointedUnarySystemOpenLang _ (primOL
                                      x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftPointedUnarySystemOpenLang
           _
           x1)
    liftPointedUnarySystemOpenLang _ (eOL) =
      Now eOL
  
  module PointedZero where
    record PointedZero
      (A : Set) : Set where
      constructor PointedZeroC
      field
        0 : A
    record PointedZeroSig
      (AS : Set) : Set where
      constructor PointedZeroSigSigC
      field
        0S : AS
    record PointedZeroProd
      (AP : Set) : Set where
      constructor PointedZeroProdC
      field
        0P : Prod AP AP
    record PointedZeroHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedZero A1)
      (Po2 : PointedZero A2) :
      Set where
      constructor PointedZeroHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Po1) == 0 Po2
    record PointedZeroRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedZero A1)
      (Po2 : PointedZero A2) :
      Set where
      constructor PointedZeroRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Po1) (0 Po2)
    data PointedZeroLang : Set where
      0L : PointedZeroLang
    data PointedZeroOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> PointedZeroOpenLang n
      0OL : PointedZeroOpenLang n
    evalTerm :
      (A : Set) ->
      PointedZero A ->
      PointedZeroLang -> A
    evalTerm _ Po (0L) = 0 Po
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PointedZero A ->
      PointedZeroOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (0OL) vars =
      0 po
    simplify :
      PointedZeroLang ->
      PointedZeroLang
    simplify (0L) = 0L
    liftPointedZeroLang :
      PointedZeroLang ->
      Staged PointedZeroLang
    liftPointedZeroLang x = Now x
    0OL' :
      (n : Nat) ->
      PointedZeroOpenLang n
    0OL' _ = 0OL
    liftPointedZeroOpenLang :
      (n : Nat) ->
      PointedZeroOpenLang n ->
      Staged (PointedZeroOpenLang n)
    liftPointedZeroOpenLang _ (v
                               fin) = const _ (code _ (v fin))
    liftPointedZeroOpenLang _ (0OL) =
      Now 0OL
  
  module PreSemiring where
    record PreSemiring
      (A : Set) : Set where
      constructor PreSemiringC
      field
        * : A -> A -> A
        + : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record PreSemiringSig
      (AS : Set) : Set where
      constructor PreSemiringSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record PreSemiringProd
      (AP : Set) : Set where
      constructor PreSemiringProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record PreSemiringHom
      (A1 : Set) (A2 : Set)
      (Pr1 : PreSemiring A1)
      (Pr2 : PreSemiring A2) :
      Set where
      constructor PreSemiringHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Pr1 x1 x2) ==
            * Pr2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Pr1 x1 x2) ==
            + Pr2 (hom x1) (hom x2)
    record PreSemiringRelInterp
      (A1 : Set) (A2 : Set)
      (Pr1 : PreSemiring A1)
      (Pr2 : PreSemiring A2) :
      Set where
      constructor PreSemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Pr1 x1 x2)
            (* Pr2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Pr1 x1 x2)
            (+ Pr2 y1 y2)
    data PreSemiringLang : Set where
      *L :
        PreSemiringLang ->
        PreSemiringLang ->
        PreSemiringLang
      +L :
        PreSemiringLang ->
        PreSemiringLang ->
        PreSemiringLang
    data PreSemiringOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> PreSemiringOpenLang n
      *OL :
        PreSemiringOpenLang n ->
        PreSemiringOpenLang n ->
        PreSemiringOpenLang n
      +OL :
        PreSemiringOpenLang n ->
        PreSemiringOpenLang n ->
        PreSemiringOpenLang n
    evalTerm :
      (A : Set) ->
      PreSemiring A ->
      PreSemiringLang -> A
    evalTerm _ Pr (*L x1 x2) =
      * Pr (evalTerm _ Pr x1)
        (evalTerm _ Pr x2)
    evalTerm _ Pr (+L x1 x2) =
      + Pr (evalTerm _ Pr x1)
        (evalTerm _ Pr x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PreSemiring A ->
      PreSemiringOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n pr (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n pr (*OL
                         x1
                         x2) vars =
      * pr
        (evalOpenTerm _ n pr x1 vars)
        (evalOpenTerm _ n pr x2 vars)
    evalOpenTerm _ n pr (+OL
                         x1
                         x2) vars =
      + pr
        (evalOpenTerm _ n pr x1 vars)
        (evalOpenTerm _ n pr x2 vars)
    simplify :
      PreSemiringLang ->
      PreSemiringLang
    simplify (+L
              (*L x y)
              (*L x z)) = *L x (+L y z)
    simplify (+L
              (*L y x)
              (*L z x)) = *L (+L y z) x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftPreSemiringLang :
      PreSemiringLang ->
      Staged PreSemiringLang
    liftPreSemiringLang x = Now x
    *OL' :
      (n : Nat) ->
      PreSemiringOpenLang n ->
      PreSemiringOpenLang n ->
      PreSemiringOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      PreSemiringOpenLang n ->
      PreSemiringOpenLang n ->
      PreSemiringOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftPreSemiringOpenLang :
      (n : Nat) ->
      PreSemiringOpenLang n ->
      Staged (PreSemiringOpenLang n)
    liftPreSemiringOpenLang _ (v
                               fin) = const _ (code _ (v fin))
    liftPreSemiringOpenLang _ (*OL
                               x1
                               x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftPreSemiringOpenLang _ x1)
        (liftPreSemiringOpenLang _ x2)
    liftPreSemiringOpenLang _ (+OL
                               x1
                               x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftPreSemiringOpenLang _ x1)
        (liftPreSemiringOpenLang _ x2)
  
  module PrimAdditiveGroup where
    record PrimAdditiveGroup
      (A : Set) : Set where
      constructor PrimAdditiveGroupC
      field
        0_ : A
        *_ : A -> A -> A
        lunit_0_ :
          (x : A) -> *_ 0_ x == x
        runit_0_ :
          (x : A) -> *_ x 0_ == x
        associative_*_ :
          (x : A) (y : A) (z : A) ->
          *_ (*_ x y) z == *_ x (*_ y z)
        inv_ : A -> A
        leftInverse_inv_op_0_ :
          (x : A) -> *_ x (inv_ x) == 0_
        rightInverse_inv_op_0_ :
          (x : A) -> *_ (inv_ x) x == 0_
        commutative_*_ :
          (x : A) (y : A) ->
          *_ x y == *_ y x
    record PrimAdditiveGroupSig
      (AS : Set) : Set where
      constructor PrimAdditiveGroupSigSigC
      field
        0_S : AS
        *_S : AS -> AS -> AS
        inv_S : AS -> AS
    record PrimAdditiveGroupProd
      (AP : Set) : Set where
      constructor PrimAdditiveGroupProdC
      field
        0_P : Prod AP AP
        *_P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        inv_P : Prod AP AP -> Prod AP AP
        lunit_0_P :
          (xP : Prod AP AP) ->
          *_P 0_P xP == xP
        runit_0_P :
          (xP : Prod AP AP) ->
          *_P xP 0_P == xP
        associative_*_P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *_P (*_P xP yP) zP ==
            *_P xP (*_P yP zP)
        leftInverse_inv_op_0_P :
          (xP : Prod AP AP) ->
          *_P xP (inv_P xP) == 0_P
        rightInverse_inv_op_0_P :
          (xP : Prod AP AP) ->
          *_P (inv_P xP) xP == 0_P
        commutative_*_P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *_P xP yP == *_P yP xP
    record PrimAdditiveGroupHom
      (A1 : Set) (A2 : Set)
      (Pr1 : PrimAdditiveGroup A1)
      (Pr2 : PrimAdditiveGroup A2) :
      Set where
      constructor PrimAdditiveGroupHomC
      field
        hom : A1 -> A2
        pres-0_ : hom (0_ Pr1) == 0_ Pr2
        pres-*_ :
          (x1 : A1) (x2 : A1) ->
          hom (*_ Pr1 x1 x2) ==
            *_ Pr2 (hom x1) (hom x2)
        pres-inv_ :
          (x1 : A1) ->
          hom (inv_ Pr1 x1) ==
            inv_ Pr2 (hom x1)
    record PrimAdditiveGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Pr1 : PrimAdditiveGroup A1)
      (Pr2 : PrimAdditiveGroup A2) :
      Set where
      constructor PrimAdditiveGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0_ :
          interp (0_ Pr1) (0_ Pr2)
        interp-*_ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (*_ Pr1 x1 x2)
            (*_ Pr2 y1 y2)
        interp-inv_ :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv_ Pr1 x1)
            (inv_ Pr2 y1)
    data PrimAdditiveGroupLang
      : Set where
      0_L : PrimAdditiveGroupLang
      *_L :
        PrimAdditiveGroupLang ->
        PrimAdditiveGroupLang ->
        PrimAdditiveGroupLang
      inv_L :
        PrimAdditiveGroupLang ->
        PrimAdditiveGroupLang
    data PrimAdditiveGroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        PrimAdditiveGroupOpenLang n
      0_OL :
        PrimAdditiveGroupOpenLang n
      *_OL :
        PrimAdditiveGroupOpenLang n ->
        PrimAdditiveGroupOpenLang n ->
        PrimAdditiveGroupOpenLang n
      inv_OL :
        PrimAdditiveGroupOpenLang n ->
        PrimAdditiveGroupOpenLang n
    evalTerm :
      (A : Set) ->
      PrimAdditiveGroup A ->
      PrimAdditiveGroupLang -> A
    evalTerm _ Pr (0_L) = 0_ Pr
    evalTerm _ Pr (*_L x1 x2) =
      *_ Pr (evalTerm _ Pr x1)
        (evalTerm _ Pr x2)
    evalTerm _ Pr (inv_L x1) =
      inv_ Pr (evalTerm _ Pr x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PrimAdditiveGroup A ->
      PrimAdditiveGroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n pr (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n pr (0_OL) vars =
      0_ pr
    evalOpenTerm _ n pr (*_OL
                         x1
                         x2) vars =
      *_ pr
        (evalOpenTerm _ n pr x1 vars)
        (evalOpenTerm _ n pr x2 vars)
    evalOpenTerm _ n pr (inv_OL
                         x1) vars =
      inv_ pr
        (evalOpenTerm _ n pr x1 vars)
    simplify :
      PrimAdditiveGroupLang ->
      PrimAdditiveGroupLang
    simplify (*_L (0_L) x) = x
    simplify (*_L x (0_L)) = x
    simplify (*_L x (inv_L x)) = 0_L
    simplify (*_L (inv_L x) x) = 0_L
    simplify (0_L) = 0_L
    simplify (*_L x1 x2) =
      *_L (simplify x1) (simplify x2)
    simplify (inv_L x1) =
      inv_L (simplify x1)
    liftPrimAdditiveGroupLang :
      PrimAdditiveGroupLang ->
      Staged PrimAdditiveGroupLang
    liftPrimAdditiveGroupLang x =
      Now x
    0_OL' :
      (n : Nat) ->
      PrimAdditiveGroupOpenLang n
    0_OL' _ = 0_OL
    *_OL' :
      (n : Nat) ->
      PrimAdditiveGroupOpenLang n ->
      PrimAdditiveGroupOpenLang n ->
      PrimAdditiveGroupOpenLang n
    *_OL' _ x1 x2 = *_OL x1 x2
    inv_OL' :
      (n : Nat) ->
      PrimAdditiveGroupOpenLang n ->
      PrimAdditiveGroupOpenLang n
    inv_OL' _ x1 = inv_OL x1
    liftPrimAdditiveGroupOpenLang :
      (n : Nat) ->
      PrimAdditiveGroupOpenLang n ->
      Staged
        (PrimAdditiveGroupOpenLang n)
    liftPrimAdditiveGroupOpenLang _ (v
                                     fin) = const _ (code _ (v fin))
    liftPrimAdditiveGroupOpenLang _ (0_OL) =
      Now 0_OL
    liftPrimAdditiveGroupOpenLang _ (*_OL
                                     x1
                                     x2) =
      stage2 _ _ _ (*_OL' _)
        (codeLift2 _ _ _ (*_OL' _))
        (liftPrimAdditiveGroupOpenLang _
           x1)
        (liftPrimAdditiveGroupOpenLang _
           x2)
    liftPrimAdditiveGroupOpenLang _ (inv_OL
                                     x1) =
      stage1 _ _ (inv_OL' _)
        (codeLift1 _ _ (inv_OL' _))
        (liftPrimAdditiveGroupOpenLang _
           x1)
  
  module PrimRingoidSig where
    record PrimRingoidSig
      (A : Set) : Set where
      constructor PrimRingoidSigC
      field
        * : A -> A -> A
        + : A -> A -> A
        prim : A -> A
    record PrimRingoidSigSig
      (AS : Set) : Set where
      constructor PrimRingoidSigSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        primS : AS -> AS
    record PrimRingoidSigProd
      (AP : Set) : Set where
      constructor PrimRingoidSigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
    record PrimRingoidSigHom
      (A1 : Set) (A2 : Set)
      (Pr1 : PrimRingoidSig A1)
      (Pr2 : PrimRingoidSig A2) :
      Set where
      constructor PrimRingoidSigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Pr1 x1 x2) ==
            * Pr2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Pr1 x1 x2) ==
            + Pr2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Pr1 x1) ==
            prim Pr2 (hom x1)
    record PrimRingoidSigRelInterp
      (A1 : Set) (A2 : Set)
      (Pr1 : PrimRingoidSig A1)
      (Pr2 : PrimRingoidSig A2) :
      Set where
      constructor PrimRingoidSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Pr1 x1 x2)
            (* Pr2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Pr1 x1 x2)
            (+ Pr2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Pr1 x1)
            (prim Pr2 y1)
    data PrimRingoidSigLang
      : Set where
      *L :
        PrimRingoidSigLang ->
        PrimRingoidSigLang ->
        PrimRingoidSigLang
      +L :
        PrimRingoidSigLang ->
        PrimRingoidSigLang ->
        PrimRingoidSigLang
      primL :
        PrimRingoidSigLang ->
        PrimRingoidSigLang
    data PrimRingoidSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        PrimRingoidSigOpenLang n
      *OL :
        PrimRingoidSigOpenLang n ->
        PrimRingoidSigOpenLang n ->
        PrimRingoidSigOpenLang n
      +OL :
        PrimRingoidSigOpenLang n ->
        PrimRingoidSigOpenLang n ->
        PrimRingoidSigOpenLang n
      primOL :
        PrimRingoidSigOpenLang n ->
        PrimRingoidSigOpenLang n
    evalTerm :
      (A : Set) ->
      PrimRingoidSig A ->
      PrimRingoidSigLang -> A
    evalTerm _ Pr (*L x1 x2) =
      * Pr (evalTerm _ Pr x1)
        (evalTerm _ Pr x2)
    evalTerm _ Pr (+L x1 x2) =
      + Pr (evalTerm _ Pr x1)
        (evalTerm _ Pr x2)
    evalTerm _ Pr (primL x1) =
      prim Pr (evalTerm _ Pr x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PrimRingoidSig A ->
      PrimRingoidSigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n pr (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n pr (*OL
                         x1
                         x2) vars =
      * pr
        (evalOpenTerm _ n pr x1 vars)
        (evalOpenTerm _ n pr x2 vars)
    evalOpenTerm _ n pr (+OL
                         x1
                         x2) vars =
      + pr
        (evalOpenTerm _ n pr x1 vars)
        (evalOpenTerm _ n pr x2 vars)
    evalOpenTerm _ n pr (primOL
                         x1) vars =
      prim pr
        (evalOpenTerm _ n pr x1 vars)
    simplify :
      PrimRingoidSigLang ->
      PrimRingoidSigLang
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (primL x1) =
      primL (simplify x1)
    liftPrimRingoidSigLang :
      PrimRingoidSigLang ->
      Staged PrimRingoidSigLang
    liftPrimRingoidSigLang x = Now x
    *OL' :
      (n : Nat) ->
      PrimRingoidSigOpenLang n ->
      PrimRingoidSigOpenLang n ->
      PrimRingoidSigOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      PrimRingoidSigOpenLang n ->
      PrimRingoidSigOpenLang n ->
      PrimRingoidSigOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    primOL' :
      (n : Nat) ->
      PrimRingoidSigOpenLang n ->
      PrimRingoidSigOpenLang n
    primOL' _ x1 = primOL x1
    liftPrimRingoidSigOpenLang :
      (n : Nat) ->
      PrimRingoidSigOpenLang n ->
      Staged
        (PrimRingoidSigOpenLang n)
    liftPrimRingoidSigOpenLang _ (v
                                  fin) = const _ (code _ (v fin))
    liftPrimRingoidSigOpenLang _ (*OL
                                  x1
                                  x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftPrimRingoidSigOpenLang _
           x1)
        (liftPrimRingoidSigOpenLang _
           x2)
    liftPrimRingoidSigOpenLang _ (+OL
                                  x1
                                  x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftPrimRingoidSigOpenLang _
           x1)
        (liftPrimRingoidSigOpenLang _
           x2)
    liftPrimRingoidSigOpenLang _ (primOL
                                  x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftPrimRingoidSigOpenLang _
           x1)
  
  module PseudoInverse where
    record PseudoInverse
      (A : Set) : Set where
      constructor PseudoInverseC
      field
        inv : A -> A
        op : A -> A -> A
        quasiInverse_inv_op_e :
          (x : A) ->
          op (op x (inv x)) x == x
    record PseudoInverseSig
      (AS : Set) : Set where
      constructor PseudoInverseSigSigC
      field
        invS : AS -> AS
        opS : AS -> AS -> AS
    record PseudoInverseProd
      (AP : Set) : Set where
      constructor PseudoInverseProdC
      field
        invP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        quasiInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (opP xP (invP xP)) xP == xP
    record PseudoInverseHom
      (A1 : Set) (A2 : Set)
      (Ps1 : PseudoInverse A1)
      (Ps2 : PseudoInverse A2) :
      Set where
      constructor PseudoInverseHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv Ps1 x1) ==
            inv Ps2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ps1 x1 x2) ==
            op Ps2 (hom x1) (hom x2)
    record PseudoInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Ps1 : PseudoInverse A1)
      (Ps2 : PseudoInverse A2) :
      Set where
      constructor PseudoInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Ps1 x1) (inv Ps2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ps1 x1 x2)
            (op Ps2 y1 y2)
    data PseudoInverseLang
      : Set where
      invL :
        PseudoInverseLang ->
        PseudoInverseLang
      opL :
        PseudoInverseLang ->
        PseudoInverseLang ->
        PseudoInverseLang
    data PseudoInverseOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> PseudoInverseOpenLang n
      invOL :
        PseudoInverseOpenLang n ->
        PseudoInverseOpenLang n
      opOL :
        PseudoInverseOpenLang n ->
        PseudoInverseOpenLang n ->
        PseudoInverseOpenLang n
    evalTerm :
      (A : Set) ->
      PseudoInverse A ->
      PseudoInverseLang -> A
    evalTerm _ Ps (invL x1) =
      inv Ps (evalTerm _ Ps x1)
    evalTerm _ Ps (opL x1 x2) =
      op Ps (evalTerm _ Ps x1)
        (evalTerm _ Ps x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PseudoInverse A ->
      PseudoInverseOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ps (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ps (invOL
                         x1) vars =
      inv ps
        (evalOpenTerm _ n ps x1 vars)
    evalOpenTerm _ n ps (opOL
                         x1
                         x2) vars =
      op ps
        (evalOpenTerm _ n ps x1 vars)
        (evalOpenTerm _ n ps x2 vars)
    simplify :
      PseudoInverseLang ->
      PseudoInverseLang
    simplify (opL
              (opL x (invL x))
              x) = x
    simplify (invL x1) =
      invL (simplify x1)
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftPseudoInverseLang :
      PseudoInverseLang ->
      Staged PseudoInverseLang
    liftPseudoInverseLang x = Now x
    invOL' :
      (n : Nat) ->
      PseudoInverseOpenLang n ->
      PseudoInverseOpenLang n
    invOL' _ x1 = invOL x1
    opOL' :
      (n : Nat) ->
      PseudoInverseOpenLang n ->
      PseudoInverseOpenLang n ->
      PseudoInverseOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftPseudoInverseOpenLang :
      (n : Nat) ->
      PseudoInverseOpenLang n ->
      Staged (PseudoInverseOpenLang n)
    liftPseudoInverseOpenLang _ (v
                                 fin) = const _ (code _ (v fin))
    liftPseudoInverseOpenLang _ (invOL
                                 x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (liftPseudoInverseOpenLang _ x1)
    liftPseudoInverseOpenLang _ (opOL
                                 x1
                                 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftPseudoInverseOpenLang _ x1)
        (liftPseudoInverseOpenLang _ x2)
  
  module PseudoInverseSig where
    record PseudoInverseSig
      (A : Set) : Set where
      constructor PseudoInverseSigC
      field
        inv : A -> A
        op : A -> A -> A
    record PseudoInverseSigSig
      (AS : Set) : Set where
      constructor PseudoInverseSigSigSigC
      field
        invS : AS -> AS
        opS : AS -> AS -> AS
    record PseudoInverseSigProd
      (AP : Set) : Set where
      constructor PseudoInverseSigProdC
      field
        invP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record PseudoInverseSigHom
      (A1 : Set) (A2 : Set)
      (Ps1 : PseudoInverseSig A1)
      (Ps2 : PseudoInverseSig A2) :
      Set where
      constructor PseudoInverseSigHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv Ps1 x1) ==
            inv Ps2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ps1 x1 x2) ==
            op Ps2 (hom x1) (hom x2)
    record PseudoInverseSigRelInterp
      (A1 : Set) (A2 : Set)
      (Ps1 : PseudoInverseSig A1)
      (Ps2 : PseudoInverseSig A2) :
      Set where
      constructor PseudoInverseSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Ps1 x1) (inv Ps2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ps1 x1 x2)
            (op Ps2 y1 y2)
    data PseudoInverseSigLang
      : Set where
      invL :
        PseudoInverseSigLang ->
        PseudoInverseSigLang
      opL :
        PseudoInverseSigLang ->
        PseudoInverseSigLang ->
        PseudoInverseSigLang
    data PseudoInverseSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        PseudoInverseSigOpenLang n
      invOL :
        PseudoInverseSigOpenLang n ->
        PseudoInverseSigOpenLang n
      opOL :
        PseudoInverseSigOpenLang n ->
        PseudoInverseSigOpenLang n ->
        PseudoInverseSigOpenLang n
    evalTerm :
      (A : Set) ->
      PseudoInverseSig A ->
      PseudoInverseSigLang -> A
    evalTerm _ Ps (invL x1) =
      inv Ps (evalTerm _ Ps x1)
    evalTerm _ Ps (opL x1 x2) =
      op Ps (evalTerm _ Ps x1)
        (evalTerm _ Ps x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PseudoInverseSig A ->
      PseudoInverseSigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ps (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ps (invOL
                         x1) vars =
      inv ps
        (evalOpenTerm _ n ps x1 vars)
    evalOpenTerm _ n ps (opOL
                         x1
                         x2) vars =
      op ps
        (evalOpenTerm _ n ps x1 vars)
        (evalOpenTerm _ n ps x2 vars)
    simplify :
      PseudoInverseSigLang ->
      PseudoInverseSigLang
    simplify (invL x1) =
      invL (simplify x1)
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftPseudoInverseSigLang :
      PseudoInverseSigLang ->
      Staged PseudoInverseSigLang
    liftPseudoInverseSigLang x =
      Now x
    invOL' :
      (n : Nat) ->
      PseudoInverseSigOpenLang n ->
      PseudoInverseSigOpenLang n
    invOL' _ x1 = invOL x1
    opOL' :
      (n : Nat) ->
      PseudoInverseSigOpenLang n ->
      PseudoInverseSigOpenLang n ->
      PseudoInverseSigOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftPseudoInverseSigOpenLang :
      (n : Nat) ->
      PseudoInverseSigOpenLang n ->
      Staged
        (PseudoInverseSigOpenLang n)
    liftPseudoInverseSigOpenLang _ (v
                                    fin) = const _ (code _ (v fin))
    liftPseudoInverseSigOpenLang _ (invOL
                                    x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (liftPseudoInverseSigOpenLang _
           x1)
    liftPseudoInverseSigOpenLang _ (opOL
                                    x1
                                    x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftPseudoInverseSigOpenLang _
           x1)
        (liftPseudoInverseSigOpenLang _
           x2)
  
  module PseudoInvolution where
    record PseudoInvolution
      (A : Set) : Set where
      constructor PseudoInvolutionC
      field
        inv : A -> A
        op : A -> A -> A
        quasiRightInverse_inv_op_e :
          (x : A) ->
          op (op (inv x) x) (inv x) ==
            inv x
    record PseudoInvolutionSig
      (AS : Set) : Set where
      constructor PseudoInvolutionSigSigC
      field
        invS : AS -> AS
        opS : AS -> AS -> AS
    record PseudoInvolutionProd
      (AP : Set) : Set where
      constructor PseudoInvolutionProdC
      field
        invP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        quasiRightInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (opP (invP xP) xP)
            (invP xP) == invP xP
    record PseudoInvolutionHom
      (A1 : Set) (A2 : Set)
      (Ps1 : PseudoInvolution A1)
      (Ps2 : PseudoInvolution A2) :
      Set where
      constructor PseudoInvolutionHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv Ps1 x1) ==
            inv Ps2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ps1 x1 x2) ==
            op Ps2 (hom x1) (hom x2)
    record PseudoInvolutionRelInterp
      (A1 : Set) (A2 : Set)
      (Ps1 : PseudoInvolution A1)
      (Ps2 : PseudoInvolution A2) :
      Set where
      constructor PseudoInvolutionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Ps1 x1) (inv Ps2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ps1 x1 x2)
            (op Ps2 y1 y2)
    data PseudoInvolutionLang
      : Set where
      invL :
        PseudoInvolutionLang ->
        PseudoInvolutionLang
      opL :
        PseudoInvolutionLang ->
        PseudoInvolutionLang ->
        PseudoInvolutionLang
    data PseudoInvolutionOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        PseudoInvolutionOpenLang n
      invOL :
        PseudoInvolutionOpenLang n ->
        PseudoInvolutionOpenLang n
      opOL :
        PseudoInvolutionOpenLang n ->
        PseudoInvolutionOpenLang n ->
        PseudoInvolutionOpenLang n
    evalTerm :
      (A : Set) ->
      PseudoInvolution A ->
      PseudoInvolutionLang -> A
    evalTerm _ Ps (invL x1) =
      inv Ps (evalTerm _ Ps x1)
    evalTerm _ Ps (opL x1 x2) =
      op Ps (evalTerm _ Ps x1)
        (evalTerm _ Ps x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PseudoInvolution A ->
      PseudoInvolutionOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ps (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ps (invOL
                         x1) vars =
      inv ps
        (evalOpenTerm _ n ps x1 vars)
    evalOpenTerm _ n ps (opOL
                         x1
                         x2) vars =
      op ps
        (evalOpenTerm _ n ps x1 vars)
        (evalOpenTerm _ n ps x2 vars)
    simplify :
      PseudoInvolutionLang ->
      PseudoInvolutionLang
    simplify (opL
              (opL (invL x) x)
              (invL x)) = invL x
    simplify (invL x1) =
      invL (simplify x1)
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftPseudoInvolutionLang :
      PseudoInvolutionLang ->
      Staged PseudoInvolutionLang
    liftPseudoInvolutionLang x =
      Now x
    invOL' :
      (n : Nat) ->
      PseudoInvolutionOpenLang n ->
      PseudoInvolutionOpenLang n
    invOL' _ x1 = invOL x1
    opOL' :
      (n : Nat) ->
      PseudoInvolutionOpenLang n ->
      PseudoInvolutionOpenLang n ->
      PseudoInvolutionOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftPseudoInvolutionOpenLang :
      (n : Nat) ->
      PseudoInvolutionOpenLang n ->
      Staged
        (PseudoInvolutionOpenLang n)
    liftPseudoInvolutionOpenLang _ (v
                                    fin) = const _ (code _ (v fin))
    liftPseudoInvolutionOpenLang _ (invOL
                                    x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (liftPseudoInvolutionOpenLang _
           x1)
    liftPseudoInvolutionOpenLang _ (opOL
                                    x1
                                    x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftPseudoInvolutionOpenLang _
           x1)
        (liftPseudoInvolutionOpenLang _
           x2)
  
  module Quandle where
    record Quandle
      (A : Set) : Set where
      constructor QuandleC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
        leftInverse :
          (x : A) (y : A) ->
          <| (|> x y) x == y
        rightInverse :
          (x : A) (y : A) ->
          |> x (<| y x) == y
        idempotent_|> :
          (x : A) -> |> x x == x
        idempotent_<| :
          (x : A) -> <| x x == x
    record QuandleSig
      (AS : Set) : Set where
      constructor QuandleSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record QuandleProd
      (AP : Set) : Set where
      constructor QuandleProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
        leftInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          <|P (|>P xP yP) xP == yP
        rightInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          |>P xP (<|P yP xP) == yP
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
        idempotent_<|P :
          (xP : Prod AP AP) ->
          <|P xP xP == xP
    record QuandleHom
      (A1 : Set) (A2 : Set)
      (Qu1 : Quandle A1)
      (Qu2 : Quandle A2) : Set where
      constructor QuandleHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Qu1 x1 x2) ==
            |> Qu2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Qu1 x1 x2) ==
            <| Qu2 (hom x1) (hom x2)
    record QuandleRelInterp
      (A1 : Set) (A2 : Set)
      (Qu1 : Quandle A1)
      (Qu2 : Quandle A2) : Set where
      constructor QuandleRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Qu1 x1 x2)
            (|> Qu2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Qu1 x1 x2)
            (<| Qu2 y1 y2)
    data QuandleLang : Set where
      |>L :
        QuandleLang ->
        QuandleLang -> QuandleLang
      <|L :
        QuandleLang ->
        QuandleLang -> QuandleLang
    data QuandleOpenLang
      (n : Nat) : Set where
      v : Fin n -> QuandleOpenLang n
      |>OL :
        QuandleOpenLang n ->
        QuandleOpenLang n ->
        QuandleOpenLang n
      <|OL :
        QuandleOpenLang n ->
        QuandleOpenLang n ->
        QuandleOpenLang n
    evalTerm :
      (A : Set) ->
      Quandle A -> QuandleLang -> A
    evalTerm _ Qu (|>L x1 x2) =
      |> Qu (evalTerm _ Qu x1)
        (evalTerm _ Qu x2)
    evalTerm _ Qu (<|L x1 x2) =
      <| Qu (evalTerm _ Qu x1)
        (evalTerm _ Qu x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Quandle A ->
      QuandleOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n qu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n qu (|>OL
                         x1
                         x2) vars =
      |> qu
        (evalOpenTerm _ n qu x1 vars)
        (evalOpenTerm _ n qu x2 vars)
    evalOpenTerm _ n qu (<|OL
                         x1
                         x2) vars =
      <| qu
        (evalOpenTerm _ n qu x1 vars)
        (evalOpenTerm _ n qu x2 vars)
    simplify :
      QuandleLang -> QuandleLang
    simplify (|>L
              (|>L x y)
              (|>L x z)) = |>L x (|>L y z)
    simplify (<|L
              (<|L y x)
              (<|L z x)) = <|L (<|L y z) x
    simplify (<|L (|>L x y) x) = y
    simplify (|>L x (<|L y x)) = y
    simplify (|>L x x) = x
    simplify (<|L x x) = x
    simplify (|>L x1 x2) =
      |>L (simplify x1) (simplify x2)
    simplify (<|L x1 x2) =
      <|L (simplify x1) (simplify x2)
    liftQuandleLang :
      QuandleLang ->
      Staged QuandleLang
    liftQuandleLang x = Now x
    |>OL' :
      (n : Nat) ->
      QuandleOpenLang n ->
      QuandleOpenLang n ->
      QuandleOpenLang n
    |>OL' _ x1 x2 = |>OL x1 x2
    <|OL' :
      (n : Nat) ->
      QuandleOpenLang n ->
      QuandleOpenLang n ->
      QuandleOpenLang n
    <|OL' _ x1 x2 = <|OL x1 x2
    liftQuandleOpenLang :
      (n : Nat) ->
      QuandleOpenLang n ->
      Staged (QuandleOpenLang n)
    liftQuandleOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftQuandleOpenLang _ (|>OL
                           x1
                           x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (liftQuandleOpenLang _ x1)
        (liftQuandleOpenLang _ x2)
    liftQuandleOpenLang _ (<|OL
                           x1
                           x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (liftQuandleOpenLang _ x1)
        (liftQuandleOpenLang _ x2)
  
  module QuasiGroup where
    record QuasiGroup
      (A : Set) : Set where
      constructor QuasiGroupC
      field
        op : A -> A -> A
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
    record QuasiGroupSig
      (AS : Set) : Set where
      constructor QuasiGroupSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record QuasiGroupProd
      (AP : Set) : Set where
      constructor QuasiGroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
    record QuasiGroupHom
      (A1 : Set) (A2 : Set)
      (Qu1 : QuasiGroup A1)
      (Qu2 : QuasiGroup A2) :
      Set where
      constructor QuasiGroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Qu1 x1 x2) ==
            op Qu2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Qu1 x1 x2) ==
            linv Qu2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Qu1 x1 x2) ==
            rinv Qu2 (hom x1) (hom x2)
    record QuasiGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Qu1 : QuasiGroup A1)
      (Qu2 : QuasiGroup A2) :
      Set where
      constructor QuasiGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Qu1 x1 x2)
            (op Qu2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Qu1 x1 x2)
            (linv Qu2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Qu1 x1 x2)
            (rinv Qu2 y1 y2)
    data QuasiGroupLang : Set where
      opL :
        QuasiGroupLang ->
        QuasiGroupLang -> QuasiGroupLang
      linvL :
        QuasiGroupLang ->
        QuasiGroupLang -> QuasiGroupLang
      rinvL :
        QuasiGroupLang ->
        QuasiGroupLang -> QuasiGroupLang
    data QuasiGroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> QuasiGroupOpenLang n
      opOL :
        QuasiGroupOpenLang n ->
        QuasiGroupOpenLang n ->
        QuasiGroupOpenLang n
      linvOL :
        QuasiGroupOpenLang n ->
        QuasiGroupOpenLang n ->
        QuasiGroupOpenLang n
      rinvOL :
        QuasiGroupOpenLang n ->
        QuasiGroupOpenLang n ->
        QuasiGroupOpenLang n
    evalTerm :
      (A : Set) ->
      QuasiGroup A ->
      QuasiGroupLang -> A
    evalTerm _ Qu (opL x1 x2) =
      op Qu (evalTerm _ Qu x1)
        (evalTerm _ Qu x2)
    evalTerm _ Qu (linvL x1 x2) =
      linv Qu (evalTerm _ Qu x1)
        (evalTerm _ Qu x2)
    evalTerm _ Qu (rinvL x1 x2) =
      rinv Qu (evalTerm _ Qu x1)
        (evalTerm _ Qu x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      QuasiGroup A ->
      QuasiGroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n qu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n qu (opOL
                         x1
                         x2) vars =
      op qu
        (evalOpenTerm _ n qu x1 vars)
        (evalOpenTerm _ n qu x2 vars)
    evalOpenTerm _ n qu (linvOL
                         x1
                         x2) vars =
      linv qu
        (evalOpenTerm _ n qu x1 vars)
        (evalOpenTerm _ n qu x2 vars)
    evalOpenTerm _ n qu (rinvOL
                         x1
                         x2) vars =
      rinv qu
        (evalOpenTerm _ n qu x1 vars)
        (evalOpenTerm _ n qu x2 vars)
    simplify :
      QuasiGroupLang -> QuasiGroupLang
    simplify (opL x (linvL x y)) = y
    simplify (linvL x (opL x y)) = y
    simplify (opL (rinvL y x) x) = y
    simplify (rinvL (opL y x) x) = y
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (linvL x1 x2) =
      linvL (simplify x1)
        (simplify x2)
    simplify (rinvL x1 x2) =
      rinvL (simplify x1)
        (simplify x2)
    liftQuasiGroupLang :
      QuasiGroupLang ->
      Staged QuasiGroupLang
    liftQuasiGroupLang x = Now x
    opOL' :
      (n : Nat) ->
      QuasiGroupOpenLang n ->
      QuasiGroupOpenLang n ->
      QuasiGroupOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    linvOL' :
      (n : Nat) ->
      QuasiGroupOpenLang n ->
      QuasiGroupOpenLang n ->
      QuasiGroupOpenLang n
    linvOL' _ x1 x2 = linvOL x1 x2
    rinvOL' :
      (n : Nat) ->
      QuasiGroupOpenLang n ->
      QuasiGroupOpenLang n ->
      QuasiGroupOpenLang n
    rinvOL' _ x1 x2 = rinvOL x1 x2
    liftQuasiGroupOpenLang :
      (n : Nat) ->
      QuasiGroupOpenLang n ->
      Staged (QuasiGroupOpenLang n)
    liftQuasiGroupOpenLang _ (v
                              fin) = const _ (code _ (v fin))
    liftQuasiGroupOpenLang _ (opOL
                              x1
                              x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftQuasiGroupOpenLang _ x1)
        (liftQuasiGroupOpenLang _ x2)
    liftQuasiGroupOpenLang _ (linvOL
                              x1
                              x2) =
      stage2 _ _ _ (linvOL' _)
        (codeLift2 _ _ _ (linvOL' _))
        (liftQuasiGroupOpenLang _ x1)
        (liftQuasiGroupOpenLang _ x2)
    liftQuasiGroupOpenLang _ (rinvOL
                              x1
                              x2) =
      stage2 _ _ _ (rinvOL' _)
        (codeLift2 _ _ _ (rinvOL' _))
        (liftQuasiGroupOpenLang _ x1)
        (liftQuasiGroupOpenLang _ x2)
  
  module QuasiInverse where
    record QuasiInverse
      (A : Set) : Set where
      constructor QuasiInverseC
      field
        inv : A -> A
        op : A -> A -> A
        quasiInverse_inv_op_e :
          (x : A) ->
          op (op x (inv x)) x == x
        quasiRightInverse_inv_op_e :
          (x : A) ->
          op (op (inv x) x) (inv x) ==
            inv x
    record QuasiInverseSig
      (AS : Set) : Set where
      constructor QuasiInverseSigSigC
      field
        invS : AS -> AS
        opS : AS -> AS -> AS
    record QuasiInverseProd
      (AP : Set) : Set where
      constructor QuasiInverseProdC
      field
        invP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        quasiInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (opP xP (invP xP)) xP == xP
        quasiRightInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (opP (invP xP) xP)
            (invP xP) == invP xP
    record QuasiInverseHom
      (A1 : Set) (A2 : Set)
      (Qu1 : QuasiInverse A1)
      (Qu2 : QuasiInverse A2) :
      Set where
      constructor QuasiInverseHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv Qu1 x1) ==
            inv Qu2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Qu1 x1 x2) ==
            op Qu2 (hom x1) (hom x2)
    record QuasiInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Qu1 : QuasiInverse A1)
      (Qu2 : QuasiInverse A2) :
      Set where
      constructor QuasiInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Qu1 x1) (inv Qu2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Qu1 x1 x2)
            (op Qu2 y1 y2)
    data QuasiInverseLang
      : Set where
      invL :
        QuasiInverseLang ->
        QuasiInverseLang
      opL :
        QuasiInverseLang ->
        QuasiInverseLang ->
        QuasiInverseLang
    data QuasiInverseOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> QuasiInverseOpenLang n
      invOL :
        QuasiInverseOpenLang n ->
        QuasiInverseOpenLang n
      opOL :
        QuasiInverseOpenLang n ->
        QuasiInverseOpenLang n ->
        QuasiInverseOpenLang n
    evalTerm :
      (A : Set) ->
      QuasiInverse A ->
      QuasiInverseLang -> A
    evalTerm _ Qu (invL x1) =
      inv Qu (evalTerm _ Qu x1)
    evalTerm _ Qu (opL x1 x2) =
      op Qu (evalTerm _ Qu x1)
        (evalTerm _ Qu x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      QuasiInverse A ->
      QuasiInverseOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n qu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n qu (invOL
                         x1) vars =
      inv qu
        (evalOpenTerm _ n qu x1 vars)
    evalOpenTerm _ n qu (opOL
                         x1
                         x2) vars =
      op qu
        (evalOpenTerm _ n qu x1 vars)
        (evalOpenTerm _ n qu x2 vars)
    simplify :
      QuasiInverseLang ->
      QuasiInverseLang
    simplify (opL
              (opL x (invL x))
              x) = x
    simplify (opL
              (opL (invL x) x)
              (invL x)) = invL x
    simplify (invL x1) =
      invL (simplify x1)
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftQuasiInverseLang :
      QuasiInverseLang ->
      Staged QuasiInverseLang
    liftQuasiInverseLang x = Now x
    invOL' :
      (n : Nat) ->
      QuasiInverseOpenLang n ->
      QuasiInverseOpenLang n
    invOL' _ x1 = invOL x1
    opOL' :
      (n : Nat) ->
      QuasiInverseOpenLang n ->
      QuasiInverseOpenLang n ->
      QuasiInverseOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftQuasiInverseOpenLang :
      (n : Nat) ->
      QuasiInverseOpenLang n ->
      Staged (QuasiInverseOpenLang n)
    liftQuasiInverseOpenLang _ (v
                                fin) = const _ (code _ (v fin))
    liftQuasiInverseOpenLang _ (invOL
                                x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (liftQuasiInverseOpenLang _ x1)
    liftQuasiInverseOpenLang _ (opOL
                                x1
                                x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftQuasiInverseOpenLang _ x1)
        (liftQuasiInverseOpenLang _ x2)
  
  module Rack where
    record Rack
      (A : Set) : Set where
      constructor RackC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
        leftInverse :
          (x : A) (y : A) ->
          <| (|> x y) x == y
        rightInverse :
          (x : A) (y : A) ->
          |> x (<| y x) == y
    record RackSig
      (AS : Set) : Set where
      constructor RackSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record RackProd
      (AP : Set) : Set where
      constructor RackProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
        leftInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          <|P (|>P xP yP) xP == yP
        rightInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          |>P xP (<|P yP xP) == yP
    record RackHom
      (A1 : Set) (A2 : Set)
      (Ra1 : Rack A1)
      (Ra2 : Rack A2) : Set where
      constructor RackHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ra1 x1 x2) ==
            |> Ra2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ra1 x1 x2) ==
            <| Ra2 (hom x1) (hom x2)
    record RackRelInterp
      (A1 : Set) (A2 : Set)
      (Ra1 : Rack A1)
      (Ra2 : Rack A2) : Set where
      constructor RackRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ra1 x1 x2)
            (|> Ra2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ra1 x1 x2)
            (<| Ra2 y1 y2)
    data RackLang : Set where
      |>L :
        RackLang -> RackLang -> RackLang
      <|L :
        RackLang -> RackLang -> RackLang
    data RackOpenLang
      (n : Nat) : Set where
      v : Fin n -> RackOpenLang n
      |>OL :
        RackOpenLang n ->
        RackOpenLang n -> RackOpenLang n
      <|OL :
        RackOpenLang n ->
        RackOpenLang n -> RackOpenLang n
    evalTerm :
      (A : Set) ->
      Rack A -> RackLang -> A
    evalTerm _ Ra (|>L x1 x2) =
      |> Ra (evalTerm _ Ra x1)
        (evalTerm _ Ra x2)
    evalTerm _ Ra (<|L x1 x2) =
      <| Ra (evalTerm _ Ra x1)
        (evalTerm _ Ra x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Rack A ->
      RackOpenLang n -> Vec A n -> A
    evalOpenTerm _ n ra (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ra (|>OL
                         x1
                         x2) vars =
      |> ra
        (evalOpenTerm _ n ra x1 vars)
        (evalOpenTerm _ n ra x2 vars)
    evalOpenTerm _ n ra (<|OL
                         x1
                         x2) vars =
      <| ra
        (evalOpenTerm _ n ra x1 vars)
        (evalOpenTerm _ n ra x2 vars)
    simplify : RackLang -> RackLang
    simplify (|>L
              (|>L x y)
              (|>L x z)) = |>L x (|>L y z)
    simplify (<|L
              (<|L y x)
              (<|L z x)) = <|L (<|L y z) x
    simplify (<|L (|>L x y) x) = y
    simplify (|>L x (<|L y x)) = y
    simplify (|>L x1 x2) =
      |>L (simplify x1) (simplify x2)
    simplify (<|L x1 x2) =
      <|L (simplify x1) (simplify x2)
    liftRackLang :
      RackLang -> Staged RackLang
    liftRackLang x = Now x
    |>OL' :
      (n : Nat) ->
      RackOpenLang n ->
      RackOpenLang n -> RackOpenLang n
    |>OL' _ x1 x2 = |>OL x1 x2
    <|OL' :
      (n : Nat) ->
      RackOpenLang n ->
      RackOpenLang n -> RackOpenLang n
    <|OL' _ x1 x2 = <|OL x1 x2
    liftRackOpenLang :
      (n : Nat) ->
      RackOpenLang n ->
      Staged (RackOpenLang n)
    liftRackOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftRackOpenLang _ (|>OL
                        x1
                        x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (liftRackOpenLang _ x1)
        (liftRackOpenLang _ x2)
    liftRackOpenLang _ (<|OL
                        x1
                        x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (liftRackOpenLang _ x1)
        (liftRackOpenLang _ x2)
  
  module RectangularBand where
    record RectangularBand
      (A : Set) : Set where
      constructor RectangularBandC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        idempotent_op :
          (x : A) -> op x x == x
        middleCommute_* :
          (x : A) (y : A) (z : A) ->
          op (op (op x y) z) x ==
            op (op (op x z) y) x
    record RectangularBandSig
      (AS : Set) : Set where
      constructor RectangularBandSigSigC
      field
        opS : AS -> AS -> AS
    record RectangularBandProd
      (AP : Set) : Set where
      constructor RectangularBandProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        idempotent_opP :
          (xP : Prod AP AP) ->
          opP xP xP == xP
        middleCommute_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP (opP xP yP) zP) xP ==
            opP (opP (opP xP zP) yP) xP
    record RectangularBandHom
      (A1 : Set) (A2 : Set)
      (Re1 : RectangularBand A1)
      (Re2 : RectangularBand A2) :
      Set where
      constructor RectangularBandHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Re1 x1 x2) ==
            op Re2 (hom x1) (hom x2)
    record RectangularBandRelInterp
      (A1 : Set) (A2 : Set)
      (Re1 : RectangularBand A1)
      (Re2 : RectangularBand A2) :
      Set where
      constructor RectangularBandRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Re1 x1 x2)
            (op Re2 y1 y2)
    data RectangularBandLang
      : Set where
      opL :
        RectangularBandLang ->
        RectangularBandLang ->
        RectangularBandLang
    data RectangularBandOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RectangularBandOpenLang n
      opOL :
        RectangularBandOpenLang n ->
        RectangularBandOpenLang n ->
        RectangularBandOpenLang n
    evalTerm :
      (A : Set) ->
      RectangularBand A ->
      RectangularBandLang -> A
    evalTerm _ Re (opL x1 x2) =
      op Re (evalTerm _ Re x1)
        (evalTerm _ Re x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RectangularBand A ->
      RectangularBandOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n re (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n re (opOL
                         x1
                         x2) vars =
      op re
        (evalOpenTerm _ n re x1 vars)
        (evalOpenTerm _ n re x2 vars)
    simplify :
      RectangularBandLang ->
      RectangularBandLang
    simplify (opL x x) = x
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftRectangularBandLang :
      RectangularBandLang ->
      Staged RectangularBandLang
    liftRectangularBandLang x =
      Now x
    opOL' :
      (n : Nat) ->
      RectangularBandOpenLang n ->
      RectangularBandOpenLang n ->
      RectangularBandOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftRectangularBandOpenLang :
      (n : Nat) ->
      RectangularBandOpenLang n ->
      Staged
        (RectangularBandOpenLang n)
    liftRectangularBandOpenLang _ (v
                                   fin) = const _ (code _ (v fin))
    liftRectangularBandOpenLang _ (opOL
                                   x1
                                   x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftRectangularBandOpenLang _
           x1)
        (liftRectangularBandOpenLang _
           x2)
  
  module RegularSemigroup where
    record RegularSemigroup
      (A : Set) : Set where
      constructor RegularSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        inv : A -> A
        quasiInverse_inv_op_e :
          (x : A) ->
          op (op x (inv x)) x == x
    record RegularSemigroupSig
      (AS : Set) : Set where
      constructor RegularSemigroupSigSigC
      field
        opS : AS -> AS -> AS
        invS : AS -> AS
    record RegularSemigroupProd
      (AP : Set) : Set where
      constructor RegularSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        quasiInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (opP xP (invP xP)) xP == xP
    record RegularSemigroupHom
      (A1 : Set) (A2 : Set)
      (Re1 : RegularSemigroup A1)
      (Re2 : RegularSemigroup A2) :
      Set where
      constructor RegularSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Re1 x1 x2) ==
            op Re2 (hom x1) (hom x2)
        pres-inv :
          (x1 : A1) ->
          hom (inv Re1 x1) ==
            inv Re2 (hom x1)
    record RegularSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Re1 : RegularSemigroup A1)
      (Re2 : RegularSemigroup A2) :
      Set where
      constructor RegularSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Re1 x1 x2)
            (op Re2 y1 y2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Re1 x1) (inv Re2 y1)
    data RegularSemigroupLang
      : Set where
      opL :
        RegularSemigroupLang ->
        RegularSemigroupLang ->
        RegularSemigroupLang
      invL :
        RegularSemigroupLang ->
        RegularSemigroupLang
    data RegularSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RegularSemigroupOpenLang n
      opOL :
        RegularSemigroupOpenLang n ->
        RegularSemigroupOpenLang n ->
        RegularSemigroupOpenLang n
      invOL :
        RegularSemigroupOpenLang n ->
        RegularSemigroupOpenLang n
    evalTerm :
      (A : Set) ->
      RegularSemigroup A ->
      RegularSemigroupLang -> A
    evalTerm _ Re (opL x1 x2) =
      op Re (evalTerm _ Re x1)
        (evalTerm _ Re x2)
    evalTerm _ Re (invL x1) =
      inv Re (evalTerm _ Re x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RegularSemigroup A ->
      RegularSemigroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n re (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n re (opOL
                         x1
                         x2) vars =
      op re
        (evalOpenTerm _ n re x1 vars)
        (evalOpenTerm _ n re x2 vars)
    evalOpenTerm _ n re (invOL
                         x1) vars =
      inv re
        (evalOpenTerm _ n re x1 vars)
    simplify :
      RegularSemigroupLang ->
      RegularSemigroupLang
    simplify (opL
              (opL x (invL x))
              x) = x
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (invL x1) =
      invL (simplify x1)
    liftRegularSemigroupLang :
      RegularSemigroupLang ->
      Staged RegularSemigroupLang
    liftRegularSemigroupLang x =
      Now x
    opOL' :
      (n : Nat) ->
      RegularSemigroupOpenLang n ->
      RegularSemigroupOpenLang n ->
      RegularSemigroupOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    invOL' :
      (n : Nat) ->
      RegularSemigroupOpenLang n ->
      RegularSemigroupOpenLang n
    invOL' _ x1 = invOL x1
    liftRegularSemigroupOpenLang :
      (n : Nat) ->
      RegularSemigroupOpenLang n ->
      Staged
        (RegularSemigroupOpenLang n)
    liftRegularSemigroupOpenLang _ (v
                                    fin) = const _ (code _ (v fin))
    liftRegularSemigroupOpenLang _ (opOL
                                    x1
                                    x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftRegularSemigroupOpenLang _
           x1)
        (liftRegularSemigroupOpenLang _
           x2)
    liftRegularSemigroupOpenLang _ (invOL
                                    x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (liftRegularSemigroupOpenLang _
           x1)
  
  module Right0 where
    record Right0
      (A : Set) : Set where
      constructor Right0C
      field
        0 : A
        op : A -> A -> A
        rightZero_op_0 :
          (x : A) -> op x 0 == 0
    record Right0Sig
      (AS : Set) : Set where
      constructor Right0SigSigC
      field
        0S : AS
        opS : AS -> AS -> AS
    record Right0Prod
      (AP : Set) : Set where
      constructor Right0ProdC
      field
        0P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          opP xP 0P == 0P
    record Right0Hom
      (A1 : Set) (A2 : Set)
      (Ri1 : Right0 A1)
      (Ri2 : Right0 A2) : Set where
      constructor Right0HomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ri1) == 0 Ri2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record Right0RelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Right0 A1)
      (Ri2 : Right0 A2) : Set where
      constructor Right0RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ri1) (0 Ri2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data Right0Lang : Set where
      0L : Right0Lang
      opL :
        Right0Lang ->
        Right0Lang -> Right0Lang
    data Right0OpenLang
      (n : Nat) : Set where
      v : Fin n -> Right0OpenLang n
      0OL : Right0OpenLang n
      opOL :
        Right0OpenLang n ->
        Right0OpenLang n ->
        Right0OpenLang n
    evalTerm :
      (A : Set) ->
      Right0 A -> Right0Lang -> A
    evalTerm _ Ri (0L) = 0 Ri
    evalTerm _ Ri (opL x1 x2) =
      op Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Right0 A ->
      Right0OpenLang n -> Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (0OL) vars =
      0 ri
    evalOpenTerm _ n ri (opOL
                         x1
                         x2) vars =
      op ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      Right0Lang -> Right0Lang
    simplify (opL x (0L)) = 0L
    simplify (0L) = 0L
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftRight0Lang :
      Right0Lang -> Staged Right0Lang
    liftRight0Lang x = Now x
    0OL' :
      (n : Nat) -> Right0OpenLang n
    0OL' _ = 0OL
    opOL' :
      (n : Nat) ->
      Right0OpenLang n ->
      Right0OpenLang n ->
      Right0OpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftRight0OpenLang :
      (n : Nat) ->
      Right0OpenLang n ->
      Staged (Right0OpenLang n)
    liftRight0OpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftRight0OpenLang _ (0OL) =
      Now 0OL
    liftRight0OpenLang _ (opOL
                          x1
                          x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftRight0OpenLang _ x1)
        (liftRight0OpenLang _ x2)
  
  module RightBiMagma where
    record RightBiMagma
      (A : Set) : Set where
      constructor RightBiMagmaC
      field
        op : A -> A -> A
        rinv : A -> A -> A
    record RightBiMagmaSig
      (AS : Set) : Set where
      constructor RightBiMagmaSigSigC
      field
        opS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record RightBiMagmaProd
      (AP : Set) : Set where
      constructor RightBiMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record RightBiMagmaHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightBiMagma A1)
      (Ri2 : RightBiMagma A2) :
      Set where
      constructor RightBiMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Ri1 x1 x2) ==
            rinv Ri2 (hom x1) (hom x2)
    record RightBiMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightBiMagma A1)
      (Ri2 : RightBiMagma A2) :
      Set where
      constructor RightBiMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Ri1 x1 x2)
            (rinv Ri2 y1 y2)
    data RightBiMagmaLang
      : Set where
      opL :
        RightBiMagmaLang ->
        RightBiMagmaLang ->
        RightBiMagmaLang
      rinvL :
        RightBiMagmaLang ->
        RightBiMagmaLang ->
        RightBiMagmaLang
    data RightBiMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> RightBiMagmaOpenLang n
      opOL :
        RightBiMagmaOpenLang n ->
        RightBiMagmaOpenLang n ->
        RightBiMagmaOpenLang n
      rinvOL :
        RightBiMagmaOpenLang n ->
        RightBiMagmaOpenLang n ->
        RightBiMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      RightBiMagma A ->
      RightBiMagmaLang -> A
    evalTerm _ Ri (opL x1 x2) =
      op Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (rinvL x1 x2) =
      rinv Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightBiMagma A ->
      RightBiMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (opOL
                         x1
                         x2) vars =
      op ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (rinvOL
                         x1
                         x2) vars =
      rinv ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RightBiMagmaLang ->
      RightBiMagmaLang
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (rinvL x1 x2) =
      rinvL (simplify x1)
        (simplify x2)
    liftRightBiMagmaLang :
      RightBiMagmaLang ->
      Staged RightBiMagmaLang
    liftRightBiMagmaLang x = Now x
    opOL' :
      (n : Nat) ->
      RightBiMagmaOpenLang n ->
      RightBiMagmaOpenLang n ->
      RightBiMagmaOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    rinvOL' :
      (n : Nat) ->
      RightBiMagmaOpenLang n ->
      RightBiMagmaOpenLang n ->
      RightBiMagmaOpenLang n
    rinvOL' _ x1 x2 = rinvOL x1 x2
    liftRightBiMagmaOpenLang :
      (n : Nat) ->
      RightBiMagmaOpenLang n ->
      Staged (RightBiMagmaOpenLang n)
    liftRightBiMagmaOpenLang _ (v
                                fin) = const _ (code _ (v fin))
    liftRightBiMagmaOpenLang _ (opOL
                                x1
                                x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftRightBiMagmaOpenLang _ x1)
        (liftRightBiMagmaOpenLang _ x2)
    liftRightBiMagmaOpenLang _ (rinvOL
                                x1
                                x2) =
      stage2 _ _ _ (rinvOL' _)
        (codeLift2 _ _ _ (rinvOL' _))
        (liftRightBiMagmaOpenLang _ x1)
        (liftRightBiMagmaOpenLang _ x2)
  
  module RightBinaryInverse where
    record RightBinaryInverse
      (A : Set) : Set where
      constructor RightBinaryInverseC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        rightInverse :
          (x : A) (y : A) ->
          |> x (<| y x) == y
    record RightBinaryInverseSig
      (AS : Set) : Set where
      constructor RightBinaryInverseSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record RightBinaryInverseProd
      (AP : Set) : Set where
      constructor RightBinaryInverseProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          |>P xP (<|P yP xP) == yP
    record RightBinaryInverseHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightBinaryInverse A1)
      (Ri2 : RightBinaryInverse A2) :
      Set where
      constructor RightBinaryInverseHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ri1 x1 x2) ==
            |> Ri2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
    record RightBinaryInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightBinaryInverse A1)
      (Ri2 : RightBinaryInverse A2) :
      Set where
      constructor RightBinaryInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ri1 x1 x2)
            (|> Ri2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
    data RightBinaryInverseLang
      : Set where
      |>L :
        RightBinaryInverseLang ->
        RightBinaryInverseLang ->
        RightBinaryInverseLang
      <|L :
        RightBinaryInverseLang ->
        RightBinaryInverseLang ->
        RightBinaryInverseLang
    data RightBinaryInverseOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RightBinaryInverseOpenLang n
      |>OL :
        RightBinaryInverseOpenLang n ->
        RightBinaryInverseOpenLang n ->
        RightBinaryInverseOpenLang n
      <|OL :
        RightBinaryInverseOpenLang n ->
        RightBinaryInverseOpenLang n ->
        RightBinaryInverseOpenLang n
    evalTerm :
      (A : Set) ->
      RightBinaryInverse A ->
      RightBinaryInverseLang -> A
    evalTerm _ Ri (|>L x1 x2) =
      |> Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (<|L x1 x2) =
      <| Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightBinaryInverse A ->
      RightBinaryInverseOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (|>OL
                         x1
                         x2) vars =
      |> ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (<|OL
                         x1
                         x2) vars =
      <| ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RightBinaryInverseLang ->
      RightBinaryInverseLang
    simplify (|>L x (<|L y x)) = y
    simplify (|>L x1 x2) =
      |>L (simplify x1) (simplify x2)
    simplify (<|L x1 x2) =
      <|L (simplify x1) (simplify x2)
    liftRightBinaryInverseLang :
      RightBinaryInverseLang ->
      Staged RightBinaryInverseLang
    liftRightBinaryInverseLang x =
      Now x
    |>OL' :
      (n : Nat) ->
      RightBinaryInverseOpenLang n ->
      RightBinaryInverseOpenLang n ->
      RightBinaryInverseOpenLang n
    |>OL' _ x1 x2 = |>OL x1 x2
    <|OL' :
      (n : Nat) ->
      RightBinaryInverseOpenLang n ->
      RightBinaryInverseOpenLang n ->
      RightBinaryInverseOpenLang n
    <|OL' _ x1 x2 = <|OL x1 x2
    liftRightBinaryInverseOpenLang :
      (n : Nat) ->
      RightBinaryInverseOpenLang n ->
      Staged
        (RightBinaryInverseOpenLang n)
    liftRightBinaryInverseOpenLang _ (v
                                      fin) = const _ (code _ (v fin))
    liftRightBinaryInverseOpenLang _ (|>OL
                                      x1
                                      x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (liftRightBinaryInverseOpenLang
           _
           x1)
        (liftRightBinaryInverseOpenLang
           _
           x2)
    liftRightBinaryInverseOpenLang _ (<|OL
                                      x1
                                      x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (liftRightBinaryInverseOpenLang
           _
           x1)
        (liftRightBinaryInverseOpenLang
           _
           x2)
  
  module RightCancellative where
    record RightCancellative
      (A : Set) : Set where
      constructor RightCancellativeC
      field
        op : A -> A -> A
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
    record RightCancellativeSig
      (AS : Set) : Set where
      constructor RightCancellativeSigSigC
      field
        opS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record RightCancellativeProd
      (AP : Set) : Set where
      constructor RightCancellativeProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
    record RightCancellativeHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellative A1)
      (Ri2 : RightCancellative A2) :
      Set where
      constructor RightCancellativeHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Ri1 x1 x2) ==
            rinv Ri2 (hom x1) (hom x2)
    record RightCancellativeRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellative A1)
      (Ri2 : RightCancellative A2) :
      Set where
      constructor RightCancellativeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Ri1 x1 x2)
            (rinv Ri2 y1 y2)
    data RightCancellativeLang
      : Set where
      opL :
        RightCancellativeLang ->
        RightCancellativeLang ->
        RightCancellativeLang
      rinvL :
        RightCancellativeLang ->
        RightCancellativeLang ->
        RightCancellativeLang
    data RightCancellativeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RightCancellativeOpenLang n
      opOL :
        RightCancellativeOpenLang n ->
        RightCancellativeOpenLang n ->
        RightCancellativeOpenLang n
      rinvOL :
        RightCancellativeOpenLang n ->
        RightCancellativeOpenLang n ->
        RightCancellativeOpenLang n
    evalTerm :
      (A : Set) ->
      RightCancellative A ->
      RightCancellativeLang -> A
    evalTerm _ Ri (opL x1 x2) =
      op Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (rinvL x1 x2) =
      rinv Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightCancellative A ->
      RightCancellativeOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (opOL
                         x1
                         x2) vars =
      op ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (rinvOL
                         x1
                         x2) vars =
      rinv ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RightCancellativeLang ->
      RightCancellativeLang
    simplify (opL (rinvL y x) x) = y
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (rinvL x1 x2) =
      rinvL (simplify x1)
        (simplify x2)
    liftRightCancellativeLang :
      RightCancellativeLang ->
      Staged RightCancellativeLang
    liftRightCancellativeLang x =
      Now x
    opOL' :
      (n : Nat) ->
      RightCancellativeOpenLang n ->
      RightCancellativeOpenLang n ->
      RightCancellativeOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    rinvOL' :
      (n : Nat) ->
      RightCancellativeOpenLang n ->
      RightCancellativeOpenLang n ->
      RightCancellativeOpenLang n
    rinvOL' _ x1 x2 = rinvOL x1 x2
    liftRightCancellativeOpenLang :
      (n : Nat) ->
      RightCancellativeOpenLang n ->
      Staged
        (RightCancellativeOpenLang n)
    liftRightCancellativeOpenLang _ (v
                                     fin) = const _ (code _ (v fin))
    liftRightCancellativeOpenLang _ (opOL
                                     x1
                                     x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftRightCancellativeOpenLang _
           x1)
        (liftRightCancellativeOpenLang _
           x2)
    liftRightCancellativeOpenLang _ (rinvOL
                                     x1
                                     x2) =
      stage2 _ _ _ (rinvOL' _)
        (codeLift2 _ _ _ (rinvOL' _))
        (liftRightCancellativeOpenLang _
           x1)
        (liftRightCancellativeOpenLang _
           x2)
  
  module RightCancellativeMagma where
    record RightCancellativeMagma
      (A : Set) : Set where
      constructor RightCancellativeMagmaC
      field
        op : A -> A -> A
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
    record RightCancellativeMagmaSig
      (AS : Set) : Set where
      constructor RightCancellativeMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record RightCancellativeMagmaProd
      (AP : Set) : Set where
      constructor RightCancellativeMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
    record RightCancellativeMagmaHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellativeMagma
         A1)
      (Ri2 : RightCancellativeMagma
         A2) : Set where
      constructor RightCancellativeMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record RightCancellativeMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellativeMagma
         A1)
      (Ri2 : RightCancellativeMagma
         A2) : Set where
      constructor RightCancellativeMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data RightCancellativeMagmaLang
      : Set where
      opL :
        RightCancellativeMagmaLang ->
        RightCancellativeMagmaLang ->
        RightCancellativeMagmaLang
    data RightCancellativeMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RightCancellativeMagmaOpenLang n
      opOL :
        RightCancellativeMagmaOpenLang
          n ->
        RightCancellativeMagmaOpenLang
          n ->
        RightCancellativeMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      RightCancellativeMagma A ->
      RightCancellativeMagmaLang -> A
    evalTerm _ Ri (opL x1 x2) =
      op Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightCancellativeMagma A ->
      RightCancellativeMagmaOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (opOL
                         x1
                         x2) vars =
      op ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RightCancellativeMagmaLang ->
      RightCancellativeMagmaLang
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftRightCancellativeMagmaLang :
      RightCancellativeMagmaLang ->
      Staged
        RightCancellativeMagmaLang
    liftRightCancellativeMagmaLang x =
      Now x
    opOL' :
      (n : Nat) ->
      RightCancellativeMagmaOpenLang
        n ->
      RightCancellativeMagmaOpenLang
        n ->
      RightCancellativeMagmaOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftRightCancellativeMagmaOpenLang :
      (n : Nat) ->
      RightCancellativeMagmaOpenLang
        n ->
      Staged
        (RightCancellativeMagmaOpenLang
           n)
    liftRightCancellativeMagmaOpenLang _ (v
                                          fin) = const _ (code _ (v fin))
    liftRightCancellativeMagmaOpenLang _ (opOL
                                          x1
                                          x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftRightCancellativeMagmaOpenLang
           _
           x1)
        (liftRightCancellativeMagmaOpenLang
           _
           x2)
  
  module RightCancellativeOp where
    record RightCancellativeOp
      (A : Set) : Set where
      constructor RightCancellativeOpC
      field
        op : A -> A -> A
        rinv : A -> A -> A
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
    record RightCancellativeOpSig
      (AS : Set) : Set where
      constructor RightCancellativeOpSigSigC
      field
        opS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record RightCancellativeOpProd
      (AP : Set) : Set where
      constructor RightCancellativeOpProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
    record RightCancellativeOpHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellativeOp A1)
      (Ri2 : RightCancellativeOp A2) :
      Set where
      constructor RightCancellativeOpHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Ri1 x1 x2) ==
            rinv Ri2 (hom x1) (hom x2)
    record RightCancellativeOpRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellativeOp A1)
      (Ri2 : RightCancellativeOp A2) :
      Set where
      constructor RightCancellativeOpRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Ri1 x1 x2)
            (rinv Ri2 y1 y2)
    data RightCancellativeOpLang
      : Set where
      opL :
        RightCancellativeOpLang ->
        RightCancellativeOpLang ->
        RightCancellativeOpLang
      rinvL :
        RightCancellativeOpLang ->
        RightCancellativeOpLang ->
        RightCancellativeOpLang
    data RightCancellativeOpOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RightCancellativeOpOpenLang n
      opOL :
        RightCancellativeOpOpenLang n ->
        RightCancellativeOpOpenLang n ->
        RightCancellativeOpOpenLang n
      rinvOL :
        RightCancellativeOpOpenLang n ->
        RightCancellativeOpOpenLang n ->
        RightCancellativeOpOpenLang n
    evalTerm :
      (A : Set) ->
      RightCancellativeOp A ->
      RightCancellativeOpLang -> A
    evalTerm _ Ri (opL x1 x2) =
      op Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (rinvL x1 x2) =
      rinv Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightCancellativeOp A ->
      RightCancellativeOpOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (opOL
                         x1
                         x2) vars =
      op ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (rinvOL
                         x1
                         x2) vars =
      rinv ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RightCancellativeOpLang ->
      RightCancellativeOpLang
    simplify (rinvL (opL y x) x) = y
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (rinvL x1 x2) =
      rinvL (simplify x1)
        (simplify x2)
    liftRightCancellativeOpLang :
      RightCancellativeOpLang ->
      Staged RightCancellativeOpLang
    liftRightCancellativeOpLang x =
      Now x
    opOL' :
      (n : Nat) ->
      RightCancellativeOpOpenLang n ->
      RightCancellativeOpOpenLang n ->
      RightCancellativeOpOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    rinvOL' :
      (n : Nat) ->
      RightCancellativeOpOpenLang n ->
      RightCancellativeOpOpenLang n ->
      RightCancellativeOpOpenLang n
    rinvOL' _ x1 x2 = rinvOL x1 x2
    liftRightCancellativeOpOpenLang :
      (n : Nat) ->
      RightCancellativeOpOpenLang n ->
      Staged
        (RightCancellativeOpOpenLang n)
    liftRightCancellativeOpOpenLang _ (v
                                       fin) = const _ (code _ (v fin))
    liftRightCancellativeOpOpenLang _ (opOL
                                       x1
                                       x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftRightCancellativeOpOpenLang
           _
           x1)
        (liftRightCancellativeOpOpenLang
           _
           x2)
    liftRightCancellativeOpOpenLang _ (rinvOL
                                       x1
                                       x2) =
      stage2 _ _ _ (rinvOL' _)
        (codeLift2 _ _ _ (rinvOL' _))
        (liftRightCancellativeOpOpenLang
           _
           x1)
        (liftRightCancellativeOpOpenLang
           _
           x2)
  
  module RightCancellativeSemigroup where
    record RightCancellativeSemigroup
      (A : Set) : Set where
      constructor RightCancellativeSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
    record RightCancellativeSemigroupSig
      (AS : Set) : Set where
      constructor RightCancellativeSemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record RightCancellativeSemigroupProd
      (AP : Set) : Set where
      constructor RightCancellativeSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
    record RightCancellativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellativeSemigroup
         A1)
      (Ri2 : RightCancellativeSemigroup
         A2) : Set where
      constructor RightCancellativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record RightCancellativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellativeSemigroup
         A1)
      (Ri2 : RightCancellativeSemigroup
         A2) : Set where
      constructor RightCancellativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data RightCancellativeSemigroupLang
      : Set where
      opL :
        RightCancellativeSemigroupLang ->
        RightCancellativeSemigroupLang ->
        RightCancellativeSemigroupLang
    data RightCancellativeSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RightCancellativeSemigroupOpenLang
          n
      opOL :
        RightCancellativeSemigroupOpenLang
          n ->
        RightCancellativeSemigroupOpenLang
          n ->
        RightCancellativeSemigroupOpenLang
          n
    evalTerm :
      (A : Set) ->
      RightCancellativeSemigroup A ->
      RightCancellativeSemigroupLang ->
      A
    evalTerm _ Ri (opL x1 x2) =
      op Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightCancellativeSemigroup A ->
      RightCancellativeSemigroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (opOL
                         x1
                         x2) vars =
      op ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RightCancellativeSemigroupLang ->
      RightCancellativeSemigroupLang
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftRightCancellativeSemigroupLang :
      RightCancellativeSemigroupLang ->
      Staged
        RightCancellativeSemigroupLang
    liftRightCancellativeSemigroupLang x =
      Now x
    opOL' :
      (n : Nat) ->
      RightCancellativeSemigroupOpenLang
        n ->
      RightCancellativeSemigroupOpenLang
        n ->
      RightCancellativeSemigroupOpenLang
        n
    opOL' _ x1 x2 = opOL x1 x2
    liftRightCancellativeSemigroupOpenLang :
      (n : Nat) ->
      RightCancellativeSemigroupOpenLang
        n ->
      Staged
        (RightCancellativeSemigroupOpenLang
           n)
    liftRightCancellativeSemigroupOpenLang _ (v
                                              fin) = const _ (code _ (v fin))
    liftRightCancellativeSemigroupOpenLang _ (opOL
                                              x1
                                              x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftRightCancellativeSemigroupOpenLang
           _
           x1)
        (liftRightCancellativeSemigroupOpenLang
           _
           x2)
  
  module RightDistributiveMagma where
    record RightDistributiveMagma
      (A : Set) : Set where
      constructor RightDistributiveMagmaC
      field
        op : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          op (op y z) x ==
            op (op y x) (op z x)
    record RightDistributiveMagmaSig
      (AS : Set) : Set where
      constructor RightDistributiveMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record RightDistributiveMagmaProd
      (AP : Set) : Set where
      constructor RightDistributiveMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP yP zP) xP ==
            opP (opP yP xP) (opP zP xP)
    record RightDistributiveMagmaHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightDistributiveMagma
         A1)
      (Ri2 : RightDistributiveMagma
         A2) : Set where
      constructor RightDistributiveMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record RightDistributiveMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightDistributiveMagma
         A1)
      (Ri2 : RightDistributiveMagma
         A2) : Set where
      constructor RightDistributiveMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data RightDistributiveMagmaLang
      : Set where
      opL :
        RightDistributiveMagmaLang ->
        RightDistributiveMagmaLang ->
        RightDistributiveMagmaLang
    data RightDistributiveMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RightDistributiveMagmaOpenLang n
      opOL :
        RightDistributiveMagmaOpenLang
          n ->
        RightDistributiveMagmaOpenLang
          n ->
        RightDistributiveMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      RightDistributiveMagma A ->
      RightDistributiveMagmaLang -> A
    evalTerm _ Ri (opL x1 x2) =
      op Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightDistributiveMagma A ->
      RightDistributiveMagmaOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (opOL
                         x1
                         x2) vars =
      op ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RightDistributiveMagmaLang ->
      RightDistributiveMagmaLang
    simplify (opL
              (opL y x)
              (opL z x)) = opL (opL y z) x
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftRightDistributiveMagmaLang :
      RightDistributiveMagmaLang ->
      Staged
        RightDistributiveMagmaLang
    liftRightDistributiveMagmaLang x =
      Now x
    opOL' :
      (n : Nat) ->
      RightDistributiveMagmaOpenLang
        n ->
      RightDistributiveMagmaOpenLang
        n ->
      RightDistributiveMagmaOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftRightDistributiveMagmaOpenLang :
      (n : Nat) ->
      RightDistributiveMagmaOpenLang
        n ->
      Staged
        (RightDistributiveMagmaOpenLang
           n)
    liftRightDistributiveMagmaOpenLang _ (v
                                          fin) = const _ (code _ (v fin))
    liftRightDistributiveMagmaOpenLang _ (opOL
                                          x1
                                          x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftRightDistributiveMagmaOpenLang
           _
           x1)
        (liftRightDistributiveMagmaOpenLang
           _
           x2)
  
  module RightIdempotence where
    record RightIdempotence
      (A : Set) : Set where
      constructor RightIdempotenceC
      field
        <| : A -> A -> A
        idempotent_<| :
          (x : A) -> <| x x == x
    record RightIdempotenceSig
      (AS : Set) : Set where
      constructor RightIdempotenceSigSigC
      field
        <|S : AS -> AS -> AS
    record RightIdempotenceProd
      (AP : Set) : Set where
      constructor RightIdempotenceProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        idempotent_<|P :
          (xP : Prod AP AP) ->
          <|P xP xP == xP
    record RightIdempotenceHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightIdempotence A1)
      (Ri2 : RightIdempotence A2) :
      Set where
      constructor RightIdempotenceHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
    record RightIdempotenceRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightIdempotence A1)
      (Ri2 : RightIdempotence A2) :
      Set where
      constructor RightIdempotenceRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
    data RightIdempotenceLang
      : Set where
      <|L :
        RightIdempotenceLang ->
        RightIdempotenceLang ->
        RightIdempotenceLang
    data RightIdempotenceOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RightIdempotenceOpenLang n
      <|OL :
        RightIdempotenceOpenLang n ->
        RightIdempotenceOpenLang n ->
        RightIdempotenceOpenLang n
    evalTerm :
      (A : Set) ->
      RightIdempotence A ->
      RightIdempotenceLang -> A
    evalTerm _ Ri (<|L x1 x2) =
      <| Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightIdempotence A ->
      RightIdempotenceOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (<|OL
                         x1
                         x2) vars =
      <| ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RightIdempotenceLang ->
      RightIdempotenceLang
    simplify (<|L x x) = x
    simplify (<|L x1 x2) =
      <|L (simplify x1) (simplify x2)
    liftRightIdempotenceLang :
      RightIdempotenceLang ->
      Staged RightIdempotenceLang
    liftRightIdempotenceLang x =
      Now x
    <|OL' :
      (n : Nat) ->
      RightIdempotenceOpenLang n ->
      RightIdempotenceOpenLang n ->
      RightIdempotenceOpenLang n
    <|OL' _ x1 x2 = <|OL x1 x2
    liftRightIdempotenceOpenLang :
      (n : Nat) ->
      RightIdempotenceOpenLang n ->
      Staged
        (RightIdempotenceOpenLang n)
    liftRightIdempotenceOpenLang _ (v
                                    fin) = const _ (code _ (v fin))
    liftRightIdempotenceOpenLang _ (<|OL
                                    x1
                                    x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (liftRightIdempotenceOpenLang _
           x1)
        (liftRightIdempotenceOpenLang _
           x2)
  
  module RightInverse where
    record RightInverse
      (A : Set) : Set where
      constructor RightInverseC
      field
        inv : A -> A
        e : A
        op : A -> A -> A
        rightInverse_inv_op_e :
          (x : A) -> op (inv x) x == e
    record RightInverseSig
      (AS : Set) : Set where
      constructor RightInverseSigSigC
      field
        invS : AS -> AS
        eS : AS
        opS : AS -> AS -> AS
    record RightInverseProd
      (AP : Set) : Set where
      constructor RightInverseProdC
      field
        invP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (invP xP) xP == eP
    record RightInverseHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightInverse A1)
      (Ri2 : RightInverse A2) :
      Set where
      constructor RightInverseHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv Ri1 x1) ==
            inv Ri2 (hom x1)
        pres-e : hom (e Ri1) == e Ri2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record RightInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightInverse A1)
      (Ri2 : RightInverse A2) :
      Set where
      constructor RightInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Ri1 x1) (inv Ri2 y1)
        interp-e :
          interp (e Ri1) (e Ri2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data RightInverseLang
      : Set where
      invL :
        RightInverseLang ->
        RightInverseLang
      eL : RightInverseLang
      opL :
        RightInverseLang ->
        RightInverseLang ->
        RightInverseLang
    data RightInverseOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> RightInverseOpenLang n
      invOL :
        RightInverseOpenLang n ->
        RightInverseOpenLang n
      eOL : RightInverseOpenLang n
      opOL :
        RightInverseOpenLang n ->
        RightInverseOpenLang n ->
        RightInverseOpenLang n
    evalTerm :
      (A : Set) ->
      RightInverse A ->
      RightInverseLang -> A
    evalTerm _ Ri (invL x1) =
      inv Ri (evalTerm _ Ri x1)
    evalTerm _ Ri (eL) = e Ri
    evalTerm _ Ri (opL x1 x2) =
      op Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightInverse A ->
      RightInverseOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (invOL
                         x1) vars =
      inv ri
        (evalOpenTerm _ n ri x1 vars)
    evalOpenTerm _ n ri (eOL) vars =
      e ri
    evalOpenTerm _ n ri (opOL
                         x1
                         x2) vars =
      op ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RightInverseLang ->
      RightInverseLang
    simplify (opL (invL x) x) = eL
    simplify (invL x1) =
      invL (simplify x1)
    simplify (eL) = eL
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftRightInverseLang :
      RightInverseLang ->
      Staged RightInverseLang
    liftRightInverseLang x = Now x
    invOL' :
      (n : Nat) ->
      RightInverseOpenLang n ->
      RightInverseOpenLang n
    invOL' _ x1 = invOL x1
    eOL' :
      (n : Nat) ->
      RightInverseOpenLang n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      RightInverseOpenLang n ->
      RightInverseOpenLang n ->
      RightInverseOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftRightInverseOpenLang :
      (n : Nat) ->
      RightInverseOpenLang n ->
      Staged (RightInverseOpenLang n)
    liftRightInverseOpenLang _ (v
                                fin) = const _ (code _ (v fin))
    liftRightInverseOpenLang _ (invOL
                                x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (liftRightInverseOpenLang _ x1)
    liftRightInverseOpenLang _ (eOL) =
      Now eOL
    liftRightInverseOpenLang _ (opOL
                                x1
                                x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftRightInverseOpenLang _ x1)
        (liftRightInverseOpenLang _ x2)
  
  module RightInverseMagma where
    record RightInverseMagma
      (A : Set) : Set where
      constructor RightInverseMagmaC
      field
        rinv : A -> A -> A
    record RightInverseMagmaSig
      (AS : Set) : Set where
      constructor RightInverseMagmaSigSigC
      field
        rinvS : AS -> AS -> AS
    record RightInverseMagmaProd
      (AP : Set) : Set where
      constructor RightInverseMagmaProdC
      field
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record RightInverseMagmaHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightInverseMagma A1)
      (Ri2 : RightInverseMagma A2) :
      Set where
      constructor RightInverseMagmaHomC
      field
        hom : A1 -> A2
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Ri1 x1 x2) ==
            rinv Ri2 (hom x1) (hom x2)
    record RightInverseMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightInverseMagma A1)
      (Ri2 : RightInverseMagma A2) :
      Set where
      constructor RightInverseMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Ri1 x1 x2)
            (rinv Ri2 y1 y2)
    data RightInverseMagmaLang
      : Set where
      rinvL :
        RightInverseMagmaLang ->
        RightInverseMagmaLang ->
        RightInverseMagmaLang
    data RightInverseMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RightInverseMagmaOpenLang n
      rinvOL :
        RightInverseMagmaOpenLang n ->
        RightInverseMagmaOpenLang n ->
        RightInverseMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      RightInverseMagma A ->
      RightInverseMagmaLang -> A
    evalTerm _ Ri (rinvL x1 x2) =
      rinv Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightInverseMagma A ->
      RightInverseMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (rinvOL
                         x1
                         x2) vars =
      rinv ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RightInverseMagmaLang ->
      RightInverseMagmaLang
    simplify (rinvL x1 x2) =
      rinvL (simplify x1)
        (simplify x2)
    liftRightInverseMagmaLang :
      RightInverseMagmaLang ->
      Staged RightInverseMagmaLang
    liftRightInverseMagmaLang x =
      Now x
    rinvOL' :
      (n : Nat) ->
      RightInverseMagmaOpenLang n ->
      RightInverseMagmaOpenLang n ->
      RightInverseMagmaOpenLang n
    rinvOL' _ x1 x2 = rinvOL x1 x2
    liftRightInverseMagmaOpenLang :
      (n : Nat) ->
      RightInverseMagmaOpenLang n ->
      Staged
        (RightInverseMagmaOpenLang n)
    liftRightInverseMagmaOpenLang _ (v
                                     fin) = const _ (code _ (v fin))
    liftRightInverseMagmaOpenLang _ (rinvOL
                                     x1
                                     x2) =
      stage2 _ _ _ (rinvOL' _)
        (codeLift2 _ _ _ (rinvOL' _))
        (liftRightInverseMagmaOpenLang _
           x1)
        (liftRightInverseMagmaOpenLang _
           x2)
  
  module RightMonoid where
    record RightMonoid
      (A : Set) : Set where
      constructor RightMonoidC
      field
        op : A -> A -> A
        e : A
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record RightMonoidSig
      (AS : Set) : Set where
      constructor RightMonoidSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record RightMonoidProd
      (AP : Set) : Set where
      constructor RightMonoidProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record RightMonoidHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightMonoid A1)
      (Ri2 : RightMonoid A2) :
      Set where
      constructor RightMonoidHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
        pres-e : hom (e Ri1) == e Ri2
    record RightMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightMonoid A1)
      (Ri2 : RightMonoid A2) :
      Set where
      constructor RightMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
        interp-e :
          interp (e Ri1) (e Ri2)
    data RightMonoidLang : Set where
      opL :
        RightMonoidLang ->
        RightMonoidLang ->
        RightMonoidLang
      eL : RightMonoidLang
    data RightMonoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> RightMonoidOpenLang n
      opOL :
        RightMonoidOpenLang n ->
        RightMonoidOpenLang n ->
        RightMonoidOpenLang n
      eOL : RightMonoidOpenLang n
    evalTerm :
      (A : Set) ->
      RightMonoid A ->
      RightMonoidLang -> A
    evalTerm _ Ri (opL x1 x2) =
      op Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (eL) = e Ri
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightMonoid A ->
      RightMonoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (opOL
                         x1
                         x2) vars =
      op ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (eOL) vars =
      e ri
    simplify :
      RightMonoidLang ->
      RightMonoidLang
    simplify (opL x (eL)) = x
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (eL) = eL
    liftRightMonoidLang :
      RightMonoidLang ->
      Staged RightMonoidLang
    liftRightMonoidLang x = Now x
    opOL' :
      (n : Nat) ->
      RightMonoidOpenLang n ->
      RightMonoidOpenLang n ->
      RightMonoidOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    eOL' :
      (n : Nat) ->
      RightMonoidOpenLang n
    eOL' _ = eOL
    liftRightMonoidOpenLang :
      (n : Nat) ->
      RightMonoidOpenLang n ->
      Staged (RightMonoidOpenLang n)
    liftRightMonoidOpenLang _ (v
                               fin) = const _ (code _ (v fin))
    liftRightMonoidOpenLang _ (opOL
                               x1
                               x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftRightMonoidOpenLang _ x1)
        (liftRightMonoidOpenLang _ x2)
    liftRightMonoidOpenLang _ (eOL) =
      Now eOL
  
  module RightPreSemiring where
    record RightPreSemiring
      (A : Set) : Set where
      constructor RightPreSemiringC
      field
        * : A -> A -> A
        + : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record RightPreSemiringSig
      (AS : Set) : Set where
      constructor RightPreSemiringSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record RightPreSemiringProd
      (AP : Set) : Set where
      constructor RightPreSemiringProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record RightPreSemiringHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightPreSemiring A1)
      (Ri2 : RightPreSemiring A2) :
      Set where
      constructor RightPreSemiringHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
    record RightPreSemiringRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightPreSemiring A1)
      (Ri2 : RightPreSemiring A2) :
      Set where
      constructor RightPreSemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
    data RightPreSemiringLang
      : Set where
      *L :
        RightPreSemiringLang ->
        RightPreSemiringLang ->
        RightPreSemiringLang
      +L :
        RightPreSemiringLang ->
        RightPreSemiringLang ->
        RightPreSemiringLang
    data RightPreSemiringOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RightPreSemiringOpenLang n
      *OL :
        RightPreSemiringOpenLang n ->
        RightPreSemiringOpenLang n ->
        RightPreSemiringOpenLang n
      +OL :
        RightPreSemiringOpenLang n ->
        RightPreSemiringOpenLang n ->
        RightPreSemiringOpenLang n
    evalTerm :
      (A : Set) ->
      RightPreSemiring A ->
      RightPreSemiringLang -> A
    evalTerm _ Ri (*L x1 x2) =
      * Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (+L x1 x2) =
      + Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightPreSemiring A ->
      RightPreSemiringOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (*OL
                         x1
                         x2) vars =
      * ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (+OL
                         x1
                         x2) vars =
      + ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RightPreSemiringLang ->
      RightPreSemiringLang
    simplify (+L
              (*L y x)
              (*L z x)) = *L (+L y z) x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftRightPreSemiringLang :
      RightPreSemiringLang ->
      Staged RightPreSemiringLang
    liftRightPreSemiringLang x =
      Now x
    *OL' :
      (n : Nat) ->
      RightPreSemiringOpenLang n ->
      RightPreSemiringOpenLang n ->
      RightPreSemiringOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      RightPreSemiringOpenLang n ->
      RightPreSemiringOpenLang n ->
      RightPreSemiringOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftRightPreSemiringOpenLang :
      (n : Nat) ->
      RightPreSemiringOpenLang n ->
      Staged
        (RightPreSemiringOpenLang n)
    liftRightPreSemiringOpenLang _ (v
                                    fin) = const _ (code _ (v fin))
    liftRightPreSemiringOpenLang _ (*OL
                                    x1
                                    x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftRightPreSemiringOpenLang _
           x1)
        (liftRightPreSemiringOpenLang _
           x2)
    liftRightPreSemiringOpenLang _ (+OL
                                    x1
                                    x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftRightPreSemiringOpenLang _
           x1)
        (liftRightPreSemiringOpenLang _
           x2)
  
  module RightQuasiGroup where
    record RightQuasiGroup
      (A : Set) : Set where
      constructor RightQuasiGroupC
      field
        op : A -> A -> A
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
    record RightQuasiGroupSig
      (AS : Set) : Set where
      constructor RightQuasiGroupSigSigC
      field
        opS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record RightQuasiGroupProd
      (AP : Set) : Set where
      constructor RightQuasiGroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
    record RightQuasiGroupHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightQuasiGroup A1)
      (Ri2 : RightQuasiGroup A2) :
      Set where
      constructor RightQuasiGroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Ri1 x1 x2) ==
            rinv Ri2 (hom x1) (hom x2)
    record RightQuasiGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightQuasiGroup A1)
      (Ri2 : RightQuasiGroup A2) :
      Set where
      constructor RightQuasiGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Ri1 x1 x2)
            (rinv Ri2 y1 y2)
    data RightQuasiGroupLang
      : Set where
      opL :
        RightQuasiGroupLang ->
        RightQuasiGroupLang ->
        RightQuasiGroupLang
      rinvL :
        RightQuasiGroupLang ->
        RightQuasiGroupLang ->
        RightQuasiGroupLang
    data RightQuasiGroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RightQuasiGroupOpenLang n
      opOL :
        RightQuasiGroupOpenLang n ->
        RightQuasiGroupOpenLang n ->
        RightQuasiGroupOpenLang n
      rinvOL :
        RightQuasiGroupOpenLang n ->
        RightQuasiGroupOpenLang n ->
        RightQuasiGroupOpenLang n
    evalTerm :
      (A : Set) ->
      RightQuasiGroup A ->
      RightQuasiGroupLang -> A
    evalTerm _ Ri (opL x1 x2) =
      op Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (rinvL x1 x2) =
      rinv Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightQuasiGroup A ->
      RightQuasiGroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (opOL
                         x1
                         x2) vars =
      op ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (rinvOL
                         x1
                         x2) vars =
      rinv ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RightQuasiGroupLang ->
      RightQuasiGroupLang
    simplify (opL (rinvL y x) x) = y
    simplify (rinvL (opL y x) x) = y
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    simplify (rinvL x1 x2) =
      rinvL (simplify x1)
        (simplify x2)
    liftRightQuasiGroupLang :
      RightQuasiGroupLang ->
      Staged RightQuasiGroupLang
    liftRightQuasiGroupLang x =
      Now x
    opOL' :
      (n : Nat) ->
      RightQuasiGroupOpenLang n ->
      RightQuasiGroupOpenLang n ->
      RightQuasiGroupOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    rinvOL' :
      (n : Nat) ->
      RightQuasiGroupOpenLang n ->
      RightQuasiGroupOpenLang n ->
      RightQuasiGroupOpenLang n
    rinvOL' _ x1 x2 = rinvOL x1 x2
    liftRightQuasiGroupOpenLang :
      (n : Nat) ->
      RightQuasiGroupOpenLang n ->
      Staged
        (RightQuasiGroupOpenLang n)
    liftRightQuasiGroupOpenLang _ (v
                                   fin) = const _ (code _ (v fin))
    liftRightQuasiGroupOpenLang _ (opOL
                                   x1
                                   x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftRightQuasiGroupOpenLang _
           x1)
        (liftRightQuasiGroupOpenLang _
           x2)
    liftRightQuasiGroupOpenLang _ (rinvOL
                                   x1
                                   x2) =
      stage2 _ _ _ (rinvOL' _)
        (codeLift2 _ _ _ (rinvOL' _))
        (liftRightQuasiGroupOpenLang _
           x1)
        (liftRightQuasiGroupOpenLang _
           x2)
  
  module RightRack where
    record RightRack
      (A : Set) : Set where
      constructor RightRackC
      field
        <| : A -> A -> A
        |> : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
    record RightRackSig
      (AS : Set) : Set where
      constructor RightRackSigSigC
      field
        <|S : AS -> AS -> AS
        |>S : AS -> AS -> AS
    record RightRackProd
      (AP : Set) : Set where
      constructor RightRackProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
    record RightRackHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightRack A1)
      (Ri2 : RightRack A2) : Set where
      constructor RightRackHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ri1 x1 x2) ==
            |> Ri2 (hom x1) (hom x2)
    record RightRackRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightRack A1)
      (Ri2 : RightRack A2) : Set where
      constructor RightRackRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ri1 x1 x2)
            (|> Ri2 y1 y2)
    data RightRackLang : Set where
      <|L :
        RightRackLang ->
        RightRackLang -> RightRackLang
      |>L :
        RightRackLang ->
        RightRackLang -> RightRackLang
    data RightRackOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> RightRackOpenLang n
      <|OL :
        RightRackOpenLang n ->
        RightRackOpenLang n ->
        RightRackOpenLang n
      |>OL :
        RightRackOpenLang n ->
        RightRackOpenLang n ->
        RightRackOpenLang n
    evalTerm :
      (A : Set) ->
      RightRack A ->
      RightRackLang -> A
    evalTerm _ Ri (<|L x1 x2) =
      <| Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (|>L x1 x2) =
      |> Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightRack A ->
      RightRackOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (<|OL
                         x1
                         x2) vars =
      <| ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (|>OL
                         x1
                         x2) vars =
      |> ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RightRackLang -> RightRackLang
    simplify (<|L
              (<|L y x)
              (<|L z x)) = <|L (<|L y z) x
    simplify (<|L x1 x2) =
      <|L (simplify x1) (simplify x2)
    simplify (|>L x1 x2) =
      |>L (simplify x1) (simplify x2)
    liftRightRackLang :
      RightRackLang ->
      Staged RightRackLang
    liftRightRackLang x = Now x
    <|OL' :
      (n : Nat) ->
      RightRackOpenLang n ->
      RightRackOpenLang n ->
      RightRackOpenLang n
    <|OL' _ x1 x2 = <|OL x1 x2
    |>OL' :
      (n : Nat) ->
      RightRackOpenLang n ->
      RightRackOpenLang n ->
      RightRackOpenLang n
    |>OL' _ x1 x2 = |>OL x1 x2
    liftRightRackOpenLang :
      (n : Nat) ->
      RightRackOpenLang n ->
      Staged (RightRackOpenLang n)
    liftRightRackOpenLang _ (v
                             fin) = const _ (code _ (v fin))
    liftRightRackOpenLang _ (<|OL
                             x1
                             x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (liftRightRackOpenLang _ x1)
        (liftRightRackOpenLang _ x2)
    liftRightRackOpenLang _ (|>OL
                             x1
                             x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (liftRightRackOpenLang _ x1)
        (liftRightRackOpenLang _ x2)
  
  module RightRingoid where
    record RightRingoid
      (A : Set) : Set where
      constructor RightRingoidC
      field
        * : A -> A -> A
        + : A -> A -> A
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record RightRingoidSig
      (AS : Set) : Set where
      constructor RightRingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record RightRingoidProd
      (AP : Set) : Set where
      constructor RightRingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record RightRingoidHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightRingoid A1)
      (Ri2 : RightRingoid A2) :
      Set where
      constructor RightRingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
    record RightRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightRingoid A1)
      (Ri2 : RightRingoid A2) :
      Set where
      constructor RightRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
    data RightRingoidLang
      : Set where
      *L :
        RightRingoidLang ->
        RightRingoidLang ->
        RightRingoidLang
      +L :
        RightRingoidLang ->
        RightRingoidLang ->
        RightRingoidLang
    data RightRingoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> RightRingoidOpenLang n
      *OL :
        RightRingoidOpenLang n ->
        RightRingoidOpenLang n ->
        RightRingoidOpenLang n
      +OL :
        RightRingoidOpenLang n ->
        RightRingoidOpenLang n ->
        RightRingoidOpenLang n
    evalTerm :
      (A : Set) ->
      RightRingoid A ->
      RightRingoidLang -> A
    evalTerm _ Ri (*L x1 x2) =
      * Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (+L x1 x2) =
      + Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightRingoid A ->
      RightRingoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (*OL
                         x1
                         x2) vars =
      * ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (+OL
                         x1
                         x2) vars =
      + ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RightRingoidLang ->
      RightRingoidLang
    simplify (+L
              (*L y x)
              (*L z x)) = *L (+L y z) x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftRightRingoidLang :
      RightRingoidLang ->
      Staged RightRingoidLang
    liftRightRingoidLang x = Now x
    *OL' :
      (n : Nat) ->
      RightRingoidOpenLang n ->
      RightRingoidOpenLang n ->
      RightRingoidOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      RightRingoidOpenLang n ->
      RightRingoidOpenLang n ->
      RightRingoidOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftRightRingoidOpenLang :
      (n : Nat) ->
      RightRingoidOpenLang n ->
      Staged (RightRingoidOpenLang n)
    liftRightRingoidOpenLang _ (v
                                fin) = const _ (code _ (v fin))
    liftRightRingoidOpenLang _ (*OL
                                x1
                                x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftRightRingoidOpenLang _ x1)
        (liftRightRingoidOpenLang _ x2)
    liftRightRingoidOpenLang _ (+OL
                                x1
                                x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftRightRingoidOpenLang _ x1)
        (liftRightRingoidOpenLang _ x2)
  
  module RightSelfInverse where
    record RightSelfInverse
      (A : Set) : Set where
      constructor RightSelfInverseC
      field
        |> : A -> A -> A
        rightSelfInverse_|> :
          (x : A) (y : A) ->
          |> (|> x y) y == x
    record RightSelfInverseSig
      (AS : Set) : Set where
      constructor RightSelfInverseSigSigC
      field
        |>S : AS -> AS -> AS
    record RightSelfInverseProd
      (AP : Set) : Set where
      constructor RightSelfInverseProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightSelfInverse_|>P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          |>P (|>P xP yP) yP == xP
    record RightSelfInverseHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSelfInverse A1)
      (Ri2 : RightSelfInverse A2) :
      Set where
      constructor RightSelfInverseHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ri1 x1 x2) ==
            |> Ri2 (hom x1) (hom x2)
    record RightSelfInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSelfInverse A1)
      (Ri2 : RightSelfInverse A2) :
      Set where
      constructor RightSelfInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ri1 x1 x2)
            (|> Ri2 y1 y2)
    data RightSelfInverseLang
      : Set where
      |>L :
        RightSelfInverseLang ->
        RightSelfInverseLang ->
        RightSelfInverseLang
    data RightSelfInverseOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RightSelfInverseOpenLang n
      |>OL :
        RightSelfInverseOpenLang n ->
        RightSelfInverseOpenLang n ->
        RightSelfInverseOpenLang n
    evalTerm :
      (A : Set) ->
      RightSelfInverse A ->
      RightSelfInverseLang -> A
    evalTerm _ Ri (|>L x1 x2) =
      |> Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightSelfInverse A ->
      RightSelfInverseOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (|>OL
                         x1
                         x2) vars =
      |> ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RightSelfInverseLang ->
      RightSelfInverseLang
    simplify (|>L (|>L x y) y) = x
    simplify (|>L x1 x2) =
      |>L (simplify x1) (simplify x2)
    liftRightSelfInverseLang :
      RightSelfInverseLang ->
      Staged RightSelfInverseLang
    liftRightSelfInverseLang x =
      Now x
    |>OL' :
      (n : Nat) ->
      RightSelfInverseOpenLang n ->
      RightSelfInverseOpenLang n ->
      RightSelfInverseOpenLang n
    |>OL' _ x1 x2 = |>OL x1 x2
    liftRightSelfInverseOpenLang :
      (n : Nat) ->
      RightSelfInverseOpenLang n ->
      Staged
        (RightSelfInverseOpenLang n)
    liftRightSelfInverseOpenLang _ (v
                                    fin) = const _ (code _ (v fin))
    liftRightSelfInverseOpenLang _ (|>OL
                                    x1
                                    x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (liftRightSelfInverseOpenLang _
           x1)
        (liftRightSelfInverseOpenLang _
           x2)
  
  module RightShelf where
    record RightShelf
      (A : Set) : Set where
      constructor RightShelfC
      field
        <| : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
    record RightShelfSig
      (AS : Set) : Set where
      constructor RightShelfSigSigC
      field
        <|S : AS -> AS -> AS
    record RightShelfProd
      (AP : Set) : Set where
      constructor RightShelfProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
    record RightShelfHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightShelf A1)
      (Ri2 : RightShelf A2) :
      Set where
      constructor RightShelfHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
    record RightShelfRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightShelf A1)
      (Ri2 : RightShelf A2) :
      Set where
      constructor RightShelfRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
    data RightShelfLang : Set where
      <|L :
        RightShelfLang ->
        RightShelfLang -> RightShelfLang
    data RightShelfOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> RightShelfOpenLang n
      <|OL :
        RightShelfOpenLang n ->
        RightShelfOpenLang n ->
        RightShelfOpenLang n
    evalTerm :
      (A : Set) ->
      RightShelf A ->
      RightShelfLang -> A
    evalTerm _ Ri (<|L x1 x2) =
      <| Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightShelf A ->
      RightShelfOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (<|OL
                         x1
                         x2) vars =
      <| ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RightShelfLang -> RightShelfLang
    simplify (<|L
              (<|L y x)
              (<|L z x)) = <|L (<|L y z) x
    simplify (<|L x1 x2) =
      <|L (simplify x1) (simplify x2)
    liftRightShelfLang :
      RightShelfLang ->
      Staged RightShelfLang
    liftRightShelfLang x = Now x
    <|OL' :
      (n : Nat) ->
      RightShelfOpenLang n ->
      RightShelfOpenLang n ->
      RightShelfOpenLang n
    <|OL' _ x1 x2 = <|OL x1 x2
    liftRightShelfOpenLang :
      (n : Nat) ->
      RightShelfOpenLang n ->
      Staged (RightShelfOpenLang n)
    liftRightShelfOpenLang _ (v
                              fin) = const _ (code _ (v fin))
    liftRightShelfOpenLang _ (<|OL
                              x1
                              x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (liftRightShelfOpenLang _ x1)
        (liftRightShelfOpenLang _ x2)
  
  module RightShelfSig where
    record RightShelfSig
      (A : Set) : Set where
      constructor RightShelfSigC
      field
        <| : A -> A -> A
    record RightShelfSigSig
      (AS : Set) : Set where
      constructor RightShelfSigSigSigC
      field
        <|S : AS -> AS -> AS
    record RightShelfSigProd
      (AP : Set) : Set where
      constructor RightShelfSigProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record RightShelfSigHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightShelfSig A1)
      (Ri2 : RightShelfSig A2) :
      Set where
      constructor RightShelfSigHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
    record RightShelfSigRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightShelfSig A1)
      (Ri2 : RightShelfSig A2) :
      Set where
      constructor RightShelfSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
    data RightShelfSigLang
      : Set where
      <|L :
        RightShelfSigLang ->
        RightShelfSigLang ->
        RightShelfSigLang
    data RightShelfSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> RightShelfSigOpenLang n
      <|OL :
        RightShelfSigOpenLang n ->
        RightShelfSigOpenLang n ->
        RightShelfSigOpenLang n
    evalTerm :
      (A : Set) ->
      RightShelfSig A ->
      RightShelfSigLang -> A
    evalTerm _ Ri (<|L x1 x2) =
      <| Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightShelfSig A ->
      RightShelfSigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (<|OL
                         x1
                         x2) vars =
      <| ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RightShelfSigLang ->
      RightShelfSigLang
    simplify (<|L x1 x2) =
      <|L (simplify x1) (simplify x2)
    liftRightShelfSigLang :
      RightShelfSigLang ->
      Staged RightShelfSigLang
    liftRightShelfSigLang x = Now x
    <|OL' :
      (n : Nat) ->
      RightShelfSigOpenLang n ->
      RightShelfSigOpenLang n ->
      RightShelfSigOpenLang n
    <|OL' _ x1 x2 = <|OL x1 x2
    liftRightShelfSigOpenLang :
      (n : Nat) ->
      RightShelfSigOpenLang n ->
      Staged (RightShelfSigOpenLang n)
    liftRightShelfSigOpenLang _ (v
                                 fin) = const _ (code _ (v fin))
    liftRightShelfSigOpenLang _ (<|OL
                                 x1
                                 x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (liftRightShelfSigOpenLang _ x1)
        (liftRightShelfSigOpenLang _ x2)
  
  module RightSpindle where
    record RightSpindle
      (A : Set) : Set where
      constructor RightSpindleC
      field
        <| : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
        idempotent_<| :
          (x : A) -> <| x x == x
    record RightSpindleSig
      (AS : Set) : Set where
      constructor RightSpindleSigSigC
      field
        <|S : AS -> AS -> AS
    record RightSpindleProd
      (AP : Set) : Set where
      constructor RightSpindleProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
        idempotent_<|P :
          (xP : Prod AP AP) ->
          <|P xP xP == xP
    record RightSpindleHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSpindle A1)
      (Ri2 : RightSpindle A2) :
      Set where
      constructor RightSpindleHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
    record RightSpindleRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSpindle A1)
      (Ri2 : RightSpindle A2) :
      Set where
      constructor RightSpindleRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
    data RightSpindleLang
      : Set where
      <|L :
        RightSpindleLang ->
        RightSpindleLang ->
        RightSpindleLang
    data RightSpindleOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> RightSpindleOpenLang n
      <|OL :
        RightSpindleOpenLang n ->
        RightSpindleOpenLang n ->
        RightSpindleOpenLang n
    evalTerm :
      (A : Set) ->
      RightSpindle A ->
      RightSpindleLang -> A
    evalTerm _ Ri (<|L x1 x2) =
      <| Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightSpindle A ->
      RightSpindleOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (<|OL
                         x1
                         x2) vars =
      <| ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RightSpindleLang ->
      RightSpindleLang
    simplify (<|L
              (<|L y x)
              (<|L z x)) = <|L (<|L y z) x
    simplify (<|L x x) = x
    simplify (<|L x1 x2) =
      <|L (simplify x1) (simplify x2)
    liftRightSpindleLang :
      RightSpindleLang ->
      Staged RightSpindleLang
    liftRightSpindleLang x = Now x
    <|OL' :
      (n : Nat) ->
      RightSpindleOpenLang n ->
      RightSpindleOpenLang n ->
      RightSpindleOpenLang n
    <|OL' _ x1 x2 = <|OL x1 x2
    liftRightSpindleOpenLang :
      (n : Nat) ->
      RightSpindleOpenLang n ->
      Staged (RightSpindleOpenLang n)
    liftRightSpindleOpenLang _ (v
                                fin) = const _ (code _ (v fin))
    liftRightSpindleOpenLang _ (<|OL
                                x1
                                x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (liftRightSpindleOpenLang _ x1)
        (liftRightSpindleOpenLang _ x2)
  
  module RightSpindle_Shelf where
    record RightSpindle_Shelf
      (A : Set) : Set where
      constructor RightSpindle_ShelfC
      field
        <| : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
        idempotent_<| :
          (x : A) -> <| x x == x
        |> : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
    record RightSpindle_ShelfSig
      (AS : Set) : Set where
      constructor RightSpindle_ShelfSigSigC
      field
        <|S : AS -> AS -> AS
        |>S : AS -> AS -> AS
    record RightSpindle_ShelfProd
      (AP : Set) : Set where
      constructor RightSpindle_ShelfProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
        idempotent_<|P :
          (xP : Prod AP AP) ->
          <|P xP xP == xP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
    record RightSpindle_ShelfHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSpindle_Shelf A1)
      (Ri2 : RightSpindle_Shelf A2) :
      Set where
      constructor RightSpindle_ShelfHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ri1 x1 x2) ==
            |> Ri2 (hom x1) (hom x2)
    record RightSpindle_ShelfRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSpindle_Shelf A1)
      (Ri2 : RightSpindle_Shelf A2) :
      Set where
      constructor RightSpindle_ShelfRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ri1 x1 x2)
            (|> Ri2 y1 y2)
    data RightSpindle_ShelfLang
      : Set where
      <|L :
        RightSpindle_ShelfLang ->
        RightSpindle_ShelfLang ->
        RightSpindle_ShelfLang
      |>L :
        RightSpindle_ShelfLang ->
        RightSpindle_ShelfLang ->
        RightSpindle_ShelfLang
    data RightSpindle_ShelfOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RightSpindle_ShelfOpenLang n
      <|OL :
        RightSpindle_ShelfOpenLang n ->
        RightSpindle_ShelfOpenLang n ->
        RightSpindle_ShelfOpenLang n
      |>OL :
        RightSpindle_ShelfOpenLang n ->
        RightSpindle_ShelfOpenLang n ->
        RightSpindle_ShelfOpenLang n
    evalTerm :
      (A : Set) ->
      RightSpindle_Shelf A ->
      RightSpindle_ShelfLang -> A
    evalTerm _ Ri (<|L x1 x2) =
      <| Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (|>L x1 x2) =
      |> Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightSpindle_Shelf A ->
      RightSpindle_ShelfOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (<|OL
                         x1
                         x2) vars =
      <| ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (|>OL
                         x1
                         x2) vars =
      |> ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RightSpindle_ShelfLang ->
      RightSpindle_ShelfLang
    simplify (<|L
              (<|L y x)
              (<|L z x)) = <|L (<|L y z) x
    simplify (<|L x x) = x
    simplify (|>L
              (|>L x y)
              (|>L x z)) = |>L x (|>L y z)
    simplify (<|L x1 x2) =
      <|L (simplify x1) (simplify x2)
    simplify (|>L x1 x2) =
      |>L (simplify x1) (simplify x2)
    liftRightSpindle_ShelfLang :
      RightSpindle_ShelfLang ->
      Staged RightSpindle_ShelfLang
    liftRightSpindle_ShelfLang x =
      Now x
    <|OL' :
      (n : Nat) ->
      RightSpindle_ShelfOpenLang n ->
      RightSpindle_ShelfOpenLang n ->
      RightSpindle_ShelfOpenLang n
    <|OL' _ x1 x2 = <|OL x1 x2
    |>OL' :
      (n : Nat) ->
      RightSpindle_ShelfOpenLang n ->
      RightSpindle_ShelfOpenLang n ->
      RightSpindle_ShelfOpenLang n
    |>OL' _ x1 x2 = |>OL x1 x2
    liftRightSpindle_ShelfOpenLang :
      (n : Nat) ->
      RightSpindle_ShelfOpenLang n ->
      Staged
        (RightSpindle_ShelfOpenLang n)
    liftRightSpindle_ShelfOpenLang _ (v
                                      fin) = const _ (code _ (v fin))
    liftRightSpindle_ShelfOpenLang _ (<|OL
                                      x1
                                      x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (liftRightSpindle_ShelfOpenLang
           _
           x1)
        (liftRightSpindle_ShelfOpenLang
           _
           x2)
    liftRightSpindle_ShelfOpenLang _ (|>OL
                                      x1
                                      x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (liftRightSpindle_ShelfOpenLang
           _
           x1)
        (liftRightSpindle_ShelfOpenLang
           _
           x2)
  
  module RightSpindle_ShelfSig where
    record RightSpindle_ShelfSig
      (A : Set) : Set where
      constructor RightSpindle_ShelfSigC
      field
        <| : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
        idempotent_<| :
          (x : A) -> <| x x == x
        |> : A -> A -> A
    record RightSpindle_ShelfSigSig
      (AS : Set) : Set where
      constructor RightSpindle_ShelfSigSigSigC
      field
        <|S : AS -> AS -> AS
        |>S : AS -> AS -> AS
    record RightSpindle_ShelfSigProd
      (AP : Set) : Set where
      constructor RightSpindle_ShelfSigProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
        idempotent_<|P :
          (xP : Prod AP AP) ->
          <|P xP xP == xP
    record RightSpindle_ShelfSigHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSpindle_ShelfSig A1)
      (Ri2 : RightSpindle_ShelfSig
         A2) : Set where
      constructor RightSpindle_ShelfSigHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ri1 x1 x2) ==
            |> Ri2 (hom x1) (hom x2)
    record RightSpindle_ShelfSigRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSpindle_ShelfSig A1)
      (Ri2 : RightSpindle_ShelfSig
         A2) : Set where
      constructor RightSpindle_ShelfSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ri1 x1 x2)
            (|> Ri2 y1 y2)
    data RightSpindle_ShelfSigLang
      : Set where
      <|L :
        RightSpindle_ShelfSigLang ->
        RightSpindle_ShelfSigLang ->
        RightSpindle_ShelfSigLang
      |>L :
        RightSpindle_ShelfSigLang ->
        RightSpindle_ShelfSigLang ->
        RightSpindle_ShelfSigLang
    data RightSpindle_ShelfSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RightSpindle_ShelfSigOpenLang n
      <|OL :
        RightSpindle_ShelfSigOpenLang
          n ->
        RightSpindle_ShelfSigOpenLang
          n ->
        RightSpindle_ShelfSigOpenLang n
      |>OL :
        RightSpindle_ShelfSigOpenLang
          n ->
        RightSpindle_ShelfSigOpenLang
          n ->
        RightSpindle_ShelfSigOpenLang n
    evalTerm :
      (A : Set) ->
      RightSpindle_ShelfSig A ->
      RightSpindle_ShelfSigLang -> A
    evalTerm _ Ri (<|L x1 x2) =
      <| Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (|>L x1 x2) =
      |> Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightSpindle_ShelfSig A ->
      RightSpindle_ShelfSigOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (<|OL
                         x1
                         x2) vars =
      <| ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (|>OL
                         x1
                         x2) vars =
      |> ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RightSpindle_ShelfSigLang ->
      RightSpindle_ShelfSigLang
    simplify (<|L
              (<|L y x)
              (<|L z x)) = <|L (<|L y z) x
    simplify (<|L x x) = x
    simplify (<|L x1 x2) =
      <|L (simplify x1) (simplify x2)
    simplify (|>L x1 x2) =
      |>L (simplify x1) (simplify x2)
    liftRightSpindle_ShelfSigLang :
      RightSpindle_ShelfSigLang ->
      Staged RightSpindle_ShelfSigLang
    liftRightSpindle_ShelfSigLang x =
      Now x
    <|OL' :
      (n : Nat) ->
      RightSpindle_ShelfSigOpenLang
        n ->
      RightSpindle_ShelfSigOpenLang
        n ->
      RightSpindle_ShelfSigOpenLang n
    <|OL' _ x1 x2 = <|OL x1 x2
    |>OL' :
      (n : Nat) ->
      RightSpindle_ShelfSigOpenLang
        n ->
      RightSpindle_ShelfSigOpenLang
        n ->
      RightSpindle_ShelfSigOpenLang n
    |>OL' _ x1 x2 = |>OL x1 x2
    liftRightSpindle_ShelfSigOpenLang :
      (n : Nat) ->
      RightSpindle_ShelfSigOpenLang
        n ->
      Staged
        (RightSpindle_ShelfSigOpenLang
           n)
    liftRightSpindle_ShelfSigOpenLang _ (v
                                         fin) = const _ (code _ (v fin))
    liftRightSpindle_ShelfSigOpenLang _ (<|OL
                                         x1
                                         x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (liftRightSpindle_ShelfSigOpenLang
           _
           x1)
        (liftRightSpindle_ShelfSigOpenLang
           _
           x2)
    liftRightSpindle_ShelfSigOpenLang _ (|>OL
                                         x1
                                         x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (liftRightSpindle_ShelfSigOpenLang
           _
           x1)
        (liftRightSpindle_ShelfSigOpenLang
           _
           x2)
  
  module RightUnital where
    record RightUnital
      (A : Set) : Set where
      constructor RightUnitalC
      field
        e : A
        op : A -> A -> A
        runit_e : (x : A) -> op x e == x
    record RightUnitalSig
      (AS : Set) : Set where
      constructor RightUnitalSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record RightUnitalProd
      (AP : Set) : Set where
      constructor RightUnitalProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
    record RightUnitalHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightUnital A1)
      (Ri2 : RightUnital A2) :
      Set where
      constructor RightUnitalHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Ri1) == e Ri2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record RightUnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightUnital A1)
      (Ri2 : RightUnital A2) :
      Set where
      constructor RightUnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Ri1) (e Ri2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data RightUnitalLang : Set where
      eL : RightUnitalLang
      opL :
        RightUnitalLang ->
        RightUnitalLang ->
        RightUnitalLang
    data RightUnitalOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> RightUnitalOpenLang n
      eOL : RightUnitalOpenLang n
      opOL :
        RightUnitalOpenLang n ->
        RightUnitalOpenLang n ->
        RightUnitalOpenLang n
    evalTerm :
      (A : Set) ->
      RightUnital A ->
      RightUnitalLang -> A
    evalTerm _ Ri (eL) = e Ri
    evalTerm _ Ri (opL x1 x2) =
      op Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightUnital A ->
      RightUnitalOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (eOL) vars =
      e ri
    evalOpenTerm _ n ri (opOL
                         x1
                         x2) vars =
      op ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RightUnitalLang ->
      RightUnitalLang
    simplify (opL x (eL)) = x
    simplify (eL) = eL
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftRightUnitalLang :
      RightUnitalLang ->
      Staged RightUnitalLang
    liftRightUnitalLang x = Now x
    eOL' :
      (n : Nat) ->
      RightUnitalOpenLang n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      RightUnitalOpenLang n ->
      RightUnitalOpenLang n ->
      RightUnitalOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftRightUnitalOpenLang :
      (n : Nat) ->
      RightUnitalOpenLang n ->
      Staged (RightUnitalOpenLang n)
    liftRightUnitalOpenLang _ (v
                               fin) = const _ (code _ (v fin))
    liftRightUnitalOpenLang _ (eOL) =
      Now eOL
    liftRightUnitalOpenLang _ (opOL
                               x1
                               x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftRightUnitalOpenLang _ x1)
        (liftRightUnitalOpenLang _ x2)
  
  module RightZero where
    record RightZero
      (A : Set) : Set where
      constructor RightZeroC
      field
        e : A
        op : A -> A -> A
        rightZero_op_e :
          (x : A) -> op x e == e
    record RightZeroSig
      (AS : Set) : Set where
      constructor RightZeroSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record RightZeroProd
      (AP : Set) : Set where
      constructor RightZeroProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightZero_op_eP :
          (xP : Prod AP AP) ->
          opP xP eP == eP
    record RightZeroHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightZero A1)
      (Ri2 : RightZero A2) : Set where
      constructor RightZeroHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Ri1) == e Ri2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record RightZeroRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightZero A1)
      (Ri2 : RightZero A2) : Set where
      constructor RightZeroRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Ri1) (e Ri2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data RightZeroLang : Set where
      eL : RightZeroLang
      opL :
        RightZeroLang ->
        RightZeroLang -> RightZeroLang
    data RightZeroOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> RightZeroOpenLang n
      eOL : RightZeroOpenLang n
      opOL :
        RightZeroOpenLang n ->
        RightZeroOpenLang n ->
        RightZeroOpenLang n
    evalTerm :
      (A : Set) ->
      RightZero A ->
      RightZeroLang -> A
    evalTerm _ Ri (eL) = e Ri
    evalTerm _ Ri (opL x1 x2) =
      op Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightZero A ->
      RightZeroOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (eOL) vars =
      e ri
    evalOpenTerm _ n ri (opOL
                         x1
                         x2) vars =
      op ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RightZeroLang -> RightZeroLang
    simplify (opL x (eL)) = eL
    simplify (eL) = eL
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftRightZeroLang :
      RightZeroLang ->
      Staged RightZeroLang
    liftRightZeroLang x = Now x
    eOL' :
      (n : Nat) -> RightZeroOpenLang n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      RightZeroOpenLang n ->
      RightZeroOpenLang n ->
      RightZeroOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftRightZeroOpenLang :
      (n : Nat) ->
      RightZeroOpenLang n ->
      Staged (RightZeroOpenLang n)
    liftRightZeroOpenLang _ (v
                             fin) = const _ (code _ (v fin))
    liftRightZeroOpenLang _ (eOL) =
      Now eOL
    liftRightZeroOpenLang _ (opOL
                             x1
                             x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftRightZeroOpenLang _ x1)
        (liftRightZeroOpenLang _ x2)
  
  module Ring where
    record Ring
      (A : Set) : Set where
      constructor RingC
      field
        * : A -> A -> A
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
    record RingSig
      (AS : Set) : Set where
      constructor RingSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
        1S : AS
    record RingProd
      (AP : Set) : Set where
      constructor RingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
    record RingHom
      (A1 : Set) (A2 : Set)
      (Ri1 : Ring A1)
      (Ri2 : Ring A2) : Set where
      constructor RingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
        pres-0 : hom (0 Ri1) == 0 Ri2
        pres-neg :
          (x1 : A1) ->
          hom (neg Ri1 x1) ==
            neg Ri2 (hom x1)
        pres-1 : hom (1 Ri1) == 1 Ri2
    record RingRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Ring A1)
      (Ri2 : Ring A2) : Set where
      constructor RingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
        interp-0 :
          interp (0 Ri1) (0 Ri2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Ri1 x1) (neg Ri2 y1)
        interp-1 :
          interp (1 Ri1) (1 Ri2)
    data RingLang : Set where
      *L :
        RingLang -> RingLang -> RingLang
      +L :
        RingLang -> RingLang -> RingLang
      0L : RingLang
      negL : RingLang -> RingLang
      1L : RingLang
    data RingOpenLang
      (n : Nat) : Set where
      v : Fin n -> RingOpenLang n
      *OL :
        RingOpenLang n ->
        RingOpenLang n -> RingOpenLang n
      +OL :
        RingOpenLang n ->
        RingOpenLang n -> RingOpenLang n
      0OL : RingOpenLang n
      negOL :
        RingOpenLang n -> RingOpenLang n
      1OL : RingOpenLang n
    evalTerm :
      (A : Set) ->
      Ring A -> RingLang -> A
    evalTerm _ Ri (*L x1 x2) =
      * Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (+L x1 x2) =
      + Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (0L) = 0 Ri
    evalTerm _ Ri (negL x1) =
      neg Ri (evalTerm _ Ri x1)
    evalTerm _ Ri (1L) = 1 Ri
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Ring A ->
      RingOpenLang n -> Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (*OL
                         x1
                         x2) vars =
      * ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (+OL
                         x1
                         x2) vars =
      + ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (0OL) vars =
      0 ri
    evalOpenTerm _ n ri (negOL
                         x1) vars =
      neg ri
        (evalOpenTerm _ n ri x1 vars)
    evalOpenTerm _ n ri (1OL) vars =
      1 ri
    simplify : RingLang -> RingLang
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (+L
              (*L x y)
              (*L x z)) = *L x (+L y z)
    simplify (+L
              (*L y x)
              (*L z x)) = *L (+L y z) x
    simplify (+L x (negL x)) = 0L
    simplify (+L (negL x) x) = 0L
    simplify (*L (1L) x) = x
    simplify (*L x (1L)) = x
    simplify (*L (0L) x) = 0L
    simplify (*L x (0L)) = 0L
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (0L) = 0L
    simplify (negL x1) =
      negL (simplify x1)
    simplify (1L) = 1L
    liftRingLang :
      RingLang -> Staged RingLang
    liftRingLang x = Now x
    *OL' :
      (n : Nat) ->
      RingOpenLang n ->
      RingOpenLang n -> RingOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      RingOpenLang n ->
      RingOpenLang n -> RingOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) -> RingOpenLang n
    0OL' _ = 0OL
    negOL' :
      (n : Nat) ->
      RingOpenLang n -> RingOpenLang n
    negOL' _ x1 = negOL x1
    1OL' :
      (n : Nat) -> RingOpenLang n
    1OL' _ = 1OL
    liftRingOpenLang :
      (n : Nat) ->
      RingOpenLang n ->
      Staged (RingOpenLang n)
    liftRingOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftRingOpenLang _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftRingOpenLang _ x1)
        (liftRingOpenLang _ x2)
    liftRingOpenLang _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftRingOpenLang _ x1)
        (liftRingOpenLang _ x2)
    liftRingOpenLang _ (0OL) =
      Now 0OL
    liftRingOpenLang _ (negOL x1) =
      stage1 _ _ (negOL' _)
        (codeLift1 _ _ (negOL' _))
        (liftRingOpenLang _ x1)
    liftRingOpenLang _ (1OL) =
      Now 1OL
  
  module Ringoid where
    record Ringoid
      (A : Set) : Set where
      constructor RingoidC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record RingoidSig
      (AS : Set) : Set where
      constructor RingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record RingoidProd
      (AP : Set) : Set where
      constructor RingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record RingoidHom
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid A1)
      (Ri2 : Ringoid A2) : Set where
      constructor RingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
    record RingoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid A1)
      (Ri2 : Ringoid A2) : Set where
      constructor RingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
    data RingoidLang : Set where
      *L :
        RingoidLang ->
        RingoidLang -> RingoidLang
      +L :
        RingoidLang ->
        RingoidLang -> RingoidLang
    data RingoidOpenLang
      (n : Nat) : Set where
      v : Fin n -> RingoidOpenLang n
      *OL :
        RingoidOpenLang n ->
        RingoidOpenLang n ->
        RingoidOpenLang n
      +OL :
        RingoidOpenLang n ->
        RingoidOpenLang n ->
        RingoidOpenLang n
    evalTerm :
      (A : Set) ->
      Ringoid A -> RingoidLang -> A
    evalTerm _ Ri (*L x1 x2) =
      * Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (+L x1 x2) =
      + Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Ringoid A ->
      RingoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (*OL
                         x1
                         x2) vars =
      * ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (+OL
                         x1
                         x2) vars =
      + ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RingoidLang -> RingoidLang
    simplify (+L
              (*L x y)
              (*L x z)) = *L x (+L y z)
    simplify (+L
              (*L y x)
              (*L z x)) = *L (+L y z) x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftRingoidLang :
      RingoidLang ->
      Staged RingoidLang
    liftRingoidLang x = Now x
    *OL' :
      (n : Nat) ->
      RingoidOpenLang n ->
      RingoidOpenLang n ->
      RingoidOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      RingoidOpenLang n ->
      RingoidOpenLang n ->
      RingoidOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftRingoidOpenLang :
      (n : Nat) ->
      RingoidOpenLang n ->
      Staged (RingoidOpenLang n)
    liftRingoidOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftRingoidOpenLang _ (*OL
                           x1
                           x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftRingoidOpenLang _ x1)
        (liftRingoidOpenLang _ x2)
    liftRingoidOpenLang _ (+OL
                           x1
                           x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftRingoidOpenLang _ x1)
        (liftRingoidOpenLang _ x2)
  
  module Ringoid01Sig where
    record Ringoid01Sig
      (A : Set) : Set where
      constructor Ringoid01SigC
      field
        * : A -> A -> A
        + : A -> A -> A
        0 : A
        1 : A
    record Ringoid01SigSig
      (AS : Set) : Set where
      constructor Ringoid01SigSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        1S : AS
    record Ringoid01SigProd
      (AP : Set) : Set where
      constructor Ringoid01SigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        1P : Prod AP AP
    record Ringoid01SigHom
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid01Sig A1)
      (Ri2 : Ringoid01Sig A2) :
      Set where
      constructor Ringoid01SigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
        pres-0 : hom (0 Ri1) == 0 Ri2
        pres-1 : hom (1 Ri1) == 1 Ri2
    record Ringoid01SigRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid01Sig A1)
      (Ri2 : Ringoid01Sig A2) :
      Set where
      constructor Ringoid01SigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
        interp-0 :
          interp (0 Ri1) (0 Ri2)
        interp-1 :
          interp (1 Ri1) (1 Ri2)
    data Ringoid01SigLang
      : Set where
      *L :
        Ringoid01SigLang ->
        Ringoid01SigLang ->
        Ringoid01SigLang
      +L :
        Ringoid01SigLang ->
        Ringoid01SigLang ->
        Ringoid01SigLang
      0L : Ringoid01SigLang
      1L : Ringoid01SigLang
    data Ringoid01SigOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> Ringoid01SigOpenLang n
      *OL :
        Ringoid01SigOpenLang n ->
        Ringoid01SigOpenLang n ->
        Ringoid01SigOpenLang n
      +OL :
        Ringoid01SigOpenLang n ->
        Ringoid01SigOpenLang n ->
        Ringoid01SigOpenLang n
      0OL : Ringoid01SigOpenLang n
      1OL : Ringoid01SigOpenLang n
    evalTerm :
      (A : Set) ->
      Ringoid01Sig A ->
      Ringoid01SigLang -> A
    evalTerm _ Ri (*L x1 x2) =
      * Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (+L x1 x2) =
      + Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (0L) = 0 Ri
    evalTerm _ Ri (1L) = 1 Ri
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Ringoid01Sig A ->
      Ringoid01SigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (*OL
                         x1
                         x2) vars =
      * ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (+OL
                         x1
                         x2) vars =
      + ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (0OL) vars =
      0 ri
    evalOpenTerm _ n ri (1OL) vars =
      1 ri
    simplify :
      Ringoid01SigLang ->
      Ringoid01SigLang
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (0L) = 0L
    simplify (1L) = 1L
    liftRingoid01SigLang :
      Ringoid01SigLang ->
      Staged Ringoid01SigLang
    liftRingoid01SigLang x = Now x
    *OL' :
      (n : Nat) ->
      Ringoid01SigOpenLang n ->
      Ringoid01SigOpenLang n ->
      Ringoid01SigOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      Ringoid01SigOpenLang n ->
      Ringoid01SigOpenLang n ->
      Ringoid01SigOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      Ringoid01SigOpenLang n
    0OL' _ = 0OL
    1OL' :
      (n : Nat) ->
      Ringoid01SigOpenLang n
    1OL' _ = 1OL
    liftRingoid01SigOpenLang :
      (n : Nat) ->
      Ringoid01SigOpenLang n ->
      Staged (Ringoid01SigOpenLang n)
    liftRingoid01SigOpenLang _ (v
                                fin) = const _ (code _ (v fin))
    liftRingoid01SigOpenLang _ (*OL
                                x1
                                x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftRingoid01SigOpenLang _ x1)
        (liftRingoid01SigOpenLang _ x2)
    liftRingoid01SigOpenLang _ (+OL
                                x1
                                x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftRingoid01SigOpenLang _ x1)
        (liftRingoid01SigOpenLang _ x2)
    liftRingoid01SigOpenLang _ (0OL) =
      Now 0OL
    liftRingoid01SigOpenLang _ (1OL) =
      Now 1OL
  
  module Ringoid0Sig where
    record Ringoid0Sig
      (A : Set) : Set where
      constructor Ringoid0SigC
      field
        0 : A
        + : A -> A -> A
        * : A -> A -> A
    record Ringoid0SigSig
      (AS : Set) : Set where
      constructor Ringoid0SigSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
    record Ringoid0SigProd
      (AP : Set) : Set where
      constructor Ringoid0SigProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record Ringoid0SigHom
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid0Sig A1)
      (Ri2 : Ringoid0Sig A2) :
      Set where
      constructor Ringoid0SigHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ri1) == 0 Ri2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
    record Ringoid0SigRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid0Sig A1)
      (Ri2 : Ringoid0Sig A2) :
      Set where
      constructor Ringoid0SigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ri1) (0 Ri2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
    data Ringoid0SigLang : Set where
      0L : Ringoid0SigLang
      +L :
        Ringoid0SigLang ->
        Ringoid0SigLang ->
        Ringoid0SigLang
      *L :
        Ringoid0SigLang ->
        Ringoid0SigLang ->
        Ringoid0SigLang
    data Ringoid0SigOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> Ringoid0SigOpenLang n
      0OL : Ringoid0SigOpenLang n
      +OL :
        Ringoid0SigOpenLang n ->
        Ringoid0SigOpenLang n ->
        Ringoid0SigOpenLang n
      *OL :
        Ringoid0SigOpenLang n ->
        Ringoid0SigOpenLang n ->
        Ringoid0SigOpenLang n
    evalTerm :
      (A : Set) ->
      Ringoid0Sig A ->
      Ringoid0SigLang -> A
    evalTerm _ Ri (0L) = 0 Ri
    evalTerm _ Ri (+L x1 x2) =
      + Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (*L x1 x2) =
      * Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Ringoid0Sig A ->
      Ringoid0SigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (0OL) vars =
      0 ri
    evalOpenTerm _ n ri (+OL
                         x1
                         x2) vars =
      + ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (*OL
                         x1
                         x2) vars =
      * ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      Ringoid0SigLang ->
      Ringoid0SigLang
    simplify (0L) = 0L
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    liftRingoid0SigLang :
      Ringoid0SigLang ->
      Staged Ringoid0SigLang
    liftRingoid0SigLang x = Now x
    0OL' :
      (n : Nat) ->
      Ringoid0SigOpenLang n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      Ringoid0SigOpenLang n ->
      Ringoid0SigOpenLang n ->
      Ringoid0SigOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    *OL' :
      (n : Nat) ->
      Ringoid0SigOpenLang n ->
      Ringoid0SigOpenLang n ->
      Ringoid0SigOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    liftRingoid0SigOpenLang :
      (n : Nat) ->
      Ringoid0SigOpenLang n ->
      Staged (Ringoid0SigOpenLang n)
    liftRingoid0SigOpenLang _ (v
                               fin) = const _ (code _ (v fin))
    liftRingoid0SigOpenLang _ (0OL) =
      Now 0OL
    liftRingoid0SigOpenLang _ (+OL
                               x1
                               x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftRingoid0SigOpenLang _ x1)
        (liftRingoid0SigOpenLang _ x2)
    liftRingoid0SigOpenLang _ (*OL
                               x1
                               x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftRingoid0SigOpenLang _ x1)
        (liftRingoid0SigOpenLang _ x2)
  
  module Ringoid1 where
    record Ringoid1
      (A : Set) : Set where
      constructor Ringoid1C
      field
        * : A -> A -> A
        + : A -> A -> A
        1 : A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record Ringoid1Sig
      (AS : Set) : Set where
      constructor Ringoid1SigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        1S : AS
    record Ringoid1Prod
      (AP : Set) : Set where
      constructor Ringoid1ProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record Ringoid1Hom
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid1 A1)
      (Ri2 : Ringoid1 A2) : Set where
      constructor Ringoid1HomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
        pres-1 : hom (1 Ri1) == 1 Ri2
    record Ringoid1RelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid1 A1)
      (Ri2 : Ringoid1 A2) : Set where
      constructor Ringoid1RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
        interp-1 :
          interp (1 Ri1) (1 Ri2)
    data Ringoid1Lang : Set where
      *L :
        Ringoid1Lang ->
        Ringoid1Lang -> Ringoid1Lang
      +L :
        Ringoid1Lang ->
        Ringoid1Lang -> Ringoid1Lang
      1L : Ringoid1Lang
    data Ringoid1OpenLang
      (n : Nat) : Set where
      v :
        Fin n -> Ringoid1OpenLang n
      *OL :
        Ringoid1OpenLang n ->
        Ringoid1OpenLang n ->
        Ringoid1OpenLang n
      +OL :
        Ringoid1OpenLang n ->
        Ringoid1OpenLang n ->
        Ringoid1OpenLang n
      1OL : Ringoid1OpenLang n
    evalTerm :
      (A : Set) ->
      Ringoid1 A -> Ringoid1Lang -> A
    evalTerm _ Ri (*L x1 x2) =
      * Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (+L x1 x2) =
      + Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (1L) = 1 Ri
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Ringoid1 A ->
      Ringoid1OpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (*OL
                         x1
                         x2) vars =
      * ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (+OL
                         x1
                         x2) vars =
      + ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (1OL) vars =
      1 ri
    simplify :
      Ringoid1Lang -> Ringoid1Lang
    simplify (+L
              (*L x y)
              (*L x z)) = *L x (+L y z)
    simplify (+L
              (*L y x)
              (*L z x)) = *L (+L y z) x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (1L) = 1L
    liftRingoid1Lang :
      Ringoid1Lang ->
      Staged Ringoid1Lang
    liftRingoid1Lang x = Now x
    *OL' :
      (n : Nat) ->
      Ringoid1OpenLang n ->
      Ringoid1OpenLang n ->
      Ringoid1OpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      Ringoid1OpenLang n ->
      Ringoid1OpenLang n ->
      Ringoid1OpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    1OL' :
      (n : Nat) -> Ringoid1OpenLang n
    1OL' _ = 1OL
    liftRingoid1OpenLang :
      (n : Nat) ->
      Ringoid1OpenLang n ->
      Staged (Ringoid1OpenLang n)
    liftRingoid1OpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftRingoid1OpenLang _ (*OL
                            x1
                            x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftRingoid1OpenLang _ x1)
        (liftRingoid1OpenLang _ x2)
    liftRingoid1OpenLang _ (+OL
                            x1
                            x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftRingoid1OpenLang _ x1)
        (liftRingoid1OpenLang _ x2)
    liftRingoid1OpenLang _ (1OL) =
      Now 1OL
  
  module Ringoid1Sig where
    record Ringoid1Sig
      (A : Set) : Set where
      constructor Ringoid1SigC
      field
        * : A -> A -> A
        1 : A
        + : A -> A -> A
    record Ringoid1SigSig
      (AS : Set) : Set where
      constructor Ringoid1SigSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
        +S : AS -> AS -> AS
    record Ringoid1SigProd
      (AP : Set) : Set where
      constructor Ringoid1SigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record Ringoid1SigHom
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid1Sig A1)
      (Ri2 : Ringoid1Sig A2) :
      Set where
      constructor Ringoid1SigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-1 : hom (1 Ri1) == 1 Ri2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
    record Ringoid1SigRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid1Sig A1)
      (Ri2 : Ringoid1Sig A2) :
      Set where
      constructor Ringoid1SigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-1 :
          interp (1 Ri1) (1 Ri2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
    data Ringoid1SigLang : Set where
      *L :
        Ringoid1SigLang ->
        Ringoid1SigLang ->
        Ringoid1SigLang
      1L : Ringoid1SigLang
      +L :
        Ringoid1SigLang ->
        Ringoid1SigLang ->
        Ringoid1SigLang
    data Ringoid1SigOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> Ringoid1SigOpenLang n
      *OL :
        Ringoid1SigOpenLang n ->
        Ringoid1SigOpenLang n ->
        Ringoid1SigOpenLang n
      1OL : Ringoid1SigOpenLang n
      +OL :
        Ringoid1SigOpenLang n ->
        Ringoid1SigOpenLang n ->
        Ringoid1SigOpenLang n
    evalTerm :
      (A : Set) ->
      Ringoid1Sig A ->
      Ringoid1SigLang -> A
    evalTerm _ Ri (*L x1 x2) =
      * Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (1L) = 1 Ri
    evalTerm _ Ri (+L x1 x2) =
      + Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Ringoid1Sig A ->
      Ringoid1SigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (*OL
                         x1
                         x2) vars =
      * ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (1OL) vars =
      1 ri
    evalOpenTerm _ n ri (+OL
                         x1
                         x2) vars =
      + ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      Ringoid1SigLang ->
      Ringoid1SigLang
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (1L) = 1L
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftRingoid1SigLang :
      Ringoid1SigLang ->
      Staged Ringoid1SigLang
    liftRingoid1SigLang x = Now x
    *OL' :
      (n : Nat) ->
      Ringoid1SigOpenLang n ->
      Ringoid1SigOpenLang n ->
      Ringoid1SigOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    1OL' :
      (n : Nat) ->
      Ringoid1SigOpenLang n
    1OL' _ = 1OL
    +OL' :
      (n : Nat) ->
      Ringoid1SigOpenLang n ->
      Ringoid1SigOpenLang n ->
      Ringoid1SigOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftRingoid1SigOpenLang :
      (n : Nat) ->
      Ringoid1SigOpenLang n ->
      Staged (Ringoid1SigOpenLang n)
    liftRingoid1SigOpenLang _ (v
                               fin) = const _ (code _ (v fin))
    liftRingoid1SigOpenLang _ (*OL
                               x1
                               x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftRingoid1SigOpenLang _ x1)
        (liftRingoid1SigOpenLang _ x2)
    liftRingoid1SigOpenLang _ (1OL) =
      Now 1OL
    liftRingoid1SigOpenLang _ (+OL
                               x1
                               x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftRingoid1SigOpenLang _ x1)
        (liftRingoid1SigOpenLang _ x2)
  
  module RingoidSig where
    record RingoidSig
      (A : Set) : Set where
      constructor RingoidSigC
      field
        * : A -> A -> A
        + : A -> A -> A
    record RingoidSigSig
      (AS : Set) : Set where
      constructor RingoidSigSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record RingoidSigProd
      (AP : Set) : Set where
      constructor RingoidSigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record RingoidSigHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidSig A1)
      (Ri2 : RingoidSig A2) :
      Set where
      constructor RingoidSigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
    record RingoidSigRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidSig A1)
      (Ri2 : RingoidSig A2) :
      Set where
      constructor RingoidSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
    data RingoidSigLang : Set where
      *L :
        RingoidSigLang ->
        RingoidSigLang -> RingoidSigLang
      +L :
        RingoidSigLang ->
        RingoidSigLang -> RingoidSigLang
    data RingoidSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> RingoidSigOpenLang n
      *OL :
        RingoidSigOpenLang n ->
        RingoidSigOpenLang n ->
        RingoidSigOpenLang n
      +OL :
        RingoidSigOpenLang n ->
        RingoidSigOpenLang n ->
        RingoidSigOpenLang n
    evalTerm :
      (A : Set) ->
      RingoidSig A ->
      RingoidSigLang -> A
    evalTerm _ Ri (*L x1 x2) =
      * Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (+L x1 x2) =
      + Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RingoidSig A ->
      RingoidSigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (*OL
                         x1
                         x2) vars =
      * ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (+OL
                         x1
                         x2) vars =
      + ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RingoidSigLang -> RingoidSigLang
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftRingoidSigLang :
      RingoidSigLang ->
      Staged RingoidSigLang
    liftRingoidSigLang x = Now x
    *OL' :
      (n : Nat) ->
      RingoidSigOpenLang n ->
      RingoidSigOpenLang n ->
      RingoidSigOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      RingoidSigOpenLang n ->
      RingoidSigOpenLang n ->
      RingoidSigOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftRingoidSigOpenLang :
      (n : Nat) ->
      RingoidSigOpenLang n ->
      Staged (RingoidSigOpenLang n)
    liftRingoidSigOpenLang _ (v
                              fin) = const _ (code _ (v fin))
    liftRingoidSigOpenLang _ (*OL
                              x1
                              x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftRingoidSigOpenLang _ x1)
        (liftRingoidSigOpenLang _ x2)
    liftRingoidSigOpenLang _ (+OL
                              x1
                              x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftRingoidSigOpenLang _ x1)
        (liftRingoidSigOpenLang _ x2)
  
  module RingoidWithAddAntiDistrib where
    record RingoidWithAddAntiDistrib
      (A : Set) : Set where
      constructor RingoidWithAddAntiDistribC
      field
        + : A -> A -> A
        prim : A -> A
        antidis_prim_+ :
          (x : A) (y : A) ->
          prim (+ x y) ==
            + (prim y) (prim x)
        * : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record RingoidWithAddAntiDistribSig
      (AS : Set) : Set where
      constructor RingoidWithAddAntiDistribSigSigC
      field
        +S : AS -> AS -> AS
        primS : AS -> AS
        *S : AS -> AS -> AS
    record RingoidWithAddAntiDistribProd
      (AP : Set) : Set where
      constructor RingoidWithAddAntiDistribProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        antidis_prim_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (+P xP yP) ==
            +P (primP yP) (primP xP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record RingoidWithAddAntiDistribHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidWithAddAntiDistrib
         A1)
      (Ri2 : RingoidWithAddAntiDistrib
         A2) : Set where
      constructor RingoidWithAddAntiDistribHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Ri1 x1) ==
            prim Ri2 (hom x1)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
    record RingoidWithAddAntiDistribRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidWithAddAntiDistrib
         A1)
      (Ri2 : RingoidWithAddAntiDistrib
         A2) : Set where
      constructor RingoidWithAddAntiDistribRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Ri1 x1)
            (prim Ri2 y1)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
    data RingoidWithAddAntiDistribLang
      : Set where
      +L :
        RingoidWithAddAntiDistribLang ->
        RingoidWithAddAntiDistribLang ->
        RingoidWithAddAntiDistribLang
      primL :
        RingoidWithAddAntiDistribLang ->
        RingoidWithAddAntiDistribLang
      *L :
        RingoidWithAddAntiDistribLang ->
        RingoidWithAddAntiDistribLang ->
        RingoidWithAddAntiDistribLang
    data RingoidWithAddAntiDistribOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RingoidWithAddAntiDistribOpenLang
          n
      +OL :
        RingoidWithAddAntiDistribOpenLang
          n ->
        RingoidWithAddAntiDistribOpenLang
          n ->
        RingoidWithAddAntiDistribOpenLang
          n
      primOL :
        RingoidWithAddAntiDistribOpenLang
          n ->
        RingoidWithAddAntiDistribOpenLang
          n
      *OL :
        RingoidWithAddAntiDistribOpenLang
          n ->
        RingoidWithAddAntiDistribOpenLang
          n ->
        RingoidWithAddAntiDistribOpenLang
          n
    evalTerm :
      (A : Set) ->
      RingoidWithAddAntiDistrib A ->
      RingoidWithAddAntiDistribLang ->
      A
    evalTerm _ Ri (+L x1 x2) =
      + Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (primL x1) =
      prim Ri (evalTerm _ Ri x1)
    evalTerm _ Ri (*L x1 x2) =
      * Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RingoidWithAddAntiDistrib A ->
      RingoidWithAddAntiDistribOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (+OL
                         x1
                         x2) vars =
      + ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (primOL
                         x1) vars =
      prim ri
        (evalOpenTerm _ n ri x1 vars)
    evalOpenTerm _ n ri (*OL
                         x1
                         x2) vars =
      * ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RingoidWithAddAntiDistribLang ->
      RingoidWithAddAntiDistribLang
    simplify (+L
              (primL y)
              (primL x)) = primL (+L x y)
    simplify (+L
              (*L x y)
              (*L x z)) = *L x (+L y z)
    simplify (+L
              (*L y x)
              (*L z x)) = *L (+L y z) x
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (primL x1) =
      primL (simplify x1)
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    liftRingoidWithAddAntiDistribLang :
      RingoidWithAddAntiDistribLang ->
      Staged
        RingoidWithAddAntiDistribLang
    liftRingoidWithAddAntiDistribLang x =
      Now x
    +OL' :
      (n : Nat) ->
      RingoidWithAddAntiDistribOpenLang
        n ->
      RingoidWithAddAntiDistribOpenLang
        n ->
      RingoidWithAddAntiDistribOpenLang
        n
    +OL' _ x1 x2 = +OL x1 x2
    primOL' :
      (n : Nat) ->
      RingoidWithAddAntiDistribOpenLang
        n ->
      RingoidWithAddAntiDistribOpenLang
        n
    primOL' _ x1 = primOL x1
    *OL' :
      (n : Nat) ->
      RingoidWithAddAntiDistribOpenLang
        n ->
      RingoidWithAddAntiDistribOpenLang
        n ->
      RingoidWithAddAntiDistribOpenLang
        n
    *OL' _ x1 x2 = *OL x1 x2
    liftRingoidWithAddAntiDistribOpenLang :
      (n : Nat) ->
      RingoidWithAddAntiDistribOpenLang
        n ->
      Staged
        (RingoidWithAddAntiDistribOpenLang
           n)
    liftRingoidWithAddAntiDistribOpenLang _ (v
                                             fin) = const _ (code _ (v fin))
    liftRingoidWithAddAntiDistribOpenLang _ (+OL
                                             x1
                                             x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftRingoidWithAddAntiDistribOpenLang
           _
           x1)
        (liftRingoidWithAddAntiDistribOpenLang
           _
           x2)
    liftRingoidWithAddAntiDistribOpenLang _ (primOL
                                             x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftRingoidWithAddAntiDistribOpenLang
           _
           x1)
    liftRingoidWithAddAntiDistribOpenLang _ (*OL
                                             x1
                                             x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftRingoidWithAddAntiDistribOpenLang
           _
           x1)
        (liftRingoidWithAddAntiDistribOpenLang
           _
           x2)
  
  module RingoidWithInvolution where
    record RingoidWithInvolution
      (A : Set) : Set where
      constructor RingoidWithInvolutionC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        prim : A -> A
    record RingoidWithInvolutionSig
      (AS : Set) : Set where
      constructor RingoidWithInvolutionSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        primS : AS -> AS
    record RingoidWithInvolutionProd
      (AP : Set) : Set where
      constructor RingoidWithInvolutionProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record RingoidWithInvolutionHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidWithInvolution A1)
      (Ri2 : RingoidWithInvolution
         A2) : Set where
      constructor RingoidWithInvolutionHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Ri1 x1) ==
            prim Ri2 (hom x1)
    record RingoidWithInvolutionRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidWithInvolution A1)
      (Ri2 : RingoidWithInvolution
         A2) : Set where
      constructor RingoidWithInvolutionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Ri1 x1)
            (prim Ri2 y1)
    data RingoidWithInvolutionLang
      : Set where
      *L :
        RingoidWithInvolutionLang ->
        RingoidWithInvolutionLang ->
        RingoidWithInvolutionLang
      +L :
        RingoidWithInvolutionLang ->
        RingoidWithInvolutionLang ->
        RingoidWithInvolutionLang
      primL :
        RingoidWithInvolutionLang ->
        RingoidWithInvolutionLang
    data RingoidWithInvolutionOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RingoidWithInvolutionOpenLang n
      *OL :
        RingoidWithInvolutionOpenLang
          n ->
        RingoidWithInvolutionOpenLang
          n ->
        RingoidWithInvolutionOpenLang n
      +OL :
        RingoidWithInvolutionOpenLang
          n ->
        RingoidWithInvolutionOpenLang
          n ->
        RingoidWithInvolutionOpenLang n
      primOL :
        RingoidWithInvolutionOpenLang
          n ->
        RingoidWithInvolutionOpenLang n
    evalTerm :
      (A : Set) ->
      RingoidWithInvolution A ->
      RingoidWithInvolutionLang -> A
    evalTerm _ Ri (*L x1 x2) =
      * Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (+L x1 x2) =
      + Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (primL x1) =
      prim Ri (evalTerm _ Ri x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RingoidWithInvolution A ->
      RingoidWithInvolutionOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (*OL
                         x1
                         x2) vars =
      * ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (+OL
                         x1
                         x2) vars =
      + ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (primOL
                         x1) vars =
      prim ri
        (evalOpenTerm _ n ri x1 vars)
    simplify :
      RingoidWithInvolutionLang ->
      RingoidWithInvolutionLang
    simplify (+L
              (*L x y)
              (*L x z)) = *L x (+L y z)
    simplify (+L
              (*L y x)
              (*L z x)) = *L (+L y z) x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (primL x1) =
      primL (simplify x1)
    liftRingoidWithInvolutionLang :
      RingoidWithInvolutionLang ->
      Staged RingoidWithInvolutionLang
    liftRingoidWithInvolutionLang x =
      Now x
    *OL' :
      (n : Nat) ->
      RingoidWithInvolutionOpenLang
        n ->
      RingoidWithInvolutionOpenLang
        n ->
      RingoidWithInvolutionOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      RingoidWithInvolutionOpenLang
        n ->
      RingoidWithInvolutionOpenLang
        n ->
      RingoidWithInvolutionOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    primOL' :
      (n : Nat) ->
      RingoidWithInvolutionOpenLang
        n ->
      RingoidWithInvolutionOpenLang n
    primOL' _ x1 = primOL x1
    liftRingoidWithInvolutionOpenLang :
      (n : Nat) ->
      RingoidWithInvolutionOpenLang
        n ->
      Staged
        (RingoidWithInvolutionOpenLang
           n)
    liftRingoidWithInvolutionOpenLang _ (v
                                         fin) = const _ (code _ (v fin))
    liftRingoidWithInvolutionOpenLang _ (*OL
                                         x1
                                         x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftRingoidWithInvolutionOpenLang
           _
           x1)
        (liftRingoidWithInvolutionOpenLang
           _
           x2)
    liftRingoidWithInvolutionOpenLang _ (+OL
                                         x1
                                         x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftRingoidWithInvolutionOpenLang
           _
           x1)
        (liftRingoidWithInvolutionOpenLang
           _
           x2)
    liftRingoidWithInvolutionOpenLang _ (primOL
                                         x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftRingoidWithInvolutionOpenLang
           _
           x1)
  
  module RingoidWithMultAntiDistrib where
    record RingoidWithMultAntiDistrib
      (A : Set) : Set where
      constructor RingoidWithMultAntiDistribC
      field
        * : A -> A -> A
        prim : A -> A
        antidis_prim_* :
          (x : A) (y : A) ->
          prim (* x y) ==
            * (prim y) (prim x)
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record RingoidWithMultAntiDistribSig
      (AS : Set) : Set where
      constructor RingoidWithMultAntiDistribSigSigC
      field
        *S : AS -> AS -> AS
        primS : AS -> AS
        +S : AS -> AS -> AS
    record RingoidWithMultAntiDistribProd
      (AP : Set) : Set where
      constructor RingoidWithMultAntiDistribProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        antidis_prim_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (*P xP yP) ==
            *P (primP yP) (primP xP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record RingoidWithMultAntiDistribHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidWithMultAntiDistrib
         A1)
      (Ri2 : RingoidWithMultAntiDistrib
         A2) : Set where
      constructor RingoidWithMultAntiDistribHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Ri1 x1) ==
            prim Ri2 (hom x1)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
    record RingoidWithMultAntiDistribRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidWithMultAntiDistrib
         A1)
      (Ri2 : RingoidWithMultAntiDistrib
         A2) : Set where
      constructor RingoidWithMultAntiDistribRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Ri1 x1)
            (prim Ri2 y1)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
    data RingoidWithMultAntiDistribLang
      : Set where
      *L :
        RingoidWithMultAntiDistribLang ->
        RingoidWithMultAntiDistribLang ->
        RingoidWithMultAntiDistribLang
      primL :
        RingoidWithMultAntiDistribLang ->
        RingoidWithMultAntiDistribLang
      +L :
        RingoidWithMultAntiDistribLang ->
        RingoidWithMultAntiDistribLang ->
        RingoidWithMultAntiDistribLang
    data RingoidWithMultAntiDistribOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RingoidWithMultAntiDistribOpenLang
          n
      *OL :
        RingoidWithMultAntiDistribOpenLang
          n ->
        RingoidWithMultAntiDistribOpenLang
          n ->
        RingoidWithMultAntiDistribOpenLang
          n
      primOL :
        RingoidWithMultAntiDistribOpenLang
          n ->
        RingoidWithMultAntiDistribOpenLang
          n
      +OL :
        RingoidWithMultAntiDistribOpenLang
          n ->
        RingoidWithMultAntiDistribOpenLang
          n ->
        RingoidWithMultAntiDistribOpenLang
          n
    evalTerm :
      (A : Set) ->
      RingoidWithMultAntiDistrib A ->
      RingoidWithMultAntiDistribLang ->
      A
    evalTerm _ Ri (*L x1 x2) =
      * Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (primL x1) =
      prim Ri (evalTerm _ Ri x1)
    evalTerm _ Ri (+L x1 x2) =
      + Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RingoidWithMultAntiDistrib A ->
      RingoidWithMultAntiDistribOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (*OL
                         x1
                         x2) vars =
      * ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (primOL
                         x1) vars =
      prim ri
        (evalOpenTerm _ n ri x1 vars)
    evalOpenTerm _ n ri (+OL
                         x1
                         x2) vars =
      + ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    simplify :
      RingoidWithMultAntiDistribLang ->
      RingoidWithMultAntiDistribLang
    simplify (*L
              (primL y)
              (primL x)) = primL (*L x y)
    simplify (+L
              (*L x y)
              (*L x z)) = *L x (+L y z)
    simplify (+L
              (*L y x)
              (*L z x)) = *L (+L y z) x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (primL x1) =
      primL (simplify x1)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftRingoidWithMultAntiDistribLang :
      RingoidWithMultAntiDistribLang ->
      Staged
        RingoidWithMultAntiDistribLang
    liftRingoidWithMultAntiDistribLang x =
      Now x
    *OL' :
      (n : Nat) ->
      RingoidWithMultAntiDistribOpenLang
        n ->
      RingoidWithMultAntiDistribOpenLang
        n ->
      RingoidWithMultAntiDistribOpenLang
        n
    *OL' _ x1 x2 = *OL x1 x2
    primOL' :
      (n : Nat) ->
      RingoidWithMultAntiDistribOpenLang
        n ->
      RingoidWithMultAntiDistribOpenLang
        n
    primOL' _ x1 = primOL x1
    +OL' :
      (n : Nat) ->
      RingoidWithMultAntiDistribOpenLang
        n ->
      RingoidWithMultAntiDistribOpenLang
        n ->
      RingoidWithMultAntiDistribOpenLang
        n
    +OL' _ x1 x2 = +OL x1 x2
    liftRingoidWithMultAntiDistribOpenLang :
      (n : Nat) ->
      RingoidWithMultAntiDistribOpenLang
        n ->
      Staged
        (RingoidWithMultAntiDistribOpenLang
           n)
    liftRingoidWithMultAntiDistribOpenLang _ (v
                                              fin) = const _ (code _ (v fin))
    liftRingoidWithMultAntiDistribOpenLang _ (*OL
                                              x1
                                              x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftRingoidWithMultAntiDistribOpenLang
           _
           x1)
        (liftRingoidWithMultAntiDistribOpenLang
           _
           x2)
    liftRingoidWithMultAntiDistribOpenLang _ (primOL
                                              x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftRingoidWithMultAntiDistribOpenLang
           _
           x1)
    liftRingoidWithMultAntiDistribOpenLang _ (+OL
                                              x1
                                              x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftRingoidWithMultAntiDistribOpenLang
           _
           x1)
        (liftRingoidWithMultAntiDistribOpenLang
           _
           x2)
  
  module Rng where
    record Rng (A : Set) : Set where
      constructor RngC
      field
        0 : A
        + : A -> A -> A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record RngSig
      (AS : Set) : Set where
      constructor RngSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        negS : AS -> AS
        *S : AS -> AS -> AS
    record RngProd
      (AP : Set) : Set where
      constructor RngProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record RngHom
      (A1 : Set) (A2 : Set)
      (Rn1 : Rng A1)
      (Rn2 : Rng A2) : Set where
      constructor RngHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Rn1) == 0 Rn2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Rn1 x1 x2) ==
            + Rn2 (hom x1) (hom x2)
        pres-neg :
          (x1 : A1) ->
          hom (neg Rn1 x1) ==
            neg Rn2 (hom x1)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Rn1 x1 x2) ==
            * Rn2 (hom x1) (hom x2)
    record RngRelInterp
      (A1 : Set) (A2 : Set)
      (Rn1 : Rng A1)
      (Rn2 : Rng A2) : Set where
      constructor RngRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Rn1) (0 Rn2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Rn1 x1 x2)
            (+ Rn2 y1 y2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Rn1 x1) (neg Rn2 y1)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Rn1 x1 x2)
            (* Rn2 y1 y2)
    data RngLang : Set where
      0L : RngLang
      +L :
        RngLang -> RngLang -> RngLang
      negL : RngLang -> RngLang
      *L :
        RngLang -> RngLang -> RngLang
    data RngOpenLang
      (n : Nat) : Set where
      v : Fin n -> RngOpenLang n
      0OL : RngOpenLang n
      +OL :
        RngOpenLang n ->
        RngOpenLang n -> RngOpenLang n
      negOL :
        RngOpenLang n -> RngOpenLang n
      *OL :
        RngOpenLang n ->
        RngOpenLang n -> RngOpenLang n
    evalTerm :
      (A : Set) ->
      Rng A -> RngLang -> A
    evalTerm _ Rn (0L) = 0 Rn
    evalTerm _ Rn (+L x1 x2) =
      + Rn (evalTerm _ Rn x1)
        (evalTerm _ Rn x2)
    evalTerm _ Rn (negL x1) =
      neg Rn (evalTerm _ Rn x1)
    evalTerm _ Rn (*L x1 x2) =
      * Rn (evalTerm _ Rn x1)
        (evalTerm _ Rn x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Rng A ->
      RngOpenLang n -> Vec A n -> A
    evalOpenTerm _ n rn (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n rn (0OL) vars =
      0 rn
    evalOpenTerm _ n rn (+OL
                         x1
                         x2) vars =
      + rn
        (evalOpenTerm _ n rn x1 vars)
        (evalOpenTerm _ n rn x2 vars)
    evalOpenTerm _ n rn (negOL
                         x1) vars =
      neg rn
        (evalOpenTerm _ n rn x1 vars)
    evalOpenTerm _ n rn (*OL
                         x1
                         x2) vars =
      * rn
        (evalOpenTerm _ n rn x1 vars)
        (evalOpenTerm _ n rn x2 vars)
    simplify : RngLang -> RngLang
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (+L x (negL x)) = 0L
    simplify (+L (negL x) x) = 0L
    simplify (+L
              (*L x y)
              (*L x z)) = *L x (+L y z)
    simplify (+L
              (*L y x)
              (*L z x)) = *L (+L y z) x
    simplify (0L) = 0L
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (negL x1) =
      negL (simplify x1)
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    liftRngLang :
      RngLang -> Staged RngLang
    liftRngLang x = Now x
    0OL' :
      (n : Nat) -> RngOpenLang n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      RngOpenLang n ->
      RngOpenLang n -> RngOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    negOL' :
      (n : Nat) ->
      RngOpenLang n -> RngOpenLang n
    negOL' _ x1 = negOL x1
    *OL' :
      (n : Nat) ->
      RngOpenLang n ->
      RngOpenLang n -> RngOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    liftRngOpenLang :
      (n : Nat) ->
      RngOpenLang n ->
      Staged (RngOpenLang n)
    liftRngOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftRngOpenLang _ (0OL) =
      Now 0OL
    liftRngOpenLang _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftRngOpenLang _ x1)
        (liftRngOpenLang _ x2)
    liftRngOpenLang _ (negOL x1) =
      stage1 _ _ (negOL' _)
        (codeLift1 _ _ (negOL' _))
        (liftRngOpenLang _ x1)
    liftRngOpenLang _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftRngOpenLang _ x1)
        (liftRngOpenLang _ x2)
  
  module SemiRng where
    record SemiRng
      (A : Set) : Set where
      constructor SemiRngC
      field
        * : A -> A -> A
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record SemiRngSig
      (AS : Set) : Set where
      constructor SemiRngSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
    record SemiRngProd
      (AP : Set) : Set where
      constructor SemiRngProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record SemiRngHom
      (A1 : Set) (A2 : Set)
      (Se1 : SemiRng A1)
      (Se2 : SemiRng A2) : Set where
      constructor SemiRngHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Se1 x1 x2) ==
            * Se2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Se1 x1 x2) ==
            + Se2 (hom x1) (hom x2)
        pres-0 : hom (0 Se1) == 0 Se2
    record SemiRngRelInterp
      (A1 : Set) (A2 : Set)
      (Se1 : SemiRng A1)
      (Se2 : SemiRng A2) : Set where
      constructor SemiRngRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Se1 x1 x2)
            (* Se2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Se1 x1 x2)
            (+ Se2 y1 y2)
        interp-0 :
          interp (0 Se1) (0 Se2)
    data SemiRngLang : Set where
      *L :
        SemiRngLang ->
        SemiRngLang -> SemiRngLang
      +L :
        SemiRngLang ->
        SemiRngLang -> SemiRngLang
      0L : SemiRngLang
    data SemiRngOpenLang
      (n : Nat) : Set where
      v : Fin n -> SemiRngOpenLang n
      *OL :
        SemiRngOpenLang n ->
        SemiRngOpenLang n ->
        SemiRngOpenLang n
      +OL :
        SemiRngOpenLang n ->
        SemiRngOpenLang n ->
        SemiRngOpenLang n
      0OL : SemiRngOpenLang n
    evalTerm :
      (A : Set) ->
      SemiRng A -> SemiRngLang -> A
    evalTerm _ Se (*L x1 x2) =
      * Se (evalTerm _ Se x1)
        (evalTerm _ Se x2)
    evalTerm _ Se (+L x1 x2) =
      + Se (evalTerm _ Se x1)
        (evalTerm _ Se x2)
    evalTerm _ Se (0L) = 0 Se
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      SemiRng A ->
      SemiRngOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n se (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n se (*OL
                         x1
                         x2) vars =
      * se
        (evalOpenTerm _ n se x1 vars)
        (evalOpenTerm _ n se x2 vars)
    evalOpenTerm _ n se (+OL
                         x1
                         x2) vars =
      + se
        (evalOpenTerm _ n se x1 vars)
        (evalOpenTerm _ n se x2 vars)
    evalOpenTerm _ n se (0OL) vars =
      0 se
    simplify :
      SemiRngLang -> SemiRngLang
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (+L
              (*L x y)
              (*L x z)) = *L x (+L y z)
    simplify (+L
              (*L y x)
              (*L z x)) = *L (+L y z) x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (0L) = 0L
    liftSemiRngLang :
      SemiRngLang ->
      Staged SemiRngLang
    liftSemiRngLang x = Now x
    *OL' :
      (n : Nat) ->
      SemiRngOpenLang n ->
      SemiRngOpenLang n ->
      SemiRngOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      SemiRngOpenLang n ->
      SemiRngOpenLang n ->
      SemiRngOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) -> SemiRngOpenLang n
    0OL' _ = 0OL
    liftSemiRngOpenLang :
      (n : Nat) ->
      SemiRngOpenLang n ->
      Staged (SemiRngOpenLang n)
    liftSemiRngOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftSemiRngOpenLang _ (*OL
                           x1
                           x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftSemiRngOpenLang _ x1)
        (liftSemiRngOpenLang _ x2)
    liftSemiRngOpenLang _ (+OL
                           x1
                           x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftSemiRngOpenLang _ x1)
        (liftSemiRngOpenLang _ x2)
    liftSemiRngOpenLang _ (0OL) =
      Now 0OL
  
  module SemiRngWithUnit where
    record SemiRngWithUnit
      (A : Set) : Set where
      constructor SemiRngWithUnitC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record SemiRngWithUnitSig
      (AS : Set) : Set where
      constructor SemiRngWithUnitSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
        +S : AS -> AS -> AS
        0S : AS
    record SemiRngWithUnitProd
      (AP : Set) : Set where
      constructor SemiRngWithUnitProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record SemiRngWithUnitHom
      (A1 : Set) (A2 : Set)
      (Se1 : SemiRngWithUnit A1)
      (Se2 : SemiRngWithUnit A2) :
      Set where
      constructor SemiRngWithUnitHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Se1 x1 x2) ==
            * Se2 (hom x1) (hom x2)
        pres-1 : hom (1 Se1) == 1 Se2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Se1 x1 x2) ==
            + Se2 (hom x1) (hom x2)
        pres-0 : hom (0 Se1) == 0 Se2
    record SemiRngWithUnitRelInterp
      (A1 : Set) (A2 : Set)
      (Se1 : SemiRngWithUnit A1)
      (Se2 : SemiRngWithUnit A2) :
      Set where
      constructor SemiRngWithUnitRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Se1 x1 x2)
            (* Se2 y1 y2)
        interp-1 :
          interp (1 Se1) (1 Se2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Se1 x1 x2)
            (+ Se2 y1 y2)
        interp-0 :
          interp (0 Se1) (0 Se2)
    data SemiRngWithUnitLang
      : Set where
      *L :
        SemiRngWithUnitLang ->
        SemiRngWithUnitLang ->
        SemiRngWithUnitLang
      1L : SemiRngWithUnitLang
      +L :
        SemiRngWithUnitLang ->
        SemiRngWithUnitLang ->
        SemiRngWithUnitLang
      0L : SemiRngWithUnitLang
    data SemiRngWithUnitOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        SemiRngWithUnitOpenLang n
      *OL :
        SemiRngWithUnitOpenLang n ->
        SemiRngWithUnitOpenLang n ->
        SemiRngWithUnitOpenLang n
      1OL : SemiRngWithUnitOpenLang n
      +OL :
        SemiRngWithUnitOpenLang n ->
        SemiRngWithUnitOpenLang n ->
        SemiRngWithUnitOpenLang n
      0OL : SemiRngWithUnitOpenLang n
    evalTerm :
      (A : Set) ->
      SemiRngWithUnit A ->
      SemiRngWithUnitLang -> A
    evalTerm _ Se (*L x1 x2) =
      * Se (evalTerm _ Se x1)
        (evalTerm _ Se x2)
    evalTerm _ Se (1L) = 1 Se
    evalTerm _ Se (+L x1 x2) =
      + Se (evalTerm _ Se x1)
        (evalTerm _ Se x2)
    evalTerm _ Se (0L) = 0 Se
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      SemiRngWithUnit A ->
      SemiRngWithUnitOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n se (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n se (*OL
                         x1
                         x2) vars =
      * se
        (evalOpenTerm _ n se x1 vars)
        (evalOpenTerm _ n se x2 vars)
    evalOpenTerm _ n se (1OL) vars =
      1 se
    evalOpenTerm _ n se (+OL
                         x1
                         x2) vars =
      + se
        (evalOpenTerm _ n se x1 vars)
        (evalOpenTerm _ n se x2 vars)
    evalOpenTerm _ n se (0OL) vars =
      0 se
    simplify :
      SemiRngWithUnitLang ->
      SemiRngWithUnitLang
    simplify (*L (1L) x) = x
    simplify (*L x (1L)) = x
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (+L
              (*L x y)
              (*L x z)) = *L x (+L y z)
    simplify (+L
              (*L y x)
              (*L z x)) = *L (+L y z) x
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (1L) = 1L
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (0L) = 0L
    liftSemiRngWithUnitLang :
      SemiRngWithUnitLang ->
      Staged SemiRngWithUnitLang
    liftSemiRngWithUnitLang x =
      Now x
    *OL' :
      (n : Nat) ->
      SemiRngWithUnitOpenLang n ->
      SemiRngWithUnitOpenLang n ->
      SemiRngWithUnitOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    1OL' :
      (n : Nat) ->
      SemiRngWithUnitOpenLang n
    1OL' _ = 1OL
    +OL' :
      (n : Nat) ->
      SemiRngWithUnitOpenLang n ->
      SemiRngWithUnitOpenLang n ->
      SemiRngWithUnitOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      SemiRngWithUnitOpenLang n
    0OL' _ = 0OL
    liftSemiRngWithUnitOpenLang :
      (n : Nat) ->
      SemiRngWithUnitOpenLang n ->
      Staged
        (SemiRngWithUnitOpenLang n)
    liftSemiRngWithUnitOpenLang _ (v
                                   fin) = const _ (code _ (v fin))
    liftSemiRngWithUnitOpenLang _ (*OL
                                   x1
                                   x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftSemiRngWithUnitOpenLang _
           x1)
        (liftSemiRngWithUnitOpenLang _
           x2)
    liftSemiRngWithUnitOpenLang _ (1OL) =
      Now 1OL
    liftSemiRngWithUnitOpenLang _ (+OL
                                   x1
                                   x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftSemiRngWithUnitOpenLang _
           x1)
        (liftSemiRngWithUnitOpenLang _
           x2)
    liftSemiRngWithUnitOpenLang _ (0OL) =
      Now 0OL
  
  module Semigroup where
    record Semigroup
      (A : Set) : Set where
      constructor SemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record SemigroupSig
      (AS : Set) : Set where
      constructor SemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record SemigroupProd
      (AP : Set) : Set where
      constructor SemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record SemigroupHom
      (A1 : Set) (A2 : Set)
      (Se1 : Semigroup A1)
      (Se2 : Semigroup A2) : Set where
      constructor SemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Se1 x1 x2) ==
            op Se2 (hom x1) (hom x2)
    record SemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Se1 : Semigroup A1)
      (Se2 : Semigroup A2) : Set where
      constructor SemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Se1 x1 x2)
            (op Se2 y1 y2)
    data SemigroupLang : Set where
      opL :
        SemigroupLang ->
        SemigroupLang -> SemigroupLang
    data SemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> SemigroupOpenLang n
      opOL :
        SemigroupOpenLang n ->
        SemigroupOpenLang n ->
        SemigroupOpenLang n
    evalTerm :
      (A : Set) ->
      Semigroup A ->
      SemigroupLang -> A
    evalTerm _ Se (opL x1 x2) =
      op Se (evalTerm _ Se x1)
        (evalTerm _ Se x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Semigroup A ->
      SemigroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n se (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n se (opOL
                         x1
                         x2) vars =
      op se
        (evalOpenTerm _ n se x1 vars)
        (evalOpenTerm _ n se x2 vars)
    simplify :
      SemigroupLang -> SemigroupLang
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftSemigroupLang :
      SemigroupLang ->
      Staged SemigroupLang
    liftSemigroupLang x = Now x
    opOL' :
      (n : Nat) ->
      SemigroupOpenLang n ->
      SemigroupOpenLang n ->
      SemigroupOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftSemigroupOpenLang :
      (n : Nat) ->
      SemigroupOpenLang n ->
      Staged (SemigroupOpenLang n)
    liftSemigroupOpenLang _ (v
                             fin) = const _ (code _ (v fin))
    liftSemigroupOpenLang _ (opOL
                             x1
                             x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftSemigroupOpenLang _ x1)
        (liftSemigroupOpenLang _ x2)
  
  module Semiring where
    record Semiring
      (A : Set) : Set where
      constructor SemiringC
      field
        0 : A
        + : A -> A -> A
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
    record SemiringSig
      (AS : Set) : Set where
      constructor SemiringSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
        1S : AS
    record SemiringProd
      (AP : Set) : Set where
      constructor SemiringProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
    record SemiringHom
      (A1 : Set) (A2 : Set)
      (Se1 : Semiring A1)
      (Se2 : Semiring A2) : Set where
      constructor SemiringHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Se1) == 0 Se2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Se1 x1 x2) ==
            + Se2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Se1 x1 x2) ==
            * Se2 (hom x1) (hom x2)
        pres-1 : hom (1 Se1) == 1 Se2
    record SemiringRelInterp
      (A1 : Set) (A2 : Set)
      (Se1 : Semiring A1)
      (Se2 : Semiring A2) : Set where
      constructor SemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Se1) (0 Se2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Se1 x1 x2)
            (+ Se2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Se1 x1 x2)
            (* Se2 y1 y2)
        interp-1 :
          interp (1 Se1) (1 Se2)
    data SemiringLang : Set where
      0L : SemiringLang
      +L :
        SemiringLang ->
        SemiringLang -> SemiringLang
      *L :
        SemiringLang ->
        SemiringLang -> SemiringLang
      1L : SemiringLang
    data SemiringOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> SemiringOpenLang n
      0OL : SemiringOpenLang n
      +OL :
        SemiringOpenLang n ->
        SemiringOpenLang n ->
        SemiringOpenLang n
      *OL :
        SemiringOpenLang n ->
        SemiringOpenLang n ->
        SemiringOpenLang n
      1OL : SemiringOpenLang n
    evalTerm :
      (A : Set) ->
      Semiring A -> SemiringLang -> A
    evalTerm _ Se (0L) = 0 Se
    evalTerm _ Se (+L x1 x2) =
      + Se (evalTerm _ Se x1)
        (evalTerm _ Se x2)
    evalTerm _ Se (*L x1 x2) =
      * Se (evalTerm _ Se x1)
        (evalTerm _ Se x2)
    evalTerm _ Se (1L) = 1 Se
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Semiring A ->
      SemiringOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n se (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n se (0OL) vars =
      0 se
    evalOpenTerm _ n se (+OL
                         x1
                         x2) vars =
      + se
        (evalOpenTerm _ n se x1 vars)
        (evalOpenTerm _ n se x2 vars)
    evalOpenTerm _ n se (*OL
                         x1
                         x2) vars =
      * se
        (evalOpenTerm _ n se x1 vars)
        (evalOpenTerm _ n se x2 vars)
    evalOpenTerm _ n se (1OL) vars =
      1 se
    simplify :
      SemiringLang -> SemiringLang
    simplify (*L (1L) x) = x
    simplify (*L x (1L)) = x
    simplify (+L (0L) x) = x
    simplify (+L x (0L)) = x
    simplify (+L
              (*L x y)
              (*L x z)) = *L x (+L y z)
    simplify (+L
              (*L y x)
              (*L z x)) = *L (+L y z) x
    simplify (*L (0L) x) = 0L
    simplify (*L x (0L)) = 0L
    simplify (0L) = 0L
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (1L) = 1L
    liftSemiringLang :
      SemiringLang ->
      Staged SemiringLang
    liftSemiringLang x = Now x
    0OL' :
      (n : Nat) -> SemiringOpenLang n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      SemiringOpenLang n ->
      SemiringOpenLang n ->
      SemiringOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    *OL' :
      (n : Nat) ->
      SemiringOpenLang n ->
      SemiringOpenLang n ->
      SemiringOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    1OL' :
      (n : Nat) -> SemiringOpenLang n
    1OL' _ = 1OL
    liftSemiringOpenLang :
      (n : Nat) ->
      SemiringOpenLang n ->
      Staged (SemiringOpenLang n)
    liftSemiringOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftSemiringOpenLang _ (0OL) =
      Now 0OL
    liftSemiringOpenLang _ (+OL
                            x1
                            x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftSemiringOpenLang _ x1)
        (liftSemiringOpenLang _ x2)
    liftSemiringOpenLang _ (*OL
                            x1
                            x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftSemiringOpenLang _ x1)
        (liftSemiringOpenLang _ x2)
    liftSemiringOpenLang _ (1OL) =
      Now 1OL
  
  module Shelf where
    record Shelf
      (A : Set) : Set where
      constructor ShelfC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
    record ShelfSig
      (AS : Set) : Set where
      constructor ShelfSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record ShelfProd
      (AP : Set) : Set where
      constructor ShelfProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
    record ShelfHom
      (A1 : Set) (A2 : Set)
      (Sh1 : Shelf A1)
      (Sh2 : Shelf A2) : Set where
      constructor ShelfHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Sh1 x1 x2) ==
            |> Sh2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Sh1 x1 x2) ==
            <| Sh2 (hom x1) (hom x2)
    record ShelfRelInterp
      (A1 : Set) (A2 : Set)
      (Sh1 : Shelf A1)
      (Sh2 : Shelf A2) : Set where
      constructor ShelfRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Sh1 x1 x2)
            (|> Sh2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Sh1 x1 x2)
            (<| Sh2 y1 y2)
    data ShelfLang : Set where
      |>L :
        ShelfLang ->
        ShelfLang -> ShelfLang
      <|L :
        ShelfLang ->
        ShelfLang -> ShelfLang
    data ShelfOpenLang
      (n : Nat) : Set where
      v : Fin n -> ShelfOpenLang n
      |>OL :
        ShelfOpenLang n ->
        ShelfOpenLang n ->
        ShelfOpenLang n
      <|OL :
        ShelfOpenLang n ->
        ShelfOpenLang n ->
        ShelfOpenLang n
    evalTerm :
      (A : Set) ->
      Shelf A -> ShelfLang -> A
    evalTerm _ Sh (|>L x1 x2) =
      |> Sh (evalTerm _ Sh x1)
        (evalTerm _ Sh x2)
    evalTerm _ Sh (<|L x1 x2) =
      <| Sh (evalTerm _ Sh x1)
        (evalTerm _ Sh x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Shelf A ->
      ShelfOpenLang n -> Vec A n -> A
    evalOpenTerm _ n sh (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n sh (|>OL
                         x1
                         x2) vars =
      |> sh
        (evalOpenTerm _ n sh x1 vars)
        (evalOpenTerm _ n sh x2 vars)
    evalOpenTerm _ n sh (<|OL
                         x1
                         x2) vars =
      <| sh
        (evalOpenTerm _ n sh x1 vars)
        (evalOpenTerm _ n sh x2 vars)
    simplify :
      ShelfLang -> ShelfLang
    simplify (|>L
              (|>L x y)
              (|>L x z)) = |>L x (|>L y z)
    simplify (<|L
              (<|L y x)
              (<|L z x)) = <|L (<|L y z) x
    simplify (|>L x1 x2) =
      |>L (simplify x1) (simplify x2)
    simplify (<|L x1 x2) =
      <|L (simplify x1) (simplify x2)
    liftShelfLang :
      ShelfLang -> Staged ShelfLang
    liftShelfLang x = Now x
    |>OL' :
      (n : Nat) ->
      ShelfOpenLang n ->
      ShelfOpenLang n ->
      ShelfOpenLang n
    |>OL' _ x1 x2 = |>OL x1 x2
    <|OL' :
      (n : Nat) ->
      ShelfOpenLang n ->
      ShelfOpenLang n ->
      ShelfOpenLang n
    <|OL' _ x1 x2 = <|OL x1 x2
    liftShelfOpenLang :
      (n : Nat) ->
      ShelfOpenLang n ->
      Staged (ShelfOpenLang n)
    liftShelfOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftShelfOpenLang _ (|>OL
                         x1
                         x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (liftShelfOpenLang _ x1)
        (liftShelfOpenLang _ x2)
    liftShelfOpenLang _ (<|OL
                         x1
                         x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (liftShelfOpenLang _ x1)
        (liftShelfOpenLang _ x2)
  
  module ShelfSig where
    record ShelfSig
      (A : Set) : Set where
      constructor ShelfSigC
      field
        |> : A -> A -> A
        <| : A -> A -> A
    record ShelfSigSig
      (AS : Set) : Set where
      constructor ShelfSigSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record ShelfSigProd
      (AP : Set) : Set where
      constructor ShelfSigProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record ShelfSigHom
      (A1 : Set) (A2 : Set)
      (Sh1 : ShelfSig A1)
      (Sh2 : ShelfSig A2) : Set where
      constructor ShelfSigHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Sh1 x1 x2) ==
            |> Sh2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Sh1 x1 x2) ==
            <| Sh2 (hom x1) (hom x2)
    record ShelfSigRelInterp
      (A1 : Set) (A2 : Set)
      (Sh1 : ShelfSig A1)
      (Sh2 : ShelfSig A2) : Set where
      constructor ShelfSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Sh1 x1 x2)
            (|> Sh2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Sh1 x1 x2)
            (<| Sh2 y1 y2)
    data ShelfSigLang : Set where
      |>L :
        ShelfSigLang ->
        ShelfSigLang -> ShelfSigLang
      <|L :
        ShelfSigLang ->
        ShelfSigLang -> ShelfSigLang
    data ShelfSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> ShelfSigOpenLang n
      |>OL :
        ShelfSigOpenLang n ->
        ShelfSigOpenLang n ->
        ShelfSigOpenLang n
      <|OL :
        ShelfSigOpenLang n ->
        ShelfSigOpenLang n ->
        ShelfSigOpenLang n
    evalTerm :
      (A : Set) ->
      ShelfSig A -> ShelfSigLang -> A
    evalTerm _ Sh (|>L x1 x2) =
      |> Sh (evalTerm _ Sh x1)
        (evalTerm _ Sh x2)
    evalTerm _ Sh (<|L x1 x2) =
      <| Sh (evalTerm _ Sh x1)
        (evalTerm _ Sh x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      ShelfSig A ->
      ShelfSigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n sh (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n sh (|>OL
                         x1
                         x2) vars =
      |> sh
        (evalOpenTerm _ n sh x1 vars)
        (evalOpenTerm _ n sh x2 vars)
    evalOpenTerm _ n sh (<|OL
                         x1
                         x2) vars =
      <| sh
        (evalOpenTerm _ n sh x1 vars)
        (evalOpenTerm _ n sh x2 vars)
    simplify :
      ShelfSigLang -> ShelfSigLang
    simplify (|>L x1 x2) =
      |>L (simplify x1) (simplify x2)
    simplify (<|L x1 x2) =
      <|L (simplify x1) (simplify x2)
    liftShelfSigLang :
      ShelfSigLang ->
      Staged ShelfSigLang
    liftShelfSigLang x = Now x
    |>OL' :
      (n : Nat) ->
      ShelfSigOpenLang n ->
      ShelfSigOpenLang n ->
      ShelfSigOpenLang n
    |>OL' _ x1 x2 = |>OL x1 x2
    <|OL' :
      (n : Nat) ->
      ShelfSigOpenLang n ->
      ShelfSigOpenLang n ->
      ShelfSigOpenLang n
    <|OL' _ x1 x2 = <|OL x1 x2
    liftShelfSigOpenLang :
      (n : Nat) ->
      ShelfSigOpenLang n ->
      Staged (ShelfSigOpenLang n)
    liftShelfSigOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftShelfSigOpenLang _ (|>OL
                            x1
                            x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (liftShelfSigOpenLang _ x1)
        (liftShelfSigOpenLang _ x2)
    liftShelfSigOpenLang _ (<|OL
                            x1
                            x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (liftShelfSigOpenLang _ x1)
        (liftShelfSigOpenLang _ x2)
  
  module Sloop where
    record Sloop
      (A : Set) : Set where
      constructor SloopC
      field
        e : A
        op : A -> A -> A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
        antiAbsorbent :
          (x : A) (y : A) ->
          op x (op x y) == y
        unipotence :
          (x : A) -> op x x == e
    record SloopSig
      (AS : Set) : Set where
      constructor SloopSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record SloopProd
      (AP : Set) : Set where
      constructor SloopProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
        antiAbsorbentP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (opP xP yP) == yP
        unipotenceP :
          (xP : Prod AP AP) ->
          opP xP xP == eP
    record SloopHom
      (A1 : Set) (A2 : Set)
      (Sl1 : Sloop A1)
      (Sl2 : Sloop A2) : Set where
      constructor SloopHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Sl1) == e Sl2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Sl1 x1 x2) ==
            op Sl2 (hom x1) (hom x2)
    record SloopRelInterp
      (A1 : Set) (A2 : Set)
      (Sl1 : Sloop A1)
      (Sl2 : Sloop A2) : Set where
      constructor SloopRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Sl1) (e Sl2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Sl1 x1 x2)
            (op Sl2 y1 y2)
    data SloopLang : Set where
      eL : SloopLang
      opL :
        SloopLang ->
        SloopLang -> SloopLang
    data SloopOpenLang
      (n : Nat) : Set where
      v : Fin n -> SloopOpenLang n
      eOL : SloopOpenLang n
      opOL :
        SloopOpenLang n ->
        SloopOpenLang n ->
        SloopOpenLang n
    evalTerm :
      (A : Set) ->
      Sloop A -> SloopLang -> A
    evalTerm _ Sl (eL) = e Sl
    evalTerm _ Sl (opL x1 x2) =
      op Sl (evalTerm _ Sl x1)
        (evalTerm _ Sl x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Sloop A ->
      SloopOpenLang n -> Vec A n -> A
    evalOpenTerm _ n sl (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n sl (eOL) vars =
      e sl
    evalOpenTerm _ n sl (opOL
                         x1
                         x2) vars =
      op sl
        (evalOpenTerm _ n sl x1 vars)
        (evalOpenTerm _ n sl x2 vars)
    simplify :
      SloopLang -> SloopLang
    simplify (opL x (opL x y)) = y
    simplify (opL x x) = eL
    simplify (eL) = eL
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftSloopLang :
      SloopLang -> Staged SloopLang
    liftSloopLang x = Now x
    eOL' :
      (n : Nat) -> SloopOpenLang n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      SloopOpenLang n ->
      SloopOpenLang n ->
      SloopOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftSloopOpenLang :
      (n : Nat) ->
      SloopOpenLang n ->
      Staged (SloopOpenLang n)
    liftSloopOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftSloopOpenLang _ (eOL) =
      Now eOL
    liftSloopOpenLang _ (opOL
                         x1
                         x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftSloopOpenLang _ x1)
        (liftSloopOpenLang _ x2)
  
  module Spindle where
    record Spindle
      (A : Set) : Set where
      constructor SpindleC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
        idempotent_|> :
          (x : A) -> |> x x == x
        idempotent_<| :
          (x : A) -> <| x x == x
    record SpindleSig
      (AS : Set) : Set where
      constructor SpindleSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record SpindleProd
      (AP : Set) : Set where
      constructor SpindleProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
        idempotent_<|P :
          (xP : Prod AP AP) ->
          <|P xP xP == xP
    record SpindleHom
      (A1 : Set) (A2 : Set)
      (Sp1 : Spindle A1)
      (Sp2 : Spindle A2) : Set where
      constructor SpindleHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Sp1 x1 x2) ==
            |> Sp2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Sp1 x1 x2) ==
            <| Sp2 (hom x1) (hom x2)
    record SpindleRelInterp
      (A1 : Set) (A2 : Set)
      (Sp1 : Spindle A1)
      (Sp2 : Spindle A2) : Set where
      constructor SpindleRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Sp1 x1 x2)
            (|> Sp2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Sp1 x1 x2)
            (<| Sp2 y1 y2)
    data SpindleLang : Set where
      |>L :
        SpindleLang ->
        SpindleLang -> SpindleLang
      <|L :
        SpindleLang ->
        SpindleLang -> SpindleLang
    data SpindleOpenLang
      (n : Nat) : Set where
      v : Fin n -> SpindleOpenLang n
      |>OL :
        SpindleOpenLang n ->
        SpindleOpenLang n ->
        SpindleOpenLang n
      <|OL :
        SpindleOpenLang n ->
        SpindleOpenLang n ->
        SpindleOpenLang n
    evalTerm :
      (A : Set) ->
      Spindle A -> SpindleLang -> A
    evalTerm _ Sp (|>L x1 x2) =
      |> Sp (evalTerm _ Sp x1)
        (evalTerm _ Sp x2)
    evalTerm _ Sp (<|L x1 x2) =
      <| Sp (evalTerm _ Sp x1)
        (evalTerm _ Sp x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Spindle A ->
      SpindleOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n sp (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n sp (|>OL
                         x1
                         x2) vars =
      |> sp
        (evalOpenTerm _ n sp x1 vars)
        (evalOpenTerm _ n sp x2 vars)
    evalOpenTerm _ n sp (<|OL
                         x1
                         x2) vars =
      <| sp
        (evalOpenTerm _ n sp x1 vars)
        (evalOpenTerm _ n sp x2 vars)
    simplify :
      SpindleLang -> SpindleLang
    simplify (|>L
              (|>L x y)
              (|>L x z)) = |>L x (|>L y z)
    simplify (<|L
              (<|L y x)
              (<|L z x)) = <|L (<|L y z) x
    simplify (|>L x x) = x
    simplify (<|L x x) = x
    simplify (|>L x1 x2) =
      |>L (simplify x1) (simplify x2)
    simplify (<|L x1 x2) =
      <|L (simplify x1) (simplify x2)
    liftSpindleLang :
      SpindleLang ->
      Staged SpindleLang
    liftSpindleLang x = Now x
    |>OL' :
      (n : Nat) ->
      SpindleOpenLang n ->
      SpindleOpenLang n ->
      SpindleOpenLang n
    |>OL' _ x1 x2 = |>OL x1 x2
    <|OL' :
      (n : Nat) ->
      SpindleOpenLang n ->
      SpindleOpenLang n ->
      SpindleOpenLang n
    <|OL' _ x1 x2 = <|OL x1 x2
    liftSpindleOpenLang :
      (n : Nat) ->
      SpindleOpenLang n ->
      Staged (SpindleOpenLang n)
    liftSpindleOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftSpindleOpenLang _ (|>OL
                           x1
                           x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (liftSpindleOpenLang _ x1)
        (liftSpindleOpenLang _ x2)
    liftSpindleOpenLang _ (<|OL
                           x1
                           x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (liftSpindleOpenLang _ x1)
        (liftSpindleOpenLang _ x2)
  
  module Squag where
    record Squag
      (A : Set) : Set where
      constructor SquagC
      field
        op : A -> A -> A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
        antiAbsorbent :
          (x : A) (y : A) ->
          op x (op x y) == y
        idempotent_op :
          (x : A) -> op x x == x
    record SquagSig
      (AS : Set) : Set where
      constructor SquagSigSigC
      field
        opS : AS -> AS -> AS
    record SquagProd
      (AP : Set) : Set where
      constructor SquagProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
        antiAbsorbentP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (opP xP yP) == yP
        idempotent_opP :
          (xP : Prod AP AP) ->
          opP xP xP == xP
    record SquagHom
      (A1 : Set) (A2 : Set)
      (Sq1 : Squag A1)
      (Sq2 : Squag A2) : Set where
      constructor SquagHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Sq1 x1 x2) ==
            op Sq2 (hom x1) (hom x2)
    record SquagRelInterp
      (A1 : Set) (A2 : Set)
      (Sq1 : Squag A1)
      (Sq2 : Squag A2) : Set where
      constructor SquagRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Sq1 x1 x2)
            (op Sq2 y1 y2)
    data SquagLang : Set where
      opL :
        SquagLang ->
        SquagLang -> SquagLang
    data SquagOpenLang
      (n : Nat) : Set where
      v : Fin n -> SquagOpenLang n
      opOL :
        SquagOpenLang n ->
        SquagOpenLang n ->
        SquagOpenLang n
    evalTerm :
      (A : Set) ->
      Squag A -> SquagLang -> A
    evalTerm _ Sq (opL x1 x2) =
      op Sq (evalTerm _ Sq x1)
        (evalTerm _ Sq x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Squag A ->
      SquagOpenLang n -> Vec A n -> A
    evalOpenTerm _ n sq (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n sq (opOL
                         x1
                         x2) vars =
      op sq
        (evalOpenTerm _ n sq x1 vars)
        (evalOpenTerm _ n sq x2 vars)
    simplify :
      SquagLang -> SquagLang
    simplify (opL x (opL x y)) = y
    simplify (opL x x) = x
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftSquagLang :
      SquagLang -> Staged SquagLang
    liftSquagLang x = Now x
    opOL' :
      (n : Nat) ->
      SquagOpenLang n ->
      SquagOpenLang n ->
      SquagOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftSquagOpenLang :
      (n : Nat) ->
      SquagOpenLang n ->
      Staged (SquagOpenLang n)
    liftSquagOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftSquagOpenLang _ (opOL
                         x1
                         x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftSquagOpenLang _ x1)
        (liftSquagOpenLang _ x2)
  
  module SteinerMagma where
    record SteinerMagma
      (A : Set) : Set where
      constructor SteinerMagmaC
      field
        op : A -> A -> A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
        antiAbsorbent :
          (x : A) (y : A) ->
          op x (op x y) == y
    record SteinerMagmaSig
      (AS : Set) : Set where
      constructor SteinerMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record SteinerMagmaProd
      (AP : Set) : Set where
      constructor SteinerMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
        antiAbsorbentP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (opP xP yP) == yP
    record SteinerMagmaHom
      (A1 : Set) (A2 : Set)
      (St1 : SteinerMagma A1)
      (St2 : SteinerMagma A2) :
      Set where
      constructor SteinerMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op St1 x1 x2) ==
            op St2 (hom x1) (hom x2)
    record SteinerMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (St1 : SteinerMagma A1)
      (St2 : SteinerMagma A2) :
      Set where
      constructor SteinerMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op St1 x1 x2)
            (op St2 y1 y2)
    data SteinerMagmaLang
      : Set where
      opL :
        SteinerMagmaLang ->
        SteinerMagmaLang ->
        SteinerMagmaLang
    data SteinerMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> SteinerMagmaOpenLang n
      opOL :
        SteinerMagmaOpenLang n ->
        SteinerMagmaOpenLang n ->
        SteinerMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      SteinerMagma A ->
      SteinerMagmaLang -> A
    evalTerm _ St (opL x1 x2) =
      op St (evalTerm _ St x1)
        (evalTerm _ St x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      SteinerMagma A ->
      SteinerMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n st (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n st (opOL
                         x1
                         x2) vars =
      op st
        (evalOpenTerm _ n st x1 vars)
        (evalOpenTerm _ n st x2 vars)
    simplify :
      SteinerMagmaLang ->
      SteinerMagmaLang
    simplify (opL x (opL x y)) = y
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftSteinerMagmaLang :
      SteinerMagmaLang ->
      Staged SteinerMagmaLang
    liftSteinerMagmaLang x = Now x
    opOL' :
      (n : Nat) ->
      SteinerMagmaOpenLang n ->
      SteinerMagmaOpenLang n ->
      SteinerMagmaOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftSteinerMagmaOpenLang :
      (n : Nat) ->
      SteinerMagmaOpenLang n ->
      Staged (SteinerMagmaOpenLang n)
    liftSteinerMagmaOpenLang _ (v
                                fin) = const _ (code _ (v fin))
    liftSteinerMagmaOpenLang _ (opOL
                                x1
                                x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftSteinerMagmaOpenLang _ x1)
        (liftSteinerMagmaOpenLang _ x2)
  
  module TwoPointed where
    record TwoPointed
      (A : Set) : Set where
      constructor TwoPointedC
      field
        e1 : A
        e2 : A
    record TwoPointedSig
      (AS : Set) : Set where
      constructor TwoPointedSigSigC
      field
        e1S : AS
        e2S : AS
    record TwoPointedProd
      (AP : Set) : Set where
      constructor TwoPointedProdC
      field
        e1P : Prod AP AP
        e2P : Prod AP AP
    record TwoPointedHom
      (A1 : Set) (A2 : Set)
      (Tw1 : TwoPointed A1)
      (Tw2 : TwoPointed A2) :
      Set where
      constructor TwoPointedHomC
      field
        hom : A1 -> A2
        pres-e1 : hom (e1 Tw1) == e1 Tw2
        pres-e2 : hom (e2 Tw1) == e2 Tw2
    record TwoPointedRelInterp
      (A1 : Set) (A2 : Set)
      (Tw1 : TwoPointed A1)
      (Tw2 : TwoPointed A2) :
      Set where
      constructor TwoPointedRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e1 :
          interp (e1 Tw1) (e1 Tw2)
        interp-e2 :
          interp (e2 Tw1) (e2 Tw2)
    data TwoPointedLang : Set where
      e1L : TwoPointedLang
      e2L : TwoPointedLang
    data TwoPointedOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> TwoPointedOpenLang n
      e1OL : TwoPointedOpenLang n
      e2OL : TwoPointedOpenLang n
    evalTerm :
      (A : Set) ->
      TwoPointed A ->
      TwoPointedLang -> A
    evalTerm _ Tw (e1L) = e1 Tw
    evalTerm _ Tw (e2L) = e2 Tw
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      TwoPointed A ->
      TwoPointedOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n tw (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n tw (e1OL) vars =
      e1 tw
    evalOpenTerm _ n tw (e2OL) vars =
      e2 tw
    simplify :
      TwoPointedLang -> TwoPointedLang
    simplify (e1L) = e1L
    simplify (e2L) = e2L
    liftTwoPointedLang :
      TwoPointedLang ->
      Staged TwoPointedLang
    liftTwoPointedLang x = Now x
    e1OL' :
      (n : Nat) ->
      TwoPointedOpenLang n
    e1OL' _ = e1OL
    e2OL' :
      (n : Nat) ->
      TwoPointedOpenLang n
    e2OL' _ = e2OL
    liftTwoPointedOpenLang :
      (n : Nat) ->
      TwoPointedOpenLang n ->
      Staged (TwoPointedOpenLang n)
    liftTwoPointedOpenLang _ (v
                              fin) = const _ (code _ (v fin))
    liftTwoPointedOpenLang _ (e1OL) =
      Now e1OL
    liftTwoPointedOpenLang _ (e2OL) =
      Now e2OL
  
  module TwoPointed01 where
    record TwoPointed01
      (A : Set) : Set where
      constructor TwoPointed01C
      field
        e1 : A
        e2 : A
    record TwoPointed01Sig
      (AS : Set) : Set where
      constructor TwoPointed01SigSigC
      field
        e1S : AS
        e2S : AS
    record TwoPointed01Prod
      (AP : Set) : Set where
      constructor TwoPointed01ProdC
      field
        e1P : Prod AP AP
        e2P : Prod AP AP
    record TwoPointed01Hom
      (A1 : Set) (A2 : Set)
      (Tw1 : TwoPointed01 A1)
      (Tw2 : TwoPointed01 A2) :
      Set where
      constructor TwoPointed01HomC
      field
        hom : A1 -> A2
        pres-e1 : hom (e1 Tw1) == e1 Tw2
        pres-e2 : hom (e2 Tw1) == e2 Tw2
    record TwoPointed01RelInterp
      (A1 : Set) (A2 : Set)
      (Tw1 : TwoPointed01 A1)
      (Tw2 : TwoPointed01 A2) :
      Set where
      constructor TwoPointed01RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e1 :
          interp (e1 Tw1) (e1 Tw2)
        interp-e2 :
          interp (e2 Tw1) (e2 Tw2)
    data TwoPointed01Lang
      : Set where
      e1L : TwoPointed01Lang
      e2L : TwoPointed01Lang
    data TwoPointed01OpenLang
      (n : Nat) : Set where
      v :
        Fin n -> TwoPointed01OpenLang n
      e1OL : TwoPointed01OpenLang n
      e2OL : TwoPointed01OpenLang n
    evalTerm :
      (A : Set) ->
      TwoPointed01 A ->
      TwoPointed01Lang -> A
    evalTerm _ Tw (e1L) = e1 Tw
    evalTerm _ Tw (e2L) = e2 Tw
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      TwoPointed01 A ->
      TwoPointed01OpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n tw (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n tw (e1OL) vars =
      e1 tw
    evalOpenTerm _ n tw (e2OL) vars =
      e2 tw
    simplify :
      TwoPointed01Lang ->
      TwoPointed01Lang
    simplify (e1L) = e1L
    simplify (e2L) = e2L
    liftTwoPointed01Lang :
      TwoPointed01Lang ->
      Staged TwoPointed01Lang
    liftTwoPointed01Lang x = Now x
    e1OL' :
      (n : Nat) ->
      TwoPointed01OpenLang n
    e1OL' _ = e1OL
    e2OL' :
      (n : Nat) ->
      TwoPointed01OpenLang n
    e2OL' _ = e2OL
    liftTwoPointed01OpenLang :
      (n : Nat) ->
      TwoPointed01OpenLang n ->
      Staged (TwoPointed01OpenLang n)
    liftTwoPointed01OpenLang _ (v
                                fin) = const _ (code _ (v fin))
    liftTwoPointed01OpenLang _ (e1OL) =
      Now e1OL
    liftTwoPointed01OpenLang _ (e2OL) =
      Now e2OL
  
  module UnaryAntiDistribution where
    record UnaryAntiDistribution
      (A : Set) : Set where
      constructor UnaryAntiDistributionC
      field
        prim : A -> A
        op : A -> A -> A
        antidis_prim_op :
          (x : A) (y : A) ->
          prim (op x y) ==
            op (prim y) (prim x)
    record UnaryAntiDistributionSig
      (AS : Set) : Set where
      constructor UnaryAntiDistributionSigSigC
      field
        primS : AS -> AS
        opS : AS -> AS -> AS
    record UnaryAntiDistributionProd
      (AP : Set) : Set where
      constructor UnaryAntiDistributionProdC
      field
        primP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        antidis_prim_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (opP xP yP) ==
            opP (primP yP) (primP xP)
    record UnaryAntiDistributionHom
      (A1 : Set) (A2 : Set)
      (Un1 : UnaryAntiDistribution A1)
      (Un2 : UnaryAntiDistribution
         A2) : Set where
      constructor UnaryAntiDistributionHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Un1 x1) ==
            prim Un2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Un1 x1 x2) ==
            op Un2 (hom x1) (hom x2)
    record UnaryAntiDistributionRelInterp
      (A1 : Set) (A2 : Set)
      (Un1 : UnaryAntiDistribution A1)
      (Un2 : UnaryAntiDistribution
         A2) : Set where
      constructor UnaryAntiDistributionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Un1 x1)
            (prim Un2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Un1 x1 x2)
            (op Un2 y1 y2)
    data UnaryAntiDistributionLang
      : Set where
      primL :
        UnaryAntiDistributionLang ->
        UnaryAntiDistributionLang
      opL :
        UnaryAntiDistributionLang ->
        UnaryAntiDistributionLang ->
        UnaryAntiDistributionLang
    data UnaryAntiDistributionOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        UnaryAntiDistributionOpenLang n
      primOL :
        UnaryAntiDistributionOpenLang
          n ->
        UnaryAntiDistributionOpenLang n
      opOL :
        UnaryAntiDistributionOpenLang
          n ->
        UnaryAntiDistributionOpenLang
          n ->
        UnaryAntiDistributionOpenLang n
    evalTerm :
      (A : Set) ->
      UnaryAntiDistribution A ->
      UnaryAntiDistributionLang -> A
    evalTerm _ Un (primL x1) =
      prim Un (evalTerm _ Un x1)
    evalTerm _ Un (opL x1 x2) =
      op Un (evalTerm _ Un x1)
        (evalTerm _ Un x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      UnaryAntiDistribution A ->
      UnaryAntiDistributionOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n un (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n un (primOL
                         x1) vars =
      prim un
        (evalOpenTerm _ n un x1 vars)
    evalOpenTerm _ n un (opOL
                         x1
                         x2) vars =
      op un
        (evalOpenTerm _ n un x1 vars)
        (evalOpenTerm _ n un x2 vars)
    simplify :
      UnaryAntiDistributionLang ->
      UnaryAntiDistributionLang
    simplify (opL
              (primL y)
              (primL x)) = primL (opL x y)
    simplify (primL x1) =
      primL (simplify x1)
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftUnaryAntiDistributionLang :
      UnaryAntiDistributionLang ->
      Staged UnaryAntiDistributionLang
    liftUnaryAntiDistributionLang x =
      Now x
    primOL' :
      (n : Nat) ->
      UnaryAntiDistributionOpenLang
        n ->
      UnaryAntiDistributionOpenLang n
    primOL' _ x1 = primOL x1
    opOL' :
      (n : Nat) ->
      UnaryAntiDistributionOpenLang
        n ->
      UnaryAntiDistributionOpenLang
        n ->
      UnaryAntiDistributionOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftUnaryAntiDistributionOpenLang :
      (n : Nat) ->
      UnaryAntiDistributionOpenLang
        n ->
      Staged
        (UnaryAntiDistributionOpenLang
           n)
    liftUnaryAntiDistributionOpenLang _ (v
                                         fin) = const _ (code _ (v fin))
    liftUnaryAntiDistributionOpenLang _ (primOL
                                         x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftUnaryAntiDistributionOpenLang
           _
           x1)
    liftUnaryAntiDistributionOpenLang _ (opOL
                                         x1
                                         x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftUnaryAntiDistributionOpenLang
           _
           x1)
        (liftUnaryAntiDistributionOpenLang
           _
           x2)
  
  module UnaryDistributes where
    record UnaryDistributes
      (A : Set) : Set where
      constructor UnaryDistributesC
      field
        prim : A -> A
        op : A -> A -> A
        distribute_prim_op :
          (x : A) (y : A) ->
          prim (op x y) ==
            op (prim x) (prim y)
    record UnaryDistributesSig
      (AS : Set) : Set where
      constructor UnaryDistributesSigSigC
      field
        primS : AS -> AS
        opS : AS -> AS -> AS
    record UnaryDistributesProd
      (AP : Set) : Set where
      constructor UnaryDistributesProdC
      field
        primP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        distribute_prim_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (opP xP yP) ==
            opP (primP xP) (primP yP)
    record UnaryDistributesHom
      (A1 : Set) (A2 : Set)
      (Un1 : UnaryDistributes A1)
      (Un2 : UnaryDistributes A2) :
      Set where
      constructor UnaryDistributesHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Un1 x1) ==
            prim Un2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Un1 x1 x2) ==
            op Un2 (hom x1) (hom x2)
    record UnaryDistributesRelInterp
      (A1 : Set) (A2 : Set)
      (Un1 : UnaryDistributes A1)
      (Un2 : UnaryDistributes A2) :
      Set where
      constructor UnaryDistributesRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Un1 x1)
            (prim Un2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Un1 x1 x2)
            (op Un2 y1 y2)
    data UnaryDistributesLang
      : Set where
      primL :
        UnaryDistributesLang ->
        UnaryDistributesLang
      opL :
        UnaryDistributesLang ->
        UnaryDistributesLang ->
        UnaryDistributesLang
    data UnaryDistributesOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        UnaryDistributesOpenLang n
      primOL :
        UnaryDistributesOpenLang n ->
        UnaryDistributesOpenLang n
      opOL :
        UnaryDistributesOpenLang n ->
        UnaryDistributesOpenLang n ->
        UnaryDistributesOpenLang n
    evalTerm :
      (A : Set) ->
      UnaryDistributes A ->
      UnaryDistributesLang -> A
    evalTerm _ Un (primL x1) =
      prim Un (evalTerm _ Un x1)
    evalTerm _ Un (opL x1 x2) =
      op Un (evalTerm _ Un x1)
        (evalTerm _ Un x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      UnaryDistributes A ->
      UnaryDistributesOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n un (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n un (primOL
                         x1) vars =
      prim un
        (evalOpenTerm _ n un x1 vars)
    evalOpenTerm _ n un (opOL
                         x1
                         x2) vars =
      op un
        (evalOpenTerm _ n un x1 vars)
        (evalOpenTerm _ n un x2 vars)
    simplify :
      UnaryDistributesLang ->
      UnaryDistributesLang
    simplify (opL
              (primL x)
              (primL y)) = primL (opL x y)
    simplify (primL x1) =
      primL (simplify x1)
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftUnaryDistributesLang :
      UnaryDistributesLang ->
      Staged UnaryDistributesLang
    liftUnaryDistributesLang x =
      Now x
    primOL' :
      (n : Nat) ->
      UnaryDistributesOpenLang n ->
      UnaryDistributesOpenLang n
    primOL' _ x1 = primOL x1
    opOL' :
      (n : Nat) ->
      UnaryDistributesOpenLang n ->
      UnaryDistributesOpenLang n ->
      UnaryDistributesOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftUnaryDistributesOpenLang :
      (n : Nat) ->
      UnaryDistributesOpenLang n ->
      Staged
        (UnaryDistributesOpenLang n)
    liftUnaryDistributesOpenLang _ (v
                                    fin) = const _ (code _ (v fin))
    liftUnaryDistributesOpenLang _ (primOL
                                    x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftUnaryDistributesOpenLang _
           x1)
    liftUnaryDistributesOpenLang _ (opOL
                                    x1
                                    x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftUnaryDistributesOpenLang _
           x1)
        (liftUnaryDistributesOpenLang _
           x2)
  
  module UnaryOperation where
    record UnaryOperation
      (A : Set) : Set where
      constructor UnaryOperationC
      field
        prim : A -> A
    record UnaryOperationSig
      (AS : Set) : Set where
      constructor UnaryOperationSigSigC
      field
        primS : AS -> AS
    record UnaryOperationProd
      (AP : Set) : Set where
      constructor UnaryOperationProdC
      field
        primP : Prod AP AP -> Prod AP AP
    record UnaryOperationHom
      (A1 : Set) (A2 : Set)
      (Un1 : UnaryOperation A1)
      (Un2 : UnaryOperation A2) :
      Set where
      constructor UnaryOperationHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Un1 x1) ==
            prim Un2 (hom x1)
    record UnaryOperationRelInterp
      (A1 : Set) (A2 : Set)
      (Un1 : UnaryOperation A1)
      (Un2 : UnaryOperation A2) :
      Set where
      constructor UnaryOperationRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Un1 x1)
            (prim Un2 y1)
    data UnaryOperationLang
      : Set where
      primL :
        UnaryOperationLang ->
        UnaryOperationLang
    data UnaryOperationOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        UnaryOperationOpenLang n
      primOL :
        UnaryOperationOpenLang n ->
        UnaryOperationOpenLang n
    evalTerm :
      (A : Set) ->
      UnaryOperation A ->
      UnaryOperationLang -> A
    evalTerm _ Un (primL x1) =
      prim Un (evalTerm _ Un x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      UnaryOperation A ->
      UnaryOperationOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n un (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n un (primOL
                         x1) vars =
      prim un
        (evalOpenTerm _ n un x1 vars)
    simplify :
      UnaryOperationLang ->
      UnaryOperationLang
    simplify (primL x1) =
      primL (simplify x1)
    liftUnaryOperationLang :
      UnaryOperationLang ->
      Staged UnaryOperationLang
    liftUnaryOperationLang x = Now x
    primOL' :
      (n : Nat) ->
      UnaryOperationOpenLang n ->
      UnaryOperationOpenLang n
    primOL' _ x1 = primOL x1
    liftUnaryOperationOpenLang :
      (n : Nat) ->
      UnaryOperationOpenLang n ->
      Staged
        (UnaryOperationOpenLang n)
    liftUnaryOperationOpenLang _ (v
                                  fin) = const _ (code _ (v fin))
    liftUnaryOperationOpenLang _ (primOL
                                  x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (liftUnaryOperationOpenLang _
           x1)
  
  module UnipotentPointedMagma where
    record UnipotentPointedMagma
      (A : Set) : Set where
      constructor UnipotentPointedMagmaC
      field
        e : A
        op : A -> A -> A
        unipotence :
          (x : A) -> op x x == e
    record UnipotentPointedMagmaSig
      (AS : Set) : Set where
      constructor UnipotentPointedMagmaSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record UnipotentPointedMagmaProd
      (AP : Set) : Set where
      constructor UnipotentPointedMagmaProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        unipotenceP :
          (xP : Prod AP AP) ->
          opP xP xP == eP
    record UnipotentPointedMagmaHom
      (A1 : Set) (A2 : Set)
      (Un1 : UnipotentPointedMagma A1)
      (Un2 : UnipotentPointedMagma
         A2) : Set where
      constructor UnipotentPointedMagmaHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Un1) == e Un2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Un1 x1 x2) ==
            op Un2 (hom x1) (hom x2)
    record UnipotentPointedMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Un1 : UnipotentPointedMagma A1)
      (Un2 : UnipotentPointedMagma
         A2) : Set where
      constructor UnipotentPointedMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Un1) (e Un2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Un1 x1 x2)
            (op Un2 y1 y2)
    data UnipotentPointedMagmaLang
      : Set where
      eL : UnipotentPointedMagmaLang
      opL :
        UnipotentPointedMagmaLang ->
        UnipotentPointedMagmaLang ->
        UnipotentPointedMagmaLang
    data UnipotentPointedMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        UnipotentPointedMagmaOpenLang n
      eOL :
        UnipotentPointedMagmaOpenLang n
      opOL :
        UnipotentPointedMagmaOpenLang
          n ->
        UnipotentPointedMagmaOpenLang
          n ->
        UnipotentPointedMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      UnipotentPointedMagma A ->
      UnipotentPointedMagmaLang -> A
    evalTerm _ Un (eL) = e Un
    evalTerm _ Un (opL x1 x2) =
      op Un (evalTerm _ Un x1)
        (evalTerm _ Un x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      UnipotentPointedMagma A ->
      UnipotentPointedMagmaOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n un (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n un (eOL) vars =
      e un
    evalOpenTerm _ n un (opOL
                         x1
                         x2) vars =
      op un
        (evalOpenTerm _ n un x1 vars)
        (evalOpenTerm _ n un x2 vars)
    simplify :
      UnipotentPointedMagmaLang ->
      UnipotentPointedMagmaLang
    simplify (opL x x) = eL
    simplify (eL) = eL
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftUnipotentPointedMagmaLang :
      UnipotentPointedMagmaLang ->
      Staged UnipotentPointedMagmaLang
    liftUnipotentPointedMagmaLang x =
      Now x
    eOL' :
      (n : Nat) ->
      UnipotentPointedMagmaOpenLang n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      UnipotentPointedMagmaOpenLang
        n ->
      UnipotentPointedMagmaOpenLang
        n ->
      UnipotentPointedMagmaOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftUnipotentPointedMagmaOpenLang :
      (n : Nat) ->
      UnipotentPointedMagmaOpenLang
        n ->
      Staged
        (UnipotentPointedMagmaOpenLang
           n)
    liftUnipotentPointedMagmaOpenLang _ (v
                                         fin) = const _ (code _ (v fin))
    liftUnipotentPointedMagmaOpenLang _ (eOL) =
      Now eOL
    liftUnipotentPointedMagmaOpenLang _ (opOL
                                         x1
                                         x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftUnipotentPointedMagmaOpenLang
           _
           x1)
        (liftUnipotentPointedMagmaOpenLang
           _
           x2)
  
  module Unital where
    record Unital
      (A : Set) : Set where
      constructor UnitalC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
    record UnitalSig
      (AS : Set) : Set where
      constructor UnitalSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record UnitalProd
      (AP : Set) : Set where
      constructor UnitalProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
    record UnitalHom
      (A1 : Set) (A2 : Set)
      (Un1 : Unital A1)
      (Un2 : Unital A2) : Set where
      constructor UnitalHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Un1) == e Un2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Un1 x1 x2) ==
            op Un2 (hom x1) (hom x2)
    record UnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Un1 : Unital A1)
      (Un2 : Unital A2) : Set where
      constructor UnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Un1) (e Un2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Un1 x1 x2)
            (op Un2 y1 y2)
    data UnitalLang : Set where
      eL : UnitalLang
      opL :
        UnitalLang ->
        UnitalLang -> UnitalLang
    data UnitalOpenLang
      (n : Nat) : Set where
      v : Fin n -> UnitalOpenLang n
      eOL : UnitalOpenLang n
      opOL :
        UnitalOpenLang n ->
        UnitalOpenLang n ->
        UnitalOpenLang n
    evalTerm :
      (A : Set) ->
      Unital A -> UnitalLang -> A
    evalTerm _ Un (eL) = e Un
    evalTerm _ Un (opL x1 x2) =
      op Un (evalTerm _ Un x1)
        (evalTerm _ Un x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Unital A ->
      UnitalOpenLang n -> Vec A n -> A
    evalOpenTerm _ n un (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n un (eOL) vars =
      e un
    evalOpenTerm _ n un (opOL
                         x1
                         x2) vars =
      op un
        (evalOpenTerm _ n un x1 vars)
        (evalOpenTerm _ n un x2 vars)
    simplify :
      UnitalLang -> UnitalLang
    simplify (opL (eL) x) = x
    simplify (opL x (eL)) = x
    simplify (eL) = eL
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftUnitalLang :
      UnitalLang -> Staged UnitalLang
    liftUnitalLang x = Now x
    eOL' :
      (n : Nat) -> UnitalOpenLang n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      UnitalOpenLang n ->
      UnitalOpenLang n ->
      UnitalOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftUnitalOpenLang :
      (n : Nat) ->
      UnitalOpenLang n ->
      Staged (UnitalOpenLang n)
    liftUnitalOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftUnitalOpenLang _ (eOL) =
      Now eOL
    liftUnitalOpenLang _ (opOL
                          x1
                          x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftUnitalOpenLang _ x1)
        (liftUnitalOpenLang _ x2)
  
  module Zero where
    record Zero
      (A : Set) : Set where
      constructor ZeroC
      field
        e : A
        op : A -> A -> A
        leftZero_op_e :
          (x : A) -> op e x == e
        rightZero_op_e :
          (x : A) -> op x e == e
    record ZeroSig
      (AS : Set) : Set where
      constructor ZeroSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record ZeroProd
      (AP : Set) : Set where
      constructor ZeroProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftZero_op_eP :
          (xP : Prod AP AP) ->
          opP eP xP == eP
        rightZero_op_eP :
          (xP : Prod AP AP) ->
          opP xP eP == eP
    record ZeroHom
      (A1 : Set) (A2 : Set)
      (Ze1 : Zero A1)
      (Ze2 : Zero A2) : Set where
      constructor ZeroHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Ze1) == e Ze2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ze1 x1 x2) ==
            op Ze2 (hom x1) (hom x2)
    record ZeroRelInterp
      (A1 : Set) (A2 : Set)
      (Ze1 : Zero A1)
      (Ze2 : Zero A2) : Set where
      constructor ZeroRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Ze1) (e Ze2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ze1 x1 x2)
            (op Ze2 y1 y2)
    data ZeroLang : Set where
      eL : ZeroLang
      opL :
        ZeroLang -> ZeroLang -> ZeroLang
    data ZeroOpenLang
      (n : Nat) : Set where
      v : Fin n -> ZeroOpenLang n
      eOL : ZeroOpenLang n
      opOL :
        ZeroOpenLang n ->
        ZeroOpenLang n -> ZeroOpenLang n
    evalTerm :
      (A : Set) ->
      Zero A -> ZeroLang -> A
    evalTerm _ Ze (eL) = e Ze
    evalTerm _ Ze (opL x1 x2) =
      op Ze (evalTerm _ Ze x1)
        (evalTerm _ Ze x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Zero A ->
      ZeroOpenLang n -> Vec A n -> A
    evalOpenTerm _ n ze (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ze (eOL) vars =
      e ze
    evalOpenTerm _ n ze (opOL
                         x1
                         x2) vars =
      op ze
        (evalOpenTerm _ n ze x1 vars)
        (evalOpenTerm _ n ze x2 vars)
    simplify : ZeroLang -> ZeroLang
    simplify (opL (eL) x) = eL
    simplify (opL x (eL)) = eL
    simplify (eL) = eL
    simplify (opL x1 x2) =
      opL (simplify x1) (simplify x2)
    liftZeroLang :
      ZeroLang -> Staged ZeroLang
    liftZeroLang x = Now x
    eOL' :
      (n : Nat) -> ZeroOpenLang n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      ZeroOpenLang n ->
      ZeroOpenLang n -> ZeroOpenLang n
    opOL' _ x1 x2 = opOL x1 x2
    liftZeroOpenLang :
      (n : Nat) ->
      ZeroOpenLang n ->
      Staged (ZeroOpenLang n)
    liftZeroOpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftZeroOpenLang _ (eOL) =
      Now eOL
    liftZeroOpenLang _ (opOL
                        x1
                        x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (liftZeroOpenLang _ x1)
        (liftZeroOpenLang _ x2)
  
  module Zero0 where
    record Zero0
      (A : Set) : Set where
      constructor Zero0C
      field
        0 : A
        * : A -> A -> A
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
    record Zero0Sig
      (AS : Set) : Set where
      constructor Zero0SigSigC
      field
        0S : AS
        *S : AS -> AS -> AS
    record Zero0Prod
      (AP : Set) : Set where
      constructor Zero0ProdC
      field
        0P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
    record Zero0Hom
      (A1 : Set) (A2 : Set)
      (Ze1 : Zero0 A1)
      (Ze2 : Zero0 A2) : Set where
      constructor Zero0HomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ze1) == 0 Ze2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ze1 x1 x2) ==
            * Ze2 (hom x1) (hom x2)
    record Zero0RelInterp
      (A1 : Set) (A2 : Set)
      (Ze1 : Zero0 A1)
      (Ze2 : Zero0 A2) : Set where
      constructor Zero0RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ze1) (0 Ze2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ze1 x1 x2)
            (* Ze2 y1 y2)
    data Zero0Lang : Set where
      0L : Zero0Lang
      *L :
        Zero0Lang ->
        Zero0Lang -> Zero0Lang
    data Zero0OpenLang
      (n : Nat) : Set where
      v : Fin n -> Zero0OpenLang n
      0OL : Zero0OpenLang n
      *OL :
        Zero0OpenLang n ->
        Zero0OpenLang n ->
        Zero0OpenLang n
    evalTerm :
      (A : Set) ->
      Zero0 A -> Zero0Lang -> A
    evalTerm _ Ze (0L) = 0 Ze
    evalTerm _ Ze (*L x1 x2) =
      * Ze (evalTerm _ Ze x1)
        (evalTerm _ Ze x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Zero0 A ->
      Zero0OpenLang n -> Vec A n -> A
    evalOpenTerm _ n ze (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ze (0OL) vars =
      0 ze
    evalOpenTerm _ n ze (*OL
                         x1
                         x2) vars =
      * ze
        (evalOpenTerm _ n ze x1 vars)
        (evalOpenTerm _ n ze x2 vars)
    simplify :
      Zero0Lang -> Zero0Lang
    simplify (*L (0L) x) = 0L
    simplify (*L x (0L)) = 0L
    simplify (0L) = 0L
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    liftZero0Lang :
      Zero0Lang -> Staged Zero0Lang
    liftZero0Lang x = Now x
    0OL' :
      (n : Nat) -> Zero0OpenLang n
    0OL' _ = 0OL
    *OL' :
      (n : Nat) ->
      Zero0OpenLang n ->
      Zero0OpenLang n ->
      Zero0OpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    liftZero0OpenLang :
      (n : Nat) ->
      Zero0OpenLang n ->
      Staged (Zero0OpenLang n)
    liftZero0OpenLang _ (v fin) =
      const _ (code _ (v fin))
    liftZero0OpenLang _ (0OL) =
      Now 0OL
    liftZero0OpenLang _ (*OL
                         x1
                         x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftZero0OpenLang _ x1)
        (liftZero0OpenLang _ x2)
  
  module Zero_Ringoid0Sig where
    record Zero_Ringoid0Sig
      (A : Set) : Set where
      constructor Zero_Ringoid0SigC
      field
        0 : A
        * : A -> A -> A
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
        + : A -> A -> A
    record Zero_Ringoid0SigSig
      (AS : Set) : Set where
      constructor Zero_Ringoid0SigSigSigC
      field
        0S : AS
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record Zero_Ringoid0SigProd
      (AP : Set) : Set where
      constructor Zero_Ringoid0SigProdC
      field
        0P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
    record Zero_Ringoid0SigHom
      (A1 : Set) (A2 : Set)
      (Ze1 : Zero_Ringoid0Sig A1)
      (Ze2 : Zero_Ringoid0Sig A2) :
      Set where
      constructor Zero_Ringoid0SigHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ze1) == 0 Ze2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ze1 x1 x2) ==
            * Ze2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ze1 x1 x2) ==
            + Ze2 (hom x1) (hom x2)
    record Zero_Ringoid0SigRelInterp
      (A1 : Set) (A2 : Set)
      (Ze1 : Zero_Ringoid0Sig A1)
      (Ze2 : Zero_Ringoid0Sig A2) :
      Set where
      constructor Zero_Ringoid0SigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ze1) (0 Ze2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ze1 x1 x2)
            (* Ze2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ze1 x1 x2)
            (+ Ze2 y1 y2)
    data Zero_Ringoid0SigLang
      : Set where
      0L : Zero_Ringoid0SigLang
      *L :
        Zero_Ringoid0SigLang ->
        Zero_Ringoid0SigLang ->
        Zero_Ringoid0SigLang
      +L :
        Zero_Ringoid0SigLang ->
        Zero_Ringoid0SigLang ->
        Zero_Ringoid0SigLang
    data Zero_Ringoid0SigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        Zero_Ringoid0SigOpenLang n
      0OL : Zero_Ringoid0SigOpenLang n
      *OL :
        Zero_Ringoid0SigOpenLang n ->
        Zero_Ringoid0SigOpenLang n ->
        Zero_Ringoid0SigOpenLang n
      +OL :
        Zero_Ringoid0SigOpenLang n ->
        Zero_Ringoid0SigOpenLang n ->
        Zero_Ringoid0SigOpenLang n
    evalTerm :
      (A : Set) ->
      Zero_Ringoid0Sig A ->
      Zero_Ringoid0SigLang -> A
    evalTerm _ Ze (0L) = 0 Ze
    evalTerm _ Ze (*L x1 x2) =
      * Ze (evalTerm _ Ze x1)
        (evalTerm _ Ze x2)
    evalTerm _ Ze (+L x1 x2) =
      + Ze (evalTerm _ Ze x1)
        (evalTerm _ Ze x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Zero_Ringoid0Sig A ->
      Zero_Ringoid0SigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ze (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ze (0OL) vars =
      0 ze
    evalOpenTerm _ n ze (*OL
                         x1
                         x2) vars =
      * ze
        (evalOpenTerm _ n ze x1 vars)
        (evalOpenTerm _ n ze x2 vars)
    evalOpenTerm _ n ze (+OL
                         x1
                         x2) vars =
      + ze
        (evalOpenTerm _ n ze x1 vars)
        (evalOpenTerm _ n ze x2 vars)
    simplify :
      Zero_Ringoid0SigLang ->
      Zero_Ringoid0SigLang
    simplify (*L (0L) x) = 0L
    simplify (*L x (0L)) = 0L
    simplify (0L) = 0L
    simplify (*L x1 x2) =
      *L (simplify x1) (simplify x2)
    simplify (+L x1 x2) =
      +L (simplify x1) (simplify x2)
    liftZero_Ringoid0SigLang :
      Zero_Ringoid0SigLang ->
      Staged Zero_Ringoid0SigLang
    liftZero_Ringoid0SigLang x =
      Now x
    0OL' :
      (n : Nat) ->
      Zero_Ringoid0SigOpenLang n
    0OL' _ = 0OL
    *OL' :
      (n : Nat) ->
      Zero_Ringoid0SigOpenLang n ->
      Zero_Ringoid0SigOpenLang n ->
      Zero_Ringoid0SigOpenLang n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      Zero_Ringoid0SigOpenLang n ->
      Zero_Ringoid0SigOpenLang n ->
      Zero_Ringoid0SigOpenLang n
    +OL' _ x1 x2 = +OL x1 x2
    liftZero_Ringoid0SigOpenLang :
      (n : Nat) ->
      Zero_Ringoid0SigOpenLang n ->
      Staged
        (Zero_Ringoid0SigOpenLang n)
    liftZero_Ringoid0SigOpenLang _ (v
                                    fin) = const _ (code _ (v fin))
    liftZero_Ringoid0SigOpenLang _ (0OL) =
      Now 0OL
    liftZero_Ringoid0SigOpenLang _ (*OL
                                    x1
                                    x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (liftZero_Ringoid0SigOpenLang _
           x1)
        (liftZero_Ringoid0SigOpenLang _
           x2)
    liftZero_Ringoid0SigOpenLang _ (+OL
                                    x1
                                    x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (liftZero_Ringoid0SigOpenLang _
           x1)
        (liftZero_Ringoid0SigOpenLang _
           x2)
  

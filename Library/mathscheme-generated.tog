------------------------------------------------------------------------
-- Checking declarations
------------------------------------------------------------------------
-- Solved Metas: 146501
-- Unsolved Metas: 0
------------------------------------------------------------------------
-- Unsolved problems: 0
------------------------------------------------------------------------
module MathScheme where
  data Prod
    (A : Set) (B : Set) : Set where
    
  data Nat : Set where
    zero : Nat
    succ : Nat -> Nat
  data Fin (n : Nat) : Set where
    fzero :
      (m : Nat) (p : n == succ m) ->
      Fin n
    fsuc :
      (m : Nat) (p : n == succ m)
      (i : Fin m) -> Fin n
  module AbelianAdditiveGroup where
    record AbelianAdditiveGroup
      (A : Set) : Set where
      constructor AbelianAdditiveGroupC
      field
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
    record AbelianAdditiveGroupSig
      (AS : Set) : Set where
      constructor AbelianAdditiveGroupSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
    record AbelianAdditiveGroupProd
      (AP : Set) : Set where
      constructor AbelianAdditiveGroupProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
    record AbelianAdditiveGroupHom
      (A1 : Set) (A2 : Set)
      (Ab1 : AbelianAdditiveGroup A1)
      (Ab2 : AbelianAdditiveGroup
         A2) : Set where
      constructor AbelianAdditiveGroupHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ab1 x1 x2) ==
            + Ab2 (hom x1) (hom x2)
        pres-0 : hom (0 Ab1) == 0 Ab2
        pres-neg :
          (x1 : A1) ->
          hom (neg Ab1 x1) ==
            neg Ab2 (hom x1)
    record AbelianAdditiveGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ab1 : AbelianAdditiveGroup A1)
      (Ab2 : AbelianAdditiveGroup
         A2) : Set where
      constructor AbelianAdditiveGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ab1 x1 x2)
            (+ Ab2 y1 y2)
        interp-0 :
          interp (0 Ab1) (0 Ab2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Ab1 x1) (neg Ab2 y1)
    data AbelianAdditiveGroupLang
      : Set where
      +L :
        AbelianAdditiveGroupLang ->
        AbelianAdditiveGroupLang ->
        AbelianAdditiveGroupLang
      0L : AbelianAdditiveGroupLang
      negL :
        AbelianAdditiveGroupLang ->
        AbelianAdditiveGroupLang
    data AbelianAdditiveGroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        AbelianAdditiveGroupOpenLang
      +OL :
        AbelianAdditiveGroupOpenLang ->
        AbelianAdditiveGroupOpenLang ->
        AbelianAdditiveGroupOpenLang
      0OL :
        AbelianAdditiveGroupOpenLang
      negOL :
        AbelianAdditiveGroupOpenLang ->
        AbelianAdditiveGroupOpenLang
  
  module AbelianGroup where
    record AbelianGroup
      (A : Set) : Set where
      constructor AbelianGroupC
      field
        1 : A
        * : A -> A -> A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        inv : A -> A
        leftInverse_inv_op_1 :
          (x : A) -> * x (inv x) == 1
        rightInverse_inv_op_1 :
          (x : A) -> * (inv x) x == 1
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
    record AbelianGroupSig
      (AS : Set) : Set where
      constructor AbelianGroupSigSigC
      field
        1S : AS
        *S : AS -> AS -> AS
        invS : AS -> AS
    record AbelianGroupProd
      (AP : Set) : Set where
      constructor AbelianGroupProdC
      field
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P xP (invP xP) == 1P
        rightInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P (invP xP) xP == 1P
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
    record AbelianGroupHom
      (A1 : Set) (A2 : Set)
      (Ab1 : AbelianGroup A1)
      (Ab2 : AbelianGroup A2) :
      Set where
      constructor AbelianGroupHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Ab1) == 1 Ab2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ab1 x1 x2) ==
            * Ab2 (hom x1) (hom x2)
        pres-inv :
          (x1 : A1) ->
          hom (inv Ab1 x1) ==
            inv Ab2 (hom x1)
    record AbelianGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ab1 : AbelianGroup A1)
      (Ab2 : AbelianGroup A2) :
      Set where
      constructor AbelianGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Ab1) (1 Ab2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ab1 x1 x2)
            (* Ab2 y1 y2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Ab1 x1) (inv Ab2 y1)
    data AbelianGroupLang
      : Set where
      1L : AbelianGroupLang
      *L :
        AbelianGroupLang ->
        AbelianGroupLang ->
        AbelianGroupLang
      invL :
        AbelianGroupLang ->
        AbelianGroupLang
    data AbelianGroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> AbelianGroupOpenLang
      1OL : AbelianGroupOpenLang
      *OL :
        AbelianGroupOpenLang ->
        AbelianGroupOpenLang ->
        AbelianGroupOpenLang
      invOL :
        AbelianGroupOpenLang ->
        AbelianGroupOpenLang
  
  module Absorption where
    record Absorption
      (A : Set) : Set where
      constructor AbsorptionC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
    record AbsorptionSig
      (AS : Set) : Set where
      constructor AbsorptionSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record AbsorptionProd
      (AP : Set) : Set where
      constructor AbsorptionProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
    record AbsorptionHom
      (A1 : Set) (A2 : Set)
      (Ab1 : Absorption A1)
      (Ab2 : Absorption A2) :
      Set where
      constructor AbsorptionHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ab1 x1 x2) ==
            * Ab2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ab1 x1 x2) ==
            + Ab2 (hom x1) (hom x2)
    record AbsorptionRelInterp
      (A1 : Set) (A2 : Set)
      (Ab1 : Absorption A1)
      (Ab2 : Absorption A2) :
      Set where
      constructor AbsorptionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ab1 x1 x2)
            (* Ab2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ab1 x1 x2)
            (+ Ab2 y1 y2)
    data AbsorptionLang : Set where
      *L :
        AbsorptionLang ->
        AbsorptionLang -> AbsorptionLang
      +L :
        AbsorptionLang ->
        AbsorptionLang -> AbsorptionLang
    data AbsorptionOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> AbsorptionOpenLang
      *OL :
        AbsorptionOpenLang ->
        AbsorptionOpenLang ->
        AbsorptionOpenLang
      +OL :
        AbsorptionOpenLang ->
        AbsorptionOpenLang ->
        AbsorptionOpenLang
  
  module AddCommMonWithMultMagma where
    record AddCommMonWithMultMagma
      (A : Set) : Set where
      constructor AddCommMonWithMultMagmaC
      field
        0 : A
        + : A -> A -> A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        * : A -> A -> A
    record AddCommMonWithMultMagmaSig
      (AS : Set) : Set where
      constructor AddCommMonWithMultMagmaSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
    record AddCommMonWithMultMagmaProd
      (AP : Set) : Set where
      constructor AddCommMonWithMultMagmaProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
    record AddCommMonWithMultMagmaHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AddCommMonWithMultMagma
         A1)
      (Ad2 : AddCommMonWithMultMagma
         A2) : Set where
      constructor AddCommMonWithMultMagmaHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ad1 x1 x2) ==
            * Ad2 (hom x1) (hom x2)
    record AddCommMonWithMultMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AddCommMonWithMultMagma
         A1)
      (Ad2 : AddCommMonWithMultMagma
         A2) : Set where
      constructor AddCommMonWithMultMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ad1 x1 x2)
            (* Ad2 y1 y2)
    data AddCommMonWithMultMagmaLang
      : Set where
      0L :
        AddCommMonWithMultMagmaLang
      +L :
        AddCommMonWithMultMagmaLang ->
        AddCommMonWithMultMagmaLang ->
        AddCommMonWithMultMagmaLang
      *L :
        AddCommMonWithMultMagmaLang ->
        AddCommMonWithMultMagmaLang ->
        AddCommMonWithMultMagmaLang
    data AddCommMonWithMultMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        AddCommMonWithMultMagmaOpenLang
      0OL :
        AddCommMonWithMultMagmaOpenLang
      +OL :
        AddCommMonWithMultMagmaOpenLang ->
        AddCommMonWithMultMagmaOpenLang ->
        AddCommMonWithMultMagmaOpenLang
      *OL :
        AddCommMonWithMultMagmaOpenLang ->
        AddCommMonWithMultMagmaOpenLang ->
        AddCommMonWithMultMagmaOpenLang
  
  module AddCommMonWithMultSemigroup where
    record AddCommMonWithMultSemigroup
      (A : Set) : Set where
      constructor AddCommMonWithMultSemigroupC
      field
        * : A -> A -> A
        0 : A
        + : A -> A -> A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
    record AddCommMonWithMultSemigroupSig
      (AS : Set) : Set where
      constructor AddCommMonWithMultSemigroupSigSigC
      field
        *S : AS -> AS -> AS
        0S : AS
        +S : AS -> AS -> AS
    record AddCommMonWithMultSemigroupProd
      (AP : Set) : Set where
      constructor AddCommMonWithMultSemigroupProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
    record AddCommMonWithMultSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AddCommMonWithMultSemigroup
         A1)
      (Ad2 : AddCommMonWithMultSemigroup
         A2) : Set where
      constructor AddCommMonWithMultSemigroupHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ad1 x1 x2) ==
            * Ad2 (hom x1) (hom x2)
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AddCommMonWithMultSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AddCommMonWithMultSemigroup
         A1)
      (Ad2 : AddCommMonWithMultSemigroup
         A2) : Set where
      constructor AddCommMonWithMultSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ad1 x1 x2)
            (* Ad2 y1 y2)
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AddCommMonWithMultSemigroupLang
      : Set where
      *L :
        AddCommMonWithMultSemigroupLang ->
        AddCommMonWithMultSemigroupLang ->
        AddCommMonWithMultSemigroupLang
      0L :
        AddCommMonWithMultSemigroupLang
      +L :
        AddCommMonWithMultSemigroupLang ->
        AddCommMonWithMultSemigroupLang ->
        AddCommMonWithMultSemigroupLang
    data AddCommMonWithMultSemigroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        AddCommMonWithMultSemigroupOpenLang
      *OL :
        AddCommMonWithMultSemigroupOpenLang ->
        AddCommMonWithMultSemigroupOpenLang ->
        AddCommMonWithMultSemigroupOpenLang
      0OL :
        AddCommMonWithMultSemigroupOpenLang
      +OL :
        AddCommMonWithMultSemigroupOpenLang ->
        AddCommMonWithMultSemigroupOpenLang ->
        AddCommMonWithMultSemigroupOpenLang
  
  module AddGroup_RingoidSig where
    record AddGroup_RingoidSig
      (A : Set) : Set where
      constructor AddGroup_RingoidSigC
      field
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        * : A -> A -> A
    record AddGroup_RingoidSigSig
      (AS : Set) : Set where
      constructor AddGroup_RingoidSigSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
        *S : AS -> AS -> AS
    record AddGroup_RingoidSigProd
      (AP : Set) : Set where
      constructor AddGroup_RingoidSigProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
    record AddGroup_RingoidSigHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AddGroup_RingoidSig A1)
      (Ad2 : AddGroup_RingoidSig A2) :
      Set where
      constructor AddGroup_RingoidSigHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-neg :
          (x1 : A1) ->
          hom (neg Ad1 x1) ==
            neg Ad2 (hom x1)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ad1 x1 x2) ==
            * Ad2 (hom x1) (hom x2)
    record AddGroup_RingoidSigRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AddGroup_RingoidSig A1)
      (Ad2 : AddGroup_RingoidSig A2) :
      Set where
      constructor AddGroup_RingoidSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Ad1 x1) (neg Ad2 y1)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ad1 x1 x2)
            (* Ad2 y1 y2)
    data AddGroup_RingoidSigLang
      : Set where
      +L :
        AddGroup_RingoidSigLang ->
        AddGroup_RingoidSigLang ->
        AddGroup_RingoidSigLang
      0L : AddGroup_RingoidSigLang
      negL :
        AddGroup_RingoidSigLang ->
        AddGroup_RingoidSigLang
      *L :
        AddGroup_RingoidSigLang ->
        AddGroup_RingoidSigLang ->
        AddGroup_RingoidSigLang
    data AddGroup_RingoidSigOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        AddGroup_RingoidSigOpenLang
      +OL :
        AddGroup_RingoidSigOpenLang ->
        AddGroup_RingoidSigOpenLang ->
        AddGroup_RingoidSigOpenLang
      0OL :
        AddGroup_RingoidSigOpenLang
      negOL :
        AddGroup_RingoidSigOpenLang ->
        AddGroup_RingoidSigOpenLang
      *OL :
        AddGroup_RingoidSigOpenLang ->
        AddGroup_RingoidSigOpenLang ->
        AddGroup_RingoidSigOpenLang
  
  module AdditiveCommutativeMonoid where
    record AdditiveCommutativeMonoid
      (A : Set) : Set where
      constructor AdditiveCommutativeMonoidC
      field
        0 : A
        + : A -> A -> A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
    record AdditiveCommutativeMonoidSig
      (AS : Set) : Set where
      constructor AdditiveCommutativeMonoidSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
    record AdditiveCommutativeMonoidProd
      (AP : Set) : Set where
      constructor AdditiveCommutativeMonoidProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
    record AdditiveCommutativeMonoidHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveCommutativeMonoid
         A1)
      (Ad2 : AdditiveCommutativeMonoid
         A2) : Set where
      constructor AdditiveCommutativeMonoidHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveCommutativeMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveCommutativeMonoid
         A1)
      (Ad2 : AdditiveCommutativeMonoid
         A2) : Set where
      constructor AdditiveCommutativeMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveCommutativeMonoidLang
      : Set where
      0L :
        AdditiveCommutativeMonoidLang
      +L :
        AdditiveCommutativeMonoidLang ->
        AdditiveCommutativeMonoidLang ->
        AdditiveCommutativeMonoidLang
    data AdditiveCommutativeMonoidOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        AdditiveCommutativeMonoidOpenLang
      0OL :
        AdditiveCommutativeMonoidOpenLang
      +OL :
        AdditiveCommutativeMonoidOpenLang ->
        AdditiveCommutativeMonoidOpenLang ->
        AdditiveCommutativeMonoidOpenLang
  
  module AdditiveCommutativeSemigroup where
    record AdditiveCommutativeSemigroup
      (A : Set) : Set where
      constructor AdditiveCommutativeSemigroupC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record AdditiveCommutativeSemigroupSig
      (AS : Set) : Set where
      constructor AdditiveCommutativeSemigroupSigSigC
      field
        +S : AS -> AS -> AS
    record AdditiveCommutativeSemigroupProd
      (AP : Set) : Set where
      constructor AdditiveCommutativeSemigroupProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record AdditiveCommutativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveCommutativeSemigroup
         A1)
      (Ad2 : AdditiveCommutativeSemigroup
         A2) : Set where
      constructor AdditiveCommutativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveCommutativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveCommutativeSemigroup
         A1)
      (Ad2 : AdditiveCommutativeSemigroup
         A2) : Set where
      constructor AdditiveCommutativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveCommutativeSemigroupLang
      : Set where
      +L :
        AdditiveCommutativeSemigroupLang ->
        AdditiveCommutativeSemigroupLang ->
        AdditiveCommutativeSemigroupLang
    data AdditiveCommutativeSemigroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        AdditiveCommutativeSemigroupOpenLang
      +OL :
        AdditiveCommutativeSemigroupOpenLang ->
        AdditiveCommutativeSemigroupOpenLang ->
        AdditiveCommutativeSemigroupOpenLang
  
  module AdditiveGroup where
    record AdditiveGroup
      (A : Set) : Set where
      constructor AdditiveGroupC
      field
        0 : A
        + : A -> A -> A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
    record AdditiveGroupSig
      (AS : Set) : Set where
      constructor AdditiveGroupSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        negS : AS -> AS
    record AdditiveGroupProd
      (AP : Set) : Set where
      constructor AdditiveGroupProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
    record AdditiveGroupHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveGroup A1)
      (Ad2 : AdditiveGroup A2) :
      Set where
      constructor AdditiveGroupHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
        pres-neg :
          (x1 : A1) ->
          hom (neg Ad1 x1) ==
            neg Ad2 (hom x1)
    record AdditiveGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveGroup A1)
      (Ad2 : AdditiveGroup A2) :
      Set where
      constructor AdditiveGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Ad1 x1) (neg Ad2 y1)
    data AdditiveGroupLang
      : Set where
      0L : AdditiveGroupLang
      +L :
        AdditiveGroupLang ->
        AdditiveGroupLang ->
        AdditiveGroupLang
      negL :
        AdditiveGroupLang ->
        AdditiveGroupLang
    data AdditiveGroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> AdditiveGroupOpenLang
      0OL : AdditiveGroupOpenLang
      +OL :
        AdditiveGroupOpenLang ->
        AdditiveGroupOpenLang ->
        AdditiveGroupOpenLang
      negOL :
        AdditiveGroupOpenLang ->
        AdditiveGroupOpenLang
  
  module AdditiveMagma where
    record AdditiveMagma
      (A : Set) : Set where
      constructor AdditiveMagmaC
      field
        + : A -> A -> A
    record AdditiveMagmaSig
      (AS : Set) : Set where
      constructor AdditiveMagmaSigSigC
      field
        +S : AS -> AS -> AS
    record AdditiveMagmaProd
      (AP : Set) : Set where
      constructor AdditiveMagmaProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record AdditiveMagmaHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveMagma A1)
      (Ad2 : AdditiveMagma A2) :
      Set where
      constructor AdditiveMagmaHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveMagma A1)
      (Ad2 : AdditiveMagma A2) :
      Set where
      constructor AdditiveMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveMagmaLang
      : Set where
      +L :
        AdditiveMagmaLang ->
        AdditiveMagmaLang ->
        AdditiveMagmaLang
    data AdditiveMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> AdditiveMagmaOpenLang
      +OL :
        AdditiveMagmaOpenLang ->
        AdditiveMagmaOpenLang ->
        AdditiveMagmaOpenLang
  
  module AdditiveMonoid where
    record AdditiveMonoid
      (A : Set) : Set where
      constructor AdditiveMonoidC
      field
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
    record AdditiveMonoidSig
      (AS : Set) : Set where
      constructor AdditiveMonoidSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
    record AdditiveMonoidProd
      (AP : Set) : Set where
      constructor AdditiveMonoidProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
    record AdditiveMonoidHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveMonoid A1)
      (Ad2 : AdditiveMonoid A2) :
      Set where
      constructor AdditiveMonoidHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
        pres-0 : hom (0 Ad1) == 0 Ad2
    record AdditiveMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveMonoid A1)
      (Ad2 : AdditiveMonoid A2) :
      Set where
      constructor AdditiveMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
        interp-0 :
          interp (0 Ad1) (0 Ad2)
    data AdditiveMonoidLang
      : Set where
      +L :
        AdditiveMonoidLang ->
        AdditiveMonoidLang ->
        AdditiveMonoidLang
      0L : AdditiveMonoidLang
    data AdditiveMonoidOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> AdditiveMonoidOpenLang
      +OL :
        AdditiveMonoidOpenLang ->
        AdditiveMonoidOpenLang ->
        AdditiveMonoidOpenLang
      0OL : AdditiveMonoidOpenLang
  
  module AdditivePointedMagma where
    record AdditivePointedMagma
      (A : Set) : Set where
      constructor AdditivePointedMagmaC
      field
        0 : A
        + : A -> A -> A
    record AdditivePointedMagmaSig
      (AS : Set) : Set where
      constructor AdditivePointedMagmaSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
    record AdditivePointedMagmaProd
      (AP : Set) : Set where
      constructor AdditivePointedMagmaProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record AdditivePointedMagmaHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditivePointedMagma A1)
      (Ad2 : AdditivePointedMagma
         A2) : Set where
      constructor AdditivePointedMagmaHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditivePointedMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditivePointedMagma A1)
      (Ad2 : AdditivePointedMagma
         A2) : Set where
      constructor AdditivePointedMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditivePointedMagmaLang
      : Set where
      0L : AdditivePointedMagmaLang
      +L :
        AdditivePointedMagmaLang ->
        AdditivePointedMagmaLang ->
        AdditivePointedMagmaLang
    data AdditivePointedMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        AdditivePointedMagmaOpenLang
      0OL :
        AdditivePointedMagmaOpenLang
      +OL :
        AdditivePointedMagmaOpenLang ->
        AdditivePointedMagmaOpenLang ->
        AdditivePointedMagmaOpenLang
  
  module AdditivePointedSemigroup where
    record AdditivePointedSemigroup
      (A : Set) : Set where
      constructor AdditivePointedSemigroupC
      field
        0 : A
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record AdditivePointedSemigroupSig
      (AS : Set) : Set where
      constructor AdditivePointedSemigroupSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
    record AdditivePointedSemigroupProd
      (AP : Set) : Set where
      constructor AdditivePointedSemigroupProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record AdditivePointedSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditivePointedSemigroup
         A1)
      (Ad2 : AdditivePointedSemigroup
         A2) : Set where
      constructor AdditivePointedSemigroupHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditivePointedSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditivePointedSemigroup
         A1)
      (Ad2 : AdditivePointedSemigroup
         A2) : Set where
      constructor AdditivePointedSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditivePointedSemigroupLang
      : Set where
      0L :
        AdditivePointedSemigroupLang
      +L :
        AdditivePointedSemigroupLang ->
        AdditivePointedSemigroupLang ->
        AdditivePointedSemigroupLang
    data AdditivePointedSemigroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        AdditivePointedSemigroupOpenLang
      0OL :
        AdditivePointedSemigroupOpenLang
      +OL :
        AdditivePointedSemigroupOpenLang ->
        AdditivePointedSemigroupOpenLang ->
        AdditivePointedSemigroupOpenLang
  
  module AdditiveSemigroup where
    record AdditiveSemigroup
      (A : Set) : Set where
      constructor AdditiveSemigroupC
      field
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record AdditiveSemigroupSig
      (AS : Set) : Set where
      constructor AdditiveSemigroupSigSigC
      field
        +S : AS -> AS -> AS
    record AdditiveSemigroupProd
      (AP : Set) : Set where
      constructor AdditiveSemigroupProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record AdditiveSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveSemigroup A1)
      (Ad2 : AdditiveSemigroup A2) :
      Set where
      constructor AdditiveSemigroupHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveSemigroup A1)
      (Ad2 : AdditiveSemigroup A2) :
      Set where
      constructor AdditiveSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveSemigroupLang
      : Set where
      +L :
        AdditiveSemigroupLang ->
        AdditiveSemigroupLang ->
        AdditiveSemigroupLang
    data AdditiveSemigroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        AdditiveSemigroupOpenLang
      +OL :
        AdditiveSemigroupOpenLang ->
        AdditiveSemigroupOpenLang ->
        AdditiveSemigroupOpenLang
  
  module AdditiveUnaryAntiDistribution where
    record AdditiveUnaryAntiDistribution
      (A : Set) : Set where
      constructor AdditiveUnaryAntiDistributionC
      field
        prim : A -> A
        + : A -> A -> A
        antidis_prim_+ :
          (x : A) (y : A) ->
          prim (+ x y) ==
            + (prim y) (prim x)
    record AdditiveUnaryAntiDistributionSig
      (AS : Set) : Set where
      constructor AdditiveUnaryAntiDistributionSigSigC
      field
        primS : AS -> AS
        +S : AS -> AS -> AS
    record AdditiveUnaryAntiDistributionProd
      (AP : Set) : Set where
      constructor AdditiveUnaryAntiDistributionProdC
      field
        primP : Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        antidis_prim_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (+P xP yP) ==
            +P (primP yP) (primP xP)
    record AdditiveUnaryAntiDistributionHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveUnaryAntiDistribution
         A1)
      (Ad2 : AdditiveUnaryAntiDistribution
         A2) : Set where
      constructor AdditiveUnaryAntiDistributionHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Ad1 x1) ==
            prim Ad2 (hom x1)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveUnaryAntiDistributionRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveUnaryAntiDistribution
         A1)
      (Ad2 : AdditiveUnaryAntiDistribution
         A2) : Set where
      constructor AdditiveUnaryAntiDistributionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Ad1 x1)
            (prim Ad2 y1)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveUnaryAntiDistributionLang
      : Set where
      primL :
        AdditiveUnaryAntiDistributionLang ->
        AdditiveUnaryAntiDistributionLang
      +L :
        AdditiveUnaryAntiDistributionLang ->
        AdditiveUnaryAntiDistributionLang ->
        AdditiveUnaryAntiDistributionLang
    data AdditiveUnaryAntiDistributionOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        AdditiveUnaryAntiDistributionOpenLang
      primOL :
        AdditiveUnaryAntiDistributionOpenLang ->
        AdditiveUnaryAntiDistributionOpenLang
      +OL :
        AdditiveUnaryAntiDistributionOpenLang ->
        AdditiveUnaryAntiDistributionOpenLang ->
        AdditiveUnaryAntiDistributionOpenLang
  
  module AdditiveUnital where
    record AdditiveUnital
      (A : Set) : Set where
      constructor AdditiveUnitalC
      field
        0 : A
        + : A -> A -> A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
    record AdditiveUnitalSig
      (AS : Set) : Set where
      constructor AdditiveUnitalSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
    record AdditiveUnitalProd
      (AP : Set) : Set where
      constructor AdditiveUnitalProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
    record AdditiveUnitalHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveUnital A1)
      (Ad2 : AdditiveUnital A2) :
      Set where
      constructor AdditiveUnitalHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveUnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveUnital A1)
      (Ad2 : AdditiveUnital A2) :
      Set where
      constructor AdditiveUnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveUnitalLang
      : Set where
      0L : AdditiveUnitalLang
      +L :
        AdditiveUnitalLang ->
        AdditiveUnitalLang ->
        AdditiveUnitalLang
    data AdditiveUnitalOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> AdditiveUnitalOpenLang
      0OL : AdditiveUnitalOpenLang
      +OL :
        AdditiveUnitalOpenLang ->
        AdditiveUnitalOpenLang ->
        AdditiveUnitalOpenLang
  
  module AndDeMorgan where
    record AndDeMorgan
      (A : Set) : Set where
      constructor AndDeMorganC
      field
        * : A -> A -> A
        + : A -> A -> A
        prim : A -> A
        andDeMorgan_*_+_prim :
          (x : A) (y : A) (z : A) ->
          prim (* x y) ==
            + (prim x) (prim y)
    record AndDeMorganSig
      (AS : Set) : Set where
      constructor AndDeMorganSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        primS : AS -> AS
    record AndDeMorganProd
      (AP : Set) : Set where
      constructor AndDeMorganProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        andDeMorgan_*_+_primP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          primP (*P xP yP) ==
            +P (primP xP) (primP yP)
    record AndDeMorganHom
      (A1 : Set) (A2 : Set)
      (An1 : AndDeMorgan A1)
      (An2 : AndDeMorgan A2) :
      Set where
      constructor AndDeMorganHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* An1 x1 x2) ==
            * An2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ An1 x1 x2) ==
            + An2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim An1 x1) ==
            prim An2 (hom x1)
    record AndDeMorganRelInterp
      (A1 : Set) (A2 : Set)
      (An1 : AndDeMorgan A1)
      (An2 : AndDeMorgan A2) :
      Set where
      constructor AndDeMorganRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* An1 x1 x2)
            (* An2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ An1 x1 x2)
            (+ An2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim An1 x1)
            (prim An2 y1)
    data AndDeMorganLang : Set where
      *L :
        AndDeMorganLang ->
        AndDeMorganLang ->
        AndDeMorganLang
      +L :
        AndDeMorganLang ->
        AndDeMorganLang ->
        AndDeMorganLang
      primL :
        AndDeMorganLang ->
        AndDeMorganLang
    data AndDeMorganOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> AndDeMorganOpenLang
      *OL :
        AndDeMorganOpenLang ->
        AndDeMorganOpenLang ->
        AndDeMorganOpenLang
      +OL :
        AndDeMorganOpenLang ->
        AndDeMorganOpenLang ->
        AndDeMorganOpenLang
      primOL :
        AndDeMorganOpenLang ->
        AndDeMorganOpenLang
  
  module AntiAbsorbent where
    record AntiAbsorbent
      (A : Set) : Set where
      constructor AntiAbsorbentC
      field
        op : A -> A -> A
        antiAbsorbent :
          (x : A) (y : A) ->
          op x (op x y) == y
    record AntiAbsorbentSig
      (AS : Set) : Set where
      constructor AntiAbsorbentSigSigC
      field
        opS : AS -> AS -> AS
    record AntiAbsorbentProd
      (AP : Set) : Set where
      constructor AntiAbsorbentProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        antiAbsorbentP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (opP xP yP) == yP
    record AntiAbsorbentHom
      (A1 : Set) (A2 : Set)
      (An1 : AntiAbsorbent A1)
      (An2 : AntiAbsorbent A2) :
      Set where
      constructor AntiAbsorbentHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op An1 x1 x2) ==
            op An2 (hom x1) (hom x2)
    record AntiAbsorbentRelInterp
      (A1 : Set) (A2 : Set)
      (An1 : AntiAbsorbent A1)
      (An2 : AntiAbsorbent A2) :
      Set where
      constructor AntiAbsorbentRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op An1 x1 x2)
            (op An2 y1 y2)
    data AntiAbsorbentLang
      : Set where
      opL :
        AntiAbsorbentLang ->
        AntiAbsorbentLang ->
        AntiAbsorbentLang
    data AntiAbsorbentOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> AntiAbsorbentOpenLang
      opOL :
        AntiAbsorbentOpenLang ->
        AntiAbsorbentOpenLang ->
        AntiAbsorbentOpenLang
  
  module AntiCommutativeRing where
    record AntiCommutativeRing
      (A : Set) : Set where
      constructor AntiCommutativeRingC
      field
        * : A -> A -> A
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
        antiCommutative :
          (x : A) (y : A) ->
          * x y == neg (* y x)
    record AntiCommutativeRingSig
      (AS : Set) : Set where
      constructor AntiCommutativeRingSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
        1S : AS
    record AntiCommutativeRingProd
      (AP : Set) : Set where
      constructor AntiCommutativeRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
        antiCommutativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == negP (*P yP xP)
    record AntiCommutativeRingHom
      (A1 : Set) (A2 : Set)
      (An1 : AntiCommutativeRing A1)
      (An2 : AntiCommutativeRing A2) :
      Set where
      constructor AntiCommutativeRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* An1 x1 x2) ==
            * An2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ An1 x1 x2) ==
            + An2 (hom x1) (hom x2)
        pres-0 : hom (0 An1) == 0 An2
        pres-neg :
          (x1 : A1) ->
          hom (neg An1 x1) ==
            neg An2 (hom x1)
        pres-1 : hom (1 An1) == 1 An2
    record AntiCommutativeRingRelInterp
      (A1 : Set) (A2 : Set)
      (An1 : AntiCommutativeRing A1)
      (An2 : AntiCommutativeRing A2) :
      Set where
      constructor AntiCommutativeRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* An1 x1 x2)
            (* An2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ An1 x1 x2)
            (+ An2 y1 y2)
        interp-0 :
          interp (0 An1) (0 An2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg An1 x1) (neg An2 y1)
        interp-1 :
          interp (1 An1) (1 An2)
    data AntiCommutativeRingLang
      : Set where
      *L :
        AntiCommutativeRingLang ->
        AntiCommutativeRingLang ->
        AntiCommutativeRingLang
      +L :
        AntiCommutativeRingLang ->
        AntiCommutativeRingLang ->
        AntiCommutativeRingLang
      0L : AntiCommutativeRingLang
      negL :
        AntiCommutativeRingLang ->
        AntiCommutativeRingLang
      1L : AntiCommutativeRingLang
    data AntiCommutativeRingOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        AntiCommutativeRingOpenLang
      *OL :
        AntiCommutativeRingOpenLang ->
        AntiCommutativeRingOpenLang ->
        AntiCommutativeRingOpenLang
      +OL :
        AntiCommutativeRingOpenLang ->
        AntiCommutativeRingOpenLang ->
        AntiCommutativeRingOpenLang
      0OL :
        AntiCommutativeRingOpenLang
      negOL :
        AntiCommutativeRingOpenLang ->
        AntiCommutativeRingOpenLang
      1OL :
        AntiCommutativeRingOpenLang
  
  module AssocPlusRingoid where
    record AssocPlusRingoid
      (A : Set) : Set where
      constructor AssocPlusRingoidC
      field
        + : A -> A -> A
        * : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record AssocPlusRingoidSig
      (AS : Set) : Set where
      constructor AssocPlusRingoidSigSigC
      field
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
    record AssocPlusRingoidProd
      (AP : Set) : Set where
      constructor AssocPlusRingoidProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record AssocPlusRingoidHom
      (A1 : Set) (A2 : Set)
      (As1 : AssocPlusRingoid A1)
      (As2 : AssocPlusRingoid A2) :
      Set where
      constructor AssocPlusRingoidHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ As1 x1 x2) ==
            + As2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* As1 x1 x2) ==
            * As2 (hom x1) (hom x2)
    record AssocPlusRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (As1 : AssocPlusRingoid A1)
      (As2 : AssocPlusRingoid A2) :
      Set where
      constructor AssocPlusRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ As1 x1 x2)
            (+ As2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* As1 x1 x2)
            (* As2 y1 y2)
    data AssocPlusRingoidLang
      : Set where
      +L :
        AssocPlusRingoidLang ->
        AssocPlusRingoidLang ->
        AssocPlusRingoidLang
      *L :
        AssocPlusRingoidLang ->
        AssocPlusRingoidLang ->
        AssocPlusRingoidLang
    data AssocPlusRingoidOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        AssocPlusRingoidOpenLang
      +OL :
        AssocPlusRingoidOpenLang ->
        AssocPlusRingoidOpenLang ->
        AssocPlusRingoidOpenLang
      *OL :
        AssocPlusRingoidOpenLang ->
        AssocPlusRingoidOpenLang ->
        AssocPlusRingoidOpenLang
  
  module AssocTimesRingoid where
    record AssocTimesRingoid
      (A : Set) : Set where
      constructor AssocTimesRingoidC
      field
        * : A -> A -> A
        + : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
    record AssocTimesRingoidSig
      (AS : Set) : Set where
      constructor AssocTimesRingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record AssocTimesRingoidProd
      (AP : Set) : Set where
      constructor AssocTimesRingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
    record AssocTimesRingoidHom
      (A1 : Set) (A2 : Set)
      (As1 : AssocTimesRingoid A1)
      (As2 : AssocTimesRingoid A2) :
      Set where
      constructor AssocTimesRingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* As1 x1 x2) ==
            * As2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ As1 x1 x2) ==
            + As2 (hom x1) (hom x2)
    record AssocTimesRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (As1 : AssocTimesRingoid A1)
      (As2 : AssocTimesRingoid A2) :
      Set where
      constructor AssocTimesRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* As1 x1 x2)
            (* As2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ As1 x1 x2)
            (+ As2 y1 y2)
    data AssocTimesRingoidLang
      : Set where
      *L :
        AssocTimesRingoidLang ->
        AssocTimesRingoidLang ->
        AssocTimesRingoidLang
      +L :
        AssocTimesRingoidLang ->
        AssocTimesRingoidLang ->
        AssocTimesRingoidLang
    data AssocTimesRingoidOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        AssocTimesRingoidOpenLang
      *OL :
        AssocTimesRingoidOpenLang ->
        AssocTimesRingoidOpenLang ->
        AssocTimesRingoidOpenLang
      +OL :
        AssocTimesRingoidOpenLang ->
        AssocTimesRingoidOpenLang ->
        AssocTimesRingoidOpenLang
  
  module AssociativeLeftRingoid where
    record AssociativeLeftRingoid
      (A : Set) : Set where
      constructor AssociativeLeftRingoidC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
    record AssociativeLeftRingoidSig
      (AS : Set) : Set where
      constructor AssociativeLeftRingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record AssociativeLeftRingoidProd
      (AP : Set) : Set where
      constructor AssociativeLeftRingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
    record AssociativeLeftRingoidHom
      (A1 : Set) (A2 : Set)
      (As1 : AssociativeLeftRingoid
         A1)
      (As2 : AssociativeLeftRingoid
         A2) : Set where
      constructor AssociativeLeftRingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* As1 x1 x2) ==
            * As2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ As1 x1 x2) ==
            + As2 (hom x1) (hom x2)
    record AssociativeLeftRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (As1 : AssociativeLeftRingoid
         A1)
      (As2 : AssociativeLeftRingoid
         A2) : Set where
      constructor AssociativeLeftRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* As1 x1 x2)
            (* As2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ As1 x1 x2)
            (+ As2 y1 y2)
    data AssociativeLeftRingoidLang
      : Set where
      *L :
        AssociativeLeftRingoidLang ->
        AssociativeLeftRingoidLang ->
        AssociativeLeftRingoidLang
      +L :
        AssociativeLeftRingoidLang ->
        AssociativeLeftRingoidLang ->
        AssociativeLeftRingoidLang
    data AssociativeLeftRingoidOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        AssociativeLeftRingoidOpenLang
      *OL :
        AssociativeLeftRingoidOpenLang ->
        AssociativeLeftRingoidOpenLang ->
        AssociativeLeftRingoidOpenLang
      +OL :
        AssociativeLeftRingoidOpenLang ->
        AssociativeLeftRingoidOpenLang ->
        AssociativeLeftRingoidOpenLang
  
  module AssociativeNonDistributiveRingoid where
    record AssociativeNonDistributiveRingoid
      (A : Set) : Set where
      constructor AssociativeNonDistributiveRingoidC
      field
        * : A -> A -> A
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
    record AssociativeNonDistributiveRingoidSig
      (AS : Set) : Set where
      constructor AssociativeNonDistributiveRingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record AssociativeNonDistributiveRingoidProd
      (AP : Set) : Set where
      constructor AssociativeNonDistributiveRingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
    record AssociativeNonDistributiveRingoidHom
      (A1 : Set) (A2 : Set)
      (As1 : AssociativeNonDistributiveRingoid
         A1)
      (As2 : AssociativeNonDistributiveRingoid
         A2) : Set where
      constructor AssociativeNonDistributiveRingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* As1 x1 x2) ==
            * As2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ As1 x1 x2) ==
            + As2 (hom x1) (hom x2)
    record AssociativeNonDistributiveRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (As1 : AssociativeNonDistributiveRingoid
         A1)
      (As2 : AssociativeNonDistributiveRingoid
         A2) : Set where
      constructor AssociativeNonDistributiveRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* As1 x1 x2)
            (* As2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ As1 x1 x2)
            (+ As2 y1 y2)
    data AssociativeNonDistributiveRingoidLang
      : Set where
      *L :
        AssociativeNonDistributiveRingoidLang ->
        AssociativeNonDistributiveRingoidLang ->
        AssociativeNonDistributiveRingoidLang
      +L :
        AssociativeNonDistributiveRingoidLang ->
        AssociativeNonDistributiveRingoidLang ->
        AssociativeNonDistributiveRingoidLang
    data AssociativeNonDistributiveRingoidOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        AssociativeNonDistributiveRingoidOpenLang
      *OL :
        AssociativeNonDistributiveRingoidOpenLang ->
        AssociativeNonDistributiveRingoidOpenLang ->
        AssociativeNonDistributiveRingoidOpenLang
      +OL :
        AssociativeNonDistributiveRingoidOpenLang ->
        AssociativeNonDistributiveRingoidOpenLang ->
        AssociativeNonDistributiveRingoidOpenLang
  
  module AssociativeRightRingoid where
    record AssociativeRightRingoid
      (A : Set) : Set where
      constructor AssociativeRightRingoidC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        + : A -> A -> A
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record AssociativeRightRingoidSig
      (AS : Set) : Set where
      constructor AssociativeRightRingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record AssociativeRightRingoidProd
      (AP : Set) : Set where
      constructor AssociativeRightRingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record AssociativeRightRingoidHom
      (A1 : Set) (A2 : Set)
      (As1 : AssociativeRightRingoid
         A1)
      (As2 : AssociativeRightRingoid
         A2) : Set where
      constructor AssociativeRightRingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* As1 x1 x2) ==
            * As2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ As1 x1 x2) ==
            + As2 (hom x1) (hom x2)
    record AssociativeRightRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (As1 : AssociativeRightRingoid
         A1)
      (As2 : AssociativeRightRingoid
         A2) : Set where
      constructor AssociativeRightRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* As1 x1 x2)
            (* As2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ As1 x1 x2)
            (+ As2 y1 y2)
    data AssociativeRightRingoidLang
      : Set where
      *L :
        AssociativeRightRingoidLang ->
        AssociativeRightRingoidLang ->
        AssociativeRightRingoidLang
      +L :
        AssociativeRightRingoidLang ->
        AssociativeRightRingoidLang ->
        AssociativeRightRingoidLang
    data AssociativeRightRingoidOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        AssociativeRightRingoidOpenLang
      *OL :
        AssociativeRightRingoidOpenLang ->
        AssociativeRightRingoidOpenLang ->
        AssociativeRightRingoidOpenLang
      +OL :
        AssociativeRightRingoidOpenLang ->
        AssociativeRightRingoidOpenLang ->
        AssociativeRightRingoidOpenLang
  
  module Band where
    record Band
      (A : Set) : Set where
      constructor BandC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        idempotent_op :
          (x : A) -> op x x == x
    record BandSig
      (AS : Set) : Set where
      constructor BandSigSigC
      field
        opS : AS -> AS -> AS
    record BandProd
      (AP : Set) : Set where
      constructor BandProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        idempotent_opP :
          (xP : Prod AP AP) ->
          opP xP xP == xP
    record BandHom
      (A1 : Set) (A2 : Set)
      (Ba1 : Band A1)
      (Ba2 : Band A2) : Set where
      constructor BandHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ba1 x1 x2) ==
            op Ba2 (hom x1) (hom x2)
    record BandRelInterp
      (A1 : Set) (A2 : Set)
      (Ba1 : Band A1)
      (Ba2 : Band A2) : Set where
      constructor BandRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ba1 x1 x2)
            (op Ba2 y1 y2)
    data BandLang : Set where
      opL :
        BandLang -> BandLang -> BandLang
    data BandOpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> BandOpenLang
      opOL :
        BandOpenLang ->
        BandOpenLang -> BandOpenLang
  
  module BinaryInverse where
    record BinaryInverse
      (A : Set) : Set where
      constructor BinaryInverseC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftInverse :
          (x : A) (y : A) ->
          <| (|> x y) x == y
        rightInverse :
          (x : A) (y : A) ->
          |> x (<| y x) == y
    record BinaryInverseSig
      (AS : Set) : Set where
      constructor BinaryInverseSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record BinaryInverseProd
      (AP : Set) : Set where
      constructor BinaryInverseProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          <|P (|>P xP yP) xP == yP
        rightInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          |>P xP (<|P yP xP) == yP
    record BinaryInverseHom
      (A1 : Set) (A2 : Set)
      (Bi1 : BinaryInverse A1)
      (Bi2 : BinaryInverse A2) :
      Set where
      constructor BinaryInverseHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Bi1 x1 x2) ==
            |> Bi2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Bi1 x1 x2) ==
            <| Bi2 (hom x1) (hom x2)
    record BinaryInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Bi1 : BinaryInverse A1)
      (Bi2 : BinaryInverse A2) :
      Set where
      constructor BinaryInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Bi1 x1 x2)
            (|> Bi2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Bi1 x1 x2)
            (<| Bi2 y1 y2)
    data BinaryInverseLang
      : Set where
      |>L :
        BinaryInverseLang ->
        BinaryInverseLang ->
        BinaryInverseLang
      <|L :
        BinaryInverseLang ->
        BinaryInverseLang ->
        BinaryInverseLang
    data BinaryInverseOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> BinaryInverseOpenLang
      |>OL :
        BinaryInverseOpenLang ->
        BinaryInverseOpenLang ->
        BinaryInverseOpenLang
      <|OL :
        BinaryInverseOpenLang ->
        BinaryInverseOpenLang ->
        BinaryInverseOpenLang
  
  module BooleanGroup where
    record BooleanGroup
      (A : Set) : Set where
      constructor BooleanGroupC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        unipotence :
          (x : A) -> op x x == e
    record BooleanGroupSig
      (AS : Set) : Set where
      constructor BooleanGroupSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record BooleanGroupProd
      (AP : Set) : Set where
      constructor BooleanGroupProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        unipotenceP :
          (xP : Prod AP AP) ->
          opP xP xP == eP
    record BooleanGroupHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BooleanGroup A1)
      (Bo2 : BooleanGroup A2) :
      Set where
      constructor BooleanGroupHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Bo1) == e Bo2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Bo1 x1 x2) ==
            op Bo2 (hom x1) (hom x2)
    record BooleanGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BooleanGroup A1)
      (Bo2 : BooleanGroup A2) :
      Set where
      constructor BooleanGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Bo1) (e Bo2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Bo1 x1 x2)
            (op Bo2 y1 y2)
    data BooleanGroupLang
      : Set where
      eL : BooleanGroupLang
      opL :
        BooleanGroupLang ->
        BooleanGroupLang ->
        BooleanGroupLang
    data BooleanGroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> BooleanGroupOpenLang
      eOL : BooleanGroupOpenLang
      opOL :
        BooleanGroupOpenLang ->
        BooleanGroupOpenLang ->
        BooleanGroupOpenLang
  
  module BooleanRing where
    record BooleanRing
      (A : Set) : Set where
      constructor BooleanRingC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
        idempotent_* :
          (x : A) -> * x x == x
    record BooleanRingSig
      (AS : Set) : Set where
      constructor BooleanRingSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
    record BooleanRingProd
      (AP : Set) : Set where
      constructor BooleanRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
    record BooleanRingHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BooleanRing A1)
      (Bo2 : BooleanRing A2) :
      Set where
      constructor BooleanRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
        pres-1 : hom (1 Bo1) == 1 Bo2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
        pres-0 : hom (0 Bo1) == 0 Bo2
        pres-neg :
          (x1 : A1) ->
          hom (neg Bo1 x1) ==
            neg Bo2 (hom x1)
    record BooleanRingRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BooleanRing A1)
      (Bo2 : BooleanRing A2) :
      Set where
      constructor BooleanRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
        interp-1 :
          interp (1 Bo1) (1 Bo2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
        interp-0 :
          interp (0 Bo1) (0 Bo2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Bo1 x1) (neg Bo2 y1)
    data BooleanRingLang : Set where
      *L :
        BooleanRingLang ->
        BooleanRingLang ->
        BooleanRingLang
      1L : BooleanRingLang
      +L :
        BooleanRingLang ->
        BooleanRingLang ->
        BooleanRingLang
      0L : BooleanRingLang
      negL :
        BooleanRingLang ->
        BooleanRingLang
    data BooleanRingOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> BooleanRingOpenLang
      *OL :
        BooleanRingOpenLang ->
        BooleanRingOpenLang ->
        BooleanRingOpenLang
      1OL : BooleanRingOpenLang
      +OL :
        BooleanRingOpenLang ->
        BooleanRingOpenLang ->
        BooleanRingOpenLang
      0OL : BooleanRingOpenLang
      negOL :
        BooleanRingOpenLang ->
        BooleanRingOpenLang
  
  module BoundedDistributiveLattice where
    record BoundedDistributiveLattice
      (A : Set) : Set where
      constructor BoundedDistributiveLatticeC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
        leftModular_*_+ :
          (x : A) (y : A) (z : A) ->
          + (* x y) (* x z) ==
            * x (+ y (* x z))
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
    record BoundedDistributiveLatticeSig
      (AS : Set) : Set where
      constructor BoundedDistributiveLatticeSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        1S : AS
    record BoundedDistributiveLatticeProd
      (AP : Set) : Set where
      constructor BoundedDistributiveLatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        1P : Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
        leftModular_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (*P xP yP) (*P xP zP) ==
            *P xP (+P yP (*P xP zP))
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
    record BoundedDistributiveLatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedDistributiveLattice
         A1)
      (Bo2 : BoundedDistributiveLattice
         A2) : Set where
      constructor BoundedDistributiveLatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
        pres-0 : hom (0 Bo1) == 0 Bo2
        pres-1 : hom (1 Bo1) == 1 Bo2
    record BoundedDistributiveLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedDistributiveLattice
         A1)
      (Bo2 : BoundedDistributiveLattice
         A2) : Set where
      constructor BoundedDistributiveLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
        interp-0 :
          interp (0 Bo1) (0 Bo2)
        interp-1 :
          interp (1 Bo1) (1 Bo2)
    data BoundedDistributiveLatticeLang
      : Set where
      *L :
        BoundedDistributiveLatticeLang ->
        BoundedDistributiveLatticeLang ->
        BoundedDistributiveLatticeLang
      +L :
        BoundedDistributiveLatticeLang ->
        BoundedDistributiveLatticeLang ->
        BoundedDistributiveLatticeLang
      0L :
        BoundedDistributiveLatticeLang
      1L :
        BoundedDistributiveLatticeLang
    data BoundedDistributiveLatticeOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        BoundedDistributiveLatticeOpenLang
      *OL :
        BoundedDistributiveLatticeOpenLang ->
        BoundedDistributiveLatticeOpenLang ->
        BoundedDistributiveLatticeOpenLang
      +OL :
        BoundedDistributiveLatticeOpenLang ->
        BoundedDistributiveLatticeOpenLang ->
        BoundedDistributiveLatticeOpenLang
      0OL :
        BoundedDistributiveLatticeOpenLang
      1OL :
        BoundedDistributiveLatticeOpenLang
  
  module BoundedJoinLattice where
    record BoundedJoinLattice
      (A : Set) : Set where
      constructor BoundedJoinLatticeC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        * : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
    record BoundedJoinLatticeSig
      (AS : Set) : Set where
      constructor BoundedJoinLatticeSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
        *S : AS -> AS -> AS
    record BoundedJoinLatticeProd
      (AP : Set) : Set where
      constructor BoundedJoinLatticeProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
    record BoundedJoinLatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedJoinLattice A1)
      (Bo2 : BoundedJoinLattice A2) :
      Set where
      constructor BoundedJoinLatticeHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
        pres-0 : hom (0 Bo1) == 0 Bo2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
    record BoundedJoinLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedJoinLattice A1)
      (Bo2 : BoundedJoinLattice A2) :
      Set where
      constructor BoundedJoinLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
        interp-0 :
          interp (0 Bo1) (0 Bo2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
    data BoundedJoinLatticeLang
      : Set where
      +L :
        BoundedJoinLatticeLang ->
        BoundedJoinLatticeLang ->
        BoundedJoinLatticeLang
      0L : BoundedJoinLatticeLang
      *L :
        BoundedJoinLatticeLang ->
        BoundedJoinLatticeLang ->
        BoundedJoinLatticeLang
    data BoundedJoinLatticeOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        BoundedJoinLatticeOpenLang
      +OL :
        BoundedJoinLatticeOpenLang ->
        BoundedJoinLatticeOpenLang ->
        BoundedJoinLatticeOpenLang
      0OL : BoundedJoinLatticeOpenLang
      *OL :
        BoundedJoinLatticeOpenLang ->
        BoundedJoinLatticeOpenLang ->
        BoundedJoinLatticeOpenLang
  
  module BoundedJoinSemilattice where
    record BoundedJoinSemilattice
      (A : Set) : Set where
      constructor BoundedJoinSemilatticeC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        idempotent_+ :
          (x : A) -> + x x == x
    record BoundedJoinSemilatticeSig
      (AS : Set) : Set where
      constructor BoundedJoinSemilatticeSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
    record BoundedJoinSemilatticeProd
      (AP : Set) : Set where
      constructor BoundedJoinSemilatticeProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record BoundedJoinSemilatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedJoinSemilattice
         A1)
      (Bo2 : BoundedJoinSemilattice
         A2) : Set where
      constructor BoundedJoinSemilatticeHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
        pres-0 : hom (0 Bo1) == 0 Bo2
    record BoundedJoinSemilatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedJoinSemilattice
         A1)
      (Bo2 : BoundedJoinSemilattice
         A2) : Set where
      constructor BoundedJoinSemilatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
        interp-0 :
          interp (0 Bo1) (0 Bo2)
    data BoundedJoinSemilatticeLang
      : Set where
      +L :
        BoundedJoinSemilatticeLang ->
        BoundedJoinSemilatticeLang ->
        BoundedJoinSemilatticeLang
      0L : BoundedJoinSemilatticeLang
    data BoundedJoinSemilatticeOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        BoundedJoinSemilatticeOpenLang
      +OL :
        BoundedJoinSemilatticeOpenLang ->
        BoundedJoinSemilatticeOpenLang ->
        BoundedJoinSemilatticeOpenLang
      0OL :
        BoundedJoinSemilatticeOpenLang
  
  module BoundedLattice where
    record BoundedLattice
      (A : Set) : Set where
      constructor BoundedLatticeC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
    record BoundedLatticeSig
      (AS : Set) : Set where
      constructor BoundedLatticeSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        1S : AS
    record BoundedLatticeProd
      (AP : Set) : Set where
      constructor BoundedLatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        1P : Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
    record BoundedLatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedLattice A1)
      (Bo2 : BoundedLattice A2) :
      Set where
      constructor BoundedLatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
        pres-0 : hom (0 Bo1) == 0 Bo2
        pres-1 : hom (1 Bo1) == 1 Bo2
    record BoundedLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedLattice A1)
      (Bo2 : BoundedLattice A2) :
      Set where
      constructor BoundedLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
        interp-0 :
          interp (0 Bo1) (0 Bo2)
        interp-1 :
          interp (1 Bo1) (1 Bo2)
    data BoundedLatticeLang
      : Set where
      *L :
        BoundedLatticeLang ->
        BoundedLatticeLang ->
        BoundedLatticeLang
      +L :
        BoundedLatticeLang ->
        BoundedLatticeLang ->
        BoundedLatticeLang
      0L : BoundedLatticeLang
      1L : BoundedLatticeLang
    data BoundedLatticeOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> BoundedLatticeOpenLang
      *OL :
        BoundedLatticeOpenLang ->
        BoundedLatticeOpenLang ->
        BoundedLatticeOpenLang
      +OL :
        BoundedLatticeOpenLang ->
        BoundedLatticeOpenLang ->
        BoundedLatticeOpenLang
      0OL : BoundedLatticeOpenLang
      1OL : BoundedLatticeOpenLang
  
  module BoundedMeetLattice where
    record BoundedMeetLattice
      (A : Set) : Set where
      constructor BoundedMeetLatticeC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
    record BoundedMeetLatticeSig
      (AS : Set) : Set where
      constructor BoundedMeetLatticeSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
        +S : AS -> AS -> AS
    record BoundedMeetLatticeProd
      (AP : Set) : Set where
      constructor BoundedMeetLatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
    record BoundedMeetLatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedMeetLattice A1)
      (Bo2 : BoundedMeetLattice A2) :
      Set where
      constructor BoundedMeetLatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
        pres-1 : hom (1 Bo1) == 1 Bo2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
    record BoundedMeetLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedMeetLattice A1)
      (Bo2 : BoundedMeetLattice A2) :
      Set where
      constructor BoundedMeetLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
        interp-1 :
          interp (1 Bo1) (1 Bo2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
    data BoundedMeetLatticeLang
      : Set where
      *L :
        BoundedMeetLatticeLang ->
        BoundedMeetLatticeLang ->
        BoundedMeetLatticeLang
      1L : BoundedMeetLatticeLang
      +L :
        BoundedMeetLatticeLang ->
        BoundedMeetLatticeLang ->
        BoundedMeetLatticeLang
    data BoundedMeetLatticeOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        BoundedMeetLatticeOpenLang
      *OL :
        BoundedMeetLatticeOpenLang ->
        BoundedMeetLatticeOpenLang ->
        BoundedMeetLatticeOpenLang
      1OL : BoundedMeetLatticeOpenLang
      +OL :
        BoundedMeetLatticeOpenLang ->
        BoundedMeetLatticeOpenLang ->
        BoundedMeetLatticeOpenLang
  
  module BoundedMeetSemilattice where
    record BoundedMeetSemilattice
      (A : Set) : Set where
      constructor BoundedMeetSemilatticeC
      field
        * : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        idempotent_* :
          (x : A) -> * x x == x
    record BoundedMeetSemilatticeSig
      (AS : Set) : Set where
      constructor BoundedMeetSemilatticeSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
    record BoundedMeetSemilatticeProd
      (AP : Set) : Set where
      constructor BoundedMeetSemilatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
    record BoundedMeetSemilatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedMeetSemilattice
         A1)
      (Bo2 : BoundedMeetSemilattice
         A2) : Set where
      constructor BoundedMeetSemilatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
        pres-1 : hom (1 Bo1) == 1 Bo2
    record BoundedMeetSemilatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedMeetSemilattice
         A1)
      (Bo2 : BoundedMeetSemilattice
         A2) : Set where
      constructor BoundedMeetSemilatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
        interp-1 :
          interp (1 Bo1) (1 Bo2)
    data BoundedMeetSemilatticeLang
      : Set where
      *L :
        BoundedMeetSemilatticeLang ->
        BoundedMeetSemilatticeLang ->
        BoundedMeetSemilatticeLang
      1L : BoundedMeetSemilatticeLang
    data BoundedMeetSemilatticeOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        BoundedMeetSemilatticeOpenLang
      *OL :
        BoundedMeetSemilatticeOpenLang ->
        BoundedMeetSemilatticeOpenLang ->
        BoundedMeetSemilatticeOpenLang
      1OL :
        BoundedMeetSemilatticeOpenLang
  
  module BoundedModularLattice where
    record BoundedModularLattice
      (A : Set) : Set where
      constructor BoundedModularLatticeC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        leftModular_*_+ :
          (x : A) (y : A) (z : A) ->
          + (* x y) (* x z) ==
            * x (+ y (* x z))
    record BoundedModularLatticeSig
      (AS : Set) : Set where
      constructor BoundedModularLatticeSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        1S : AS
    record BoundedModularLatticeProd
      (AP : Set) : Set where
      constructor BoundedModularLatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        1P : Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        leftModular_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (*P xP yP) (*P xP zP) ==
            *P xP (+P yP (*P xP zP))
    record BoundedModularLatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedModularLattice A1)
      (Bo2 : BoundedModularLattice
         A2) : Set where
      constructor BoundedModularLatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
        pres-0 : hom (0 Bo1) == 0 Bo2
        pres-1 : hom (1 Bo1) == 1 Bo2
    record BoundedModularLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedModularLattice A1)
      (Bo2 : BoundedModularLattice
         A2) : Set where
      constructor BoundedModularLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
        interp-0 :
          interp (0 Bo1) (0 Bo2)
        interp-1 :
          interp (1 Bo1) (1 Bo2)
    data BoundedModularLatticeLang
      : Set where
      *L :
        BoundedModularLatticeLang ->
        BoundedModularLatticeLang ->
        BoundedModularLatticeLang
      +L :
        BoundedModularLatticeLang ->
        BoundedModularLatticeLang ->
        BoundedModularLatticeLang
      0L : BoundedModularLatticeLang
      1L : BoundedModularLatticeLang
    data BoundedModularLatticeOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        BoundedModularLatticeOpenLang
      *OL :
        BoundedModularLatticeOpenLang ->
        BoundedModularLatticeOpenLang ->
        BoundedModularLatticeOpenLang
      +OL :
        BoundedModularLatticeOpenLang ->
        BoundedModularLatticeOpenLang ->
        BoundedModularLatticeOpenLang
      0OL :
        BoundedModularLatticeOpenLang
      1OL :
        BoundedModularLatticeOpenLang
  
  module CancellativeCommutativeMonoid where
    record CancellativeCommutativeMonoid
      (A : Set) : Set where
      constructor CancellativeCommutativeMonoidC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CancellativeCommutativeMonoidSig
      (AS : Set) : Set where
      constructor CancellativeCommutativeMonoidSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record CancellativeCommutativeMonoidProd
      (AP : Set) : Set where
      constructor CancellativeCommutativeMonoidProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CancellativeCommutativeMonoidHom
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeCommutativeMonoid
         A1)
      (Ca2 : CancellativeCommutativeMonoid
         A2) : Set where
      constructor CancellativeCommutativeMonoidHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Ca1) == e Ca2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ca1 x1 x2) ==
            op Ca2 (hom x1) (hom x2)
    record CancellativeCommutativeMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeCommutativeMonoid
         A1)
      (Ca2 : CancellativeCommutativeMonoid
         A2) : Set where
      constructor CancellativeCommutativeMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Ca1) (e Ca2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ca1 x1 x2)
            (op Ca2 y1 y2)
    data CancellativeCommutativeMonoidLang
      : Set where
      eL :
        CancellativeCommutativeMonoidLang
      opL :
        CancellativeCommutativeMonoidLang ->
        CancellativeCommutativeMonoidLang ->
        CancellativeCommutativeMonoidLang
    data CancellativeCommutativeMonoidOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        CancellativeCommutativeMonoidOpenLang
      eOL :
        CancellativeCommutativeMonoidOpenLang
      opOL :
        CancellativeCommutativeMonoidOpenLang ->
        CancellativeCommutativeMonoidOpenLang ->
        CancellativeCommutativeMonoidOpenLang
  
  module CancellativeCommutativeSemigroup where
    record CancellativeCommutativeSemigroup
      (A : Set) : Set where
      constructor CancellativeCommutativeSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
    record CancellativeCommutativeSemigroupSig
      (AS : Set) : Set where
      constructor CancellativeCommutativeSemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record CancellativeCommutativeSemigroupProd
      (AP : Set) : Set where
      constructor CancellativeCommutativeSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
    record CancellativeCommutativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeCommutativeSemigroup
         A1)
      (Ca2 : CancellativeCommutativeSemigroup
         A2) : Set where
      constructor CancellativeCommutativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ca1 x1 x2) ==
            op Ca2 (hom x1) (hom x2)
    record CancellativeCommutativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeCommutativeSemigroup
         A1)
      (Ca2 : CancellativeCommutativeSemigroup
         A2) : Set where
      constructor CancellativeCommutativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ca1 x1 x2)
            (op Ca2 y1 y2)
    data CancellativeCommutativeSemigroupLang
      : Set where
      opL :
        CancellativeCommutativeSemigroupLang ->
        CancellativeCommutativeSemigroupLang ->
        CancellativeCommutativeSemigroupLang
    data CancellativeCommutativeSemigroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        CancellativeCommutativeSemigroupOpenLang
      opOL :
        CancellativeCommutativeSemigroupOpenLang ->
        CancellativeCommutativeSemigroupOpenLang ->
        CancellativeCommutativeSemigroupOpenLang
  
  module CancellativeMagma where
    record CancellativeMagma
      (A : Set) : Set where
      constructor CancellativeMagmaC
      field
        op : A -> A -> A
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
    record CancellativeMagmaSig
      (AS : Set) : Set where
      constructor CancellativeMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record CancellativeMagmaProd
      (AP : Set) : Set where
      constructor CancellativeMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
    record CancellativeMagmaHom
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeMagma A1)
      (Ca2 : CancellativeMagma A2) :
      Set where
      constructor CancellativeMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ca1 x1 x2) ==
            op Ca2 (hom x1) (hom x2)
    record CancellativeMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeMagma A1)
      (Ca2 : CancellativeMagma A2) :
      Set where
      constructor CancellativeMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ca1 x1 x2)
            (op Ca2 y1 y2)
    data CancellativeMagmaLang
      : Set where
      opL :
        CancellativeMagmaLang ->
        CancellativeMagmaLang ->
        CancellativeMagmaLang
    data CancellativeMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        CancellativeMagmaOpenLang
      opOL :
        CancellativeMagmaOpenLang ->
        CancellativeMagmaOpenLang ->
        CancellativeMagmaOpenLang
  
  module CancellativeMonoid where
    record CancellativeMonoid
      (A : Set) : Set where
      constructor CancellativeMonoidC
      field
        op : A -> A -> A
        e : A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
    record CancellativeMonoidSig
      (AS : Set) : Set where
      constructor CancellativeMonoidSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record CancellativeMonoidProd
      (AP : Set) : Set where
      constructor CancellativeMonoidProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
    record CancellativeMonoidHom
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeMonoid A1)
      (Ca2 : CancellativeMonoid A2) :
      Set where
      constructor CancellativeMonoidHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ca1 x1 x2) ==
            op Ca2 (hom x1) (hom x2)
        pres-e : hom (e Ca1) == e Ca2
    record CancellativeMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeMonoid A1)
      (Ca2 : CancellativeMonoid A2) :
      Set where
      constructor CancellativeMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ca1 x1 x2)
            (op Ca2 y1 y2)
        interp-e :
          interp (e Ca1) (e Ca2)
    data CancellativeMonoidLang
      : Set where
      opL :
        CancellativeMonoidLang ->
        CancellativeMonoidLang ->
        CancellativeMonoidLang
      eL : CancellativeMonoidLang
    data CancellativeMonoidOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        CancellativeMonoidOpenLang
      opOL :
        CancellativeMonoidOpenLang ->
        CancellativeMonoidOpenLang ->
        CancellativeMonoidOpenLang
      eOL : CancellativeMonoidOpenLang
  
  module CancellativeSemigroup where
    record CancellativeSemigroup
      (A : Set) : Set where
      constructor CancellativeSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
    record CancellativeSemigroupSig
      (AS : Set) : Set where
      constructor CancellativeSemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record CancellativeSemigroupProd
      (AP : Set) : Set where
      constructor CancellativeSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
    record CancellativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeSemigroup A1)
      (Ca2 : CancellativeSemigroup
         A2) : Set where
      constructor CancellativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ca1 x1 x2) ==
            op Ca2 (hom x1) (hom x2)
    record CancellativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeSemigroup A1)
      (Ca2 : CancellativeSemigroup
         A2) : Set where
      constructor CancellativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ca1 x1 x2)
            (op Ca2 y1 y2)
    data CancellativeSemigroupLang
      : Set where
      opL :
        CancellativeSemigroupLang ->
        CancellativeSemigroupLang ->
        CancellativeSemigroupLang
    data CancellativeSemigroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        CancellativeSemigroupOpenLang
      opOL :
        CancellativeSemigroupOpenLang ->
        CancellativeSemigroupOpenLang ->
        CancellativeSemigroupOpenLang
  
  module Carrier where
    record Carrier
      (A : Set) : Set where
      constructor CarrierC
      field
        
    record CarrierSig
      (AS : Set) : Set where
      constructor CarrierSigSigC
      field
        
    record CarrierProd
      (AP : Set) : Set where
      constructor CarrierProdC
      field
        
    record CarrierHom
      (A1 : Set) (A2 : Set)
      (Ca1 : Carrier A1)
      (Ca2 : Carrier A2) : Set where
      constructor CarrierHomC
      field
        hom : A1 -> A2
    record CarrierRelInterp
      (A1 : Set) (A2 : Set)
      (Ca1 : Carrier A1)
      (Ca2 : Carrier A2) : Set where
      constructor CarrierRelInterpC
      field
        interp : A1 -> A2 -> Set
    data CarrierLang : Set where
      
    data CarrierOpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> CarrierOpenLang
  
  module CommutativeAdditiveMagma where
    record CommutativeAdditiveMagma
      (A : Set) : Set where
      constructor CommutativeAdditiveMagmaC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
    record CommutativeAdditiveMagmaSig
      (AS : Set) : Set where
      constructor CommutativeAdditiveMagmaSigSigC
      field
        +S : AS -> AS -> AS
    record CommutativeAdditiveMagmaProd
      (AP : Set) : Set where
      constructor CommutativeAdditiveMagmaProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
    record CommutativeAdditiveMagmaHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeAdditiveMagma
         A1)
      (Co2 : CommutativeAdditiveMagma
         A2) : Set where
      constructor CommutativeAdditiveMagmaHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Co1 x1 x2) ==
            + Co2 (hom x1) (hom x2)
    record CommutativeAdditiveMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeAdditiveMagma
         A1)
      (Co2 : CommutativeAdditiveMagma
         A2) : Set where
      constructor CommutativeAdditiveMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Co1 x1 x2)
            (+ Co2 y1 y2)
    data CommutativeAdditiveMagmaLang
      : Set where
      +L :
        CommutativeAdditiveMagmaLang ->
        CommutativeAdditiveMagmaLang ->
        CommutativeAdditiveMagmaLang
    data CommutativeAdditiveMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        CommutativeAdditiveMagmaOpenLang
      +OL :
        CommutativeAdditiveMagmaOpenLang ->
        CommutativeAdditiveMagmaOpenLang ->
        CommutativeAdditiveMagmaOpenLang
  
  module CommutativeGroup where
    record CommutativeGroup
      (A : Set) : Set where
      constructor CommutativeGroupC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        inv : A -> A
        leftInverse_inv_op_e :
          (x : A) -> op x (inv x) == e
        rightInverse_inv_op_e :
          (x : A) -> op (inv x) x == e
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CommutativeGroupSig
      (AS : Set) : Set where
      constructor CommutativeGroupSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
        invS : AS -> AS
    record CommutativeGroupProd
      (AP : Set) : Set where
      constructor CommutativeGroupProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP xP (invP xP) == eP
        rightInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (invP xP) xP == eP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CommutativeGroupHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeGroup A1)
      (Co2 : CommutativeGroup A2) :
      Set where
      constructor CommutativeGroupHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Co1) == e Co2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
        pres-inv :
          (x1 : A1) ->
          hom (inv Co1 x1) ==
            inv Co2 (hom x1)
    record CommutativeGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeGroup A1)
      (Co2 : CommutativeGroup A2) :
      Set where
      constructor CommutativeGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Co1) (e Co2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Co1 x1) (inv Co2 y1)
    data CommutativeGroupLang
      : Set where
      eL : CommutativeGroupLang
      opL :
        CommutativeGroupLang ->
        CommutativeGroupLang ->
        CommutativeGroupLang
      invL :
        CommutativeGroupLang ->
        CommutativeGroupLang
    data CommutativeGroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        CommutativeGroupOpenLang
      eOL : CommutativeGroupOpenLang
      opOL :
        CommutativeGroupOpenLang ->
        CommutativeGroupOpenLang ->
        CommutativeGroupOpenLang
      invOL :
        CommutativeGroupOpenLang ->
        CommutativeGroupOpenLang
  
  module CommutativeMagma where
    record CommutativeMagma
      (A : Set) : Set where
      constructor CommutativeMagmaC
      field
        op : A -> A -> A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CommutativeMagmaSig
      (AS : Set) : Set where
      constructor CommutativeMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record CommutativeMagmaProd
      (AP : Set) : Set where
      constructor CommutativeMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CommutativeMagmaHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMagma A1)
      (Co2 : CommutativeMagma A2) :
      Set where
      constructor CommutativeMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
    record CommutativeMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMagma A1)
      (Co2 : CommutativeMagma A2) :
      Set where
      constructor CommutativeMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
    data CommutativeMagmaLang
      : Set where
      opL :
        CommutativeMagmaLang ->
        CommutativeMagmaLang ->
        CommutativeMagmaLang
    data CommutativeMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        CommutativeMagmaOpenLang
      opOL :
        CommutativeMagmaOpenLang ->
        CommutativeMagmaOpenLang ->
        CommutativeMagmaOpenLang
  
  module CommutativeMonoid where
    record CommutativeMonoid
      (A : Set) : Set where
      constructor CommutativeMonoidC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        e : A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CommutativeMonoidSig
      (AS : Set) : Set where
      constructor CommutativeMonoidSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record CommutativeMonoidProd
      (AP : Set) : Set where
      constructor CommutativeMonoidProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CommutativeMonoidHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMonoid A1)
      (Co2 : CommutativeMonoid A2) :
      Set where
      constructor CommutativeMonoidHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
        pres-e : hom (e Co1) == e Co2
    record CommutativeMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMonoid A1)
      (Co2 : CommutativeMonoid A2) :
      Set where
      constructor CommutativeMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
        interp-e :
          interp (e Co1) (e Co2)
    data CommutativeMonoidLang
      : Set where
      opL :
        CommutativeMonoidLang ->
        CommutativeMonoidLang ->
        CommutativeMonoidLang
      eL : CommutativeMonoidLang
    data CommutativeMonoidOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        CommutativeMonoidOpenLang
      opOL :
        CommutativeMonoidOpenLang ->
        CommutativeMonoidOpenLang ->
        CommutativeMonoidOpenLang
      eOL : CommutativeMonoidOpenLang
  
  module CommutativeMonoid1 where
    record CommutativeMonoid1
      (A : Set) : Set where
      constructor CommutativeMonoid1C
      field
        1 : A
        op : A -> A -> A
        lunit_1 : (x : A) -> op 1 x == x
        runit_1 : (x : A) -> op x 1 == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CommutativeMonoid1Sig
      (AS : Set) : Set where
      constructor CommutativeMonoid1SigSigC
      field
        1S : AS
        opS : AS -> AS -> AS
    record CommutativeMonoid1Prod
      (AP : Set) : Set where
      constructor CommutativeMonoid1ProdC
      field
        1P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          opP 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          opP xP 1P == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CommutativeMonoid1Hom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMonoid1 A1)
      (Co2 : CommutativeMonoid1 A2) :
      Set where
      constructor CommutativeMonoid1HomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Co1) == 1 Co2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
    record CommutativeMonoid1RelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMonoid1 A1)
      (Co2 : CommutativeMonoid1 A2) :
      Set where
      constructor CommutativeMonoid1RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Co1) (1 Co2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
    data CommutativeMonoid1Lang
      : Set where
      1L : CommutativeMonoid1Lang
      opL :
        CommutativeMonoid1Lang ->
        CommutativeMonoid1Lang ->
        CommutativeMonoid1Lang
    data CommutativeMonoid1OpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        CommutativeMonoid1OpenLang
      1OL : CommutativeMonoid1OpenLang
      opOL :
        CommutativeMonoid1OpenLang ->
        CommutativeMonoid1OpenLang ->
        CommutativeMonoid1OpenLang
  
  module CommutativePointedMagma where
    record CommutativePointedMagma
      (A : Set) : Set where
      constructor CommutativePointedMagmaC
      field
        op : A -> A -> A
        e : A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CommutativePointedMagmaSig
      (AS : Set) : Set where
      constructor CommutativePointedMagmaSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record CommutativePointedMagmaProd
      (AP : Set) : Set where
      constructor CommutativePointedMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CommutativePointedMagmaHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativePointedMagma
         A1)
      (Co2 : CommutativePointedMagma
         A2) : Set where
      constructor CommutativePointedMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
        pres-e : hom (e Co1) == e Co2
    record CommutativePointedMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativePointedMagma
         A1)
      (Co2 : CommutativePointedMagma
         A2) : Set where
      constructor CommutativePointedMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
        interp-e :
          interp (e Co1) (e Co2)
    data CommutativePointedMagmaLang
      : Set where
      opL :
        CommutativePointedMagmaLang ->
        CommutativePointedMagmaLang ->
        CommutativePointedMagmaLang
      eL : CommutativePointedMagmaLang
    data CommutativePointedMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        CommutativePointedMagmaOpenLang
      opOL :
        CommutativePointedMagmaOpenLang ->
        CommutativePointedMagmaOpenLang ->
        CommutativePointedMagmaOpenLang
      eOL :
        CommutativePointedMagmaOpenLang
  
  module CommutativeRing where
    record CommutativeRing
      (A : Set) : Set where
      constructor CommutativeRingC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
    record CommutativeRingSig
      (AS : Set) : Set where
      constructor CommutativeRingSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
    record CommutativeRingProd
      (AP : Set) : Set where
      constructor CommutativeRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
    record CommutativeRingHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeRing A1)
      (Co2 : CommutativeRing A2) :
      Set where
      constructor CommutativeRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Co1 x1 x2) ==
            * Co2 (hom x1) (hom x2)
        pres-1 : hom (1 Co1) == 1 Co2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Co1 x1 x2) ==
            + Co2 (hom x1) (hom x2)
        pres-0 : hom (0 Co1) == 0 Co2
        pres-neg :
          (x1 : A1) ->
          hom (neg Co1 x1) ==
            neg Co2 (hom x1)
    record CommutativeRingRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeRing A1)
      (Co2 : CommutativeRing A2) :
      Set where
      constructor CommutativeRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Co1 x1 x2)
            (* Co2 y1 y2)
        interp-1 :
          interp (1 Co1) (1 Co2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Co1 x1 x2)
            (+ Co2 y1 y2)
        interp-0 :
          interp (0 Co1) (0 Co2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Co1 x1) (neg Co2 y1)
    data CommutativeRingLang
      : Set where
      *L :
        CommutativeRingLang ->
        CommutativeRingLang ->
        CommutativeRingLang
      1L : CommutativeRingLang
      +L :
        CommutativeRingLang ->
        CommutativeRingLang ->
        CommutativeRingLang
      0L : CommutativeRingLang
      negL :
        CommutativeRingLang ->
        CommutativeRingLang
    data CommutativeRingOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> CommutativeRingOpenLang
      *OL :
        CommutativeRingOpenLang ->
        CommutativeRingOpenLang ->
        CommutativeRingOpenLang
      1OL : CommutativeRingOpenLang
      +OL :
        CommutativeRingOpenLang ->
        CommutativeRingOpenLang ->
        CommutativeRingOpenLang
      0OL : CommutativeRingOpenLang
      negOL :
        CommutativeRingOpenLang ->
        CommutativeRingOpenLang
  
  module CommutativeSemigroup where
    record CommutativeSemigroup
      (A : Set) : Set where
      constructor CommutativeSemigroupC
      field
        op : A -> A -> A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record CommutativeSemigroupSig
      (AS : Set) : Set where
      constructor CommutativeSemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record CommutativeSemigroupProd
      (AP : Set) : Set where
      constructor CommutativeSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record CommutativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeSemigroup A1)
      (Co2 : CommutativeSemigroup
         A2) : Set where
      constructor CommutativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
    record CommutativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeSemigroup A1)
      (Co2 : CommutativeSemigroup
         A2) : Set where
      constructor CommutativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
    data CommutativeSemigroupLang
      : Set where
      opL :
        CommutativeSemigroupLang ->
        CommutativeSemigroupLang ->
        CommutativeSemigroupLang
    data CommutativeSemigroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        CommutativeSemigroupOpenLang
      opOL :
        CommutativeSemigroupOpenLang ->
        CommutativeSemigroupOpenLang ->
        CommutativeSemigroupOpenLang
  
  module ComplementSig where
    record ComplementSig
      (A : Set) : Set where
      constructor ComplementSigC
      field
        compl : A -> A
    record ComplementSigSig
      (AS : Set) : Set where
      constructor ComplementSigSigSigC
      field
        complS : AS -> AS
    record ComplementSigProd
      (AP : Set) : Set where
      constructor ComplementSigProdC
      field
        complP :
          Prod AP AP -> Prod AP AP
    record ComplementSigHom
      (A1 : Set) (A2 : Set)
      (Co1 : ComplementSig A1)
      (Co2 : ComplementSig A2) :
      Set where
      constructor ComplementSigHomC
      field
        hom : A1 -> A2
        pres-compl :
          (x1 : A1) ->
          hom (compl Co1 x1) ==
            compl Co2 (hom x1)
    record ComplementSigRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : ComplementSig A1)
      (Co2 : ComplementSig A2) :
      Set where
      constructor ComplementSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-compl :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (compl Co1 x1)
            (compl Co2 y1)
    data ComplementSigLang
      : Set where
      complL :
        ComplementSigLang ->
        ComplementSigLang
    data ComplementSigOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> ComplementSigOpenLang
      complOL :
        ComplementSigOpenLang ->
        ComplementSigOpenLang
  
  module DistributiveLattice where
    record DistributiveLattice
      (A : Set) : Set where
      constructor DistributiveLatticeC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
        leftModular_*_+ :
          (x : A) (y : A) (z : A) ->
          + (* x y) (* x z) ==
            * x (+ y (* x z))
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
    record DistributiveLatticeSig
      (AS : Set) : Set where
      constructor DistributiveLatticeSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record DistributiveLatticeProd
      (AP : Set) : Set where
      constructor DistributiveLatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
        leftModular_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (*P xP yP) (*P xP zP) ==
            *P xP (+P yP (*P xP zP))
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
    record DistributiveLatticeHom
      (A1 : Set) (A2 : Set)
      (Di1 : DistributiveLattice A1)
      (Di2 : DistributiveLattice A2) :
      Set where
      constructor DistributiveLatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Di1 x1 x2) ==
            * Di2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Di1 x1 x2) ==
            + Di2 (hom x1) (hom x2)
    record DistributiveLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Di1 : DistributiveLattice A1)
      (Di2 : DistributiveLattice A2) :
      Set where
      constructor DistributiveLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Di1 x1 x2)
            (* Di2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Di1 x1 x2)
            (+ Di2 y1 y2)
    data DistributiveLatticeLang
      : Set where
      *L :
        DistributiveLatticeLang ->
        DistributiveLatticeLang ->
        DistributiveLatticeLang
      +L :
        DistributiveLatticeLang ->
        DistributiveLatticeLang ->
        DistributiveLatticeLang
    data DistributiveLatticeOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        DistributiveLatticeOpenLang
      *OL :
        DistributiveLatticeOpenLang ->
        DistributiveLatticeOpenLang ->
        DistributiveLatticeOpenLang
      +OL :
        DistributiveLatticeOpenLang ->
        DistributiveLatticeOpenLang ->
        DistributiveLatticeOpenLang
  
  module DoubleMonoid where
    record DoubleMonoid
      (A : Set) : Set where
      constructor DoubleMonoidC
      field
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
    record DoubleMonoidSig
      (AS : Set) : Set where
      constructor DoubleMonoidSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
        *S : AS -> AS -> AS
        1S : AS
    record DoubleMonoidProd
      (AP : Set) : Set where
      constructor DoubleMonoidProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
    record DoubleMonoidHom
      (A1 : Set) (A2 : Set)
      (Do1 : DoubleMonoid A1)
      (Do2 : DoubleMonoid A2) :
      Set where
      constructor DoubleMonoidHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Do1 x1 x2) ==
            + Do2 (hom x1) (hom x2)
        pres-0 : hom (0 Do1) == 0 Do2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Do1 x1 x2) ==
            * Do2 (hom x1) (hom x2)
        pres-1 : hom (1 Do1) == 1 Do2
    record DoubleMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Do1 : DoubleMonoid A1)
      (Do2 : DoubleMonoid A2) :
      Set where
      constructor DoubleMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Do1 x1 x2)
            (+ Do2 y1 y2)
        interp-0 :
          interp (0 Do1) (0 Do2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Do1 x1 x2)
            (* Do2 y1 y2)
        interp-1 :
          interp (1 Do1) (1 Do2)
    data DoubleMonoidLang
      : Set where
      +L :
        DoubleMonoidLang ->
        DoubleMonoidLang ->
        DoubleMonoidLang
      0L : DoubleMonoidLang
      *L :
        DoubleMonoidLang ->
        DoubleMonoidLang ->
        DoubleMonoidLang
      1L : DoubleMonoidLang
    data DoubleMonoidOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> DoubleMonoidOpenLang
      +OL :
        DoubleMonoidOpenLang ->
        DoubleMonoidOpenLang ->
        DoubleMonoidOpenLang
      0OL : DoubleMonoidOpenLang
      *OL :
        DoubleMonoidOpenLang ->
        DoubleMonoidOpenLang ->
        DoubleMonoidOpenLang
      1OL : DoubleMonoidOpenLang
  
  module DualDeMorgan where
    record DualDeMorgan
      (A : Set) : Set where
      constructor DualDeMorganC
      field
        * : A -> A -> A
        + : A -> A -> A
        prim : A -> A
        andDeMorgan_*_+_prim :
          (x : A) (y : A) (z : A) ->
          prim (* x y) ==
            + (prim x) (prim y)
        orDeMorgan_+_*_prim :
          (x : A) (y : A) (z : A) ->
          prim (+ x y) ==
            * (prim x) (prim y)
    record DualDeMorganSig
      (AS : Set) : Set where
      constructor DualDeMorganSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        primS : AS -> AS
    record DualDeMorganProd
      (AP : Set) : Set where
      constructor DualDeMorganProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        andDeMorgan_*_+_primP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          primP (*P xP yP) ==
            +P (primP xP) (primP yP)
        orDeMorgan_+_*_primP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          primP (+P xP yP) ==
            *P (primP xP) (primP yP)
    record DualDeMorganHom
      (A1 : Set) (A2 : Set)
      (Du1 : DualDeMorgan A1)
      (Du2 : DualDeMorgan A2) :
      Set where
      constructor DualDeMorganHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Du1 x1 x2) ==
            * Du2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Du1 x1 x2) ==
            + Du2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Du1 x1) ==
            prim Du2 (hom x1)
    record DualDeMorganRelInterp
      (A1 : Set) (A2 : Set)
      (Du1 : DualDeMorgan A1)
      (Du2 : DualDeMorgan A2) :
      Set where
      constructor DualDeMorganRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Du1 x1 x2)
            (* Du2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Du1 x1 x2)
            (+ Du2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Du1 x1)
            (prim Du2 y1)
    data DualDeMorganLang
      : Set where
      *L :
        DualDeMorganLang ->
        DualDeMorganLang ->
        DualDeMorganLang
      +L :
        DualDeMorganLang ->
        DualDeMorganLang ->
        DualDeMorganLang
      primL :
        DualDeMorganLang ->
        DualDeMorganLang
    data DualDeMorganOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> DualDeMorganOpenLang
      *OL :
        DualDeMorganOpenLang ->
        DualDeMorganOpenLang ->
        DualDeMorganOpenLang
      +OL :
        DualDeMorganOpenLang ->
        DualDeMorganOpenLang ->
        DualDeMorganOpenLang
      primOL :
        DualDeMorganOpenLang ->
        DualDeMorganOpenLang
  
  module DualSemilattices where
    record DualSemilattices
      (A : Set) : Set where
      constructor DualSemilatticesC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
    record DualSemilatticesSig
      (AS : Set) : Set where
      constructor DualSemilatticesSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record DualSemilatticesProd
      (AP : Set) : Set where
      constructor DualSemilatticesProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record DualSemilatticesHom
      (A1 : Set) (A2 : Set)
      (Du1 : DualSemilattices A1)
      (Du2 : DualSemilattices A2) :
      Set where
      constructor DualSemilatticesHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Du1 x1 x2) ==
            * Du2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Du1 x1 x2) ==
            + Du2 (hom x1) (hom x2)
    record DualSemilatticesRelInterp
      (A1 : Set) (A2 : Set)
      (Du1 : DualSemilattices A1)
      (Du2 : DualSemilattices A2) :
      Set where
      constructor DualSemilatticesRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Du1 x1 x2)
            (* Du2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Du1 x1 x2)
            (+ Du2 y1 y2)
    data DualSemilatticesLang
      : Set where
      *L :
        DualSemilatticesLang ->
        DualSemilatticesLang ->
        DualSemilatticesLang
      +L :
        DualSemilatticesLang ->
        DualSemilatticesLang ->
        DualSemilatticesLang
    data DualSemilatticesOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        DualSemilatticesOpenLang
      *OL :
        DualSemilatticesOpenLang ->
        DualSemilatticesOpenLang ->
        DualSemilatticesOpenLang
      +OL :
        DualSemilatticesOpenLang ->
        DualSemilatticesOpenLang ->
        DualSemilatticesOpenLang
  
  module Empty where
    record Empty : Set where
      constructor EmptyC
      field
        
  
  module FixedPoint where
    record FixedPoint
      (A : Set) : Set where
      constructor FixedPointC
      field
        prim : A -> A
        e : A
        fixes_prim_e : prim e == e
    record FixedPointSig
      (AS : Set) : Set where
      constructor FixedPointSigSigC
      field
        primS : AS -> AS
        eS : AS
    record FixedPointProd
      (AP : Set) : Set where
      constructor FixedPointProdC
      field
        primP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        fixes_prim_eP : primP eP == eP
    record FixedPointHom
      (A1 : Set) (A2 : Set)
      (Fi1 : FixedPoint A1)
      (Fi2 : FixedPoint A2) :
      Set where
      constructor FixedPointHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Fi1 x1) ==
            prim Fi2 (hom x1)
        pres-e : hom (e Fi1) == e Fi2
    record FixedPointRelInterp
      (A1 : Set) (A2 : Set)
      (Fi1 : FixedPoint A1)
      (Fi2 : FixedPoint A2) :
      Set where
      constructor FixedPointRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Fi1 x1)
            (prim Fi2 y1)
        interp-e :
          interp (e Fi1) (e Fi2)
    data FixedPointLang : Set where
      primL :
        FixedPointLang -> FixedPointLang
      eL : FixedPointLang
    data FixedPointOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> FixedPointOpenLang
      primOL :
        FixedPointOpenLang ->
        FixedPointOpenLang
      eOL : FixedPointOpenLang
  
  module Group where
    record Group
      (A : Set) : Set where
      constructor GroupC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        inv : A -> A
        leftInverse_inv_op_e :
          (x : A) -> op x (inv x) == e
        rightInverse_inv_op_e :
          (x : A) -> op (inv x) x == e
    record GroupSig
      (AS : Set) : Set where
      constructor GroupSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
        invS : AS -> AS
    record GroupProd
      (AP : Set) : Set where
      constructor GroupProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP xP (invP xP) == eP
        rightInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (invP xP) xP == eP
    record GroupHom
      (A1 : Set) (A2 : Set)
      (Gr1 : Group A1)
      (Gr2 : Group A2) : Set where
      constructor GroupHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Gr1) == e Gr2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Gr1 x1 x2) ==
            op Gr2 (hom x1) (hom x2)
        pres-inv :
          (x1 : A1) ->
          hom (inv Gr1 x1) ==
            inv Gr2 (hom x1)
    record GroupRelInterp
      (A1 : Set) (A2 : Set)
      (Gr1 : Group A1)
      (Gr2 : Group A2) : Set where
      constructor GroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Gr1) (e Gr2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Gr1 x1 x2)
            (op Gr2 y1 y2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Gr1 x1) (inv Gr2 y1)
    data GroupLang : Set where
      eL : GroupLang
      opL :
        GroupLang ->
        GroupLang -> GroupLang
      invL : GroupLang -> GroupLang
    data GroupOpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> GroupOpenLang
      eOL : GroupOpenLang
      opOL :
        GroupOpenLang ->
        GroupOpenLang -> GroupOpenLang
      invOL :
        GroupOpenLang -> GroupOpenLang
  
  module Group1 where
    record Group1
      (A : Set) : Set where
      constructor Group1C
      field
        1 : A
        op : A -> A -> A
        lunit_1 : (x : A) -> op 1 x == x
        runit_1 : (x : A) -> op x 1 == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        inv : A -> A
        leftInverse_inv_op_1 :
          (x : A) -> op x (inv x) == 1
        rightInverse_inv_op_1 :
          (x : A) -> op (inv x) x == 1
    record Group1Sig
      (AS : Set) : Set where
      constructor Group1SigSigC
      field
        1S : AS
        opS : AS -> AS -> AS
        invS : AS -> AS
    record Group1Prod
      (AP : Set) : Set where
      constructor Group1ProdC
      field
        1P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          opP 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          opP xP 1P == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          opP xP (invP xP) == 1P
        rightInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          opP (invP xP) xP == 1P
    record Group1Hom
      (A1 : Set) (A2 : Set)
      (Gr1 : Group1 A1)
      (Gr2 : Group1 A2) : Set where
      constructor Group1HomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Gr1) == 1 Gr2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Gr1 x1 x2) ==
            op Gr2 (hom x1) (hom x2)
        pres-inv :
          (x1 : A1) ->
          hom (inv Gr1 x1) ==
            inv Gr2 (hom x1)
    record Group1RelInterp
      (A1 : Set) (A2 : Set)
      (Gr1 : Group1 A1)
      (Gr2 : Group1 A2) : Set where
      constructor Group1RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Gr1) (1 Gr2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Gr1 x1 x2)
            (op Gr2 y1 y2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Gr1 x1) (inv Gr2 y1)
    data Group1Lang : Set where
      1L : Group1Lang
      opL :
        Group1Lang ->
        Group1Lang -> Group1Lang
      invL : Group1Lang -> Group1Lang
    data Group1OpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> Group1OpenLang
      1OL : Group1OpenLang
      opOL :
        Group1OpenLang ->
        Group1OpenLang -> Group1OpenLang
      invOL :
        Group1OpenLang -> Group1OpenLang
  
  module IdempotentAdditiveMagma where
    record IdempotentAdditiveMagma
      (A : Set) : Set where
      constructor IdempotentAdditiveMagmaC
      field
        + : A -> A -> A
        idempotent_+ :
          (x : A) -> + x x == x
    record IdempotentAdditiveMagmaSig
      (AS : Set) : Set where
      constructor IdempotentAdditiveMagmaSigSigC
      field
        +S : AS -> AS -> AS
    record IdempotentAdditiveMagmaProd
      (AP : Set) : Set where
      constructor IdempotentAdditiveMagmaProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record IdempotentAdditiveMagmaHom
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentAdditiveMagma
         A1)
      (Id2 : IdempotentAdditiveMagma
         A2) : Set where
      constructor IdempotentAdditiveMagmaHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Id1 x1 x2) ==
            + Id2 (hom x1) (hom x2)
    record IdempotentAdditiveMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentAdditiveMagma
         A1)
      (Id2 : IdempotentAdditiveMagma
         A2) : Set where
      constructor IdempotentAdditiveMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Id1 x1 x2)
            (+ Id2 y1 y2)
    data IdempotentAdditiveMagmaLang
      : Set where
      +L :
        IdempotentAdditiveMagmaLang ->
        IdempotentAdditiveMagmaLang ->
        IdempotentAdditiveMagmaLang
    data IdempotentAdditiveMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        IdempotentAdditiveMagmaOpenLang
      +OL :
        IdempotentAdditiveMagmaOpenLang ->
        IdempotentAdditiveMagmaOpenLang ->
        IdempotentAdditiveMagmaOpenLang
  
  module IdempotentMagma where
    record IdempotentMagma
      (A : Set) : Set where
      constructor IdempotentMagmaC
      field
        op : A -> A -> A
        idempotent_op :
          (x : A) -> op x x == x
    record IdempotentMagmaSig
      (AS : Set) : Set where
      constructor IdempotentMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record IdempotentMagmaProd
      (AP : Set) : Set where
      constructor IdempotentMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        idempotent_opP :
          (xP : Prod AP AP) ->
          opP xP xP == xP
    record IdempotentMagmaHom
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentMagma A1)
      (Id2 : IdempotentMagma A2) :
      Set where
      constructor IdempotentMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Id1 x1 x2) ==
            op Id2 (hom x1) (hom x2)
    record IdempotentMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentMagma A1)
      (Id2 : IdempotentMagma A2) :
      Set where
      constructor IdempotentMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Id1 x1 x2)
            (op Id2 y1 y2)
    data IdempotentMagmaLang
      : Set where
      opL :
        IdempotentMagmaLang ->
        IdempotentMagmaLang ->
        IdempotentMagmaLang
    data IdempotentMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> IdempotentMagmaOpenLang
      opOL :
        IdempotentMagmaOpenLang ->
        IdempotentMagmaOpenLang ->
        IdempotentMagmaOpenLang
  
  module IdempotentMultMagma where
    record IdempotentMultMagma
      (A : Set) : Set where
      constructor IdempotentMultMagmaC
      field
        * : A -> A -> A
        idempotent_* :
          (x : A) -> * x x == x
    record IdempotentMultMagmaSig
      (AS : Set) : Set where
      constructor IdempotentMultMagmaSigSigC
      field
        *S : AS -> AS -> AS
    record IdempotentMultMagmaProd
      (AP : Set) : Set where
      constructor IdempotentMultMagmaProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
    record IdempotentMultMagmaHom
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentMultMagma A1)
      (Id2 : IdempotentMultMagma A2) :
      Set where
      constructor IdempotentMultMagmaHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Id1 x1 x2) ==
            * Id2 (hom x1) (hom x2)
    record IdempotentMultMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentMultMagma A1)
      (Id2 : IdempotentMultMagma A2) :
      Set where
      constructor IdempotentMultMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Id1 x1 x2)
            (* Id2 y1 y2)
    data IdempotentMultMagmaLang
      : Set where
      *L :
        IdempotentMultMagmaLang ->
        IdempotentMultMagmaLang ->
        IdempotentMultMagmaLang
    data IdempotentMultMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        IdempotentMultMagmaOpenLang
      *OL :
        IdempotentMultMagmaOpenLang ->
        IdempotentMultMagmaOpenLang ->
        IdempotentMultMagmaOpenLang
  
  module IdempotentSemiRng where
    record IdempotentSemiRng
      (A : Set) : Set where
      constructor IdempotentSemiRngC
      field
        + : A -> A -> A
        * : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        idempotent_+ :
          (x : A) -> + x x == x
    record IdempotentSemiRngSig
      (AS : Set) : Set where
      constructor IdempotentSemiRngSigSigC
      field
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
        0S : AS
    record IdempotentSemiRngProd
      (AP : Set) : Set where
      constructor IdempotentSemiRngProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record IdempotentSemiRngHom
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentSemiRng A1)
      (Id2 : IdempotentSemiRng A2) :
      Set where
      constructor IdempotentSemiRngHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Id1 x1 x2) ==
            + Id2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Id1 x1 x2) ==
            * Id2 (hom x1) (hom x2)
        pres-0 : hom (0 Id1) == 0 Id2
    record IdempotentSemiRngRelInterp
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentSemiRng A1)
      (Id2 : IdempotentSemiRng A2) :
      Set where
      constructor IdempotentSemiRngRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Id1 x1 x2)
            (+ Id2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Id1 x1 x2)
            (* Id2 y1 y2)
        interp-0 :
          interp (0 Id1) (0 Id2)
    data IdempotentSemiRngLang
      : Set where
      +L :
        IdempotentSemiRngLang ->
        IdempotentSemiRngLang ->
        IdempotentSemiRngLang
      *L :
        IdempotentSemiRngLang ->
        IdempotentSemiRngLang ->
        IdempotentSemiRngLang
      0L : IdempotentSemiRngLang
    data IdempotentSemiRngOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        IdempotentSemiRngOpenLang
      +OL :
        IdempotentSemiRngOpenLang ->
        IdempotentSemiRngOpenLang ->
        IdempotentSemiRngOpenLang
      *OL :
        IdempotentSemiRngOpenLang ->
        IdempotentSemiRngOpenLang ->
        IdempotentSemiRngOpenLang
      0OL : IdempotentSemiRngOpenLang
  
  module IdempotentSemiring where
    record IdempotentSemiring
      (A : Set) : Set where
      constructor IdempotentSemiringC
      field
        + : A -> A -> A
        0 : A
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
        idempotent_+ :
          (x : A) -> + x x == x
    record IdempotentSemiringSig
      (AS : Set) : Set where
      constructor IdempotentSemiringSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
        *S : AS -> AS -> AS
        1S : AS
    record IdempotentSemiringProd
      (AP : Set) : Set where
      constructor IdempotentSemiringProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record IdempotentSemiringHom
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentSemiring A1)
      (Id2 : IdempotentSemiring A2) :
      Set where
      constructor IdempotentSemiringHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Id1 x1 x2) ==
            + Id2 (hom x1) (hom x2)
        pres-0 : hom (0 Id1) == 0 Id2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Id1 x1 x2) ==
            * Id2 (hom x1) (hom x2)
        pres-1 : hom (1 Id1) == 1 Id2
    record IdempotentSemiringRelInterp
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentSemiring A1)
      (Id2 : IdempotentSemiring A2) :
      Set where
      constructor IdempotentSemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Id1 x1 x2)
            (+ Id2 y1 y2)
        interp-0 :
          interp (0 Id1) (0 Id2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Id1 x1 x2)
            (* Id2 y1 y2)
        interp-1 :
          interp (1 Id1) (1 Id2)
    data IdempotentSemiringLang
      : Set where
      +L :
        IdempotentSemiringLang ->
        IdempotentSemiringLang ->
        IdempotentSemiringLang
      0L : IdempotentSemiringLang
      *L :
        IdempotentSemiringLang ->
        IdempotentSemiringLang ->
        IdempotentSemiringLang
      1L : IdempotentSemiringLang
    data IdempotentSemiringOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        IdempotentSemiringOpenLang
      +OL :
        IdempotentSemiringOpenLang ->
        IdempotentSemiringOpenLang ->
        IdempotentSemiringOpenLang
      0OL : IdempotentSemiringOpenLang
      *OL :
        IdempotentSemiringOpenLang ->
        IdempotentSemiringOpenLang ->
        IdempotentSemiringOpenLang
      1OL : IdempotentSemiringOpenLang
  
  module IdempotentUnary where
    record IdempotentUnary
      (A : Set) : Set where
      constructor IdempotentUnaryC
      field
        prim : A -> A
        idempotent_prim :
          (x : A) ->
          prim (prim x) == prim x
    record IdempotentUnarySig
      (AS : Set) : Set where
      constructor IdempotentUnarySigSigC
      field
        primS : AS -> AS
    record IdempotentUnaryProd
      (AP : Set) : Set where
      constructor IdempotentUnaryProdC
      field
        primP : Prod AP AP -> Prod AP AP
        idempotent_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == primP xP
    record IdempotentUnaryHom
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentUnary A1)
      (Id2 : IdempotentUnary A2) :
      Set where
      constructor IdempotentUnaryHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Id1 x1) ==
            prim Id2 (hom x1)
    record IdempotentUnaryRelInterp
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentUnary A1)
      (Id2 : IdempotentUnary A2) :
      Set where
      constructor IdempotentUnaryRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Id1 x1)
            (prim Id2 y1)
    data IdempotentUnaryLang
      : Set where
      primL :
        IdempotentUnaryLang ->
        IdempotentUnaryLang
    data IdempotentUnaryOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> IdempotentUnaryOpenLang
      primOL :
        IdempotentUnaryOpenLang ->
        IdempotentUnaryOpenLang
  
  module Inverse where
    record Inverse
      (A : Set) : Set where
      constructor InverseC
      field
        inv : A -> A
        e : A
        op : A -> A -> A
        leftInverse_inv_op_e :
          (x : A) -> op x (inv x) == e
        rightInverse_inv_op_e :
          (x : A) -> op (inv x) x == e
    record InverseSig
      (AS : Set) : Set where
      constructor InverseSigSigC
      field
        invS : AS -> AS
        eS : AS
        opS : AS -> AS -> AS
    record InverseProd
      (AP : Set) : Set where
      constructor InverseProdC
      field
        invP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP xP (invP xP) == eP
        rightInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (invP xP) xP == eP
    record InverseHom
      (A1 : Set) (A2 : Set)
      (In1 : Inverse A1)
      (In2 : Inverse A2) : Set where
      constructor InverseHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv In1 x1) ==
            inv In2 (hom x1)
        pres-e : hom (e In1) == e In2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
    record InverseRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : Inverse A1)
      (In2 : Inverse A2) : Set where
      constructor InverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv In1 x1) (inv In2 y1)
        interp-e :
          interp (e In1) (e In2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
    data InverseLang : Set where
      invL :
        InverseLang -> InverseLang
      eL : InverseLang
      opL :
        InverseLang ->
        InverseLang -> InverseLang
    data InverseOpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> InverseOpenLang
      invOL :
        InverseOpenLang ->
        InverseOpenLang
      eOL : InverseOpenLang
      opOL :
        InverseOpenLang ->
        InverseOpenLang ->
        InverseOpenLang
  
  module InverseSig where
    record InverseSig
      (A : Set) : Set where
      constructor InverseSigC
      field
        inv : A -> A
        e : A
        op : A -> A -> A
    record InverseSigSig
      (AS : Set) : Set where
      constructor InverseSigSigSigC
      field
        invS : AS -> AS
        eS : AS
        opS : AS -> AS -> AS
    record InverseSigProd
      (AP : Set) : Set where
      constructor InverseSigProdC
      field
        invP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record InverseSigHom
      (A1 : Set) (A2 : Set)
      (In1 : InverseSig A1)
      (In2 : InverseSig A2) :
      Set where
      constructor InverseSigHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv In1 x1) ==
            inv In2 (hom x1)
        pres-e : hom (e In1) == e In2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
    record InverseSigRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InverseSig A1)
      (In2 : InverseSig A2) :
      Set where
      constructor InverseSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv In1 x1) (inv In2 y1)
        interp-e :
          interp (e In1) (e In2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
    data InverseSigLang : Set where
      invL :
        InverseSigLang -> InverseSigLang
      eL : InverseSigLang
      opL :
        InverseSigLang ->
        InverseSigLang -> InverseSigLang
    data InverseSigOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> InverseSigOpenLang
      invOL :
        InverseSigOpenLang ->
        InverseSigOpenLang
      eOL : InverseSigOpenLang
      opOL :
        InverseSigOpenLang ->
        InverseSigOpenLang ->
        InverseSigOpenLang
  
  module InverseUnaryOperation where
    record InverseUnaryOperation
      (A : Set) : Set where
      constructor InverseUnaryOperationC
      field
        inv : A -> A
    record InverseUnaryOperationSig
      (AS : Set) : Set where
      constructor InverseUnaryOperationSigSigC
      field
        invS : AS -> AS
    record InverseUnaryOperationProd
      (AP : Set) : Set where
      constructor InverseUnaryOperationProdC
      field
        invP : Prod AP AP -> Prod AP AP
    record InverseUnaryOperationHom
      (A1 : Set) (A2 : Set)
      (In1 : InverseUnaryOperation A1)
      (In2 : InverseUnaryOperation
         A2) : Set where
      constructor InverseUnaryOperationHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv In1 x1) ==
            inv In2 (hom x1)
    record InverseUnaryOperationRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InverseUnaryOperation A1)
      (In2 : InverseUnaryOperation
         A2) : Set where
      constructor InverseUnaryOperationRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv In1 x1) (inv In2 y1)
    data InverseUnaryOperationLang
      : Set where
      invL :
        InverseUnaryOperationLang ->
        InverseUnaryOperationLang
    data InverseUnaryOperationOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        InverseUnaryOperationOpenLang
      invOL :
        InverseUnaryOperationOpenLang ->
        InverseUnaryOperationOpenLang
  
  module Involution where
    record Involution
      (A : Set) : Set where
      constructor InvolutionC
      field
        prim : A -> A
        involutive_prim :
          (x : A) -> prim (prim x) == x
    record InvolutionSig
      (AS : Set) : Set where
      constructor InvolutionSigSigC
      field
        primS : AS -> AS
    record InvolutionProd
      (AP : Set) : Set where
      constructor InvolutionProdC
      field
        primP : Prod AP AP -> Prod AP AP
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
    record InvolutionHom
      (A1 : Set) (A2 : Set)
      (In1 : Involution A1)
      (In2 : Involution A2) :
      Set where
      constructor InvolutionHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutionRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : Involution A1)
      (In2 : Involution A2) :
      Set where
      constructor InvolutionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutionLang : Set where
      primL :
        InvolutionLang -> InvolutionLang
    data InvolutionOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> InvolutionOpenLang
      primOL :
        InvolutionOpenLang ->
        InvolutionOpenLang
  
  module InvolutiveAddMagmaSig where
    record InvolutiveAddMagmaSig
      (A : Set) : Set where
      constructor InvolutiveAddMagmaSigC
      field
        + : A -> A -> A
        prim : A -> A
    record InvolutiveAddMagmaSigSig
      (AS : Set) : Set where
      constructor InvolutiveAddMagmaSigSigSigC
      field
        +S : AS -> AS -> AS
        primS : AS -> AS
    record InvolutiveAddMagmaSigProd
      (AP : Set) : Set where
      constructor InvolutiveAddMagmaSigProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
    record InvolutiveAddMagmaSigHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveAddMagmaSig A1)
      (In2 : InvolutiveAddMagmaSig
         A2) : Set where
      constructor InvolutiveAddMagmaSigHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ In1 x1 x2) ==
            + In2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutiveAddMagmaSigRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveAddMagmaSig A1)
      (In2 : InvolutiveAddMagmaSig
         A2) : Set where
      constructor InvolutiveAddMagmaSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ In1 x1 x2)
            (+ In2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutiveAddMagmaSigLang
      : Set where
      +L :
        InvolutiveAddMagmaSigLang ->
        InvolutiveAddMagmaSigLang ->
        InvolutiveAddMagmaSigLang
      primL :
        InvolutiveAddMagmaSigLang ->
        InvolutiveAddMagmaSigLang
    data InvolutiveAddMagmaSigOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        InvolutiveAddMagmaSigOpenLang
      +OL :
        InvolutiveAddMagmaSigOpenLang ->
        InvolutiveAddMagmaSigOpenLang ->
        InvolutiveAddMagmaSigOpenLang
      primOL :
        InvolutiveAddMagmaSigOpenLang ->
        InvolutiveAddMagmaSigOpenLang
  
  module InvolutiveFixedPoint where
    record InvolutiveFixedPoint
      (A : Set) : Set where
      constructor InvolutiveFixedPointC
      field
        prim : A -> A
        1 : A
        fixes_prim_1 : prim 1 == 1
        involutive_prim :
          (x : A) -> prim (prim x) == x
    record InvolutiveFixedPointSig
      (AS : Set) : Set where
      constructor InvolutiveFixedPointSigSigC
      field
        primS : AS -> AS
        1S : AS
    record InvolutiveFixedPointProd
      (AP : Set) : Set where
      constructor InvolutiveFixedPointProdC
      field
        primP : Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        fixes_prim_1P : primP 1P == 1P
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
    record InvolutiveFixedPointHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveFixedPoint A1)
      (In2 : InvolutiveFixedPoint
         A2) : Set where
      constructor InvolutiveFixedPointHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-1 : hom (1 In1) == 1 In2
    record InvolutiveFixedPointRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveFixedPoint A1)
      (In2 : InvolutiveFixedPoint
         A2) : Set where
      constructor InvolutiveFixedPointRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-1 :
          interp (1 In1) (1 In2)
    data InvolutiveFixedPointLang
      : Set where
      primL :
        InvolutiveFixedPointLang ->
        InvolutiveFixedPointLang
      1L : InvolutiveFixedPointLang
    data InvolutiveFixedPointOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        InvolutiveFixedPointOpenLang
      primOL :
        InvolutiveFixedPointOpenLang ->
        InvolutiveFixedPointOpenLang
      1OL :
        InvolutiveFixedPointOpenLang
  
  module InvolutiveFixes where
    record InvolutiveFixes
      (A : Set) : Set where
      constructor InvolutiveFixesC
      field
        1 : A
        prim : A -> A
        fixes_prim_1 : prim 1 == 1
    record InvolutiveFixesSig
      (AS : Set) : Set where
      constructor InvolutiveFixesSigSigC
      field
        1S : AS
        primS : AS -> AS
    record InvolutiveFixesProd
      (AP : Set) : Set where
      constructor InvolutiveFixesProdC
      field
        1P : Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        fixes_prim_1P : primP 1P == 1P
    record InvolutiveFixesHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveFixes A1)
      (In2 : InvolutiveFixes A2) :
      Set where
      constructor InvolutiveFixesHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 In1) == 1 In2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutiveFixesRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveFixes A1)
      (In2 : InvolutiveFixes A2) :
      Set where
      constructor InvolutiveFixesRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 In1) (1 In2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutiveFixesLang
      : Set where
      1L : InvolutiveFixesLang
      primL :
        InvolutiveFixesLang ->
        InvolutiveFixesLang
    data InvolutiveFixesOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> InvolutiveFixesOpenLang
      1OL : InvolutiveFixesOpenLang
      primOL :
        InvolutiveFixesOpenLang ->
        InvolutiveFixesOpenLang
  
  module InvolutiveMagma where
    record InvolutiveMagma
      (A : Set) : Set where
      constructor InvolutiveMagmaC
      field
        prim : A -> A
        involutive_prim :
          (x : A) -> prim (prim x) == x
        op : A -> A -> A
        antidis_prim_op :
          (x : A) (y : A) ->
          prim (op x y) ==
            op (prim y) (prim x)
    record InvolutiveMagmaSig
      (AS : Set) : Set where
      constructor InvolutiveMagmaSigSigC
      field
        primS : AS -> AS
        opS : AS -> AS -> AS
    record InvolutiveMagmaProd
      (AP : Set) : Set where
      constructor InvolutiveMagmaProdC
      field
        primP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
        antidis_prim_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (opP xP yP) ==
            opP (primP yP) (primP xP)
    record InvolutiveMagmaHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveMagma A1)
      (In2 : InvolutiveMagma A2) :
      Set where
      constructor InvolutiveMagmaHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
    record InvolutiveMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveMagma A1)
      (In2 : InvolutiveMagma A2) :
      Set where
      constructor InvolutiveMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
    data InvolutiveMagmaLang
      : Set where
      primL :
        InvolutiveMagmaLang ->
        InvolutiveMagmaLang
      opL :
        InvolutiveMagmaLang ->
        InvolutiveMagmaLang ->
        InvolutiveMagmaLang
    data InvolutiveMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> InvolutiveMagmaOpenLang
      primOL :
        InvolutiveMagmaOpenLang ->
        InvolutiveMagmaOpenLang
      opOL :
        InvolutiveMagmaOpenLang ->
        InvolutiveMagmaOpenLang ->
        InvolutiveMagmaOpenLang
  
  module InvolutiveMagmaSig where
    record InvolutiveMagmaSig
      (A : Set) : Set where
      constructor InvolutiveMagmaSigC
      field
        prim : A -> A
        op : A -> A -> A
    record InvolutiveMagmaSigSig
      (AS : Set) : Set where
      constructor InvolutiveMagmaSigSigSigC
      field
        primS : AS -> AS
        opS : AS -> AS -> AS
    record InvolutiveMagmaSigProd
      (AP : Set) : Set where
      constructor InvolutiveMagmaSigProdC
      field
        primP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record InvolutiveMagmaSigHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveMagmaSig A1)
      (In2 : InvolutiveMagmaSig A2) :
      Set where
      constructor InvolutiveMagmaSigHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
    record InvolutiveMagmaSigRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveMagmaSig A1)
      (In2 : InvolutiveMagmaSig A2) :
      Set where
      constructor InvolutiveMagmaSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
    data InvolutiveMagmaSigLang
      : Set where
      primL :
        InvolutiveMagmaSigLang ->
        InvolutiveMagmaSigLang
      opL :
        InvolutiveMagmaSigLang ->
        InvolutiveMagmaSigLang ->
        InvolutiveMagmaSigLang
    data InvolutiveMagmaSigOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        InvolutiveMagmaSigOpenLang
      primOL :
        InvolutiveMagmaSigOpenLang ->
        InvolutiveMagmaSigOpenLang
      opOL :
        InvolutiveMagmaSigOpenLang ->
        InvolutiveMagmaSigOpenLang ->
        InvolutiveMagmaSigOpenLang
  
  module InvolutiveMultMagmaSig where
    record InvolutiveMultMagmaSig
      (A : Set) : Set where
      constructor InvolutiveMultMagmaSigC
      field
        * : A -> A -> A
        prim : A -> A
    record InvolutiveMultMagmaSigSig
      (AS : Set) : Set where
      constructor InvolutiveMultMagmaSigSigSigC
      field
        *S : AS -> AS -> AS
        primS : AS -> AS
    record InvolutiveMultMagmaSigProd
      (AP : Set) : Set where
      constructor InvolutiveMultMagmaSigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
    record InvolutiveMultMagmaSigHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveMultMagmaSig
         A1)
      (In2 : InvolutiveMultMagmaSig
         A2) : Set where
      constructor InvolutiveMultMagmaSigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* In1 x1 x2) ==
            * In2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutiveMultMagmaSigRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveMultMagmaSig
         A1)
      (In2 : InvolutiveMultMagmaSig
         A2) : Set where
      constructor InvolutiveMultMagmaSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* In1 x1 x2)
            (* In2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutiveMultMagmaSigLang
      : Set where
      *L :
        InvolutiveMultMagmaSigLang ->
        InvolutiveMultMagmaSigLang ->
        InvolutiveMultMagmaSigLang
      primL :
        InvolutiveMultMagmaSigLang ->
        InvolutiveMultMagmaSigLang
    data InvolutiveMultMagmaSigOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        InvolutiveMultMagmaSigOpenLang
      *OL :
        InvolutiveMultMagmaSigOpenLang ->
        InvolutiveMultMagmaSigOpenLang ->
        InvolutiveMultMagmaSigOpenLang
      primOL :
        InvolutiveMultMagmaSigOpenLang ->
        InvolutiveMultMagmaSigOpenLang
  
  module InvolutivePointedMagmaSig where
    record InvolutivePointedMagmaSig
      (A : Set) : Set where
      constructor InvolutivePointedMagmaSigC
      field
        prim : A -> A
        e : A
        op : A -> A -> A
    record InvolutivePointedMagmaSigSig
      (AS : Set) : Set where
      constructor InvolutivePointedMagmaSigSigSigC
      field
        primS : AS -> AS
        eS : AS
        opS : AS -> AS -> AS
    record InvolutivePointedMagmaSigProd
      (AP : Set) : Set where
      constructor InvolutivePointedMagmaSigProdC
      field
        primP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record InvolutivePointedMagmaSigHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutivePointedMagmaSig
         A1)
      (In2 : InvolutivePointedMagmaSig
         A2) : Set where
      constructor InvolutivePointedMagmaSigHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-e : hom (e In1) == e In2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
    record InvolutivePointedMagmaSigRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutivePointedMagmaSig
         A1)
      (In2 : InvolutivePointedMagmaSig
         A2) : Set where
      constructor InvolutivePointedMagmaSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-e :
          interp (e In1) (e In2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
    data InvolutivePointedMagmaSigLang
      : Set where
      primL :
        InvolutivePointedMagmaSigLang ->
        InvolutivePointedMagmaSigLang
      eL :
        InvolutivePointedMagmaSigLang
      opL :
        InvolutivePointedMagmaSigLang ->
        InvolutivePointedMagmaSigLang ->
        InvolutivePointedMagmaSigLang
    data InvolutivePointedMagmaSigOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        InvolutivePointedMagmaSigOpenLang
      primOL :
        InvolutivePointedMagmaSigOpenLang ->
        InvolutivePointedMagmaSigOpenLang
      eOL :
        InvolutivePointedMagmaSigOpenLang
      opOL :
        InvolutivePointedMagmaSigOpenLang ->
        InvolutivePointedMagmaSigOpenLang ->
        InvolutivePointedMagmaSigOpenLang
  
  module InvolutivePointedSemigroup where
    record InvolutivePointedSemigroup
      (A : Set) : Set where
      constructor InvolutivePointedSemigroupC
      field
        op : A -> A -> A
        e : A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        prim : A -> A
        involutive_prim :
          (x : A) -> prim (prim x) == x
        antidis_prim_op :
          (x : A) (y : A) ->
          prim (op x y) ==
            op (prim y) (prim x)
    record InvolutivePointedSemigroupSig
      (AS : Set) : Set where
      constructor InvolutivePointedSemigroupSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
        primS : AS -> AS
    record InvolutivePointedSemigroupProd
      (AP : Set) : Set where
      constructor InvolutivePointedSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
        antidis_prim_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (opP xP yP) ==
            opP (primP yP) (primP xP)
    record InvolutivePointedSemigroupHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutivePointedSemigroup
         A1)
      (In2 : InvolutivePointedSemigroup
         A2) : Set where
      constructor InvolutivePointedSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
        pres-e : hom (e In1) == e In2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutivePointedSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutivePointedSemigroup
         A1)
      (In2 : InvolutivePointedSemigroup
         A2) : Set where
      constructor InvolutivePointedSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
        interp-e :
          interp (e In1) (e In2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutivePointedSemigroupLang
      : Set where
      opL :
        InvolutivePointedSemigroupLang ->
        InvolutivePointedSemigroupLang ->
        InvolutivePointedSemigroupLang
      eL :
        InvolutivePointedSemigroupLang
      primL :
        InvolutivePointedSemigroupLang ->
        InvolutivePointedSemigroupLang
    data InvolutivePointedSemigroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        InvolutivePointedSemigroupOpenLang
      opOL :
        InvolutivePointedSemigroupOpenLang ->
        InvolutivePointedSemigroupOpenLang ->
        InvolutivePointedSemigroupOpenLang
      eOL :
        InvolutivePointedSemigroupOpenLang
      primOL :
        InvolutivePointedSemigroupOpenLang ->
        InvolutivePointedSemigroupOpenLang
  
  module InvolutiveRing where
    record InvolutiveRing
      (A : Set) : Set where
      constructor InvolutiveRingC
      field
        * : A -> A -> A
        + : A -> A -> A
        1 : A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        prim : A -> A
        fixes_prim_1 : prim 1 == 1
        involutive_prim :
          (x : A) -> prim (prim x) == x
        antidis_prim_+ :
          (x : A) (y : A) ->
          prim (+ x y) ==
            + (prim y) (prim x)
        antidis_prim_* :
          (x : A) (y : A) ->
          prim (* x y) ==
            * (prim y) (prim x)
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
    record InvolutiveRingSig
      (AS : Set) : Set where
      constructor InvolutiveRingSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        1S : AS
        primS : AS -> AS
        0S : AS
        negS : AS -> AS
    record InvolutiveRingProd
      (AP : Set) : Set where
      constructor InvolutiveRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        fixes_prim_1P : primP 1P == 1P
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
        antidis_prim_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (+P xP yP) ==
            +P (primP yP) (primP xP)
        antidis_prim_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (*P xP yP) ==
            *P (primP yP) (primP xP)
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
    record InvolutiveRingHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRing A1)
      (In2 : InvolutiveRing A2) :
      Set where
      constructor InvolutiveRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* In1 x1 x2) ==
            * In2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ In1 x1 x2) ==
            + In2 (hom x1) (hom x2)
        pres-1 : hom (1 In1) == 1 In2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-0 : hom (0 In1) == 0 In2
        pres-neg :
          (x1 : A1) ->
          hom (neg In1 x1) ==
            neg In2 (hom x1)
    record InvolutiveRingRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRing A1)
      (In2 : InvolutiveRing A2) :
      Set where
      constructor InvolutiveRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* In1 x1 x2)
            (* In2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ In1 x1 x2)
            (+ In2 y1 y2)
        interp-1 :
          interp (1 In1) (1 In2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-0 :
          interp (0 In1) (0 In2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg In1 x1) (neg In2 y1)
    data InvolutiveRingLang
      : Set where
      *L :
        InvolutiveRingLang ->
        InvolutiveRingLang ->
        InvolutiveRingLang
      +L :
        InvolutiveRingLang ->
        InvolutiveRingLang ->
        InvolutiveRingLang
      1L : InvolutiveRingLang
      primL :
        InvolutiveRingLang ->
        InvolutiveRingLang
      0L : InvolutiveRingLang
      negL :
        InvolutiveRingLang ->
        InvolutiveRingLang
    data InvolutiveRingOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> InvolutiveRingOpenLang
      *OL :
        InvolutiveRingOpenLang ->
        InvolutiveRingOpenLang ->
        InvolutiveRingOpenLang
      +OL :
        InvolutiveRingOpenLang ->
        InvolutiveRingOpenLang ->
        InvolutiveRingOpenLang
      1OL : InvolutiveRingOpenLang
      primOL :
        InvolutiveRingOpenLang ->
        InvolutiveRingOpenLang
      0OL : InvolutiveRingOpenLang
      negOL :
        InvolutiveRingOpenLang ->
        InvolutiveRingOpenLang
  
  module InvolutiveRingoid where
    record InvolutiveRingoid
      (A : Set) : Set where
      constructor InvolutiveRingoidC
      field
        prim : A -> A
        1 : A
        fixes_prim_1 : prim 1 == 1
        involutive_prim :
          (x : A) -> prim (prim x) == x
        * : A -> A -> A
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        antidis_prim_+ :
          (x : A) (y : A) ->
          prim (+ x y) ==
            + (prim y) (prim x)
        antidis_prim_* :
          (x : A) (y : A) ->
          prim (* x y) ==
            * (prim y) (prim x)
    record InvolutiveRingoidSig
      (AS : Set) : Set where
      constructor InvolutiveRingoidSigSigC
      field
        primS : AS -> AS
        1S : AS
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record InvolutiveRingoidProd
      (AP : Set) : Set where
      constructor InvolutiveRingoidProdC
      field
        primP : Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        fixes_prim_1P : primP 1P == 1P
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        antidis_prim_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (+P xP yP) ==
            +P (primP yP) (primP xP)
        antidis_prim_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (*P xP yP) ==
            *P (primP yP) (primP xP)
    record InvolutiveRingoidHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRingoid A1)
      (In2 : InvolutiveRingoid A2) :
      Set where
      constructor InvolutiveRingoidHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-1 : hom (1 In1) == 1 In2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* In1 x1 x2) ==
            * In2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ In1 x1 x2) ==
            + In2 (hom x1) (hom x2)
    record InvolutiveRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRingoid A1)
      (In2 : InvolutiveRingoid A2) :
      Set where
      constructor InvolutiveRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-1 :
          interp (1 In1) (1 In2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* In1 x1 x2)
            (* In2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ In1 x1 x2)
            (+ In2 y1 y2)
    data InvolutiveRingoidLang
      : Set where
      primL :
        InvolutiveRingoidLang ->
        InvolutiveRingoidLang
      1L : InvolutiveRingoidLang
      *L :
        InvolutiveRingoidLang ->
        InvolutiveRingoidLang ->
        InvolutiveRingoidLang
      +L :
        InvolutiveRingoidLang ->
        InvolutiveRingoidLang ->
        InvolutiveRingoidLang
    data InvolutiveRingoidOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        InvolutiveRingoidOpenLang
      primOL :
        InvolutiveRingoidOpenLang ->
        InvolutiveRingoidOpenLang
      1OL : InvolutiveRingoidOpenLang
      *OL :
        InvolutiveRingoidOpenLang ->
        InvolutiveRingoidOpenLang ->
        InvolutiveRingoidOpenLang
      +OL :
        InvolutiveRingoidOpenLang ->
        InvolutiveRingoidOpenLang ->
        InvolutiveRingoidOpenLang
  
  module InvolutiveRingoidSig where
    record InvolutiveRingoidSig
      (A : Set) : Set where
      constructor InvolutiveRingoidSigC
      field
        prim : A -> A
        * : A -> A -> A
        + : A -> A -> A
    record InvolutiveRingoidSigSig
      (AS : Set) : Set where
      constructor InvolutiveRingoidSigSigSigC
      field
        primS : AS -> AS
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record InvolutiveRingoidSigProd
      (AP : Set) : Set where
      constructor InvolutiveRingoidSigProdC
      field
        primP : Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record InvolutiveRingoidSigHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRingoidSig A1)
      (In2 : InvolutiveRingoidSig
         A2) : Set where
      constructor InvolutiveRingoidSigHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* In1 x1 x2) ==
            * In2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ In1 x1 x2) ==
            + In2 (hom x1) (hom x2)
    record InvolutiveRingoidSigRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRingoidSig A1)
      (In2 : InvolutiveRingoidSig
         A2) : Set where
      constructor InvolutiveRingoidSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* In1 x1 x2)
            (* In2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ In1 x1 x2)
            (+ In2 y1 y2)
    data InvolutiveRingoidSigLang
      : Set where
      primL :
        InvolutiveRingoidSigLang ->
        InvolutiveRingoidSigLang
      *L :
        InvolutiveRingoidSigLang ->
        InvolutiveRingoidSigLang ->
        InvolutiveRingoidSigLang
      +L :
        InvolutiveRingoidSigLang ->
        InvolutiveRingoidSigLang ->
        InvolutiveRingoidSigLang
    data InvolutiveRingoidSigOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        InvolutiveRingoidSigOpenLang
      primOL :
        InvolutiveRingoidSigOpenLang ->
        InvolutiveRingoidSigOpenLang
      *OL :
        InvolutiveRingoidSigOpenLang ->
        InvolutiveRingoidSigOpenLang ->
        InvolutiveRingoidSigOpenLang
      +OL :
        InvolutiveRingoidSigOpenLang ->
        InvolutiveRingoidSigOpenLang ->
        InvolutiveRingoidSigOpenLang
  
  module InvolutiveRingoidWithAntiDistrib where
    record InvolutiveRingoidWithAntiDistrib
      (A : Set) : Set where
      constructor InvolutiveRingoidWithAntiDistribC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        prim : A -> A
        antidis_prim_+ :
          (x : A) (y : A) ->
          prim (+ x y) ==
            + (prim y) (prim x)
        antidis_prim_* :
          (x : A) (y : A) ->
          prim (* x y) ==
            * (prim y) (prim x)
    record InvolutiveRingoidWithAntiDistribSig
      (AS : Set) : Set where
      constructor InvolutiveRingoidWithAntiDistribSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        primS : AS -> AS
    record InvolutiveRingoidWithAntiDistribProd
      (AP : Set) : Set where
      constructor InvolutiveRingoidWithAntiDistribProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        antidis_prim_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (+P xP yP) ==
            +P (primP yP) (primP xP)
        antidis_prim_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (*P xP yP) ==
            *P (primP yP) (primP xP)
    record InvolutiveRingoidWithAntiDistribHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRingoidWithAntiDistrib
         A1)
      (In2 : InvolutiveRingoidWithAntiDistrib
         A2) : Set where
      constructor InvolutiveRingoidWithAntiDistribHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* In1 x1 x2) ==
            * In2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ In1 x1 x2) ==
            + In2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutiveRingoidWithAntiDistribRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRingoidWithAntiDistrib
         A1)
      (In2 : InvolutiveRingoidWithAntiDistrib
         A2) : Set where
      constructor InvolutiveRingoidWithAntiDistribRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* In1 x1 x2)
            (* In2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ In1 x1 x2)
            (+ In2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutiveRingoidWithAntiDistribLang
      : Set where
      *L :
        InvolutiveRingoidWithAntiDistribLang ->
        InvolutiveRingoidWithAntiDistribLang ->
        InvolutiveRingoidWithAntiDistribLang
      +L :
        InvolutiveRingoidWithAntiDistribLang ->
        InvolutiveRingoidWithAntiDistribLang ->
        InvolutiveRingoidWithAntiDistribLang
      primL :
        InvolutiveRingoidWithAntiDistribLang ->
        InvolutiveRingoidWithAntiDistribLang
    data InvolutiveRingoidWithAntiDistribOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        InvolutiveRingoidWithAntiDistribOpenLang
      *OL :
        InvolutiveRingoidWithAntiDistribOpenLang ->
        InvolutiveRingoidWithAntiDistribOpenLang ->
        InvolutiveRingoidWithAntiDistribOpenLang
      +OL :
        InvolutiveRingoidWithAntiDistribOpenLang ->
        InvolutiveRingoidWithAntiDistribOpenLang ->
        InvolutiveRingoidWithAntiDistribOpenLang
      primOL :
        InvolutiveRingoidWithAntiDistribOpenLang ->
        InvolutiveRingoidWithAntiDistribOpenLang
  
  module InvolutiveSemigroup where
    record InvolutiveSemigroup
      (A : Set) : Set where
      constructor InvolutiveSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        prim : A -> A
        involutive_prim :
          (x : A) -> prim (prim x) == x
        antidis_prim_op :
          (x : A) (y : A) ->
          prim (op x y) ==
            op (prim y) (prim x)
    record InvolutiveSemigroupSig
      (AS : Set) : Set where
      constructor InvolutiveSemigroupSigSigC
      field
        opS : AS -> AS -> AS
        primS : AS -> AS
    record InvolutiveSemigroupProd
      (AP : Set) : Set where
      constructor InvolutiveSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
        antidis_prim_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (opP xP yP) ==
            opP (primP yP) (primP xP)
    record InvolutiveSemigroupHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveSemigroup A1)
      (In2 : InvolutiveSemigroup A2) :
      Set where
      constructor InvolutiveSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutiveSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveSemigroup A1)
      (In2 : InvolutiveSemigroup A2) :
      Set where
      constructor InvolutiveSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutiveSemigroupLang
      : Set where
      opL :
        InvolutiveSemigroupLang ->
        InvolutiveSemigroupLang ->
        InvolutiveSemigroupLang
      primL :
        InvolutiveSemigroupLang ->
        InvolutiveSemigroupLang
    data InvolutiveSemigroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        InvolutiveSemigroupOpenLang
      opOL :
        InvolutiveSemigroupOpenLang ->
        InvolutiveSemigroupOpenLang ->
        InvolutiveSemigroupOpenLang
      primOL :
        InvolutiveSemigroupOpenLang ->
        InvolutiveSemigroupOpenLang
  
  module JacobianIdentity where
    record JacobianIdentity
      (A : Set) : Set where
      constructor JacobianIdentityC
      field
        0 : A
        + : A -> A -> A
        * : A -> A -> A
        jacobian_*_+ :
          (x : A) (y : A) (z : A) ->
          +
            (+ (* x (* y z)) (* y (* z x)))
            (* z (* x y)) == 0
    record JacobianIdentitySig
      (AS : Set) : Set where
      constructor JacobianIdentitySigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
    record JacobianIdentityProd
      (AP : Set) : Set where
      constructor JacobianIdentityProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        jacobian_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P
            (+P (*P xP (*P yP zP))
               (*P yP (*P zP xP)))
            (*P zP (*P xP yP)) == 0P
    record JacobianIdentityHom
      (A1 : Set) (A2 : Set)
      (Ja1 : JacobianIdentity A1)
      (Ja2 : JacobianIdentity A2) :
      Set where
      constructor JacobianIdentityHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ja1) == 0 Ja2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ja1 x1 x2) ==
            + Ja2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ja1 x1 x2) ==
            * Ja2 (hom x1) (hom x2)
    record JacobianIdentityRelInterp
      (A1 : Set) (A2 : Set)
      (Ja1 : JacobianIdentity A1)
      (Ja2 : JacobianIdentity A2) :
      Set where
      constructor JacobianIdentityRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ja1) (0 Ja2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ja1 x1 x2)
            (+ Ja2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ja1 x1 x2)
            (* Ja2 y1 y2)
    data JacobianIdentityLang
      : Set where
      0L : JacobianIdentityLang
      +L :
        JacobianIdentityLang ->
        JacobianIdentityLang ->
        JacobianIdentityLang
      *L :
        JacobianIdentityLang ->
        JacobianIdentityLang ->
        JacobianIdentityLang
    data JacobianIdentityOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        JacobianIdentityOpenLang
      0OL : JacobianIdentityOpenLang
      +OL :
        JacobianIdentityOpenLang ->
        JacobianIdentityOpenLang ->
        JacobianIdentityOpenLang
      *OL :
        JacobianIdentityOpenLang ->
        JacobianIdentityOpenLang ->
        JacobianIdentityOpenLang
  
  module JoinSemilattice where
    record JoinSemilattice
      (A : Set) : Set where
      constructor JoinSemilatticeC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
    record JoinSemilatticeSig
      (AS : Set) : Set where
      constructor JoinSemilatticeSigSigC
      field
        +S : AS -> AS -> AS
    record JoinSemilatticeProd
      (AP : Set) : Set where
      constructor JoinSemilatticeProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record JoinSemilatticeHom
      (A1 : Set) (A2 : Set)
      (Jo1 : JoinSemilattice A1)
      (Jo2 : JoinSemilattice A2) :
      Set where
      constructor JoinSemilatticeHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Jo1 x1 x2) ==
            + Jo2 (hom x1) (hom x2)
    record JoinSemilatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Jo1 : JoinSemilattice A1)
      (Jo2 : JoinSemilattice A2) :
      Set where
      constructor JoinSemilatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Jo1 x1 x2)
            (+ Jo2 y1 y2)
    data JoinSemilatticeLang
      : Set where
      +L :
        JoinSemilatticeLang ->
        JoinSemilatticeLang ->
        JoinSemilatticeLang
    data JoinSemilatticeOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> JoinSemilatticeOpenLang
      +OL :
        JoinSemilatticeOpenLang ->
        JoinSemilatticeOpenLang ->
        JoinSemilatticeOpenLang
  
  module JoinSemilattice_RingoidSig where
    record JoinSemilattice_RingoidSig
      (A : Set) : Set where
      constructor JoinSemilattice_RingoidSigC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        * : A -> A -> A
    record JoinSemilattice_RingoidSigSig
      (AS : Set) : Set where
      constructor JoinSemilattice_RingoidSigSigSigC
      field
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
    record JoinSemilattice_RingoidSigProd
      (AP : Set) : Set where
      constructor JoinSemilattice_RingoidSigProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record JoinSemilattice_RingoidSigHom
      (A1 : Set) (A2 : Set)
      (Jo1 : JoinSemilattice_RingoidSig
         A1)
      (Jo2 : JoinSemilattice_RingoidSig
         A2) : Set where
      constructor JoinSemilattice_RingoidSigHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Jo1 x1 x2) ==
            + Jo2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Jo1 x1 x2) ==
            * Jo2 (hom x1) (hom x2)
    record JoinSemilattice_RingoidSigRelInterp
      (A1 : Set) (A2 : Set)
      (Jo1 : JoinSemilattice_RingoidSig
         A1)
      (Jo2 : JoinSemilattice_RingoidSig
         A2) : Set where
      constructor JoinSemilattice_RingoidSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Jo1 x1 x2)
            (+ Jo2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Jo1 x1 x2)
            (* Jo2 y1 y2)
    data JoinSemilattice_RingoidSigLang
      : Set where
      +L :
        JoinSemilattice_RingoidSigLang ->
        JoinSemilattice_RingoidSigLang ->
        JoinSemilattice_RingoidSigLang
      *L :
        JoinSemilattice_RingoidSigLang ->
        JoinSemilattice_RingoidSigLang ->
        JoinSemilattice_RingoidSigLang
    data JoinSemilattice_RingoidSigOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        JoinSemilattice_RingoidSigOpenLang
      +OL :
        JoinSemilattice_RingoidSigOpenLang ->
        JoinSemilattice_RingoidSigOpenLang ->
        JoinSemilattice_RingoidSigOpenLang
      *OL :
        JoinSemilattice_RingoidSigOpenLang ->
        JoinSemilattice_RingoidSigOpenLang ->
        JoinSemilattice_RingoidSigOpenLang
  
  module Kei where
    record Kei (A : Set) : Set where
      constructor KeiC
      field
        |> : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        idempotent_|> :
          (x : A) -> |> x x == x
        rightSelfInverse_|> :
          (x : A) (y : A) ->
          |> (|> x y) y == x
    record KeiSig
      (AS : Set) : Set where
      constructor KeiSigSigC
      field
        |>S : AS -> AS -> AS
    record KeiProd
      (AP : Set) : Set where
      constructor KeiProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
        rightSelfInverse_|>P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          |>P (|>P xP yP) yP == xP
    record KeiHom
      (A1 : Set) (A2 : Set)
      (Ke1 : Kei A1)
      (Ke2 : Kei A2) : Set where
      constructor KeiHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ke1 x1 x2) ==
            |> Ke2 (hom x1) (hom x2)
    record KeiRelInterp
      (A1 : Set) (A2 : Set)
      (Ke1 : Kei A1)
      (Ke2 : Kei A2) : Set where
      constructor KeiRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ke1 x1 x2)
            (|> Ke2 y1 y2)
    data KeiLang : Set where
      |>L :
        KeiLang -> KeiLang -> KeiLang
    data KeiOpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> KeiOpenLang
      |>OL :
        KeiOpenLang ->
        KeiOpenLang -> KeiOpenLang
  
  module Lattice where
    record Lattice
      (A : Set) : Set where
      constructor LatticeC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
    record LatticeSig
      (AS : Set) : Set where
      constructor LatticeSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record LatticeProd
      (AP : Set) : Set where
      constructor LatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
    record LatticeHom
      (A1 : Set) (A2 : Set)
      (La1 : Lattice A1)
      (La2 : Lattice A2) : Set where
      constructor LatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* La1 x1 x2) ==
            * La2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ La1 x1 x2) ==
            + La2 (hom x1) (hom x2)
    record LatticeRelInterp
      (A1 : Set) (A2 : Set)
      (La1 : Lattice A1)
      (La2 : Lattice A2) : Set where
      constructor LatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* La1 x1 x2)
            (* La2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ La1 x1 x2)
            (+ La2 y1 y2)
    data LatticeLang : Set where
      *L :
        LatticeLang ->
        LatticeLang -> LatticeLang
      +L :
        LatticeLang ->
        LatticeLang -> LatticeLang
    data LatticeOpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> LatticeOpenLang
      *OL :
        LatticeOpenLang ->
        LatticeOpenLang ->
        LatticeOpenLang
      +OL :
        LatticeOpenLang ->
        LatticeOpenLang ->
        LatticeOpenLang
  
  module Left0 where
    record Left0
      (A : Set) : Set where
      constructor Left0C
      field
        0 : A
        op : A -> A -> A
        leftZero_op_0 :
          (x : A) -> op 0 x == 0
    record Left0Sig
      (AS : Set) : Set where
      constructor Left0SigSigC
      field
        0S : AS
        opS : AS -> AS -> AS
    record Left0Prod
      (AP : Set) : Set where
      constructor Left0ProdC
      field
        0P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          opP 0P xP == 0P
    record Left0Hom
      (A1 : Set) (A2 : Set)
      (Le1 : Left0 A1)
      (Le2 : Left0 A2) : Set where
      constructor Left0HomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Le1) == 0 Le2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record Left0RelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : Left0 A1)
      (Le2 : Left0 A2) : Set where
      constructor Left0RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Le1) (0 Le2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data Left0Lang : Set where
      0L : Left0Lang
      opL :
        Left0Lang ->
        Left0Lang -> Left0Lang
    data Left0OpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> Left0OpenLang
      0OL : Left0OpenLang
      opOL :
        Left0OpenLang ->
        Left0OpenLang -> Left0OpenLang
  
  module LeftAbsorption where
    record LeftAbsorption
      (A : Set) : Set where
      constructor LeftAbsorptionC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
    record LeftAbsorptionSig
      (AS : Set) : Set where
      constructor LeftAbsorptionSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record LeftAbsorptionProd
      (AP : Set) : Set where
      constructor LeftAbsorptionProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
    record LeftAbsorptionHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftAbsorption A1)
      (Le2 : LeftAbsorption A2) :
      Set where
      constructor LeftAbsorptionHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Le1 x1 x2) ==
            * Le2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Le1 x1 x2) ==
            + Le2 (hom x1) (hom x2)
    record LeftAbsorptionRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftAbsorption A1)
      (Le2 : LeftAbsorption A2) :
      Set where
      constructor LeftAbsorptionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Le1 x1 x2)
            (* Le2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Le1 x1 x2)
            (+ Le2 y1 y2)
    data LeftAbsorptionLang
      : Set where
      *L :
        LeftAbsorptionLang ->
        LeftAbsorptionLang ->
        LeftAbsorptionLang
      +L :
        LeftAbsorptionLang ->
        LeftAbsorptionLang ->
        LeftAbsorptionLang
    data LeftAbsorptionOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> LeftAbsorptionOpenLang
      *OL :
        LeftAbsorptionOpenLang ->
        LeftAbsorptionOpenLang ->
        LeftAbsorptionOpenLang
      +OL :
        LeftAbsorptionOpenLang ->
        LeftAbsorptionOpenLang ->
        LeftAbsorptionOpenLang
  
  module LeftAbsorptionOp where
    record LeftAbsorptionOp
      (A : Set) : Set where
      constructor LeftAbsorptionOpC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
    record LeftAbsorptionOpSig
      (AS : Set) : Set where
      constructor LeftAbsorptionOpSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record LeftAbsorptionOpProd
      (AP : Set) : Set where
      constructor LeftAbsorptionOpProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
    record LeftAbsorptionOpHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftAbsorptionOp A1)
      (Le2 : LeftAbsorptionOp A2) :
      Set where
      constructor LeftAbsorptionOpHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Le1 x1 x2) ==
            * Le2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Le1 x1 x2) ==
            + Le2 (hom x1) (hom x2)
    record LeftAbsorptionOpRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftAbsorptionOp A1)
      (Le2 : LeftAbsorptionOp A2) :
      Set where
      constructor LeftAbsorptionOpRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Le1 x1 x2)
            (* Le2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Le1 x1 x2)
            (+ Le2 y1 y2)
    data LeftAbsorptionOpLang
      : Set where
      *L :
        LeftAbsorptionOpLang ->
        LeftAbsorptionOpLang ->
        LeftAbsorptionOpLang
      +L :
        LeftAbsorptionOpLang ->
        LeftAbsorptionOpLang ->
        LeftAbsorptionOpLang
    data LeftAbsorptionOpOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        LeftAbsorptionOpOpenLang
      *OL :
        LeftAbsorptionOpOpenLang ->
        LeftAbsorptionOpOpenLang ->
        LeftAbsorptionOpOpenLang
      +OL :
        LeftAbsorptionOpOpenLang ->
        LeftAbsorptionOpOpenLang ->
        LeftAbsorptionOpOpenLang
  
  module LeftBiMagma where
    record LeftBiMagma
      (A : Set) : Set where
      constructor LeftBiMagmaC
      field
        op : A -> A -> A
        linv : A -> A -> A
    record LeftBiMagmaSig
      (AS : Set) : Set where
      constructor LeftBiMagmaSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
    record LeftBiMagmaProd
      (AP : Set) : Set where
      constructor LeftBiMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record LeftBiMagmaHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftBiMagma A1)
      (Le2 : LeftBiMagma A2) :
      Set where
      constructor LeftBiMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Le1 x1 x2) ==
            linv Le2 (hom x1) (hom x2)
    record LeftBiMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftBiMagma A1)
      (Le2 : LeftBiMagma A2) :
      Set where
      constructor LeftBiMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Le1 x1 x2)
            (linv Le2 y1 y2)
    data LeftBiMagmaLang : Set where
      opL :
        LeftBiMagmaLang ->
        LeftBiMagmaLang ->
        LeftBiMagmaLang
      linvL :
        LeftBiMagmaLang ->
        LeftBiMagmaLang ->
        LeftBiMagmaLang
    data LeftBiMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> LeftBiMagmaOpenLang
      opOL :
        LeftBiMagmaOpenLang ->
        LeftBiMagmaOpenLang ->
        LeftBiMagmaOpenLang
      linvOL :
        LeftBiMagmaOpenLang ->
        LeftBiMagmaOpenLang ->
        LeftBiMagmaOpenLang
  
  module LeftBinaryInverse where
    record LeftBinaryInverse
      (A : Set) : Set where
      constructor LeftBinaryInverseC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftInverse :
          (x : A) (y : A) ->
          <| (|> x y) x == y
    record LeftBinaryInverseSig
      (AS : Set) : Set where
      constructor LeftBinaryInverseSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record LeftBinaryInverseProd
      (AP : Set) : Set where
      constructor LeftBinaryInverseProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          <|P (|>P xP yP) xP == yP
    record LeftBinaryInverseHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftBinaryInverse A1)
      (Le2 : LeftBinaryInverse A2) :
      Set where
      constructor LeftBinaryInverseHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Le1 x1 x2) ==
            <| Le2 (hom x1) (hom x2)
    record LeftBinaryInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftBinaryInverse A1)
      (Le2 : LeftBinaryInverse A2) :
      Set where
      constructor LeftBinaryInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Le1 x1 x2)
            (<| Le2 y1 y2)
    data LeftBinaryInverseLang
      : Set where
      |>L :
        LeftBinaryInverseLang ->
        LeftBinaryInverseLang ->
        LeftBinaryInverseLang
      <|L :
        LeftBinaryInverseLang ->
        LeftBinaryInverseLang ->
        LeftBinaryInverseLang
    data LeftBinaryInverseOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        LeftBinaryInverseOpenLang
      |>OL :
        LeftBinaryInverseOpenLang ->
        LeftBinaryInverseOpenLang ->
        LeftBinaryInverseOpenLang
      <|OL :
        LeftBinaryInverseOpenLang ->
        LeftBinaryInverseOpenLang ->
        LeftBinaryInverseOpenLang
  
  module LeftCancellative where
    record LeftCancellative
      (A : Set) : Set where
      constructor LeftCancellativeC
      field
        op : A -> A -> A
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
    record LeftCancellativeSig
      (AS : Set) : Set where
      constructor LeftCancellativeSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
    record LeftCancellativeProd
      (AP : Set) : Set where
      constructor LeftCancellativeProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
    record LeftCancellativeHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellative A1)
      (Le2 : LeftCancellative A2) :
      Set where
      constructor LeftCancellativeHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Le1 x1 x2) ==
            linv Le2 (hom x1) (hom x2)
    record LeftCancellativeRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellative A1)
      (Le2 : LeftCancellative A2) :
      Set where
      constructor LeftCancellativeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Le1 x1 x2)
            (linv Le2 y1 y2)
    data LeftCancellativeLang
      : Set where
      opL :
        LeftCancellativeLang ->
        LeftCancellativeLang ->
        LeftCancellativeLang
      linvL :
        LeftCancellativeLang ->
        LeftCancellativeLang ->
        LeftCancellativeLang
    data LeftCancellativeOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        LeftCancellativeOpenLang
      opOL :
        LeftCancellativeOpenLang ->
        LeftCancellativeOpenLang ->
        LeftCancellativeOpenLang
      linvOL :
        LeftCancellativeOpenLang ->
        LeftCancellativeOpenLang ->
        LeftCancellativeOpenLang
  
  module LeftCancellativeMagma where
    record LeftCancellativeMagma
      (A : Set) : Set where
      constructor LeftCancellativeMagmaC
      field
        op : A -> A -> A
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
    record LeftCancellativeMagmaSig
      (AS : Set) : Set where
      constructor LeftCancellativeMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record LeftCancellativeMagmaProd
      (AP : Set) : Set where
      constructor LeftCancellativeMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
    record LeftCancellativeMagmaHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellativeMagma A1)
      (Le2 : LeftCancellativeMagma
         A2) : Set where
      constructor LeftCancellativeMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record LeftCancellativeMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellativeMagma A1)
      (Le2 : LeftCancellativeMagma
         A2) : Set where
      constructor LeftCancellativeMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data LeftCancellativeMagmaLang
      : Set where
      opL :
        LeftCancellativeMagmaLang ->
        LeftCancellativeMagmaLang ->
        LeftCancellativeMagmaLang
    data LeftCancellativeMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        LeftCancellativeMagmaOpenLang
      opOL :
        LeftCancellativeMagmaOpenLang ->
        LeftCancellativeMagmaOpenLang ->
        LeftCancellativeMagmaOpenLang
  
  module LeftCancellativeOp where
    record LeftCancellativeOp
      (A : Set) : Set where
      constructor LeftCancellativeOpC
      field
        op : A -> A -> A
        linv : A -> A -> A
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
    record LeftCancellativeOpSig
      (AS : Set) : Set where
      constructor LeftCancellativeOpSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
    record LeftCancellativeOpProd
      (AP : Set) : Set where
      constructor LeftCancellativeOpProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
    record LeftCancellativeOpHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellativeOp A1)
      (Le2 : LeftCancellativeOp A2) :
      Set where
      constructor LeftCancellativeOpHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Le1 x1 x2) ==
            linv Le2 (hom x1) (hom x2)
    record LeftCancellativeOpRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellativeOp A1)
      (Le2 : LeftCancellativeOp A2) :
      Set where
      constructor LeftCancellativeOpRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Le1 x1 x2)
            (linv Le2 y1 y2)
    data LeftCancellativeOpLang
      : Set where
      opL :
        LeftCancellativeOpLang ->
        LeftCancellativeOpLang ->
        LeftCancellativeOpLang
      linvL :
        LeftCancellativeOpLang ->
        LeftCancellativeOpLang ->
        LeftCancellativeOpLang
    data LeftCancellativeOpOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        LeftCancellativeOpOpenLang
      opOL :
        LeftCancellativeOpOpenLang ->
        LeftCancellativeOpOpenLang ->
        LeftCancellativeOpOpenLang
      linvOL :
        LeftCancellativeOpOpenLang ->
        LeftCancellativeOpOpenLang ->
        LeftCancellativeOpOpenLang
  
  module LeftCancellativeSemigroup where
    record LeftCancellativeSemigroup
      (A : Set) : Set where
      constructor LeftCancellativeSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
    record LeftCancellativeSemigroupSig
      (AS : Set) : Set where
      constructor LeftCancellativeSemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record LeftCancellativeSemigroupProd
      (AP : Set) : Set where
      constructor LeftCancellativeSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
    record LeftCancellativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellativeSemigroup
         A1)
      (Le2 : LeftCancellativeSemigroup
         A2) : Set where
      constructor LeftCancellativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record LeftCancellativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellativeSemigroup
         A1)
      (Le2 : LeftCancellativeSemigroup
         A2) : Set where
      constructor LeftCancellativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data LeftCancellativeSemigroupLang
      : Set where
      opL :
        LeftCancellativeSemigroupLang ->
        LeftCancellativeSemigroupLang ->
        LeftCancellativeSemigroupLang
    data LeftCancellativeSemigroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        LeftCancellativeSemigroupOpenLang
      opOL :
        LeftCancellativeSemigroupOpenLang ->
        LeftCancellativeSemigroupOpenLang ->
        LeftCancellativeSemigroupOpenLang
  
  module LeftDistributiveMagma where
    record LeftDistributiveMagma
      (A : Set) : Set where
      constructor LeftDistributiveMagmaC
      field
        op : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          op x (op y z) ==
            op (op x y) (op x z)
    record LeftDistributiveMagmaSig
      (AS : Set) : Set where
      constructor LeftDistributiveMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record LeftDistributiveMagmaProd
      (AP : Set) : Set where
      constructor LeftDistributiveMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP (opP yP zP) ==
            opP (opP xP yP) (opP xP zP)
    record LeftDistributiveMagmaHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftDistributiveMagma A1)
      (Le2 : LeftDistributiveMagma
         A2) : Set where
      constructor LeftDistributiveMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record LeftDistributiveMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftDistributiveMagma A1)
      (Le2 : LeftDistributiveMagma
         A2) : Set where
      constructor LeftDistributiveMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data LeftDistributiveMagmaLang
      : Set where
      opL :
        LeftDistributiveMagmaLang ->
        LeftDistributiveMagmaLang ->
        LeftDistributiveMagmaLang
    data LeftDistributiveMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        LeftDistributiveMagmaOpenLang
      opOL :
        LeftDistributiveMagmaOpenLang ->
        LeftDistributiveMagmaOpenLang ->
        LeftDistributiveMagmaOpenLang
  
  module LeftIdempotence where
    record LeftIdempotence
      (A : Set) : Set where
      constructor LeftIdempotenceC
      field
        |> : A -> A -> A
        idempotent_|> :
          (x : A) -> |> x x == x
    record LeftIdempotenceSig
      (AS : Set) : Set where
      constructor LeftIdempotenceSigSigC
      field
        |>S : AS -> AS -> AS
    record LeftIdempotenceProd
      (AP : Set) : Set where
      constructor LeftIdempotenceProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
    record LeftIdempotenceHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftIdempotence A1)
      (Le2 : LeftIdempotence A2) :
      Set where
      constructor LeftIdempotenceHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
    record LeftIdempotenceRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftIdempotence A1)
      (Le2 : LeftIdempotence A2) :
      Set where
      constructor LeftIdempotenceRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
    data LeftIdempotenceLang
      : Set where
      |>L :
        LeftIdempotenceLang ->
        LeftIdempotenceLang ->
        LeftIdempotenceLang
    data LeftIdempotenceOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> LeftIdempotenceOpenLang
      |>OL :
        LeftIdempotenceOpenLang ->
        LeftIdempotenceOpenLang ->
        LeftIdempotenceOpenLang
  
  module LeftInverse where
    record LeftInverse
      (A : Set) : Set where
      constructor LeftInverseC
      field
        inv : A -> A
        e : A
        op : A -> A -> A
        leftInverse_inv_op_e :
          (x : A) -> op x (inv x) == e
    record LeftInverseSig
      (AS : Set) : Set where
      constructor LeftInverseSigSigC
      field
        invS : AS -> AS
        eS : AS
        opS : AS -> AS -> AS
    record LeftInverseProd
      (AP : Set) : Set where
      constructor LeftInverseProdC
      field
        invP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP xP (invP xP) == eP
    record LeftInverseHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftInverse A1)
      (Le2 : LeftInverse A2) :
      Set where
      constructor LeftInverseHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv Le1 x1) ==
            inv Le2 (hom x1)
        pres-e : hom (e Le1) == e Le2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record LeftInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftInverse A1)
      (Le2 : LeftInverse A2) :
      Set where
      constructor LeftInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Le1 x1) (inv Le2 y1)
        interp-e :
          interp (e Le1) (e Le2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data LeftInverseLang : Set where
      invL :
        LeftInverseLang ->
        LeftInverseLang
      eL : LeftInverseLang
      opL :
        LeftInverseLang ->
        LeftInverseLang ->
        LeftInverseLang
    data LeftInverseOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> LeftInverseOpenLang
      invOL :
        LeftInverseOpenLang ->
        LeftInverseOpenLang
      eOL : LeftInverseOpenLang
      opOL :
        LeftInverseOpenLang ->
        LeftInverseOpenLang ->
        LeftInverseOpenLang
  
  module LeftInverseMagma where
    record LeftInverseMagma
      (A : Set) : Set where
      constructor LeftInverseMagmaC
      field
        linv : A -> A -> A
    record LeftInverseMagmaSig
      (AS : Set) : Set where
      constructor LeftInverseMagmaSigSigC
      field
        linvS : AS -> AS -> AS
    record LeftInverseMagmaProd
      (AP : Set) : Set where
      constructor LeftInverseMagmaProdC
      field
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record LeftInverseMagmaHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftInverseMagma A1)
      (Le2 : LeftInverseMagma A2) :
      Set where
      constructor LeftInverseMagmaHomC
      field
        hom : A1 -> A2
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Le1 x1 x2) ==
            linv Le2 (hom x1) (hom x2)
    record LeftInverseMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftInverseMagma A1)
      (Le2 : LeftInverseMagma A2) :
      Set where
      constructor LeftInverseMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Le1 x1 x2)
            (linv Le2 y1 y2)
    data LeftInverseMagmaLang
      : Set where
      linvL :
        LeftInverseMagmaLang ->
        LeftInverseMagmaLang ->
        LeftInverseMagmaLang
    data LeftInverseMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        LeftInverseMagmaOpenLang
      linvOL :
        LeftInverseMagmaOpenLang ->
        LeftInverseMagmaOpenLang ->
        LeftInverseMagmaOpenLang
  
  module LeftLoop where
    record LeftLoop
      (A : Set) : Set where
      constructor LeftLoopC
      field
        op : A -> A -> A
        e : A
        runit_e : (x : A) -> op x e == x
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
    record LeftLoopSig
      (AS : Set) : Set where
      constructor LeftLoopSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
        linvS : AS -> AS -> AS
    record LeftLoopProd
      (AP : Set) : Set where
      constructor LeftLoopProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
    record LeftLoopHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftLoop A1)
      (Le2 : LeftLoop A2) : Set where
      constructor LeftLoopHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
        pres-e : hom (e Le1) == e Le2
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Le1 x1 x2) ==
            linv Le2 (hom x1) (hom x2)
    record LeftLoopRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftLoop A1)
      (Le2 : LeftLoop A2) : Set where
      constructor LeftLoopRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
        interp-e :
          interp (e Le1) (e Le2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Le1 x1 x2)
            (linv Le2 y1 y2)
    data LeftLoopLang : Set where
      opL :
        LeftLoopLang ->
        LeftLoopLang -> LeftLoopLang
      eL : LeftLoopLang
      linvL :
        LeftLoopLang ->
        LeftLoopLang -> LeftLoopLang
    data LeftLoopOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> LeftLoopOpenLang
      opOL :
        LeftLoopOpenLang ->
        LeftLoopOpenLang ->
        LeftLoopOpenLang
      eOL : LeftLoopOpenLang
      linvOL :
        LeftLoopOpenLang ->
        LeftLoopOpenLang ->
        LeftLoopOpenLang
  
  module LeftMonoid where
    record LeftMonoid
      (A : Set) : Set where
      constructor LeftMonoidC
      field
        op : A -> A -> A
        e : A
        lunit_e : (x : A) -> op e x == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record LeftMonoidSig
      (AS : Set) : Set where
      constructor LeftMonoidSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record LeftMonoidProd
      (AP : Set) : Set where
      constructor LeftMonoidProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record LeftMonoidHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftMonoid A1)
      (Le2 : LeftMonoid A2) :
      Set where
      constructor LeftMonoidHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
        pres-e : hom (e Le1) == e Le2
    record LeftMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftMonoid A1)
      (Le2 : LeftMonoid A2) :
      Set where
      constructor LeftMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
        interp-e :
          interp (e Le1) (e Le2)
    data LeftMonoidLang : Set where
      opL :
        LeftMonoidLang ->
        LeftMonoidLang -> LeftMonoidLang
      eL : LeftMonoidLang
    data LeftMonoidOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> LeftMonoidOpenLang
      opOL :
        LeftMonoidOpenLang ->
        LeftMonoidOpenLang ->
        LeftMonoidOpenLang
      eOL : LeftMonoidOpenLang
  
  module LeftPreSemiring where
    record LeftPreSemiring
      (A : Set) : Set where
      constructor LeftPreSemiringC
      field
        * : A -> A -> A
        + : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record LeftPreSemiringSig
      (AS : Set) : Set where
      constructor LeftPreSemiringSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record LeftPreSemiringProd
      (AP : Set) : Set where
      constructor LeftPreSemiringProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record LeftPreSemiringHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftPreSemiring A1)
      (Le2 : LeftPreSemiring A2) :
      Set where
      constructor LeftPreSemiringHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Le1 x1 x2) ==
            * Le2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Le1 x1 x2) ==
            + Le2 (hom x1) (hom x2)
    record LeftPreSemiringRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftPreSemiring A1)
      (Le2 : LeftPreSemiring A2) :
      Set where
      constructor LeftPreSemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Le1 x1 x2)
            (* Le2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Le1 x1 x2)
            (+ Le2 y1 y2)
    data LeftPreSemiringLang
      : Set where
      *L :
        LeftPreSemiringLang ->
        LeftPreSemiringLang ->
        LeftPreSemiringLang
      +L :
        LeftPreSemiringLang ->
        LeftPreSemiringLang ->
        LeftPreSemiringLang
    data LeftPreSemiringOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> LeftPreSemiringOpenLang
      *OL :
        LeftPreSemiringOpenLang ->
        LeftPreSemiringOpenLang ->
        LeftPreSemiringOpenLang
      +OL :
        LeftPreSemiringOpenLang ->
        LeftPreSemiringOpenLang ->
        LeftPreSemiringOpenLang
  
  module LeftQuasiGroup where
    record LeftQuasiGroup
      (A : Set) : Set where
      constructor LeftQuasiGroupC
      field
        op : A -> A -> A
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
    record LeftQuasiGroupSig
      (AS : Set) : Set where
      constructor LeftQuasiGroupSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
    record LeftQuasiGroupProd
      (AP : Set) : Set where
      constructor LeftQuasiGroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
    record LeftQuasiGroupHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftQuasiGroup A1)
      (Le2 : LeftQuasiGroup A2) :
      Set where
      constructor LeftQuasiGroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Le1 x1 x2) ==
            linv Le2 (hom x1) (hom x2)
    record LeftQuasiGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftQuasiGroup A1)
      (Le2 : LeftQuasiGroup A2) :
      Set where
      constructor LeftQuasiGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Le1 x1 x2)
            (linv Le2 y1 y2)
    data LeftQuasiGroupLang
      : Set where
      opL :
        LeftQuasiGroupLang ->
        LeftQuasiGroupLang ->
        LeftQuasiGroupLang
      linvL :
        LeftQuasiGroupLang ->
        LeftQuasiGroupLang ->
        LeftQuasiGroupLang
    data LeftQuasiGroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> LeftQuasiGroupOpenLang
      opOL :
        LeftQuasiGroupOpenLang ->
        LeftQuasiGroupOpenLang ->
        LeftQuasiGroupOpenLang
      linvOL :
        LeftQuasiGroupOpenLang ->
        LeftQuasiGroupOpenLang ->
        LeftQuasiGroupOpenLang
  
  module LeftRack where
    record LeftRack
      (A : Set) : Set where
      constructor LeftRackC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
    record LeftRackSig
      (AS : Set) : Set where
      constructor LeftRackSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record LeftRackProd
      (AP : Set) : Set where
      constructor LeftRackProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
    record LeftRackHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftRack A1)
      (Le2 : LeftRack A2) : Set where
      constructor LeftRackHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Le1 x1 x2) ==
            <| Le2 (hom x1) (hom x2)
    record LeftRackRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftRack A1)
      (Le2 : LeftRack A2) : Set where
      constructor LeftRackRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Le1 x1 x2)
            (<| Le2 y1 y2)
    data LeftRackLang : Set where
      |>L :
        LeftRackLang ->
        LeftRackLang -> LeftRackLang
      <|L :
        LeftRackLang ->
        LeftRackLang -> LeftRackLang
    data LeftRackOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> LeftRackOpenLang
      |>OL :
        LeftRackOpenLang ->
        LeftRackOpenLang ->
        LeftRackOpenLang
      <|OL :
        LeftRackOpenLang ->
        LeftRackOpenLang ->
        LeftRackOpenLang
  
  module LeftRingoid where
    record LeftRingoid
      (A : Set) : Set where
      constructor LeftRingoidC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
    record LeftRingoidSig
      (AS : Set) : Set where
      constructor LeftRingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record LeftRingoidProd
      (AP : Set) : Set where
      constructor LeftRingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
    record LeftRingoidHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftRingoid A1)
      (Le2 : LeftRingoid A2) :
      Set where
      constructor LeftRingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Le1 x1 x2) ==
            * Le2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Le1 x1 x2) ==
            + Le2 (hom x1) (hom x2)
    record LeftRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftRingoid A1)
      (Le2 : LeftRingoid A2) :
      Set where
      constructor LeftRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Le1 x1 x2)
            (* Le2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Le1 x1 x2)
            (+ Le2 y1 y2)
    data LeftRingoidLang : Set where
      *L :
        LeftRingoidLang ->
        LeftRingoidLang ->
        LeftRingoidLang
      +L :
        LeftRingoidLang ->
        LeftRingoidLang ->
        LeftRingoidLang
    data LeftRingoidOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> LeftRingoidOpenLang
      *OL :
        LeftRingoidOpenLang ->
        LeftRingoidOpenLang ->
        LeftRingoidOpenLang
      +OL :
        LeftRingoidOpenLang ->
        LeftRingoidOpenLang ->
        LeftRingoidOpenLang
  
  module LeftShelf where
    record LeftShelf
      (A : Set) : Set where
      constructor LeftShelfC
      field
        |> : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
    record LeftShelfSig
      (AS : Set) : Set where
      constructor LeftShelfSigSigC
      field
        |>S : AS -> AS -> AS
    record LeftShelfProd
      (AP : Set) : Set where
      constructor LeftShelfProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
    record LeftShelfHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftShelf A1)
      (Le2 : LeftShelf A2) : Set where
      constructor LeftShelfHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
    record LeftShelfRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftShelf A1)
      (Le2 : LeftShelf A2) : Set where
      constructor LeftShelfRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
    data LeftShelfLang : Set where
      |>L :
        LeftShelfLang ->
        LeftShelfLang -> LeftShelfLang
    data LeftShelfOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> LeftShelfOpenLang
      |>OL :
        LeftShelfOpenLang ->
        LeftShelfOpenLang ->
        LeftShelfOpenLang
  
  module LeftShelfSig where
    record LeftShelfSig
      (A : Set) : Set where
      constructor LeftShelfSigC
      field
        |> : A -> A -> A
    record LeftShelfSigSig
      (AS : Set) : Set where
      constructor LeftShelfSigSigSigC
      field
        |>S : AS -> AS -> AS
    record LeftShelfSigProd
      (AP : Set) : Set where
      constructor LeftShelfSigProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record LeftShelfSigHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftShelfSig A1)
      (Le2 : LeftShelfSig A2) :
      Set where
      constructor LeftShelfSigHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
    record LeftShelfSigRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftShelfSig A1)
      (Le2 : LeftShelfSig A2) :
      Set where
      constructor LeftShelfSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
    data LeftShelfSigLang
      : Set where
      |>L :
        LeftShelfSigLang ->
        LeftShelfSigLang ->
        LeftShelfSigLang
    data LeftShelfSigOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> LeftShelfSigOpenLang
      |>OL :
        LeftShelfSigOpenLang ->
        LeftShelfSigOpenLang ->
        LeftShelfSigOpenLang
  
  module LeftSpindle where
    record LeftSpindle
      (A : Set) : Set where
      constructor LeftSpindleC
      field
        |> : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        idempotent_|> :
          (x : A) -> |> x x == x
    record LeftSpindleSig
      (AS : Set) : Set where
      constructor LeftSpindleSigSigC
      field
        |>S : AS -> AS -> AS
    record LeftSpindleProd
      (AP : Set) : Set where
      constructor LeftSpindleProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
    record LeftSpindleHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftSpindle A1)
      (Le2 : LeftSpindle A2) :
      Set where
      constructor LeftSpindleHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
    record LeftSpindleRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftSpindle A1)
      (Le2 : LeftSpindle A2) :
      Set where
      constructor LeftSpindleRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
    data LeftSpindleLang : Set where
      |>L :
        LeftSpindleLang ->
        LeftSpindleLang ->
        LeftSpindleLang
    data LeftSpindleOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> LeftSpindleOpenLang
      |>OL :
        LeftSpindleOpenLang ->
        LeftSpindleOpenLang ->
        LeftSpindleOpenLang
  
  module LeftSpindle_Shelf where
    record LeftSpindle_Shelf
      (A : Set) : Set where
      constructor LeftSpindle_ShelfC
      field
        |> : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        idempotent_|> :
          (x : A) -> |> x x == x
        <| : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
    record LeftSpindle_ShelfSig
      (AS : Set) : Set where
      constructor LeftSpindle_ShelfSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record LeftSpindle_ShelfProd
      (AP : Set) : Set where
      constructor LeftSpindle_ShelfProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
    record LeftSpindle_ShelfHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftSpindle_Shelf A1)
      (Le2 : LeftSpindle_Shelf A2) :
      Set where
      constructor LeftSpindle_ShelfHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Le1 x1 x2) ==
            <| Le2 (hom x1) (hom x2)
    record LeftSpindle_ShelfRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftSpindle_Shelf A1)
      (Le2 : LeftSpindle_Shelf A2) :
      Set where
      constructor LeftSpindle_ShelfRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Le1 x1 x2)
            (<| Le2 y1 y2)
    data LeftSpindle_ShelfLang
      : Set where
      |>L :
        LeftSpindle_ShelfLang ->
        LeftSpindle_ShelfLang ->
        LeftSpindle_ShelfLang
      <|L :
        LeftSpindle_ShelfLang ->
        LeftSpindle_ShelfLang ->
        LeftSpindle_ShelfLang
    data LeftSpindle_ShelfOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        LeftSpindle_ShelfOpenLang
      |>OL :
        LeftSpindle_ShelfOpenLang ->
        LeftSpindle_ShelfOpenLang ->
        LeftSpindle_ShelfOpenLang
      <|OL :
        LeftSpindle_ShelfOpenLang ->
        LeftSpindle_ShelfOpenLang ->
        LeftSpindle_ShelfOpenLang
  
  module LeftSpindle_ShelfSig where
    record LeftSpindle_ShelfSig
      (A : Set) : Set where
      constructor LeftSpindle_ShelfSigC
      field
        |> : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        idempotent_|> :
          (x : A) -> |> x x == x
        <| : A -> A -> A
    record LeftSpindle_ShelfSigSig
      (AS : Set) : Set where
      constructor LeftSpindle_ShelfSigSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record LeftSpindle_ShelfSigProd
      (AP : Set) : Set where
      constructor LeftSpindle_ShelfSigProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
    record LeftSpindle_ShelfSigHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftSpindle_ShelfSig A1)
      (Le2 : LeftSpindle_ShelfSig
         A2) : Set where
      constructor LeftSpindle_ShelfSigHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Le1 x1 x2) ==
            <| Le2 (hom x1) (hom x2)
    record LeftSpindle_ShelfSigRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftSpindle_ShelfSig A1)
      (Le2 : LeftSpindle_ShelfSig
         A2) : Set where
      constructor LeftSpindle_ShelfSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Le1 x1 x2)
            (<| Le2 y1 y2)
    data LeftSpindle_ShelfSigLang
      : Set where
      |>L :
        LeftSpindle_ShelfSigLang ->
        LeftSpindle_ShelfSigLang ->
        LeftSpindle_ShelfSigLang
      <|L :
        LeftSpindle_ShelfSigLang ->
        LeftSpindle_ShelfSigLang ->
        LeftSpindle_ShelfSigLang
    data LeftSpindle_ShelfSigOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        LeftSpindle_ShelfSigOpenLang
      |>OL :
        LeftSpindle_ShelfSigOpenLang ->
        LeftSpindle_ShelfSigOpenLang ->
        LeftSpindle_ShelfSigOpenLang
      <|OL :
        LeftSpindle_ShelfSigOpenLang ->
        LeftSpindle_ShelfSigOpenLang ->
        LeftSpindle_ShelfSigOpenLang
  
  module LeftUnital where
    record LeftUnital
      (A : Set) : Set where
      constructor LeftUnitalC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
    record LeftUnitalSig
      (AS : Set) : Set where
      constructor LeftUnitalSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record LeftUnitalProd
      (AP : Set) : Set where
      constructor LeftUnitalProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
    record LeftUnitalHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftUnital A1)
      (Le2 : LeftUnital A2) :
      Set where
      constructor LeftUnitalHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Le1) == e Le2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record LeftUnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftUnital A1)
      (Le2 : LeftUnital A2) :
      Set where
      constructor LeftUnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Le1) (e Le2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data LeftUnitalLang : Set where
      eL : LeftUnitalLang
      opL :
        LeftUnitalLang ->
        LeftUnitalLang -> LeftUnitalLang
    data LeftUnitalOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> LeftUnitalOpenLang
      eOL : LeftUnitalOpenLang
      opOL :
        LeftUnitalOpenLang ->
        LeftUnitalOpenLang ->
        LeftUnitalOpenLang
  
  module LeftZero where
    record LeftZero
      (A : Set) : Set where
      constructor LeftZeroC
      field
        e : A
        op : A -> A -> A
        leftZero_op_e :
          (x : A) -> op e x == e
    record LeftZeroSig
      (AS : Set) : Set where
      constructor LeftZeroSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record LeftZeroProd
      (AP : Set) : Set where
      constructor LeftZeroProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftZero_op_eP :
          (xP : Prod AP AP) ->
          opP eP xP == eP
    record LeftZeroHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftZero A1)
      (Le2 : LeftZero A2) : Set where
      constructor LeftZeroHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Le1) == e Le2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record LeftZeroRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftZero A1)
      (Le2 : LeftZero A2) : Set where
      constructor LeftZeroRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Le1) (e Le2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data LeftZeroLang : Set where
      eL : LeftZeroLang
      opL :
        LeftZeroLang ->
        LeftZeroLang -> LeftZeroLang
    data LeftZeroOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> LeftZeroOpenLang
      eOL : LeftZeroOpenLang
      opOL :
        LeftZeroOpenLang ->
        LeftZeroOpenLang ->
        LeftZeroOpenLang
  
  module LieRing where
    record LieRing
      (A : Set) : Set where
      constructor LieRingC
      field
        0 : A
        + : A -> A -> A
        * : A -> A -> A
        jacobian_*_+ :
          (x : A) (y : A) (z : A) ->
          +
            (+ (* x (* y z)) (* y (* z x)))
            (* z (* x y)) == 0
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
        antiCommutative :
          (x : A) (y : A) ->
          * x y == neg (* y x)
    record LieRingSig
      (AS : Set) : Set where
      constructor LieRingSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
        negS : AS -> AS
        1S : AS
    record LieRingProd
      (AP : Set) : Set where
      constructor LieRingProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        jacobian_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P
            (+P (*P xP (*P yP zP))
               (*P yP (*P zP xP)))
            (*P zP (*P xP yP)) == 0P
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
        antiCommutativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == negP (*P yP xP)
    record LieRingHom
      (A1 : Set) (A2 : Set)
      (Li1 : LieRing A1)
      (Li2 : LieRing A2) : Set where
      constructor LieRingHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Li1) == 0 Li2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Li1 x1 x2) ==
            + Li2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Li1 x1 x2) ==
            * Li2 (hom x1) (hom x2)
        pres-neg :
          (x1 : A1) ->
          hom (neg Li1 x1) ==
            neg Li2 (hom x1)
        pres-1 : hom (1 Li1) == 1 Li2
    record LieRingRelInterp
      (A1 : Set) (A2 : Set)
      (Li1 : LieRing A1)
      (Li2 : LieRing A2) : Set where
      constructor LieRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Li1) (0 Li2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Li1 x1 x2)
            (+ Li2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Li1 x1 x2)
            (* Li2 y1 y2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Li1 x1) (neg Li2 y1)
        interp-1 :
          interp (1 Li1) (1 Li2)
    data LieRingLang : Set where
      0L : LieRingLang
      +L :
        LieRingLang ->
        LieRingLang -> LieRingLang
      *L :
        LieRingLang ->
        LieRingLang -> LieRingLang
      negL :
        LieRingLang -> LieRingLang
      1L : LieRingLang
    data LieRingOpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> LieRingOpenLang
      0OL : LieRingOpenLang
      +OL :
        LieRingOpenLang ->
        LieRingOpenLang ->
        LieRingOpenLang
      *OL :
        LieRingOpenLang ->
        LieRingOpenLang ->
        LieRingOpenLang
      negOL :
        LieRingOpenLang ->
        LieRingOpenLang
      1OL : LieRingOpenLang
  
  module Loop where
    record Loop
      (A : Set) : Set where
      constructor LoopC
      field
        op : A -> A -> A
        e : A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
    record LoopSig
      (AS : Set) : Set where
      constructor LoopSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
        linvS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record LoopProd
      (AP : Set) : Set where
      constructor LoopProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
    record LoopHom
      (A1 : Set) (A2 : Set)
      (Lo1 : Loop A1)
      (Lo2 : Loop A2) : Set where
      constructor LoopHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Lo1 x1 x2) ==
            op Lo2 (hom x1) (hom x2)
        pres-e : hom (e Lo1) == e Lo2
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Lo1 x1 x2) ==
            linv Lo2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Lo1 x1 x2) ==
            rinv Lo2 (hom x1) (hom x2)
    record LoopRelInterp
      (A1 : Set) (A2 : Set)
      (Lo1 : Loop A1)
      (Lo2 : Loop A2) : Set where
      constructor LoopRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Lo1 x1 x2)
            (op Lo2 y1 y2)
        interp-e :
          interp (e Lo1) (e Lo2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Lo1 x1 x2)
            (linv Lo2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Lo1 x1 x2)
            (rinv Lo2 y1 y2)
    data LoopLang : Set where
      opL :
        LoopLang -> LoopLang -> LoopLang
      eL : LoopLang
      linvL :
        LoopLang -> LoopLang -> LoopLang
      rinvL :
        LoopLang -> LoopLang -> LoopLang
    data LoopOpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> LoopOpenLang
      opOL :
        LoopOpenLang ->
        LoopOpenLang -> LoopOpenLang
      eOL : LoopOpenLang
      linvOL :
        LoopOpenLang ->
        LoopOpenLang -> LoopOpenLang
      rinvOL :
        LoopOpenLang ->
        LoopOpenLang -> LoopOpenLang
  
  module Magma where
    record Magma
      (A : Set) : Set where
      constructor MagmaC
      field
        op : A -> A -> A
    record MagmaSig
      (AS : Set) : Set where
      constructor MagmaSigSigC
      field
        opS : AS -> AS -> AS
    record MagmaProd
      (AP : Set) : Set where
      constructor MagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record MagmaHom
      (A1 : Set) (A2 : Set)
      (Ma1 : Magma A1)
      (Ma2 : Magma A2) : Set where
      constructor MagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ma1 x1 x2) ==
            op Ma2 (hom x1) (hom x2)
    record MagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ma1 : Magma A1)
      (Ma2 : Magma A2) : Set where
      constructor MagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ma1 x1 x2)
            (op Ma2 y1 y2)
    data MagmaLang : Set where
      opL :
        MagmaLang ->
        MagmaLang -> MagmaLang
    data MagmaOpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> MagmaOpenLang
      opOL :
        MagmaOpenLang ->
        MagmaOpenLang -> MagmaOpenLang
  
  module MedialMagma where
    record MedialMagma
      (A : Set) : Set where
      constructor MedialMagmaC
      field
        op : A -> A -> A
        mediates :
          (w : A) (x : A) (y : A)
          (z : A) ->
          op (op x y) (op z w) ==
            op (op x z) (op y w)
    record MedialMagmaSig
      (AS : Set) : Set where
      constructor MedialMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record MedialMagmaProd
      (AP : Set) : Set where
      constructor MedialMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        mediatesP :
          (wP : Prod AP AP)
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) (opP zP wP) ==
            opP (opP xP zP) (opP yP wP)
    record MedialMagmaHom
      (A1 : Set) (A2 : Set)
      (Me1 : MedialMagma A1)
      (Me2 : MedialMagma A2) :
      Set where
      constructor MedialMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Me1 x1 x2) ==
            op Me2 (hom x1) (hom x2)
    record MedialMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Me1 : MedialMagma A1)
      (Me2 : MedialMagma A2) :
      Set where
      constructor MedialMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Me1 x1 x2)
            (op Me2 y1 y2)
    data MedialMagmaLang : Set where
      opL :
        MedialMagmaLang ->
        MedialMagmaLang ->
        MedialMagmaLang
    data MedialMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> MedialMagmaOpenLang
      opOL :
        MedialMagmaOpenLang ->
        MedialMagmaOpenLang ->
        MedialMagmaOpenLang
  
  module MedialQuasiGroup where
    record MedialQuasiGroup
      (A : Set) : Set where
      constructor MedialQuasiGroupC
      field
        op : A -> A -> A
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
        mediates :
          (w : A) (x : A) (y : A)
          (z : A) ->
          op (op x y) (op z w) ==
            op (op x z) (op y w)
    record MedialQuasiGroupSig
      (AS : Set) : Set where
      constructor MedialQuasiGroupSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record MedialQuasiGroupProd
      (AP : Set) : Set where
      constructor MedialQuasiGroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
        mediatesP :
          (wP : Prod AP AP)
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) (opP zP wP) ==
            opP (opP xP zP) (opP yP wP)
    record MedialQuasiGroupHom
      (A1 : Set) (A2 : Set)
      (Me1 : MedialQuasiGroup A1)
      (Me2 : MedialQuasiGroup A2) :
      Set where
      constructor MedialQuasiGroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Me1 x1 x2) ==
            op Me2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Me1 x1 x2) ==
            linv Me2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Me1 x1 x2) ==
            rinv Me2 (hom x1) (hom x2)
    record MedialQuasiGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Me1 : MedialQuasiGroup A1)
      (Me2 : MedialQuasiGroup A2) :
      Set where
      constructor MedialQuasiGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Me1 x1 x2)
            (op Me2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Me1 x1 x2)
            (linv Me2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Me1 x1 x2)
            (rinv Me2 y1 y2)
    data MedialQuasiGroupLang
      : Set where
      opL :
        MedialQuasiGroupLang ->
        MedialQuasiGroupLang ->
        MedialQuasiGroupLang
      linvL :
        MedialQuasiGroupLang ->
        MedialQuasiGroupLang ->
        MedialQuasiGroupLang
      rinvL :
        MedialQuasiGroupLang ->
        MedialQuasiGroupLang ->
        MedialQuasiGroupLang
    data MedialQuasiGroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        MedialQuasiGroupOpenLang
      opOL :
        MedialQuasiGroupOpenLang ->
        MedialQuasiGroupOpenLang ->
        MedialQuasiGroupOpenLang
      linvOL :
        MedialQuasiGroupOpenLang ->
        MedialQuasiGroupOpenLang ->
        MedialQuasiGroupOpenLang
      rinvOL :
        MedialQuasiGroupOpenLang ->
        MedialQuasiGroupOpenLang ->
        MedialQuasiGroupOpenLang
  
  module MeetSemilattice where
    record MeetSemilattice
      (A : Set) : Set where
      constructor MeetSemilatticeC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        idempotent_op :
          (x : A) -> op x x == x
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record MeetSemilatticeSig
      (AS : Set) : Set where
      constructor MeetSemilatticeSigSigC
      field
        opS : AS -> AS -> AS
    record MeetSemilatticeProd
      (AP : Set) : Set where
      constructor MeetSemilatticeProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        idempotent_opP :
          (xP : Prod AP AP) ->
          opP xP xP == xP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record MeetSemilatticeHom
      (A1 : Set) (A2 : Set)
      (Me1 : MeetSemilattice A1)
      (Me2 : MeetSemilattice A2) :
      Set where
      constructor MeetSemilatticeHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Me1 x1 x2) ==
            op Me2 (hom x1) (hom x2)
    record MeetSemilatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Me1 : MeetSemilattice A1)
      (Me2 : MeetSemilattice A2) :
      Set where
      constructor MeetSemilatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Me1 x1 x2)
            (op Me2 y1 y2)
    data MeetSemilatticeLang
      : Set where
      opL :
        MeetSemilatticeLang ->
        MeetSemilatticeLang ->
        MeetSemilatticeLang
    data MeetSemilatticeOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> MeetSemilatticeOpenLang
      opOL :
        MeetSemilatticeOpenLang ->
        MeetSemilatticeOpenLang ->
        MeetSemilatticeOpenLang
  
  module MiddleAbsorption where
    record MiddleAbsorption
      (A : Set) : Set where
      constructor MiddleAbsorptionC
      field
        op : A -> A -> A
        middleAbsorb_* :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x z
    record MiddleAbsorptionSig
      (AS : Set) : Set where
      constructor MiddleAbsorptionSigSigC
      field
        opS : AS -> AS -> AS
    record MiddleAbsorptionProd
      (AP : Set) : Set where
      constructor MiddleAbsorptionProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        middleAbsorb_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP == opP xP zP
    record MiddleAbsorptionHom
      (A1 : Set) (A2 : Set)
      (Mi1 : MiddleAbsorption A1)
      (Mi2 : MiddleAbsorption A2) :
      Set where
      constructor MiddleAbsorptionHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mi1 x1 x2) ==
            op Mi2 (hom x1) (hom x2)
    record MiddleAbsorptionRelInterp
      (A1 : Set) (A2 : Set)
      (Mi1 : MiddleAbsorption A1)
      (Mi2 : MiddleAbsorption A2) :
      Set where
      constructor MiddleAbsorptionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mi1 x1 x2)
            (op Mi2 y1 y2)
    data MiddleAbsorptionLang
      : Set where
      opL :
        MiddleAbsorptionLang ->
        MiddleAbsorptionLang ->
        MiddleAbsorptionLang
    data MiddleAbsorptionOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        MiddleAbsorptionOpenLang
      opOL :
        MiddleAbsorptionOpenLang ->
        MiddleAbsorptionOpenLang ->
        MiddleAbsorptionOpenLang
  
  module MiddleCommute where
    record MiddleCommute
      (A : Set) : Set where
      constructor MiddleCommuteC
      field
        op : A -> A -> A
        middleCommute_* :
          (x : A) (y : A) (z : A) ->
          op (op (op x y) z) x ==
            op (op (op x z) y) x
    record MiddleCommuteSig
      (AS : Set) : Set where
      constructor MiddleCommuteSigSigC
      field
        opS : AS -> AS -> AS
    record MiddleCommuteProd
      (AP : Set) : Set where
      constructor MiddleCommuteProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        middleCommute_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP (opP xP yP) zP) xP ==
            opP (opP (opP xP zP) yP) xP
    record MiddleCommuteHom
      (A1 : Set) (A2 : Set)
      (Mi1 : MiddleCommute A1)
      (Mi2 : MiddleCommute A2) :
      Set where
      constructor MiddleCommuteHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mi1 x1 x2) ==
            op Mi2 (hom x1) (hom x2)
    record MiddleCommuteRelInterp
      (A1 : Set) (A2 : Set)
      (Mi1 : MiddleCommute A1)
      (Mi2 : MiddleCommute A2) :
      Set where
      constructor MiddleCommuteRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mi1 x1 x2)
            (op Mi2 y1 y2)
    data MiddleCommuteLang
      : Set where
      opL :
        MiddleCommuteLang ->
        MiddleCommuteLang ->
        MiddleCommuteLang
    data MiddleCommuteOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> MiddleCommuteOpenLang
      opOL :
        MiddleCommuteOpenLang ->
        MiddleCommuteOpenLang ->
        MiddleCommuteOpenLang
  
  module ModularLattice where
    record ModularLattice
      (A : Set) : Set where
      constructor ModularLatticeC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
        leftModular_*_+ :
          (x : A) (y : A) (z : A) ->
          + (* x y) (* x z) ==
            * x (+ y (* x z))
    record ModularLatticeSig
      (AS : Set) : Set where
      constructor ModularLatticeSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record ModularLatticeProd
      (AP : Set) : Set where
      constructor ModularLatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
        leftModular_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (*P xP yP) (*P xP zP) ==
            *P xP (+P yP (*P xP zP))
    record ModularLatticeHom
      (A1 : Set) (A2 : Set)
      (Mo1 : ModularLattice A1)
      (Mo2 : ModularLattice A2) :
      Set where
      constructor ModularLatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mo1 x1 x2) ==
            * Mo2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Mo1 x1 x2) ==
            + Mo2 (hom x1) (hom x2)
    record ModularLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : ModularLattice A1)
      (Mo2 : ModularLattice A2) :
      Set where
      constructor ModularLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mo1 x1 x2)
            (* Mo2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Mo1 x1 x2)
            (+ Mo2 y1 y2)
    data ModularLatticeLang
      : Set where
      *L :
        ModularLatticeLang ->
        ModularLatticeLang ->
        ModularLatticeLang
      +L :
        ModularLatticeLang ->
        ModularLatticeLang ->
        ModularLatticeLang
    data ModularLatticeOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> ModularLatticeOpenLang
      *OL :
        ModularLatticeOpenLang ->
        ModularLatticeOpenLang ->
        ModularLatticeOpenLang
      +OL :
        ModularLatticeOpenLang ->
        ModularLatticeOpenLang ->
        ModularLatticeOpenLang
  
  module Modularity where
    record Modularity
      (A : Set) : Set where
      constructor ModularityC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftModular_*_+ :
          (x : A) (y : A) (z : A) ->
          + (* x y) (* x z) ==
            * x (+ y (* x z))
    record ModularitySig
      (AS : Set) : Set where
      constructor ModularitySigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record ModularityProd
      (AP : Set) : Set where
      constructor ModularityProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftModular_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (*P xP yP) (*P xP zP) ==
            *P xP (+P yP (*P xP zP))
    record ModularityHom
      (A1 : Set) (A2 : Set)
      (Mo1 : Modularity A1)
      (Mo2 : Modularity A2) :
      Set where
      constructor ModularityHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mo1 x1 x2) ==
            * Mo2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Mo1 x1 x2) ==
            + Mo2 (hom x1) (hom x2)
    record ModularityRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : Modularity A1)
      (Mo2 : Modularity A2) :
      Set where
      constructor ModularityRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mo1 x1 x2)
            (* Mo2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Mo1 x1 x2)
            (+ Mo2 y1 y2)
    data ModularityLang : Set where
      *L :
        ModularityLang ->
        ModularityLang -> ModularityLang
      +L :
        ModularityLang ->
        ModularityLang -> ModularityLang
    data ModularityOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> ModularityOpenLang
      *OL :
        ModularityOpenLang ->
        ModularityOpenLang ->
        ModularityOpenLang
      +OL :
        ModularityOpenLang ->
        ModularityOpenLang ->
        ModularityOpenLang
  
  module Monoid where
    record Monoid
      (A : Set) : Set where
      constructor MonoidC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record MonoidSig
      (AS : Set) : Set where
      constructor MonoidSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record MonoidProd
      (AP : Set) : Set where
      constructor MonoidProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record MonoidHom
      (A1 : Set) (A2 : Set)
      (Mo1 : Monoid A1)
      (Mo2 : Monoid A2) : Set where
      constructor MonoidHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Mo1) == e Mo2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mo1 x1 x2) ==
            op Mo2 (hom x1) (hom x2)
    record MonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : Monoid A1)
      (Mo2 : Monoid A2) : Set where
      constructor MonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Mo1) (e Mo2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mo1 x1 x2)
            (op Mo2 y1 y2)
    data MonoidLang : Set where
      eL : MonoidLang
      opL :
        MonoidLang ->
        MonoidLang -> MonoidLang
    data MonoidOpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> MonoidOpenLang
      eOL : MonoidOpenLang
      opOL :
        MonoidOpenLang ->
        MonoidOpenLang -> MonoidOpenLang
  
  module Monoid1 where
    record Monoid1
      (A : Set) : Set where
      constructor Monoid1C
      field
        1 : A
        op : A -> A -> A
        lunit_1 : (x : A) -> op 1 x == x
        runit_1 : (x : A) -> op x 1 == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record Monoid1Sig
      (AS : Set) : Set where
      constructor Monoid1SigSigC
      field
        1S : AS
        opS : AS -> AS -> AS
    record Monoid1Prod
      (AP : Set) : Set where
      constructor Monoid1ProdC
      field
        1P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          opP 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          opP xP 1P == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record Monoid1Hom
      (A1 : Set) (A2 : Set)
      (Mo1 : Monoid1 A1)
      (Mo2 : Monoid1 A2) : Set where
      constructor Monoid1HomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Mo1) == 1 Mo2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mo1 x1 x2) ==
            op Mo2 (hom x1) (hom x2)
    record Monoid1RelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : Monoid1 A1)
      (Mo2 : Monoid1 A2) : Set where
      constructor Monoid1RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Mo1) (1 Mo2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mo1 x1 x2)
            (op Mo2 y1 y2)
    data Monoid1Lang : Set where
      1L : Monoid1Lang
      opL :
        Monoid1Lang ->
        Monoid1Lang -> Monoid1Lang
    data Monoid1OpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> Monoid1OpenLang
      1OL : Monoid1OpenLang
      opOL :
        Monoid1OpenLang ->
        Monoid1OpenLang ->
        Monoid1OpenLang
  
  module MoufangIdentity where
    record MoufangIdentity
      (A : Set) : Set where
      constructor MoufangIdentityC
      field
        op : A -> A -> A
        moufangId :
          (x : A) (y : A) (z : A) ->
          op (op z x) (op y z) ==
            op (op z (op x y)) z
    record MoufangIdentitySig
      (AS : Set) : Set where
      constructor MoufangIdentitySigSigC
      field
        opS : AS -> AS -> AS
    record MoufangIdentityProd
      (AP : Set) : Set where
      constructor MoufangIdentityProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        moufangIdP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP zP xP) (opP yP zP) ==
            opP (opP zP (opP xP yP)) zP
    record MoufangIdentityHom
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangIdentity A1)
      (Mo2 : MoufangIdentity A2) :
      Set where
      constructor MoufangIdentityHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mo1 x1 x2) ==
            op Mo2 (hom x1) (hom x2)
    record MoufangIdentityRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangIdentity A1)
      (Mo2 : MoufangIdentity A2) :
      Set where
      constructor MoufangIdentityRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mo1 x1 x2)
            (op Mo2 y1 y2)
    data MoufangIdentityLang
      : Set where
      opL :
        MoufangIdentityLang ->
        MoufangIdentityLang ->
        MoufangIdentityLang
    data MoufangIdentityOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> MoufangIdentityOpenLang
      opOL :
        MoufangIdentityOpenLang ->
        MoufangIdentityOpenLang ->
        MoufangIdentityOpenLang
  
  module MoufangLaw where
    record MoufangLaw
      (A : Set) : Set where
      constructor MoufangLawC
      field
        op : A -> A -> A
        moufangLaw :
          (e : A) (x : A) (y : A)
          (z : A) ->
          op y e == y ->
          op (op (op x y) z) x ==
            op x (op y (op (op e z) x))
    record MoufangLawSig
      (AS : Set) : Set where
      constructor MoufangLawSigSigC
      field
        opS : AS -> AS -> AS
    record MoufangLawProd
      (AP : Set) : Set where
      constructor MoufangLawProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        moufangLawP :
          (eP : Prod AP AP)
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP yP eP == yP ->
          opP (opP (opP xP yP) zP) xP ==
            opP xP
              (opP yP (opP (opP eP zP) xP))
    record MoufangLawHom
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangLaw A1)
      (Mo2 : MoufangLaw A2) :
      Set where
      constructor MoufangLawHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mo1 x1 x2) ==
            op Mo2 (hom x1) (hom x2)
    record MoufangLawRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangLaw A1)
      (Mo2 : MoufangLaw A2) :
      Set where
      constructor MoufangLawRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mo1 x1 x2)
            (op Mo2 y1 y2)
    data MoufangLawLang : Set where
      opL :
        MoufangLawLang ->
        MoufangLawLang -> MoufangLawLang
    data MoufangLawOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> MoufangLawOpenLang
      opOL :
        MoufangLawOpenLang ->
        MoufangLawOpenLang ->
        MoufangLawOpenLang
  
  module MoufangLoop where
    record MoufangLoop
      (A : Set) : Set where
      constructor MoufangLoopC
      field
        op : A -> A -> A
        e : A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
        moufangId :
          (x : A) (y : A) (z : A) ->
          op (op z x) (op y z) ==
            op (op z (op x y)) z
    record MoufangLoopSig
      (AS : Set) : Set where
      constructor MoufangLoopSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
        linvS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record MoufangLoopProd
      (AP : Set) : Set where
      constructor MoufangLoopProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
        moufangIdP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP zP xP) (opP yP zP) ==
            opP (opP zP (opP xP yP)) zP
    record MoufangLoopHom
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangLoop A1)
      (Mo2 : MoufangLoop A2) :
      Set where
      constructor MoufangLoopHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mo1 x1 x2) ==
            op Mo2 (hom x1) (hom x2)
        pres-e : hom (e Mo1) == e Mo2
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Mo1 x1 x2) ==
            linv Mo2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Mo1 x1 x2) ==
            rinv Mo2 (hom x1) (hom x2)
    record MoufangLoopRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangLoop A1)
      (Mo2 : MoufangLoop A2) :
      Set where
      constructor MoufangLoopRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mo1 x1 x2)
            (op Mo2 y1 y2)
        interp-e :
          interp (e Mo1) (e Mo2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Mo1 x1 x2)
            (linv Mo2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Mo1 x1 x2)
            (rinv Mo2 y1 y2)
    data MoufangLoopLang : Set where
      opL :
        MoufangLoopLang ->
        MoufangLoopLang ->
        MoufangLoopLang
      eL : MoufangLoopLang
      linvL :
        MoufangLoopLang ->
        MoufangLoopLang ->
        MoufangLoopLang
      rinvL :
        MoufangLoopLang ->
        MoufangLoopLang ->
        MoufangLoopLang
    data MoufangLoopOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> MoufangLoopOpenLang
      opOL :
        MoufangLoopOpenLang ->
        MoufangLoopOpenLang ->
        MoufangLoopOpenLang
      eOL : MoufangLoopOpenLang
      linvOL :
        MoufangLoopOpenLang ->
        MoufangLoopOpenLang ->
        MoufangLoopOpenLang
      rinvOL :
        MoufangLoopOpenLang ->
        MoufangLoopOpenLang ->
        MoufangLoopOpenLang
  
  module MoufangQuasiGroup where
    record MoufangQuasiGroup
      (A : Set) : Set where
      constructor MoufangQuasiGroupC
      field
        op : A -> A -> A
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
        moufangLaw :
          (e : A) (x : A) (y : A)
          (z : A) ->
          op y e == y ->
          op (op (op x y) z) x ==
            op x (op y (op (op e z) x))
    record MoufangQuasiGroupSig
      (AS : Set) : Set where
      constructor MoufangQuasiGroupSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record MoufangQuasiGroupProd
      (AP : Set) : Set where
      constructor MoufangQuasiGroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
        moufangLawP :
          (eP : Prod AP AP)
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP yP eP == yP ->
          opP (opP (opP xP yP) zP) xP ==
            opP xP
              (opP yP (opP (opP eP zP) xP))
    record MoufangQuasiGroupHom
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangQuasiGroup A1)
      (Mo2 : MoufangQuasiGroup A2) :
      Set where
      constructor MoufangQuasiGroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mo1 x1 x2) ==
            op Mo2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Mo1 x1 x2) ==
            linv Mo2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Mo1 x1 x2) ==
            rinv Mo2 (hom x1) (hom x2)
    record MoufangQuasiGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangQuasiGroup A1)
      (Mo2 : MoufangQuasiGroup A2) :
      Set where
      constructor MoufangQuasiGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mo1 x1 x2)
            (op Mo2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Mo1 x1 x2)
            (linv Mo2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Mo1 x1 x2)
            (rinv Mo2 y1 y2)
    data MoufangQuasiGroupLang
      : Set where
      opL :
        MoufangQuasiGroupLang ->
        MoufangQuasiGroupLang ->
        MoufangQuasiGroupLang
      linvL :
        MoufangQuasiGroupLang ->
        MoufangQuasiGroupLang ->
        MoufangQuasiGroupLang
      rinvL :
        MoufangQuasiGroupLang ->
        MoufangQuasiGroupLang ->
        MoufangQuasiGroupLang
    data MoufangQuasiGroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        MoufangQuasiGroupOpenLang
      opOL :
        MoufangQuasiGroupOpenLang ->
        MoufangQuasiGroupOpenLang ->
        MoufangQuasiGroupOpenLang
      linvOL :
        MoufangQuasiGroupOpenLang ->
        MoufangQuasiGroupOpenLang ->
        MoufangQuasiGroupOpenLang
      rinvOL :
        MoufangQuasiGroupOpenLang ->
        MoufangQuasiGroupOpenLang ->
        MoufangQuasiGroupOpenLang
  
  module MultCommutativeMonoid where
    record MultCommutativeMonoid
      (A : Set) : Set where
      constructor MultCommutativeMonoidC
      field
        1 : A
        * : A -> A -> A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
    record MultCommutativeMonoidSig
      (AS : Set) : Set where
      constructor MultCommutativeMonoidSigSigC
      field
        1S : AS
        *S : AS -> AS -> AS
    record MultCommutativeMonoidProd
      (AP : Set) : Set where
      constructor MultCommutativeMonoidProdC
      field
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
    record MultCommutativeMonoidHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultCommutativeMonoid A1)
      (Mu2 : MultCommutativeMonoid
         A2) : Set where
      constructor MultCommutativeMonoidHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Mu1) == 1 Mu2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultCommutativeMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultCommutativeMonoid A1)
      (Mu2 : MultCommutativeMonoid
         A2) : Set where
      constructor MultCommutativeMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Mu1) (1 Mu2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultCommutativeMonoidLang
      : Set where
      1L : MultCommutativeMonoidLang
      *L :
        MultCommutativeMonoidLang ->
        MultCommutativeMonoidLang ->
        MultCommutativeMonoidLang
    data MultCommutativeMonoidOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        MultCommutativeMonoidOpenLang
      1OL :
        MultCommutativeMonoidOpenLang
      *OL :
        MultCommutativeMonoidOpenLang ->
        MultCommutativeMonoidOpenLang ->
        MultCommutativeMonoidOpenLang
  
  module MultCommutativeSemigroup where
    record MultCommutativeSemigroup
      (A : Set) : Set where
      constructor MultCommutativeSemigroupC
      field
        * : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
    record MultCommutativeSemigroupSig
      (AS : Set) : Set where
      constructor MultCommutativeSemigroupSigSigC
      field
        *S : AS -> AS -> AS
    record MultCommutativeSemigroupProd
      (AP : Set) : Set where
      constructor MultCommutativeSemigroupProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
    record MultCommutativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultCommutativeSemigroup
         A1)
      (Mu2 : MultCommutativeSemigroup
         A2) : Set where
      constructor MultCommutativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultCommutativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultCommutativeSemigroup
         A1)
      (Mu2 : MultCommutativeSemigroup
         A2) : Set where
      constructor MultCommutativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultCommutativeSemigroupLang
      : Set where
      *L :
        MultCommutativeSemigroupLang ->
        MultCommutativeSemigroupLang ->
        MultCommutativeSemigroupLang
    data MultCommutativeSemigroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        MultCommutativeSemigroupOpenLang
      *OL :
        MultCommutativeSemigroupOpenLang ->
        MultCommutativeSemigroupOpenLang ->
        MultCommutativeSemigroupOpenLang
  
  module MultGroup where
    record MultGroup
      (A : Set) : Set where
      constructor MultGroupC
      field
        1 : A
        * : A -> A -> A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        inv : A -> A
        leftInverse_inv_op_1 :
          (x : A) -> * x (inv x) == 1
        rightInverse_inv_op_1 :
          (x : A) -> * (inv x) x == 1
    record MultGroupSig
      (AS : Set) : Set where
      constructor MultGroupSigSigC
      field
        1S : AS
        *S : AS -> AS -> AS
        invS : AS -> AS
    record MultGroupProd
      (AP : Set) : Set where
      constructor MultGroupProdC
      field
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P xP (invP xP) == 1P
        rightInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P (invP xP) xP == 1P
    record MultGroupHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultGroup A1)
      (Mu2 : MultGroup A2) : Set where
      constructor MultGroupHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Mu1) == 1 Mu2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
        pres-inv :
          (x1 : A1) ->
          hom (inv Mu1 x1) ==
            inv Mu2 (hom x1)
    record MultGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultGroup A1)
      (Mu2 : MultGroup A2) : Set where
      constructor MultGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Mu1) (1 Mu2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Mu1 x1) (inv Mu2 y1)
    data MultGroupLang : Set where
      1L : MultGroupLang
      *L :
        MultGroupLang ->
        MultGroupLang -> MultGroupLang
      invL :
        MultGroupLang -> MultGroupLang
    data MultGroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> MultGroupOpenLang
      1OL : MultGroupOpenLang
      *OL :
        MultGroupOpenLang ->
        MultGroupOpenLang ->
        MultGroupOpenLang
      invOL :
        MultGroupOpenLang ->
        MultGroupOpenLang
  
  module MultMagma where
    record MultMagma
      (A : Set) : Set where
      constructor MultMagmaC
      field
        * : A -> A -> A
    record MultMagmaSig
      (AS : Set) : Set where
      constructor MultMagmaSigSigC
      field
        *S : AS -> AS -> AS
    record MultMagmaProd
      (AP : Set) : Set where
      constructor MultMagmaProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record MultMagmaHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultMagma A1)
      (Mu2 : MultMagma A2) : Set where
      constructor MultMagmaHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultMagma A1)
      (Mu2 : MultMagma A2) : Set where
      constructor MultMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultMagmaLang : Set where
      *L :
        MultMagmaLang ->
        MultMagmaLang -> MultMagmaLang
    data MultMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> MultMagmaOpenLang
      *OL :
        MultMagmaOpenLang ->
        MultMagmaOpenLang ->
        MultMagmaOpenLang
  
  module MultMeetSemilattice where
    record MultMeetSemilattice
      (A : Set) : Set where
      constructor MultMeetSemilatticeC
      field
        * : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
    record MultMeetSemilatticeSig
      (AS : Set) : Set where
      constructor MultMeetSemilatticeSigSigC
      field
        *S : AS -> AS -> AS
    record MultMeetSemilatticeProd
      (AP : Set) : Set where
      constructor MultMeetSemilatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
    record MultMeetSemilatticeHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultMeetSemilattice A1)
      (Mu2 : MultMeetSemilattice A2) :
      Set where
      constructor MultMeetSemilatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultMeetSemilatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultMeetSemilattice A1)
      (Mu2 : MultMeetSemilattice A2) :
      Set where
      constructor MultMeetSemilatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultMeetSemilatticeLang
      : Set where
      *L :
        MultMeetSemilatticeLang ->
        MultMeetSemilatticeLang ->
        MultMeetSemilatticeLang
    data MultMeetSemilatticeOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        MultMeetSemilatticeOpenLang
      *OL :
        MultMeetSemilatticeOpenLang ->
        MultMeetSemilatticeOpenLang ->
        MultMeetSemilatticeOpenLang
  
  module MultMonoid where
    record MultMonoid
      (A : Set) : Set where
      constructor MultMonoidC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
    record MultMonoidSig
      (AS : Set) : Set where
      constructor MultMonoidSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
    record MultMonoidProd
      (AP : Set) : Set where
      constructor MultMonoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
    record MultMonoidHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultMonoid A1)
      (Mu2 : MultMonoid A2) :
      Set where
      constructor MultMonoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
        pres-1 : hom (1 Mu1) == 1 Mu2
    record MultMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultMonoid A1)
      (Mu2 : MultMonoid A2) :
      Set where
      constructor MultMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
        interp-1 :
          interp (1 Mu1) (1 Mu2)
    data MultMonoidLang : Set where
      *L :
        MultMonoidLang ->
        MultMonoidLang -> MultMonoidLang
      1L : MultMonoidLang
    data MultMonoidOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> MultMonoidOpenLang
      *OL :
        MultMonoidOpenLang ->
        MultMonoidOpenLang ->
        MultMonoidOpenLang
      1OL : MultMonoidOpenLang
  
  module MultPointedMagma where
    record MultPointedMagma
      (A : Set) : Set where
      constructor MultPointedMagmaC
      field
        1 : A
        * : A -> A -> A
    record MultPointedMagmaSig
      (AS : Set) : Set where
      constructor MultPointedMagmaSigSigC
      field
        1S : AS
        *S : AS -> AS -> AS
    record MultPointedMagmaProd
      (AP : Set) : Set where
      constructor MultPointedMagmaProdC
      field
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record MultPointedMagmaHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultPointedMagma A1)
      (Mu2 : MultPointedMagma A2) :
      Set where
      constructor MultPointedMagmaHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Mu1) == 1 Mu2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultPointedMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultPointedMagma A1)
      (Mu2 : MultPointedMagma A2) :
      Set where
      constructor MultPointedMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Mu1) (1 Mu2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultPointedMagmaLang
      : Set where
      1L : MultPointedMagmaLang
      *L :
        MultPointedMagmaLang ->
        MultPointedMagmaLang ->
        MultPointedMagmaLang
    data MultPointedMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        MultPointedMagmaOpenLang
      1OL : MultPointedMagmaOpenLang
      *OL :
        MultPointedMagmaOpenLang ->
        MultPointedMagmaOpenLang ->
        MultPointedMagmaOpenLang
  
  module MultPointedSemigroup where
    record MultPointedSemigroup
      (A : Set) : Set where
      constructor MultPointedSemigroupC
      field
        1 : A
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
    record MultPointedSemigroupSig
      (AS : Set) : Set where
      constructor MultPointedSemigroupSigSigC
      field
        1S : AS
        *S : AS -> AS -> AS
    record MultPointedSemigroupProd
      (AP : Set) : Set where
      constructor MultPointedSemigroupProdC
      field
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
    record MultPointedSemigroupHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultPointedSemigroup A1)
      (Mu2 : MultPointedSemigroup
         A2) : Set where
      constructor MultPointedSemigroupHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Mu1) == 1 Mu2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultPointedSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultPointedSemigroup A1)
      (Mu2 : MultPointedSemigroup
         A2) : Set where
      constructor MultPointedSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Mu1) (1 Mu2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultPointedSemigroupLang
      : Set where
      1L : MultPointedSemigroupLang
      *L :
        MultPointedSemigroupLang ->
        MultPointedSemigroupLang ->
        MultPointedSemigroupLang
    data MultPointedSemigroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        MultPointedSemigroupOpenLang
      1OL :
        MultPointedSemigroupOpenLang
      *OL :
        MultPointedSemigroupOpenLang ->
        MultPointedSemigroupOpenLang ->
        MultPointedSemigroupOpenLang
  
  module MultSemigroup where
    record MultSemigroup
      (A : Set) : Set where
      constructor MultSemigroupC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
    record MultSemigroupSig
      (AS : Set) : Set where
      constructor MultSemigroupSigSigC
      field
        *S : AS -> AS -> AS
    record MultSemigroupProd
      (AP : Set) : Set where
      constructor MultSemigroupProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
    record MultSemigroupHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultSemigroup A1)
      (Mu2 : MultSemigroup A2) :
      Set where
      constructor MultSemigroupHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultSemigroup A1)
      (Mu2 : MultSemigroup A2) :
      Set where
      constructor MultSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultSemigroupLang
      : Set where
      *L :
        MultSemigroupLang ->
        MultSemigroupLang ->
        MultSemigroupLang
    data MultSemigroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> MultSemigroupOpenLang
      *OL :
        MultSemigroupOpenLang ->
        MultSemigroupOpenLang ->
        MultSemigroupOpenLang
  
  module MultSemilattice_RingoidSig where
    record MultSemilattice_RingoidSig
      (A : Set) : Set where
      constructor MultSemilattice_RingoidSigC
      field
        * : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        + : A -> A -> A
    record MultSemilattice_RingoidSigSig
      (AS : Set) : Set where
      constructor MultSemilattice_RingoidSigSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record MultSemilattice_RingoidSigProd
      (AP : Set) : Set where
      constructor MultSemilattice_RingoidSigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
    record MultSemilattice_RingoidSigHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultSemilattice_RingoidSig
         A1)
      (Mu2 : MultSemilattice_RingoidSig
         A2) : Set where
      constructor MultSemilattice_RingoidSigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Mu1 x1 x2) ==
            + Mu2 (hom x1) (hom x2)
    record MultSemilattice_RingoidSigRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultSemilattice_RingoidSig
         A1)
      (Mu2 : MultSemilattice_RingoidSig
         A2) : Set where
      constructor MultSemilattice_RingoidSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Mu1 x1 x2)
            (+ Mu2 y1 y2)
    data MultSemilattice_RingoidSigLang
      : Set where
      *L :
        MultSemilattice_RingoidSigLang ->
        MultSemilattice_RingoidSigLang ->
        MultSemilattice_RingoidSigLang
      +L :
        MultSemilattice_RingoidSigLang ->
        MultSemilattice_RingoidSigLang ->
        MultSemilattice_RingoidSigLang
    data MultSemilattice_RingoidSigOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        MultSemilattice_RingoidSigOpenLang
      *OL :
        MultSemilattice_RingoidSigOpenLang ->
        MultSemilattice_RingoidSigOpenLang ->
        MultSemilattice_RingoidSigOpenLang
      +OL :
        MultSemilattice_RingoidSigOpenLang ->
        MultSemilattice_RingoidSigOpenLang ->
        MultSemilattice_RingoidSigOpenLang
  
  module MultUnaryAntiDistribution where
    record MultUnaryAntiDistribution
      (A : Set) : Set where
      constructor MultUnaryAntiDistributionC
      field
        prim : A -> A
        * : A -> A -> A
        antidis_prim_* :
          (x : A) (y : A) ->
          prim (* x y) ==
            * (prim y) (prim x)
    record MultUnaryAntiDistributionSig
      (AS : Set) : Set where
      constructor MultUnaryAntiDistributionSigSigC
      field
        primS : AS -> AS
        *S : AS -> AS -> AS
    record MultUnaryAntiDistributionProd
      (AP : Set) : Set where
      constructor MultUnaryAntiDistributionProdC
      field
        primP : Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        antidis_prim_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (*P xP yP) ==
            *P (primP yP) (primP xP)
    record MultUnaryAntiDistributionHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultUnaryAntiDistribution
         A1)
      (Mu2 : MultUnaryAntiDistribution
         A2) : Set where
      constructor MultUnaryAntiDistributionHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Mu1 x1) ==
            prim Mu2 (hom x1)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultUnaryAntiDistributionRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultUnaryAntiDistribution
         A1)
      (Mu2 : MultUnaryAntiDistribution
         A2) : Set where
      constructor MultUnaryAntiDistributionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Mu1 x1)
            (prim Mu2 y1)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultUnaryAntiDistributionLang
      : Set where
      primL :
        MultUnaryAntiDistributionLang ->
        MultUnaryAntiDistributionLang
      *L :
        MultUnaryAntiDistributionLang ->
        MultUnaryAntiDistributionLang ->
        MultUnaryAntiDistributionLang
    data MultUnaryAntiDistributionOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        MultUnaryAntiDistributionOpenLang
      primOL :
        MultUnaryAntiDistributionOpenLang ->
        MultUnaryAntiDistributionOpenLang
      *OL :
        MultUnaryAntiDistributionOpenLang ->
        MultUnaryAntiDistributionOpenLang ->
        MultUnaryAntiDistributionOpenLang
  
  module MultUnital where
    record MultUnital
      (A : Set) : Set where
      constructor MultUnitalC
      field
        1 : A
        * : A -> A -> A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
    record MultUnitalSig
      (AS : Set) : Set where
      constructor MultUnitalSigSigC
      field
        1S : AS
        *S : AS -> AS -> AS
    record MultUnitalProd
      (AP : Set) : Set where
      constructor MultUnitalProdC
      field
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
    record MultUnitalHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultUnital A1)
      (Mu2 : MultUnital A2) :
      Set where
      constructor MultUnitalHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Mu1) == 1 Mu2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultUnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultUnital A1)
      (Mu2 : MultUnital A2) :
      Set where
      constructor MultUnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Mu1) (1 Mu2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultUnitalLang : Set where
      1L : MultUnitalLang
      *L :
        MultUnitalLang ->
        MultUnitalLang -> MultUnitalLang
    data MultUnitalOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> MultUnitalOpenLang
      1OL : MultUnitalOpenLang
      *OL :
        MultUnitalOpenLang ->
        MultUnitalOpenLang ->
        MultUnitalOpenLang
  
  module NearRing where
    record NearRing
      (A : Set) : Set where
      constructor NearRingC
      field
        * : A -> A -> A
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record NearRingSig
      (AS : Set) : Set where
      constructor NearRingSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
    record NearRingProd
      (AP : Set) : Set where
      constructor NearRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record NearRingHom
      (A1 : Set) (A2 : Set)
      (Ne1 : NearRing A1)
      (Ne2 : NearRing A2) : Set where
      constructor NearRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ne1 x1 x2) ==
            * Ne2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ne1 x1 x2) ==
            + Ne2 (hom x1) (hom x2)
        pres-0 : hom (0 Ne1) == 0 Ne2
        pres-neg :
          (x1 : A1) ->
          hom (neg Ne1 x1) ==
            neg Ne2 (hom x1)
    record NearRingRelInterp
      (A1 : Set) (A2 : Set)
      (Ne1 : NearRing A1)
      (Ne2 : NearRing A2) : Set where
      constructor NearRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ne1 x1 x2)
            (* Ne2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ne1 x1 x2)
            (+ Ne2 y1 y2)
        interp-0 :
          interp (0 Ne1) (0 Ne2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Ne1 x1) (neg Ne2 y1)
    data NearRingLang : Set where
      *L :
        NearRingLang ->
        NearRingLang -> NearRingLang
      +L :
        NearRingLang ->
        NearRingLang -> NearRingLang
      0L : NearRingLang
      negL :
        NearRingLang -> NearRingLang
    data NearRingOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> NearRingOpenLang
      *OL :
        NearRingOpenLang ->
        NearRingOpenLang ->
        NearRingOpenLang
      +OL :
        NearRingOpenLang ->
        NearRingOpenLang ->
        NearRingOpenLang
      0OL : NearRingOpenLang
      negOL :
        NearRingOpenLang ->
        NearRingOpenLang
  
  module NearSemiring where
    record NearSemiring
      (A : Set) : Set where
      constructor NearSemiringC
      field
        * : A -> A -> A
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record NearSemiringSig
      (AS : Set) : Set where
      constructor NearSemiringSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record NearSemiringProd
      (AP : Set) : Set where
      constructor NearSemiringProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record NearSemiringHom
      (A1 : Set) (A2 : Set)
      (Ne1 : NearSemiring A1)
      (Ne2 : NearSemiring A2) :
      Set where
      constructor NearSemiringHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ne1 x1 x2) ==
            * Ne2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ne1 x1 x2) ==
            + Ne2 (hom x1) (hom x2)
    record NearSemiringRelInterp
      (A1 : Set) (A2 : Set)
      (Ne1 : NearSemiring A1)
      (Ne2 : NearSemiring A2) :
      Set where
      constructor NearSemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ne1 x1 x2)
            (* Ne2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ne1 x1 x2)
            (+ Ne2 y1 y2)
    data NearSemiringLang
      : Set where
      *L :
        NearSemiringLang ->
        NearSemiringLang ->
        NearSemiringLang
      +L :
        NearSemiringLang ->
        NearSemiringLang ->
        NearSemiringLang
    data NearSemiringOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> NearSemiringOpenLang
      *OL :
        NearSemiringOpenLang ->
        NearSemiringOpenLang ->
        NearSemiringOpenLang
      +OL :
        NearSemiringOpenLang ->
        NearSemiringOpenLang ->
        NearSemiringOpenLang
  
  module NonDistributiveAddPreSemiring where
    record NonDistributiveAddPreSemiring
      (A : Set) : Set where
      constructor NonDistributiveAddPreSemiringC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        * : A -> A -> A
    record NonDistributiveAddPreSemiringSig
      (AS : Set) : Set where
      constructor NonDistributiveAddPreSemiringSigSigC
      field
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
    record NonDistributiveAddPreSemiringProd
      (AP : Set) : Set where
      constructor NonDistributiveAddPreSemiringProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record NonDistributiveAddPreSemiringHom
      (A1 : Set) (A2 : Set)
      (No1 : NonDistributiveAddPreSemiring
         A1)
      (No2 : NonDistributiveAddPreSemiring
         A2) : Set where
      constructor NonDistributiveAddPreSemiringHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ No1 x1 x2) ==
            + No2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* No1 x1 x2) ==
            * No2 (hom x1) (hom x2)
    record NonDistributiveAddPreSemiringRelInterp
      (A1 : Set) (A2 : Set)
      (No1 : NonDistributiveAddPreSemiring
         A1)
      (No2 : NonDistributiveAddPreSemiring
         A2) : Set where
      constructor NonDistributiveAddPreSemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ No1 x1 x2)
            (+ No2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* No1 x1 x2)
            (* No2 y1 y2)
    data NonDistributiveAddPreSemiringLang
      : Set where
      +L :
        NonDistributiveAddPreSemiringLang ->
        NonDistributiveAddPreSemiringLang ->
        NonDistributiveAddPreSemiringLang
      *L :
        NonDistributiveAddPreSemiringLang ->
        NonDistributiveAddPreSemiringLang ->
        NonDistributiveAddPreSemiringLang
    data NonDistributiveAddPreSemiringOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        NonDistributiveAddPreSemiringOpenLang
      +OL :
        NonDistributiveAddPreSemiringOpenLang ->
        NonDistributiveAddPreSemiringOpenLang ->
        NonDistributiveAddPreSemiringOpenLang
      *OL :
        NonDistributiveAddPreSemiringOpenLang ->
        NonDistributiveAddPreSemiringOpenLang ->
        NonDistributiveAddPreSemiringOpenLang
  
  module NonassociativeNondistributiveRing where
    record NonassociativeNondistributiveRing
      (A : Set) : Set where
      constructor NonassociativeNondistributiveRingC
      field
        * : A -> A -> A
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        inv : A -> A
        leftInverse_inv_op_1 :
          (x : A) -> * x (inv x) == 1
        rightInverse_inv_op_1 :
          (x : A) -> * (inv x) x == 1
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        + : A -> A -> A
    record NonassociativeNondistributiveRingSig
      (AS : Set) : Set where
      constructor NonassociativeNondistributiveRingSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
        invS : AS -> AS
        +S : AS -> AS -> AS
    record NonassociativeNondistributiveRingProd
      (AP : Set) : Set where
      constructor NonassociativeNondistributiveRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P xP (invP xP) == 1P
        rightInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P (invP xP) xP == 1P
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
    record NonassociativeNondistributiveRingHom
      (A1 : Set) (A2 : Set)
      (No1 : NonassociativeNondistributiveRing
         A1)
      (No2 : NonassociativeNondistributiveRing
         A2) : Set where
      constructor NonassociativeNondistributiveRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* No1 x1 x2) ==
            * No2 (hom x1) (hom x2)
        pres-1 : hom (1 No1) == 1 No2
        pres-inv :
          (x1 : A1) ->
          hom (inv No1 x1) ==
            inv No2 (hom x1)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ No1 x1 x2) ==
            + No2 (hom x1) (hom x2)
    record NonassociativeNondistributiveRingRelInterp
      (A1 : Set) (A2 : Set)
      (No1 : NonassociativeNondistributiveRing
         A1)
      (No2 : NonassociativeNondistributiveRing
         A2) : Set where
      constructor NonassociativeNondistributiveRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* No1 x1 x2)
            (* No2 y1 y2)
        interp-1 :
          interp (1 No1) (1 No2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv No1 x1) (inv No2 y1)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ No1 x1 x2)
            (+ No2 y1 y2)
    data NonassociativeNondistributiveRingLang
      : Set where
      *L :
        NonassociativeNondistributiveRingLang ->
        NonassociativeNondistributiveRingLang ->
        NonassociativeNondistributiveRingLang
      1L :
        NonassociativeNondistributiveRingLang
      invL :
        NonassociativeNondistributiveRingLang ->
        NonassociativeNondistributiveRingLang
      +L :
        NonassociativeNondistributiveRingLang ->
        NonassociativeNondistributiveRingLang ->
        NonassociativeNondistributiveRingLang
    data NonassociativeNondistributiveRingOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        NonassociativeNondistributiveRingOpenLang
      *OL :
        NonassociativeNondistributiveRingOpenLang ->
        NonassociativeNondistributiveRingOpenLang ->
        NonassociativeNondistributiveRingOpenLang
      1OL :
        NonassociativeNondistributiveRingOpenLang
      invOL :
        NonassociativeNondistributiveRingOpenLang ->
        NonassociativeNondistributiveRingOpenLang
      +OL :
        NonassociativeNondistributiveRingOpenLang ->
        NonassociativeNondistributiveRingOpenLang ->
        NonassociativeNondistributiveRingOpenLang
  
  module NonassociativeRing where
    record NonassociativeRing
      (A : Set) : Set where
      constructor NonassociativeRingC
      field
        * : A -> A -> A
        + : A -> A -> A
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        inv : A -> A
        leftInverse_inv_op_1 :
          (x : A) -> * x (inv x) == 1
        rightInverse_inv_op_1 :
          (x : A) -> * (inv x) x == 1
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record NonassociativeRingSig
      (AS : Set) : Set where
      constructor NonassociativeRingSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        1S : AS
        invS : AS -> AS
    record NonassociativeRingProd
      (AP : Set) : Set where
      constructor NonassociativeRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P xP (invP xP) == 1P
        rightInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P (invP xP) xP == 1P
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record NonassociativeRingHom
      (A1 : Set) (A2 : Set)
      (No1 : NonassociativeRing A1)
      (No2 : NonassociativeRing A2) :
      Set where
      constructor NonassociativeRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* No1 x1 x2) ==
            * No2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ No1 x1 x2) ==
            + No2 (hom x1) (hom x2)
        pres-1 : hom (1 No1) == 1 No2
        pres-inv :
          (x1 : A1) ->
          hom (inv No1 x1) ==
            inv No2 (hom x1)
    record NonassociativeRingRelInterp
      (A1 : Set) (A2 : Set)
      (No1 : NonassociativeRing A1)
      (No2 : NonassociativeRing A2) :
      Set where
      constructor NonassociativeRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* No1 x1 x2)
            (* No2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ No1 x1 x2)
            (+ No2 y1 y2)
        interp-1 :
          interp (1 No1) (1 No2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv No1 x1) (inv No2 y1)
    data NonassociativeRingLang
      : Set where
      *L :
        NonassociativeRingLang ->
        NonassociativeRingLang ->
        NonassociativeRingLang
      +L :
        NonassociativeRingLang ->
        NonassociativeRingLang ->
        NonassociativeRingLang
      1L : NonassociativeRingLang
      invL :
        NonassociativeRingLang ->
        NonassociativeRingLang
    data NonassociativeRingOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        NonassociativeRingOpenLang
      *OL :
        NonassociativeRingOpenLang ->
        NonassociativeRingOpenLang ->
        NonassociativeRingOpenLang
      +OL :
        NonassociativeRingOpenLang ->
        NonassociativeRingOpenLang ->
        NonassociativeRingOpenLang
      1OL : NonassociativeRingOpenLang
      invOL :
        NonassociativeRingOpenLang ->
        NonassociativeRingOpenLang
  
  module NormalBand where
    record NormalBand
      (A : Set) : Set where
      constructor NormalBandC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        idempotent_op :
          (x : A) -> op x x == x
        middleCommute_* :
          (x : A) (y : A) (z : A) ->
          op (op (op x y) z) x ==
            op (op (op x z) y) x
    record NormalBandSig
      (AS : Set) : Set where
      constructor NormalBandSigSigC
      field
        opS : AS -> AS -> AS
    record NormalBandProd
      (AP : Set) : Set where
      constructor NormalBandProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        idempotent_opP :
          (xP : Prod AP AP) ->
          opP xP xP == xP
        middleCommute_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP (opP xP yP) zP) xP ==
            opP (opP (opP xP zP) yP) xP
    record NormalBandHom
      (A1 : Set) (A2 : Set)
      (No1 : NormalBand A1)
      (No2 : NormalBand A2) :
      Set where
      constructor NormalBandHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op No1 x1 x2) ==
            op No2 (hom x1) (hom x2)
    record NormalBandRelInterp
      (A1 : Set) (A2 : Set)
      (No1 : NormalBand A1)
      (No2 : NormalBand A2) :
      Set where
      constructor NormalBandRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op No1 x1 x2)
            (op No2 y1 y2)
    data NormalBandLang : Set where
      opL :
        NormalBandLang ->
        NormalBandLang -> NormalBandLang
    data NormalBandOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> NormalBandOpenLang
      opOL :
        NormalBandOpenLang ->
        NormalBandOpenLang ->
        NormalBandOpenLang
  
  module OrDeMorgran where
    record OrDeMorgran
      (A : Set) : Set where
      constructor OrDeMorgranC
      field
        * : A -> A -> A
        + : A -> A -> A
        prim : A -> A
        orDeMorgan_+_*_prim :
          (x : A) (y : A) (z : A) ->
          prim (+ x y) ==
            * (prim x) (prim y)
    record OrDeMorgranSig
      (AS : Set) : Set where
      constructor OrDeMorgranSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        primS : AS -> AS
    record OrDeMorgranProd
      (AP : Set) : Set where
      constructor OrDeMorgranProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        orDeMorgan_+_*_primP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          primP (+P xP yP) ==
            *P (primP xP) (primP yP)
    record OrDeMorgranHom
      (A1 : Set) (A2 : Set)
      (Or1 : OrDeMorgran A1)
      (Or2 : OrDeMorgran A2) :
      Set where
      constructor OrDeMorgranHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Or1 x1 x2) ==
            * Or2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Or1 x1 x2) ==
            + Or2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Or1 x1) ==
            prim Or2 (hom x1)
    record OrDeMorgranRelInterp
      (A1 : Set) (A2 : Set)
      (Or1 : OrDeMorgran A1)
      (Or2 : OrDeMorgran A2) :
      Set where
      constructor OrDeMorgranRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Or1 x1 x2)
            (* Or2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Or1 x1 x2)
            (+ Or2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Or1 x1)
            (prim Or2 y1)
    data OrDeMorgranLang : Set where
      *L :
        OrDeMorgranLang ->
        OrDeMorgranLang ->
        OrDeMorgranLang
      +L :
        OrDeMorgranLang ->
        OrDeMorgranLang ->
        OrDeMorgranLang
      primL :
        OrDeMorgranLang ->
        OrDeMorgranLang
    data OrDeMorgranOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> OrDeMorgranOpenLang
      *OL :
        OrDeMorgranOpenLang ->
        OrDeMorgranOpenLang ->
        OrDeMorgranOpenLang
      +OL :
        OrDeMorgranOpenLang ->
        OrDeMorgranOpenLang ->
        OrDeMorgranOpenLang
      primOL :
        OrDeMorgranOpenLang ->
        OrDeMorgranOpenLang
  
  module Pointed where
    record Pointed
      (A : Set) : Set where
      constructor PointedC
      field
        e : A
    record PointedSig
      (AS : Set) : Set where
      constructor PointedSigSigC
      field
        eS : AS
    record PointedProd
      (AP : Set) : Set where
      constructor PointedProdC
      field
        eP : Prod AP AP
    record PointedHom
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed A1)
      (Po2 : Pointed A2) : Set where
      constructor PointedHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Po1) == e Po2
    record PointedRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed A1)
      (Po2 : Pointed A2) : Set where
      constructor PointedRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Po1) (e Po2)
    data PointedLang : Set where
      eL : PointedLang
    data PointedOpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> PointedOpenLang
      eOL : PointedOpenLang
  
  module Pointed0Magma where
    record Pointed0Magma
      (A : Set) : Set where
      constructor Pointed0MagmaC
      field
        0 : A
        op : A -> A -> A
    record Pointed0MagmaSig
      (AS : Set) : Set where
      constructor Pointed0MagmaSigSigC
      field
        0S : AS
        opS : AS -> AS -> AS
    record Pointed0MagmaProd
      (AP : Set) : Set where
      constructor Pointed0MagmaProdC
      field
        0P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record Pointed0MagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed0Magma A1)
      (Po2 : Pointed0Magma A2) :
      Set where
      constructor Pointed0MagmaHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Po1) == 0 Po2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Po1 x1 x2) ==
            op Po2 (hom x1) (hom x2)
    record Pointed0MagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed0Magma A1)
      (Po2 : Pointed0Magma A2) :
      Set where
      constructor Pointed0MagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Po1) (0 Po2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Po1 x1 x2)
            (op Po2 y1 y2)
    data Pointed0MagmaLang
      : Set where
      0L : Pointed0MagmaLang
      opL :
        Pointed0MagmaLang ->
        Pointed0MagmaLang ->
        Pointed0MagmaLang
    data Pointed0MagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> Pointed0MagmaOpenLang
      0OL : Pointed0MagmaOpenLang
      opOL :
        Pointed0MagmaOpenLang ->
        Pointed0MagmaOpenLang ->
        Pointed0MagmaOpenLang
  
  module Pointed1Magma where
    record Pointed1Magma
      (A : Set) : Set where
      constructor Pointed1MagmaC
      field
        1 : A
        op : A -> A -> A
    record Pointed1MagmaSig
      (AS : Set) : Set where
      constructor Pointed1MagmaSigSigC
      field
        1S : AS
        opS : AS -> AS -> AS
    record Pointed1MagmaProd
      (AP : Set) : Set where
      constructor Pointed1MagmaProdC
      field
        1P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record Pointed1MagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed1Magma A1)
      (Po2 : Pointed1Magma A2) :
      Set where
      constructor Pointed1MagmaHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Po1) == 1 Po2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Po1 x1 x2) ==
            op Po2 (hom x1) (hom x2)
    record Pointed1MagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed1Magma A1)
      (Po2 : Pointed1Magma A2) :
      Set where
      constructor Pointed1MagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Po1) (1 Po2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Po1 x1 x2)
            (op Po2 y1 y2)
    data Pointed1MagmaLang
      : Set where
      1L : Pointed1MagmaLang
      opL :
        Pointed1MagmaLang ->
        Pointed1MagmaLang ->
        Pointed1MagmaLang
    data Pointed1MagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> Pointed1MagmaOpenLang
      1OL : Pointed1MagmaOpenLang
      opOL :
        Pointed1MagmaOpenLang ->
        Pointed1MagmaOpenLang ->
        Pointed1MagmaOpenLang
  
  module PointedInvolutiveMagma0Sig where
    record PointedInvolutiveMagma0Sig
      (A : Set) : Set where
      constructor PointedInvolutiveMagma0SigC
      field
        * : A -> A -> A
        prim : A -> A
        0 : A
    record PointedInvolutiveMagma0SigSig
      (AS : Set) : Set where
      constructor PointedInvolutiveMagma0SigSigSigC
      field
        *S : AS -> AS -> AS
        primS : AS -> AS
        0S : AS
    record PointedInvolutiveMagma0SigProd
      (AP : Set) : Set where
      constructor PointedInvolutiveMagma0SigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        0P : Prod AP AP
    record PointedInvolutiveMagma0SigHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedInvolutiveMagma0Sig
         A1)
      (Po2 : PointedInvolutiveMagma0Sig
         A2) : Set where
      constructor PointedInvolutiveMagma0SigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Po1 x1 x2) ==
            * Po2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Po1 x1) ==
            prim Po2 (hom x1)
        pres-0 : hom (0 Po1) == 0 Po2
    record PointedInvolutiveMagma0SigRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedInvolutiveMagma0Sig
         A1)
      (Po2 : PointedInvolutiveMagma0Sig
         A2) : Set where
      constructor PointedInvolutiveMagma0SigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Po1 x1 x2)
            (* Po2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Po1 x1)
            (prim Po2 y1)
        interp-0 :
          interp (0 Po1) (0 Po2)
    data PointedInvolutiveMagma0SigLang
      : Set where
      *L :
        PointedInvolutiveMagma0SigLang ->
        PointedInvolutiveMagma0SigLang ->
        PointedInvolutiveMagma0SigLang
      primL :
        PointedInvolutiveMagma0SigLang ->
        PointedInvolutiveMagma0SigLang
      0L :
        PointedInvolutiveMagma0SigLang
    data PointedInvolutiveMagma0SigOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        PointedInvolutiveMagma0SigOpenLang
      *OL :
        PointedInvolutiveMagma0SigOpenLang ->
        PointedInvolutiveMagma0SigOpenLang ->
        PointedInvolutiveMagma0SigOpenLang
      primOL :
        PointedInvolutiveMagma0SigOpenLang ->
        PointedInvolutiveMagma0SigOpenLang
      0OL :
        PointedInvolutiveMagma0SigOpenLang
  
  module PointedMagma where
    record PointedMagma
      (A : Set) : Set where
      constructor PointedMagmaC
      field
        e : A
        op : A -> A -> A
    record PointedMagmaSig
      (AS : Set) : Set where
      constructor PointedMagmaSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record PointedMagmaProd
      (AP : Set) : Set where
      constructor PointedMagmaProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record PointedMagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedMagma A1)
      (Po2 : PointedMagma A2) :
      Set where
      constructor PointedMagmaHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Po1) == e Po2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Po1 x1 x2) ==
            op Po2 (hom x1) (hom x2)
    record PointedMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedMagma A1)
      (Po2 : PointedMagma A2) :
      Set where
      constructor PointedMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Po1) (e Po2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Po1 x1 x2)
            (op Po2 y1 y2)
    data PointedMagmaLang
      : Set where
      eL : PointedMagmaLang
      opL :
        PointedMagmaLang ->
        PointedMagmaLang ->
        PointedMagmaLang
    data PointedMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> PointedMagmaOpenLang
      eOL : PointedMagmaOpenLang
      opOL :
        PointedMagmaOpenLang ->
        PointedMagmaOpenLang ->
        PointedMagmaOpenLang
  
  module PointedOne where
    record PointedOne
      (A : Set) : Set where
      constructor PointedOneC
      field
        1 : A
    record PointedOneSig
      (AS : Set) : Set where
      constructor PointedOneSigSigC
      field
        1S : AS
    record PointedOneProd
      (AP : Set) : Set where
      constructor PointedOneProdC
      field
        1P : Prod AP AP
    record PointedOneHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedOne A1)
      (Po2 : PointedOne A2) :
      Set where
      constructor PointedOneHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Po1) == 1 Po2
    record PointedOneRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedOne A1)
      (Po2 : PointedOne A2) :
      Set where
      constructor PointedOneRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Po1) (1 Po2)
    data PointedOneLang : Set where
      1L : PointedOneLang
    data PointedOneOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> PointedOneOpenLang
      1OL : PointedOneOpenLang
  
  module PointedPlusMagma where
    record PointedPlusMagma
      (A : Set) : Set where
      constructor PointedPlusMagmaC
      field
        + : A -> A -> A
        e : A
    record PointedPlusMagmaSig
      (AS : Set) : Set where
      constructor PointedPlusMagmaSigSigC
      field
        +S : AS -> AS -> AS
        eS : AS
    record PointedPlusMagmaProd
      (AP : Set) : Set where
      constructor PointedPlusMagmaProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
    record PointedPlusMagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedPlusMagma A1)
      (Po2 : PointedPlusMagma A2) :
      Set where
      constructor PointedPlusMagmaHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Po1 x1 x2) ==
            + Po2 (hom x1) (hom x2)
        pres-e : hom (e Po1) == e Po2
    record PointedPlusMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedPlusMagma A1)
      (Po2 : PointedPlusMagma A2) :
      Set where
      constructor PointedPlusMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Po1 x1 x2)
            (+ Po2 y1 y2)
        interp-e :
          interp (e Po1) (e Po2)
    data PointedPlusMagmaLang
      : Set where
      +L :
        PointedPlusMagmaLang ->
        PointedPlusMagmaLang ->
        PointedPlusMagmaLang
      eL : PointedPlusMagmaLang
    data PointedPlusMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        PointedPlusMagmaOpenLang
      +OL :
        PointedPlusMagmaOpenLang ->
        PointedPlusMagmaOpenLang ->
        PointedPlusMagmaOpenLang
      eOL : PointedPlusMagmaOpenLang
  
  module PointedSemigroup where
    record PointedSemigroup
      (A : Set) : Set where
      constructor PointedSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        e : A
    record PointedSemigroupSig
      (AS : Set) : Set where
      constructor PointedSemigroupSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record PointedSemigroupProd
      (AP : Set) : Set where
      constructor PointedSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record PointedSemigroupHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedSemigroup A1)
      (Po2 : PointedSemigroup A2) :
      Set where
      constructor PointedSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Po1 x1 x2) ==
            op Po2 (hom x1) (hom x2)
        pres-e : hom (e Po1) == e Po2
    record PointedSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedSemigroup A1)
      (Po2 : PointedSemigroup A2) :
      Set where
      constructor PointedSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Po1 x1 x2)
            (op Po2 y1 y2)
        interp-e :
          interp (e Po1) (e Po2)
    data PointedSemigroupLang
      : Set where
      opL :
        PointedSemigroupLang ->
        PointedSemigroupLang ->
        PointedSemigroupLang
      eL : PointedSemigroupLang
    data PointedSemigroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        PointedSemigroupOpenLang
      opOL :
        PointedSemigroupOpenLang ->
        PointedSemigroupOpenLang ->
        PointedSemigroupOpenLang
      eOL : PointedSemigroupOpenLang
  
  module PointedSteinerMagma where
    record PointedSteinerMagma
      (A : Set) : Set where
      constructor PointedSteinerMagmaC
      field
        op : A -> A -> A
        e : A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
        antiAbsorbent :
          (x : A) (y : A) ->
          op x (op x y) == y
    record PointedSteinerMagmaSig
      (AS : Set) : Set where
      constructor PointedSteinerMagmaSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record PointedSteinerMagmaProd
      (AP : Set) : Set where
      constructor PointedSteinerMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
        antiAbsorbentP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (opP xP yP) == yP
    record PointedSteinerMagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedSteinerMagma A1)
      (Po2 : PointedSteinerMagma A2) :
      Set where
      constructor PointedSteinerMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Po1 x1 x2) ==
            op Po2 (hom x1) (hom x2)
        pres-e : hom (e Po1) == e Po2
    record PointedSteinerMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedSteinerMagma A1)
      (Po2 : PointedSteinerMagma A2) :
      Set where
      constructor PointedSteinerMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Po1 x1 x2)
            (op Po2 y1 y2)
        interp-e :
          interp (e Po1) (e Po2)
    data PointedSteinerMagmaLang
      : Set where
      opL :
        PointedSteinerMagmaLang ->
        PointedSteinerMagmaLang ->
        PointedSteinerMagmaLang
      eL : PointedSteinerMagmaLang
    data PointedSteinerMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        PointedSteinerMagmaOpenLang
      opOL :
        PointedSteinerMagmaOpenLang ->
        PointedSteinerMagmaOpenLang ->
        PointedSteinerMagmaOpenLang
      eOL :
        PointedSteinerMagmaOpenLang
  
  module PointedTimesMagma where
    record PointedTimesMagma
      (A : Set) : Set where
      constructor PointedTimesMagmaC
      field
        * : A -> A -> A
        e : A
    record PointedTimesMagmaSig
      (AS : Set) : Set where
      constructor PointedTimesMagmaSigSigC
      field
        *S : AS -> AS -> AS
        eS : AS
    record PointedTimesMagmaProd
      (AP : Set) : Set where
      constructor PointedTimesMagmaProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
    record PointedTimesMagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedTimesMagma A1)
      (Po2 : PointedTimesMagma A2) :
      Set where
      constructor PointedTimesMagmaHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Po1 x1 x2) ==
            * Po2 (hom x1) (hom x2)
        pres-e : hom (e Po1) == e Po2
    record PointedTimesMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedTimesMagma A1)
      (Po2 : PointedTimesMagma A2) :
      Set where
      constructor PointedTimesMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Po1 x1 x2)
            (* Po2 y1 y2)
        interp-e :
          interp (e Po1) (e Po2)
    data PointedTimesMagmaLang
      : Set where
      *L :
        PointedTimesMagmaLang ->
        PointedTimesMagmaLang ->
        PointedTimesMagmaLang
      eL : PointedTimesMagmaLang
    data PointedTimesMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        PointedTimesMagmaOpenLang
      *OL :
        PointedTimesMagmaOpenLang ->
        PointedTimesMagmaOpenLang ->
        PointedTimesMagmaOpenLang
      eOL : PointedTimesMagmaOpenLang
  
  module PointedTimesZeroMagma where
    record PointedTimesZeroMagma
      (A : Set) : Set where
      constructor PointedTimesZeroMagmaC
      field
        0 : A
        * : A -> A -> A
    record PointedTimesZeroMagmaSig
      (AS : Set) : Set where
      constructor PointedTimesZeroMagmaSigSigC
      field
        0S : AS
        *S : AS -> AS -> AS
    record PointedTimesZeroMagmaProd
      (AP : Set) : Set where
      constructor PointedTimesZeroMagmaProdC
      field
        0P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record PointedTimesZeroMagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedTimesZeroMagma A1)
      (Po2 : PointedTimesZeroMagma
         A2) : Set where
      constructor PointedTimesZeroMagmaHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Po1) == 0 Po2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Po1 x1 x2) ==
            * Po2 (hom x1) (hom x2)
    record PointedTimesZeroMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedTimesZeroMagma A1)
      (Po2 : PointedTimesZeroMagma
         A2) : Set where
      constructor PointedTimesZeroMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Po1) (0 Po2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Po1 x1 x2)
            (* Po2 y1 y2)
    data PointedTimesZeroMagmaLang
      : Set where
      0L : PointedTimesZeroMagmaLang
      *L :
        PointedTimesZeroMagmaLang ->
        PointedTimesZeroMagmaLang ->
        PointedTimesZeroMagmaLang
    data PointedTimesZeroMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        PointedTimesZeroMagmaOpenLang
      0OL :
        PointedTimesZeroMagmaOpenLang
      *OL :
        PointedTimesZeroMagmaOpenLang ->
        PointedTimesZeroMagmaOpenLang ->
        PointedTimesZeroMagmaOpenLang
  
  module PointedUnarySystem where
    record PointedUnarySystem
      (A : Set) : Set where
      constructor PointedUnarySystemC
      field
        prim : A -> A
        e : A
    record PointedUnarySystemSig
      (AS : Set) : Set where
      constructor PointedUnarySystemSigSigC
      field
        primS : AS -> AS
        eS : AS
    record PointedUnarySystemProd
      (AP : Set) : Set where
      constructor PointedUnarySystemProdC
      field
        primP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
    record PointedUnarySystemHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedUnarySystem A1)
      (Po2 : PointedUnarySystem A2) :
      Set where
      constructor PointedUnarySystemHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Po1 x1) ==
            prim Po2 (hom x1)
        pres-e : hom (e Po1) == e Po2
    record PointedUnarySystemRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedUnarySystem A1)
      (Po2 : PointedUnarySystem A2) :
      Set where
      constructor PointedUnarySystemRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Po1 x1)
            (prim Po2 y1)
        interp-e :
          interp (e Po1) (e Po2)
    data PointedUnarySystemLang
      : Set where
      primL :
        PointedUnarySystemLang ->
        PointedUnarySystemLang
      eL : PointedUnarySystemLang
    data PointedUnarySystemOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        PointedUnarySystemOpenLang
      primOL :
        PointedUnarySystemOpenLang ->
        PointedUnarySystemOpenLang
      eOL : PointedUnarySystemOpenLang
  
  module PointedZero where
    record PointedZero
      (A : Set) : Set where
      constructor PointedZeroC
      field
        0 : A
    record PointedZeroSig
      (AS : Set) : Set where
      constructor PointedZeroSigSigC
      field
        0S : AS
    record PointedZeroProd
      (AP : Set) : Set where
      constructor PointedZeroProdC
      field
        0P : Prod AP AP
    record PointedZeroHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedZero A1)
      (Po2 : PointedZero A2) :
      Set where
      constructor PointedZeroHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Po1) == 0 Po2
    record PointedZeroRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedZero A1)
      (Po2 : PointedZero A2) :
      Set where
      constructor PointedZeroRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Po1) (0 Po2)
    data PointedZeroLang : Set where
      0L : PointedZeroLang
    data PointedZeroOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> PointedZeroOpenLang
      0OL : PointedZeroOpenLang
  
  module PreSemiring where
    record PreSemiring
      (A : Set) : Set where
      constructor PreSemiringC
      field
        * : A -> A -> A
        + : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record PreSemiringSig
      (AS : Set) : Set where
      constructor PreSemiringSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record PreSemiringProd
      (AP : Set) : Set where
      constructor PreSemiringProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record PreSemiringHom
      (A1 : Set) (A2 : Set)
      (Pr1 : PreSemiring A1)
      (Pr2 : PreSemiring A2) :
      Set where
      constructor PreSemiringHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Pr1 x1 x2) ==
            * Pr2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Pr1 x1 x2) ==
            + Pr2 (hom x1) (hom x2)
    record PreSemiringRelInterp
      (A1 : Set) (A2 : Set)
      (Pr1 : PreSemiring A1)
      (Pr2 : PreSemiring A2) :
      Set where
      constructor PreSemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Pr1 x1 x2)
            (* Pr2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Pr1 x1 x2)
            (+ Pr2 y1 y2)
    data PreSemiringLang : Set where
      *L :
        PreSemiringLang ->
        PreSemiringLang ->
        PreSemiringLang
      +L :
        PreSemiringLang ->
        PreSemiringLang ->
        PreSemiringLang
    data PreSemiringOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> PreSemiringOpenLang
      *OL :
        PreSemiringOpenLang ->
        PreSemiringOpenLang ->
        PreSemiringOpenLang
      +OL :
        PreSemiringOpenLang ->
        PreSemiringOpenLang ->
        PreSemiringOpenLang
  
  module PrimAdditiveGroup where
    record PrimAdditiveGroup
      (A : Set) : Set where
      constructor PrimAdditiveGroupC
      field
        0_ : A
        *_ : A -> A -> A
        lunit_0_ :
          (x : A) -> *_ 0_ x == x
        runit_0_ :
          (x : A) -> *_ x 0_ == x
        associative_*_ :
          (x : A) (y : A) (z : A) ->
          *_ (*_ x y) z == *_ x (*_ y z)
        inv_ : A -> A
        leftInverse_inv_op_0_ :
          (x : A) -> *_ x (inv_ x) == 0_
        rightInverse_inv_op_0_ :
          (x : A) -> *_ (inv_ x) x == 0_
        commutative_*_ :
          (x : A) (y : A) ->
          *_ x y == *_ y x
    record PrimAdditiveGroupSig
      (AS : Set) : Set where
      constructor PrimAdditiveGroupSigSigC
      field
        0_S : AS
        *_S : AS -> AS -> AS
        inv_S : AS -> AS
    record PrimAdditiveGroupProd
      (AP : Set) : Set where
      constructor PrimAdditiveGroupProdC
      field
        0_P : Prod AP AP
        *_P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        inv_P : Prod AP AP -> Prod AP AP
        lunit_0_P :
          (xP : Prod AP AP) ->
          *_P 0_P xP == xP
        runit_0_P :
          (xP : Prod AP AP) ->
          *_P xP 0_P == xP
        associative_*_P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *_P (*_P xP yP) zP ==
            *_P xP (*_P yP zP)
        leftInverse_inv_op_0_P :
          (xP : Prod AP AP) ->
          *_P xP (inv_P xP) == 0_P
        rightInverse_inv_op_0_P :
          (xP : Prod AP AP) ->
          *_P (inv_P xP) xP == 0_P
        commutative_*_P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *_P xP yP == *_P yP xP
    record PrimAdditiveGroupHom
      (A1 : Set) (A2 : Set)
      (Pr1 : PrimAdditiveGroup A1)
      (Pr2 : PrimAdditiveGroup A2) :
      Set where
      constructor PrimAdditiveGroupHomC
      field
        hom : A1 -> A2
        pres-0_ : hom (0_ Pr1) == 0_ Pr2
        pres-*_ :
          (x1 : A1) (x2 : A1) ->
          hom (*_ Pr1 x1 x2) ==
            *_ Pr2 (hom x1) (hom x2)
        pres-inv_ :
          (x1 : A1) ->
          hom (inv_ Pr1 x1) ==
            inv_ Pr2 (hom x1)
    record PrimAdditiveGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Pr1 : PrimAdditiveGroup A1)
      (Pr2 : PrimAdditiveGroup A2) :
      Set where
      constructor PrimAdditiveGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0_ :
          interp (0_ Pr1) (0_ Pr2)
        interp-*_ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (*_ Pr1 x1 x2)
            (*_ Pr2 y1 y2)
        interp-inv_ :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv_ Pr1 x1)
            (inv_ Pr2 y1)
    data PrimAdditiveGroupLang
      : Set where
      0_L : PrimAdditiveGroupLang
      *_L :
        PrimAdditiveGroupLang ->
        PrimAdditiveGroupLang ->
        PrimAdditiveGroupLang
      inv_L :
        PrimAdditiveGroupLang ->
        PrimAdditiveGroupLang
    data PrimAdditiveGroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        PrimAdditiveGroupOpenLang
      0_OL : PrimAdditiveGroupOpenLang
      *_OL :
        PrimAdditiveGroupOpenLang ->
        PrimAdditiveGroupOpenLang ->
        PrimAdditiveGroupOpenLang
      inv_OL :
        PrimAdditiveGroupOpenLang ->
        PrimAdditiveGroupOpenLang
  
  module PrimRingoidSig where
    record PrimRingoidSig
      (A : Set) : Set where
      constructor PrimRingoidSigC
      field
        * : A -> A -> A
        + : A -> A -> A
        prim : A -> A
    record PrimRingoidSigSig
      (AS : Set) : Set where
      constructor PrimRingoidSigSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        primS : AS -> AS
    record PrimRingoidSigProd
      (AP : Set) : Set where
      constructor PrimRingoidSigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
    record PrimRingoidSigHom
      (A1 : Set) (A2 : Set)
      (Pr1 : PrimRingoidSig A1)
      (Pr2 : PrimRingoidSig A2) :
      Set where
      constructor PrimRingoidSigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Pr1 x1 x2) ==
            * Pr2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Pr1 x1 x2) ==
            + Pr2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Pr1 x1) ==
            prim Pr2 (hom x1)
    record PrimRingoidSigRelInterp
      (A1 : Set) (A2 : Set)
      (Pr1 : PrimRingoidSig A1)
      (Pr2 : PrimRingoidSig A2) :
      Set where
      constructor PrimRingoidSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Pr1 x1 x2)
            (* Pr2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Pr1 x1 x2)
            (+ Pr2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Pr1 x1)
            (prim Pr2 y1)
    data PrimRingoidSigLang
      : Set where
      *L :
        PrimRingoidSigLang ->
        PrimRingoidSigLang ->
        PrimRingoidSigLang
      +L :
        PrimRingoidSigLang ->
        PrimRingoidSigLang ->
        PrimRingoidSigLang
      primL :
        PrimRingoidSigLang ->
        PrimRingoidSigLang
    data PrimRingoidSigOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> PrimRingoidSigOpenLang
      *OL :
        PrimRingoidSigOpenLang ->
        PrimRingoidSigOpenLang ->
        PrimRingoidSigOpenLang
      +OL :
        PrimRingoidSigOpenLang ->
        PrimRingoidSigOpenLang ->
        PrimRingoidSigOpenLang
      primOL :
        PrimRingoidSigOpenLang ->
        PrimRingoidSigOpenLang
  
  module PseudoInverse where
    record PseudoInverse
      (A : Set) : Set where
      constructor PseudoInverseC
      field
        inv : A -> A
        op : A -> A -> A
        quasiInverse_inv_op_e :
          (x : A) ->
          op (op x (inv x)) x == x
    record PseudoInverseSig
      (AS : Set) : Set where
      constructor PseudoInverseSigSigC
      field
        invS : AS -> AS
        opS : AS -> AS -> AS
    record PseudoInverseProd
      (AP : Set) : Set where
      constructor PseudoInverseProdC
      field
        invP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        quasiInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (opP xP (invP xP)) xP == xP
    record PseudoInverseHom
      (A1 : Set) (A2 : Set)
      (Ps1 : PseudoInverse A1)
      (Ps2 : PseudoInverse A2) :
      Set where
      constructor PseudoInverseHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv Ps1 x1) ==
            inv Ps2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ps1 x1 x2) ==
            op Ps2 (hom x1) (hom x2)
    record PseudoInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Ps1 : PseudoInverse A1)
      (Ps2 : PseudoInverse A2) :
      Set where
      constructor PseudoInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Ps1 x1) (inv Ps2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ps1 x1 x2)
            (op Ps2 y1 y2)
    data PseudoInverseLang
      : Set where
      invL :
        PseudoInverseLang ->
        PseudoInverseLang
      opL :
        PseudoInverseLang ->
        PseudoInverseLang ->
        PseudoInverseLang
    data PseudoInverseOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> PseudoInverseOpenLang
      invOL :
        PseudoInverseOpenLang ->
        PseudoInverseOpenLang
      opOL :
        PseudoInverseOpenLang ->
        PseudoInverseOpenLang ->
        PseudoInverseOpenLang
  
  module PseudoInverseSig where
    record PseudoInverseSig
      (A : Set) : Set where
      constructor PseudoInverseSigC
      field
        inv : A -> A
        op : A -> A -> A
    record PseudoInverseSigSig
      (AS : Set) : Set where
      constructor PseudoInverseSigSigSigC
      field
        invS : AS -> AS
        opS : AS -> AS -> AS
    record PseudoInverseSigProd
      (AP : Set) : Set where
      constructor PseudoInverseSigProdC
      field
        invP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record PseudoInverseSigHom
      (A1 : Set) (A2 : Set)
      (Ps1 : PseudoInverseSig A1)
      (Ps2 : PseudoInverseSig A2) :
      Set where
      constructor PseudoInverseSigHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv Ps1 x1) ==
            inv Ps2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ps1 x1 x2) ==
            op Ps2 (hom x1) (hom x2)
    record PseudoInverseSigRelInterp
      (A1 : Set) (A2 : Set)
      (Ps1 : PseudoInverseSig A1)
      (Ps2 : PseudoInverseSig A2) :
      Set where
      constructor PseudoInverseSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Ps1 x1) (inv Ps2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ps1 x1 x2)
            (op Ps2 y1 y2)
    data PseudoInverseSigLang
      : Set where
      invL :
        PseudoInverseSigLang ->
        PseudoInverseSigLang
      opL :
        PseudoInverseSigLang ->
        PseudoInverseSigLang ->
        PseudoInverseSigLang
    data PseudoInverseSigOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        PseudoInverseSigOpenLang
      invOL :
        PseudoInverseSigOpenLang ->
        PseudoInverseSigOpenLang
      opOL :
        PseudoInverseSigOpenLang ->
        PseudoInverseSigOpenLang ->
        PseudoInverseSigOpenLang
  
  module PseudoInvolution where
    record PseudoInvolution
      (A : Set) : Set where
      constructor PseudoInvolutionC
      field
        inv : A -> A
        op : A -> A -> A
        quasiRightInverse_inv_op_e :
          (x : A) ->
          op (op (inv x) x) (inv x) ==
            inv x
    record PseudoInvolutionSig
      (AS : Set) : Set where
      constructor PseudoInvolutionSigSigC
      field
        invS : AS -> AS
        opS : AS -> AS -> AS
    record PseudoInvolutionProd
      (AP : Set) : Set where
      constructor PseudoInvolutionProdC
      field
        invP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        quasiRightInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (opP (invP xP) xP)
            (invP xP) == invP xP
    record PseudoInvolutionHom
      (A1 : Set) (A2 : Set)
      (Ps1 : PseudoInvolution A1)
      (Ps2 : PseudoInvolution A2) :
      Set where
      constructor PseudoInvolutionHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv Ps1 x1) ==
            inv Ps2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ps1 x1 x2) ==
            op Ps2 (hom x1) (hom x2)
    record PseudoInvolutionRelInterp
      (A1 : Set) (A2 : Set)
      (Ps1 : PseudoInvolution A1)
      (Ps2 : PseudoInvolution A2) :
      Set where
      constructor PseudoInvolutionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Ps1 x1) (inv Ps2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ps1 x1 x2)
            (op Ps2 y1 y2)
    data PseudoInvolutionLang
      : Set where
      invL :
        PseudoInvolutionLang ->
        PseudoInvolutionLang
      opL :
        PseudoInvolutionLang ->
        PseudoInvolutionLang ->
        PseudoInvolutionLang
    data PseudoInvolutionOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        PseudoInvolutionOpenLang
      invOL :
        PseudoInvolutionOpenLang ->
        PseudoInvolutionOpenLang
      opOL :
        PseudoInvolutionOpenLang ->
        PseudoInvolutionOpenLang ->
        PseudoInvolutionOpenLang
  
  module Quandle where
    record Quandle
      (A : Set) : Set where
      constructor QuandleC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
        leftInverse :
          (x : A) (y : A) ->
          <| (|> x y) x == y
        rightInverse :
          (x : A) (y : A) ->
          |> x (<| y x) == y
        idempotent_|> :
          (x : A) -> |> x x == x
        idempotent_<| :
          (x : A) -> <| x x == x
    record QuandleSig
      (AS : Set) : Set where
      constructor QuandleSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record QuandleProd
      (AP : Set) : Set where
      constructor QuandleProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
        leftInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          <|P (|>P xP yP) xP == yP
        rightInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          |>P xP (<|P yP xP) == yP
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
        idempotent_<|P :
          (xP : Prod AP AP) ->
          <|P xP xP == xP
    record QuandleHom
      (A1 : Set) (A2 : Set)
      (Qu1 : Quandle A1)
      (Qu2 : Quandle A2) : Set where
      constructor QuandleHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Qu1 x1 x2) ==
            |> Qu2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Qu1 x1 x2) ==
            <| Qu2 (hom x1) (hom x2)
    record QuandleRelInterp
      (A1 : Set) (A2 : Set)
      (Qu1 : Quandle A1)
      (Qu2 : Quandle A2) : Set where
      constructor QuandleRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Qu1 x1 x2)
            (|> Qu2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Qu1 x1 x2)
            (<| Qu2 y1 y2)
    data QuandleLang : Set where
      |>L :
        QuandleLang ->
        QuandleLang -> QuandleLang
      <|L :
        QuandleLang ->
        QuandleLang -> QuandleLang
    data QuandleOpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> QuandleOpenLang
      |>OL :
        QuandleOpenLang ->
        QuandleOpenLang ->
        QuandleOpenLang
      <|OL :
        QuandleOpenLang ->
        QuandleOpenLang ->
        QuandleOpenLang
  
  module QuasiGroup where
    record QuasiGroup
      (A : Set) : Set where
      constructor QuasiGroupC
      field
        op : A -> A -> A
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
    record QuasiGroupSig
      (AS : Set) : Set where
      constructor QuasiGroupSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record QuasiGroupProd
      (AP : Set) : Set where
      constructor QuasiGroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
    record QuasiGroupHom
      (A1 : Set) (A2 : Set)
      (Qu1 : QuasiGroup A1)
      (Qu2 : QuasiGroup A2) :
      Set where
      constructor QuasiGroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Qu1 x1 x2) ==
            op Qu2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Qu1 x1 x2) ==
            linv Qu2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Qu1 x1 x2) ==
            rinv Qu2 (hom x1) (hom x2)
    record QuasiGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Qu1 : QuasiGroup A1)
      (Qu2 : QuasiGroup A2) :
      Set where
      constructor QuasiGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Qu1 x1 x2)
            (op Qu2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Qu1 x1 x2)
            (linv Qu2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Qu1 x1 x2)
            (rinv Qu2 y1 y2)
    data QuasiGroupLang : Set where
      opL :
        QuasiGroupLang ->
        QuasiGroupLang -> QuasiGroupLang
      linvL :
        QuasiGroupLang ->
        QuasiGroupLang -> QuasiGroupLang
      rinvL :
        QuasiGroupLang ->
        QuasiGroupLang -> QuasiGroupLang
    data QuasiGroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> QuasiGroupOpenLang
      opOL :
        QuasiGroupOpenLang ->
        QuasiGroupOpenLang ->
        QuasiGroupOpenLang
      linvOL :
        QuasiGroupOpenLang ->
        QuasiGroupOpenLang ->
        QuasiGroupOpenLang
      rinvOL :
        QuasiGroupOpenLang ->
        QuasiGroupOpenLang ->
        QuasiGroupOpenLang
  
  module QuasiInverse where
    record QuasiInverse
      (A : Set) : Set where
      constructor QuasiInverseC
      field
        inv : A -> A
        op : A -> A -> A
        quasiInverse_inv_op_e :
          (x : A) ->
          op (op x (inv x)) x == x
        quasiRightInverse_inv_op_e :
          (x : A) ->
          op (op (inv x) x) (inv x) ==
            inv x
    record QuasiInverseSig
      (AS : Set) : Set where
      constructor QuasiInverseSigSigC
      field
        invS : AS -> AS
        opS : AS -> AS -> AS
    record QuasiInverseProd
      (AP : Set) : Set where
      constructor QuasiInverseProdC
      field
        invP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        quasiInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (opP xP (invP xP)) xP == xP
        quasiRightInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (opP (invP xP) xP)
            (invP xP) == invP xP
    record QuasiInverseHom
      (A1 : Set) (A2 : Set)
      (Qu1 : QuasiInverse A1)
      (Qu2 : QuasiInverse A2) :
      Set where
      constructor QuasiInverseHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv Qu1 x1) ==
            inv Qu2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Qu1 x1 x2) ==
            op Qu2 (hom x1) (hom x2)
    record QuasiInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Qu1 : QuasiInverse A1)
      (Qu2 : QuasiInverse A2) :
      Set where
      constructor QuasiInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Qu1 x1) (inv Qu2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Qu1 x1 x2)
            (op Qu2 y1 y2)
    data QuasiInverseLang
      : Set where
      invL :
        QuasiInverseLang ->
        QuasiInverseLang
      opL :
        QuasiInverseLang ->
        QuasiInverseLang ->
        QuasiInverseLang
    data QuasiInverseOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> QuasiInverseOpenLang
      invOL :
        QuasiInverseOpenLang ->
        QuasiInverseOpenLang
      opOL :
        QuasiInverseOpenLang ->
        QuasiInverseOpenLang ->
        QuasiInverseOpenLang
  
  module Rack where
    record Rack
      (A : Set) : Set where
      constructor RackC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
        leftInverse :
          (x : A) (y : A) ->
          <| (|> x y) x == y
        rightInverse :
          (x : A) (y : A) ->
          |> x (<| y x) == y
    record RackSig
      (AS : Set) : Set where
      constructor RackSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record RackProd
      (AP : Set) : Set where
      constructor RackProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
        leftInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          <|P (|>P xP yP) xP == yP
        rightInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          |>P xP (<|P yP xP) == yP
    record RackHom
      (A1 : Set) (A2 : Set)
      (Ra1 : Rack A1)
      (Ra2 : Rack A2) : Set where
      constructor RackHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ra1 x1 x2) ==
            |> Ra2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ra1 x1 x2) ==
            <| Ra2 (hom x1) (hom x2)
    record RackRelInterp
      (A1 : Set) (A2 : Set)
      (Ra1 : Rack A1)
      (Ra2 : Rack A2) : Set where
      constructor RackRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ra1 x1 x2)
            (|> Ra2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ra1 x1 x2)
            (<| Ra2 y1 y2)
    data RackLang : Set where
      |>L :
        RackLang -> RackLang -> RackLang
      <|L :
        RackLang -> RackLang -> RackLang
    data RackOpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> RackOpenLang
      |>OL :
        RackOpenLang ->
        RackOpenLang -> RackOpenLang
      <|OL :
        RackOpenLang ->
        RackOpenLang -> RackOpenLang
  
  module RectangularBand where
    record RectangularBand
      (A : Set) : Set where
      constructor RectangularBandC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        idempotent_op :
          (x : A) -> op x x == x
        middleCommute_* :
          (x : A) (y : A) (z : A) ->
          op (op (op x y) z) x ==
            op (op (op x z) y) x
    record RectangularBandSig
      (AS : Set) : Set where
      constructor RectangularBandSigSigC
      field
        opS : AS -> AS -> AS
    record RectangularBandProd
      (AP : Set) : Set where
      constructor RectangularBandProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        idempotent_opP :
          (xP : Prod AP AP) ->
          opP xP xP == xP
        middleCommute_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP (opP xP yP) zP) xP ==
            opP (opP (opP xP zP) yP) xP
    record RectangularBandHom
      (A1 : Set) (A2 : Set)
      (Re1 : RectangularBand A1)
      (Re2 : RectangularBand A2) :
      Set where
      constructor RectangularBandHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Re1 x1 x2) ==
            op Re2 (hom x1) (hom x2)
    record RectangularBandRelInterp
      (A1 : Set) (A2 : Set)
      (Re1 : RectangularBand A1)
      (Re2 : RectangularBand A2) :
      Set where
      constructor RectangularBandRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Re1 x1 x2)
            (op Re2 y1 y2)
    data RectangularBandLang
      : Set where
      opL :
        RectangularBandLang ->
        RectangularBandLang ->
        RectangularBandLang
    data RectangularBandOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> RectangularBandOpenLang
      opOL :
        RectangularBandOpenLang ->
        RectangularBandOpenLang ->
        RectangularBandOpenLang
  
  module RegularSemigroup where
    record RegularSemigroup
      (A : Set) : Set where
      constructor RegularSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        inv : A -> A
        quasiInverse_inv_op_e :
          (x : A) ->
          op (op x (inv x)) x == x
    record RegularSemigroupSig
      (AS : Set) : Set where
      constructor RegularSemigroupSigSigC
      field
        opS : AS -> AS -> AS
        invS : AS -> AS
    record RegularSemigroupProd
      (AP : Set) : Set where
      constructor RegularSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        quasiInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (opP xP (invP xP)) xP == xP
    record RegularSemigroupHom
      (A1 : Set) (A2 : Set)
      (Re1 : RegularSemigroup A1)
      (Re2 : RegularSemigroup A2) :
      Set where
      constructor RegularSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Re1 x1 x2) ==
            op Re2 (hom x1) (hom x2)
        pres-inv :
          (x1 : A1) ->
          hom (inv Re1 x1) ==
            inv Re2 (hom x1)
    record RegularSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Re1 : RegularSemigroup A1)
      (Re2 : RegularSemigroup A2) :
      Set where
      constructor RegularSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Re1 x1 x2)
            (op Re2 y1 y2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Re1 x1) (inv Re2 y1)
    data RegularSemigroupLang
      : Set where
      opL :
        RegularSemigroupLang ->
        RegularSemigroupLang ->
        RegularSemigroupLang
      invL :
        RegularSemigroupLang ->
        RegularSemigroupLang
    data RegularSemigroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        RegularSemigroupOpenLang
      opOL :
        RegularSemigroupOpenLang ->
        RegularSemigroupOpenLang ->
        RegularSemigroupOpenLang
      invOL :
        RegularSemigroupOpenLang ->
        RegularSemigroupOpenLang
  
  module Right0 where
    record Right0
      (A : Set) : Set where
      constructor Right0C
      field
        0 : A
        op : A -> A -> A
        rightZero_op_0 :
          (x : A) -> op x 0 == 0
    record Right0Sig
      (AS : Set) : Set where
      constructor Right0SigSigC
      field
        0S : AS
        opS : AS -> AS -> AS
    record Right0Prod
      (AP : Set) : Set where
      constructor Right0ProdC
      field
        0P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          opP xP 0P == 0P
    record Right0Hom
      (A1 : Set) (A2 : Set)
      (Ri1 : Right0 A1)
      (Ri2 : Right0 A2) : Set where
      constructor Right0HomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ri1) == 0 Ri2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record Right0RelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Right0 A1)
      (Ri2 : Right0 A2) : Set where
      constructor Right0RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ri1) (0 Ri2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data Right0Lang : Set where
      0L : Right0Lang
      opL :
        Right0Lang ->
        Right0Lang -> Right0Lang
    data Right0OpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> Right0OpenLang
      0OL : Right0OpenLang
      opOL :
        Right0OpenLang ->
        Right0OpenLang -> Right0OpenLang
  
  module RightBiMagma where
    record RightBiMagma
      (A : Set) : Set where
      constructor RightBiMagmaC
      field
        op : A -> A -> A
        rinv : A -> A -> A
    record RightBiMagmaSig
      (AS : Set) : Set where
      constructor RightBiMagmaSigSigC
      field
        opS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record RightBiMagmaProd
      (AP : Set) : Set where
      constructor RightBiMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record RightBiMagmaHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightBiMagma A1)
      (Ri2 : RightBiMagma A2) :
      Set where
      constructor RightBiMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Ri1 x1 x2) ==
            rinv Ri2 (hom x1) (hom x2)
    record RightBiMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightBiMagma A1)
      (Ri2 : RightBiMagma A2) :
      Set where
      constructor RightBiMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Ri1 x1 x2)
            (rinv Ri2 y1 y2)
    data RightBiMagmaLang
      : Set where
      opL :
        RightBiMagmaLang ->
        RightBiMagmaLang ->
        RightBiMagmaLang
      rinvL :
        RightBiMagmaLang ->
        RightBiMagmaLang ->
        RightBiMagmaLang
    data RightBiMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> RightBiMagmaOpenLang
      opOL :
        RightBiMagmaOpenLang ->
        RightBiMagmaOpenLang ->
        RightBiMagmaOpenLang
      rinvOL :
        RightBiMagmaOpenLang ->
        RightBiMagmaOpenLang ->
        RightBiMagmaOpenLang
  
  module RightBinaryInverse where
    record RightBinaryInverse
      (A : Set) : Set where
      constructor RightBinaryInverseC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        rightInverse :
          (x : A) (y : A) ->
          |> x (<| y x) == y
    record RightBinaryInverseSig
      (AS : Set) : Set where
      constructor RightBinaryInverseSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record RightBinaryInverseProd
      (AP : Set) : Set where
      constructor RightBinaryInverseProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          |>P xP (<|P yP xP) == yP
    record RightBinaryInverseHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightBinaryInverse A1)
      (Ri2 : RightBinaryInverse A2) :
      Set where
      constructor RightBinaryInverseHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ri1 x1 x2) ==
            |> Ri2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
    record RightBinaryInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightBinaryInverse A1)
      (Ri2 : RightBinaryInverse A2) :
      Set where
      constructor RightBinaryInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ri1 x1 x2)
            (|> Ri2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
    data RightBinaryInverseLang
      : Set where
      |>L :
        RightBinaryInverseLang ->
        RightBinaryInverseLang ->
        RightBinaryInverseLang
      <|L :
        RightBinaryInverseLang ->
        RightBinaryInverseLang ->
        RightBinaryInverseLang
    data RightBinaryInverseOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        RightBinaryInverseOpenLang
      |>OL :
        RightBinaryInverseOpenLang ->
        RightBinaryInverseOpenLang ->
        RightBinaryInverseOpenLang
      <|OL :
        RightBinaryInverseOpenLang ->
        RightBinaryInverseOpenLang ->
        RightBinaryInverseOpenLang
  
  module RightCancellative where
    record RightCancellative
      (A : Set) : Set where
      constructor RightCancellativeC
      field
        op : A -> A -> A
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
    record RightCancellativeSig
      (AS : Set) : Set where
      constructor RightCancellativeSigSigC
      field
        opS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record RightCancellativeProd
      (AP : Set) : Set where
      constructor RightCancellativeProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
    record RightCancellativeHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellative A1)
      (Ri2 : RightCancellative A2) :
      Set where
      constructor RightCancellativeHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Ri1 x1 x2) ==
            rinv Ri2 (hom x1) (hom x2)
    record RightCancellativeRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellative A1)
      (Ri2 : RightCancellative A2) :
      Set where
      constructor RightCancellativeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Ri1 x1 x2)
            (rinv Ri2 y1 y2)
    data RightCancellativeLang
      : Set where
      opL :
        RightCancellativeLang ->
        RightCancellativeLang ->
        RightCancellativeLang
      rinvL :
        RightCancellativeLang ->
        RightCancellativeLang ->
        RightCancellativeLang
    data RightCancellativeOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        RightCancellativeOpenLang
      opOL :
        RightCancellativeOpenLang ->
        RightCancellativeOpenLang ->
        RightCancellativeOpenLang
      rinvOL :
        RightCancellativeOpenLang ->
        RightCancellativeOpenLang ->
        RightCancellativeOpenLang
  
  module RightCancellativeMagma where
    record RightCancellativeMagma
      (A : Set) : Set where
      constructor RightCancellativeMagmaC
      field
        op : A -> A -> A
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
    record RightCancellativeMagmaSig
      (AS : Set) : Set where
      constructor RightCancellativeMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record RightCancellativeMagmaProd
      (AP : Set) : Set where
      constructor RightCancellativeMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
    record RightCancellativeMagmaHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellativeMagma
         A1)
      (Ri2 : RightCancellativeMagma
         A2) : Set where
      constructor RightCancellativeMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record RightCancellativeMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellativeMagma
         A1)
      (Ri2 : RightCancellativeMagma
         A2) : Set where
      constructor RightCancellativeMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data RightCancellativeMagmaLang
      : Set where
      opL :
        RightCancellativeMagmaLang ->
        RightCancellativeMagmaLang ->
        RightCancellativeMagmaLang
    data RightCancellativeMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        RightCancellativeMagmaOpenLang
      opOL :
        RightCancellativeMagmaOpenLang ->
        RightCancellativeMagmaOpenLang ->
        RightCancellativeMagmaOpenLang
  
  module RightCancellativeOp where
    record RightCancellativeOp
      (A : Set) : Set where
      constructor RightCancellativeOpC
      field
        op : A -> A -> A
        rinv : A -> A -> A
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
    record RightCancellativeOpSig
      (AS : Set) : Set where
      constructor RightCancellativeOpSigSigC
      field
        opS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record RightCancellativeOpProd
      (AP : Set) : Set where
      constructor RightCancellativeOpProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
    record RightCancellativeOpHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellativeOp A1)
      (Ri2 : RightCancellativeOp A2) :
      Set where
      constructor RightCancellativeOpHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Ri1 x1 x2) ==
            rinv Ri2 (hom x1) (hom x2)
    record RightCancellativeOpRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellativeOp A1)
      (Ri2 : RightCancellativeOp A2) :
      Set where
      constructor RightCancellativeOpRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Ri1 x1 x2)
            (rinv Ri2 y1 y2)
    data RightCancellativeOpLang
      : Set where
      opL :
        RightCancellativeOpLang ->
        RightCancellativeOpLang ->
        RightCancellativeOpLang
      rinvL :
        RightCancellativeOpLang ->
        RightCancellativeOpLang ->
        RightCancellativeOpLang
    data RightCancellativeOpOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        RightCancellativeOpOpenLang
      opOL :
        RightCancellativeOpOpenLang ->
        RightCancellativeOpOpenLang ->
        RightCancellativeOpOpenLang
      rinvOL :
        RightCancellativeOpOpenLang ->
        RightCancellativeOpOpenLang ->
        RightCancellativeOpOpenLang
  
  module RightCancellativeSemigroup where
    record RightCancellativeSemigroup
      (A : Set) : Set where
      constructor RightCancellativeSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
    record RightCancellativeSemigroupSig
      (AS : Set) : Set where
      constructor RightCancellativeSemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record RightCancellativeSemigroupProd
      (AP : Set) : Set where
      constructor RightCancellativeSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
    record RightCancellativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellativeSemigroup
         A1)
      (Ri2 : RightCancellativeSemigroup
         A2) : Set where
      constructor RightCancellativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record RightCancellativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellativeSemigroup
         A1)
      (Ri2 : RightCancellativeSemigroup
         A2) : Set where
      constructor RightCancellativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data RightCancellativeSemigroupLang
      : Set where
      opL :
        RightCancellativeSemigroupLang ->
        RightCancellativeSemigroupLang ->
        RightCancellativeSemigroupLang
    data RightCancellativeSemigroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        RightCancellativeSemigroupOpenLang
      opOL :
        RightCancellativeSemigroupOpenLang ->
        RightCancellativeSemigroupOpenLang ->
        RightCancellativeSemigroupOpenLang
  
  module RightDistributiveMagma where
    record RightDistributiveMagma
      (A : Set) : Set where
      constructor RightDistributiveMagmaC
      field
        op : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          op (op y z) x ==
            op (op y x) (op z x)
    record RightDistributiveMagmaSig
      (AS : Set) : Set where
      constructor RightDistributiveMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record RightDistributiveMagmaProd
      (AP : Set) : Set where
      constructor RightDistributiveMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP yP zP) xP ==
            opP (opP yP xP) (opP zP xP)
    record RightDistributiveMagmaHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightDistributiveMagma
         A1)
      (Ri2 : RightDistributiveMagma
         A2) : Set where
      constructor RightDistributiveMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record RightDistributiveMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightDistributiveMagma
         A1)
      (Ri2 : RightDistributiveMagma
         A2) : Set where
      constructor RightDistributiveMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data RightDistributiveMagmaLang
      : Set where
      opL :
        RightDistributiveMagmaLang ->
        RightDistributiveMagmaLang ->
        RightDistributiveMagmaLang
    data RightDistributiveMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        RightDistributiveMagmaOpenLang
      opOL :
        RightDistributiveMagmaOpenLang ->
        RightDistributiveMagmaOpenLang ->
        RightDistributiveMagmaOpenLang
  
  module RightIdempotence where
    record RightIdempotence
      (A : Set) : Set where
      constructor RightIdempotenceC
      field
        <| : A -> A -> A
        idempotent_<| :
          (x : A) -> <| x x == x
    record RightIdempotenceSig
      (AS : Set) : Set where
      constructor RightIdempotenceSigSigC
      field
        <|S : AS -> AS -> AS
    record RightIdempotenceProd
      (AP : Set) : Set where
      constructor RightIdempotenceProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        idempotent_<|P :
          (xP : Prod AP AP) ->
          <|P xP xP == xP
    record RightIdempotenceHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightIdempotence A1)
      (Ri2 : RightIdempotence A2) :
      Set where
      constructor RightIdempotenceHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
    record RightIdempotenceRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightIdempotence A1)
      (Ri2 : RightIdempotence A2) :
      Set where
      constructor RightIdempotenceRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
    data RightIdempotenceLang
      : Set where
      <|L :
        RightIdempotenceLang ->
        RightIdempotenceLang ->
        RightIdempotenceLang
    data RightIdempotenceOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        RightIdempotenceOpenLang
      <|OL :
        RightIdempotenceOpenLang ->
        RightIdempotenceOpenLang ->
        RightIdempotenceOpenLang
  
  module RightInverse where
    record RightInverse
      (A : Set) : Set where
      constructor RightInverseC
      field
        inv : A -> A
        e : A
        op : A -> A -> A
        rightInverse_inv_op_e :
          (x : A) -> op (inv x) x == e
    record RightInverseSig
      (AS : Set) : Set where
      constructor RightInverseSigSigC
      field
        invS : AS -> AS
        eS : AS
        opS : AS -> AS -> AS
    record RightInverseProd
      (AP : Set) : Set where
      constructor RightInverseProdC
      field
        invP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (invP xP) xP == eP
    record RightInverseHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightInverse A1)
      (Ri2 : RightInverse A2) :
      Set where
      constructor RightInverseHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv Ri1 x1) ==
            inv Ri2 (hom x1)
        pres-e : hom (e Ri1) == e Ri2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record RightInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightInverse A1)
      (Ri2 : RightInverse A2) :
      Set where
      constructor RightInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Ri1 x1) (inv Ri2 y1)
        interp-e :
          interp (e Ri1) (e Ri2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data RightInverseLang
      : Set where
      invL :
        RightInverseLang ->
        RightInverseLang
      eL : RightInverseLang
      opL :
        RightInverseLang ->
        RightInverseLang ->
        RightInverseLang
    data RightInverseOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> RightInverseOpenLang
      invOL :
        RightInverseOpenLang ->
        RightInverseOpenLang
      eOL : RightInverseOpenLang
      opOL :
        RightInverseOpenLang ->
        RightInverseOpenLang ->
        RightInverseOpenLang
  
  module RightInverseMagma where
    record RightInverseMagma
      (A : Set) : Set where
      constructor RightInverseMagmaC
      field
        rinv : A -> A -> A
    record RightInverseMagmaSig
      (AS : Set) : Set where
      constructor RightInverseMagmaSigSigC
      field
        rinvS : AS -> AS -> AS
    record RightInverseMagmaProd
      (AP : Set) : Set where
      constructor RightInverseMagmaProdC
      field
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record RightInverseMagmaHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightInverseMagma A1)
      (Ri2 : RightInverseMagma A2) :
      Set where
      constructor RightInverseMagmaHomC
      field
        hom : A1 -> A2
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Ri1 x1 x2) ==
            rinv Ri2 (hom x1) (hom x2)
    record RightInverseMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightInverseMagma A1)
      (Ri2 : RightInverseMagma A2) :
      Set where
      constructor RightInverseMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Ri1 x1 x2)
            (rinv Ri2 y1 y2)
    data RightInverseMagmaLang
      : Set where
      rinvL :
        RightInverseMagmaLang ->
        RightInverseMagmaLang ->
        RightInverseMagmaLang
    data RightInverseMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        RightInverseMagmaOpenLang
      rinvOL :
        RightInverseMagmaOpenLang ->
        RightInverseMagmaOpenLang ->
        RightInverseMagmaOpenLang
  
  module RightMonoid where
    record RightMonoid
      (A : Set) : Set where
      constructor RightMonoidC
      field
        op : A -> A -> A
        e : A
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record RightMonoidSig
      (AS : Set) : Set where
      constructor RightMonoidSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record RightMonoidProd
      (AP : Set) : Set where
      constructor RightMonoidProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record RightMonoidHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightMonoid A1)
      (Ri2 : RightMonoid A2) :
      Set where
      constructor RightMonoidHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
        pres-e : hom (e Ri1) == e Ri2
    record RightMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightMonoid A1)
      (Ri2 : RightMonoid A2) :
      Set where
      constructor RightMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
        interp-e :
          interp (e Ri1) (e Ri2)
    data RightMonoidLang : Set where
      opL :
        RightMonoidLang ->
        RightMonoidLang ->
        RightMonoidLang
      eL : RightMonoidLang
    data RightMonoidOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> RightMonoidOpenLang
      opOL :
        RightMonoidOpenLang ->
        RightMonoidOpenLang ->
        RightMonoidOpenLang
      eOL : RightMonoidOpenLang
  
  module RightPreSemiring where
    record RightPreSemiring
      (A : Set) : Set where
      constructor RightPreSemiringC
      field
        * : A -> A -> A
        + : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record RightPreSemiringSig
      (AS : Set) : Set where
      constructor RightPreSemiringSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record RightPreSemiringProd
      (AP : Set) : Set where
      constructor RightPreSemiringProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record RightPreSemiringHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightPreSemiring A1)
      (Ri2 : RightPreSemiring A2) :
      Set where
      constructor RightPreSemiringHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
    record RightPreSemiringRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightPreSemiring A1)
      (Ri2 : RightPreSemiring A2) :
      Set where
      constructor RightPreSemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
    data RightPreSemiringLang
      : Set where
      *L :
        RightPreSemiringLang ->
        RightPreSemiringLang ->
        RightPreSemiringLang
      +L :
        RightPreSemiringLang ->
        RightPreSemiringLang ->
        RightPreSemiringLang
    data RightPreSemiringOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        RightPreSemiringOpenLang
      *OL :
        RightPreSemiringOpenLang ->
        RightPreSemiringOpenLang ->
        RightPreSemiringOpenLang
      +OL :
        RightPreSemiringOpenLang ->
        RightPreSemiringOpenLang ->
        RightPreSemiringOpenLang
  
  module RightQuasiGroup where
    record RightQuasiGroup
      (A : Set) : Set where
      constructor RightQuasiGroupC
      field
        op : A -> A -> A
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
    record RightQuasiGroupSig
      (AS : Set) : Set where
      constructor RightQuasiGroupSigSigC
      field
        opS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record RightQuasiGroupProd
      (AP : Set) : Set where
      constructor RightQuasiGroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
    record RightQuasiGroupHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightQuasiGroup A1)
      (Ri2 : RightQuasiGroup A2) :
      Set where
      constructor RightQuasiGroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Ri1 x1 x2) ==
            rinv Ri2 (hom x1) (hom x2)
    record RightQuasiGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightQuasiGroup A1)
      (Ri2 : RightQuasiGroup A2) :
      Set where
      constructor RightQuasiGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Ri1 x1 x2)
            (rinv Ri2 y1 y2)
    data RightQuasiGroupLang
      : Set where
      opL :
        RightQuasiGroupLang ->
        RightQuasiGroupLang ->
        RightQuasiGroupLang
      rinvL :
        RightQuasiGroupLang ->
        RightQuasiGroupLang ->
        RightQuasiGroupLang
    data RightQuasiGroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> RightQuasiGroupOpenLang
      opOL :
        RightQuasiGroupOpenLang ->
        RightQuasiGroupOpenLang ->
        RightQuasiGroupOpenLang
      rinvOL :
        RightQuasiGroupOpenLang ->
        RightQuasiGroupOpenLang ->
        RightQuasiGroupOpenLang
  
  module RightRack where
    record RightRack
      (A : Set) : Set where
      constructor RightRackC
      field
        <| : A -> A -> A
        |> : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
    record RightRackSig
      (AS : Set) : Set where
      constructor RightRackSigSigC
      field
        <|S : AS -> AS -> AS
        |>S : AS -> AS -> AS
    record RightRackProd
      (AP : Set) : Set where
      constructor RightRackProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
    record RightRackHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightRack A1)
      (Ri2 : RightRack A2) : Set where
      constructor RightRackHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ri1 x1 x2) ==
            |> Ri2 (hom x1) (hom x2)
    record RightRackRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightRack A1)
      (Ri2 : RightRack A2) : Set where
      constructor RightRackRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ri1 x1 x2)
            (|> Ri2 y1 y2)
    data RightRackLang : Set where
      <|L :
        RightRackLang ->
        RightRackLang -> RightRackLang
      |>L :
        RightRackLang ->
        RightRackLang -> RightRackLang
    data RightRackOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> RightRackOpenLang
      <|OL :
        RightRackOpenLang ->
        RightRackOpenLang ->
        RightRackOpenLang
      |>OL :
        RightRackOpenLang ->
        RightRackOpenLang ->
        RightRackOpenLang
  
  module RightRingoid where
    record RightRingoid
      (A : Set) : Set where
      constructor RightRingoidC
      field
        * : A -> A -> A
        + : A -> A -> A
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record RightRingoidSig
      (AS : Set) : Set where
      constructor RightRingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record RightRingoidProd
      (AP : Set) : Set where
      constructor RightRingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record RightRingoidHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightRingoid A1)
      (Ri2 : RightRingoid A2) :
      Set where
      constructor RightRingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
    record RightRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightRingoid A1)
      (Ri2 : RightRingoid A2) :
      Set where
      constructor RightRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
    data RightRingoidLang
      : Set where
      *L :
        RightRingoidLang ->
        RightRingoidLang ->
        RightRingoidLang
      +L :
        RightRingoidLang ->
        RightRingoidLang ->
        RightRingoidLang
    data RightRingoidOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> RightRingoidOpenLang
      *OL :
        RightRingoidOpenLang ->
        RightRingoidOpenLang ->
        RightRingoidOpenLang
      +OL :
        RightRingoidOpenLang ->
        RightRingoidOpenLang ->
        RightRingoidOpenLang
  
  module RightSelfInverse where
    record RightSelfInverse
      (A : Set) : Set where
      constructor RightSelfInverseC
      field
        |> : A -> A -> A
        rightSelfInverse_|> :
          (x : A) (y : A) ->
          |> (|> x y) y == x
    record RightSelfInverseSig
      (AS : Set) : Set where
      constructor RightSelfInverseSigSigC
      field
        |>S : AS -> AS -> AS
    record RightSelfInverseProd
      (AP : Set) : Set where
      constructor RightSelfInverseProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightSelfInverse_|>P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          |>P (|>P xP yP) yP == xP
    record RightSelfInverseHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSelfInverse A1)
      (Ri2 : RightSelfInverse A2) :
      Set where
      constructor RightSelfInverseHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ri1 x1 x2) ==
            |> Ri2 (hom x1) (hom x2)
    record RightSelfInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSelfInverse A1)
      (Ri2 : RightSelfInverse A2) :
      Set where
      constructor RightSelfInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ri1 x1 x2)
            (|> Ri2 y1 y2)
    data RightSelfInverseLang
      : Set where
      |>L :
        RightSelfInverseLang ->
        RightSelfInverseLang ->
        RightSelfInverseLang
    data RightSelfInverseOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        RightSelfInverseOpenLang
      |>OL :
        RightSelfInverseOpenLang ->
        RightSelfInverseOpenLang ->
        RightSelfInverseOpenLang
  
  module RightShelf where
    record RightShelf
      (A : Set) : Set where
      constructor RightShelfC
      field
        <| : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
    record RightShelfSig
      (AS : Set) : Set where
      constructor RightShelfSigSigC
      field
        <|S : AS -> AS -> AS
    record RightShelfProd
      (AP : Set) : Set where
      constructor RightShelfProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
    record RightShelfHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightShelf A1)
      (Ri2 : RightShelf A2) :
      Set where
      constructor RightShelfHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
    record RightShelfRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightShelf A1)
      (Ri2 : RightShelf A2) :
      Set where
      constructor RightShelfRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
    data RightShelfLang : Set where
      <|L :
        RightShelfLang ->
        RightShelfLang -> RightShelfLang
    data RightShelfOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> RightShelfOpenLang
      <|OL :
        RightShelfOpenLang ->
        RightShelfOpenLang ->
        RightShelfOpenLang
  
  module RightShelfSig where
    record RightShelfSig
      (A : Set) : Set where
      constructor RightShelfSigC
      field
        <| : A -> A -> A
    record RightShelfSigSig
      (AS : Set) : Set where
      constructor RightShelfSigSigSigC
      field
        <|S : AS -> AS -> AS
    record RightShelfSigProd
      (AP : Set) : Set where
      constructor RightShelfSigProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record RightShelfSigHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightShelfSig A1)
      (Ri2 : RightShelfSig A2) :
      Set where
      constructor RightShelfSigHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
    record RightShelfSigRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightShelfSig A1)
      (Ri2 : RightShelfSig A2) :
      Set where
      constructor RightShelfSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
    data RightShelfSigLang
      : Set where
      <|L :
        RightShelfSigLang ->
        RightShelfSigLang ->
        RightShelfSigLang
    data RightShelfSigOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> RightShelfSigOpenLang
      <|OL :
        RightShelfSigOpenLang ->
        RightShelfSigOpenLang ->
        RightShelfSigOpenLang
  
  module RightSpindle where
    record RightSpindle
      (A : Set) : Set where
      constructor RightSpindleC
      field
        <| : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
        idempotent_<| :
          (x : A) -> <| x x == x
    record RightSpindleSig
      (AS : Set) : Set where
      constructor RightSpindleSigSigC
      field
        <|S : AS -> AS -> AS
    record RightSpindleProd
      (AP : Set) : Set where
      constructor RightSpindleProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
        idempotent_<|P :
          (xP : Prod AP AP) ->
          <|P xP xP == xP
    record RightSpindleHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSpindle A1)
      (Ri2 : RightSpindle A2) :
      Set where
      constructor RightSpindleHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
    record RightSpindleRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSpindle A1)
      (Ri2 : RightSpindle A2) :
      Set where
      constructor RightSpindleRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
    data RightSpindleLang
      : Set where
      <|L :
        RightSpindleLang ->
        RightSpindleLang ->
        RightSpindleLang
    data RightSpindleOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> RightSpindleOpenLang
      <|OL :
        RightSpindleOpenLang ->
        RightSpindleOpenLang ->
        RightSpindleOpenLang
  
  module RightSpindle_Shelf where
    record RightSpindle_Shelf
      (A : Set) : Set where
      constructor RightSpindle_ShelfC
      field
        <| : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
        idempotent_<| :
          (x : A) -> <| x x == x
        |> : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
    record RightSpindle_ShelfSig
      (AS : Set) : Set where
      constructor RightSpindle_ShelfSigSigC
      field
        <|S : AS -> AS -> AS
        |>S : AS -> AS -> AS
    record RightSpindle_ShelfProd
      (AP : Set) : Set where
      constructor RightSpindle_ShelfProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
        idempotent_<|P :
          (xP : Prod AP AP) ->
          <|P xP xP == xP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
    record RightSpindle_ShelfHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSpindle_Shelf A1)
      (Ri2 : RightSpindle_Shelf A2) :
      Set where
      constructor RightSpindle_ShelfHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ri1 x1 x2) ==
            |> Ri2 (hom x1) (hom x2)
    record RightSpindle_ShelfRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSpindle_Shelf A1)
      (Ri2 : RightSpindle_Shelf A2) :
      Set where
      constructor RightSpindle_ShelfRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ri1 x1 x2)
            (|> Ri2 y1 y2)
    data RightSpindle_ShelfLang
      : Set where
      <|L :
        RightSpindle_ShelfLang ->
        RightSpindle_ShelfLang ->
        RightSpindle_ShelfLang
      |>L :
        RightSpindle_ShelfLang ->
        RightSpindle_ShelfLang ->
        RightSpindle_ShelfLang
    data RightSpindle_ShelfOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        RightSpindle_ShelfOpenLang
      <|OL :
        RightSpindle_ShelfOpenLang ->
        RightSpindle_ShelfOpenLang ->
        RightSpindle_ShelfOpenLang
      |>OL :
        RightSpindle_ShelfOpenLang ->
        RightSpindle_ShelfOpenLang ->
        RightSpindle_ShelfOpenLang
  
  module RightSpindle_ShelfSig where
    record RightSpindle_ShelfSig
      (A : Set) : Set where
      constructor RightSpindle_ShelfSigC
      field
        <| : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
        idempotent_<| :
          (x : A) -> <| x x == x
        |> : A -> A -> A
    record RightSpindle_ShelfSigSig
      (AS : Set) : Set where
      constructor RightSpindle_ShelfSigSigSigC
      field
        <|S : AS -> AS -> AS
        |>S : AS -> AS -> AS
    record RightSpindle_ShelfSigProd
      (AP : Set) : Set where
      constructor RightSpindle_ShelfSigProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
        idempotent_<|P :
          (xP : Prod AP AP) ->
          <|P xP xP == xP
    record RightSpindle_ShelfSigHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSpindle_ShelfSig A1)
      (Ri2 : RightSpindle_ShelfSig
         A2) : Set where
      constructor RightSpindle_ShelfSigHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ri1 x1 x2) ==
            |> Ri2 (hom x1) (hom x2)
    record RightSpindle_ShelfSigRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSpindle_ShelfSig A1)
      (Ri2 : RightSpindle_ShelfSig
         A2) : Set where
      constructor RightSpindle_ShelfSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ri1 x1 x2)
            (|> Ri2 y1 y2)
    data RightSpindle_ShelfSigLang
      : Set where
      <|L :
        RightSpindle_ShelfSigLang ->
        RightSpindle_ShelfSigLang ->
        RightSpindle_ShelfSigLang
      |>L :
        RightSpindle_ShelfSigLang ->
        RightSpindle_ShelfSigLang ->
        RightSpindle_ShelfSigLang
    data RightSpindle_ShelfSigOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        RightSpindle_ShelfSigOpenLang
      <|OL :
        RightSpindle_ShelfSigOpenLang ->
        RightSpindle_ShelfSigOpenLang ->
        RightSpindle_ShelfSigOpenLang
      |>OL :
        RightSpindle_ShelfSigOpenLang ->
        RightSpindle_ShelfSigOpenLang ->
        RightSpindle_ShelfSigOpenLang
  
  module RightUnital where
    record RightUnital
      (A : Set) : Set where
      constructor RightUnitalC
      field
        e : A
        op : A -> A -> A
        runit_e : (x : A) -> op x e == x
    record RightUnitalSig
      (AS : Set) : Set where
      constructor RightUnitalSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record RightUnitalProd
      (AP : Set) : Set where
      constructor RightUnitalProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
    record RightUnitalHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightUnital A1)
      (Ri2 : RightUnital A2) :
      Set where
      constructor RightUnitalHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Ri1) == e Ri2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record RightUnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightUnital A1)
      (Ri2 : RightUnital A2) :
      Set where
      constructor RightUnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Ri1) (e Ri2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data RightUnitalLang : Set where
      eL : RightUnitalLang
      opL :
        RightUnitalLang ->
        RightUnitalLang ->
        RightUnitalLang
    data RightUnitalOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> RightUnitalOpenLang
      eOL : RightUnitalOpenLang
      opOL :
        RightUnitalOpenLang ->
        RightUnitalOpenLang ->
        RightUnitalOpenLang
  
  module RightZero where
    record RightZero
      (A : Set) : Set where
      constructor RightZeroC
      field
        e : A
        op : A -> A -> A
        rightZero_op_e :
          (x : A) -> op x e == e
    record RightZeroSig
      (AS : Set) : Set where
      constructor RightZeroSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record RightZeroProd
      (AP : Set) : Set where
      constructor RightZeroProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightZero_op_eP :
          (xP : Prod AP AP) ->
          opP xP eP == eP
    record RightZeroHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightZero A1)
      (Ri2 : RightZero A2) : Set where
      constructor RightZeroHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Ri1) == e Ri2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record RightZeroRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightZero A1)
      (Ri2 : RightZero A2) : Set where
      constructor RightZeroRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Ri1) (e Ri2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data RightZeroLang : Set where
      eL : RightZeroLang
      opL :
        RightZeroLang ->
        RightZeroLang -> RightZeroLang
    data RightZeroOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> RightZeroOpenLang
      eOL : RightZeroOpenLang
      opOL :
        RightZeroOpenLang ->
        RightZeroOpenLang ->
        RightZeroOpenLang
  
  module Ring where
    record Ring
      (A : Set) : Set where
      constructor RingC
      field
        * : A -> A -> A
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
    record RingSig
      (AS : Set) : Set where
      constructor RingSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
        1S : AS
    record RingProd
      (AP : Set) : Set where
      constructor RingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
    record RingHom
      (A1 : Set) (A2 : Set)
      (Ri1 : Ring A1)
      (Ri2 : Ring A2) : Set where
      constructor RingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
        pres-0 : hom (0 Ri1) == 0 Ri2
        pres-neg :
          (x1 : A1) ->
          hom (neg Ri1 x1) ==
            neg Ri2 (hom x1)
        pres-1 : hom (1 Ri1) == 1 Ri2
    record RingRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Ring A1)
      (Ri2 : Ring A2) : Set where
      constructor RingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
        interp-0 :
          interp (0 Ri1) (0 Ri2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Ri1 x1) (neg Ri2 y1)
        interp-1 :
          interp (1 Ri1) (1 Ri2)
    data RingLang : Set where
      *L :
        RingLang -> RingLang -> RingLang
      +L :
        RingLang -> RingLang -> RingLang
      0L : RingLang
      negL : RingLang -> RingLang
      1L : RingLang
    data RingOpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> RingOpenLang
      *OL :
        RingOpenLang ->
        RingOpenLang -> RingOpenLang
      +OL :
        RingOpenLang ->
        RingOpenLang -> RingOpenLang
      0OL : RingOpenLang
      negOL :
        RingOpenLang -> RingOpenLang
      1OL : RingOpenLang
  
  module Ringoid where
    record Ringoid
      (A : Set) : Set where
      constructor RingoidC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record RingoidSig
      (AS : Set) : Set where
      constructor RingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record RingoidProd
      (AP : Set) : Set where
      constructor RingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record RingoidHom
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid A1)
      (Ri2 : Ringoid A2) : Set where
      constructor RingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
    record RingoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid A1)
      (Ri2 : Ringoid A2) : Set where
      constructor RingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
    data RingoidLang : Set where
      *L :
        RingoidLang ->
        RingoidLang -> RingoidLang
      +L :
        RingoidLang ->
        RingoidLang -> RingoidLang
    data RingoidOpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> RingoidOpenLang
      *OL :
        RingoidOpenLang ->
        RingoidOpenLang ->
        RingoidOpenLang
      +OL :
        RingoidOpenLang ->
        RingoidOpenLang ->
        RingoidOpenLang
  
  module Ringoid01Sig where
    record Ringoid01Sig
      (A : Set) : Set where
      constructor Ringoid01SigC
      field
        * : A -> A -> A
        + : A -> A -> A
        0 : A
        1 : A
    record Ringoid01SigSig
      (AS : Set) : Set where
      constructor Ringoid01SigSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        1S : AS
    record Ringoid01SigProd
      (AP : Set) : Set where
      constructor Ringoid01SigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        1P : Prod AP AP
    record Ringoid01SigHom
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid01Sig A1)
      (Ri2 : Ringoid01Sig A2) :
      Set where
      constructor Ringoid01SigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
        pres-0 : hom (0 Ri1) == 0 Ri2
        pres-1 : hom (1 Ri1) == 1 Ri2
    record Ringoid01SigRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid01Sig A1)
      (Ri2 : Ringoid01Sig A2) :
      Set where
      constructor Ringoid01SigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
        interp-0 :
          interp (0 Ri1) (0 Ri2)
        interp-1 :
          interp (1 Ri1) (1 Ri2)
    data Ringoid01SigLang
      : Set where
      *L :
        Ringoid01SigLang ->
        Ringoid01SigLang ->
        Ringoid01SigLang
      +L :
        Ringoid01SigLang ->
        Ringoid01SigLang ->
        Ringoid01SigLang
      0L : Ringoid01SigLang
      1L : Ringoid01SigLang
    data Ringoid01SigOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> Ringoid01SigOpenLang
      *OL :
        Ringoid01SigOpenLang ->
        Ringoid01SigOpenLang ->
        Ringoid01SigOpenLang
      +OL :
        Ringoid01SigOpenLang ->
        Ringoid01SigOpenLang ->
        Ringoid01SigOpenLang
      0OL : Ringoid01SigOpenLang
      1OL : Ringoid01SigOpenLang
  
  module Ringoid0Sig where
    record Ringoid0Sig
      (A : Set) : Set where
      constructor Ringoid0SigC
      field
        0 : A
        + : A -> A -> A
        * : A -> A -> A
    record Ringoid0SigSig
      (AS : Set) : Set where
      constructor Ringoid0SigSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
    record Ringoid0SigProd
      (AP : Set) : Set where
      constructor Ringoid0SigProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record Ringoid0SigHom
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid0Sig A1)
      (Ri2 : Ringoid0Sig A2) :
      Set where
      constructor Ringoid0SigHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ri1) == 0 Ri2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
    record Ringoid0SigRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid0Sig A1)
      (Ri2 : Ringoid0Sig A2) :
      Set where
      constructor Ringoid0SigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ri1) (0 Ri2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
    data Ringoid0SigLang : Set where
      0L : Ringoid0SigLang
      +L :
        Ringoid0SigLang ->
        Ringoid0SigLang ->
        Ringoid0SigLang
      *L :
        Ringoid0SigLang ->
        Ringoid0SigLang ->
        Ringoid0SigLang
    data Ringoid0SigOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> Ringoid0SigOpenLang
      0OL : Ringoid0SigOpenLang
      +OL :
        Ringoid0SigOpenLang ->
        Ringoid0SigOpenLang ->
        Ringoid0SigOpenLang
      *OL :
        Ringoid0SigOpenLang ->
        Ringoid0SigOpenLang ->
        Ringoid0SigOpenLang
  
  module Ringoid1 where
    record Ringoid1
      (A : Set) : Set where
      constructor Ringoid1C
      field
        * : A -> A -> A
        + : A -> A -> A
        1 : A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record Ringoid1Sig
      (AS : Set) : Set where
      constructor Ringoid1SigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        1S : AS
    record Ringoid1Prod
      (AP : Set) : Set where
      constructor Ringoid1ProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record Ringoid1Hom
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid1 A1)
      (Ri2 : Ringoid1 A2) : Set where
      constructor Ringoid1HomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
        pres-1 : hom (1 Ri1) == 1 Ri2
    record Ringoid1RelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid1 A1)
      (Ri2 : Ringoid1 A2) : Set where
      constructor Ringoid1RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
        interp-1 :
          interp (1 Ri1) (1 Ri2)
    data Ringoid1Lang : Set where
      *L :
        Ringoid1Lang ->
        Ringoid1Lang -> Ringoid1Lang
      +L :
        Ringoid1Lang ->
        Ringoid1Lang -> Ringoid1Lang
      1L : Ringoid1Lang
    data Ringoid1OpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> Ringoid1OpenLang
      *OL :
        Ringoid1OpenLang ->
        Ringoid1OpenLang ->
        Ringoid1OpenLang
      +OL :
        Ringoid1OpenLang ->
        Ringoid1OpenLang ->
        Ringoid1OpenLang
      1OL : Ringoid1OpenLang
  
  module Ringoid1Sig where
    record Ringoid1Sig
      (A : Set) : Set where
      constructor Ringoid1SigC
      field
        * : A -> A -> A
        1 : A
        + : A -> A -> A
    record Ringoid1SigSig
      (AS : Set) : Set where
      constructor Ringoid1SigSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
        +S : AS -> AS -> AS
    record Ringoid1SigProd
      (AP : Set) : Set where
      constructor Ringoid1SigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record Ringoid1SigHom
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid1Sig A1)
      (Ri2 : Ringoid1Sig A2) :
      Set where
      constructor Ringoid1SigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-1 : hom (1 Ri1) == 1 Ri2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
    record Ringoid1SigRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid1Sig A1)
      (Ri2 : Ringoid1Sig A2) :
      Set where
      constructor Ringoid1SigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-1 :
          interp (1 Ri1) (1 Ri2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
    data Ringoid1SigLang : Set where
      *L :
        Ringoid1SigLang ->
        Ringoid1SigLang ->
        Ringoid1SigLang
      1L : Ringoid1SigLang
      +L :
        Ringoid1SigLang ->
        Ringoid1SigLang ->
        Ringoid1SigLang
    data Ringoid1SigOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> Ringoid1SigOpenLang
      *OL :
        Ringoid1SigOpenLang ->
        Ringoid1SigOpenLang ->
        Ringoid1SigOpenLang
      1OL : Ringoid1SigOpenLang
      +OL :
        Ringoid1SigOpenLang ->
        Ringoid1SigOpenLang ->
        Ringoid1SigOpenLang
  
  module RingoidSig where
    record RingoidSig
      (A : Set) : Set where
      constructor RingoidSigC
      field
        * : A -> A -> A
        + : A -> A -> A
    record RingoidSigSig
      (AS : Set) : Set where
      constructor RingoidSigSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record RingoidSigProd
      (AP : Set) : Set where
      constructor RingoidSigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record RingoidSigHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidSig A1)
      (Ri2 : RingoidSig A2) :
      Set where
      constructor RingoidSigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
    record RingoidSigRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidSig A1)
      (Ri2 : RingoidSig A2) :
      Set where
      constructor RingoidSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
    data RingoidSigLang : Set where
      *L :
        RingoidSigLang ->
        RingoidSigLang -> RingoidSigLang
      +L :
        RingoidSigLang ->
        RingoidSigLang -> RingoidSigLang
    data RingoidSigOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> RingoidSigOpenLang
      *OL :
        RingoidSigOpenLang ->
        RingoidSigOpenLang ->
        RingoidSigOpenLang
      +OL :
        RingoidSigOpenLang ->
        RingoidSigOpenLang ->
        RingoidSigOpenLang
  
  module RingoidWithAddAntiDistrib where
    record RingoidWithAddAntiDistrib
      (A : Set) : Set where
      constructor RingoidWithAddAntiDistribC
      field
        + : A -> A -> A
        prim : A -> A
        antidis_prim_+ :
          (x : A) (y : A) ->
          prim (+ x y) ==
            + (prim y) (prim x)
        * : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record RingoidWithAddAntiDistribSig
      (AS : Set) : Set where
      constructor RingoidWithAddAntiDistribSigSigC
      field
        +S : AS -> AS -> AS
        primS : AS -> AS
        *S : AS -> AS -> AS
    record RingoidWithAddAntiDistribProd
      (AP : Set) : Set where
      constructor RingoidWithAddAntiDistribProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        antidis_prim_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (+P xP yP) ==
            +P (primP yP) (primP xP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record RingoidWithAddAntiDistribHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidWithAddAntiDistrib
         A1)
      (Ri2 : RingoidWithAddAntiDistrib
         A2) : Set where
      constructor RingoidWithAddAntiDistribHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Ri1 x1) ==
            prim Ri2 (hom x1)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
    record RingoidWithAddAntiDistribRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidWithAddAntiDistrib
         A1)
      (Ri2 : RingoidWithAddAntiDistrib
         A2) : Set where
      constructor RingoidWithAddAntiDistribRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Ri1 x1)
            (prim Ri2 y1)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
    data RingoidWithAddAntiDistribLang
      : Set where
      +L :
        RingoidWithAddAntiDistribLang ->
        RingoidWithAddAntiDistribLang ->
        RingoidWithAddAntiDistribLang
      primL :
        RingoidWithAddAntiDistribLang ->
        RingoidWithAddAntiDistribLang
      *L :
        RingoidWithAddAntiDistribLang ->
        RingoidWithAddAntiDistribLang ->
        RingoidWithAddAntiDistribLang
    data RingoidWithAddAntiDistribOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        RingoidWithAddAntiDistribOpenLang
      +OL :
        RingoidWithAddAntiDistribOpenLang ->
        RingoidWithAddAntiDistribOpenLang ->
        RingoidWithAddAntiDistribOpenLang
      primOL :
        RingoidWithAddAntiDistribOpenLang ->
        RingoidWithAddAntiDistribOpenLang
      *OL :
        RingoidWithAddAntiDistribOpenLang ->
        RingoidWithAddAntiDistribOpenLang ->
        RingoidWithAddAntiDistribOpenLang
  
  module RingoidWithInvolution where
    record RingoidWithInvolution
      (A : Set) : Set where
      constructor RingoidWithInvolutionC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        prim : A -> A
    record RingoidWithInvolutionSig
      (AS : Set) : Set where
      constructor RingoidWithInvolutionSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        primS : AS -> AS
    record RingoidWithInvolutionProd
      (AP : Set) : Set where
      constructor RingoidWithInvolutionProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record RingoidWithInvolutionHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidWithInvolution A1)
      (Ri2 : RingoidWithInvolution
         A2) : Set where
      constructor RingoidWithInvolutionHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Ri1 x1) ==
            prim Ri2 (hom x1)
    record RingoidWithInvolutionRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidWithInvolution A1)
      (Ri2 : RingoidWithInvolution
         A2) : Set where
      constructor RingoidWithInvolutionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Ri1 x1)
            (prim Ri2 y1)
    data RingoidWithInvolutionLang
      : Set where
      *L :
        RingoidWithInvolutionLang ->
        RingoidWithInvolutionLang ->
        RingoidWithInvolutionLang
      +L :
        RingoidWithInvolutionLang ->
        RingoidWithInvolutionLang ->
        RingoidWithInvolutionLang
      primL :
        RingoidWithInvolutionLang ->
        RingoidWithInvolutionLang
    data RingoidWithInvolutionOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        RingoidWithInvolutionOpenLang
      *OL :
        RingoidWithInvolutionOpenLang ->
        RingoidWithInvolutionOpenLang ->
        RingoidWithInvolutionOpenLang
      +OL :
        RingoidWithInvolutionOpenLang ->
        RingoidWithInvolutionOpenLang ->
        RingoidWithInvolutionOpenLang
      primOL :
        RingoidWithInvolutionOpenLang ->
        RingoidWithInvolutionOpenLang
  
  module RingoidWithMultAntiDistrib where
    record RingoidWithMultAntiDistrib
      (A : Set) : Set where
      constructor RingoidWithMultAntiDistribC
      field
        * : A -> A -> A
        prim : A -> A
        antidis_prim_* :
          (x : A) (y : A) ->
          prim (* x y) ==
            * (prim y) (prim x)
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record RingoidWithMultAntiDistribSig
      (AS : Set) : Set where
      constructor RingoidWithMultAntiDistribSigSigC
      field
        *S : AS -> AS -> AS
        primS : AS -> AS
        +S : AS -> AS -> AS
    record RingoidWithMultAntiDistribProd
      (AP : Set) : Set where
      constructor RingoidWithMultAntiDistribProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        antidis_prim_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (*P xP yP) ==
            *P (primP yP) (primP xP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record RingoidWithMultAntiDistribHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidWithMultAntiDistrib
         A1)
      (Ri2 : RingoidWithMultAntiDistrib
         A2) : Set where
      constructor RingoidWithMultAntiDistribHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Ri1 x1) ==
            prim Ri2 (hom x1)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
    record RingoidWithMultAntiDistribRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidWithMultAntiDistrib
         A1)
      (Ri2 : RingoidWithMultAntiDistrib
         A2) : Set where
      constructor RingoidWithMultAntiDistribRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Ri1 x1)
            (prim Ri2 y1)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
    data RingoidWithMultAntiDistribLang
      : Set where
      *L :
        RingoidWithMultAntiDistribLang ->
        RingoidWithMultAntiDistribLang ->
        RingoidWithMultAntiDistribLang
      primL :
        RingoidWithMultAntiDistribLang ->
        RingoidWithMultAntiDistribLang
      +L :
        RingoidWithMultAntiDistribLang ->
        RingoidWithMultAntiDistribLang ->
        RingoidWithMultAntiDistribLang
    data RingoidWithMultAntiDistribOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        RingoidWithMultAntiDistribOpenLang
      *OL :
        RingoidWithMultAntiDistribOpenLang ->
        RingoidWithMultAntiDistribOpenLang ->
        RingoidWithMultAntiDistribOpenLang
      primOL :
        RingoidWithMultAntiDistribOpenLang ->
        RingoidWithMultAntiDistribOpenLang
      +OL :
        RingoidWithMultAntiDistribOpenLang ->
        RingoidWithMultAntiDistribOpenLang ->
        RingoidWithMultAntiDistribOpenLang
  
  module Rng where
    record Rng (A : Set) : Set where
      constructor RngC
      field
        0 : A
        + : A -> A -> A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record RngSig
      (AS : Set) : Set where
      constructor RngSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        negS : AS -> AS
        *S : AS -> AS -> AS
    record RngProd
      (AP : Set) : Set where
      constructor RngProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record RngHom
      (A1 : Set) (A2 : Set)
      (Rn1 : Rng A1)
      (Rn2 : Rng A2) : Set where
      constructor RngHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Rn1) == 0 Rn2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Rn1 x1 x2) ==
            + Rn2 (hom x1) (hom x2)
        pres-neg :
          (x1 : A1) ->
          hom (neg Rn1 x1) ==
            neg Rn2 (hom x1)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Rn1 x1 x2) ==
            * Rn2 (hom x1) (hom x2)
    record RngRelInterp
      (A1 : Set) (A2 : Set)
      (Rn1 : Rng A1)
      (Rn2 : Rng A2) : Set where
      constructor RngRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Rn1) (0 Rn2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Rn1 x1 x2)
            (+ Rn2 y1 y2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Rn1 x1) (neg Rn2 y1)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Rn1 x1 x2)
            (* Rn2 y1 y2)
    data RngLang : Set where
      0L : RngLang
      +L :
        RngLang -> RngLang -> RngLang
      negL : RngLang -> RngLang
      *L :
        RngLang -> RngLang -> RngLang
    data RngOpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> RngOpenLang
      0OL : RngOpenLang
      +OL :
        RngOpenLang ->
        RngOpenLang -> RngOpenLang
      negOL :
        RngOpenLang -> RngOpenLang
      *OL :
        RngOpenLang ->
        RngOpenLang -> RngOpenLang
  
  module SemiRng where
    record SemiRng
      (A : Set) : Set where
      constructor SemiRngC
      field
        * : A -> A -> A
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record SemiRngSig
      (AS : Set) : Set where
      constructor SemiRngSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
    record SemiRngProd
      (AP : Set) : Set where
      constructor SemiRngProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record SemiRngHom
      (A1 : Set) (A2 : Set)
      (Se1 : SemiRng A1)
      (Se2 : SemiRng A2) : Set where
      constructor SemiRngHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Se1 x1 x2) ==
            * Se2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Se1 x1 x2) ==
            + Se2 (hom x1) (hom x2)
        pres-0 : hom (0 Se1) == 0 Se2
    record SemiRngRelInterp
      (A1 : Set) (A2 : Set)
      (Se1 : SemiRng A1)
      (Se2 : SemiRng A2) : Set where
      constructor SemiRngRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Se1 x1 x2)
            (* Se2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Se1 x1 x2)
            (+ Se2 y1 y2)
        interp-0 :
          interp (0 Se1) (0 Se2)
    data SemiRngLang : Set where
      *L :
        SemiRngLang ->
        SemiRngLang -> SemiRngLang
      +L :
        SemiRngLang ->
        SemiRngLang -> SemiRngLang
      0L : SemiRngLang
    data SemiRngOpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> SemiRngOpenLang
      *OL :
        SemiRngOpenLang ->
        SemiRngOpenLang ->
        SemiRngOpenLang
      +OL :
        SemiRngOpenLang ->
        SemiRngOpenLang ->
        SemiRngOpenLang
      0OL : SemiRngOpenLang
  
  module SemiRngWithUnit where
    record SemiRngWithUnit
      (A : Set) : Set where
      constructor SemiRngWithUnitC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record SemiRngWithUnitSig
      (AS : Set) : Set where
      constructor SemiRngWithUnitSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
        +S : AS -> AS -> AS
        0S : AS
    record SemiRngWithUnitProd
      (AP : Set) : Set where
      constructor SemiRngWithUnitProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record SemiRngWithUnitHom
      (A1 : Set) (A2 : Set)
      (Se1 : SemiRngWithUnit A1)
      (Se2 : SemiRngWithUnit A2) :
      Set where
      constructor SemiRngWithUnitHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Se1 x1 x2) ==
            * Se2 (hom x1) (hom x2)
        pres-1 : hom (1 Se1) == 1 Se2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Se1 x1 x2) ==
            + Se2 (hom x1) (hom x2)
        pres-0 : hom (0 Se1) == 0 Se2
    record SemiRngWithUnitRelInterp
      (A1 : Set) (A2 : Set)
      (Se1 : SemiRngWithUnit A1)
      (Se2 : SemiRngWithUnit A2) :
      Set where
      constructor SemiRngWithUnitRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Se1 x1 x2)
            (* Se2 y1 y2)
        interp-1 :
          interp (1 Se1) (1 Se2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Se1 x1 x2)
            (+ Se2 y1 y2)
        interp-0 :
          interp (0 Se1) (0 Se2)
    data SemiRngWithUnitLang
      : Set where
      *L :
        SemiRngWithUnitLang ->
        SemiRngWithUnitLang ->
        SemiRngWithUnitLang
      1L : SemiRngWithUnitLang
      +L :
        SemiRngWithUnitLang ->
        SemiRngWithUnitLang ->
        SemiRngWithUnitLang
      0L : SemiRngWithUnitLang
    data SemiRngWithUnitOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> SemiRngWithUnitOpenLang
      *OL :
        SemiRngWithUnitOpenLang ->
        SemiRngWithUnitOpenLang ->
        SemiRngWithUnitOpenLang
      1OL : SemiRngWithUnitOpenLang
      +OL :
        SemiRngWithUnitOpenLang ->
        SemiRngWithUnitOpenLang ->
        SemiRngWithUnitOpenLang
      0OL : SemiRngWithUnitOpenLang
  
  module Semigroup where
    record Semigroup
      (A : Set) : Set where
      constructor SemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record SemigroupSig
      (AS : Set) : Set where
      constructor SemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record SemigroupProd
      (AP : Set) : Set where
      constructor SemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record SemigroupHom
      (A1 : Set) (A2 : Set)
      (Se1 : Semigroup A1)
      (Se2 : Semigroup A2) : Set where
      constructor SemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Se1 x1 x2) ==
            op Se2 (hom x1) (hom x2)
    record SemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Se1 : Semigroup A1)
      (Se2 : Semigroup A2) : Set where
      constructor SemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Se1 x1 x2)
            (op Se2 y1 y2)
    data SemigroupLang : Set where
      opL :
        SemigroupLang ->
        SemigroupLang -> SemigroupLang
    data SemigroupOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> SemigroupOpenLang
      opOL :
        SemigroupOpenLang ->
        SemigroupOpenLang ->
        SemigroupOpenLang
  
  module Semiring where
    record Semiring
      (A : Set) : Set where
      constructor SemiringC
      field
        0 : A
        + : A -> A -> A
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
    record SemiringSig
      (AS : Set) : Set where
      constructor SemiringSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
        1S : AS
    record SemiringProd
      (AP : Set) : Set where
      constructor SemiringProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
    record SemiringHom
      (A1 : Set) (A2 : Set)
      (Se1 : Semiring A1)
      (Se2 : Semiring A2) : Set where
      constructor SemiringHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Se1) == 0 Se2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Se1 x1 x2) ==
            + Se2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Se1 x1 x2) ==
            * Se2 (hom x1) (hom x2)
        pres-1 : hom (1 Se1) == 1 Se2
    record SemiringRelInterp
      (A1 : Set) (A2 : Set)
      (Se1 : Semiring A1)
      (Se2 : Semiring A2) : Set where
      constructor SemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Se1) (0 Se2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Se1 x1 x2)
            (+ Se2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Se1 x1 x2)
            (* Se2 y1 y2)
        interp-1 :
          interp (1 Se1) (1 Se2)
    data SemiringLang : Set where
      0L : SemiringLang
      +L :
        SemiringLang ->
        SemiringLang -> SemiringLang
      *L :
        SemiringLang ->
        SemiringLang -> SemiringLang
      1L : SemiringLang
    data SemiringOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> SemiringOpenLang
      0OL : SemiringOpenLang
      +OL :
        SemiringOpenLang ->
        SemiringOpenLang ->
        SemiringOpenLang
      *OL :
        SemiringOpenLang ->
        SemiringOpenLang ->
        SemiringOpenLang
      1OL : SemiringOpenLang
  
  module Shelf where
    record Shelf
      (A : Set) : Set where
      constructor ShelfC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
    record ShelfSig
      (AS : Set) : Set where
      constructor ShelfSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record ShelfProd
      (AP : Set) : Set where
      constructor ShelfProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
    record ShelfHom
      (A1 : Set) (A2 : Set)
      (Sh1 : Shelf A1)
      (Sh2 : Shelf A2) : Set where
      constructor ShelfHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Sh1 x1 x2) ==
            |> Sh2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Sh1 x1 x2) ==
            <| Sh2 (hom x1) (hom x2)
    record ShelfRelInterp
      (A1 : Set) (A2 : Set)
      (Sh1 : Shelf A1)
      (Sh2 : Shelf A2) : Set where
      constructor ShelfRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Sh1 x1 x2)
            (|> Sh2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Sh1 x1 x2)
            (<| Sh2 y1 y2)
    data ShelfLang : Set where
      |>L :
        ShelfLang ->
        ShelfLang -> ShelfLang
      <|L :
        ShelfLang ->
        ShelfLang -> ShelfLang
    data ShelfOpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> ShelfOpenLang
      |>OL :
        ShelfOpenLang ->
        ShelfOpenLang -> ShelfOpenLang
      <|OL :
        ShelfOpenLang ->
        ShelfOpenLang -> ShelfOpenLang
  
  module ShelfSig where
    record ShelfSig
      (A : Set) : Set where
      constructor ShelfSigC
      field
        |> : A -> A -> A
        <| : A -> A -> A
    record ShelfSigSig
      (AS : Set) : Set where
      constructor ShelfSigSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record ShelfSigProd
      (AP : Set) : Set where
      constructor ShelfSigProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record ShelfSigHom
      (A1 : Set) (A2 : Set)
      (Sh1 : ShelfSig A1)
      (Sh2 : ShelfSig A2) : Set where
      constructor ShelfSigHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Sh1 x1 x2) ==
            |> Sh2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Sh1 x1 x2) ==
            <| Sh2 (hom x1) (hom x2)
    record ShelfSigRelInterp
      (A1 : Set) (A2 : Set)
      (Sh1 : ShelfSig A1)
      (Sh2 : ShelfSig A2) : Set where
      constructor ShelfSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Sh1 x1 x2)
            (|> Sh2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Sh1 x1 x2)
            (<| Sh2 y1 y2)
    data ShelfSigLang : Set where
      |>L :
        ShelfSigLang ->
        ShelfSigLang -> ShelfSigLang
      <|L :
        ShelfSigLang ->
        ShelfSigLang -> ShelfSigLang
    data ShelfSigOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> ShelfSigOpenLang
      |>OL :
        ShelfSigOpenLang ->
        ShelfSigOpenLang ->
        ShelfSigOpenLang
      <|OL :
        ShelfSigOpenLang ->
        ShelfSigOpenLang ->
        ShelfSigOpenLang
  
  module Sloop where
    record Sloop
      (A : Set) : Set where
      constructor SloopC
      field
        e : A
        op : A -> A -> A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
        antiAbsorbent :
          (x : A) (y : A) ->
          op x (op x y) == y
        unipotence :
          (x : A) -> op x x == e
    record SloopSig
      (AS : Set) : Set where
      constructor SloopSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record SloopProd
      (AP : Set) : Set where
      constructor SloopProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
        antiAbsorbentP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (opP xP yP) == yP
        unipotenceP :
          (xP : Prod AP AP) ->
          opP xP xP == eP
    record SloopHom
      (A1 : Set) (A2 : Set)
      (Sl1 : Sloop A1)
      (Sl2 : Sloop A2) : Set where
      constructor SloopHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Sl1) == e Sl2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Sl1 x1 x2) ==
            op Sl2 (hom x1) (hom x2)
    record SloopRelInterp
      (A1 : Set) (A2 : Set)
      (Sl1 : Sloop A1)
      (Sl2 : Sloop A2) : Set where
      constructor SloopRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Sl1) (e Sl2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Sl1 x1 x2)
            (op Sl2 y1 y2)
    data SloopLang : Set where
      eL : SloopLang
      opL :
        SloopLang ->
        SloopLang -> SloopLang
    data SloopOpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> SloopOpenLang
      eOL : SloopOpenLang
      opOL :
        SloopOpenLang ->
        SloopOpenLang -> SloopOpenLang
  
  module Spindle where
    record Spindle
      (A : Set) : Set where
      constructor SpindleC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
        idempotent_|> :
          (x : A) -> |> x x == x
        idempotent_<| :
          (x : A) -> <| x x == x
    record SpindleSig
      (AS : Set) : Set where
      constructor SpindleSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record SpindleProd
      (AP : Set) : Set where
      constructor SpindleProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
        idempotent_<|P :
          (xP : Prod AP AP) ->
          <|P xP xP == xP
    record SpindleHom
      (A1 : Set) (A2 : Set)
      (Sp1 : Spindle A1)
      (Sp2 : Spindle A2) : Set where
      constructor SpindleHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Sp1 x1 x2) ==
            |> Sp2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Sp1 x1 x2) ==
            <| Sp2 (hom x1) (hom x2)
    record SpindleRelInterp
      (A1 : Set) (A2 : Set)
      (Sp1 : Spindle A1)
      (Sp2 : Spindle A2) : Set where
      constructor SpindleRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Sp1 x1 x2)
            (|> Sp2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Sp1 x1 x2)
            (<| Sp2 y1 y2)
    data SpindleLang : Set where
      |>L :
        SpindleLang ->
        SpindleLang -> SpindleLang
      <|L :
        SpindleLang ->
        SpindleLang -> SpindleLang
    data SpindleOpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> SpindleOpenLang
      |>OL :
        SpindleOpenLang ->
        SpindleOpenLang ->
        SpindleOpenLang
      <|OL :
        SpindleOpenLang ->
        SpindleOpenLang ->
        SpindleOpenLang
  
  module Squag where
    record Squag
      (A : Set) : Set where
      constructor SquagC
      field
        op : A -> A -> A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
        antiAbsorbent :
          (x : A) (y : A) ->
          op x (op x y) == y
        idempotent_op :
          (x : A) -> op x x == x
    record SquagSig
      (AS : Set) : Set where
      constructor SquagSigSigC
      field
        opS : AS -> AS -> AS
    record SquagProd
      (AP : Set) : Set where
      constructor SquagProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
        antiAbsorbentP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (opP xP yP) == yP
        idempotent_opP :
          (xP : Prod AP AP) ->
          opP xP xP == xP
    record SquagHom
      (A1 : Set) (A2 : Set)
      (Sq1 : Squag A1)
      (Sq2 : Squag A2) : Set where
      constructor SquagHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Sq1 x1 x2) ==
            op Sq2 (hom x1) (hom x2)
    record SquagRelInterp
      (A1 : Set) (A2 : Set)
      (Sq1 : Squag A1)
      (Sq2 : Squag A2) : Set where
      constructor SquagRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Sq1 x1 x2)
            (op Sq2 y1 y2)
    data SquagLang : Set where
      opL :
        SquagLang ->
        SquagLang -> SquagLang
    data SquagOpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> SquagOpenLang
      opOL :
        SquagOpenLang ->
        SquagOpenLang -> SquagOpenLang
  
  module SteinerMagma where
    record SteinerMagma
      (A : Set) : Set where
      constructor SteinerMagmaC
      field
        op : A -> A -> A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
        antiAbsorbent :
          (x : A) (y : A) ->
          op x (op x y) == y
    record SteinerMagmaSig
      (AS : Set) : Set where
      constructor SteinerMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record SteinerMagmaProd
      (AP : Set) : Set where
      constructor SteinerMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
        antiAbsorbentP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (opP xP yP) == yP
    record SteinerMagmaHom
      (A1 : Set) (A2 : Set)
      (St1 : SteinerMagma A1)
      (St2 : SteinerMagma A2) :
      Set where
      constructor SteinerMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op St1 x1 x2) ==
            op St2 (hom x1) (hom x2)
    record SteinerMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (St1 : SteinerMagma A1)
      (St2 : SteinerMagma A2) :
      Set where
      constructor SteinerMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op St1 x1 x2)
            (op St2 y1 y2)
    data SteinerMagmaLang
      : Set where
      opL :
        SteinerMagmaLang ->
        SteinerMagmaLang ->
        SteinerMagmaLang
    data SteinerMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> SteinerMagmaOpenLang
      opOL :
        SteinerMagmaOpenLang ->
        SteinerMagmaOpenLang ->
        SteinerMagmaOpenLang
  
  module TwoPointed where
    record TwoPointed
      (A : Set) : Set where
      constructor TwoPointedC
      field
        e1 : A
        e2 : A
    record TwoPointedSig
      (AS : Set) : Set where
      constructor TwoPointedSigSigC
      field
        e1S : AS
        e2S : AS
    record TwoPointedProd
      (AP : Set) : Set where
      constructor TwoPointedProdC
      field
        e1P : Prod AP AP
        e2P : Prod AP AP
    record TwoPointedHom
      (A1 : Set) (A2 : Set)
      (Tw1 : TwoPointed A1)
      (Tw2 : TwoPointed A2) :
      Set where
      constructor TwoPointedHomC
      field
        hom : A1 -> A2
        pres-e1 : hom (e1 Tw1) == e1 Tw2
        pres-e2 : hom (e2 Tw1) == e2 Tw2
    record TwoPointedRelInterp
      (A1 : Set) (A2 : Set)
      (Tw1 : TwoPointed A1)
      (Tw2 : TwoPointed A2) :
      Set where
      constructor TwoPointedRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e1 :
          interp (e1 Tw1) (e1 Tw2)
        interp-e2 :
          interp (e2 Tw1) (e2 Tw2)
    data TwoPointedLang : Set where
      e1L : TwoPointedLang
      e2L : TwoPointedLang
    data TwoPointedOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> TwoPointedOpenLang
      e1OL : TwoPointedOpenLang
      e2OL : TwoPointedOpenLang
  
  module TwoPointed01 where
    record TwoPointed01
      (A : Set) : Set where
      constructor TwoPointed01C
      field
        e1 : A
        e2 : A
    record TwoPointed01Sig
      (AS : Set) : Set where
      constructor TwoPointed01SigSigC
      field
        e1S : AS
        e2S : AS
    record TwoPointed01Prod
      (AP : Set) : Set where
      constructor TwoPointed01ProdC
      field
        e1P : Prod AP AP
        e2P : Prod AP AP
    record TwoPointed01Hom
      (A1 : Set) (A2 : Set)
      (Tw1 : TwoPointed01 A1)
      (Tw2 : TwoPointed01 A2) :
      Set where
      constructor TwoPointed01HomC
      field
        hom : A1 -> A2
        pres-e1 : hom (e1 Tw1) == e1 Tw2
        pres-e2 : hom (e2 Tw1) == e2 Tw2
    record TwoPointed01RelInterp
      (A1 : Set) (A2 : Set)
      (Tw1 : TwoPointed01 A1)
      (Tw2 : TwoPointed01 A2) :
      Set where
      constructor TwoPointed01RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e1 :
          interp (e1 Tw1) (e1 Tw2)
        interp-e2 :
          interp (e2 Tw1) (e2 Tw2)
    data TwoPointed01Lang
      : Set where
      e1L : TwoPointed01Lang
      e2L : TwoPointed01Lang
    data TwoPointed01OpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> TwoPointed01OpenLang
      e1OL : TwoPointed01OpenLang
      e2OL : TwoPointed01OpenLang
  
  module UnaryAntiDistribution where
    record UnaryAntiDistribution
      (A : Set) : Set where
      constructor UnaryAntiDistributionC
      field
        prim : A -> A
        op : A -> A -> A
        antidis_prim_op :
          (x : A) (y : A) ->
          prim (op x y) ==
            op (prim y) (prim x)
    record UnaryAntiDistributionSig
      (AS : Set) : Set where
      constructor UnaryAntiDistributionSigSigC
      field
        primS : AS -> AS
        opS : AS -> AS -> AS
    record UnaryAntiDistributionProd
      (AP : Set) : Set where
      constructor UnaryAntiDistributionProdC
      field
        primP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        antidis_prim_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (opP xP yP) ==
            opP (primP yP) (primP xP)
    record UnaryAntiDistributionHom
      (A1 : Set) (A2 : Set)
      (Un1 : UnaryAntiDistribution A1)
      (Un2 : UnaryAntiDistribution
         A2) : Set where
      constructor UnaryAntiDistributionHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Un1 x1) ==
            prim Un2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Un1 x1 x2) ==
            op Un2 (hom x1) (hom x2)
    record UnaryAntiDistributionRelInterp
      (A1 : Set) (A2 : Set)
      (Un1 : UnaryAntiDistribution A1)
      (Un2 : UnaryAntiDistribution
         A2) : Set where
      constructor UnaryAntiDistributionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Un1 x1)
            (prim Un2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Un1 x1 x2)
            (op Un2 y1 y2)
    data UnaryAntiDistributionLang
      : Set where
      primL :
        UnaryAntiDistributionLang ->
        UnaryAntiDistributionLang
      opL :
        UnaryAntiDistributionLang ->
        UnaryAntiDistributionLang ->
        UnaryAntiDistributionLang
    data UnaryAntiDistributionOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        UnaryAntiDistributionOpenLang
      primOL :
        UnaryAntiDistributionOpenLang ->
        UnaryAntiDistributionOpenLang
      opOL :
        UnaryAntiDistributionOpenLang ->
        UnaryAntiDistributionOpenLang ->
        UnaryAntiDistributionOpenLang
  
  module UnaryDistributes where
    record UnaryDistributes
      (A : Set) : Set where
      constructor UnaryDistributesC
      field
        prim : A -> A
        op : A -> A -> A
        distribute_prim_op :
          (x : A) (y : A) ->
          prim (op x y) ==
            op (prim x) (prim y)
    record UnaryDistributesSig
      (AS : Set) : Set where
      constructor UnaryDistributesSigSigC
      field
        primS : AS -> AS
        opS : AS -> AS -> AS
    record UnaryDistributesProd
      (AP : Set) : Set where
      constructor UnaryDistributesProdC
      field
        primP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        distribute_prim_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (opP xP yP) ==
            opP (primP xP) (primP yP)
    record UnaryDistributesHom
      (A1 : Set) (A2 : Set)
      (Un1 : UnaryDistributes A1)
      (Un2 : UnaryDistributes A2) :
      Set where
      constructor UnaryDistributesHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Un1 x1) ==
            prim Un2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Un1 x1 x2) ==
            op Un2 (hom x1) (hom x2)
    record UnaryDistributesRelInterp
      (A1 : Set) (A2 : Set)
      (Un1 : UnaryDistributes A1)
      (Un2 : UnaryDistributes A2) :
      Set where
      constructor UnaryDistributesRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Un1 x1)
            (prim Un2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Un1 x1 x2)
            (op Un2 y1 y2)
    data UnaryDistributesLang
      : Set where
      primL :
        UnaryDistributesLang ->
        UnaryDistributesLang
      opL :
        UnaryDistributesLang ->
        UnaryDistributesLang ->
        UnaryDistributesLang
    data UnaryDistributesOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        UnaryDistributesOpenLang
      primOL :
        UnaryDistributesOpenLang ->
        UnaryDistributesOpenLang
      opOL :
        UnaryDistributesOpenLang ->
        UnaryDistributesOpenLang ->
        UnaryDistributesOpenLang
  
  module UnaryOperation where
    record UnaryOperation
      (A : Set) : Set where
      constructor UnaryOperationC
      field
        prim : A -> A
    record UnaryOperationSig
      (AS : Set) : Set where
      constructor UnaryOperationSigSigC
      field
        primS : AS -> AS
    record UnaryOperationProd
      (AP : Set) : Set where
      constructor UnaryOperationProdC
      field
        primP : Prod AP AP -> Prod AP AP
    record UnaryOperationHom
      (A1 : Set) (A2 : Set)
      (Un1 : UnaryOperation A1)
      (Un2 : UnaryOperation A2) :
      Set where
      constructor UnaryOperationHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Un1 x1) ==
            prim Un2 (hom x1)
    record UnaryOperationRelInterp
      (A1 : Set) (A2 : Set)
      (Un1 : UnaryOperation A1)
      (Un2 : UnaryOperation A2) :
      Set where
      constructor UnaryOperationRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Un1 x1)
            (prim Un2 y1)
    data UnaryOperationLang
      : Set where
      primL :
        UnaryOperationLang ->
        UnaryOperationLang
    data UnaryOperationOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n -> UnaryOperationOpenLang
      primOL :
        UnaryOperationOpenLang ->
        UnaryOperationOpenLang
  
  module UnipotentPointedMagma where
    record UnipotentPointedMagma
      (A : Set) : Set where
      constructor UnipotentPointedMagmaC
      field
        e : A
        op : A -> A -> A
        unipotence :
          (x : A) -> op x x == e
    record UnipotentPointedMagmaSig
      (AS : Set) : Set where
      constructor UnipotentPointedMagmaSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record UnipotentPointedMagmaProd
      (AP : Set) : Set where
      constructor UnipotentPointedMagmaProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        unipotenceP :
          (xP : Prod AP AP) ->
          opP xP xP == eP
    record UnipotentPointedMagmaHom
      (A1 : Set) (A2 : Set)
      (Un1 : UnipotentPointedMagma A1)
      (Un2 : UnipotentPointedMagma
         A2) : Set where
      constructor UnipotentPointedMagmaHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Un1) == e Un2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Un1 x1 x2) ==
            op Un2 (hom x1) (hom x2)
    record UnipotentPointedMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Un1 : UnipotentPointedMagma A1)
      (Un2 : UnipotentPointedMagma
         A2) : Set where
      constructor UnipotentPointedMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Un1) (e Un2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Un1 x1 x2)
            (op Un2 y1 y2)
    data UnipotentPointedMagmaLang
      : Set where
      eL : UnipotentPointedMagmaLang
      opL :
        UnipotentPointedMagmaLang ->
        UnipotentPointedMagmaLang ->
        UnipotentPointedMagmaLang
    data UnipotentPointedMagmaOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        UnipotentPointedMagmaOpenLang
      eOL :
        UnipotentPointedMagmaOpenLang
      opOL :
        UnipotentPointedMagmaOpenLang ->
        UnipotentPointedMagmaOpenLang ->
        UnipotentPointedMagmaOpenLang
  
  module Unital where
    record Unital
      (A : Set) : Set where
      constructor UnitalC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
    record UnitalSig
      (AS : Set) : Set where
      constructor UnitalSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record UnitalProd
      (AP : Set) : Set where
      constructor UnitalProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
    record UnitalHom
      (A1 : Set) (A2 : Set)
      (Un1 : Unital A1)
      (Un2 : Unital A2) : Set where
      constructor UnitalHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Un1) == e Un2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Un1 x1 x2) ==
            op Un2 (hom x1) (hom x2)
    record UnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Un1 : Unital A1)
      (Un2 : Unital A2) : Set where
      constructor UnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Un1) (e Un2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Un1 x1 x2)
            (op Un2 y1 y2)
    data UnitalLang : Set where
      eL : UnitalLang
      opL :
        UnitalLang ->
        UnitalLang -> UnitalLang
    data UnitalOpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> UnitalOpenLang
      eOL : UnitalOpenLang
      opOL :
        UnitalOpenLang ->
        UnitalOpenLang -> UnitalOpenLang
  
  module Zero where
    record Zero
      (A : Set) : Set where
      constructor ZeroC
      field
        e : A
        op : A -> A -> A
        leftZero_op_e :
          (x : A) -> op e x == e
        rightZero_op_e :
          (x : A) -> op x e == e
    record ZeroSig
      (AS : Set) : Set where
      constructor ZeroSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record ZeroProd
      (AP : Set) : Set where
      constructor ZeroProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftZero_op_eP :
          (xP : Prod AP AP) ->
          opP eP xP == eP
        rightZero_op_eP :
          (xP : Prod AP AP) ->
          opP xP eP == eP
    record ZeroHom
      (A1 : Set) (A2 : Set)
      (Ze1 : Zero A1)
      (Ze2 : Zero A2) : Set where
      constructor ZeroHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Ze1) == e Ze2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ze1 x1 x2) ==
            op Ze2 (hom x1) (hom x2)
    record ZeroRelInterp
      (A1 : Set) (A2 : Set)
      (Ze1 : Zero A1)
      (Ze2 : Zero A2) : Set where
      constructor ZeroRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Ze1) (e Ze2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ze1 x1 x2)
            (op Ze2 y1 y2)
    data ZeroLang : Set where
      eL : ZeroLang
      opL :
        ZeroLang -> ZeroLang -> ZeroLang
    data ZeroOpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> ZeroOpenLang
      eOL : ZeroOpenLang
      opOL :
        ZeroOpenLang ->
        ZeroOpenLang -> ZeroOpenLang
  
  module Zero0 where
    record Zero0
      (A : Set) : Set where
      constructor Zero0C
      field
        0 : A
        * : A -> A -> A
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
    record Zero0Sig
      (AS : Set) : Set where
      constructor Zero0SigSigC
      field
        0S : AS
        *S : AS -> AS -> AS
    record Zero0Prod
      (AP : Set) : Set where
      constructor Zero0ProdC
      field
        0P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
    record Zero0Hom
      (A1 : Set) (A2 : Set)
      (Ze1 : Zero0 A1)
      (Ze2 : Zero0 A2) : Set where
      constructor Zero0HomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ze1) == 0 Ze2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ze1 x1 x2) ==
            * Ze2 (hom x1) (hom x2)
    record Zero0RelInterp
      (A1 : Set) (A2 : Set)
      (Ze1 : Zero0 A1)
      (Ze2 : Zero0 A2) : Set where
      constructor Zero0RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ze1) (0 Ze2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ze1 x1 x2)
            (* Ze2 y1 y2)
    data Zero0Lang : Set where
      0L : Zero0Lang
      *L :
        Zero0Lang ->
        Zero0Lang -> Zero0Lang
    data Zero0OpenLang : Set where
      v :
        (n : Nat) ->
        Fin n -> Zero0OpenLang
      0OL : Zero0OpenLang
      *OL :
        Zero0OpenLang ->
        Zero0OpenLang -> Zero0OpenLang
  
  module Zero_Ringoid0Sig where
    record Zero_Ringoid0Sig
      (A : Set) : Set where
      constructor Zero_Ringoid0SigC
      field
        0 : A
        * : A -> A -> A
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
        + : A -> A -> A
    record Zero_Ringoid0SigSig
      (AS : Set) : Set where
      constructor Zero_Ringoid0SigSigSigC
      field
        0S : AS
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record Zero_Ringoid0SigProd
      (AP : Set) : Set where
      constructor Zero_Ringoid0SigProdC
      field
        0P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
    record Zero_Ringoid0SigHom
      (A1 : Set) (A2 : Set)
      (Ze1 : Zero_Ringoid0Sig A1)
      (Ze2 : Zero_Ringoid0Sig A2) :
      Set where
      constructor Zero_Ringoid0SigHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ze1) == 0 Ze2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ze1 x1 x2) ==
            * Ze2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ze1 x1 x2) ==
            + Ze2 (hom x1) (hom x2)
    record Zero_Ringoid0SigRelInterp
      (A1 : Set) (A2 : Set)
      (Ze1 : Zero_Ringoid0Sig A1)
      (Ze2 : Zero_Ringoid0Sig A2) :
      Set where
      constructor Zero_Ringoid0SigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ze1) (0 Ze2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ze1 x1 x2)
            (* Ze2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ze1 x1 x2)
            (+ Ze2 y1 y2)
    data Zero_Ringoid0SigLang
      : Set where
      0L : Zero_Ringoid0SigLang
      *L :
        Zero_Ringoid0SigLang ->
        Zero_Ringoid0SigLang ->
        Zero_Ringoid0SigLang
      +L :
        Zero_Ringoid0SigLang ->
        Zero_Ringoid0SigLang ->
        Zero_Ringoid0SigLang
    data Zero_Ringoid0SigOpenLang
      : Set where
      v :
        (n : Nat) ->
        Fin n ->
        Zero_Ringoid0SigOpenLang
      0OL : Zero_Ringoid0SigOpenLang
      *OL :
        Zero_Ringoid0SigOpenLang ->
        Zero_Ringoid0SigOpenLang ->
        Zero_Ringoid0SigOpenLang
      +OL :
        Zero_Ringoid0SigOpenLang ->
        Zero_Ringoid0SigOpenLang ->
        Zero_Ringoid0SigOpenLang
  

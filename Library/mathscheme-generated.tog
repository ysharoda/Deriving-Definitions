------------------------------------------------------------------------
-- Checking declarations
------------------------------------------------------------------------
-- Solved Metas: 222414
-- Unsolved Metas: 0
------------------------------------------------------------------------
-- Unsolved problems: 0
------------------------------------------------------------------------
module MathScheme where
  data Prod
    (A : Set) (B : Set) : Set where
    
  data Nat : Set where
    zero : Nat
    suc : Nat -> Nat
  data Fin (n : Nat) : Set where
    fzero :
      (m : Nat) (p : n == suc m) ->
      Fin n
    fsuc :
      (m : Nat) (p : n == suc m)
      (i : Fin m) -> Fin n
  pred : Nat -> Nat
  pred (zero) = zero
  pred (suc n) = n
  data Vec
    (A : Set) (n : Nat) : Set where
    nil : n == zero -> Vec A n
    cons :
      (m : Nat) (p : n == suc m)
      (x : A)
      (xs : Vec A m) -> Vec A n
  data Unit : Set where
    unit : Unit
  EmptyT : Set
  EmptyT = (A : Set) -> A
  subst :
    (A : Set) (x : A) (y : A)
    (P : A -> Set) ->
    x == y -> P x -> P y
  subst _ _ _ P =
    J _ _ _ (\x y _ -> P x -> P y)
      (\x p -> p)
  sym :
    (A : Set) (x : A) (y : A) ->
    x == y -> y == x
  sym A x y p =
    subst _ _ _ (\y -> y == x) p
      refl
  cong :
    (A : Set) (B : Set) (x : A)
    (y : A)
    (f : A -> B) ->
    x == y -> f x == f y
  cong _ _ _ _ f p =
    subst _ _ _ (\y -> f _ == f y) p
      refl
  IsZero : Nat -> Set
  IsZero (zero) = Unit
  IsZero (suc n) = EmptyT
  zeroNOTsuc :
    (n : Nat) ->
    zero == suc n -> EmptyT
  zeroNOTsuc _ p =
    subst _ _ _ IsZero p unit
  trans :
    (A : Set) (x : A) (y : A)
    (z : A) ->
    x == y -> y == z -> x == z
  trans A x _ _ p q =
    subst _ _ _ (\y -> x == y) q p
  lemma :
    (n : Nat) (m : Nat) ->
    n == suc m ->
    n == zero -> EmptyT
  lemma _ _ p q =
    zeroNOTsuc _
      (trans _ _ _ _ (sym _ _ _ q) p)
  sucInj :
    (n : Nat) (m : Nat) ->
    suc n == suc m -> n == m
  sucInj _ _ p =
    cong _ _ _ _ pred p
  lookup :
    (A : Set) (n : Nat) (i : Fin n)
    (v : Vec A n) -> A
  lookup A n (fzero m p) (nil q) =
    lemma _ _ p q A
  lookup A n (fzero m p) (cons
                          l
                          q
                          x
                          xs) = x
  lookup A n (fsuc m p i) (nil
                           q) = lemma _ _ p q A
  lookup A n (fsuc m p i) (cons
                           l
                           q
                           x
                           xs) =
    lookup _ m i
      (subst _ _ _ (Vec A)
         (sucInj _ _
            (trans _ _ _ _ (sym _ _ _ q) p))
         xs)
  module AbelianAdditiveGroup where
    record AbelianAdditiveGroup
      (A : Set) : Set where
      constructor AbelianAdditiveGroupC
      field
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
    record AbelianAdditiveGroupSig
      (AS : Set) : Set where
      constructor AbelianAdditiveGroupSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
    record AbelianAdditiveGroupProd
      (AP : Set) : Set where
      constructor AbelianAdditiveGroupProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
    record AbelianAdditiveGroupHom
      (A1 : Set) (A2 : Set)
      (Ab1 : AbelianAdditiveGroup A1)
      (Ab2 : AbelianAdditiveGroup
         A2) : Set where
      constructor AbelianAdditiveGroupHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ab1 x1 x2) ==
            + Ab2 (hom x1) (hom x2)
        pres-0 : hom (0 Ab1) == 0 Ab2
        pres-neg :
          (x1 : A1) ->
          hom (neg Ab1 x1) ==
            neg Ab2 (hom x1)
    record AbelianAdditiveGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ab1 : AbelianAdditiveGroup A1)
      (Ab2 : AbelianAdditiveGroup
         A2) : Set where
      constructor AbelianAdditiveGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ab1 x1 x2)
            (+ Ab2 y1 y2)
        interp-0 :
          interp (0 Ab1) (0 Ab2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Ab1 x1) (neg Ab2 y1)
    data AbelianAdditiveGroupLang
      : Set where
      +L :
        AbelianAdditiveGroupLang ->
        AbelianAdditiveGroupLang ->
        AbelianAdditiveGroupLang
      0L : AbelianAdditiveGroupLang
      negL :
        AbelianAdditiveGroupLang ->
        AbelianAdditiveGroupLang
    data AbelianAdditiveGroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AbelianAdditiveGroupOpenLang n
      +OL :
        AbelianAdditiveGroupOpenLang
          n ->
        AbelianAdditiveGroupOpenLang
          n ->
        AbelianAdditiveGroupOpenLang n
      0OL :
        AbelianAdditiveGroupOpenLang n
      negOL :
        AbelianAdditiveGroupOpenLang
          n ->
        AbelianAdditiveGroupOpenLang n
    evalTerm :
      (A : Set) ->
      AbelianAdditiveGroup A ->
      AbelianAdditiveGroupLang -> A
    evalTerm _ Ab (+L x1 x2) =
      + Ab (evalTerm _ Ab x1)
        (evalTerm _ Ab x2)
    evalTerm _ Ab (0L) = 0 Ab
    evalTerm _ Ab (negL x1) =
      neg Ab (evalTerm _ Ab x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AbelianAdditiveGroup A ->
      AbelianAdditiveGroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ab (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ab (+OL
                         x1
                         x2) vars =
      + ab
        (evalOpenTerm _ n ab x1 vars)
        (evalOpenTerm _ n ab x2 vars)
    evalOpenTerm _ n ab (0OL) vars =
      0 ab
    evalOpenTerm _ n ab (negOL
                         x1) vars =
      neg ab
        (evalOpenTerm _ n ab x1 vars)
  
  module AbelianGroup where
    record AbelianGroup
      (A : Set) : Set where
      constructor AbelianGroupC
      field
        1 : A
        * : A -> A -> A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        inv : A -> A
        leftInverse_inv_op_1 :
          (x : A) -> * x (inv x) == 1
        rightInverse_inv_op_1 :
          (x : A) -> * (inv x) x == 1
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
    record AbelianGroupSig
      (AS : Set) : Set where
      constructor AbelianGroupSigSigC
      field
        1S : AS
        *S : AS -> AS -> AS
        invS : AS -> AS
    record AbelianGroupProd
      (AP : Set) : Set where
      constructor AbelianGroupProdC
      field
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P xP (invP xP) == 1P
        rightInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P (invP xP) xP == 1P
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
    record AbelianGroupHom
      (A1 : Set) (A2 : Set)
      (Ab1 : AbelianGroup A1)
      (Ab2 : AbelianGroup A2) :
      Set where
      constructor AbelianGroupHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Ab1) == 1 Ab2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ab1 x1 x2) ==
            * Ab2 (hom x1) (hom x2)
        pres-inv :
          (x1 : A1) ->
          hom (inv Ab1 x1) ==
            inv Ab2 (hom x1)
    record AbelianGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ab1 : AbelianGroup A1)
      (Ab2 : AbelianGroup A2) :
      Set where
      constructor AbelianGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Ab1) (1 Ab2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ab1 x1 x2)
            (* Ab2 y1 y2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Ab1 x1) (inv Ab2 y1)
    data AbelianGroupLang
      : Set where
      1L : AbelianGroupLang
      *L :
        AbelianGroupLang ->
        AbelianGroupLang ->
        AbelianGroupLang
      invL :
        AbelianGroupLang ->
        AbelianGroupLang
    data AbelianGroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> AbelianGroupOpenLang n
      1OL : AbelianGroupOpenLang n
      *OL :
        AbelianGroupOpenLang n ->
        AbelianGroupOpenLang n ->
        AbelianGroupOpenLang n
      invOL :
        AbelianGroupOpenLang n ->
        AbelianGroupOpenLang n
    evalTerm :
      (A : Set) ->
      AbelianGroup A ->
      AbelianGroupLang -> A
    evalTerm _ Ab (1L) = 1 Ab
    evalTerm _ Ab (*L x1 x2) =
      * Ab (evalTerm _ Ab x1)
        (evalTerm _ Ab x2)
    evalTerm _ Ab (invL x1) =
      inv Ab (evalTerm _ Ab x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AbelianGroup A ->
      AbelianGroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ab (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ab (1OL) vars =
      1 ab
    evalOpenTerm _ n ab (*OL
                         x1
                         x2) vars =
      * ab
        (evalOpenTerm _ n ab x1 vars)
        (evalOpenTerm _ n ab x2 vars)
    evalOpenTerm _ n ab (invOL
                         x1) vars =
      inv ab
        (evalOpenTerm _ n ab x1 vars)
  
  module Absorption where
    record Absorption
      (A : Set) : Set where
      constructor AbsorptionC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
    record AbsorptionSig
      (AS : Set) : Set where
      constructor AbsorptionSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record AbsorptionProd
      (AP : Set) : Set where
      constructor AbsorptionProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
    record AbsorptionHom
      (A1 : Set) (A2 : Set)
      (Ab1 : Absorption A1)
      (Ab2 : Absorption A2) :
      Set where
      constructor AbsorptionHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ab1 x1 x2) ==
            * Ab2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ab1 x1 x2) ==
            + Ab2 (hom x1) (hom x2)
    record AbsorptionRelInterp
      (A1 : Set) (A2 : Set)
      (Ab1 : Absorption A1)
      (Ab2 : Absorption A2) :
      Set where
      constructor AbsorptionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ab1 x1 x2)
            (* Ab2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ab1 x1 x2)
            (+ Ab2 y1 y2)
    data AbsorptionLang : Set where
      *L :
        AbsorptionLang ->
        AbsorptionLang -> AbsorptionLang
      +L :
        AbsorptionLang ->
        AbsorptionLang -> AbsorptionLang
    data AbsorptionOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> AbsorptionOpenLang n
      *OL :
        AbsorptionOpenLang n ->
        AbsorptionOpenLang n ->
        AbsorptionOpenLang n
      +OL :
        AbsorptionOpenLang n ->
        AbsorptionOpenLang n ->
        AbsorptionOpenLang n
    evalTerm :
      (A : Set) ->
      Absorption A ->
      AbsorptionLang -> A
    evalTerm _ Ab (*L x1 x2) =
      * Ab (evalTerm _ Ab x1)
        (evalTerm _ Ab x2)
    evalTerm _ Ab (+L x1 x2) =
      + Ab (evalTerm _ Ab x1)
        (evalTerm _ Ab x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Absorption A ->
      AbsorptionOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ab (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ab (*OL
                         x1
                         x2) vars =
      * ab
        (evalOpenTerm _ n ab x1 vars)
        (evalOpenTerm _ n ab x2 vars)
    evalOpenTerm _ n ab (+OL
                         x1
                         x2) vars =
      + ab
        (evalOpenTerm _ n ab x1 vars)
        (evalOpenTerm _ n ab x2 vars)
  
  module AddCommMonWithMultMagma where
    record AddCommMonWithMultMagma
      (A : Set) : Set where
      constructor AddCommMonWithMultMagmaC
      field
        0 : A
        + : A -> A -> A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        * : A -> A -> A
    record AddCommMonWithMultMagmaSig
      (AS : Set) : Set where
      constructor AddCommMonWithMultMagmaSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
    record AddCommMonWithMultMagmaProd
      (AP : Set) : Set where
      constructor AddCommMonWithMultMagmaProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
    record AddCommMonWithMultMagmaHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AddCommMonWithMultMagma
         A1)
      (Ad2 : AddCommMonWithMultMagma
         A2) : Set where
      constructor AddCommMonWithMultMagmaHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ad1 x1 x2) ==
            * Ad2 (hom x1) (hom x2)
    record AddCommMonWithMultMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AddCommMonWithMultMagma
         A1)
      (Ad2 : AddCommMonWithMultMagma
         A2) : Set where
      constructor AddCommMonWithMultMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ad1 x1 x2)
            (* Ad2 y1 y2)
    data AddCommMonWithMultMagmaLang
      : Set where
      0L :
        AddCommMonWithMultMagmaLang
      +L :
        AddCommMonWithMultMagmaLang ->
        AddCommMonWithMultMagmaLang ->
        AddCommMonWithMultMagmaLang
      *L :
        AddCommMonWithMultMagmaLang ->
        AddCommMonWithMultMagmaLang ->
        AddCommMonWithMultMagmaLang
    data AddCommMonWithMultMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AddCommMonWithMultMagmaOpenLang
          n
      0OL :
        AddCommMonWithMultMagmaOpenLang
          n
      +OL :
        AddCommMonWithMultMagmaOpenLang
          n ->
        AddCommMonWithMultMagmaOpenLang
          n ->
        AddCommMonWithMultMagmaOpenLang
          n
      *OL :
        AddCommMonWithMultMagmaOpenLang
          n ->
        AddCommMonWithMultMagmaOpenLang
          n ->
        AddCommMonWithMultMagmaOpenLang
          n
    evalTerm :
      (A : Set) ->
      AddCommMonWithMultMagma A ->
      AddCommMonWithMultMagmaLang -> A
    evalTerm _ Ad (0L) = 0 Ad
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalTerm _ Ad (*L x1 x2) =
      * Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AddCommMonWithMultMagma A ->
      AddCommMonWithMultMagmaOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (0OL) vars =
      0 ad
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    evalOpenTerm _ n ad (*OL
                         x1
                         x2) vars =
      * ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
  
  module AddCommMonWithMultSemigroup where
    record AddCommMonWithMultSemigroup
      (A : Set) : Set where
      constructor AddCommMonWithMultSemigroupC
      field
        * : A -> A -> A
        0 : A
        + : A -> A -> A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
    record AddCommMonWithMultSemigroupSig
      (AS : Set) : Set where
      constructor AddCommMonWithMultSemigroupSigSigC
      field
        *S : AS -> AS -> AS
        0S : AS
        +S : AS -> AS -> AS
    record AddCommMonWithMultSemigroupProd
      (AP : Set) : Set where
      constructor AddCommMonWithMultSemigroupProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
    record AddCommMonWithMultSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AddCommMonWithMultSemigroup
         A1)
      (Ad2 : AddCommMonWithMultSemigroup
         A2) : Set where
      constructor AddCommMonWithMultSemigroupHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ad1 x1 x2) ==
            * Ad2 (hom x1) (hom x2)
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AddCommMonWithMultSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AddCommMonWithMultSemigroup
         A1)
      (Ad2 : AddCommMonWithMultSemigroup
         A2) : Set where
      constructor AddCommMonWithMultSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ad1 x1 x2)
            (* Ad2 y1 y2)
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AddCommMonWithMultSemigroupLang
      : Set where
      *L :
        AddCommMonWithMultSemigroupLang ->
        AddCommMonWithMultSemigroupLang ->
        AddCommMonWithMultSemigroupLang
      0L :
        AddCommMonWithMultSemigroupLang
      +L :
        AddCommMonWithMultSemigroupLang ->
        AddCommMonWithMultSemigroupLang ->
        AddCommMonWithMultSemigroupLang
    data AddCommMonWithMultSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AddCommMonWithMultSemigroupOpenLang
          n
      *OL :
        AddCommMonWithMultSemigroupOpenLang
          n ->
        AddCommMonWithMultSemigroupOpenLang
          n ->
        AddCommMonWithMultSemigroupOpenLang
          n
      0OL :
        AddCommMonWithMultSemigroupOpenLang
          n
      +OL :
        AddCommMonWithMultSemigroupOpenLang
          n ->
        AddCommMonWithMultSemigroupOpenLang
          n ->
        AddCommMonWithMultSemigroupOpenLang
          n
    evalTerm :
      (A : Set) ->
      AddCommMonWithMultSemigroup A ->
      AddCommMonWithMultSemigroupLang ->
      A
    evalTerm _ Ad (*L x1 x2) =
      * Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalTerm _ Ad (0L) = 0 Ad
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AddCommMonWithMultSemigroup A ->
      AddCommMonWithMultSemigroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (*OL
                         x1
                         x2) vars =
      * ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    evalOpenTerm _ n ad (0OL) vars =
      0 ad
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
  
  module AddGroup_RingoidSig where
    record AddGroup_RingoidSig
      (A : Set) : Set where
      constructor AddGroup_RingoidSigC
      field
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        * : A -> A -> A
    record AddGroup_RingoidSigSig
      (AS : Set) : Set where
      constructor AddGroup_RingoidSigSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
        *S : AS -> AS -> AS
    record AddGroup_RingoidSigProd
      (AP : Set) : Set where
      constructor AddGroup_RingoidSigProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
    record AddGroup_RingoidSigHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AddGroup_RingoidSig A1)
      (Ad2 : AddGroup_RingoidSig A2) :
      Set where
      constructor AddGroup_RingoidSigHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-neg :
          (x1 : A1) ->
          hom (neg Ad1 x1) ==
            neg Ad2 (hom x1)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ad1 x1 x2) ==
            * Ad2 (hom x1) (hom x2)
    record AddGroup_RingoidSigRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AddGroup_RingoidSig A1)
      (Ad2 : AddGroup_RingoidSig A2) :
      Set where
      constructor AddGroup_RingoidSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Ad1 x1) (neg Ad2 y1)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ad1 x1 x2)
            (* Ad2 y1 y2)
    data AddGroup_RingoidSigLang
      : Set where
      +L :
        AddGroup_RingoidSigLang ->
        AddGroup_RingoidSigLang ->
        AddGroup_RingoidSigLang
      0L : AddGroup_RingoidSigLang
      negL :
        AddGroup_RingoidSigLang ->
        AddGroup_RingoidSigLang
      *L :
        AddGroup_RingoidSigLang ->
        AddGroup_RingoidSigLang ->
        AddGroup_RingoidSigLang
    data AddGroup_RingoidSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AddGroup_RingoidSigOpenLang n
      +OL :
        AddGroup_RingoidSigOpenLang n ->
        AddGroup_RingoidSigOpenLang n ->
        AddGroup_RingoidSigOpenLang n
      0OL :
        AddGroup_RingoidSigOpenLang n
      negOL :
        AddGroup_RingoidSigOpenLang n ->
        AddGroup_RingoidSigOpenLang n
      *OL :
        AddGroup_RingoidSigOpenLang n ->
        AddGroup_RingoidSigOpenLang n ->
        AddGroup_RingoidSigOpenLang n
    evalTerm :
      (A : Set) ->
      AddGroup_RingoidSig A ->
      AddGroup_RingoidSigLang -> A
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalTerm _ Ad (0L) = 0 Ad
    evalTerm _ Ad (negL x1) =
      neg Ad (evalTerm _ Ad x1)
    evalTerm _ Ad (*L x1 x2) =
      * Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AddGroup_RingoidSig A ->
      AddGroup_RingoidSigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    evalOpenTerm _ n ad (0OL) vars =
      0 ad
    evalOpenTerm _ n ad (negOL
                         x1) vars =
      neg ad
        (evalOpenTerm _ n ad x1 vars)
    evalOpenTerm _ n ad (*OL
                         x1
                         x2) vars =
      * ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
  
  module AdditiveCommutativeMonoid where
    record AdditiveCommutativeMonoid
      (A : Set) : Set where
      constructor AdditiveCommutativeMonoidC
      field
        0 : A
        + : A -> A -> A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
    record AdditiveCommutativeMonoidSig
      (AS : Set) : Set where
      constructor AdditiveCommutativeMonoidSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
    record AdditiveCommutativeMonoidProd
      (AP : Set) : Set where
      constructor AdditiveCommutativeMonoidProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
    record AdditiveCommutativeMonoidHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveCommutativeMonoid
         A1)
      (Ad2 : AdditiveCommutativeMonoid
         A2) : Set where
      constructor AdditiveCommutativeMonoidHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveCommutativeMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveCommutativeMonoid
         A1)
      (Ad2 : AdditiveCommutativeMonoid
         A2) : Set where
      constructor AdditiveCommutativeMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveCommutativeMonoidLang
      : Set where
      0L :
        AdditiveCommutativeMonoidLang
      +L :
        AdditiveCommutativeMonoidLang ->
        AdditiveCommutativeMonoidLang ->
        AdditiveCommutativeMonoidLang
    data AdditiveCommutativeMonoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AdditiveCommutativeMonoidOpenLang
          n
      0OL :
        AdditiveCommutativeMonoidOpenLang
          n
      +OL :
        AdditiveCommutativeMonoidOpenLang
          n ->
        AdditiveCommutativeMonoidOpenLang
          n ->
        AdditiveCommutativeMonoidOpenLang
          n
    evalTerm :
      (A : Set) ->
      AdditiveCommutativeMonoid A ->
      AdditiveCommutativeMonoidLang ->
      A
    evalTerm _ Ad (0L) = 0 Ad
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditiveCommutativeMonoid A ->
      AdditiveCommutativeMonoidOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (0OL) vars =
      0 ad
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
  
  module AdditiveCommutativeSemigroup where
    record AdditiveCommutativeSemigroup
      (A : Set) : Set where
      constructor AdditiveCommutativeSemigroupC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record AdditiveCommutativeSemigroupSig
      (AS : Set) : Set where
      constructor AdditiveCommutativeSemigroupSigSigC
      field
        +S : AS -> AS -> AS
    record AdditiveCommutativeSemigroupProd
      (AP : Set) : Set where
      constructor AdditiveCommutativeSemigroupProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record AdditiveCommutativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveCommutativeSemigroup
         A1)
      (Ad2 : AdditiveCommutativeSemigroup
         A2) : Set where
      constructor AdditiveCommutativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveCommutativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveCommutativeSemigroup
         A1)
      (Ad2 : AdditiveCommutativeSemigroup
         A2) : Set where
      constructor AdditiveCommutativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveCommutativeSemigroupLang
      : Set where
      +L :
        AdditiveCommutativeSemigroupLang ->
        AdditiveCommutativeSemigroupLang ->
        AdditiveCommutativeSemigroupLang
    data AdditiveCommutativeSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AdditiveCommutativeSemigroupOpenLang
          n
      +OL :
        AdditiveCommutativeSemigroupOpenLang
          n ->
        AdditiveCommutativeSemigroupOpenLang
          n ->
        AdditiveCommutativeSemigroupOpenLang
          n
    evalTerm :
      (A : Set) ->
      AdditiveCommutativeSemigroup
        A ->
      AdditiveCommutativeSemigroupLang ->
      A
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditiveCommutativeSemigroup
        A ->
      AdditiveCommutativeSemigroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
  
  module AdditiveGroup where
    record AdditiveGroup
      (A : Set) : Set where
      constructor AdditiveGroupC
      field
        0 : A
        + : A -> A -> A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
    record AdditiveGroupSig
      (AS : Set) : Set where
      constructor AdditiveGroupSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        negS : AS -> AS
    record AdditiveGroupProd
      (AP : Set) : Set where
      constructor AdditiveGroupProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
    record AdditiveGroupHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveGroup A1)
      (Ad2 : AdditiveGroup A2) :
      Set where
      constructor AdditiveGroupHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
        pres-neg :
          (x1 : A1) ->
          hom (neg Ad1 x1) ==
            neg Ad2 (hom x1)
    record AdditiveGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveGroup A1)
      (Ad2 : AdditiveGroup A2) :
      Set where
      constructor AdditiveGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Ad1 x1) (neg Ad2 y1)
    data AdditiveGroupLang
      : Set where
      0L : AdditiveGroupLang
      +L :
        AdditiveGroupLang ->
        AdditiveGroupLang ->
        AdditiveGroupLang
      negL :
        AdditiveGroupLang ->
        AdditiveGroupLang
    data AdditiveGroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> AdditiveGroupOpenLang n
      0OL : AdditiveGroupOpenLang n
      +OL :
        AdditiveGroupOpenLang n ->
        AdditiveGroupOpenLang n ->
        AdditiveGroupOpenLang n
      negOL :
        AdditiveGroupOpenLang n ->
        AdditiveGroupOpenLang n
    evalTerm :
      (A : Set) ->
      AdditiveGroup A ->
      AdditiveGroupLang -> A
    evalTerm _ Ad (0L) = 0 Ad
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalTerm _ Ad (negL x1) =
      neg Ad (evalTerm _ Ad x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditiveGroup A ->
      AdditiveGroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (0OL) vars =
      0 ad
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    evalOpenTerm _ n ad (negOL
                         x1) vars =
      neg ad
        (evalOpenTerm _ n ad x1 vars)
  
  module AdditiveMagma where
    record AdditiveMagma
      (A : Set) : Set where
      constructor AdditiveMagmaC
      field
        + : A -> A -> A
    record AdditiveMagmaSig
      (AS : Set) : Set where
      constructor AdditiveMagmaSigSigC
      field
        +S : AS -> AS -> AS
    record AdditiveMagmaProd
      (AP : Set) : Set where
      constructor AdditiveMagmaProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record AdditiveMagmaHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveMagma A1)
      (Ad2 : AdditiveMagma A2) :
      Set where
      constructor AdditiveMagmaHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveMagma A1)
      (Ad2 : AdditiveMagma A2) :
      Set where
      constructor AdditiveMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveMagmaLang
      : Set where
      +L :
        AdditiveMagmaLang ->
        AdditiveMagmaLang ->
        AdditiveMagmaLang
    data AdditiveMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> AdditiveMagmaOpenLang n
      +OL :
        AdditiveMagmaOpenLang n ->
        AdditiveMagmaOpenLang n ->
        AdditiveMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      AdditiveMagma A ->
      AdditiveMagmaLang -> A
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditiveMagma A ->
      AdditiveMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
  
  module AdditiveMonoid where
    record AdditiveMonoid
      (A : Set) : Set where
      constructor AdditiveMonoidC
      field
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
    record AdditiveMonoidSig
      (AS : Set) : Set where
      constructor AdditiveMonoidSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
    record AdditiveMonoidProd
      (AP : Set) : Set where
      constructor AdditiveMonoidProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
    record AdditiveMonoidHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveMonoid A1)
      (Ad2 : AdditiveMonoid A2) :
      Set where
      constructor AdditiveMonoidHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
        pres-0 : hom (0 Ad1) == 0 Ad2
    record AdditiveMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveMonoid A1)
      (Ad2 : AdditiveMonoid A2) :
      Set where
      constructor AdditiveMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
        interp-0 :
          interp (0 Ad1) (0 Ad2)
    data AdditiveMonoidLang
      : Set where
      +L :
        AdditiveMonoidLang ->
        AdditiveMonoidLang ->
        AdditiveMonoidLang
      0L : AdditiveMonoidLang
    data AdditiveMonoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AdditiveMonoidOpenLang n
      +OL :
        AdditiveMonoidOpenLang n ->
        AdditiveMonoidOpenLang n ->
        AdditiveMonoidOpenLang n
      0OL : AdditiveMonoidOpenLang n
    evalTerm :
      (A : Set) ->
      AdditiveMonoid A ->
      AdditiveMonoidLang -> A
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalTerm _ Ad (0L) = 0 Ad
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditiveMonoid A ->
      AdditiveMonoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
    evalOpenTerm _ n ad (0OL) vars =
      0 ad
  
  module AdditivePointedMagma where
    record AdditivePointedMagma
      (A : Set) : Set where
      constructor AdditivePointedMagmaC
      field
        0 : A
        + : A -> A -> A
    record AdditivePointedMagmaSig
      (AS : Set) : Set where
      constructor AdditivePointedMagmaSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
    record AdditivePointedMagmaProd
      (AP : Set) : Set where
      constructor AdditivePointedMagmaProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record AdditivePointedMagmaHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditivePointedMagma A1)
      (Ad2 : AdditivePointedMagma
         A2) : Set where
      constructor AdditivePointedMagmaHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditivePointedMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditivePointedMagma A1)
      (Ad2 : AdditivePointedMagma
         A2) : Set where
      constructor AdditivePointedMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditivePointedMagmaLang
      : Set where
      0L : AdditivePointedMagmaLang
      +L :
        AdditivePointedMagmaLang ->
        AdditivePointedMagmaLang ->
        AdditivePointedMagmaLang
    data AdditivePointedMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AdditivePointedMagmaOpenLang n
      0OL :
        AdditivePointedMagmaOpenLang n
      +OL :
        AdditivePointedMagmaOpenLang
          n ->
        AdditivePointedMagmaOpenLang
          n ->
        AdditivePointedMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      AdditivePointedMagma A ->
      AdditivePointedMagmaLang -> A
    evalTerm _ Ad (0L) = 0 Ad
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditivePointedMagma A ->
      AdditivePointedMagmaOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (0OL) vars =
      0 ad
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
  
  module AdditivePointedSemigroup where
    record AdditivePointedSemigroup
      (A : Set) : Set where
      constructor AdditivePointedSemigroupC
      field
        0 : A
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record AdditivePointedSemigroupSig
      (AS : Set) : Set where
      constructor AdditivePointedSemigroupSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
    record AdditivePointedSemigroupProd
      (AP : Set) : Set where
      constructor AdditivePointedSemigroupProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record AdditivePointedSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditivePointedSemigroup
         A1)
      (Ad2 : AdditivePointedSemigroup
         A2) : Set where
      constructor AdditivePointedSemigroupHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditivePointedSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditivePointedSemigroup
         A1)
      (Ad2 : AdditivePointedSemigroup
         A2) : Set where
      constructor AdditivePointedSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditivePointedSemigroupLang
      : Set where
      0L :
        AdditivePointedSemigroupLang
      +L :
        AdditivePointedSemigroupLang ->
        AdditivePointedSemigroupLang ->
        AdditivePointedSemigroupLang
    data AdditivePointedSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AdditivePointedSemigroupOpenLang
          n
      0OL :
        AdditivePointedSemigroupOpenLang
          n
      +OL :
        AdditivePointedSemigroupOpenLang
          n ->
        AdditivePointedSemigroupOpenLang
          n ->
        AdditivePointedSemigroupOpenLang
          n
    evalTerm :
      (A : Set) ->
      AdditivePointedSemigroup A ->
      AdditivePointedSemigroupLang ->
      A
    evalTerm _ Ad (0L) = 0 Ad
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditivePointedSemigroup A ->
      AdditivePointedSemigroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (0OL) vars =
      0 ad
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
  
  module AdditiveSemigroup where
    record AdditiveSemigroup
      (A : Set) : Set where
      constructor AdditiveSemigroupC
      field
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record AdditiveSemigroupSig
      (AS : Set) : Set where
      constructor AdditiveSemigroupSigSigC
      field
        +S : AS -> AS -> AS
    record AdditiveSemigroupProd
      (AP : Set) : Set where
      constructor AdditiveSemigroupProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record AdditiveSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveSemigroup A1)
      (Ad2 : AdditiveSemigroup A2) :
      Set where
      constructor AdditiveSemigroupHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveSemigroup A1)
      (Ad2 : AdditiveSemigroup A2) :
      Set where
      constructor AdditiveSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveSemigroupLang
      : Set where
      +L :
        AdditiveSemigroupLang ->
        AdditiveSemigroupLang ->
        AdditiveSemigroupLang
    data AdditiveSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AdditiveSemigroupOpenLang n
      +OL :
        AdditiveSemigroupOpenLang n ->
        AdditiveSemigroupOpenLang n ->
        AdditiveSemigroupOpenLang n
    evalTerm :
      (A : Set) ->
      AdditiveSemigroup A ->
      AdditiveSemigroupLang -> A
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditiveSemigroup A ->
      AdditiveSemigroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
  
  module AdditiveUnaryAntiDistribution where
    record AdditiveUnaryAntiDistribution
      (A : Set) : Set where
      constructor AdditiveUnaryAntiDistributionC
      field
        prim : A -> A
        + : A -> A -> A
        antidis_prim_+ :
          (x : A) (y : A) ->
          prim (+ x y) ==
            + (prim y) (prim x)
    record AdditiveUnaryAntiDistributionSig
      (AS : Set) : Set where
      constructor AdditiveUnaryAntiDistributionSigSigC
      field
        primS : AS -> AS
        +S : AS -> AS -> AS
    record AdditiveUnaryAntiDistributionProd
      (AP : Set) : Set where
      constructor AdditiveUnaryAntiDistributionProdC
      field
        primP : Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        antidis_prim_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (+P xP yP) ==
            +P (primP yP) (primP xP)
    record AdditiveUnaryAntiDistributionHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveUnaryAntiDistribution
         A1)
      (Ad2 : AdditiveUnaryAntiDistribution
         A2) : Set where
      constructor AdditiveUnaryAntiDistributionHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Ad1 x1) ==
            prim Ad2 (hom x1)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveUnaryAntiDistributionRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveUnaryAntiDistribution
         A1)
      (Ad2 : AdditiveUnaryAntiDistribution
         A2) : Set where
      constructor AdditiveUnaryAntiDistributionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Ad1 x1)
            (prim Ad2 y1)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveUnaryAntiDistributionLang
      : Set where
      primL :
        AdditiveUnaryAntiDistributionLang ->
        AdditiveUnaryAntiDistributionLang
      +L :
        AdditiveUnaryAntiDistributionLang ->
        AdditiveUnaryAntiDistributionLang ->
        AdditiveUnaryAntiDistributionLang
    data AdditiveUnaryAntiDistributionOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AdditiveUnaryAntiDistributionOpenLang
          n
      primOL :
        AdditiveUnaryAntiDistributionOpenLang
          n ->
        AdditiveUnaryAntiDistributionOpenLang
          n
      +OL :
        AdditiveUnaryAntiDistributionOpenLang
          n ->
        AdditiveUnaryAntiDistributionOpenLang
          n ->
        AdditiveUnaryAntiDistributionOpenLang
          n
    evalTerm :
      (A : Set) ->
      AdditiveUnaryAntiDistribution
        A ->
      AdditiveUnaryAntiDistributionLang ->
      A
    evalTerm _ Ad (primL x1) =
      prim Ad (evalTerm _ Ad x1)
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditiveUnaryAntiDistribution
        A ->
      AdditiveUnaryAntiDistributionOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (primOL
                         x1) vars =
      prim ad
        (evalOpenTerm _ n ad x1 vars)
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
  
  module AdditiveUnital where
    record AdditiveUnital
      (A : Set) : Set where
      constructor AdditiveUnitalC
      field
        0 : A
        + : A -> A -> A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
    record AdditiveUnitalSig
      (AS : Set) : Set where
      constructor AdditiveUnitalSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
    record AdditiveUnitalProd
      (AP : Set) : Set where
      constructor AdditiveUnitalProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
    record AdditiveUnitalHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveUnital A1)
      (Ad2 : AdditiveUnital A2) :
      Set where
      constructor AdditiveUnitalHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveUnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveUnital A1)
      (Ad2 : AdditiveUnital A2) :
      Set where
      constructor AdditiveUnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveUnitalLang
      : Set where
      0L : AdditiveUnitalLang
      +L :
        AdditiveUnitalLang ->
        AdditiveUnitalLang ->
        AdditiveUnitalLang
    data AdditiveUnitalOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AdditiveUnitalOpenLang n
      0OL : AdditiveUnitalOpenLang n
      +OL :
        AdditiveUnitalOpenLang n ->
        AdditiveUnitalOpenLang n ->
        AdditiveUnitalOpenLang n
    evalTerm :
      (A : Set) ->
      AdditiveUnital A ->
      AdditiveUnitalLang -> A
    evalTerm _ Ad (0L) = 0 Ad
    evalTerm _ Ad (+L x1 x2) =
      + Ad (evalTerm _ Ad x1)
        (evalTerm _ Ad x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AdditiveUnital A ->
      AdditiveUnitalOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ad (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ad (0OL) vars =
      0 ad
    evalOpenTerm _ n ad (+OL
                         x1
                         x2) vars =
      + ad
        (evalOpenTerm _ n ad x1 vars)
        (evalOpenTerm _ n ad x2 vars)
  
  module AndDeMorgan where
    record AndDeMorgan
      (A : Set) : Set where
      constructor AndDeMorganC
      field
        * : A -> A -> A
        + : A -> A -> A
        prim : A -> A
        andDeMorgan_*_+_prim :
          (x : A) (y : A) (z : A) ->
          prim (* x y) ==
            + (prim x) (prim y)
    record AndDeMorganSig
      (AS : Set) : Set where
      constructor AndDeMorganSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        primS : AS -> AS
    record AndDeMorganProd
      (AP : Set) : Set where
      constructor AndDeMorganProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        andDeMorgan_*_+_primP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          primP (*P xP yP) ==
            +P (primP xP) (primP yP)
    record AndDeMorganHom
      (A1 : Set) (A2 : Set)
      (An1 : AndDeMorgan A1)
      (An2 : AndDeMorgan A2) :
      Set where
      constructor AndDeMorganHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* An1 x1 x2) ==
            * An2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ An1 x1 x2) ==
            + An2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim An1 x1) ==
            prim An2 (hom x1)
    record AndDeMorganRelInterp
      (A1 : Set) (A2 : Set)
      (An1 : AndDeMorgan A1)
      (An2 : AndDeMorgan A2) :
      Set where
      constructor AndDeMorganRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* An1 x1 x2)
            (* An2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ An1 x1 x2)
            (+ An2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim An1 x1)
            (prim An2 y1)
    data AndDeMorganLang : Set where
      *L :
        AndDeMorganLang ->
        AndDeMorganLang ->
        AndDeMorganLang
      +L :
        AndDeMorganLang ->
        AndDeMorganLang ->
        AndDeMorganLang
      primL :
        AndDeMorganLang ->
        AndDeMorganLang
    data AndDeMorganOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> AndDeMorganOpenLang n
      *OL :
        AndDeMorganOpenLang n ->
        AndDeMorganOpenLang n ->
        AndDeMorganOpenLang n
      +OL :
        AndDeMorganOpenLang n ->
        AndDeMorganOpenLang n ->
        AndDeMorganOpenLang n
      primOL :
        AndDeMorganOpenLang n ->
        AndDeMorganOpenLang n
    evalTerm :
      (A : Set) ->
      AndDeMorgan A ->
      AndDeMorganLang -> A
    evalTerm _ An (*L x1 x2) =
      * An (evalTerm _ An x1)
        (evalTerm _ An x2)
    evalTerm _ An (+L x1 x2) =
      + An (evalTerm _ An x1)
        (evalTerm _ An x2)
    evalTerm _ An (primL x1) =
      prim An (evalTerm _ An x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AndDeMorgan A ->
      AndDeMorganOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n an (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n an (*OL
                         x1
                         x2) vars =
      * an
        (evalOpenTerm _ n an x1 vars)
        (evalOpenTerm _ n an x2 vars)
    evalOpenTerm _ n an (+OL
                         x1
                         x2) vars =
      + an
        (evalOpenTerm _ n an x1 vars)
        (evalOpenTerm _ n an x2 vars)
    evalOpenTerm _ n an (primOL
                         x1) vars =
      prim an
        (evalOpenTerm _ n an x1 vars)
  
  module AntiAbsorbent where
    record AntiAbsorbent
      (A : Set) : Set where
      constructor AntiAbsorbentC
      field
        op : A -> A -> A
        antiAbsorbent :
          (x : A) (y : A) ->
          op x (op x y) == y
    record AntiAbsorbentSig
      (AS : Set) : Set where
      constructor AntiAbsorbentSigSigC
      field
        opS : AS -> AS -> AS
    record AntiAbsorbentProd
      (AP : Set) : Set where
      constructor AntiAbsorbentProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        antiAbsorbentP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (opP xP yP) == yP
    record AntiAbsorbentHom
      (A1 : Set) (A2 : Set)
      (An1 : AntiAbsorbent A1)
      (An2 : AntiAbsorbent A2) :
      Set where
      constructor AntiAbsorbentHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op An1 x1 x2) ==
            op An2 (hom x1) (hom x2)
    record AntiAbsorbentRelInterp
      (A1 : Set) (A2 : Set)
      (An1 : AntiAbsorbent A1)
      (An2 : AntiAbsorbent A2) :
      Set where
      constructor AntiAbsorbentRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op An1 x1 x2)
            (op An2 y1 y2)
    data AntiAbsorbentLang
      : Set where
      opL :
        AntiAbsorbentLang ->
        AntiAbsorbentLang ->
        AntiAbsorbentLang
    data AntiAbsorbentOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> AntiAbsorbentOpenLang n
      opOL :
        AntiAbsorbentOpenLang n ->
        AntiAbsorbentOpenLang n ->
        AntiAbsorbentOpenLang n
    evalTerm :
      (A : Set) ->
      AntiAbsorbent A ->
      AntiAbsorbentLang -> A
    evalTerm _ An (opL x1 x2) =
      op An (evalTerm _ An x1)
        (evalTerm _ An x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AntiAbsorbent A ->
      AntiAbsorbentOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n an (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n an (opOL
                         x1
                         x2) vars =
      op an
        (evalOpenTerm _ n an x1 vars)
        (evalOpenTerm _ n an x2 vars)
  
  module AntiCommutativeRing where
    record AntiCommutativeRing
      (A : Set) : Set where
      constructor AntiCommutativeRingC
      field
        * : A -> A -> A
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
        antiCommutative :
          (x : A) (y : A) ->
          * x y == neg (* y x)
    record AntiCommutativeRingSig
      (AS : Set) : Set where
      constructor AntiCommutativeRingSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
        1S : AS
    record AntiCommutativeRingProd
      (AP : Set) : Set where
      constructor AntiCommutativeRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
        antiCommutativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == negP (*P yP xP)
    record AntiCommutativeRingHom
      (A1 : Set) (A2 : Set)
      (An1 : AntiCommutativeRing A1)
      (An2 : AntiCommutativeRing A2) :
      Set where
      constructor AntiCommutativeRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* An1 x1 x2) ==
            * An2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ An1 x1 x2) ==
            + An2 (hom x1) (hom x2)
        pres-0 : hom (0 An1) == 0 An2
        pres-neg :
          (x1 : A1) ->
          hom (neg An1 x1) ==
            neg An2 (hom x1)
        pres-1 : hom (1 An1) == 1 An2
    record AntiCommutativeRingRelInterp
      (A1 : Set) (A2 : Set)
      (An1 : AntiCommutativeRing A1)
      (An2 : AntiCommutativeRing A2) :
      Set where
      constructor AntiCommutativeRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* An1 x1 x2)
            (* An2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ An1 x1 x2)
            (+ An2 y1 y2)
        interp-0 :
          interp (0 An1) (0 An2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg An1 x1) (neg An2 y1)
        interp-1 :
          interp (1 An1) (1 An2)
    data AntiCommutativeRingLang
      : Set where
      *L :
        AntiCommutativeRingLang ->
        AntiCommutativeRingLang ->
        AntiCommutativeRingLang
      +L :
        AntiCommutativeRingLang ->
        AntiCommutativeRingLang ->
        AntiCommutativeRingLang
      0L : AntiCommutativeRingLang
      negL :
        AntiCommutativeRingLang ->
        AntiCommutativeRingLang
      1L : AntiCommutativeRingLang
    data AntiCommutativeRingOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AntiCommutativeRingOpenLang n
      *OL :
        AntiCommutativeRingOpenLang n ->
        AntiCommutativeRingOpenLang n ->
        AntiCommutativeRingOpenLang n
      +OL :
        AntiCommutativeRingOpenLang n ->
        AntiCommutativeRingOpenLang n ->
        AntiCommutativeRingOpenLang n
      0OL :
        AntiCommutativeRingOpenLang n
      negOL :
        AntiCommutativeRingOpenLang n ->
        AntiCommutativeRingOpenLang n
      1OL :
        AntiCommutativeRingOpenLang n
    evalTerm :
      (A : Set) ->
      AntiCommutativeRing A ->
      AntiCommutativeRingLang -> A
    evalTerm _ An (*L x1 x2) =
      * An (evalTerm _ An x1)
        (evalTerm _ An x2)
    evalTerm _ An (+L x1 x2) =
      + An (evalTerm _ An x1)
        (evalTerm _ An x2)
    evalTerm _ An (0L) = 0 An
    evalTerm _ An (negL x1) =
      neg An (evalTerm _ An x1)
    evalTerm _ An (1L) = 1 An
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AntiCommutativeRing A ->
      AntiCommutativeRingOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n an (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n an (*OL
                         x1
                         x2) vars =
      * an
        (evalOpenTerm _ n an x1 vars)
        (evalOpenTerm _ n an x2 vars)
    evalOpenTerm _ n an (+OL
                         x1
                         x2) vars =
      + an
        (evalOpenTerm _ n an x1 vars)
        (evalOpenTerm _ n an x2 vars)
    evalOpenTerm _ n an (0OL) vars =
      0 an
    evalOpenTerm _ n an (negOL
                         x1) vars =
      neg an
        (evalOpenTerm _ n an x1 vars)
    evalOpenTerm _ n an (1OL) vars =
      1 an
  
  module AssocPlusRingoid where
    record AssocPlusRingoid
      (A : Set) : Set where
      constructor AssocPlusRingoidC
      field
        + : A -> A -> A
        * : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record AssocPlusRingoidSig
      (AS : Set) : Set where
      constructor AssocPlusRingoidSigSigC
      field
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
    record AssocPlusRingoidProd
      (AP : Set) : Set where
      constructor AssocPlusRingoidProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record AssocPlusRingoidHom
      (A1 : Set) (A2 : Set)
      (As1 : AssocPlusRingoid A1)
      (As2 : AssocPlusRingoid A2) :
      Set where
      constructor AssocPlusRingoidHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ As1 x1 x2) ==
            + As2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* As1 x1 x2) ==
            * As2 (hom x1) (hom x2)
    record AssocPlusRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (As1 : AssocPlusRingoid A1)
      (As2 : AssocPlusRingoid A2) :
      Set where
      constructor AssocPlusRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ As1 x1 x2)
            (+ As2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* As1 x1 x2)
            (* As2 y1 y2)
    data AssocPlusRingoidLang
      : Set where
      +L :
        AssocPlusRingoidLang ->
        AssocPlusRingoidLang ->
        AssocPlusRingoidLang
      *L :
        AssocPlusRingoidLang ->
        AssocPlusRingoidLang ->
        AssocPlusRingoidLang
    data AssocPlusRingoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AssocPlusRingoidOpenLang n
      +OL :
        AssocPlusRingoidOpenLang n ->
        AssocPlusRingoidOpenLang n ->
        AssocPlusRingoidOpenLang n
      *OL :
        AssocPlusRingoidOpenLang n ->
        AssocPlusRingoidOpenLang n ->
        AssocPlusRingoidOpenLang n
    evalTerm :
      (A : Set) ->
      AssocPlusRingoid A ->
      AssocPlusRingoidLang -> A
    evalTerm _ As (+L x1 x2) =
      + As (evalTerm _ As x1)
        (evalTerm _ As x2)
    evalTerm _ As (*L x1 x2) =
      * As (evalTerm _ As x1)
        (evalTerm _ As x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AssocPlusRingoid A ->
      AssocPlusRingoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n as (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n as (+OL
                         x1
                         x2) vars =
      + as
        (evalOpenTerm _ n as x1 vars)
        (evalOpenTerm _ n as x2 vars)
    evalOpenTerm _ n as (*OL
                         x1
                         x2) vars =
      * as
        (evalOpenTerm _ n as x1 vars)
        (evalOpenTerm _ n as x2 vars)
  
  module AssocTimesRingoid where
    record AssocTimesRingoid
      (A : Set) : Set where
      constructor AssocTimesRingoidC
      field
        * : A -> A -> A
        + : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
    record AssocTimesRingoidSig
      (AS : Set) : Set where
      constructor AssocTimesRingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record AssocTimesRingoidProd
      (AP : Set) : Set where
      constructor AssocTimesRingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
    record AssocTimesRingoidHom
      (A1 : Set) (A2 : Set)
      (As1 : AssocTimesRingoid A1)
      (As2 : AssocTimesRingoid A2) :
      Set where
      constructor AssocTimesRingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* As1 x1 x2) ==
            * As2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ As1 x1 x2) ==
            + As2 (hom x1) (hom x2)
    record AssocTimesRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (As1 : AssocTimesRingoid A1)
      (As2 : AssocTimesRingoid A2) :
      Set where
      constructor AssocTimesRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* As1 x1 x2)
            (* As2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ As1 x1 x2)
            (+ As2 y1 y2)
    data AssocTimesRingoidLang
      : Set where
      *L :
        AssocTimesRingoidLang ->
        AssocTimesRingoidLang ->
        AssocTimesRingoidLang
      +L :
        AssocTimesRingoidLang ->
        AssocTimesRingoidLang ->
        AssocTimesRingoidLang
    data AssocTimesRingoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AssocTimesRingoidOpenLang n
      *OL :
        AssocTimesRingoidOpenLang n ->
        AssocTimesRingoidOpenLang n ->
        AssocTimesRingoidOpenLang n
      +OL :
        AssocTimesRingoidOpenLang n ->
        AssocTimesRingoidOpenLang n ->
        AssocTimesRingoidOpenLang n
    evalTerm :
      (A : Set) ->
      AssocTimesRingoid A ->
      AssocTimesRingoidLang -> A
    evalTerm _ As (*L x1 x2) =
      * As (evalTerm _ As x1)
        (evalTerm _ As x2)
    evalTerm _ As (+L x1 x2) =
      + As (evalTerm _ As x1)
        (evalTerm _ As x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AssocTimesRingoid A ->
      AssocTimesRingoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n as (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n as (*OL
                         x1
                         x2) vars =
      * as
        (evalOpenTerm _ n as x1 vars)
        (evalOpenTerm _ n as x2 vars)
    evalOpenTerm _ n as (+OL
                         x1
                         x2) vars =
      + as
        (evalOpenTerm _ n as x1 vars)
        (evalOpenTerm _ n as x2 vars)
  
  module AssociativeLeftRingoid where
    record AssociativeLeftRingoid
      (A : Set) : Set where
      constructor AssociativeLeftRingoidC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
    record AssociativeLeftRingoidSig
      (AS : Set) : Set where
      constructor AssociativeLeftRingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record AssociativeLeftRingoidProd
      (AP : Set) : Set where
      constructor AssociativeLeftRingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
    record AssociativeLeftRingoidHom
      (A1 : Set) (A2 : Set)
      (As1 : AssociativeLeftRingoid
         A1)
      (As2 : AssociativeLeftRingoid
         A2) : Set where
      constructor AssociativeLeftRingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* As1 x1 x2) ==
            * As2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ As1 x1 x2) ==
            + As2 (hom x1) (hom x2)
    record AssociativeLeftRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (As1 : AssociativeLeftRingoid
         A1)
      (As2 : AssociativeLeftRingoid
         A2) : Set where
      constructor AssociativeLeftRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* As1 x1 x2)
            (* As2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ As1 x1 x2)
            (+ As2 y1 y2)
    data AssociativeLeftRingoidLang
      : Set where
      *L :
        AssociativeLeftRingoidLang ->
        AssociativeLeftRingoidLang ->
        AssociativeLeftRingoidLang
      +L :
        AssociativeLeftRingoidLang ->
        AssociativeLeftRingoidLang ->
        AssociativeLeftRingoidLang
    data AssociativeLeftRingoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AssociativeLeftRingoidOpenLang n
      *OL :
        AssociativeLeftRingoidOpenLang
          n ->
        AssociativeLeftRingoidOpenLang
          n ->
        AssociativeLeftRingoidOpenLang n
      +OL :
        AssociativeLeftRingoidOpenLang
          n ->
        AssociativeLeftRingoidOpenLang
          n ->
        AssociativeLeftRingoidOpenLang n
    evalTerm :
      (A : Set) ->
      AssociativeLeftRingoid A ->
      AssociativeLeftRingoidLang -> A
    evalTerm _ As (*L x1 x2) =
      * As (evalTerm _ As x1)
        (evalTerm _ As x2)
    evalTerm _ As (+L x1 x2) =
      + As (evalTerm _ As x1)
        (evalTerm _ As x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AssociativeLeftRingoid A ->
      AssociativeLeftRingoidOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n as (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n as (*OL
                         x1
                         x2) vars =
      * as
        (evalOpenTerm _ n as x1 vars)
        (evalOpenTerm _ n as x2 vars)
    evalOpenTerm _ n as (+OL
                         x1
                         x2) vars =
      + as
        (evalOpenTerm _ n as x1 vars)
        (evalOpenTerm _ n as x2 vars)
  
  module AssociativeNonDistributiveRingoid where
    record AssociativeNonDistributiveRingoid
      (A : Set) : Set where
      constructor AssociativeNonDistributiveRingoidC
      field
        * : A -> A -> A
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
    record AssociativeNonDistributiveRingoidSig
      (AS : Set) : Set where
      constructor AssociativeNonDistributiveRingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record AssociativeNonDistributiveRingoidProd
      (AP : Set) : Set where
      constructor AssociativeNonDistributiveRingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
    record AssociativeNonDistributiveRingoidHom
      (A1 : Set) (A2 : Set)
      (As1 : AssociativeNonDistributiveRingoid
         A1)
      (As2 : AssociativeNonDistributiveRingoid
         A2) : Set where
      constructor AssociativeNonDistributiveRingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* As1 x1 x2) ==
            * As2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ As1 x1 x2) ==
            + As2 (hom x1) (hom x2)
    record AssociativeNonDistributiveRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (As1 : AssociativeNonDistributiveRingoid
         A1)
      (As2 : AssociativeNonDistributiveRingoid
         A2) : Set where
      constructor AssociativeNonDistributiveRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* As1 x1 x2)
            (* As2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ As1 x1 x2)
            (+ As2 y1 y2)
    data AssociativeNonDistributiveRingoidLang
      : Set where
      *L :
        AssociativeNonDistributiveRingoidLang ->
        AssociativeNonDistributiveRingoidLang ->
        AssociativeNonDistributiveRingoidLang
      +L :
        AssociativeNonDistributiveRingoidLang ->
        AssociativeNonDistributiveRingoidLang ->
        AssociativeNonDistributiveRingoidLang
    data AssociativeNonDistributiveRingoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AssociativeNonDistributiveRingoidOpenLang
          n
      *OL :
        AssociativeNonDistributiveRingoidOpenLang
          n ->
        AssociativeNonDistributiveRingoidOpenLang
          n ->
        AssociativeNonDistributiveRingoidOpenLang
          n
      +OL :
        AssociativeNonDistributiveRingoidOpenLang
          n ->
        AssociativeNonDistributiveRingoidOpenLang
          n ->
        AssociativeNonDistributiveRingoidOpenLang
          n
    evalTerm :
      (A : Set) ->
      AssociativeNonDistributiveRingoid
        A ->
      AssociativeNonDistributiveRingoidLang ->
      A
    evalTerm _ As (*L x1 x2) =
      * As (evalTerm _ As x1)
        (evalTerm _ As x2)
    evalTerm _ As (+L x1 x2) =
      + As (evalTerm _ As x1)
        (evalTerm _ As x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AssociativeNonDistributiveRingoid
        A ->
      AssociativeNonDistributiveRingoidOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n as (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n as (*OL
                         x1
                         x2) vars =
      * as
        (evalOpenTerm _ n as x1 vars)
        (evalOpenTerm _ n as x2 vars)
    evalOpenTerm _ n as (+OL
                         x1
                         x2) vars =
      + as
        (evalOpenTerm _ n as x1 vars)
        (evalOpenTerm _ n as x2 vars)
  
  module AssociativeRightRingoid where
    record AssociativeRightRingoid
      (A : Set) : Set where
      constructor AssociativeRightRingoidC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        + : A -> A -> A
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record AssociativeRightRingoidSig
      (AS : Set) : Set where
      constructor AssociativeRightRingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record AssociativeRightRingoidProd
      (AP : Set) : Set where
      constructor AssociativeRightRingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record AssociativeRightRingoidHom
      (A1 : Set) (A2 : Set)
      (As1 : AssociativeRightRingoid
         A1)
      (As2 : AssociativeRightRingoid
         A2) : Set where
      constructor AssociativeRightRingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* As1 x1 x2) ==
            * As2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ As1 x1 x2) ==
            + As2 (hom x1) (hom x2)
    record AssociativeRightRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (As1 : AssociativeRightRingoid
         A1)
      (As2 : AssociativeRightRingoid
         A2) : Set where
      constructor AssociativeRightRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* As1 x1 x2)
            (* As2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ As1 x1 x2)
            (+ As2 y1 y2)
    data AssociativeRightRingoidLang
      : Set where
      *L :
        AssociativeRightRingoidLang ->
        AssociativeRightRingoidLang ->
        AssociativeRightRingoidLang
      +L :
        AssociativeRightRingoidLang ->
        AssociativeRightRingoidLang ->
        AssociativeRightRingoidLang
    data AssociativeRightRingoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        AssociativeRightRingoidOpenLang
          n
      *OL :
        AssociativeRightRingoidOpenLang
          n ->
        AssociativeRightRingoidOpenLang
          n ->
        AssociativeRightRingoidOpenLang
          n
      +OL :
        AssociativeRightRingoidOpenLang
          n ->
        AssociativeRightRingoidOpenLang
          n ->
        AssociativeRightRingoidOpenLang
          n
    evalTerm :
      (A : Set) ->
      AssociativeRightRingoid A ->
      AssociativeRightRingoidLang -> A
    evalTerm _ As (*L x1 x2) =
      * As (evalTerm _ As x1)
        (evalTerm _ As x2)
    evalTerm _ As (+L x1 x2) =
      + As (evalTerm _ As x1)
        (evalTerm _ As x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      AssociativeRightRingoid A ->
      AssociativeRightRingoidOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n as (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n as (*OL
                         x1
                         x2) vars =
      * as
        (evalOpenTerm _ n as x1 vars)
        (evalOpenTerm _ n as x2 vars)
    evalOpenTerm _ n as (+OL
                         x1
                         x2) vars =
      + as
        (evalOpenTerm _ n as x1 vars)
        (evalOpenTerm _ n as x2 vars)
  
  module Band where
    record Band
      (A : Set) : Set where
      constructor BandC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        idempotent_op :
          (x : A) -> op x x == x
    record BandSig
      (AS : Set) : Set where
      constructor BandSigSigC
      field
        opS : AS -> AS -> AS
    record BandProd
      (AP : Set) : Set where
      constructor BandProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        idempotent_opP :
          (xP : Prod AP AP) ->
          opP xP xP == xP
    record BandHom
      (A1 : Set) (A2 : Set)
      (Ba1 : Band A1)
      (Ba2 : Band A2) : Set where
      constructor BandHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ba1 x1 x2) ==
            op Ba2 (hom x1) (hom x2)
    record BandRelInterp
      (A1 : Set) (A2 : Set)
      (Ba1 : Band A1)
      (Ba2 : Band A2) : Set where
      constructor BandRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ba1 x1 x2)
            (op Ba2 y1 y2)
    data BandLang : Set where
      opL :
        BandLang -> BandLang -> BandLang
    data BandOpenLang
      (n : Nat) : Set where
      v : Fin n -> BandOpenLang n
      opOL :
        BandOpenLang n ->
        BandOpenLang n -> BandOpenLang n
    evalTerm :
      (A : Set) ->
      Band A -> BandLang -> A
    evalTerm _ Ba (opL x1 x2) =
      op Ba (evalTerm _ Ba x1)
        (evalTerm _ Ba x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Band A ->
      BandOpenLang n -> Vec A n -> A
    evalOpenTerm _ n ba (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ba (opOL
                         x1
                         x2) vars =
      op ba
        (evalOpenTerm _ n ba x1 vars)
        (evalOpenTerm _ n ba x2 vars)
  
  module BinaryInverse where
    record BinaryInverse
      (A : Set) : Set where
      constructor BinaryInverseC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftInverse :
          (x : A) (y : A) ->
          <| (|> x y) x == y
        rightInverse :
          (x : A) (y : A) ->
          |> x (<| y x) == y
    record BinaryInverseSig
      (AS : Set) : Set where
      constructor BinaryInverseSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record BinaryInverseProd
      (AP : Set) : Set where
      constructor BinaryInverseProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          <|P (|>P xP yP) xP == yP
        rightInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          |>P xP (<|P yP xP) == yP
    record BinaryInverseHom
      (A1 : Set) (A2 : Set)
      (Bi1 : BinaryInverse A1)
      (Bi2 : BinaryInverse A2) :
      Set where
      constructor BinaryInverseHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Bi1 x1 x2) ==
            |> Bi2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Bi1 x1 x2) ==
            <| Bi2 (hom x1) (hom x2)
    record BinaryInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Bi1 : BinaryInverse A1)
      (Bi2 : BinaryInverse A2) :
      Set where
      constructor BinaryInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Bi1 x1 x2)
            (|> Bi2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Bi1 x1 x2)
            (<| Bi2 y1 y2)
    data BinaryInverseLang
      : Set where
      |>L :
        BinaryInverseLang ->
        BinaryInverseLang ->
        BinaryInverseLang
      <|L :
        BinaryInverseLang ->
        BinaryInverseLang ->
        BinaryInverseLang
    data BinaryInverseOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> BinaryInverseOpenLang n
      |>OL :
        BinaryInverseOpenLang n ->
        BinaryInverseOpenLang n ->
        BinaryInverseOpenLang n
      <|OL :
        BinaryInverseOpenLang n ->
        BinaryInverseOpenLang n ->
        BinaryInverseOpenLang n
    evalTerm :
      (A : Set) ->
      BinaryInverse A ->
      BinaryInverseLang -> A
    evalTerm _ Bi (|>L x1 x2) =
      |> Bi (evalTerm _ Bi x1)
        (evalTerm _ Bi x2)
    evalTerm _ Bi (<|L x1 x2) =
      <| Bi (evalTerm _ Bi x1)
        (evalTerm _ Bi x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      BinaryInverse A ->
      BinaryInverseOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n bi (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n bi (|>OL
                         x1
                         x2) vars =
      |> bi
        (evalOpenTerm _ n bi x1 vars)
        (evalOpenTerm _ n bi x2 vars)
    evalOpenTerm _ n bi (<|OL
                         x1
                         x2) vars =
      <| bi
        (evalOpenTerm _ n bi x1 vars)
        (evalOpenTerm _ n bi x2 vars)
  
  module BooleanGroup where
    record BooleanGroup
      (A : Set) : Set where
      constructor BooleanGroupC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        unipotence :
          (x : A) -> op x x == e
    record BooleanGroupSig
      (AS : Set) : Set where
      constructor BooleanGroupSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record BooleanGroupProd
      (AP : Set) : Set where
      constructor BooleanGroupProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        unipotenceP :
          (xP : Prod AP AP) ->
          opP xP xP == eP
    record BooleanGroupHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BooleanGroup A1)
      (Bo2 : BooleanGroup A2) :
      Set where
      constructor BooleanGroupHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Bo1) == e Bo2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Bo1 x1 x2) ==
            op Bo2 (hom x1) (hom x2)
    record BooleanGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BooleanGroup A1)
      (Bo2 : BooleanGroup A2) :
      Set where
      constructor BooleanGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Bo1) (e Bo2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Bo1 x1 x2)
            (op Bo2 y1 y2)
    data BooleanGroupLang
      : Set where
      eL : BooleanGroupLang
      opL :
        BooleanGroupLang ->
        BooleanGroupLang ->
        BooleanGroupLang
    data BooleanGroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> BooleanGroupOpenLang n
      eOL : BooleanGroupOpenLang n
      opOL :
        BooleanGroupOpenLang n ->
        BooleanGroupOpenLang n ->
        BooleanGroupOpenLang n
    evalTerm :
      (A : Set) ->
      BooleanGroup A ->
      BooleanGroupLang -> A
    evalTerm _ Bo (eL) = e Bo
    evalTerm _ Bo (opL x1 x2) =
      op Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      BooleanGroup A ->
      BooleanGroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n bo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n bo (eOL) vars =
      e bo
    evalOpenTerm _ n bo (opOL
                         x1
                         x2) vars =
      op bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
  
  module BooleanRing where
    record BooleanRing
      (A : Set) : Set where
      constructor BooleanRingC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
        idempotent_* :
          (x : A) -> * x x == x
    record BooleanRingSig
      (AS : Set) : Set where
      constructor BooleanRingSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
    record BooleanRingProd
      (AP : Set) : Set where
      constructor BooleanRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
    record BooleanRingHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BooleanRing A1)
      (Bo2 : BooleanRing A2) :
      Set where
      constructor BooleanRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
        pres-1 : hom (1 Bo1) == 1 Bo2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
        pres-0 : hom (0 Bo1) == 0 Bo2
        pres-neg :
          (x1 : A1) ->
          hom (neg Bo1 x1) ==
            neg Bo2 (hom x1)
    record BooleanRingRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BooleanRing A1)
      (Bo2 : BooleanRing A2) :
      Set where
      constructor BooleanRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
        interp-1 :
          interp (1 Bo1) (1 Bo2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
        interp-0 :
          interp (0 Bo1) (0 Bo2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Bo1 x1) (neg Bo2 y1)
    data BooleanRingLang : Set where
      *L :
        BooleanRingLang ->
        BooleanRingLang ->
        BooleanRingLang
      1L : BooleanRingLang
      +L :
        BooleanRingLang ->
        BooleanRingLang ->
        BooleanRingLang
      0L : BooleanRingLang
      negL :
        BooleanRingLang ->
        BooleanRingLang
    data BooleanRingOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> BooleanRingOpenLang n
      *OL :
        BooleanRingOpenLang n ->
        BooleanRingOpenLang n ->
        BooleanRingOpenLang n
      1OL : BooleanRingOpenLang n
      +OL :
        BooleanRingOpenLang n ->
        BooleanRingOpenLang n ->
        BooleanRingOpenLang n
      0OL : BooleanRingOpenLang n
      negOL :
        BooleanRingOpenLang n ->
        BooleanRingOpenLang n
    evalTerm :
      (A : Set) ->
      BooleanRing A ->
      BooleanRingLang -> A
    evalTerm _ Bo (*L x1 x2) =
      * Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalTerm _ Bo (1L) = 1 Bo
    evalTerm _ Bo (+L x1 x2) =
      + Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalTerm _ Bo (0L) = 0 Bo
    evalTerm _ Bo (negL x1) =
      neg Bo (evalTerm _ Bo x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      BooleanRing A ->
      BooleanRingOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n bo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n bo (*OL
                         x1
                         x2) vars =
      * bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    evalOpenTerm _ n bo (1OL) vars =
      1 bo
    evalOpenTerm _ n bo (+OL
                         x1
                         x2) vars =
      + bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    evalOpenTerm _ n bo (0OL) vars =
      0 bo
    evalOpenTerm _ n bo (negOL
                         x1) vars =
      neg bo
        (evalOpenTerm _ n bo x1 vars)
  
  module BoundedDistributiveLattice where
    record BoundedDistributiveLattice
      (A : Set) : Set where
      constructor BoundedDistributiveLatticeC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
        leftModular_*_+ :
          (x : A) (y : A) (z : A) ->
          + (* x y) (* x z) ==
            * x (+ y (* x z))
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
    record BoundedDistributiveLatticeSig
      (AS : Set) : Set where
      constructor BoundedDistributiveLatticeSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        1S : AS
    record BoundedDistributiveLatticeProd
      (AP : Set) : Set where
      constructor BoundedDistributiveLatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        1P : Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
        leftModular_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (*P xP yP) (*P xP zP) ==
            *P xP (+P yP (*P xP zP))
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
    record BoundedDistributiveLatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedDistributiveLattice
         A1)
      (Bo2 : BoundedDistributiveLattice
         A2) : Set where
      constructor BoundedDistributiveLatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
        pres-0 : hom (0 Bo1) == 0 Bo2
        pres-1 : hom (1 Bo1) == 1 Bo2
    record BoundedDistributiveLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedDistributiveLattice
         A1)
      (Bo2 : BoundedDistributiveLattice
         A2) : Set where
      constructor BoundedDistributiveLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
        interp-0 :
          interp (0 Bo1) (0 Bo2)
        interp-1 :
          interp (1 Bo1) (1 Bo2)
    data BoundedDistributiveLatticeLang
      : Set where
      *L :
        BoundedDistributiveLatticeLang ->
        BoundedDistributiveLatticeLang ->
        BoundedDistributiveLatticeLang
      +L :
        BoundedDistributiveLatticeLang ->
        BoundedDistributiveLatticeLang ->
        BoundedDistributiveLatticeLang
      0L :
        BoundedDistributiveLatticeLang
      1L :
        BoundedDistributiveLatticeLang
    data BoundedDistributiveLatticeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        BoundedDistributiveLatticeOpenLang
          n
      *OL :
        BoundedDistributiveLatticeOpenLang
          n ->
        BoundedDistributiveLatticeOpenLang
          n ->
        BoundedDistributiveLatticeOpenLang
          n
      +OL :
        BoundedDistributiveLatticeOpenLang
          n ->
        BoundedDistributiveLatticeOpenLang
          n ->
        BoundedDistributiveLatticeOpenLang
          n
      0OL :
        BoundedDistributiveLatticeOpenLang
          n
      1OL :
        BoundedDistributiveLatticeOpenLang
          n
    evalTerm :
      (A : Set) ->
      BoundedDistributiveLattice A ->
      BoundedDistributiveLatticeLang ->
      A
    evalTerm _ Bo (*L x1 x2) =
      * Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalTerm _ Bo (+L x1 x2) =
      + Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalTerm _ Bo (0L) = 0 Bo
    evalTerm _ Bo (1L) = 1 Bo
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      BoundedDistributiveLattice A ->
      BoundedDistributiveLatticeOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n bo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n bo (*OL
                         x1
                         x2) vars =
      * bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    evalOpenTerm _ n bo (+OL
                         x1
                         x2) vars =
      + bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    evalOpenTerm _ n bo (0OL) vars =
      0 bo
    evalOpenTerm _ n bo (1OL) vars =
      1 bo
  
  module BoundedJoinLattice where
    record BoundedJoinLattice
      (A : Set) : Set where
      constructor BoundedJoinLatticeC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        * : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
    record BoundedJoinLatticeSig
      (AS : Set) : Set where
      constructor BoundedJoinLatticeSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
        *S : AS -> AS -> AS
    record BoundedJoinLatticeProd
      (AP : Set) : Set where
      constructor BoundedJoinLatticeProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
    record BoundedJoinLatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedJoinLattice A1)
      (Bo2 : BoundedJoinLattice A2) :
      Set where
      constructor BoundedJoinLatticeHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
        pres-0 : hom (0 Bo1) == 0 Bo2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
    record BoundedJoinLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedJoinLattice A1)
      (Bo2 : BoundedJoinLattice A2) :
      Set where
      constructor BoundedJoinLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
        interp-0 :
          interp (0 Bo1) (0 Bo2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
    data BoundedJoinLatticeLang
      : Set where
      +L :
        BoundedJoinLatticeLang ->
        BoundedJoinLatticeLang ->
        BoundedJoinLatticeLang
      0L : BoundedJoinLatticeLang
      *L :
        BoundedJoinLatticeLang ->
        BoundedJoinLatticeLang ->
        BoundedJoinLatticeLang
    data BoundedJoinLatticeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        BoundedJoinLatticeOpenLang n
      +OL :
        BoundedJoinLatticeOpenLang n ->
        BoundedJoinLatticeOpenLang n ->
        BoundedJoinLatticeOpenLang n
      0OL :
        BoundedJoinLatticeOpenLang n
      *OL :
        BoundedJoinLatticeOpenLang n ->
        BoundedJoinLatticeOpenLang n ->
        BoundedJoinLatticeOpenLang n
    evalTerm :
      (A : Set) ->
      BoundedJoinLattice A ->
      BoundedJoinLatticeLang -> A
    evalTerm _ Bo (+L x1 x2) =
      + Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalTerm _ Bo (0L) = 0 Bo
    evalTerm _ Bo (*L x1 x2) =
      * Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      BoundedJoinLattice A ->
      BoundedJoinLatticeOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n bo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n bo (+OL
                         x1
                         x2) vars =
      + bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    evalOpenTerm _ n bo (0OL) vars =
      0 bo
    evalOpenTerm _ n bo (*OL
                         x1
                         x2) vars =
      * bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
  
  module BoundedJoinSemilattice where
    record BoundedJoinSemilattice
      (A : Set) : Set where
      constructor BoundedJoinSemilatticeC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        idempotent_+ :
          (x : A) -> + x x == x
    record BoundedJoinSemilatticeSig
      (AS : Set) : Set where
      constructor BoundedJoinSemilatticeSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
    record BoundedJoinSemilatticeProd
      (AP : Set) : Set where
      constructor BoundedJoinSemilatticeProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record BoundedJoinSemilatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedJoinSemilattice
         A1)
      (Bo2 : BoundedJoinSemilattice
         A2) : Set where
      constructor BoundedJoinSemilatticeHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
        pres-0 : hom (0 Bo1) == 0 Bo2
    record BoundedJoinSemilatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedJoinSemilattice
         A1)
      (Bo2 : BoundedJoinSemilattice
         A2) : Set where
      constructor BoundedJoinSemilatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
        interp-0 :
          interp (0 Bo1) (0 Bo2)
    data BoundedJoinSemilatticeLang
      : Set where
      +L :
        BoundedJoinSemilatticeLang ->
        BoundedJoinSemilatticeLang ->
        BoundedJoinSemilatticeLang
      0L : BoundedJoinSemilatticeLang
    data BoundedJoinSemilatticeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        BoundedJoinSemilatticeOpenLang n
      +OL :
        BoundedJoinSemilatticeOpenLang
          n ->
        BoundedJoinSemilatticeOpenLang
          n ->
        BoundedJoinSemilatticeOpenLang n
      0OL :
        BoundedJoinSemilatticeOpenLang n
    evalTerm :
      (A : Set) ->
      BoundedJoinSemilattice A ->
      BoundedJoinSemilatticeLang -> A
    evalTerm _ Bo (+L x1 x2) =
      + Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalTerm _ Bo (0L) = 0 Bo
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      BoundedJoinSemilattice A ->
      BoundedJoinSemilatticeOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n bo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n bo (+OL
                         x1
                         x2) vars =
      + bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    evalOpenTerm _ n bo (0OL) vars =
      0 bo
  
  module BoundedLattice where
    record BoundedLattice
      (A : Set) : Set where
      constructor BoundedLatticeC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
    record BoundedLatticeSig
      (AS : Set) : Set where
      constructor BoundedLatticeSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        1S : AS
    record BoundedLatticeProd
      (AP : Set) : Set where
      constructor BoundedLatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        1P : Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
    record BoundedLatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedLattice A1)
      (Bo2 : BoundedLattice A2) :
      Set where
      constructor BoundedLatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
        pres-0 : hom (0 Bo1) == 0 Bo2
        pres-1 : hom (1 Bo1) == 1 Bo2
    record BoundedLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedLattice A1)
      (Bo2 : BoundedLattice A2) :
      Set where
      constructor BoundedLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
        interp-0 :
          interp (0 Bo1) (0 Bo2)
        interp-1 :
          interp (1 Bo1) (1 Bo2)
    data BoundedLatticeLang
      : Set where
      *L :
        BoundedLatticeLang ->
        BoundedLatticeLang ->
        BoundedLatticeLang
      +L :
        BoundedLatticeLang ->
        BoundedLatticeLang ->
        BoundedLatticeLang
      0L : BoundedLatticeLang
      1L : BoundedLatticeLang
    data BoundedLatticeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        BoundedLatticeOpenLang n
      *OL :
        BoundedLatticeOpenLang n ->
        BoundedLatticeOpenLang n ->
        BoundedLatticeOpenLang n
      +OL :
        BoundedLatticeOpenLang n ->
        BoundedLatticeOpenLang n ->
        BoundedLatticeOpenLang n
      0OL : BoundedLatticeOpenLang n
      1OL : BoundedLatticeOpenLang n
    evalTerm :
      (A : Set) ->
      BoundedLattice A ->
      BoundedLatticeLang -> A
    evalTerm _ Bo (*L x1 x2) =
      * Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalTerm _ Bo (+L x1 x2) =
      + Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalTerm _ Bo (0L) = 0 Bo
    evalTerm _ Bo (1L) = 1 Bo
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      BoundedLattice A ->
      BoundedLatticeOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n bo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n bo (*OL
                         x1
                         x2) vars =
      * bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    evalOpenTerm _ n bo (+OL
                         x1
                         x2) vars =
      + bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    evalOpenTerm _ n bo (0OL) vars =
      0 bo
    evalOpenTerm _ n bo (1OL) vars =
      1 bo
  
  module BoundedMeetLattice where
    record BoundedMeetLattice
      (A : Set) : Set where
      constructor BoundedMeetLatticeC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
    record BoundedMeetLatticeSig
      (AS : Set) : Set where
      constructor BoundedMeetLatticeSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
        +S : AS -> AS -> AS
    record BoundedMeetLatticeProd
      (AP : Set) : Set where
      constructor BoundedMeetLatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
    record BoundedMeetLatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedMeetLattice A1)
      (Bo2 : BoundedMeetLattice A2) :
      Set where
      constructor BoundedMeetLatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
        pres-1 : hom (1 Bo1) == 1 Bo2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
    record BoundedMeetLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedMeetLattice A1)
      (Bo2 : BoundedMeetLattice A2) :
      Set where
      constructor BoundedMeetLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
        interp-1 :
          interp (1 Bo1) (1 Bo2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
    data BoundedMeetLatticeLang
      : Set where
      *L :
        BoundedMeetLatticeLang ->
        BoundedMeetLatticeLang ->
        BoundedMeetLatticeLang
      1L : BoundedMeetLatticeLang
      +L :
        BoundedMeetLatticeLang ->
        BoundedMeetLatticeLang ->
        BoundedMeetLatticeLang
    data BoundedMeetLatticeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        BoundedMeetLatticeOpenLang n
      *OL :
        BoundedMeetLatticeOpenLang n ->
        BoundedMeetLatticeOpenLang n ->
        BoundedMeetLatticeOpenLang n
      1OL :
        BoundedMeetLatticeOpenLang n
      +OL :
        BoundedMeetLatticeOpenLang n ->
        BoundedMeetLatticeOpenLang n ->
        BoundedMeetLatticeOpenLang n
    evalTerm :
      (A : Set) ->
      BoundedMeetLattice A ->
      BoundedMeetLatticeLang -> A
    evalTerm _ Bo (*L x1 x2) =
      * Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalTerm _ Bo (1L) = 1 Bo
    evalTerm _ Bo (+L x1 x2) =
      + Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      BoundedMeetLattice A ->
      BoundedMeetLatticeOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n bo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n bo (*OL
                         x1
                         x2) vars =
      * bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    evalOpenTerm _ n bo (1OL) vars =
      1 bo
    evalOpenTerm _ n bo (+OL
                         x1
                         x2) vars =
      + bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
  
  module BoundedMeetSemilattice where
    record BoundedMeetSemilattice
      (A : Set) : Set where
      constructor BoundedMeetSemilatticeC
      field
        * : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        idempotent_* :
          (x : A) -> * x x == x
    record BoundedMeetSemilatticeSig
      (AS : Set) : Set where
      constructor BoundedMeetSemilatticeSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
    record BoundedMeetSemilatticeProd
      (AP : Set) : Set where
      constructor BoundedMeetSemilatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
    record BoundedMeetSemilatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedMeetSemilattice
         A1)
      (Bo2 : BoundedMeetSemilattice
         A2) : Set where
      constructor BoundedMeetSemilatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
        pres-1 : hom (1 Bo1) == 1 Bo2
    record BoundedMeetSemilatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedMeetSemilattice
         A1)
      (Bo2 : BoundedMeetSemilattice
         A2) : Set where
      constructor BoundedMeetSemilatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
        interp-1 :
          interp (1 Bo1) (1 Bo2)
    data BoundedMeetSemilatticeLang
      : Set where
      *L :
        BoundedMeetSemilatticeLang ->
        BoundedMeetSemilatticeLang ->
        BoundedMeetSemilatticeLang
      1L : BoundedMeetSemilatticeLang
    data BoundedMeetSemilatticeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        BoundedMeetSemilatticeOpenLang n
      *OL :
        BoundedMeetSemilatticeOpenLang
          n ->
        BoundedMeetSemilatticeOpenLang
          n ->
        BoundedMeetSemilatticeOpenLang n
      1OL :
        BoundedMeetSemilatticeOpenLang n
    evalTerm :
      (A : Set) ->
      BoundedMeetSemilattice A ->
      BoundedMeetSemilatticeLang -> A
    evalTerm _ Bo (*L x1 x2) =
      * Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalTerm _ Bo (1L) = 1 Bo
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      BoundedMeetSemilattice A ->
      BoundedMeetSemilatticeOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n bo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n bo (*OL
                         x1
                         x2) vars =
      * bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    evalOpenTerm _ n bo (1OL) vars =
      1 bo
  
  module BoundedModularLattice where
    record BoundedModularLattice
      (A : Set) : Set where
      constructor BoundedModularLatticeC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        leftModular_*_+ :
          (x : A) (y : A) (z : A) ->
          + (* x y) (* x z) ==
            * x (+ y (* x z))
    record BoundedModularLatticeSig
      (AS : Set) : Set where
      constructor BoundedModularLatticeSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        1S : AS
    record BoundedModularLatticeProd
      (AP : Set) : Set where
      constructor BoundedModularLatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        1P : Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        leftModular_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (*P xP yP) (*P xP zP) ==
            *P xP (+P yP (*P xP zP))
    record BoundedModularLatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedModularLattice A1)
      (Bo2 : BoundedModularLattice
         A2) : Set where
      constructor BoundedModularLatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
        pres-0 : hom (0 Bo1) == 0 Bo2
        pres-1 : hom (1 Bo1) == 1 Bo2
    record BoundedModularLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedModularLattice A1)
      (Bo2 : BoundedModularLattice
         A2) : Set where
      constructor BoundedModularLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
        interp-0 :
          interp (0 Bo1) (0 Bo2)
        interp-1 :
          interp (1 Bo1) (1 Bo2)
    data BoundedModularLatticeLang
      : Set where
      *L :
        BoundedModularLatticeLang ->
        BoundedModularLatticeLang ->
        BoundedModularLatticeLang
      +L :
        BoundedModularLatticeLang ->
        BoundedModularLatticeLang ->
        BoundedModularLatticeLang
      0L : BoundedModularLatticeLang
      1L : BoundedModularLatticeLang
    data BoundedModularLatticeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        BoundedModularLatticeOpenLang n
      *OL :
        BoundedModularLatticeOpenLang
          n ->
        BoundedModularLatticeOpenLang
          n ->
        BoundedModularLatticeOpenLang n
      +OL :
        BoundedModularLatticeOpenLang
          n ->
        BoundedModularLatticeOpenLang
          n ->
        BoundedModularLatticeOpenLang n
      0OL :
        BoundedModularLatticeOpenLang n
      1OL :
        BoundedModularLatticeOpenLang n
    evalTerm :
      (A : Set) ->
      BoundedModularLattice A ->
      BoundedModularLatticeLang -> A
    evalTerm _ Bo (*L x1 x2) =
      * Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalTerm _ Bo (+L x1 x2) =
      + Bo (evalTerm _ Bo x1)
        (evalTerm _ Bo x2)
    evalTerm _ Bo (0L) = 0 Bo
    evalTerm _ Bo (1L) = 1 Bo
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      BoundedModularLattice A ->
      BoundedModularLatticeOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n bo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n bo (*OL
                         x1
                         x2) vars =
      * bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    evalOpenTerm _ n bo (+OL
                         x1
                         x2) vars =
      + bo
        (evalOpenTerm _ n bo x1 vars)
        (evalOpenTerm _ n bo x2 vars)
    evalOpenTerm _ n bo (0OL) vars =
      0 bo
    evalOpenTerm _ n bo (1OL) vars =
      1 bo
  
  module CancellativeCommutativeMonoid where
    record CancellativeCommutativeMonoid
      (A : Set) : Set where
      constructor CancellativeCommutativeMonoidC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CancellativeCommutativeMonoidSig
      (AS : Set) : Set where
      constructor CancellativeCommutativeMonoidSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record CancellativeCommutativeMonoidProd
      (AP : Set) : Set where
      constructor CancellativeCommutativeMonoidProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CancellativeCommutativeMonoidHom
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeCommutativeMonoid
         A1)
      (Ca2 : CancellativeCommutativeMonoid
         A2) : Set where
      constructor CancellativeCommutativeMonoidHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Ca1) == e Ca2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ca1 x1 x2) ==
            op Ca2 (hom x1) (hom x2)
    record CancellativeCommutativeMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeCommutativeMonoid
         A1)
      (Ca2 : CancellativeCommutativeMonoid
         A2) : Set where
      constructor CancellativeCommutativeMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Ca1) (e Ca2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ca1 x1 x2)
            (op Ca2 y1 y2)
    data CancellativeCommutativeMonoidLang
      : Set where
      eL :
        CancellativeCommutativeMonoidLang
      opL :
        CancellativeCommutativeMonoidLang ->
        CancellativeCommutativeMonoidLang ->
        CancellativeCommutativeMonoidLang
    data CancellativeCommutativeMonoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CancellativeCommutativeMonoidOpenLang
          n
      eOL :
        CancellativeCommutativeMonoidOpenLang
          n
      opOL :
        CancellativeCommutativeMonoidOpenLang
          n ->
        CancellativeCommutativeMonoidOpenLang
          n ->
        CancellativeCommutativeMonoidOpenLang
          n
    evalTerm :
      (A : Set) ->
      CancellativeCommutativeMonoid
        A ->
      CancellativeCommutativeMonoidLang ->
      A
    evalTerm _ Ca (eL) = e Ca
    evalTerm _ Ca (opL x1 x2) =
      op Ca (evalTerm _ Ca x1)
        (evalTerm _ Ca x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CancellativeCommutativeMonoid
        A ->
      CancellativeCommutativeMonoidOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ca (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ca (eOL) vars =
      e ca
    evalOpenTerm _ n ca (opOL
                         x1
                         x2) vars =
      op ca
        (evalOpenTerm _ n ca x1 vars)
        (evalOpenTerm _ n ca x2 vars)
  
  module CancellativeCommutativeSemigroup where
    record CancellativeCommutativeSemigroup
      (A : Set) : Set where
      constructor CancellativeCommutativeSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
    record CancellativeCommutativeSemigroupSig
      (AS : Set) : Set where
      constructor CancellativeCommutativeSemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record CancellativeCommutativeSemigroupProd
      (AP : Set) : Set where
      constructor CancellativeCommutativeSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
    record CancellativeCommutativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeCommutativeSemigroup
         A1)
      (Ca2 : CancellativeCommutativeSemigroup
         A2) : Set where
      constructor CancellativeCommutativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ca1 x1 x2) ==
            op Ca2 (hom x1) (hom x2)
    record CancellativeCommutativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeCommutativeSemigroup
         A1)
      (Ca2 : CancellativeCommutativeSemigroup
         A2) : Set where
      constructor CancellativeCommutativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ca1 x1 x2)
            (op Ca2 y1 y2)
    data CancellativeCommutativeSemigroupLang
      : Set where
      opL :
        CancellativeCommutativeSemigroupLang ->
        CancellativeCommutativeSemigroupLang ->
        CancellativeCommutativeSemigroupLang
    data CancellativeCommutativeSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CancellativeCommutativeSemigroupOpenLang
          n
      opOL :
        CancellativeCommutativeSemigroupOpenLang
          n ->
        CancellativeCommutativeSemigroupOpenLang
          n ->
        CancellativeCommutativeSemigroupOpenLang
          n
    evalTerm :
      (A : Set) ->
      CancellativeCommutativeSemigroup
        A ->
      CancellativeCommutativeSemigroupLang ->
      A
    evalTerm _ Ca (opL x1 x2) =
      op Ca (evalTerm _ Ca x1)
        (evalTerm _ Ca x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CancellativeCommutativeSemigroup
        A ->
      CancellativeCommutativeSemigroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ca (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ca (opOL
                         x1
                         x2) vars =
      op ca
        (evalOpenTerm _ n ca x1 vars)
        (evalOpenTerm _ n ca x2 vars)
  
  module CancellativeMagma where
    record CancellativeMagma
      (A : Set) : Set where
      constructor CancellativeMagmaC
      field
        op : A -> A -> A
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
    record CancellativeMagmaSig
      (AS : Set) : Set where
      constructor CancellativeMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record CancellativeMagmaProd
      (AP : Set) : Set where
      constructor CancellativeMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
    record CancellativeMagmaHom
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeMagma A1)
      (Ca2 : CancellativeMagma A2) :
      Set where
      constructor CancellativeMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ca1 x1 x2) ==
            op Ca2 (hom x1) (hom x2)
    record CancellativeMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeMagma A1)
      (Ca2 : CancellativeMagma A2) :
      Set where
      constructor CancellativeMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ca1 x1 x2)
            (op Ca2 y1 y2)
    data CancellativeMagmaLang
      : Set where
      opL :
        CancellativeMagmaLang ->
        CancellativeMagmaLang ->
        CancellativeMagmaLang
    data CancellativeMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CancellativeMagmaOpenLang n
      opOL :
        CancellativeMagmaOpenLang n ->
        CancellativeMagmaOpenLang n ->
        CancellativeMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      CancellativeMagma A ->
      CancellativeMagmaLang -> A
    evalTerm _ Ca (opL x1 x2) =
      op Ca (evalTerm _ Ca x1)
        (evalTerm _ Ca x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CancellativeMagma A ->
      CancellativeMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ca (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ca (opOL
                         x1
                         x2) vars =
      op ca
        (evalOpenTerm _ n ca x1 vars)
        (evalOpenTerm _ n ca x2 vars)
  
  module CancellativeMonoid where
    record CancellativeMonoid
      (A : Set) : Set where
      constructor CancellativeMonoidC
      field
        op : A -> A -> A
        e : A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
    record CancellativeMonoidSig
      (AS : Set) : Set where
      constructor CancellativeMonoidSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record CancellativeMonoidProd
      (AP : Set) : Set where
      constructor CancellativeMonoidProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
    record CancellativeMonoidHom
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeMonoid A1)
      (Ca2 : CancellativeMonoid A2) :
      Set where
      constructor CancellativeMonoidHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ca1 x1 x2) ==
            op Ca2 (hom x1) (hom x2)
        pres-e : hom (e Ca1) == e Ca2
    record CancellativeMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeMonoid A1)
      (Ca2 : CancellativeMonoid A2) :
      Set where
      constructor CancellativeMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ca1 x1 x2)
            (op Ca2 y1 y2)
        interp-e :
          interp (e Ca1) (e Ca2)
    data CancellativeMonoidLang
      : Set where
      opL :
        CancellativeMonoidLang ->
        CancellativeMonoidLang ->
        CancellativeMonoidLang
      eL : CancellativeMonoidLang
    data CancellativeMonoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CancellativeMonoidOpenLang n
      opOL :
        CancellativeMonoidOpenLang n ->
        CancellativeMonoidOpenLang n ->
        CancellativeMonoidOpenLang n
      eOL :
        CancellativeMonoidOpenLang n
    evalTerm :
      (A : Set) ->
      CancellativeMonoid A ->
      CancellativeMonoidLang -> A
    evalTerm _ Ca (opL x1 x2) =
      op Ca (evalTerm _ Ca x1)
        (evalTerm _ Ca x2)
    evalTerm _ Ca (eL) = e Ca
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CancellativeMonoid A ->
      CancellativeMonoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ca (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ca (opOL
                         x1
                         x2) vars =
      op ca
        (evalOpenTerm _ n ca x1 vars)
        (evalOpenTerm _ n ca x2 vars)
    evalOpenTerm _ n ca (eOL) vars =
      e ca
  
  module CancellativeSemigroup where
    record CancellativeSemigroup
      (A : Set) : Set where
      constructor CancellativeSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
    record CancellativeSemigroupSig
      (AS : Set) : Set where
      constructor CancellativeSemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record CancellativeSemigroupProd
      (AP : Set) : Set where
      constructor CancellativeSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
    record CancellativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeSemigroup A1)
      (Ca2 : CancellativeSemigroup
         A2) : Set where
      constructor CancellativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ca1 x1 x2) ==
            op Ca2 (hom x1) (hom x2)
    record CancellativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeSemigroup A1)
      (Ca2 : CancellativeSemigroup
         A2) : Set where
      constructor CancellativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ca1 x1 x2)
            (op Ca2 y1 y2)
    data CancellativeSemigroupLang
      : Set where
      opL :
        CancellativeSemigroupLang ->
        CancellativeSemigroupLang ->
        CancellativeSemigroupLang
    data CancellativeSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CancellativeSemigroupOpenLang n
      opOL :
        CancellativeSemigroupOpenLang
          n ->
        CancellativeSemigroupOpenLang
          n ->
        CancellativeSemigroupOpenLang n
    evalTerm :
      (A : Set) ->
      CancellativeSemigroup A ->
      CancellativeSemigroupLang -> A
    evalTerm _ Ca (opL x1 x2) =
      op Ca (evalTerm _ Ca x1)
        (evalTerm _ Ca x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CancellativeSemigroup A ->
      CancellativeSemigroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ca (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ca (opOL
                         x1
                         x2) vars =
      op ca
        (evalOpenTerm _ n ca x1 vars)
        (evalOpenTerm _ n ca x2 vars)
  
  module Carrier where
    record Carrier
      (A : Set) : Set where
      constructor CarrierC
      field
        
    record CarrierSig
      (AS : Set) : Set where
      constructor CarrierSigSigC
      field
        
    record CarrierProd
      (AP : Set) : Set where
      constructor CarrierProdC
      field
        
    record CarrierHom
      (A1 : Set) (A2 : Set)
      (Ca1 : Carrier A1)
      (Ca2 : Carrier A2) : Set where
      constructor CarrierHomC
      field
        hom : A1 -> A2
    record CarrierRelInterp
      (A1 : Set) (A2 : Set)
      (Ca1 : Carrier A1)
      (Ca2 : Carrier A2) : Set where
      constructor CarrierRelInterpC
      field
        interp : A1 -> A2 -> Set
    data CarrierLang : Set where
      
    data CarrierOpenLang
      (n : Nat) : Set where
      v : Fin n -> CarrierOpenLang n
    evalTerm :
      (A : Set) ->
      Carrier A -> CarrierLang -> A
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Carrier A ->
      CarrierOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ca (v
                         fin) vars = lookup _ n fin vars
  
  module CommutativeAdditiveMagma where
    record CommutativeAdditiveMagma
      (A : Set) : Set where
      constructor CommutativeAdditiveMagmaC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
    record CommutativeAdditiveMagmaSig
      (AS : Set) : Set where
      constructor CommutativeAdditiveMagmaSigSigC
      field
        +S : AS -> AS -> AS
    record CommutativeAdditiveMagmaProd
      (AP : Set) : Set where
      constructor CommutativeAdditiveMagmaProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
    record CommutativeAdditiveMagmaHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeAdditiveMagma
         A1)
      (Co2 : CommutativeAdditiveMagma
         A2) : Set where
      constructor CommutativeAdditiveMagmaHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Co1 x1 x2) ==
            + Co2 (hom x1) (hom x2)
    record CommutativeAdditiveMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeAdditiveMagma
         A1)
      (Co2 : CommutativeAdditiveMagma
         A2) : Set where
      constructor CommutativeAdditiveMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Co1 x1 x2)
            (+ Co2 y1 y2)
    data CommutativeAdditiveMagmaLang
      : Set where
      +L :
        CommutativeAdditiveMagmaLang ->
        CommutativeAdditiveMagmaLang ->
        CommutativeAdditiveMagmaLang
    data CommutativeAdditiveMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CommutativeAdditiveMagmaOpenLang
          n
      +OL :
        CommutativeAdditiveMagmaOpenLang
          n ->
        CommutativeAdditiveMagmaOpenLang
          n ->
        CommutativeAdditiveMagmaOpenLang
          n
    evalTerm :
      (A : Set) ->
      CommutativeAdditiveMagma A ->
      CommutativeAdditiveMagmaLang ->
      A
    evalTerm _ Co (+L x1 x2) =
      + Co (evalTerm _ Co x1)
        (evalTerm _ Co x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CommutativeAdditiveMagma A ->
      CommutativeAdditiveMagmaOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n co (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n co (+OL
                         x1
                         x2) vars =
      + co
        (evalOpenTerm _ n co x1 vars)
        (evalOpenTerm _ n co x2 vars)
  
  module CommutativeGroup where
    record CommutativeGroup
      (A : Set) : Set where
      constructor CommutativeGroupC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        inv : A -> A
        leftInverse_inv_op_e :
          (x : A) -> op x (inv x) == e
        rightInverse_inv_op_e :
          (x : A) -> op (inv x) x == e
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CommutativeGroupSig
      (AS : Set) : Set where
      constructor CommutativeGroupSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
        invS : AS -> AS
    record CommutativeGroupProd
      (AP : Set) : Set where
      constructor CommutativeGroupProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP xP (invP xP) == eP
        rightInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (invP xP) xP == eP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CommutativeGroupHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeGroup A1)
      (Co2 : CommutativeGroup A2) :
      Set where
      constructor CommutativeGroupHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Co1) == e Co2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
        pres-inv :
          (x1 : A1) ->
          hom (inv Co1 x1) ==
            inv Co2 (hom x1)
    record CommutativeGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeGroup A1)
      (Co2 : CommutativeGroup A2) :
      Set where
      constructor CommutativeGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Co1) (e Co2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Co1 x1) (inv Co2 y1)
    data CommutativeGroupLang
      : Set where
      eL : CommutativeGroupLang
      opL :
        CommutativeGroupLang ->
        CommutativeGroupLang ->
        CommutativeGroupLang
      invL :
        CommutativeGroupLang ->
        CommutativeGroupLang
    data CommutativeGroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CommutativeGroupOpenLang n
      eOL : CommutativeGroupOpenLang n
      opOL :
        CommutativeGroupOpenLang n ->
        CommutativeGroupOpenLang n ->
        CommutativeGroupOpenLang n
      invOL :
        CommutativeGroupOpenLang n ->
        CommutativeGroupOpenLang n
    evalTerm :
      (A : Set) ->
      CommutativeGroup A ->
      CommutativeGroupLang -> A
    evalTerm _ Co (eL) = e Co
    evalTerm _ Co (opL x1 x2) =
      op Co (evalTerm _ Co x1)
        (evalTerm _ Co x2)
    evalTerm _ Co (invL x1) =
      inv Co (evalTerm _ Co x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CommutativeGroup A ->
      CommutativeGroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n co (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n co (eOL) vars =
      e co
    evalOpenTerm _ n co (opOL
                         x1
                         x2) vars =
      op co
        (evalOpenTerm _ n co x1 vars)
        (evalOpenTerm _ n co x2 vars)
    evalOpenTerm _ n co (invOL
                         x1) vars =
      inv co
        (evalOpenTerm _ n co x1 vars)
  
  module CommutativeMagma where
    record CommutativeMagma
      (A : Set) : Set where
      constructor CommutativeMagmaC
      field
        op : A -> A -> A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CommutativeMagmaSig
      (AS : Set) : Set where
      constructor CommutativeMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record CommutativeMagmaProd
      (AP : Set) : Set where
      constructor CommutativeMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CommutativeMagmaHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMagma A1)
      (Co2 : CommutativeMagma A2) :
      Set where
      constructor CommutativeMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
    record CommutativeMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMagma A1)
      (Co2 : CommutativeMagma A2) :
      Set where
      constructor CommutativeMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
    data CommutativeMagmaLang
      : Set where
      opL :
        CommutativeMagmaLang ->
        CommutativeMagmaLang ->
        CommutativeMagmaLang
    data CommutativeMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CommutativeMagmaOpenLang n
      opOL :
        CommutativeMagmaOpenLang n ->
        CommutativeMagmaOpenLang n ->
        CommutativeMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      CommutativeMagma A ->
      CommutativeMagmaLang -> A
    evalTerm _ Co (opL x1 x2) =
      op Co (evalTerm _ Co x1)
        (evalTerm _ Co x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CommutativeMagma A ->
      CommutativeMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n co (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n co (opOL
                         x1
                         x2) vars =
      op co
        (evalOpenTerm _ n co x1 vars)
        (evalOpenTerm _ n co x2 vars)
  
  module CommutativeMonoid where
    record CommutativeMonoid
      (A : Set) : Set where
      constructor CommutativeMonoidC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        e : A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CommutativeMonoidSig
      (AS : Set) : Set where
      constructor CommutativeMonoidSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record CommutativeMonoidProd
      (AP : Set) : Set where
      constructor CommutativeMonoidProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CommutativeMonoidHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMonoid A1)
      (Co2 : CommutativeMonoid A2) :
      Set where
      constructor CommutativeMonoidHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
        pres-e : hom (e Co1) == e Co2
    record CommutativeMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMonoid A1)
      (Co2 : CommutativeMonoid A2) :
      Set where
      constructor CommutativeMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
        interp-e :
          interp (e Co1) (e Co2)
    data CommutativeMonoidLang
      : Set where
      opL :
        CommutativeMonoidLang ->
        CommutativeMonoidLang ->
        CommutativeMonoidLang
      eL : CommutativeMonoidLang
    data CommutativeMonoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CommutativeMonoidOpenLang n
      opOL :
        CommutativeMonoidOpenLang n ->
        CommutativeMonoidOpenLang n ->
        CommutativeMonoidOpenLang n
      eOL :
        CommutativeMonoidOpenLang n
    evalTerm :
      (A : Set) ->
      CommutativeMonoid A ->
      CommutativeMonoidLang -> A
    evalTerm _ Co (opL x1 x2) =
      op Co (evalTerm _ Co x1)
        (evalTerm _ Co x2)
    evalTerm _ Co (eL) = e Co
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CommutativeMonoid A ->
      CommutativeMonoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n co (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n co (opOL
                         x1
                         x2) vars =
      op co
        (evalOpenTerm _ n co x1 vars)
        (evalOpenTerm _ n co x2 vars)
    evalOpenTerm _ n co (eOL) vars =
      e co
  
  module CommutativeMonoid1 where
    record CommutativeMonoid1
      (A : Set) : Set where
      constructor CommutativeMonoid1C
      field
        1 : A
        op : A -> A -> A
        lunit_1 : (x : A) -> op 1 x == x
        runit_1 : (x : A) -> op x 1 == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CommutativeMonoid1Sig
      (AS : Set) : Set where
      constructor CommutativeMonoid1SigSigC
      field
        1S : AS
        opS : AS -> AS -> AS
    record CommutativeMonoid1Prod
      (AP : Set) : Set where
      constructor CommutativeMonoid1ProdC
      field
        1P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          opP 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          opP xP 1P == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CommutativeMonoid1Hom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMonoid1 A1)
      (Co2 : CommutativeMonoid1 A2) :
      Set where
      constructor CommutativeMonoid1HomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Co1) == 1 Co2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
    record CommutativeMonoid1RelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMonoid1 A1)
      (Co2 : CommutativeMonoid1 A2) :
      Set where
      constructor CommutativeMonoid1RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Co1) (1 Co2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
    data CommutativeMonoid1Lang
      : Set where
      1L : CommutativeMonoid1Lang
      opL :
        CommutativeMonoid1Lang ->
        CommutativeMonoid1Lang ->
        CommutativeMonoid1Lang
    data CommutativeMonoid1OpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CommutativeMonoid1OpenLang n
      1OL :
        CommutativeMonoid1OpenLang n
      opOL :
        CommutativeMonoid1OpenLang n ->
        CommutativeMonoid1OpenLang n ->
        CommutativeMonoid1OpenLang n
    evalTerm :
      (A : Set) ->
      CommutativeMonoid1 A ->
      CommutativeMonoid1Lang -> A
    evalTerm _ Co (1L) = 1 Co
    evalTerm _ Co (opL x1 x2) =
      op Co (evalTerm _ Co x1)
        (evalTerm _ Co x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CommutativeMonoid1 A ->
      CommutativeMonoid1OpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n co (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n co (1OL) vars =
      1 co
    evalOpenTerm _ n co (opOL
                         x1
                         x2) vars =
      op co
        (evalOpenTerm _ n co x1 vars)
        (evalOpenTerm _ n co x2 vars)
  
  module CommutativePointedMagma where
    record CommutativePointedMagma
      (A : Set) : Set where
      constructor CommutativePointedMagmaC
      field
        op : A -> A -> A
        e : A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CommutativePointedMagmaSig
      (AS : Set) : Set where
      constructor CommutativePointedMagmaSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record CommutativePointedMagmaProd
      (AP : Set) : Set where
      constructor CommutativePointedMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CommutativePointedMagmaHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativePointedMagma
         A1)
      (Co2 : CommutativePointedMagma
         A2) : Set where
      constructor CommutativePointedMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
        pres-e : hom (e Co1) == e Co2
    record CommutativePointedMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativePointedMagma
         A1)
      (Co2 : CommutativePointedMagma
         A2) : Set where
      constructor CommutativePointedMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
        interp-e :
          interp (e Co1) (e Co2)
    data CommutativePointedMagmaLang
      : Set where
      opL :
        CommutativePointedMagmaLang ->
        CommutativePointedMagmaLang ->
        CommutativePointedMagmaLang
      eL : CommutativePointedMagmaLang
    data CommutativePointedMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CommutativePointedMagmaOpenLang
          n
      opOL :
        CommutativePointedMagmaOpenLang
          n ->
        CommutativePointedMagmaOpenLang
          n ->
        CommutativePointedMagmaOpenLang
          n
      eOL :
        CommutativePointedMagmaOpenLang
          n
    evalTerm :
      (A : Set) ->
      CommutativePointedMagma A ->
      CommutativePointedMagmaLang -> A
    evalTerm _ Co (opL x1 x2) =
      op Co (evalTerm _ Co x1)
        (evalTerm _ Co x2)
    evalTerm _ Co (eL) = e Co
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CommutativePointedMagma A ->
      CommutativePointedMagmaOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n co (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n co (opOL
                         x1
                         x2) vars =
      op co
        (evalOpenTerm _ n co x1 vars)
        (evalOpenTerm _ n co x2 vars)
    evalOpenTerm _ n co (eOL) vars =
      e co
  
  module CommutativeRing where
    record CommutativeRing
      (A : Set) : Set where
      constructor CommutativeRingC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
    record CommutativeRingSig
      (AS : Set) : Set where
      constructor CommutativeRingSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
    record CommutativeRingProd
      (AP : Set) : Set where
      constructor CommutativeRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
    record CommutativeRingHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeRing A1)
      (Co2 : CommutativeRing A2) :
      Set where
      constructor CommutativeRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Co1 x1 x2) ==
            * Co2 (hom x1) (hom x2)
        pres-1 : hom (1 Co1) == 1 Co2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Co1 x1 x2) ==
            + Co2 (hom x1) (hom x2)
        pres-0 : hom (0 Co1) == 0 Co2
        pres-neg :
          (x1 : A1) ->
          hom (neg Co1 x1) ==
            neg Co2 (hom x1)
    record CommutativeRingRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeRing A1)
      (Co2 : CommutativeRing A2) :
      Set where
      constructor CommutativeRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Co1 x1 x2)
            (* Co2 y1 y2)
        interp-1 :
          interp (1 Co1) (1 Co2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Co1 x1 x2)
            (+ Co2 y1 y2)
        interp-0 :
          interp (0 Co1) (0 Co2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Co1 x1) (neg Co2 y1)
    data CommutativeRingLang
      : Set where
      *L :
        CommutativeRingLang ->
        CommutativeRingLang ->
        CommutativeRingLang
      1L : CommutativeRingLang
      +L :
        CommutativeRingLang ->
        CommutativeRingLang ->
        CommutativeRingLang
      0L : CommutativeRingLang
      negL :
        CommutativeRingLang ->
        CommutativeRingLang
    data CommutativeRingOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CommutativeRingOpenLang n
      *OL :
        CommutativeRingOpenLang n ->
        CommutativeRingOpenLang n ->
        CommutativeRingOpenLang n
      1OL : CommutativeRingOpenLang n
      +OL :
        CommutativeRingOpenLang n ->
        CommutativeRingOpenLang n ->
        CommutativeRingOpenLang n
      0OL : CommutativeRingOpenLang n
      negOL :
        CommutativeRingOpenLang n ->
        CommutativeRingOpenLang n
    evalTerm :
      (A : Set) ->
      CommutativeRing A ->
      CommutativeRingLang -> A
    evalTerm _ Co (*L x1 x2) =
      * Co (evalTerm _ Co x1)
        (evalTerm _ Co x2)
    evalTerm _ Co (1L) = 1 Co
    evalTerm _ Co (+L x1 x2) =
      + Co (evalTerm _ Co x1)
        (evalTerm _ Co x2)
    evalTerm _ Co (0L) = 0 Co
    evalTerm _ Co (negL x1) =
      neg Co (evalTerm _ Co x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CommutativeRing A ->
      CommutativeRingOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n co (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n co (*OL
                         x1
                         x2) vars =
      * co
        (evalOpenTerm _ n co x1 vars)
        (evalOpenTerm _ n co x2 vars)
    evalOpenTerm _ n co (1OL) vars =
      1 co
    evalOpenTerm _ n co (+OL
                         x1
                         x2) vars =
      + co
        (evalOpenTerm _ n co x1 vars)
        (evalOpenTerm _ n co x2 vars)
    evalOpenTerm _ n co (0OL) vars =
      0 co
    evalOpenTerm _ n co (negOL
                         x1) vars =
      neg co
        (evalOpenTerm _ n co x1 vars)
  
  module CommutativeSemigroup where
    record CommutativeSemigroup
      (A : Set) : Set where
      constructor CommutativeSemigroupC
      field
        op : A -> A -> A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record CommutativeSemigroupSig
      (AS : Set) : Set where
      constructor CommutativeSemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record CommutativeSemigroupProd
      (AP : Set) : Set where
      constructor CommutativeSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record CommutativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeSemigroup A1)
      (Co2 : CommutativeSemigroup
         A2) : Set where
      constructor CommutativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
    record CommutativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeSemigroup A1)
      (Co2 : CommutativeSemigroup
         A2) : Set where
      constructor CommutativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
    data CommutativeSemigroupLang
      : Set where
      opL :
        CommutativeSemigroupLang ->
        CommutativeSemigroupLang ->
        CommutativeSemigroupLang
    data CommutativeSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        CommutativeSemigroupOpenLang n
      opOL :
        CommutativeSemigroupOpenLang
          n ->
        CommutativeSemigroupOpenLang
          n ->
        CommutativeSemigroupOpenLang n
    evalTerm :
      (A : Set) ->
      CommutativeSemigroup A ->
      CommutativeSemigroupLang -> A
    evalTerm _ Co (opL x1 x2) =
      op Co (evalTerm _ Co x1)
        (evalTerm _ Co x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      CommutativeSemigroup A ->
      CommutativeSemigroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n co (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n co (opOL
                         x1
                         x2) vars =
      op co
        (evalOpenTerm _ n co x1 vars)
        (evalOpenTerm _ n co x2 vars)
  
  module ComplementSig where
    record ComplementSig
      (A : Set) : Set where
      constructor ComplementSigC
      field
        compl : A -> A
    record ComplementSigSig
      (AS : Set) : Set where
      constructor ComplementSigSigSigC
      field
        complS : AS -> AS
    record ComplementSigProd
      (AP : Set) : Set where
      constructor ComplementSigProdC
      field
        complP :
          Prod AP AP -> Prod AP AP
    record ComplementSigHom
      (A1 : Set) (A2 : Set)
      (Co1 : ComplementSig A1)
      (Co2 : ComplementSig A2) :
      Set where
      constructor ComplementSigHomC
      field
        hom : A1 -> A2
        pres-compl :
          (x1 : A1) ->
          hom (compl Co1 x1) ==
            compl Co2 (hom x1)
    record ComplementSigRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : ComplementSig A1)
      (Co2 : ComplementSig A2) :
      Set where
      constructor ComplementSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-compl :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (compl Co1 x1)
            (compl Co2 y1)
    data ComplementSigLang
      : Set where
      complL :
        ComplementSigLang ->
        ComplementSigLang
    data ComplementSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> ComplementSigOpenLang n
      complOL :
        ComplementSigOpenLang n ->
        ComplementSigOpenLang n
    evalTerm :
      (A : Set) ->
      ComplementSig A ->
      ComplementSigLang -> A
    evalTerm _ Co (complL x1) =
      compl Co (evalTerm _ Co x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      ComplementSig A ->
      ComplementSigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n co (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n co (complOL
                         x1) vars =
      compl co
        (evalOpenTerm _ n co x1 vars)
  
  module DistributiveLattice where
    record DistributiveLattice
      (A : Set) : Set where
      constructor DistributiveLatticeC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
        leftModular_*_+ :
          (x : A) (y : A) (z : A) ->
          + (* x y) (* x z) ==
            * x (+ y (* x z))
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
    record DistributiveLatticeSig
      (AS : Set) : Set where
      constructor DistributiveLatticeSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record DistributiveLatticeProd
      (AP : Set) : Set where
      constructor DistributiveLatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
        leftModular_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (*P xP yP) (*P xP zP) ==
            *P xP (+P yP (*P xP zP))
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
    record DistributiveLatticeHom
      (A1 : Set) (A2 : Set)
      (Di1 : DistributiveLattice A1)
      (Di2 : DistributiveLattice A2) :
      Set where
      constructor DistributiveLatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Di1 x1 x2) ==
            * Di2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Di1 x1 x2) ==
            + Di2 (hom x1) (hom x2)
    record DistributiveLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Di1 : DistributiveLattice A1)
      (Di2 : DistributiveLattice A2) :
      Set where
      constructor DistributiveLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Di1 x1 x2)
            (* Di2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Di1 x1 x2)
            (+ Di2 y1 y2)
    data DistributiveLatticeLang
      : Set where
      *L :
        DistributiveLatticeLang ->
        DistributiveLatticeLang ->
        DistributiveLatticeLang
      +L :
        DistributiveLatticeLang ->
        DistributiveLatticeLang ->
        DistributiveLatticeLang
    data DistributiveLatticeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        DistributiveLatticeOpenLang n
      *OL :
        DistributiveLatticeOpenLang n ->
        DistributiveLatticeOpenLang n ->
        DistributiveLatticeOpenLang n
      +OL :
        DistributiveLatticeOpenLang n ->
        DistributiveLatticeOpenLang n ->
        DistributiveLatticeOpenLang n
    evalTerm :
      (A : Set) ->
      DistributiveLattice A ->
      DistributiveLatticeLang -> A
    evalTerm _ Di (*L x1 x2) =
      * Di (evalTerm _ Di x1)
        (evalTerm _ Di x2)
    evalTerm _ Di (+L x1 x2) =
      + Di (evalTerm _ Di x1)
        (evalTerm _ Di x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      DistributiveLattice A ->
      DistributiveLatticeOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n di (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n di (*OL
                         x1
                         x2) vars =
      * di
        (evalOpenTerm _ n di x1 vars)
        (evalOpenTerm _ n di x2 vars)
    evalOpenTerm _ n di (+OL
                         x1
                         x2) vars =
      + di
        (evalOpenTerm _ n di x1 vars)
        (evalOpenTerm _ n di x2 vars)
  
  module DoubleMonoid where
    record DoubleMonoid
      (A : Set) : Set where
      constructor DoubleMonoidC
      field
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
    record DoubleMonoidSig
      (AS : Set) : Set where
      constructor DoubleMonoidSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
        *S : AS -> AS -> AS
        1S : AS
    record DoubleMonoidProd
      (AP : Set) : Set where
      constructor DoubleMonoidProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
    record DoubleMonoidHom
      (A1 : Set) (A2 : Set)
      (Do1 : DoubleMonoid A1)
      (Do2 : DoubleMonoid A2) :
      Set where
      constructor DoubleMonoidHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Do1 x1 x2) ==
            + Do2 (hom x1) (hom x2)
        pres-0 : hom (0 Do1) == 0 Do2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Do1 x1 x2) ==
            * Do2 (hom x1) (hom x2)
        pres-1 : hom (1 Do1) == 1 Do2
    record DoubleMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Do1 : DoubleMonoid A1)
      (Do2 : DoubleMonoid A2) :
      Set where
      constructor DoubleMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Do1 x1 x2)
            (+ Do2 y1 y2)
        interp-0 :
          interp (0 Do1) (0 Do2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Do1 x1 x2)
            (* Do2 y1 y2)
        interp-1 :
          interp (1 Do1) (1 Do2)
    data DoubleMonoidLang
      : Set where
      +L :
        DoubleMonoidLang ->
        DoubleMonoidLang ->
        DoubleMonoidLang
      0L : DoubleMonoidLang
      *L :
        DoubleMonoidLang ->
        DoubleMonoidLang ->
        DoubleMonoidLang
      1L : DoubleMonoidLang
    data DoubleMonoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> DoubleMonoidOpenLang n
      +OL :
        DoubleMonoidOpenLang n ->
        DoubleMonoidOpenLang n ->
        DoubleMonoidOpenLang n
      0OL : DoubleMonoidOpenLang n
      *OL :
        DoubleMonoidOpenLang n ->
        DoubleMonoidOpenLang n ->
        DoubleMonoidOpenLang n
      1OL : DoubleMonoidOpenLang n
    evalTerm :
      (A : Set) ->
      DoubleMonoid A ->
      DoubleMonoidLang -> A
    evalTerm _ Do (+L x1 x2) =
      + Do (evalTerm _ Do x1)
        (evalTerm _ Do x2)
    evalTerm _ Do (0L) = 0 Do
    evalTerm _ Do (*L x1 x2) =
      * Do (evalTerm _ Do x1)
        (evalTerm _ Do x2)
    evalTerm _ Do (1L) = 1 Do
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      DoubleMonoid A ->
      DoubleMonoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n do (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n do (+OL
                         x1
                         x2) vars =
      + do
        (evalOpenTerm _ n do x1 vars)
        (evalOpenTerm _ n do x2 vars)
    evalOpenTerm _ n do (0OL) vars =
      0 do
    evalOpenTerm _ n do (*OL
                         x1
                         x2) vars =
      * do
        (evalOpenTerm _ n do x1 vars)
        (evalOpenTerm _ n do x2 vars)
    evalOpenTerm _ n do (1OL) vars =
      1 do
  
  module DualDeMorgan where
    record DualDeMorgan
      (A : Set) : Set where
      constructor DualDeMorganC
      field
        * : A -> A -> A
        + : A -> A -> A
        prim : A -> A
        andDeMorgan_*_+_prim :
          (x : A) (y : A) (z : A) ->
          prim (* x y) ==
            + (prim x) (prim y)
        orDeMorgan_+_*_prim :
          (x : A) (y : A) (z : A) ->
          prim (+ x y) ==
            * (prim x) (prim y)
    record DualDeMorganSig
      (AS : Set) : Set where
      constructor DualDeMorganSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        primS : AS -> AS
    record DualDeMorganProd
      (AP : Set) : Set where
      constructor DualDeMorganProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        andDeMorgan_*_+_primP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          primP (*P xP yP) ==
            +P (primP xP) (primP yP)
        orDeMorgan_+_*_primP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          primP (+P xP yP) ==
            *P (primP xP) (primP yP)
    record DualDeMorganHom
      (A1 : Set) (A2 : Set)
      (Du1 : DualDeMorgan A1)
      (Du2 : DualDeMorgan A2) :
      Set where
      constructor DualDeMorganHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Du1 x1 x2) ==
            * Du2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Du1 x1 x2) ==
            + Du2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Du1 x1) ==
            prim Du2 (hom x1)
    record DualDeMorganRelInterp
      (A1 : Set) (A2 : Set)
      (Du1 : DualDeMorgan A1)
      (Du2 : DualDeMorgan A2) :
      Set where
      constructor DualDeMorganRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Du1 x1 x2)
            (* Du2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Du1 x1 x2)
            (+ Du2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Du1 x1)
            (prim Du2 y1)
    data DualDeMorganLang
      : Set where
      *L :
        DualDeMorganLang ->
        DualDeMorganLang ->
        DualDeMorganLang
      +L :
        DualDeMorganLang ->
        DualDeMorganLang ->
        DualDeMorganLang
      primL :
        DualDeMorganLang ->
        DualDeMorganLang
    data DualDeMorganOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> DualDeMorganOpenLang n
      *OL :
        DualDeMorganOpenLang n ->
        DualDeMorganOpenLang n ->
        DualDeMorganOpenLang n
      +OL :
        DualDeMorganOpenLang n ->
        DualDeMorganOpenLang n ->
        DualDeMorganOpenLang n
      primOL :
        DualDeMorganOpenLang n ->
        DualDeMorganOpenLang n
    evalTerm :
      (A : Set) ->
      DualDeMorgan A ->
      DualDeMorganLang -> A
    evalTerm _ Du (*L x1 x2) =
      * Du (evalTerm _ Du x1)
        (evalTerm _ Du x2)
    evalTerm _ Du (+L x1 x2) =
      + Du (evalTerm _ Du x1)
        (evalTerm _ Du x2)
    evalTerm _ Du (primL x1) =
      prim Du (evalTerm _ Du x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      DualDeMorgan A ->
      DualDeMorganOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n du (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n du (*OL
                         x1
                         x2) vars =
      * du
        (evalOpenTerm _ n du x1 vars)
        (evalOpenTerm _ n du x2 vars)
    evalOpenTerm _ n du (+OL
                         x1
                         x2) vars =
      + du
        (evalOpenTerm _ n du x1 vars)
        (evalOpenTerm _ n du x2 vars)
    evalOpenTerm _ n du (primOL
                         x1) vars =
      prim du
        (evalOpenTerm _ n du x1 vars)
  
  module DualSemilattices where
    record DualSemilattices
      (A : Set) : Set where
      constructor DualSemilatticesC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
    record DualSemilatticesSig
      (AS : Set) : Set where
      constructor DualSemilatticesSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record DualSemilatticesProd
      (AP : Set) : Set where
      constructor DualSemilatticesProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record DualSemilatticesHom
      (A1 : Set) (A2 : Set)
      (Du1 : DualSemilattices A1)
      (Du2 : DualSemilattices A2) :
      Set where
      constructor DualSemilatticesHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Du1 x1 x2) ==
            * Du2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Du1 x1 x2) ==
            + Du2 (hom x1) (hom x2)
    record DualSemilatticesRelInterp
      (A1 : Set) (A2 : Set)
      (Du1 : DualSemilattices A1)
      (Du2 : DualSemilattices A2) :
      Set where
      constructor DualSemilatticesRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Du1 x1 x2)
            (* Du2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Du1 x1 x2)
            (+ Du2 y1 y2)
    data DualSemilatticesLang
      : Set where
      *L :
        DualSemilatticesLang ->
        DualSemilatticesLang ->
        DualSemilatticesLang
      +L :
        DualSemilatticesLang ->
        DualSemilatticesLang ->
        DualSemilatticesLang
    data DualSemilatticesOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        DualSemilatticesOpenLang n
      *OL :
        DualSemilatticesOpenLang n ->
        DualSemilatticesOpenLang n ->
        DualSemilatticesOpenLang n
      +OL :
        DualSemilatticesOpenLang n ->
        DualSemilatticesOpenLang n ->
        DualSemilatticesOpenLang n
    evalTerm :
      (A : Set) ->
      DualSemilattices A ->
      DualSemilatticesLang -> A
    evalTerm _ Du (*L x1 x2) =
      * Du (evalTerm _ Du x1)
        (evalTerm _ Du x2)
    evalTerm _ Du (+L x1 x2) =
      + Du (evalTerm _ Du x1)
        (evalTerm _ Du x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      DualSemilattices A ->
      DualSemilatticesOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n du (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n du (*OL
                         x1
                         x2) vars =
      * du
        (evalOpenTerm _ n du x1 vars)
        (evalOpenTerm _ n du x2 vars)
    evalOpenTerm _ n du (+OL
                         x1
                         x2) vars =
      + du
        (evalOpenTerm _ n du x1 vars)
        (evalOpenTerm _ n du x2 vars)
  
  module Empty where
    record Empty : Set where
      constructor EmptyC
      field
        
  
  module FixedPoint where
    record FixedPoint
      (A : Set) : Set where
      constructor FixedPointC
      field
        prim : A -> A
        e : A
        fixes_prim_e : prim e == e
    record FixedPointSig
      (AS : Set) : Set where
      constructor FixedPointSigSigC
      field
        primS : AS -> AS
        eS : AS
    record FixedPointProd
      (AP : Set) : Set where
      constructor FixedPointProdC
      field
        primP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        fixes_prim_eP : primP eP == eP
    record FixedPointHom
      (A1 : Set) (A2 : Set)
      (Fi1 : FixedPoint A1)
      (Fi2 : FixedPoint A2) :
      Set where
      constructor FixedPointHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Fi1 x1) ==
            prim Fi2 (hom x1)
        pres-e : hom (e Fi1) == e Fi2
    record FixedPointRelInterp
      (A1 : Set) (A2 : Set)
      (Fi1 : FixedPoint A1)
      (Fi2 : FixedPoint A2) :
      Set where
      constructor FixedPointRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Fi1 x1)
            (prim Fi2 y1)
        interp-e :
          interp (e Fi1) (e Fi2)
    data FixedPointLang : Set where
      primL :
        FixedPointLang -> FixedPointLang
      eL : FixedPointLang
    data FixedPointOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> FixedPointOpenLang n
      primOL :
        FixedPointOpenLang n ->
        FixedPointOpenLang n
      eOL : FixedPointOpenLang n
    evalTerm :
      (A : Set) ->
      FixedPoint A ->
      FixedPointLang -> A
    evalTerm _ Fi (primL x1) =
      prim Fi (evalTerm _ Fi x1)
    evalTerm _ Fi (eL) = e Fi
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      FixedPoint A ->
      FixedPointOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n fi (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n fi (primOL
                         x1) vars =
      prim fi
        (evalOpenTerm _ n fi x1 vars)
    evalOpenTerm _ n fi (eOL) vars =
      e fi
  
  module Group where
    record Group
      (A : Set) : Set where
      constructor GroupC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        inv : A -> A
        leftInverse_inv_op_e :
          (x : A) -> op x (inv x) == e
        rightInverse_inv_op_e :
          (x : A) -> op (inv x) x == e
    record GroupSig
      (AS : Set) : Set where
      constructor GroupSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
        invS : AS -> AS
    record GroupProd
      (AP : Set) : Set where
      constructor GroupProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP xP (invP xP) == eP
        rightInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (invP xP) xP == eP
    record GroupHom
      (A1 : Set) (A2 : Set)
      (Gr1 : Group A1)
      (Gr2 : Group A2) : Set where
      constructor GroupHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Gr1) == e Gr2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Gr1 x1 x2) ==
            op Gr2 (hom x1) (hom x2)
        pres-inv :
          (x1 : A1) ->
          hom (inv Gr1 x1) ==
            inv Gr2 (hom x1)
    record GroupRelInterp
      (A1 : Set) (A2 : Set)
      (Gr1 : Group A1)
      (Gr2 : Group A2) : Set where
      constructor GroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Gr1) (e Gr2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Gr1 x1 x2)
            (op Gr2 y1 y2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Gr1 x1) (inv Gr2 y1)
    data GroupLang : Set where
      eL : GroupLang
      opL :
        GroupLang ->
        GroupLang -> GroupLang
      invL : GroupLang -> GroupLang
    data GroupOpenLang
      (n : Nat) : Set where
      v : Fin n -> GroupOpenLang n
      eOL : GroupOpenLang n
      opOL :
        GroupOpenLang n ->
        GroupOpenLang n ->
        GroupOpenLang n
      invOL :
        GroupOpenLang n ->
        GroupOpenLang n
    evalTerm :
      (A : Set) ->
      Group A -> GroupLang -> A
    evalTerm _ Gr (eL) = e Gr
    evalTerm _ Gr (opL x1 x2) =
      op Gr (evalTerm _ Gr x1)
        (evalTerm _ Gr x2)
    evalTerm _ Gr (invL x1) =
      inv Gr (evalTerm _ Gr x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Group A ->
      GroupOpenLang n -> Vec A n -> A
    evalOpenTerm _ n gr (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n gr (eOL) vars =
      e gr
    evalOpenTerm _ n gr (opOL
                         x1
                         x2) vars =
      op gr
        (evalOpenTerm _ n gr x1 vars)
        (evalOpenTerm _ n gr x2 vars)
    evalOpenTerm _ n gr (invOL
                         x1) vars =
      inv gr
        (evalOpenTerm _ n gr x1 vars)
  
  module Group1 where
    record Group1
      (A : Set) : Set where
      constructor Group1C
      field
        1 : A
        op : A -> A -> A
        lunit_1 : (x : A) -> op 1 x == x
        runit_1 : (x : A) -> op x 1 == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        inv : A -> A
        leftInverse_inv_op_1 :
          (x : A) -> op x (inv x) == 1
        rightInverse_inv_op_1 :
          (x : A) -> op (inv x) x == 1
    record Group1Sig
      (AS : Set) : Set where
      constructor Group1SigSigC
      field
        1S : AS
        opS : AS -> AS -> AS
        invS : AS -> AS
    record Group1Prod
      (AP : Set) : Set where
      constructor Group1ProdC
      field
        1P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          opP 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          opP xP 1P == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          opP xP (invP xP) == 1P
        rightInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          opP (invP xP) xP == 1P
    record Group1Hom
      (A1 : Set) (A2 : Set)
      (Gr1 : Group1 A1)
      (Gr2 : Group1 A2) : Set where
      constructor Group1HomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Gr1) == 1 Gr2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Gr1 x1 x2) ==
            op Gr2 (hom x1) (hom x2)
        pres-inv :
          (x1 : A1) ->
          hom (inv Gr1 x1) ==
            inv Gr2 (hom x1)
    record Group1RelInterp
      (A1 : Set) (A2 : Set)
      (Gr1 : Group1 A1)
      (Gr2 : Group1 A2) : Set where
      constructor Group1RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Gr1) (1 Gr2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Gr1 x1 x2)
            (op Gr2 y1 y2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Gr1 x1) (inv Gr2 y1)
    data Group1Lang : Set where
      1L : Group1Lang
      opL :
        Group1Lang ->
        Group1Lang -> Group1Lang
      invL : Group1Lang -> Group1Lang
    data Group1OpenLang
      (n : Nat) : Set where
      v : Fin n -> Group1OpenLang n
      1OL : Group1OpenLang n
      opOL :
        Group1OpenLang n ->
        Group1OpenLang n ->
        Group1OpenLang n
      invOL :
        Group1OpenLang n ->
        Group1OpenLang n
    evalTerm :
      (A : Set) ->
      Group1 A -> Group1Lang -> A
    evalTerm _ Gr (1L) = 1 Gr
    evalTerm _ Gr (opL x1 x2) =
      op Gr (evalTerm _ Gr x1)
        (evalTerm _ Gr x2)
    evalTerm _ Gr (invL x1) =
      inv Gr (evalTerm _ Gr x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Group1 A ->
      Group1OpenLang n -> Vec A n -> A
    evalOpenTerm _ n gr (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n gr (1OL) vars =
      1 gr
    evalOpenTerm _ n gr (opOL
                         x1
                         x2) vars =
      op gr
        (evalOpenTerm _ n gr x1 vars)
        (evalOpenTerm _ n gr x2 vars)
    evalOpenTerm _ n gr (invOL
                         x1) vars =
      inv gr
        (evalOpenTerm _ n gr x1 vars)
  
  module IdempotentAdditiveMagma where
    record IdempotentAdditiveMagma
      (A : Set) : Set where
      constructor IdempotentAdditiveMagmaC
      field
        + : A -> A -> A
        idempotent_+ :
          (x : A) -> + x x == x
    record IdempotentAdditiveMagmaSig
      (AS : Set) : Set where
      constructor IdempotentAdditiveMagmaSigSigC
      field
        +S : AS -> AS -> AS
    record IdempotentAdditiveMagmaProd
      (AP : Set) : Set where
      constructor IdempotentAdditiveMagmaProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record IdempotentAdditiveMagmaHom
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentAdditiveMagma
         A1)
      (Id2 : IdempotentAdditiveMagma
         A2) : Set where
      constructor IdempotentAdditiveMagmaHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Id1 x1 x2) ==
            + Id2 (hom x1) (hom x2)
    record IdempotentAdditiveMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentAdditiveMagma
         A1)
      (Id2 : IdempotentAdditiveMagma
         A2) : Set where
      constructor IdempotentAdditiveMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Id1 x1 x2)
            (+ Id2 y1 y2)
    data IdempotentAdditiveMagmaLang
      : Set where
      +L :
        IdempotentAdditiveMagmaLang ->
        IdempotentAdditiveMagmaLang ->
        IdempotentAdditiveMagmaLang
    data IdempotentAdditiveMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        IdempotentAdditiveMagmaOpenLang
          n
      +OL :
        IdempotentAdditiveMagmaOpenLang
          n ->
        IdempotentAdditiveMagmaOpenLang
          n ->
        IdempotentAdditiveMagmaOpenLang
          n
    evalTerm :
      (A : Set) ->
      IdempotentAdditiveMagma A ->
      IdempotentAdditiveMagmaLang -> A
    evalTerm _ Id (+L x1 x2) =
      + Id (evalTerm _ Id x1)
        (evalTerm _ Id x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      IdempotentAdditiveMagma A ->
      IdempotentAdditiveMagmaOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n id (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n id (+OL
                         x1
                         x2) vars =
      + id
        (evalOpenTerm _ n id x1 vars)
        (evalOpenTerm _ n id x2 vars)
  
  module IdempotentMagma where
    record IdempotentMagma
      (A : Set) : Set where
      constructor IdempotentMagmaC
      field
        op : A -> A -> A
        idempotent_op :
          (x : A) -> op x x == x
    record IdempotentMagmaSig
      (AS : Set) : Set where
      constructor IdempotentMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record IdempotentMagmaProd
      (AP : Set) : Set where
      constructor IdempotentMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        idempotent_opP :
          (xP : Prod AP AP) ->
          opP xP xP == xP
    record IdempotentMagmaHom
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentMagma A1)
      (Id2 : IdempotentMagma A2) :
      Set where
      constructor IdempotentMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Id1 x1 x2) ==
            op Id2 (hom x1) (hom x2)
    record IdempotentMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentMagma A1)
      (Id2 : IdempotentMagma A2) :
      Set where
      constructor IdempotentMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Id1 x1 x2)
            (op Id2 y1 y2)
    data IdempotentMagmaLang
      : Set where
      opL :
        IdempotentMagmaLang ->
        IdempotentMagmaLang ->
        IdempotentMagmaLang
    data IdempotentMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        IdempotentMagmaOpenLang n
      opOL :
        IdempotentMagmaOpenLang n ->
        IdempotentMagmaOpenLang n ->
        IdempotentMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      IdempotentMagma A ->
      IdempotentMagmaLang -> A
    evalTerm _ Id (opL x1 x2) =
      op Id (evalTerm _ Id x1)
        (evalTerm _ Id x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      IdempotentMagma A ->
      IdempotentMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n id (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n id (opOL
                         x1
                         x2) vars =
      op id
        (evalOpenTerm _ n id x1 vars)
        (evalOpenTerm _ n id x2 vars)
  
  module IdempotentMultMagma where
    record IdempotentMultMagma
      (A : Set) : Set where
      constructor IdempotentMultMagmaC
      field
        * : A -> A -> A
        idempotent_* :
          (x : A) -> * x x == x
    record IdempotentMultMagmaSig
      (AS : Set) : Set where
      constructor IdempotentMultMagmaSigSigC
      field
        *S : AS -> AS -> AS
    record IdempotentMultMagmaProd
      (AP : Set) : Set where
      constructor IdempotentMultMagmaProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
    record IdempotentMultMagmaHom
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentMultMagma A1)
      (Id2 : IdempotentMultMagma A2) :
      Set where
      constructor IdempotentMultMagmaHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Id1 x1 x2) ==
            * Id2 (hom x1) (hom x2)
    record IdempotentMultMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentMultMagma A1)
      (Id2 : IdempotentMultMagma A2) :
      Set where
      constructor IdempotentMultMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Id1 x1 x2)
            (* Id2 y1 y2)
    data IdempotentMultMagmaLang
      : Set where
      *L :
        IdempotentMultMagmaLang ->
        IdempotentMultMagmaLang ->
        IdempotentMultMagmaLang
    data IdempotentMultMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        IdempotentMultMagmaOpenLang n
      *OL :
        IdempotentMultMagmaOpenLang n ->
        IdempotentMultMagmaOpenLang n ->
        IdempotentMultMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      IdempotentMultMagma A ->
      IdempotentMultMagmaLang -> A
    evalTerm _ Id (*L x1 x2) =
      * Id (evalTerm _ Id x1)
        (evalTerm _ Id x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      IdempotentMultMagma A ->
      IdempotentMultMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n id (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n id (*OL
                         x1
                         x2) vars =
      * id
        (evalOpenTerm _ n id x1 vars)
        (evalOpenTerm _ n id x2 vars)
  
  module IdempotentSemiRng where
    record IdempotentSemiRng
      (A : Set) : Set where
      constructor IdempotentSemiRngC
      field
        + : A -> A -> A
        * : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        idempotent_+ :
          (x : A) -> + x x == x
    record IdempotentSemiRngSig
      (AS : Set) : Set where
      constructor IdempotentSemiRngSigSigC
      field
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
        0S : AS
    record IdempotentSemiRngProd
      (AP : Set) : Set where
      constructor IdempotentSemiRngProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record IdempotentSemiRngHom
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentSemiRng A1)
      (Id2 : IdempotentSemiRng A2) :
      Set where
      constructor IdempotentSemiRngHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Id1 x1 x2) ==
            + Id2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Id1 x1 x2) ==
            * Id2 (hom x1) (hom x2)
        pres-0 : hom (0 Id1) == 0 Id2
    record IdempotentSemiRngRelInterp
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentSemiRng A1)
      (Id2 : IdempotentSemiRng A2) :
      Set where
      constructor IdempotentSemiRngRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Id1 x1 x2)
            (+ Id2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Id1 x1 x2)
            (* Id2 y1 y2)
        interp-0 :
          interp (0 Id1) (0 Id2)
    data IdempotentSemiRngLang
      : Set where
      +L :
        IdempotentSemiRngLang ->
        IdempotentSemiRngLang ->
        IdempotentSemiRngLang
      *L :
        IdempotentSemiRngLang ->
        IdempotentSemiRngLang ->
        IdempotentSemiRngLang
      0L : IdempotentSemiRngLang
    data IdempotentSemiRngOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        IdempotentSemiRngOpenLang n
      +OL :
        IdempotentSemiRngOpenLang n ->
        IdempotentSemiRngOpenLang n ->
        IdempotentSemiRngOpenLang n
      *OL :
        IdempotentSemiRngOpenLang n ->
        IdempotentSemiRngOpenLang n ->
        IdempotentSemiRngOpenLang n
      0OL :
        IdempotentSemiRngOpenLang n
    evalTerm :
      (A : Set) ->
      IdempotentSemiRng A ->
      IdempotentSemiRngLang -> A
    evalTerm _ Id (+L x1 x2) =
      + Id (evalTerm _ Id x1)
        (evalTerm _ Id x2)
    evalTerm _ Id (*L x1 x2) =
      * Id (evalTerm _ Id x1)
        (evalTerm _ Id x2)
    evalTerm _ Id (0L) = 0 Id
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      IdempotentSemiRng A ->
      IdempotentSemiRngOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n id (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n id (+OL
                         x1
                         x2) vars =
      + id
        (evalOpenTerm _ n id x1 vars)
        (evalOpenTerm _ n id x2 vars)
    evalOpenTerm _ n id (*OL
                         x1
                         x2) vars =
      * id
        (evalOpenTerm _ n id x1 vars)
        (evalOpenTerm _ n id x2 vars)
    evalOpenTerm _ n id (0OL) vars =
      0 id
  
  module IdempotentSemiring where
    record IdempotentSemiring
      (A : Set) : Set where
      constructor IdempotentSemiringC
      field
        + : A -> A -> A
        0 : A
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
        idempotent_+ :
          (x : A) -> + x x == x
    record IdempotentSemiringSig
      (AS : Set) : Set where
      constructor IdempotentSemiringSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
        *S : AS -> AS -> AS
        1S : AS
    record IdempotentSemiringProd
      (AP : Set) : Set where
      constructor IdempotentSemiringProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record IdempotentSemiringHom
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentSemiring A1)
      (Id2 : IdempotentSemiring A2) :
      Set where
      constructor IdempotentSemiringHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Id1 x1 x2) ==
            + Id2 (hom x1) (hom x2)
        pres-0 : hom (0 Id1) == 0 Id2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Id1 x1 x2) ==
            * Id2 (hom x1) (hom x2)
        pres-1 : hom (1 Id1) == 1 Id2
    record IdempotentSemiringRelInterp
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentSemiring A1)
      (Id2 : IdempotentSemiring A2) :
      Set where
      constructor IdempotentSemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Id1 x1 x2)
            (+ Id2 y1 y2)
        interp-0 :
          interp (0 Id1) (0 Id2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Id1 x1 x2)
            (* Id2 y1 y2)
        interp-1 :
          interp (1 Id1) (1 Id2)
    data IdempotentSemiringLang
      : Set where
      +L :
        IdempotentSemiringLang ->
        IdempotentSemiringLang ->
        IdempotentSemiringLang
      0L : IdempotentSemiringLang
      *L :
        IdempotentSemiringLang ->
        IdempotentSemiringLang ->
        IdempotentSemiringLang
      1L : IdempotentSemiringLang
    data IdempotentSemiringOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        IdempotentSemiringOpenLang n
      +OL :
        IdempotentSemiringOpenLang n ->
        IdempotentSemiringOpenLang n ->
        IdempotentSemiringOpenLang n
      0OL :
        IdempotentSemiringOpenLang n
      *OL :
        IdempotentSemiringOpenLang n ->
        IdempotentSemiringOpenLang n ->
        IdempotentSemiringOpenLang n
      1OL :
        IdempotentSemiringOpenLang n
    evalTerm :
      (A : Set) ->
      IdempotentSemiring A ->
      IdempotentSemiringLang -> A
    evalTerm _ Id (+L x1 x2) =
      + Id (evalTerm _ Id x1)
        (evalTerm _ Id x2)
    evalTerm _ Id (0L) = 0 Id
    evalTerm _ Id (*L x1 x2) =
      * Id (evalTerm _ Id x1)
        (evalTerm _ Id x2)
    evalTerm _ Id (1L) = 1 Id
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      IdempotentSemiring A ->
      IdempotentSemiringOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n id (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n id (+OL
                         x1
                         x2) vars =
      + id
        (evalOpenTerm _ n id x1 vars)
        (evalOpenTerm _ n id x2 vars)
    evalOpenTerm _ n id (0OL) vars =
      0 id
    evalOpenTerm _ n id (*OL
                         x1
                         x2) vars =
      * id
        (evalOpenTerm _ n id x1 vars)
        (evalOpenTerm _ n id x2 vars)
    evalOpenTerm _ n id (1OL) vars =
      1 id
  
  module IdempotentUnary where
    record IdempotentUnary
      (A : Set) : Set where
      constructor IdempotentUnaryC
      field
        prim : A -> A
        idempotent_prim :
          (x : A) ->
          prim (prim x) == prim x
    record IdempotentUnarySig
      (AS : Set) : Set where
      constructor IdempotentUnarySigSigC
      field
        primS : AS -> AS
    record IdempotentUnaryProd
      (AP : Set) : Set where
      constructor IdempotentUnaryProdC
      field
        primP : Prod AP AP -> Prod AP AP
        idempotent_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == primP xP
    record IdempotentUnaryHom
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentUnary A1)
      (Id2 : IdempotentUnary A2) :
      Set where
      constructor IdempotentUnaryHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Id1 x1) ==
            prim Id2 (hom x1)
    record IdempotentUnaryRelInterp
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentUnary A1)
      (Id2 : IdempotentUnary A2) :
      Set where
      constructor IdempotentUnaryRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Id1 x1)
            (prim Id2 y1)
    data IdempotentUnaryLang
      : Set where
      primL :
        IdempotentUnaryLang ->
        IdempotentUnaryLang
    data IdempotentUnaryOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        IdempotentUnaryOpenLang n
      primOL :
        IdempotentUnaryOpenLang n ->
        IdempotentUnaryOpenLang n
    evalTerm :
      (A : Set) ->
      IdempotentUnary A ->
      IdempotentUnaryLang -> A
    evalTerm _ Id (primL x1) =
      prim Id (evalTerm _ Id x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      IdempotentUnary A ->
      IdempotentUnaryOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n id (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n id (primOL
                         x1) vars =
      prim id
        (evalOpenTerm _ n id x1 vars)
  
  module Inverse where
    record Inverse
      (A : Set) : Set where
      constructor InverseC
      field
        inv : A -> A
        e : A
        op : A -> A -> A
        leftInverse_inv_op_e :
          (x : A) -> op x (inv x) == e
        rightInverse_inv_op_e :
          (x : A) -> op (inv x) x == e
    record InverseSig
      (AS : Set) : Set where
      constructor InverseSigSigC
      field
        invS : AS -> AS
        eS : AS
        opS : AS -> AS -> AS
    record InverseProd
      (AP : Set) : Set where
      constructor InverseProdC
      field
        invP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP xP (invP xP) == eP
        rightInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (invP xP) xP == eP
    record InverseHom
      (A1 : Set) (A2 : Set)
      (In1 : Inverse A1)
      (In2 : Inverse A2) : Set where
      constructor InverseHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv In1 x1) ==
            inv In2 (hom x1)
        pres-e : hom (e In1) == e In2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
    record InverseRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : Inverse A1)
      (In2 : Inverse A2) : Set where
      constructor InverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv In1 x1) (inv In2 y1)
        interp-e :
          interp (e In1) (e In2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
    data InverseLang : Set where
      invL :
        InverseLang -> InverseLang
      eL : InverseLang
      opL :
        InverseLang ->
        InverseLang -> InverseLang
    data InverseOpenLang
      (n : Nat) : Set where
      v : Fin n -> InverseOpenLang n
      invOL :
        InverseOpenLang n ->
        InverseOpenLang n
      eOL : InverseOpenLang n
      opOL :
        InverseOpenLang n ->
        InverseOpenLang n ->
        InverseOpenLang n
    evalTerm :
      (A : Set) ->
      Inverse A -> InverseLang -> A
    evalTerm _ In (invL x1) =
      inv In (evalTerm _ In x1)
    evalTerm _ In (eL) = e In
    evalTerm _ In (opL x1 x2) =
      op In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Inverse A ->
      InverseOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (invOL
                         x1) vars =
      inv in
        (evalOpenTerm _ n in x1 vars)
    evalOpenTerm _ n in (eOL) vars =
      e in
    evalOpenTerm _ n in (opOL
                         x1
                         x2) vars =
      op in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
  
  module InverseSig where
    record InverseSig
      (A : Set) : Set where
      constructor InverseSigC
      field
        inv : A -> A
        e : A
        op : A -> A -> A
    record InverseSigSig
      (AS : Set) : Set where
      constructor InverseSigSigSigC
      field
        invS : AS -> AS
        eS : AS
        opS : AS -> AS -> AS
    record InverseSigProd
      (AP : Set) : Set where
      constructor InverseSigProdC
      field
        invP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record InverseSigHom
      (A1 : Set) (A2 : Set)
      (In1 : InverseSig A1)
      (In2 : InverseSig A2) :
      Set where
      constructor InverseSigHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv In1 x1) ==
            inv In2 (hom x1)
        pres-e : hom (e In1) == e In2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
    record InverseSigRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InverseSig A1)
      (In2 : InverseSig A2) :
      Set where
      constructor InverseSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv In1 x1) (inv In2 y1)
        interp-e :
          interp (e In1) (e In2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
    data InverseSigLang : Set where
      invL :
        InverseSigLang -> InverseSigLang
      eL : InverseSigLang
      opL :
        InverseSigLang ->
        InverseSigLang -> InverseSigLang
    data InverseSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> InverseSigOpenLang n
      invOL :
        InverseSigOpenLang n ->
        InverseSigOpenLang n
      eOL : InverseSigOpenLang n
      opOL :
        InverseSigOpenLang n ->
        InverseSigOpenLang n ->
        InverseSigOpenLang n
    evalTerm :
      (A : Set) ->
      InverseSig A ->
      InverseSigLang -> A
    evalTerm _ In (invL x1) =
      inv In (evalTerm _ In x1)
    evalTerm _ In (eL) = e In
    evalTerm _ In (opL x1 x2) =
      op In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InverseSig A ->
      InverseSigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (invOL
                         x1) vars =
      inv in
        (evalOpenTerm _ n in x1 vars)
    evalOpenTerm _ n in (eOL) vars =
      e in
    evalOpenTerm _ n in (opOL
                         x1
                         x2) vars =
      op in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
  
  module InverseUnaryOperation where
    record InverseUnaryOperation
      (A : Set) : Set where
      constructor InverseUnaryOperationC
      field
        inv : A -> A
    record InverseUnaryOperationSig
      (AS : Set) : Set where
      constructor InverseUnaryOperationSigSigC
      field
        invS : AS -> AS
    record InverseUnaryOperationProd
      (AP : Set) : Set where
      constructor InverseUnaryOperationProdC
      field
        invP : Prod AP AP -> Prod AP AP
    record InverseUnaryOperationHom
      (A1 : Set) (A2 : Set)
      (In1 : InverseUnaryOperation A1)
      (In2 : InverseUnaryOperation
         A2) : Set where
      constructor InverseUnaryOperationHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv In1 x1) ==
            inv In2 (hom x1)
    record InverseUnaryOperationRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InverseUnaryOperation A1)
      (In2 : InverseUnaryOperation
         A2) : Set where
      constructor InverseUnaryOperationRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv In1 x1) (inv In2 y1)
    data InverseUnaryOperationLang
      : Set where
      invL :
        InverseUnaryOperationLang ->
        InverseUnaryOperationLang
    data InverseUnaryOperationOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InverseUnaryOperationOpenLang n
      invOL :
        InverseUnaryOperationOpenLang
          n ->
        InverseUnaryOperationOpenLang n
    evalTerm :
      (A : Set) ->
      InverseUnaryOperation A ->
      InverseUnaryOperationLang -> A
    evalTerm _ In (invL x1) =
      inv In (evalTerm _ In x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InverseUnaryOperation A ->
      InverseUnaryOperationOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (invOL
                         x1) vars =
      inv in
        (evalOpenTerm _ n in x1 vars)
  
  module Involution where
    record Involution
      (A : Set) : Set where
      constructor InvolutionC
      field
        prim : A -> A
        involutive_prim :
          (x : A) -> prim (prim x) == x
    record InvolutionSig
      (AS : Set) : Set where
      constructor InvolutionSigSigC
      field
        primS : AS -> AS
    record InvolutionProd
      (AP : Set) : Set where
      constructor InvolutionProdC
      field
        primP : Prod AP AP -> Prod AP AP
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
    record InvolutionHom
      (A1 : Set) (A2 : Set)
      (In1 : Involution A1)
      (In2 : Involution A2) :
      Set where
      constructor InvolutionHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutionRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : Involution A1)
      (In2 : Involution A2) :
      Set where
      constructor InvolutionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutionLang : Set where
      primL :
        InvolutionLang -> InvolutionLang
    data InvolutionOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> InvolutionOpenLang n
      primOL :
        InvolutionOpenLang n ->
        InvolutionOpenLang n
    evalTerm :
      (A : Set) ->
      Involution A ->
      InvolutionLang -> A
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Involution A ->
      InvolutionOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
  
  module InvolutiveAddMagmaSig where
    record InvolutiveAddMagmaSig
      (A : Set) : Set where
      constructor InvolutiveAddMagmaSigC
      field
        + : A -> A -> A
        prim : A -> A
    record InvolutiveAddMagmaSigSig
      (AS : Set) : Set where
      constructor InvolutiveAddMagmaSigSigSigC
      field
        +S : AS -> AS -> AS
        primS : AS -> AS
    record InvolutiveAddMagmaSigProd
      (AP : Set) : Set where
      constructor InvolutiveAddMagmaSigProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
    record InvolutiveAddMagmaSigHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveAddMagmaSig A1)
      (In2 : InvolutiveAddMagmaSig
         A2) : Set where
      constructor InvolutiveAddMagmaSigHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ In1 x1 x2) ==
            + In2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutiveAddMagmaSigRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveAddMagmaSig A1)
      (In2 : InvolutiveAddMagmaSig
         A2) : Set where
      constructor InvolutiveAddMagmaSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ In1 x1 x2)
            (+ In2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutiveAddMagmaSigLang
      : Set where
      +L :
        InvolutiveAddMagmaSigLang ->
        InvolutiveAddMagmaSigLang ->
        InvolutiveAddMagmaSigLang
      primL :
        InvolutiveAddMagmaSigLang ->
        InvolutiveAddMagmaSigLang
    data InvolutiveAddMagmaSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InvolutiveAddMagmaSigOpenLang n
      +OL :
        InvolutiveAddMagmaSigOpenLang
          n ->
        InvolutiveAddMagmaSigOpenLang
          n ->
        InvolutiveAddMagmaSigOpenLang n
      primOL :
        InvolutiveAddMagmaSigOpenLang
          n ->
        InvolutiveAddMagmaSigOpenLang n
    evalTerm :
      (A : Set) ->
      InvolutiveAddMagmaSig A ->
      InvolutiveAddMagmaSigLang -> A
    evalTerm _ In (+L x1 x2) =
      + In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InvolutiveAddMagmaSig A ->
      InvolutiveAddMagmaSigOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (+OL
                         x1
                         x2) vars =
      + in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
  
  module InvolutiveFixedPoint where
    record InvolutiveFixedPoint
      (A : Set) : Set where
      constructor InvolutiveFixedPointC
      field
        prim : A -> A
        1 : A
        fixes_prim_1 : prim 1 == 1
        involutive_prim :
          (x : A) -> prim (prim x) == x
    record InvolutiveFixedPointSig
      (AS : Set) : Set where
      constructor InvolutiveFixedPointSigSigC
      field
        primS : AS -> AS
        1S : AS
    record InvolutiveFixedPointProd
      (AP : Set) : Set where
      constructor InvolutiveFixedPointProdC
      field
        primP : Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        fixes_prim_1P : primP 1P == 1P
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
    record InvolutiveFixedPointHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveFixedPoint A1)
      (In2 : InvolutiveFixedPoint
         A2) : Set where
      constructor InvolutiveFixedPointHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-1 : hom (1 In1) == 1 In2
    record InvolutiveFixedPointRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveFixedPoint A1)
      (In2 : InvolutiveFixedPoint
         A2) : Set where
      constructor InvolutiveFixedPointRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-1 :
          interp (1 In1) (1 In2)
    data InvolutiveFixedPointLang
      : Set where
      primL :
        InvolutiveFixedPointLang ->
        InvolutiveFixedPointLang
      1L : InvolutiveFixedPointLang
    data InvolutiveFixedPointOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InvolutiveFixedPointOpenLang n
      primOL :
        InvolutiveFixedPointOpenLang
          n ->
        InvolutiveFixedPointOpenLang n
      1OL :
        InvolutiveFixedPointOpenLang n
    evalTerm :
      (A : Set) ->
      InvolutiveFixedPoint A ->
      InvolutiveFixedPointLang -> A
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalTerm _ In (1L) = 1 In
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InvolutiveFixedPoint A ->
      InvolutiveFixedPointOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
    evalOpenTerm _ n in (1OL) vars =
      1 in
  
  module InvolutiveFixes where
    record InvolutiveFixes
      (A : Set) : Set where
      constructor InvolutiveFixesC
      field
        1 : A
        prim : A -> A
        fixes_prim_1 : prim 1 == 1
    record InvolutiveFixesSig
      (AS : Set) : Set where
      constructor InvolutiveFixesSigSigC
      field
        1S : AS
        primS : AS -> AS
    record InvolutiveFixesProd
      (AP : Set) : Set where
      constructor InvolutiveFixesProdC
      field
        1P : Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        fixes_prim_1P : primP 1P == 1P
    record InvolutiveFixesHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveFixes A1)
      (In2 : InvolutiveFixes A2) :
      Set where
      constructor InvolutiveFixesHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 In1) == 1 In2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutiveFixesRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveFixes A1)
      (In2 : InvolutiveFixes A2) :
      Set where
      constructor InvolutiveFixesRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 In1) (1 In2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutiveFixesLang
      : Set where
      1L : InvolutiveFixesLang
      primL :
        InvolutiveFixesLang ->
        InvolutiveFixesLang
    data InvolutiveFixesOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InvolutiveFixesOpenLang n
      1OL : InvolutiveFixesOpenLang n
      primOL :
        InvolutiveFixesOpenLang n ->
        InvolutiveFixesOpenLang n
    evalTerm :
      (A : Set) ->
      InvolutiveFixes A ->
      InvolutiveFixesLang -> A
    evalTerm _ In (1L) = 1 In
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InvolutiveFixes A ->
      InvolutiveFixesOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (1OL) vars =
      1 in
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
  
  module InvolutiveMagma where
    record InvolutiveMagma
      (A : Set) : Set where
      constructor InvolutiveMagmaC
      field
        prim : A -> A
        involutive_prim :
          (x : A) -> prim (prim x) == x
        op : A -> A -> A
        antidis_prim_op :
          (x : A) (y : A) ->
          prim (op x y) ==
            op (prim y) (prim x)
    record InvolutiveMagmaSig
      (AS : Set) : Set where
      constructor InvolutiveMagmaSigSigC
      field
        primS : AS -> AS
        opS : AS -> AS -> AS
    record InvolutiveMagmaProd
      (AP : Set) : Set where
      constructor InvolutiveMagmaProdC
      field
        primP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
        antidis_prim_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (opP xP yP) ==
            opP (primP yP) (primP xP)
    record InvolutiveMagmaHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveMagma A1)
      (In2 : InvolutiveMagma A2) :
      Set where
      constructor InvolutiveMagmaHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
    record InvolutiveMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveMagma A1)
      (In2 : InvolutiveMagma A2) :
      Set where
      constructor InvolutiveMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
    data InvolutiveMagmaLang
      : Set where
      primL :
        InvolutiveMagmaLang ->
        InvolutiveMagmaLang
      opL :
        InvolutiveMagmaLang ->
        InvolutiveMagmaLang ->
        InvolutiveMagmaLang
    data InvolutiveMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InvolutiveMagmaOpenLang n
      primOL :
        InvolutiveMagmaOpenLang n ->
        InvolutiveMagmaOpenLang n
      opOL :
        InvolutiveMagmaOpenLang n ->
        InvolutiveMagmaOpenLang n ->
        InvolutiveMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      InvolutiveMagma A ->
      InvolutiveMagmaLang -> A
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalTerm _ In (opL x1 x2) =
      op In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InvolutiveMagma A ->
      InvolutiveMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
    evalOpenTerm _ n in (opOL
                         x1
                         x2) vars =
      op in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
  
  module InvolutiveMagmaSig where
    record InvolutiveMagmaSig
      (A : Set) : Set where
      constructor InvolutiveMagmaSigC
      field
        prim : A -> A
        op : A -> A -> A
    record InvolutiveMagmaSigSig
      (AS : Set) : Set where
      constructor InvolutiveMagmaSigSigSigC
      field
        primS : AS -> AS
        opS : AS -> AS -> AS
    record InvolutiveMagmaSigProd
      (AP : Set) : Set where
      constructor InvolutiveMagmaSigProdC
      field
        primP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record InvolutiveMagmaSigHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveMagmaSig A1)
      (In2 : InvolutiveMagmaSig A2) :
      Set where
      constructor InvolutiveMagmaSigHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
    record InvolutiveMagmaSigRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveMagmaSig A1)
      (In2 : InvolutiveMagmaSig A2) :
      Set where
      constructor InvolutiveMagmaSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
    data InvolutiveMagmaSigLang
      : Set where
      primL :
        InvolutiveMagmaSigLang ->
        InvolutiveMagmaSigLang
      opL :
        InvolutiveMagmaSigLang ->
        InvolutiveMagmaSigLang ->
        InvolutiveMagmaSigLang
    data InvolutiveMagmaSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InvolutiveMagmaSigOpenLang n
      primOL :
        InvolutiveMagmaSigOpenLang n ->
        InvolutiveMagmaSigOpenLang n
      opOL :
        InvolutiveMagmaSigOpenLang n ->
        InvolutiveMagmaSigOpenLang n ->
        InvolutiveMagmaSigOpenLang n
    evalTerm :
      (A : Set) ->
      InvolutiveMagmaSig A ->
      InvolutiveMagmaSigLang -> A
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalTerm _ In (opL x1 x2) =
      op In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InvolutiveMagmaSig A ->
      InvolutiveMagmaSigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
    evalOpenTerm _ n in (opOL
                         x1
                         x2) vars =
      op in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
  
  module InvolutiveMultMagmaSig where
    record InvolutiveMultMagmaSig
      (A : Set) : Set where
      constructor InvolutiveMultMagmaSigC
      field
        * : A -> A -> A
        prim : A -> A
    record InvolutiveMultMagmaSigSig
      (AS : Set) : Set where
      constructor InvolutiveMultMagmaSigSigSigC
      field
        *S : AS -> AS -> AS
        primS : AS -> AS
    record InvolutiveMultMagmaSigProd
      (AP : Set) : Set where
      constructor InvolutiveMultMagmaSigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
    record InvolutiveMultMagmaSigHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveMultMagmaSig
         A1)
      (In2 : InvolutiveMultMagmaSig
         A2) : Set where
      constructor InvolutiveMultMagmaSigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* In1 x1 x2) ==
            * In2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutiveMultMagmaSigRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveMultMagmaSig
         A1)
      (In2 : InvolutiveMultMagmaSig
         A2) : Set where
      constructor InvolutiveMultMagmaSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* In1 x1 x2)
            (* In2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutiveMultMagmaSigLang
      : Set where
      *L :
        InvolutiveMultMagmaSigLang ->
        InvolutiveMultMagmaSigLang ->
        InvolutiveMultMagmaSigLang
      primL :
        InvolutiveMultMagmaSigLang ->
        InvolutiveMultMagmaSigLang
    data InvolutiveMultMagmaSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InvolutiveMultMagmaSigOpenLang n
      *OL :
        InvolutiveMultMagmaSigOpenLang
          n ->
        InvolutiveMultMagmaSigOpenLang
          n ->
        InvolutiveMultMagmaSigOpenLang n
      primOL :
        InvolutiveMultMagmaSigOpenLang
          n ->
        InvolutiveMultMagmaSigOpenLang n
    evalTerm :
      (A : Set) ->
      InvolutiveMultMagmaSig A ->
      InvolutiveMultMagmaSigLang -> A
    evalTerm _ In (*L x1 x2) =
      * In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InvolutiveMultMagmaSig A ->
      InvolutiveMultMagmaSigOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (*OL
                         x1
                         x2) vars =
      * in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
  
  module InvolutivePointedMagmaSig where
    record InvolutivePointedMagmaSig
      (A : Set) : Set where
      constructor InvolutivePointedMagmaSigC
      field
        prim : A -> A
        e : A
        op : A -> A -> A
    record InvolutivePointedMagmaSigSig
      (AS : Set) : Set where
      constructor InvolutivePointedMagmaSigSigSigC
      field
        primS : AS -> AS
        eS : AS
        opS : AS -> AS -> AS
    record InvolutivePointedMagmaSigProd
      (AP : Set) : Set where
      constructor InvolutivePointedMagmaSigProdC
      field
        primP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record InvolutivePointedMagmaSigHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutivePointedMagmaSig
         A1)
      (In2 : InvolutivePointedMagmaSig
         A2) : Set where
      constructor InvolutivePointedMagmaSigHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-e : hom (e In1) == e In2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
    record InvolutivePointedMagmaSigRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutivePointedMagmaSig
         A1)
      (In2 : InvolutivePointedMagmaSig
         A2) : Set where
      constructor InvolutivePointedMagmaSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-e :
          interp (e In1) (e In2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
    data InvolutivePointedMagmaSigLang
      : Set where
      primL :
        InvolutivePointedMagmaSigLang ->
        InvolutivePointedMagmaSigLang
      eL :
        InvolutivePointedMagmaSigLang
      opL :
        InvolutivePointedMagmaSigLang ->
        InvolutivePointedMagmaSigLang ->
        InvolutivePointedMagmaSigLang
    data InvolutivePointedMagmaSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InvolutivePointedMagmaSigOpenLang
          n
      primOL :
        InvolutivePointedMagmaSigOpenLang
          n ->
        InvolutivePointedMagmaSigOpenLang
          n
      eOL :
        InvolutivePointedMagmaSigOpenLang
          n
      opOL :
        InvolutivePointedMagmaSigOpenLang
          n ->
        InvolutivePointedMagmaSigOpenLang
          n ->
        InvolutivePointedMagmaSigOpenLang
          n
    evalTerm :
      (A : Set) ->
      InvolutivePointedMagmaSig A ->
      InvolutivePointedMagmaSigLang ->
      A
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalTerm _ In (eL) = e In
    evalTerm _ In (opL x1 x2) =
      op In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InvolutivePointedMagmaSig A ->
      InvolutivePointedMagmaSigOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
    evalOpenTerm _ n in (eOL) vars =
      e in
    evalOpenTerm _ n in (opOL
                         x1
                         x2) vars =
      op in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
  
  module InvolutivePointedSemigroup where
    record InvolutivePointedSemigroup
      (A : Set) : Set where
      constructor InvolutivePointedSemigroupC
      field
        op : A -> A -> A
        e : A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        prim : A -> A
        involutive_prim :
          (x : A) -> prim (prim x) == x
        antidis_prim_op :
          (x : A) (y : A) ->
          prim (op x y) ==
            op (prim y) (prim x)
    record InvolutivePointedSemigroupSig
      (AS : Set) : Set where
      constructor InvolutivePointedSemigroupSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
        primS : AS -> AS
    record InvolutivePointedSemigroupProd
      (AP : Set) : Set where
      constructor InvolutivePointedSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
        antidis_prim_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (opP xP yP) ==
            opP (primP yP) (primP xP)
    record InvolutivePointedSemigroupHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutivePointedSemigroup
         A1)
      (In2 : InvolutivePointedSemigroup
         A2) : Set where
      constructor InvolutivePointedSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
        pres-e : hom (e In1) == e In2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutivePointedSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutivePointedSemigroup
         A1)
      (In2 : InvolutivePointedSemigroup
         A2) : Set where
      constructor InvolutivePointedSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
        interp-e :
          interp (e In1) (e In2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutivePointedSemigroupLang
      : Set where
      opL :
        InvolutivePointedSemigroupLang ->
        InvolutivePointedSemigroupLang ->
        InvolutivePointedSemigroupLang
      eL :
        InvolutivePointedSemigroupLang
      primL :
        InvolutivePointedSemigroupLang ->
        InvolutivePointedSemigroupLang
    data InvolutivePointedSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InvolutivePointedSemigroupOpenLang
          n
      opOL :
        InvolutivePointedSemigroupOpenLang
          n ->
        InvolutivePointedSemigroupOpenLang
          n ->
        InvolutivePointedSemigroupOpenLang
          n
      eOL :
        InvolutivePointedSemigroupOpenLang
          n
      primOL :
        InvolutivePointedSemigroupOpenLang
          n ->
        InvolutivePointedSemigroupOpenLang
          n
    evalTerm :
      (A : Set) ->
      InvolutivePointedSemigroup A ->
      InvolutivePointedSemigroupLang ->
      A
    evalTerm _ In (opL x1 x2) =
      op In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalTerm _ In (eL) = e In
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InvolutivePointedSemigroup A ->
      InvolutivePointedSemigroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (opOL
                         x1
                         x2) vars =
      op in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    evalOpenTerm _ n in (eOL) vars =
      e in
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
  
  module InvolutiveRing where
    record InvolutiveRing
      (A : Set) : Set where
      constructor InvolutiveRingC
      field
        * : A -> A -> A
        + : A -> A -> A
        1 : A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        prim : A -> A
        fixes_prim_1 : prim 1 == 1
        involutive_prim :
          (x : A) -> prim (prim x) == x
        antidis_prim_+ :
          (x : A) (y : A) ->
          prim (+ x y) ==
            + (prim y) (prim x)
        antidis_prim_* :
          (x : A) (y : A) ->
          prim (* x y) ==
            * (prim y) (prim x)
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
    record InvolutiveRingSig
      (AS : Set) : Set where
      constructor InvolutiveRingSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        1S : AS
        primS : AS -> AS
        0S : AS
        negS : AS -> AS
    record InvolutiveRingProd
      (AP : Set) : Set where
      constructor InvolutiveRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        fixes_prim_1P : primP 1P == 1P
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
        antidis_prim_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (+P xP yP) ==
            +P (primP yP) (primP xP)
        antidis_prim_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (*P xP yP) ==
            *P (primP yP) (primP xP)
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
    record InvolutiveRingHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRing A1)
      (In2 : InvolutiveRing A2) :
      Set where
      constructor InvolutiveRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* In1 x1 x2) ==
            * In2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ In1 x1 x2) ==
            + In2 (hom x1) (hom x2)
        pres-1 : hom (1 In1) == 1 In2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-0 : hom (0 In1) == 0 In2
        pres-neg :
          (x1 : A1) ->
          hom (neg In1 x1) ==
            neg In2 (hom x1)
    record InvolutiveRingRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRing A1)
      (In2 : InvolutiveRing A2) :
      Set where
      constructor InvolutiveRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* In1 x1 x2)
            (* In2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ In1 x1 x2)
            (+ In2 y1 y2)
        interp-1 :
          interp (1 In1) (1 In2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-0 :
          interp (0 In1) (0 In2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg In1 x1) (neg In2 y1)
    data InvolutiveRingLang
      : Set where
      *L :
        InvolutiveRingLang ->
        InvolutiveRingLang ->
        InvolutiveRingLang
      +L :
        InvolutiveRingLang ->
        InvolutiveRingLang ->
        InvolutiveRingLang
      1L : InvolutiveRingLang
      primL :
        InvolutiveRingLang ->
        InvolutiveRingLang
      0L : InvolutiveRingLang
      negL :
        InvolutiveRingLang ->
        InvolutiveRingLang
    data InvolutiveRingOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InvolutiveRingOpenLang n
      *OL :
        InvolutiveRingOpenLang n ->
        InvolutiveRingOpenLang n ->
        InvolutiveRingOpenLang n
      +OL :
        InvolutiveRingOpenLang n ->
        InvolutiveRingOpenLang n ->
        InvolutiveRingOpenLang n
      1OL : InvolutiveRingOpenLang n
      primOL :
        InvolutiveRingOpenLang n ->
        InvolutiveRingOpenLang n
      0OL : InvolutiveRingOpenLang n
      negOL :
        InvolutiveRingOpenLang n ->
        InvolutiveRingOpenLang n
    evalTerm :
      (A : Set) ->
      InvolutiveRing A ->
      InvolutiveRingLang -> A
    evalTerm _ In (*L x1 x2) =
      * In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalTerm _ In (+L x1 x2) =
      + In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalTerm _ In (1L) = 1 In
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalTerm _ In (0L) = 0 In
    evalTerm _ In (negL x1) =
      neg In (evalTerm _ In x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InvolutiveRing A ->
      InvolutiveRingOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (*OL
                         x1
                         x2) vars =
      * in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    evalOpenTerm _ n in (+OL
                         x1
                         x2) vars =
      + in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    evalOpenTerm _ n in (1OL) vars =
      1 in
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
    evalOpenTerm _ n in (0OL) vars =
      0 in
    evalOpenTerm _ n in (negOL
                         x1) vars =
      neg in
        (evalOpenTerm _ n in x1 vars)
  
  module InvolutiveRingoid where
    record InvolutiveRingoid
      (A : Set) : Set where
      constructor InvolutiveRingoidC
      field
        prim : A -> A
        1 : A
        fixes_prim_1 : prim 1 == 1
        involutive_prim :
          (x : A) -> prim (prim x) == x
        * : A -> A -> A
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        antidis_prim_+ :
          (x : A) (y : A) ->
          prim (+ x y) ==
            + (prim y) (prim x)
        antidis_prim_* :
          (x : A) (y : A) ->
          prim (* x y) ==
            * (prim y) (prim x)
    record InvolutiveRingoidSig
      (AS : Set) : Set where
      constructor InvolutiveRingoidSigSigC
      field
        primS : AS -> AS
        1S : AS
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record InvolutiveRingoidProd
      (AP : Set) : Set where
      constructor InvolutiveRingoidProdC
      field
        primP : Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        fixes_prim_1P : primP 1P == 1P
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        antidis_prim_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (+P xP yP) ==
            +P (primP yP) (primP xP)
        antidis_prim_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (*P xP yP) ==
            *P (primP yP) (primP xP)
    record InvolutiveRingoidHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRingoid A1)
      (In2 : InvolutiveRingoid A2) :
      Set where
      constructor InvolutiveRingoidHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-1 : hom (1 In1) == 1 In2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* In1 x1 x2) ==
            * In2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ In1 x1 x2) ==
            + In2 (hom x1) (hom x2)
    record InvolutiveRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRingoid A1)
      (In2 : InvolutiveRingoid A2) :
      Set where
      constructor InvolutiveRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-1 :
          interp (1 In1) (1 In2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* In1 x1 x2)
            (* In2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ In1 x1 x2)
            (+ In2 y1 y2)
    data InvolutiveRingoidLang
      : Set where
      primL :
        InvolutiveRingoidLang ->
        InvolutiveRingoidLang
      1L : InvolutiveRingoidLang
      *L :
        InvolutiveRingoidLang ->
        InvolutiveRingoidLang ->
        InvolutiveRingoidLang
      +L :
        InvolutiveRingoidLang ->
        InvolutiveRingoidLang ->
        InvolutiveRingoidLang
    data InvolutiveRingoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InvolutiveRingoidOpenLang n
      primOL :
        InvolutiveRingoidOpenLang n ->
        InvolutiveRingoidOpenLang n
      1OL :
        InvolutiveRingoidOpenLang n
      *OL :
        InvolutiveRingoidOpenLang n ->
        InvolutiveRingoidOpenLang n ->
        InvolutiveRingoidOpenLang n
      +OL :
        InvolutiveRingoidOpenLang n ->
        InvolutiveRingoidOpenLang n ->
        InvolutiveRingoidOpenLang n
    evalTerm :
      (A : Set) ->
      InvolutiveRingoid A ->
      InvolutiveRingoidLang -> A
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalTerm _ In (1L) = 1 In
    evalTerm _ In (*L x1 x2) =
      * In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalTerm _ In (+L x1 x2) =
      + In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InvolutiveRingoid A ->
      InvolutiveRingoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
    evalOpenTerm _ n in (1OL) vars =
      1 in
    evalOpenTerm _ n in (*OL
                         x1
                         x2) vars =
      * in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    evalOpenTerm _ n in (+OL
                         x1
                         x2) vars =
      + in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
  
  module InvolutiveRingoidSig where
    record InvolutiveRingoidSig
      (A : Set) : Set where
      constructor InvolutiveRingoidSigC
      field
        prim : A -> A
        * : A -> A -> A
        + : A -> A -> A
    record InvolutiveRingoidSigSig
      (AS : Set) : Set where
      constructor InvolutiveRingoidSigSigSigC
      field
        primS : AS -> AS
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record InvolutiveRingoidSigProd
      (AP : Set) : Set where
      constructor InvolutiveRingoidSigProdC
      field
        primP : Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record InvolutiveRingoidSigHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRingoidSig A1)
      (In2 : InvolutiveRingoidSig
         A2) : Set where
      constructor InvolutiveRingoidSigHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* In1 x1 x2) ==
            * In2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ In1 x1 x2) ==
            + In2 (hom x1) (hom x2)
    record InvolutiveRingoidSigRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRingoidSig A1)
      (In2 : InvolutiveRingoidSig
         A2) : Set where
      constructor InvolutiveRingoidSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* In1 x1 x2)
            (* In2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ In1 x1 x2)
            (+ In2 y1 y2)
    data InvolutiveRingoidSigLang
      : Set where
      primL :
        InvolutiveRingoidSigLang ->
        InvolutiveRingoidSigLang
      *L :
        InvolutiveRingoidSigLang ->
        InvolutiveRingoidSigLang ->
        InvolutiveRingoidSigLang
      +L :
        InvolutiveRingoidSigLang ->
        InvolutiveRingoidSigLang ->
        InvolutiveRingoidSigLang
    data InvolutiveRingoidSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InvolutiveRingoidSigOpenLang n
      primOL :
        InvolutiveRingoidSigOpenLang
          n ->
        InvolutiveRingoidSigOpenLang n
      *OL :
        InvolutiveRingoidSigOpenLang
          n ->
        InvolutiveRingoidSigOpenLang
          n ->
        InvolutiveRingoidSigOpenLang n
      +OL :
        InvolutiveRingoidSigOpenLang
          n ->
        InvolutiveRingoidSigOpenLang
          n ->
        InvolutiveRingoidSigOpenLang n
    evalTerm :
      (A : Set) ->
      InvolutiveRingoidSig A ->
      InvolutiveRingoidSigLang -> A
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalTerm _ In (*L x1 x2) =
      * In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalTerm _ In (+L x1 x2) =
      + In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InvolutiveRingoidSig A ->
      InvolutiveRingoidSigOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
    evalOpenTerm _ n in (*OL
                         x1
                         x2) vars =
      * in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    evalOpenTerm _ n in (+OL
                         x1
                         x2) vars =
      + in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
  
  module InvolutiveRingoidWithAntiDistrib where
    record InvolutiveRingoidWithAntiDistrib
      (A : Set) : Set where
      constructor InvolutiveRingoidWithAntiDistribC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        prim : A -> A
        antidis_prim_+ :
          (x : A) (y : A) ->
          prim (+ x y) ==
            + (prim y) (prim x)
        antidis_prim_* :
          (x : A) (y : A) ->
          prim (* x y) ==
            * (prim y) (prim x)
    record InvolutiveRingoidWithAntiDistribSig
      (AS : Set) : Set where
      constructor InvolutiveRingoidWithAntiDistribSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        primS : AS -> AS
    record InvolutiveRingoidWithAntiDistribProd
      (AP : Set) : Set where
      constructor InvolutiveRingoidWithAntiDistribProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        antidis_prim_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (+P xP yP) ==
            +P (primP yP) (primP xP)
        antidis_prim_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (*P xP yP) ==
            *P (primP yP) (primP xP)
    record InvolutiveRingoidWithAntiDistribHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRingoidWithAntiDistrib
         A1)
      (In2 : InvolutiveRingoidWithAntiDistrib
         A2) : Set where
      constructor InvolutiveRingoidWithAntiDistribHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* In1 x1 x2) ==
            * In2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ In1 x1 x2) ==
            + In2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutiveRingoidWithAntiDistribRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRingoidWithAntiDistrib
         A1)
      (In2 : InvolutiveRingoidWithAntiDistrib
         A2) : Set where
      constructor InvolutiveRingoidWithAntiDistribRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* In1 x1 x2)
            (* In2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ In1 x1 x2)
            (+ In2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutiveRingoidWithAntiDistribLang
      : Set where
      *L :
        InvolutiveRingoidWithAntiDistribLang ->
        InvolutiveRingoidWithAntiDistribLang ->
        InvolutiveRingoidWithAntiDistribLang
      +L :
        InvolutiveRingoidWithAntiDistribLang ->
        InvolutiveRingoidWithAntiDistribLang ->
        InvolutiveRingoidWithAntiDistribLang
      primL :
        InvolutiveRingoidWithAntiDistribLang ->
        InvolutiveRingoidWithAntiDistribLang
    data InvolutiveRingoidWithAntiDistribOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InvolutiveRingoidWithAntiDistribOpenLang
          n
      *OL :
        InvolutiveRingoidWithAntiDistribOpenLang
          n ->
        InvolutiveRingoidWithAntiDistribOpenLang
          n ->
        InvolutiveRingoidWithAntiDistribOpenLang
          n
      +OL :
        InvolutiveRingoidWithAntiDistribOpenLang
          n ->
        InvolutiveRingoidWithAntiDistribOpenLang
          n ->
        InvolutiveRingoidWithAntiDistribOpenLang
          n
      primOL :
        InvolutiveRingoidWithAntiDistribOpenLang
          n ->
        InvolutiveRingoidWithAntiDistribOpenLang
          n
    evalTerm :
      (A : Set) ->
      InvolutiveRingoidWithAntiDistrib
        A ->
      InvolutiveRingoidWithAntiDistribLang ->
      A
    evalTerm _ In (*L x1 x2) =
      * In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalTerm _ In (+L x1 x2) =
      + In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InvolutiveRingoidWithAntiDistrib
        A ->
      InvolutiveRingoidWithAntiDistribOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (*OL
                         x1
                         x2) vars =
      * in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    evalOpenTerm _ n in (+OL
                         x1
                         x2) vars =
      + in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
  
  module InvolutiveSemigroup where
    record InvolutiveSemigroup
      (A : Set) : Set where
      constructor InvolutiveSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        prim : A -> A
        involutive_prim :
          (x : A) -> prim (prim x) == x
        antidis_prim_op :
          (x : A) (y : A) ->
          prim (op x y) ==
            op (prim y) (prim x)
    record InvolutiveSemigroupSig
      (AS : Set) : Set where
      constructor InvolutiveSemigroupSigSigC
      field
        opS : AS -> AS -> AS
        primS : AS -> AS
    record InvolutiveSemigroupProd
      (AP : Set) : Set where
      constructor InvolutiveSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
        antidis_prim_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (opP xP yP) ==
            opP (primP yP) (primP xP)
    record InvolutiveSemigroupHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveSemigroup A1)
      (In2 : InvolutiveSemigroup A2) :
      Set where
      constructor InvolutiveSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutiveSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveSemigroup A1)
      (In2 : InvolutiveSemigroup A2) :
      Set where
      constructor InvolutiveSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutiveSemigroupLang
      : Set where
      opL :
        InvolutiveSemigroupLang ->
        InvolutiveSemigroupLang ->
        InvolutiveSemigroupLang
      primL :
        InvolutiveSemigroupLang ->
        InvolutiveSemigroupLang
    data InvolutiveSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        InvolutiveSemigroupOpenLang n
      opOL :
        InvolutiveSemigroupOpenLang n ->
        InvolutiveSemigroupOpenLang n ->
        InvolutiveSemigroupOpenLang n
      primOL :
        InvolutiveSemigroupOpenLang n ->
        InvolutiveSemigroupOpenLang n
    evalTerm :
      (A : Set) ->
      InvolutiveSemigroup A ->
      InvolutiveSemigroupLang -> A
    evalTerm _ In (opL x1 x2) =
      op In (evalTerm _ In x1)
        (evalTerm _ In x2)
    evalTerm _ In (primL x1) =
      prim In (evalTerm _ In x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      InvolutiveSemigroup A ->
      InvolutiveSemigroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n in (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n in (opOL
                         x1
                         x2) vars =
      op in
        (evalOpenTerm _ n in x1 vars)
        (evalOpenTerm _ n in x2 vars)
    evalOpenTerm _ n in (primOL
                         x1) vars =
      prim in
        (evalOpenTerm _ n in x1 vars)
  
  module JacobianIdentity where
    record JacobianIdentity
      (A : Set) : Set where
      constructor JacobianIdentityC
      field
        0 : A
        + : A -> A -> A
        * : A -> A -> A
        jacobian_*_+ :
          (x : A) (y : A) (z : A) ->
          +
            (+ (* x (* y z)) (* y (* z x)))
            (* z (* x y)) == 0
    record JacobianIdentitySig
      (AS : Set) : Set where
      constructor JacobianIdentitySigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
    record JacobianIdentityProd
      (AP : Set) : Set where
      constructor JacobianIdentityProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        jacobian_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P
            (+P (*P xP (*P yP zP))
               (*P yP (*P zP xP)))
            (*P zP (*P xP yP)) == 0P
    record JacobianIdentityHom
      (A1 : Set) (A2 : Set)
      (Ja1 : JacobianIdentity A1)
      (Ja2 : JacobianIdentity A2) :
      Set where
      constructor JacobianIdentityHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ja1) == 0 Ja2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ja1 x1 x2) ==
            + Ja2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ja1 x1 x2) ==
            * Ja2 (hom x1) (hom x2)
    record JacobianIdentityRelInterp
      (A1 : Set) (A2 : Set)
      (Ja1 : JacobianIdentity A1)
      (Ja2 : JacobianIdentity A2) :
      Set where
      constructor JacobianIdentityRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ja1) (0 Ja2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ja1 x1 x2)
            (+ Ja2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ja1 x1 x2)
            (* Ja2 y1 y2)
    data JacobianIdentityLang
      : Set where
      0L : JacobianIdentityLang
      +L :
        JacobianIdentityLang ->
        JacobianIdentityLang ->
        JacobianIdentityLang
      *L :
        JacobianIdentityLang ->
        JacobianIdentityLang ->
        JacobianIdentityLang
    data JacobianIdentityOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        JacobianIdentityOpenLang n
      0OL : JacobianIdentityOpenLang n
      +OL :
        JacobianIdentityOpenLang n ->
        JacobianIdentityOpenLang n ->
        JacobianIdentityOpenLang n
      *OL :
        JacobianIdentityOpenLang n ->
        JacobianIdentityOpenLang n ->
        JacobianIdentityOpenLang n
    evalTerm :
      (A : Set) ->
      JacobianIdentity A ->
      JacobianIdentityLang -> A
    evalTerm _ Ja (0L) = 0 Ja
    evalTerm _ Ja (+L x1 x2) =
      + Ja (evalTerm _ Ja x1)
        (evalTerm _ Ja x2)
    evalTerm _ Ja (*L x1 x2) =
      * Ja (evalTerm _ Ja x1)
        (evalTerm _ Ja x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      JacobianIdentity A ->
      JacobianIdentityOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ja (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ja (0OL) vars =
      0 ja
    evalOpenTerm _ n ja (+OL
                         x1
                         x2) vars =
      + ja
        (evalOpenTerm _ n ja x1 vars)
        (evalOpenTerm _ n ja x2 vars)
    evalOpenTerm _ n ja (*OL
                         x1
                         x2) vars =
      * ja
        (evalOpenTerm _ n ja x1 vars)
        (evalOpenTerm _ n ja x2 vars)
  
  module JoinSemilattice where
    record JoinSemilattice
      (A : Set) : Set where
      constructor JoinSemilatticeC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
    record JoinSemilatticeSig
      (AS : Set) : Set where
      constructor JoinSemilatticeSigSigC
      field
        +S : AS -> AS -> AS
    record JoinSemilatticeProd
      (AP : Set) : Set where
      constructor JoinSemilatticeProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record JoinSemilatticeHom
      (A1 : Set) (A2 : Set)
      (Jo1 : JoinSemilattice A1)
      (Jo2 : JoinSemilattice A2) :
      Set where
      constructor JoinSemilatticeHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Jo1 x1 x2) ==
            + Jo2 (hom x1) (hom x2)
    record JoinSemilatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Jo1 : JoinSemilattice A1)
      (Jo2 : JoinSemilattice A2) :
      Set where
      constructor JoinSemilatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Jo1 x1 x2)
            (+ Jo2 y1 y2)
    data JoinSemilatticeLang
      : Set where
      +L :
        JoinSemilatticeLang ->
        JoinSemilatticeLang ->
        JoinSemilatticeLang
    data JoinSemilatticeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        JoinSemilatticeOpenLang n
      +OL :
        JoinSemilatticeOpenLang n ->
        JoinSemilatticeOpenLang n ->
        JoinSemilatticeOpenLang n
    evalTerm :
      (A : Set) ->
      JoinSemilattice A ->
      JoinSemilatticeLang -> A
    evalTerm _ Jo (+L x1 x2) =
      + Jo (evalTerm _ Jo x1)
        (evalTerm _ Jo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      JoinSemilattice A ->
      JoinSemilatticeOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n jo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n jo (+OL
                         x1
                         x2) vars =
      + jo
        (evalOpenTerm _ n jo x1 vars)
        (evalOpenTerm _ n jo x2 vars)
  
  module JoinSemilattice_RingoidSig where
    record JoinSemilattice_RingoidSig
      (A : Set) : Set where
      constructor JoinSemilattice_RingoidSigC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        * : A -> A -> A
    record JoinSemilattice_RingoidSigSig
      (AS : Set) : Set where
      constructor JoinSemilattice_RingoidSigSigSigC
      field
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
    record JoinSemilattice_RingoidSigProd
      (AP : Set) : Set where
      constructor JoinSemilattice_RingoidSigProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record JoinSemilattice_RingoidSigHom
      (A1 : Set) (A2 : Set)
      (Jo1 : JoinSemilattice_RingoidSig
         A1)
      (Jo2 : JoinSemilattice_RingoidSig
         A2) : Set where
      constructor JoinSemilattice_RingoidSigHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Jo1 x1 x2) ==
            + Jo2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Jo1 x1 x2) ==
            * Jo2 (hom x1) (hom x2)
    record JoinSemilattice_RingoidSigRelInterp
      (A1 : Set) (A2 : Set)
      (Jo1 : JoinSemilattice_RingoidSig
         A1)
      (Jo2 : JoinSemilattice_RingoidSig
         A2) : Set where
      constructor JoinSemilattice_RingoidSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Jo1 x1 x2)
            (+ Jo2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Jo1 x1 x2)
            (* Jo2 y1 y2)
    data JoinSemilattice_RingoidSigLang
      : Set where
      +L :
        JoinSemilattice_RingoidSigLang ->
        JoinSemilattice_RingoidSigLang ->
        JoinSemilattice_RingoidSigLang
      *L :
        JoinSemilattice_RingoidSigLang ->
        JoinSemilattice_RingoidSigLang ->
        JoinSemilattice_RingoidSigLang
    data JoinSemilattice_RingoidSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        JoinSemilattice_RingoidSigOpenLang
          n
      +OL :
        JoinSemilattice_RingoidSigOpenLang
          n ->
        JoinSemilattice_RingoidSigOpenLang
          n ->
        JoinSemilattice_RingoidSigOpenLang
          n
      *OL :
        JoinSemilattice_RingoidSigOpenLang
          n ->
        JoinSemilattice_RingoidSigOpenLang
          n ->
        JoinSemilattice_RingoidSigOpenLang
          n
    evalTerm :
      (A : Set) ->
      JoinSemilattice_RingoidSig A ->
      JoinSemilattice_RingoidSigLang ->
      A
    evalTerm _ Jo (+L x1 x2) =
      + Jo (evalTerm _ Jo x1)
        (evalTerm _ Jo x2)
    evalTerm _ Jo (*L x1 x2) =
      * Jo (evalTerm _ Jo x1)
        (evalTerm _ Jo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      JoinSemilattice_RingoidSig A ->
      JoinSemilattice_RingoidSigOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n jo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n jo (+OL
                         x1
                         x2) vars =
      + jo
        (evalOpenTerm _ n jo x1 vars)
        (evalOpenTerm _ n jo x2 vars)
    evalOpenTerm _ n jo (*OL
                         x1
                         x2) vars =
      * jo
        (evalOpenTerm _ n jo x1 vars)
        (evalOpenTerm _ n jo x2 vars)
  
  module Kei where
    record Kei (A : Set) : Set where
      constructor KeiC
      field
        |> : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        idempotent_|> :
          (x : A) -> |> x x == x
        rightSelfInverse_|> :
          (x : A) (y : A) ->
          |> (|> x y) y == x
    record KeiSig
      (AS : Set) : Set where
      constructor KeiSigSigC
      field
        |>S : AS -> AS -> AS
    record KeiProd
      (AP : Set) : Set where
      constructor KeiProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
        rightSelfInverse_|>P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          |>P (|>P xP yP) yP == xP
    record KeiHom
      (A1 : Set) (A2 : Set)
      (Ke1 : Kei A1)
      (Ke2 : Kei A2) : Set where
      constructor KeiHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ke1 x1 x2) ==
            |> Ke2 (hom x1) (hom x2)
    record KeiRelInterp
      (A1 : Set) (A2 : Set)
      (Ke1 : Kei A1)
      (Ke2 : Kei A2) : Set where
      constructor KeiRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ke1 x1 x2)
            (|> Ke2 y1 y2)
    data KeiLang : Set where
      |>L :
        KeiLang -> KeiLang -> KeiLang
    data KeiOpenLang
      (n : Nat) : Set where
      v : Fin n -> KeiOpenLang n
      |>OL :
        KeiOpenLang n ->
        KeiOpenLang n -> KeiOpenLang n
    evalTerm :
      (A : Set) ->
      Kei A -> KeiLang -> A
    evalTerm _ Ke (|>L x1 x2) =
      |> Ke (evalTerm _ Ke x1)
        (evalTerm _ Ke x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Kei A ->
      KeiOpenLang n -> Vec A n -> A
    evalOpenTerm _ n ke (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ke (|>OL
                         x1
                         x2) vars =
      |> ke
        (evalOpenTerm _ n ke x1 vars)
        (evalOpenTerm _ n ke x2 vars)
  
  module Lattice where
    record Lattice
      (A : Set) : Set where
      constructor LatticeC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
    record LatticeSig
      (AS : Set) : Set where
      constructor LatticeSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record LatticeProd
      (AP : Set) : Set where
      constructor LatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
    record LatticeHom
      (A1 : Set) (A2 : Set)
      (La1 : Lattice A1)
      (La2 : Lattice A2) : Set where
      constructor LatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* La1 x1 x2) ==
            * La2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ La1 x1 x2) ==
            + La2 (hom x1) (hom x2)
    record LatticeRelInterp
      (A1 : Set) (A2 : Set)
      (La1 : Lattice A1)
      (La2 : Lattice A2) : Set where
      constructor LatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* La1 x1 x2)
            (* La2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ La1 x1 x2)
            (+ La2 y1 y2)
    data LatticeLang : Set where
      *L :
        LatticeLang ->
        LatticeLang -> LatticeLang
      +L :
        LatticeLang ->
        LatticeLang -> LatticeLang
    data LatticeOpenLang
      (n : Nat) : Set where
      v : Fin n -> LatticeOpenLang n
      *OL :
        LatticeOpenLang n ->
        LatticeOpenLang n ->
        LatticeOpenLang n
      +OL :
        LatticeOpenLang n ->
        LatticeOpenLang n ->
        LatticeOpenLang n
    evalTerm :
      (A : Set) ->
      Lattice A -> LatticeLang -> A
    evalTerm _ La (*L x1 x2) =
      * La (evalTerm _ La x1)
        (evalTerm _ La x2)
    evalTerm _ La (+L x1 x2) =
      + La (evalTerm _ La x1)
        (evalTerm _ La x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Lattice A ->
      LatticeOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n la (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n la (*OL
                         x1
                         x2) vars =
      * la
        (evalOpenTerm _ n la x1 vars)
        (evalOpenTerm _ n la x2 vars)
    evalOpenTerm _ n la (+OL
                         x1
                         x2) vars =
      + la
        (evalOpenTerm _ n la x1 vars)
        (evalOpenTerm _ n la x2 vars)
  
  module Left0 where
    record Left0
      (A : Set) : Set where
      constructor Left0C
      field
        0 : A
        op : A -> A -> A
        leftZero_op_0 :
          (x : A) -> op 0 x == 0
    record Left0Sig
      (AS : Set) : Set where
      constructor Left0SigSigC
      field
        0S : AS
        opS : AS -> AS -> AS
    record Left0Prod
      (AP : Set) : Set where
      constructor Left0ProdC
      field
        0P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          opP 0P xP == 0P
    record Left0Hom
      (A1 : Set) (A2 : Set)
      (Le1 : Left0 A1)
      (Le2 : Left0 A2) : Set where
      constructor Left0HomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Le1) == 0 Le2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record Left0RelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : Left0 A1)
      (Le2 : Left0 A2) : Set where
      constructor Left0RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Le1) (0 Le2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data Left0Lang : Set where
      0L : Left0Lang
      opL :
        Left0Lang ->
        Left0Lang -> Left0Lang
    data Left0OpenLang
      (n : Nat) : Set where
      v : Fin n -> Left0OpenLang n
      0OL : Left0OpenLang n
      opOL :
        Left0OpenLang n ->
        Left0OpenLang n ->
        Left0OpenLang n
    evalTerm :
      (A : Set) ->
      Left0 A -> Left0Lang -> A
    evalTerm _ Le (0L) = 0 Le
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Left0 A ->
      Left0OpenLang n -> Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (0OL) vars =
      0 le
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
  
  module LeftAbsorption where
    record LeftAbsorption
      (A : Set) : Set where
      constructor LeftAbsorptionC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
    record LeftAbsorptionSig
      (AS : Set) : Set where
      constructor LeftAbsorptionSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record LeftAbsorptionProd
      (AP : Set) : Set where
      constructor LeftAbsorptionProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
    record LeftAbsorptionHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftAbsorption A1)
      (Le2 : LeftAbsorption A2) :
      Set where
      constructor LeftAbsorptionHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Le1 x1 x2) ==
            * Le2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Le1 x1 x2) ==
            + Le2 (hom x1) (hom x2)
    record LeftAbsorptionRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftAbsorption A1)
      (Le2 : LeftAbsorption A2) :
      Set where
      constructor LeftAbsorptionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Le1 x1 x2)
            (* Le2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Le1 x1 x2)
            (+ Le2 y1 y2)
    data LeftAbsorptionLang
      : Set where
      *L :
        LeftAbsorptionLang ->
        LeftAbsorptionLang ->
        LeftAbsorptionLang
      +L :
        LeftAbsorptionLang ->
        LeftAbsorptionLang ->
        LeftAbsorptionLang
    data LeftAbsorptionOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftAbsorptionOpenLang n
      *OL :
        LeftAbsorptionOpenLang n ->
        LeftAbsorptionOpenLang n ->
        LeftAbsorptionOpenLang n
      +OL :
        LeftAbsorptionOpenLang n ->
        LeftAbsorptionOpenLang n ->
        LeftAbsorptionOpenLang n
    evalTerm :
      (A : Set) ->
      LeftAbsorption A ->
      LeftAbsorptionLang -> A
    evalTerm _ Le (*L x1 x2) =
      * Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (+L x1 x2) =
      + Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftAbsorption A ->
      LeftAbsorptionOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (*OL
                         x1
                         x2) vars =
      * le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (+OL
                         x1
                         x2) vars =
      + le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
  
  module LeftAbsorptionOp where
    record LeftAbsorptionOp
      (A : Set) : Set where
      constructor LeftAbsorptionOpC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
    record LeftAbsorptionOpSig
      (AS : Set) : Set where
      constructor LeftAbsorptionOpSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record LeftAbsorptionOpProd
      (AP : Set) : Set where
      constructor LeftAbsorptionOpProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
    record LeftAbsorptionOpHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftAbsorptionOp A1)
      (Le2 : LeftAbsorptionOp A2) :
      Set where
      constructor LeftAbsorptionOpHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Le1 x1 x2) ==
            * Le2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Le1 x1 x2) ==
            + Le2 (hom x1) (hom x2)
    record LeftAbsorptionOpRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftAbsorptionOp A1)
      (Le2 : LeftAbsorptionOp A2) :
      Set where
      constructor LeftAbsorptionOpRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Le1 x1 x2)
            (* Le2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Le1 x1 x2)
            (+ Le2 y1 y2)
    data LeftAbsorptionOpLang
      : Set where
      *L :
        LeftAbsorptionOpLang ->
        LeftAbsorptionOpLang ->
        LeftAbsorptionOpLang
      +L :
        LeftAbsorptionOpLang ->
        LeftAbsorptionOpLang ->
        LeftAbsorptionOpLang
    data LeftAbsorptionOpOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftAbsorptionOpOpenLang n
      *OL :
        LeftAbsorptionOpOpenLang n ->
        LeftAbsorptionOpOpenLang n ->
        LeftAbsorptionOpOpenLang n
      +OL :
        LeftAbsorptionOpOpenLang n ->
        LeftAbsorptionOpOpenLang n ->
        LeftAbsorptionOpOpenLang n
    evalTerm :
      (A : Set) ->
      LeftAbsorptionOp A ->
      LeftAbsorptionOpLang -> A
    evalTerm _ Le (*L x1 x2) =
      * Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (+L x1 x2) =
      + Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftAbsorptionOp A ->
      LeftAbsorptionOpOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (*OL
                         x1
                         x2) vars =
      * le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (+OL
                         x1
                         x2) vars =
      + le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
  
  module LeftBiMagma where
    record LeftBiMagma
      (A : Set) : Set where
      constructor LeftBiMagmaC
      field
        op : A -> A -> A
        linv : A -> A -> A
    record LeftBiMagmaSig
      (AS : Set) : Set where
      constructor LeftBiMagmaSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
    record LeftBiMagmaProd
      (AP : Set) : Set where
      constructor LeftBiMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record LeftBiMagmaHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftBiMagma A1)
      (Le2 : LeftBiMagma A2) :
      Set where
      constructor LeftBiMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Le1 x1 x2) ==
            linv Le2 (hom x1) (hom x2)
    record LeftBiMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftBiMagma A1)
      (Le2 : LeftBiMagma A2) :
      Set where
      constructor LeftBiMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Le1 x1 x2)
            (linv Le2 y1 y2)
    data LeftBiMagmaLang : Set where
      opL :
        LeftBiMagmaLang ->
        LeftBiMagmaLang ->
        LeftBiMagmaLang
      linvL :
        LeftBiMagmaLang ->
        LeftBiMagmaLang ->
        LeftBiMagmaLang
    data LeftBiMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> LeftBiMagmaOpenLang n
      opOL :
        LeftBiMagmaOpenLang n ->
        LeftBiMagmaOpenLang n ->
        LeftBiMagmaOpenLang n
      linvOL :
        LeftBiMagmaOpenLang n ->
        LeftBiMagmaOpenLang n ->
        LeftBiMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      LeftBiMagma A ->
      LeftBiMagmaLang -> A
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (linvL x1 x2) =
      linv Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftBiMagma A ->
      LeftBiMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (linvOL
                         x1
                         x2) vars =
      linv le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
  
  module LeftBinaryInverse where
    record LeftBinaryInverse
      (A : Set) : Set where
      constructor LeftBinaryInverseC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftInverse :
          (x : A) (y : A) ->
          <| (|> x y) x == y
    record LeftBinaryInverseSig
      (AS : Set) : Set where
      constructor LeftBinaryInverseSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record LeftBinaryInverseProd
      (AP : Set) : Set where
      constructor LeftBinaryInverseProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          <|P (|>P xP yP) xP == yP
    record LeftBinaryInverseHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftBinaryInverse A1)
      (Le2 : LeftBinaryInverse A2) :
      Set where
      constructor LeftBinaryInverseHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Le1 x1 x2) ==
            <| Le2 (hom x1) (hom x2)
    record LeftBinaryInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftBinaryInverse A1)
      (Le2 : LeftBinaryInverse A2) :
      Set where
      constructor LeftBinaryInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Le1 x1 x2)
            (<| Le2 y1 y2)
    data LeftBinaryInverseLang
      : Set where
      |>L :
        LeftBinaryInverseLang ->
        LeftBinaryInverseLang ->
        LeftBinaryInverseLang
      <|L :
        LeftBinaryInverseLang ->
        LeftBinaryInverseLang ->
        LeftBinaryInverseLang
    data LeftBinaryInverseOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftBinaryInverseOpenLang n
      |>OL :
        LeftBinaryInverseOpenLang n ->
        LeftBinaryInverseOpenLang n ->
        LeftBinaryInverseOpenLang n
      <|OL :
        LeftBinaryInverseOpenLang n ->
        LeftBinaryInverseOpenLang n ->
        LeftBinaryInverseOpenLang n
    evalTerm :
      (A : Set) ->
      LeftBinaryInverse A ->
      LeftBinaryInverseLang -> A
    evalTerm _ Le (|>L x1 x2) =
      |> Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (<|L x1 x2) =
      <| Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftBinaryInverse A ->
      LeftBinaryInverseOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (|>OL
                         x1
                         x2) vars =
      |> le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (<|OL
                         x1
                         x2) vars =
      <| le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
  
  module LeftCancellative where
    record LeftCancellative
      (A : Set) : Set where
      constructor LeftCancellativeC
      field
        op : A -> A -> A
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
    record LeftCancellativeSig
      (AS : Set) : Set where
      constructor LeftCancellativeSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
    record LeftCancellativeProd
      (AP : Set) : Set where
      constructor LeftCancellativeProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
    record LeftCancellativeHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellative A1)
      (Le2 : LeftCancellative A2) :
      Set where
      constructor LeftCancellativeHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Le1 x1 x2) ==
            linv Le2 (hom x1) (hom x2)
    record LeftCancellativeRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellative A1)
      (Le2 : LeftCancellative A2) :
      Set where
      constructor LeftCancellativeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Le1 x1 x2)
            (linv Le2 y1 y2)
    data LeftCancellativeLang
      : Set where
      opL :
        LeftCancellativeLang ->
        LeftCancellativeLang ->
        LeftCancellativeLang
      linvL :
        LeftCancellativeLang ->
        LeftCancellativeLang ->
        LeftCancellativeLang
    data LeftCancellativeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftCancellativeOpenLang n
      opOL :
        LeftCancellativeOpenLang n ->
        LeftCancellativeOpenLang n ->
        LeftCancellativeOpenLang n
      linvOL :
        LeftCancellativeOpenLang n ->
        LeftCancellativeOpenLang n ->
        LeftCancellativeOpenLang n
    evalTerm :
      (A : Set) ->
      LeftCancellative A ->
      LeftCancellativeLang -> A
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (linvL x1 x2) =
      linv Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftCancellative A ->
      LeftCancellativeOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (linvOL
                         x1
                         x2) vars =
      linv le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
  
  module LeftCancellativeMagma where
    record LeftCancellativeMagma
      (A : Set) : Set where
      constructor LeftCancellativeMagmaC
      field
        op : A -> A -> A
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
    record LeftCancellativeMagmaSig
      (AS : Set) : Set where
      constructor LeftCancellativeMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record LeftCancellativeMagmaProd
      (AP : Set) : Set where
      constructor LeftCancellativeMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
    record LeftCancellativeMagmaHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellativeMagma A1)
      (Le2 : LeftCancellativeMagma
         A2) : Set where
      constructor LeftCancellativeMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record LeftCancellativeMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellativeMagma A1)
      (Le2 : LeftCancellativeMagma
         A2) : Set where
      constructor LeftCancellativeMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data LeftCancellativeMagmaLang
      : Set where
      opL :
        LeftCancellativeMagmaLang ->
        LeftCancellativeMagmaLang ->
        LeftCancellativeMagmaLang
    data LeftCancellativeMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftCancellativeMagmaOpenLang n
      opOL :
        LeftCancellativeMagmaOpenLang
          n ->
        LeftCancellativeMagmaOpenLang
          n ->
        LeftCancellativeMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      LeftCancellativeMagma A ->
      LeftCancellativeMagmaLang -> A
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftCancellativeMagma A ->
      LeftCancellativeMagmaOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
  
  module LeftCancellativeOp where
    record LeftCancellativeOp
      (A : Set) : Set where
      constructor LeftCancellativeOpC
      field
        op : A -> A -> A
        linv : A -> A -> A
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
    record LeftCancellativeOpSig
      (AS : Set) : Set where
      constructor LeftCancellativeOpSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
    record LeftCancellativeOpProd
      (AP : Set) : Set where
      constructor LeftCancellativeOpProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
    record LeftCancellativeOpHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellativeOp A1)
      (Le2 : LeftCancellativeOp A2) :
      Set where
      constructor LeftCancellativeOpHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Le1 x1 x2) ==
            linv Le2 (hom x1) (hom x2)
    record LeftCancellativeOpRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellativeOp A1)
      (Le2 : LeftCancellativeOp A2) :
      Set where
      constructor LeftCancellativeOpRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Le1 x1 x2)
            (linv Le2 y1 y2)
    data LeftCancellativeOpLang
      : Set where
      opL :
        LeftCancellativeOpLang ->
        LeftCancellativeOpLang ->
        LeftCancellativeOpLang
      linvL :
        LeftCancellativeOpLang ->
        LeftCancellativeOpLang ->
        LeftCancellativeOpLang
    data LeftCancellativeOpOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftCancellativeOpOpenLang n
      opOL :
        LeftCancellativeOpOpenLang n ->
        LeftCancellativeOpOpenLang n ->
        LeftCancellativeOpOpenLang n
      linvOL :
        LeftCancellativeOpOpenLang n ->
        LeftCancellativeOpOpenLang n ->
        LeftCancellativeOpOpenLang n
    evalTerm :
      (A : Set) ->
      LeftCancellativeOp A ->
      LeftCancellativeOpLang -> A
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (linvL x1 x2) =
      linv Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftCancellativeOp A ->
      LeftCancellativeOpOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (linvOL
                         x1
                         x2) vars =
      linv le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
  
  module LeftCancellativeSemigroup where
    record LeftCancellativeSemigroup
      (A : Set) : Set where
      constructor LeftCancellativeSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
    record LeftCancellativeSemigroupSig
      (AS : Set) : Set where
      constructor LeftCancellativeSemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record LeftCancellativeSemigroupProd
      (AP : Set) : Set where
      constructor LeftCancellativeSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
    record LeftCancellativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellativeSemigroup
         A1)
      (Le2 : LeftCancellativeSemigroup
         A2) : Set where
      constructor LeftCancellativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record LeftCancellativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellativeSemigroup
         A1)
      (Le2 : LeftCancellativeSemigroup
         A2) : Set where
      constructor LeftCancellativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data LeftCancellativeSemigroupLang
      : Set where
      opL :
        LeftCancellativeSemigroupLang ->
        LeftCancellativeSemigroupLang ->
        LeftCancellativeSemigroupLang
    data LeftCancellativeSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftCancellativeSemigroupOpenLang
          n
      opOL :
        LeftCancellativeSemigroupOpenLang
          n ->
        LeftCancellativeSemigroupOpenLang
          n ->
        LeftCancellativeSemigroupOpenLang
          n
    evalTerm :
      (A : Set) ->
      LeftCancellativeSemigroup A ->
      LeftCancellativeSemigroupLang ->
      A
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftCancellativeSemigroup A ->
      LeftCancellativeSemigroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
  
  module LeftDistributiveMagma where
    record LeftDistributiveMagma
      (A : Set) : Set where
      constructor LeftDistributiveMagmaC
      field
        op : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          op x (op y z) ==
            op (op x y) (op x z)
    record LeftDistributiveMagmaSig
      (AS : Set) : Set where
      constructor LeftDistributiveMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record LeftDistributiveMagmaProd
      (AP : Set) : Set where
      constructor LeftDistributiveMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP (opP yP zP) ==
            opP (opP xP yP) (opP xP zP)
    record LeftDistributiveMagmaHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftDistributiveMagma A1)
      (Le2 : LeftDistributiveMagma
         A2) : Set where
      constructor LeftDistributiveMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record LeftDistributiveMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftDistributiveMagma A1)
      (Le2 : LeftDistributiveMagma
         A2) : Set where
      constructor LeftDistributiveMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data LeftDistributiveMagmaLang
      : Set where
      opL :
        LeftDistributiveMagmaLang ->
        LeftDistributiveMagmaLang ->
        LeftDistributiveMagmaLang
    data LeftDistributiveMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftDistributiveMagmaOpenLang n
      opOL :
        LeftDistributiveMagmaOpenLang
          n ->
        LeftDistributiveMagmaOpenLang
          n ->
        LeftDistributiveMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      LeftDistributiveMagma A ->
      LeftDistributiveMagmaLang -> A
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftDistributiveMagma A ->
      LeftDistributiveMagmaOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
  
  module LeftIdempotence where
    record LeftIdempotence
      (A : Set) : Set where
      constructor LeftIdempotenceC
      field
        |> : A -> A -> A
        idempotent_|> :
          (x : A) -> |> x x == x
    record LeftIdempotenceSig
      (AS : Set) : Set where
      constructor LeftIdempotenceSigSigC
      field
        |>S : AS -> AS -> AS
    record LeftIdempotenceProd
      (AP : Set) : Set where
      constructor LeftIdempotenceProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
    record LeftIdempotenceHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftIdempotence A1)
      (Le2 : LeftIdempotence A2) :
      Set where
      constructor LeftIdempotenceHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
    record LeftIdempotenceRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftIdempotence A1)
      (Le2 : LeftIdempotence A2) :
      Set where
      constructor LeftIdempotenceRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
    data LeftIdempotenceLang
      : Set where
      |>L :
        LeftIdempotenceLang ->
        LeftIdempotenceLang ->
        LeftIdempotenceLang
    data LeftIdempotenceOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftIdempotenceOpenLang n
      |>OL :
        LeftIdempotenceOpenLang n ->
        LeftIdempotenceOpenLang n ->
        LeftIdempotenceOpenLang n
    evalTerm :
      (A : Set) ->
      LeftIdempotence A ->
      LeftIdempotenceLang -> A
    evalTerm _ Le (|>L x1 x2) =
      |> Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftIdempotence A ->
      LeftIdempotenceOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (|>OL
                         x1
                         x2) vars =
      |> le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
  
  module LeftInverse where
    record LeftInverse
      (A : Set) : Set where
      constructor LeftInverseC
      field
        inv : A -> A
        e : A
        op : A -> A -> A
        leftInverse_inv_op_e :
          (x : A) -> op x (inv x) == e
    record LeftInverseSig
      (AS : Set) : Set where
      constructor LeftInverseSigSigC
      field
        invS : AS -> AS
        eS : AS
        opS : AS -> AS -> AS
    record LeftInverseProd
      (AP : Set) : Set where
      constructor LeftInverseProdC
      field
        invP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP xP (invP xP) == eP
    record LeftInverseHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftInverse A1)
      (Le2 : LeftInverse A2) :
      Set where
      constructor LeftInverseHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv Le1 x1) ==
            inv Le2 (hom x1)
        pres-e : hom (e Le1) == e Le2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record LeftInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftInverse A1)
      (Le2 : LeftInverse A2) :
      Set where
      constructor LeftInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Le1 x1) (inv Le2 y1)
        interp-e :
          interp (e Le1) (e Le2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data LeftInverseLang : Set where
      invL :
        LeftInverseLang ->
        LeftInverseLang
      eL : LeftInverseLang
      opL :
        LeftInverseLang ->
        LeftInverseLang ->
        LeftInverseLang
    data LeftInverseOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> LeftInverseOpenLang n
      invOL :
        LeftInverseOpenLang n ->
        LeftInverseOpenLang n
      eOL : LeftInverseOpenLang n
      opOL :
        LeftInverseOpenLang n ->
        LeftInverseOpenLang n ->
        LeftInverseOpenLang n
    evalTerm :
      (A : Set) ->
      LeftInverse A ->
      LeftInverseLang -> A
    evalTerm _ Le (invL x1) =
      inv Le (evalTerm _ Le x1)
    evalTerm _ Le (eL) = e Le
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftInverse A ->
      LeftInverseOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (invOL
                         x1) vars =
      inv le
        (evalOpenTerm _ n le x1 vars)
    evalOpenTerm _ n le (eOL) vars =
      e le
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
  
  module LeftInverseMagma where
    record LeftInverseMagma
      (A : Set) : Set where
      constructor LeftInverseMagmaC
      field
        linv : A -> A -> A
    record LeftInverseMagmaSig
      (AS : Set) : Set where
      constructor LeftInverseMagmaSigSigC
      field
        linvS : AS -> AS -> AS
    record LeftInverseMagmaProd
      (AP : Set) : Set where
      constructor LeftInverseMagmaProdC
      field
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record LeftInverseMagmaHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftInverseMagma A1)
      (Le2 : LeftInverseMagma A2) :
      Set where
      constructor LeftInverseMagmaHomC
      field
        hom : A1 -> A2
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Le1 x1 x2) ==
            linv Le2 (hom x1) (hom x2)
    record LeftInverseMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftInverseMagma A1)
      (Le2 : LeftInverseMagma A2) :
      Set where
      constructor LeftInverseMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Le1 x1 x2)
            (linv Le2 y1 y2)
    data LeftInverseMagmaLang
      : Set where
      linvL :
        LeftInverseMagmaLang ->
        LeftInverseMagmaLang ->
        LeftInverseMagmaLang
    data LeftInverseMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftInverseMagmaOpenLang n
      linvOL :
        LeftInverseMagmaOpenLang n ->
        LeftInverseMagmaOpenLang n ->
        LeftInverseMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      LeftInverseMagma A ->
      LeftInverseMagmaLang -> A
    evalTerm _ Le (linvL x1 x2) =
      linv Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftInverseMagma A ->
      LeftInverseMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (linvOL
                         x1
                         x2) vars =
      linv le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
  
  module LeftLoop where
    record LeftLoop
      (A : Set) : Set where
      constructor LeftLoopC
      field
        op : A -> A -> A
        e : A
        runit_e : (x : A) -> op x e == x
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
    record LeftLoopSig
      (AS : Set) : Set where
      constructor LeftLoopSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
        linvS : AS -> AS -> AS
    record LeftLoopProd
      (AP : Set) : Set where
      constructor LeftLoopProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
    record LeftLoopHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftLoop A1)
      (Le2 : LeftLoop A2) : Set where
      constructor LeftLoopHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
        pres-e : hom (e Le1) == e Le2
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Le1 x1 x2) ==
            linv Le2 (hom x1) (hom x2)
    record LeftLoopRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftLoop A1)
      (Le2 : LeftLoop A2) : Set where
      constructor LeftLoopRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
        interp-e :
          interp (e Le1) (e Le2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Le1 x1 x2)
            (linv Le2 y1 y2)
    data LeftLoopLang : Set where
      opL :
        LeftLoopLang ->
        LeftLoopLang -> LeftLoopLang
      eL : LeftLoopLang
      linvL :
        LeftLoopLang ->
        LeftLoopLang -> LeftLoopLang
    data LeftLoopOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> LeftLoopOpenLang n
      opOL :
        LeftLoopOpenLang n ->
        LeftLoopOpenLang n ->
        LeftLoopOpenLang n
      eOL : LeftLoopOpenLang n
      linvOL :
        LeftLoopOpenLang n ->
        LeftLoopOpenLang n ->
        LeftLoopOpenLang n
    evalTerm :
      (A : Set) ->
      LeftLoop A -> LeftLoopLang -> A
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (eL) = e Le
    evalTerm _ Le (linvL x1 x2) =
      linv Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftLoop A ->
      LeftLoopOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (eOL) vars =
      e le
    evalOpenTerm _ n le (linvOL
                         x1
                         x2) vars =
      linv le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
  
  module LeftMonoid where
    record LeftMonoid
      (A : Set) : Set where
      constructor LeftMonoidC
      field
        op : A -> A -> A
        e : A
        lunit_e : (x : A) -> op e x == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record LeftMonoidSig
      (AS : Set) : Set where
      constructor LeftMonoidSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record LeftMonoidProd
      (AP : Set) : Set where
      constructor LeftMonoidProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record LeftMonoidHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftMonoid A1)
      (Le2 : LeftMonoid A2) :
      Set where
      constructor LeftMonoidHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
        pres-e : hom (e Le1) == e Le2
    record LeftMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftMonoid A1)
      (Le2 : LeftMonoid A2) :
      Set where
      constructor LeftMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
        interp-e :
          interp (e Le1) (e Le2)
    data LeftMonoidLang : Set where
      opL :
        LeftMonoidLang ->
        LeftMonoidLang -> LeftMonoidLang
      eL : LeftMonoidLang
    data LeftMonoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> LeftMonoidOpenLang n
      opOL :
        LeftMonoidOpenLang n ->
        LeftMonoidOpenLang n ->
        LeftMonoidOpenLang n
      eOL : LeftMonoidOpenLang n
    evalTerm :
      (A : Set) ->
      LeftMonoid A ->
      LeftMonoidLang -> A
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (eL) = e Le
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftMonoid A ->
      LeftMonoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (eOL) vars =
      e le
  
  module LeftPreSemiring where
    record LeftPreSemiring
      (A : Set) : Set where
      constructor LeftPreSemiringC
      field
        * : A -> A -> A
        + : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record LeftPreSemiringSig
      (AS : Set) : Set where
      constructor LeftPreSemiringSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record LeftPreSemiringProd
      (AP : Set) : Set where
      constructor LeftPreSemiringProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record LeftPreSemiringHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftPreSemiring A1)
      (Le2 : LeftPreSemiring A2) :
      Set where
      constructor LeftPreSemiringHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Le1 x1 x2) ==
            * Le2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Le1 x1 x2) ==
            + Le2 (hom x1) (hom x2)
    record LeftPreSemiringRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftPreSemiring A1)
      (Le2 : LeftPreSemiring A2) :
      Set where
      constructor LeftPreSemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Le1 x1 x2)
            (* Le2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Le1 x1 x2)
            (+ Le2 y1 y2)
    data LeftPreSemiringLang
      : Set where
      *L :
        LeftPreSemiringLang ->
        LeftPreSemiringLang ->
        LeftPreSemiringLang
      +L :
        LeftPreSemiringLang ->
        LeftPreSemiringLang ->
        LeftPreSemiringLang
    data LeftPreSemiringOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftPreSemiringOpenLang n
      *OL :
        LeftPreSemiringOpenLang n ->
        LeftPreSemiringOpenLang n ->
        LeftPreSemiringOpenLang n
      +OL :
        LeftPreSemiringOpenLang n ->
        LeftPreSemiringOpenLang n ->
        LeftPreSemiringOpenLang n
    evalTerm :
      (A : Set) ->
      LeftPreSemiring A ->
      LeftPreSemiringLang -> A
    evalTerm _ Le (*L x1 x2) =
      * Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (+L x1 x2) =
      + Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftPreSemiring A ->
      LeftPreSemiringOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (*OL
                         x1
                         x2) vars =
      * le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (+OL
                         x1
                         x2) vars =
      + le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
  
  module LeftQuasiGroup where
    record LeftQuasiGroup
      (A : Set) : Set where
      constructor LeftQuasiGroupC
      field
        op : A -> A -> A
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
    record LeftQuasiGroupSig
      (AS : Set) : Set where
      constructor LeftQuasiGroupSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
    record LeftQuasiGroupProd
      (AP : Set) : Set where
      constructor LeftQuasiGroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
    record LeftQuasiGroupHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftQuasiGroup A1)
      (Le2 : LeftQuasiGroup A2) :
      Set where
      constructor LeftQuasiGroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Le1 x1 x2) ==
            linv Le2 (hom x1) (hom x2)
    record LeftQuasiGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftQuasiGroup A1)
      (Le2 : LeftQuasiGroup A2) :
      Set where
      constructor LeftQuasiGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Le1 x1 x2)
            (linv Le2 y1 y2)
    data LeftQuasiGroupLang
      : Set where
      opL :
        LeftQuasiGroupLang ->
        LeftQuasiGroupLang ->
        LeftQuasiGroupLang
      linvL :
        LeftQuasiGroupLang ->
        LeftQuasiGroupLang ->
        LeftQuasiGroupLang
    data LeftQuasiGroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftQuasiGroupOpenLang n
      opOL :
        LeftQuasiGroupOpenLang n ->
        LeftQuasiGroupOpenLang n ->
        LeftQuasiGroupOpenLang n
      linvOL :
        LeftQuasiGroupOpenLang n ->
        LeftQuasiGroupOpenLang n ->
        LeftQuasiGroupOpenLang n
    evalTerm :
      (A : Set) ->
      LeftQuasiGroup A ->
      LeftQuasiGroupLang -> A
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (linvL x1 x2) =
      linv Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftQuasiGroup A ->
      LeftQuasiGroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (linvOL
                         x1
                         x2) vars =
      linv le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
  
  module LeftRack where
    record LeftRack
      (A : Set) : Set where
      constructor LeftRackC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
    record LeftRackSig
      (AS : Set) : Set where
      constructor LeftRackSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record LeftRackProd
      (AP : Set) : Set where
      constructor LeftRackProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
    record LeftRackHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftRack A1)
      (Le2 : LeftRack A2) : Set where
      constructor LeftRackHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Le1 x1 x2) ==
            <| Le2 (hom x1) (hom x2)
    record LeftRackRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftRack A1)
      (Le2 : LeftRack A2) : Set where
      constructor LeftRackRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Le1 x1 x2)
            (<| Le2 y1 y2)
    data LeftRackLang : Set where
      |>L :
        LeftRackLang ->
        LeftRackLang -> LeftRackLang
      <|L :
        LeftRackLang ->
        LeftRackLang -> LeftRackLang
    data LeftRackOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> LeftRackOpenLang n
      |>OL :
        LeftRackOpenLang n ->
        LeftRackOpenLang n ->
        LeftRackOpenLang n
      <|OL :
        LeftRackOpenLang n ->
        LeftRackOpenLang n ->
        LeftRackOpenLang n
    evalTerm :
      (A : Set) ->
      LeftRack A -> LeftRackLang -> A
    evalTerm _ Le (|>L x1 x2) =
      |> Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (<|L x1 x2) =
      <| Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftRack A ->
      LeftRackOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (|>OL
                         x1
                         x2) vars =
      |> le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (<|OL
                         x1
                         x2) vars =
      <| le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
  
  module LeftRingoid where
    record LeftRingoid
      (A : Set) : Set where
      constructor LeftRingoidC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
    record LeftRingoidSig
      (AS : Set) : Set where
      constructor LeftRingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record LeftRingoidProd
      (AP : Set) : Set where
      constructor LeftRingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
    record LeftRingoidHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftRingoid A1)
      (Le2 : LeftRingoid A2) :
      Set where
      constructor LeftRingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Le1 x1 x2) ==
            * Le2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Le1 x1 x2) ==
            + Le2 (hom x1) (hom x2)
    record LeftRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftRingoid A1)
      (Le2 : LeftRingoid A2) :
      Set where
      constructor LeftRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Le1 x1 x2)
            (* Le2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Le1 x1 x2)
            (+ Le2 y1 y2)
    data LeftRingoidLang : Set where
      *L :
        LeftRingoidLang ->
        LeftRingoidLang ->
        LeftRingoidLang
      +L :
        LeftRingoidLang ->
        LeftRingoidLang ->
        LeftRingoidLang
    data LeftRingoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> LeftRingoidOpenLang n
      *OL :
        LeftRingoidOpenLang n ->
        LeftRingoidOpenLang n ->
        LeftRingoidOpenLang n
      +OL :
        LeftRingoidOpenLang n ->
        LeftRingoidOpenLang n ->
        LeftRingoidOpenLang n
    evalTerm :
      (A : Set) ->
      LeftRingoid A ->
      LeftRingoidLang -> A
    evalTerm _ Le (*L x1 x2) =
      * Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (+L x1 x2) =
      + Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftRingoid A ->
      LeftRingoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (*OL
                         x1
                         x2) vars =
      * le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (+OL
                         x1
                         x2) vars =
      + le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
  
  module LeftShelf where
    record LeftShelf
      (A : Set) : Set where
      constructor LeftShelfC
      field
        |> : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
    record LeftShelfSig
      (AS : Set) : Set where
      constructor LeftShelfSigSigC
      field
        |>S : AS -> AS -> AS
    record LeftShelfProd
      (AP : Set) : Set where
      constructor LeftShelfProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
    record LeftShelfHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftShelf A1)
      (Le2 : LeftShelf A2) : Set where
      constructor LeftShelfHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
    record LeftShelfRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftShelf A1)
      (Le2 : LeftShelf A2) : Set where
      constructor LeftShelfRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
    data LeftShelfLang : Set where
      |>L :
        LeftShelfLang ->
        LeftShelfLang -> LeftShelfLang
    data LeftShelfOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> LeftShelfOpenLang n
      |>OL :
        LeftShelfOpenLang n ->
        LeftShelfOpenLang n ->
        LeftShelfOpenLang n
    evalTerm :
      (A : Set) ->
      LeftShelf A ->
      LeftShelfLang -> A
    evalTerm _ Le (|>L x1 x2) =
      |> Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftShelf A ->
      LeftShelfOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (|>OL
                         x1
                         x2) vars =
      |> le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
  
  module LeftShelfSig where
    record LeftShelfSig
      (A : Set) : Set where
      constructor LeftShelfSigC
      field
        |> : A -> A -> A
    record LeftShelfSigSig
      (AS : Set) : Set where
      constructor LeftShelfSigSigSigC
      field
        |>S : AS -> AS -> AS
    record LeftShelfSigProd
      (AP : Set) : Set where
      constructor LeftShelfSigProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record LeftShelfSigHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftShelfSig A1)
      (Le2 : LeftShelfSig A2) :
      Set where
      constructor LeftShelfSigHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
    record LeftShelfSigRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftShelfSig A1)
      (Le2 : LeftShelfSig A2) :
      Set where
      constructor LeftShelfSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
    data LeftShelfSigLang
      : Set where
      |>L :
        LeftShelfSigLang ->
        LeftShelfSigLang ->
        LeftShelfSigLang
    data LeftShelfSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> LeftShelfSigOpenLang n
      |>OL :
        LeftShelfSigOpenLang n ->
        LeftShelfSigOpenLang n ->
        LeftShelfSigOpenLang n
    evalTerm :
      (A : Set) ->
      LeftShelfSig A ->
      LeftShelfSigLang -> A
    evalTerm _ Le (|>L x1 x2) =
      |> Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftShelfSig A ->
      LeftShelfSigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (|>OL
                         x1
                         x2) vars =
      |> le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
  
  module LeftSpindle where
    record LeftSpindle
      (A : Set) : Set where
      constructor LeftSpindleC
      field
        |> : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        idempotent_|> :
          (x : A) -> |> x x == x
    record LeftSpindleSig
      (AS : Set) : Set where
      constructor LeftSpindleSigSigC
      field
        |>S : AS -> AS -> AS
    record LeftSpindleProd
      (AP : Set) : Set where
      constructor LeftSpindleProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
    record LeftSpindleHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftSpindle A1)
      (Le2 : LeftSpindle A2) :
      Set where
      constructor LeftSpindleHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
    record LeftSpindleRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftSpindle A1)
      (Le2 : LeftSpindle A2) :
      Set where
      constructor LeftSpindleRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
    data LeftSpindleLang : Set where
      |>L :
        LeftSpindleLang ->
        LeftSpindleLang ->
        LeftSpindleLang
    data LeftSpindleOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> LeftSpindleOpenLang n
      |>OL :
        LeftSpindleOpenLang n ->
        LeftSpindleOpenLang n ->
        LeftSpindleOpenLang n
    evalTerm :
      (A : Set) ->
      LeftSpindle A ->
      LeftSpindleLang -> A
    evalTerm _ Le (|>L x1 x2) =
      |> Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftSpindle A ->
      LeftSpindleOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (|>OL
                         x1
                         x2) vars =
      |> le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
  
  module LeftSpindle_Shelf where
    record LeftSpindle_Shelf
      (A : Set) : Set where
      constructor LeftSpindle_ShelfC
      field
        |> : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        idempotent_|> :
          (x : A) -> |> x x == x
        <| : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
    record LeftSpindle_ShelfSig
      (AS : Set) : Set where
      constructor LeftSpindle_ShelfSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record LeftSpindle_ShelfProd
      (AP : Set) : Set where
      constructor LeftSpindle_ShelfProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
    record LeftSpindle_ShelfHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftSpindle_Shelf A1)
      (Le2 : LeftSpindle_Shelf A2) :
      Set where
      constructor LeftSpindle_ShelfHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Le1 x1 x2) ==
            <| Le2 (hom x1) (hom x2)
    record LeftSpindle_ShelfRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftSpindle_Shelf A1)
      (Le2 : LeftSpindle_Shelf A2) :
      Set where
      constructor LeftSpindle_ShelfRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Le1 x1 x2)
            (<| Le2 y1 y2)
    data LeftSpindle_ShelfLang
      : Set where
      |>L :
        LeftSpindle_ShelfLang ->
        LeftSpindle_ShelfLang ->
        LeftSpindle_ShelfLang
      <|L :
        LeftSpindle_ShelfLang ->
        LeftSpindle_ShelfLang ->
        LeftSpindle_ShelfLang
    data LeftSpindle_ShelfOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftSpindle_ShelfOpenLang n
      |>OL :
        LeftSpindle_ShelfOpenLang n ->
        LeftSpindle_ShelfOpenLang n ->
        LeftSpindle_ShelfOpenLang n
      <|OL :
        LeftSpindle_ShelfOpenLang n ->
        LeftSpindle_ShelfOpenLang n ->
        LeftSpindle_ShelfOpenLang n
    evalTerm :
      (A : Set) ->
      LeftSpindle_Shelf A ->
      LeftSpindle_ShelfLang -> A
    evalTerm _ Le (|>L x1 x2) =
      |> Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (<|L x1 x2) =
      <| Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftSpindle_Shelf A ->
      LeftSpindle_ShelfOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (|>OL
                         x1
                         x2) vars =
      |> le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (<|OL
                         x1
                         x2) vars =
      <| le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
  
  module LeftSpindle_ShelfSig where
    record LeftSpindle_ShelfSig
      (A : Set) : Set where
      constructor LeftSpindle_ShelfSigC
      field
        |> : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        idempotent_|> :
          (x : A) -> |> x x == x
        <| : A -> A -> A
    record LeftSpindle_ShelfSigSig
      (AS : Set) : Set where
      constructor LeftSpindle_ShelfSigSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record LeftSpindle_ShelfSigProd
      (AP : Set) : Set where
      constructor LeftSpindle_ShelfSigProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
    record LeftSpindle_ShelfSigHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftSpindle_ShelfSig A1)
      (Le2 : LeftSpindle_ShelfSig
         A2) : Set where
      constructor LeftSpindle_ShelfSigHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Le1 x1 x2) ==
            <| Le2 (hom x1) (hom x2)
    record LeftSpindle_ShelfSigRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftSpindle_ShelfSig A1)
      (Le2 : LeftSpindle_ShelfSig
         A2) : Set where
      constructor LeftSpindle_ShelfSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Le1 x1 x2)
            (<| Le2 y1 y2)
    data LeftSpindle_ShelfSigLang
      : Set where
      |>L :
        LeftSpindle_ShelfSigLang ->
        LeftSpindle_ShelfSigLang ->
        LeftSpindle_ShelfSigLang
      <|L :
        LeftSpindle_ShelfSigLang ->
        LeftSpindle_ShelfSigLang ->
        LeftSpindle_ShelfSigLang
    data LeftSpindle_ShelfSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        LeftSpindle_ShelfSigOpenLang n
      |>OL :
        LeftSpindle_ShelfSigOpenLang
          n ->
        LeftSpindle_ShelfSigOpenLang
          n ->
        LeftSpindle_ShelfSigOpenLang n
      <|OL :
        LeftSpindle_ShelfSigOpenLang
          n ->
        LeftSpindle_ShelfSigOpenLang
          n ->
        LeftSpindle_ShelfSigOpenLang n
    evalTerm :
      (A : Set) ->
      LeftSpindle_ShelfSig A ->
      LeftSpindle_ShelfSigLang -> A
    evalTerm _ Le (|>L x1 x2) =
      |> Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalTerm _ Le (<|L x1 x2) =
      <| Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftSpindle_ShelfSig A ->
      LeftSpindle_ShelfSigOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (|>OL
                         x1
                         x2) vars =
      |> le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
    evalOpenTerm _ n le (<|OL
                         x1
                         x2) vars =
      <| le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
  
  module LeftUnital where
    record LeftUnital
      (A : Set) : Set where
      constructor LeftUnitalC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
    record LeftUnitalSig
      (AS : Set) : Set where
      constructor LeftUnitalSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record LeftUnitalProd
      (AP : Set) : Set where
      constructor LeftUnitalProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
    record LeftUnitalHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftUnital A1)
      (Le2 : LeftUnital A2) :
      Set where
      constructor LeftUnitalHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Le1) == e Le2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record LeftUnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftUnital A1)
      (Le2 : LeftUnital A2) :
      Set where
      constructor LeftUnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Le1) (e Le2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data LeftUnitalLang : Set where
      eL : LeftUnitalLang
      opL :
        LeftUnitalLang ->
        LeftUnitalLang -> LeftUnitalLang
    data LeftUnitalOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> LeftUnitalOpenLang n
      eOL : LeftUnitalOpenLang n
      opOL :
        LeftUnitalOpenLang n ->
        LeftUnitalOpenLang n ->
        LeftUnitalOpenLang n
    evalTerm :
      (A : Set) ->
      LeftUnital A ->
      LeftUnitalLang -> A
    evalTerm _ Le (eL) = e Le
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftUnital A ->
      LeftUnitalOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (eOL) vars =
      e le
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
  
  module LeftZero where
    record LeftZero
      (A : Set) : Set where
      constructor LeftZeroC
      field
        e : A
        op : A -> A -> A
        leftZero_op_e :
          (x : A) -> op e x == e
    record LeftZeroSig
      (AS : Set) : Set where
      constructor LeftZeroSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record LeftZeroProd
      (AP : Set) : Set where
      constructor LeftZeroProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftZero_op_eP :
          (xP : Prod AP AP) ->
          opP eP xP == eP
    record LeftZeroHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftZero A1)
      (Le2 : LeftZero A2) : Set where
      constructor LeftZeroHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Le1) == e Le2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record LeftZeroRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftZero A1)
      (Le2 : LeftZero A2) : Set where
      constructor LeftZeroRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Le1) (e Le2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data LeftZeroLang : Set where
      eL : LeftZeroLang
      opL :
        LeftZeroLang ->
        LeftZeroLang -> LeftZeroLang
    data LeftZeroOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> LeftZeroOpenLang n
      eOL : LeftZeroOpenLang n
      opOL :
        LeftZeroOpenLang n ->
        LeftZeroOpenLang n ->
        LeftZeroOpenLang n
    evalTerm :
      (A : Set) ->
      LeftZero A -> LeftZeroLang -> A
    evalTerm _ Le (eL) = e Le
    evalTerm _ Le (opL x1 x2) =
      op Le (evalTerm _ Le x1)
        (evalTerm _ Le x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LeftZero A ->
      LeftZeroOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n le (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n le (eOL) vars =
      e le
    evalOpenTerm _ n le (opOL
                         x1
                         x2) vars =
      op le
        (evalOpenTerm _ n le x1 vars)
        (evalOpenTerm _ n le x2 vars)
  
  module LieRing where
    record LieRing
      (A : Set) : Set where
      constructor LieRingC
      field
        0 : A
        + : A -> A -> A
        * : A -> A -> A
        jacobian_*_+ :
          (x : A) (y : A) (z : A) ->
          +
            (+ (* x (* y z)) (* y (* z x)))
            (* z (* x y)) == 0
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
        antiCommutative :
          (x : A) (y : A) ->
          * x y == neg (* y x)
    record LieRingSig
      (AS : Set) : Set where
      constructor LieRingSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
        negS : AS -> AS
        1S : AS
    record LieRingProd
      (AP : Set) : Set where
      constructor LieRingProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        jacobian_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P
            (+P (*P xP (*P yP zP))
               (*P yP (*P zP xP)))
            (*P zP (*P xP yP)) == 0P
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
        antiCommutativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == negP (*P yP xP)
    record LieRingHom
      (A1 : Set) (A2 : Set)
      (Li1 : LieRing A1)
      (Li2 : LieRing A2) : Set where
      constructor LieRingHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Li1) == 0 Li2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Li1 x1 x2) ==
            + Li2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Li1 x1 x2) ==
            * Li2 (hom x1) (hom x2)
        pres-neg :
          (x1 : A1) ->
          hom (neg Li1 x1) ==
            neg Li2 (hom x1)
        pres-1 : hom (1 Li1) == 1 Li2
    record LieRingRelInterp
      (A1 : Set) (A2 : Set)
      (Li1 : LieRing A1)
      (Li2 : LieRing A2) : Set where
      constructor LieRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Li1) (0 Li2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Li1 x1 x2)
            (+ Li2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Li1 x1 x2)
            (* Li2 y1 y2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Li1 x1) (neg Li2 y1)
        interp-1 :
          interp (1 Li1) (1 Li2)
    data LieRingLang : Set where
      0L : LieRingLang
      +L :
        LieRingLang ->
        LieRingLang -> LieRingLang
      *L :
        LieRingLang ->
        LieRingLang -> LieRingLang
      negL :
        LieRingLang -> LieRingLang
      1L : LieRingLang
    data LieRingOpenLang
      (n : Nat) : Set where
      v : Fin n -> LieRingOpenLang n
      0OL : LieRingOpenLang n
      +OL :
        LieRingOpenLang n ->
        LieRingOpenLang n ->
        LieRingOpenLang n
      *OL :
        LieRingOpenLang n ->
        LieRingOpenLang n ->
        LieRingOpenLang n
      negOL :
        LieRingOpenLang n ->
        LieRingOpenLang n
      1OL : LieRingOpenLang n
    evalTerm :
      (A : Set) ->
      LieRing A -> LieRingLang -> A
    evalTerm _ Li (0L) = 0 Li
    evalTerm _ Li (+L x1 x2) =
      + Li (evalTerm _ Li x1)
        (evalTerm _ Li x2)
    evalTerm _ Li (*L x1 x2) =
      * Li (evalTerm _ Li x1)
        (evalTerm _ Li x2)
    evalTerm _ Li (negL x1) =
      neg Li (evalTerm _ Li x1)
    evalTerm _ Li (1L) = 1 Li
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      LieRing A ->
      LieRingOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n li (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n li (0OL) vars =
      0 li
    evalOpenTerm _ n li (+OL
                         x1
                         x2) vars =
      + li
        (evalOpenTerm _ n li x1 vars)
        (evalOpenTerm _ n li x2 vars)
    evalOpenTerm _ n li (*OL
                         x1
                         x2) vars =
      * li
        (evalOpenTerm _ n li x1 vars)
        (evalOpenTerm _ n li x2 vars)
    evalOpenTerm _ n li (negOL
                         x1) vars =
      neg li
        (evalOpenTerm _ n li x1 vars)
    evalOpenTerm _ n li (1OL) vars =
      1 li
  
  module Loop where
    record Loop
      (A : Set) : Set where
      constructor LoopC
      field
        op : A -> A -> A
        e : A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
    record LoopSig
      (AS : Set) : Set where
      constructor LoopSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
        linvS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record LoopProd
      (AP : Set) : Set where
      constructor LoopProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
    record LoopHom
      (A1 : Set) (A2 : Set)
      (Lo1 : Loop A1)
      (Lo2 : Loop A2) : Set where
      constructor LoopHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Lo1 x1 x2) ==
            op Lo2 (hom x1) (hom x2)
        pres-e : hom (e Lo1) == e Lo2
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Lo1 x1 x2) ==
            linv Lo2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Lo1 x1 x2) ==
            rinv Lo2 (hom x1) (hom x2)
    record LoopRelInterp
      (A1 : Set) (A2 : Set)
      (Lo1 : Loop A1)
      (Lo2 : Loop A2) : Set where
      constructor LoopRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Lo1 x1 x2)
            (op Lo2 y1 y2)
        interp-e :
          interp (e Lo1) (e Lo2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Lo1 x1 x2)
            (linv Lo2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Lo1 x1 x2)
            (rinv Lo2 y1 y2)
    data LoopLang : Set where
      opL :
        LoopLang -> LoopLang -> LoopLang
      eL : LoopLang
      linvL :
        LoopLang -> LoopLang -> LoopLang
      rinvL :
        LoopLang -> LoopLang -> LoopLang
    data LoopOpenLang
      (n : Nat) : Set where
      v : Fin n -> LoopOpenLang n
      opOL :
        LoopOpenLang n ->
        LoopOpenLang n -> LoopOpenLang n
      eOL : LoopOpenLang n
      linvOL :
        LoopOpenLang n ->
        LoopOpenLang n -> LoopOpenLang n
      rinvOL :
        LoopOpenLang n ->
        LoopOpenLang n -> LoopOpenLang n
    evalTerm :
      (A : Set) ->
      Loop A -> LoopLang -> A
    evalTerm _ Lo (opL x1 x2) =
      op Lo (evalTerm _ Lo x1)
        (evalTerm _ Lo x2)
    evalTerm _ Lo (eL) = e Lo
    evalTerm _ Lo (linvL x1 x2) =
      linv Lo (evalTerm _ Lo x1)
        (evalTerm _ Lo x2)
    evalTerm _ Lo (rinvL x1 x2) =
      rinv Lo (evalTerm _ Lo x1)
        (evalTerm _ Lo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Loop A ->
      LoopOpenLang n -> Vec A n -> A
    evalOpenTerm _ n lo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n lo (opOL
                         x1
                         x2) vars =
      op lo
        (evalOpenTerm _ n lo x1 vars)
        (evalOpenTerm _ n lo x2 vars)
    evalOpenTerm _ n lo (eOL) vars =
      e lo
    evalOpenTerm _ n lo (linvOL
                         x1
                         x2) vars =
      linv lo
        (evalOpenTerm _ n lo x1 vars)
        (evalOpenTerm _ n lo x2 vars)
    evalOpenTerm _ n lo (rinvOL
                         x1
                         x2) vars =
      rinv lo
        (evalOpenTerm _ n lo x1 vars)
        (evalOpenTerm _ n lo x2 vars)
  
  module Magma where
    record Magma
      (A : Set) : Set where
      constructor MagmaC
      field
        op : A -> A -> A
    record MagmaSig
      (AS : Set) : Set where
      constructor MagmaSigSigC
      field
        opS : AS -> AS -> AS
    record MagmaProd
      (AP : Set) : Set where
      constructor MagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record MagmaHom
      (A1 : Set) (A2 : Set)
      (Ma1 : Magma A1)
      (Ma2 : Magma A2) : Set where
      constructor MagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ma1 x1 x2) ==
            op Ma2 (hom x1) (hom x2)
    record MagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ma1 : Magma A1)
      (Ma2 : Magma A2) : Set where
      constructor MagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ma1 x1 x2)
            (op Ma2 y1 y2)
    data MagmaLang : Set where
      opL :
        MagmaLang ->
        MagmaLang -> MagmaLang
    data MagmaOpenLang
      (n : Nat) : Set where
      v : Fin n -> MagmaOpenLang n
      opOL :
        MagmaOpenLang n ->
        MagmaOpenLang n ->
        MagmaOpenLang n
    evalTerm :
      (A : Set) ->
      Magma A -> MagmaLang -> A
    evalTerm _ Ma (opL x1 x2) =
      op Ma (evalTerm _ Ma x1)
        (evalTerm _ Ma x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Magma A ->
      MagmaOpenLang n -> Vec A n -> A
    evalOpenTerm _ n ma (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ma (opOL
                         x1
                         x2) vars =
      op ma
        (evalOpenTerm _ n ma x1 vars)
        (evalOpenTerm _ n ma x2 vars)
  
  module MedialMagma where
    record MedialMagma
      (A : Set) : Set where
      constructor MedialMagmaC
      field
        op : A -> A -> A
        mediates :
          (w : A) (x : A) (y : A)
          (z : A) ->
          op (op x y) (op z w) ==
            op (op x z) (op y w)
    record MedialMagmaSig
      (AS : Set) : Set where
      constructor MedialMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record MedialMagmaProd
      (AP : Set) : Set where
      constructor MedialMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        mediatesP :
          (wP : Prod AP AP)
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) (opP zP wP) ==
            opP (opP xP zP) (opP yP wP)
    record MedialMagmaHom
      (A1 : Set) (A2 : Set)
      (Me1 : MedialMagma A1)
      (Me2 : MedialMagma A2) :
      Set where
      constructor MedialMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Me1 x1 x2) ==
            op Me2 (hom x1) (hom x2)
    record MedialMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Me1 : MedialMagma A1)
      (Me2 : MedialMagma A2) :
      Set where
      constructor MedialMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Me1 x1 x2)
            (op Me2 y1 y2)
    data MedialMagmaLang : Set where
      opL :
        MedialMagmaLang ->
        MedialMagmaLang ->
        MedialMagmaLang
    data MedialMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> MedialMagmaOpenLang n
      opOL :
        MedialMagmaOpenLang n ->
        MedialMagmaOpenLang n ->
        MedialMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      MedialMagma A ->
      MedialMagmaLang -> A
    evalTerm _ Me (opL x1 x2) =
      op Me (evalTerm _ Me x1)
        (evalTerm _ Me x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MedialMagma A ->
      MedialMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n me (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n me (opOL
                         x1
                         x2) vars =
      op me
        (evalOpenTerm _ n me x1 vars)
        (evalOpenTerm _ n me x2 vars)
  
  module MedialQuasiGroup where
    record MedialQuasiGroup
      (A : Set) : Set where
      constructor MedialQuasiGroupC
      field
        op : A -> A -> A
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
        mediates :
          (w : A) (x : A) (y : A)
          (z : A) ->
          op (op x y) (op z w) ==
            op (op x z) (op y w)
    record MedialQuasiGroupSig
      (AS : Set) : Set where
      constructor MedialQuasiGroupSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record MedialQuasiGroupProd
      (AP : Set) : Set where
      constructor MedialQuasiGroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
        mediatesP :
          (wP : Prod AP AP)
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) (opP zP wP) ==
            opP (opP xP zP) (opP yP wP)
    record MedialQuasiGroupHom
      (A1 : Set) (A2 : Set)
      (Me1 : MedialQuasiGroup A1)
      (Me2 : MedialQuasiGroup A2) :
      Set where
      constructor MedialQuasiGroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Me1 x1 x2) ==
            op Me2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Me1 x1 x2) ==
            linv Me2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Me1 x1 x2) ==
            rinv Me2 (hom x1) (hom x2)
    record MedialQuasiGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Me1 : MedialQuasiGroup A1)
      (Me2 : MedialQuasiGroup A2) :
      Set where
      constructor MedialQuasiGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Me1 x1 x2)
            (op Me2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Me1 x1 x2)
            (linv Me2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Me1 x1 x2)
            (rinv Me2 y1 y2)
    data MedialQuasiGroupLang
      : Set where
      opL :
        MedialQuasiGroupLang ->
        MedialQuasiGroupLang ->
        MedialQuasiGroupLang
      linvL :
        MedialQuasiGroupLang ->
        MedialQuasiGroupLang ->
        MedialQuasiGroupLang
      rinvL :
        MedialQuasiGroupLang ->
        MedialQuasiGroupLang ->
        MedialQuasiGroupLang
    data MedialQuasiGroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        MedialQuasiGroupOpenLang n
      opOL :
        MedialQuasiGroupOpenLang n ->
        MedialQuasiGroupOpenLang n ->
        MedialQuasiGroupOpenLang n
      linvOL :
        MedialQuasiGroupOpenLang n ->
        MedialQuasiGroupOpenLang n ->
        MedialQuasiGroupOpenLang n
      rinvOL :
        MedialQuasiGroupOpenLang n ->
        MedialQuasiGroupOpenLang n ->
        MedialQuasiGroupOpenLang n
    evalTerm :
      (A : Set) ->
      MedialQuasiGroup A ->
      MedialQuasiGroupLang -> A
    evalTerm _ Me (opL x1 x2) =
      op Me (evalTerm _ Me x1)
        (evalTerm _ Me x2)
    evalTerm _ Me (linvL x1 x2) =
      linv Me (evalTerm _ Me x1)
        (evalTerm _ Me x2)
    evalTerm _ Me (rinvL x1 x2) =
      rinv Me (evalTerm _ Me x1)
        (evalTerm _ Me x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MedialQuasiGroup A ->
      MedialQuasiGroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n me (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n me (opOL
                         x1
                         x2) vars =
      op me
        (evalOpenTerm _ n me x1 vars)
        (evalOpenTerm _ n me x2 vars)
    evalOpenTerm _ n me (linvOL
                         x1
                         x2) vars =
      linv me
        (evalOpenTerm _ n me x1 vars)
        (evalOpenTerm _ n me x2 vars)
    evalOpenTerm _ n me (rinvOL
                         x1
                         x2) vars =
      rinv me
        (evalOpenTerm _ n me x1 vars)
        (evalOpenTerm _ n me x2 vars)
  
  module MeetSemilattice where
    record MeetSemilattice
      (A : Set) : Set where
      constructor MeetSemilatticeC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        idempotent_op :
          (x : A) -> op x x == x
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record MeetSemilatticeSig
      (AS : Set) : Set where
      constructor MeetSemilatticeSigSigC
      field
        opS : AS -> AS -> AS
    record MeetSemilatticeProd
      (AP : Set) : Set where
      constructor MeetSemilatticeProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        idempotent_opP :
          (xP : Prod AP AP) ->
          opP xP xP == xP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record MeetSemilatticeHom
      (A1 : Set) (A2 : Set)
      (Me1 : MeetSemilattice A1)
      (Me2 : MeetSemilattice A2) :
      Set where
      constructor MeetSemilatticeHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Me1 x1 x2) ==
            op Me2 (hom x1) (hom x2)
    record MeetSemilatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Me1 : MeetSemilattice A1)
      (Me2 : MeetSemilattice A2) :
      Set where
      constructor MeetSemilatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Me1 x1 x2)
            (op Me2 y1 y2)
    data MeetSemilatticeLang
      : Set where
      opL :
        MeetSemilatticeLang ->
        MeetSemilatticeLang ->
        MeetSemilatticeLang
    data MeetSemilatticeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        MeetSemilatticeOpenLang n
      opOL :
        MeetSemilatticeOpenLang n ->
        MeetSemilatticeOpenLang n ->
        MeetSemilatticeOpenLang n
    evalTerm :
      (A : Set) ->
      MeetSemilattice A ->
      MeetSemilatticeLang -> A
    evalTerm _ Me (opL x1 x2) =
      op Me (evalTerm _ Me x1)
        (evalTerm _ Me x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MeetSemilattice A ->
      MeetSemilatticeOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n me (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n me (opOL
                         x1
                         x2) vars =
      op me
        (evalOpenTerm _ n me x1 vars)
        (evalOpenTerm _ n me x2 vars)
  
  module MiddleAbsorption where
    record MiddleAbsorption
      (A : Set) : Set where
      constructor MiddleAbsorptionC
      field
        op : A -> A -> A
        middleAbsorb_* :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x z
    record MiddleAbsorptionSig
      (AS : Set) : Set where
      constructor MiddleAbsorptionSigSigC
      field
        opS : AS -> AS -> AS
    record MiddleAbsorptionProd
      (AP : Set) : Set where
      constructor MiddleAbsorptionProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        middleAbsorb_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP == opP xP zP
    record MiddleAbsorptionHom
      (A1 : Set) (A2 : Set)
      (Mi1 : MiddleAbsorption A1)
      (Mi2 : MiddleAbsorption A2) :
      Set where
      constructor MiddleAbsorptionHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mi1 x1 x2) ==
            op Mi2 (hom x1) (hom x2)
    record MiddleAbsorptionRelInterp
      (A1 : Set) (A2 : Set)
      (Mi1 : MiddleAbsorption A1)
      (Mi2 : MiddleAbsorption A2) :
      Set where
      constructor MiddleAbsorptionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mi1 x1 x2)
            (op Mi2 y1 y2)
    data MiddleAbsorptionLang
      : Set where
      opL :
        MiddleAbsorptionLang ->
        MiddleAbsorptionLang ->
        MiddleAbsorptionLang
    data MiddleAbsorptionOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        MiddleAbsorptionOpenLang n
      opOL :
        MiddleAbsorptionOpenLang n ->
        MiddleAbsorptionOpenLang n ->
        MiddleAbsorptionOpenLang n
    evalTerm :
      (A : Set) ->
      MiddleAbsorption A ->
      MiddleAbsorptionLang -> A
    evalTerm _ Mi (opL x1 x2) =
      op Mi (evalTerm _ Mi x1)
        (evalTerm _ Mi x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MiddleAbsorption A ->
      MiddleAbsorptionOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mi (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mi (opOL
                         x1
                         x2) vars =
      op mi
        (evalOpenTerm _ n mi x1 vars)
        (evalOpenTerm _ n mi x2 vars)
  
  module MiddleCommute where
    record MiddleCommute
      (A : Set) : Set where
      constructor MiddleCommuteC
      field
        op : A -> A -> A
        middleCommute_* :
          (x : A) (y : A) (z : A) ->
          op (op (op x y) z) x ==
            op (op (op x z) y) x
    record MiddleCommuteSig
      (AS : Set) : Set where
      constructor MiddleCommuteSigSigC
      field
        opS : AS -> AS -> AS
    record MiddleCommuteProd
      (AP : Set) : Set where
      constructor MiddleCommuteProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        middleCommute_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP (opP xP yP) zP) xP ==
            opP (opP (opP xP zP) yP) xP
    record MiddleCommuteHom
      (A1 : Set) (A2 : Set)
      (Mi1 : MiddleCommute A1)
      (Mi2 : MiddleCommute A2) :
      Set where
      constructor MiddleCommuteHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mi1 x1 x2) ==
            op Mi2 (hom x1) (hom x2)
    record MiddleCommuteRelInterp
      (A1 : Set) (A2 : Set)
      (Mi1 : MiddleCommute A1)
      (Mi2 : MiddleCommute A2) :
      Set where
      constructor MiddleCommuteRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mi1 x1 x2)
            (op Mi2 y1 y2)
    data MiddleCommuteLang
      : Set where
      opL :
        MiddleCommuteLang ->
        MiddleCommuteLang ->
        MiddleCommuteLang
    data MiddleCommuteOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> MiddleCommuteOpenLang n
      opOL :
        MiddleCommuteOpenLang n ->
        MiddleCommuteOpenLang n ->
        MiddleCommuteOpenLang n
    evalTerm :
      (A : Set) ->
      MiddleCommute A ->
      MiddleCommuteLang -> A
    evalTerm _ Mi (opL x1 x2) =
      op Mi (evalTerm _ Mi x1)
        (evalTerm _ Mi x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MiddleCommute A ->
      MiddleCommuteOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mi (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mi (opOL
                         x1
                         x2) vars =
      op mi
        (evalOpenTerm _ n mi x1 vars)
        (evalOpenTerm _ n mi x2 vars)
  
  module ModularLattice where
    record ModularLattice
      (A : Set) : Set where
      constructor ModularLatticeC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
        leftModular_*_+ :
          (x : A) (y : A) (z : A) ->
          + (* x y) (* x z) ==
            * x (+ y (* x z))
    record ModularLatticeSig
      (AS : Set) : Set where
      constructor ModularLatticeSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record ModularLatticeProd
      (AP : Set) : Set where
      constructor ModularLatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
        leftModular_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (*P xP yP) (*P xP zP) ==
            *P xP (+P yP (*P xP zP))
    record ModularLatticeHom
      (A1 : Set) (A2 : Set)
      (Mo1 : ModularLattice A1)
      (Mo2 : ModularLattice A2) :
      Set where
      constructor ModularLatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mo1 x1 x2) ==
            * Mo2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Mo1 x1 x2) ==
            + Mo2 (hom x1) (hom x2)
    record ModularLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : ModularLattice A1)
      (Mo2 : ModularLattice A2) :
      Set where
      constructor ModularLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mo1 x1 x2)
            (* Mo2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Mo1 x1 x2)
            (+ Mo2 y1 y2)
    data ModularLatticeLang
      : Set where
      *L :
        ModularLatticeLang ->
        ModularLatticeLang ->
        ModularLatticeLang
      +L :
        ModularLatticeLang ->
        ModularLatticeLang ->
        ModularLatticeLang
    data ModularLatticeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        ModularLatticeOpenLang n
      *OL :
        ModularLatticeOpenLang n ->
        ModularLatticeOpenLang n ->
        ModularLatticeOpenLang n
      +OL :
        ModularLatticeOpenLang n ->
        ModularLatticeOpenLang n ->
        ModularLatticeOpenLang n
    evalTerm :
      (A : Set) ->
      ModularLattice A ->
      ModularLatticeLang -> A
    evalTerm _ Mo (*L x1 x2) =
      * Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalTerm _ Mo (+L x1 x2) =
      + Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      ModularLattice A ->
      ModularLatticeOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mo (*OL
                         x1
                         x2) vars =
      * mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
    evalOpenTerm _ n mo (+OL
                         x1
                         x2) vars =
      + mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
  
  module Modularity where
    record Modularity
      (A : Set) : Set where
      constructor ModularityC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftModular_*_+ :
          (x : A) (y : A) (z : A) ->
          + (* x y) (* x z) ==
            * x (+ y (* x z))
    record ModularitySig
      (AS : Set) : Set where
      constructor ModularitySigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record ModularityProd
      (AP : Set) : Set where
      constructor ModularityProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftModular_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (*P xP yP) (*P xP zP) ==
            *P xP (+P yP (*P xP zP))
    record ModularityHom
      (A1 : Set) (A2 : Set)
      (Mo1 : Modularity A1)
      (Mo2 : Modularity A2) :
      Set where
      constructor ModularityHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mo1 x1 x2) ==
            * Mo2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Mo1 x1 x2) ==
            + Mo2 (hom x1) (hom x2)
    record ModularityRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : Modularity A1)
      (Mo2 : Modularity A2) :
      Set where
      constructor ModularityRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mo1 x1 x2)
            (* Mo2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Mo1 x1 x2)
            (+ Mo2 y1 y2)
    data ModularityLang : Set where
      *L :
        ModularityLang ->
        ModularityLang -> ModularityLang
      +L :
        ModularityLang ->
        ModularityLang -> ModularityLang
    data ModularityOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> ModularityOpenLang n
      *OL :
        ModularityOpenLang n ->
        ModularityOpenLang n ->
        ModularityOpenLang n
      +OL :
        ModularityOpenLang n ->
        ModularityOpenLang n ->
        ModularityOpenLang n
    evalTerm :
      (A : Set) ->
      Modularity A ->
      ModularityLang -> A
    evalTerm _ Mo (*L x1 x2) =
      * Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalTerm _ Mo (+L x1 x2) =
      + Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Modularity A ->
      ModularityOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mo (*OL
                         x1
                         x2) vars =
      * mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
    evalOpenTerm _ n mo (+OL
                         x1
                         x2) vars =
      + mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
  
  module Monoid where
    record Monoid
      (A : Set) : Set where
      constructor MonoidC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record MonoidSig
      (AS : Set) : Set where
      constructor MonoidSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record MonoidProd
      (AP : Set) : Set where
      constructor MonoidProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record MonoidHom
      (A1 : Set) (A2 : Set)
      (Mo1 : Monoid A1)
      (Mo2 : Monoid A2) : Set where
      constructor MonoidHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Mo1) == e Mo2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mo1 x1 x2) ==
            op Mo2 (hom x1) (hom x2)
    record MonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : Monoid A1)
      (Mo2 : Monoid A2) : Set where
      constructor MonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Mo1) (e Mo2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mo1 x1 x2)
            (op Mo2 y1 y2)
    data MonoidLang : Set where
      eL : MonoidLang
      opL :
        MonoidLang ->
        MonoidLang -> MonoidLang
    data MonoidOpenLang
      (n : Nat) : Set where
      v : Fin n -> MonoidOpenLang n
      eOL : MonoidOpenLang n
      opOL :
        MonoidOpenLang n ->
        MonoidOpenLang n ->
        MonoidOpenLang n
    evalTerm :
      (A : Set) ->
      Monoid A -> MonoidLang -> A
    evalTerm _ Mo (eL) = e Mo
    evalTerm _ Mo (opL x1 x2) =
      op Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Monoid A ->
      MonoidOpenLang n -> Vec A n -> A
    evalOpenTerm _ n mo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mo (eOL) vars =
      e mo
    evalOpenTerm _ n mo (opOL
                         x1
                         x2) vars =
      op mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
  
  module Monoid1 where
    record Monoid1
      (A : Set) : Set where
      constructor Monoid1C
      field
        1 : A
        op : A -> A -> A
        lunit_1 : (x : A) -> op 1 x == x
        runit_1 : (x : A) -> op x 1 == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record Monoid1Sig
      (AS : Set) : Set where
      constructor Monoid1SigSigC
      field
        1S : AS
        opS : AS -> AS -> AS
    record Monoid1Prod
      (AP : Set) : Set where
      constructor Monoid1ProdC
      field
        1P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          opP 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          opP xP 1P == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record Monoid1Hom
      (A1 : Set) (A2 : Set)
      (Mo1 : Monoid1 A1)
      (Mo2 : Monoid1 A2) : Set where
      constructor Monoid1HomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Mo1) == 1 Mo2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mo1 x1 x2) ==
            op Mo2 (hom x1) (hom x2)
    record Monoid1RelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : Monoid1 A1)
      (Mo2 : Monoid1 A2) : Set where
      constructor Monoid1RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Mo1) (1 Mo2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mo1 x1 x2)
            (op Mo2 y1 y2)
    data Monoid1Lang : Set where
      1L : Monoid1Lang
      opL :
        Monoid1Lang ->
        Monoid1Lang -> Monoid1Lang
    data Monoid1OpenLang
      (n : Nat) : Set where
      v : Fin n -> Monoid1OpenLang n
      1OL : Monoid1OpenLang n
      opOL :
        Monoid1OpenLang n ->
        Monoid1OpenLang n ->
        Monoid1OpenLang n
    evalTerm :
      (A : Set) ->
      Monoid1 A -> Monoid1Lang -> A
    evalTerm _ Mo (1L) = 1 Mo
    evalTerm _ Mo (opL x1 x2) =
      op Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Monoid1 A ->
      Monoid1OpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mo (1OL) vars =
      1 mo
    evalOpenTerm _ n mo (opOL
                         x1
                         x2) vars =
      op mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
  
  module MoufangIdentity where
    record MoufangIdentity
      (A : Set) : Set where
      constructor MoufangIdentityC
      field
        op : A -> A -> A
        moufangId :
          (x : A) (y : A) (z : A) ->
          op (op z x) (op y z) ==
            op (op z (op x y)) z
    record MoufangIdentitySig
      (AS : Set) : Set where
      constructor MoufangIdentitySigSigC
      field
        opS : AS -> AS -> AS
    record MoufangIdentityProd
      (AP : Set) : Set where
      constructor MoufangIdentityProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        moufangIdP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP zP xP) (opP yP zP) ==
            opP (opP zP (opP xP yP)) zP
    record MoufangIdentityHom
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangIdentity A1)
      (Mo2 : MoufangIdentity A2) :
      Set where
      constructor MoufangIdentityHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mo1 x1 x2) ==
            op Mo2 (hom x1) (hom x2)
    record MoufangIdentityRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangIdentity A1)
      (Mo2 : MoufangIdentity A2) :
      Set where
      constructor MoufangIdentityRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mo1 x1 x2)
            (op Mo2 y1 y2)
    data MoufangIdentityLang
      : Set where
      opL :
        MoufangIdentityLang ->
        MoufangIdentityLang ->
        MoufangIdentityLang
    data MoufangIdentityOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        MoufangIdentityOpenLang n
      opOL :
        MoufangIdentityOpenLang n ->
        MoufangIdentityOpenLang n ->
        MoufangIdentityOpenLang n
    evalTerm :
      (A : Set) ->
      MoufangIdentity A ->
      MoufangIdentityLang -> A
    evalTerm _ Mo (opL x1 x2) =
      op Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MoufangIdentity A ->
      MoufangIdentityOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mo (opOL
                         x1
                         x2) vars =
      op mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
  
  module MoufangLaw where
    record MoufangLaw
      (A : Set) : Set where
      constructor MoufangLawC
      field
        op : A -> A -> A
        moufangLaw :
          (e : A) (x : A) (y : A)
          (z : A) ->
          op y e == y ->
          op (op (op x y) z) x ==
            op x (op y (op (op e z) x))
    record MoufangLawSig
      (AS : Set) : Set where
      constructor MoufangLawSigSigC
      field
        opS : AS -> AS -> AS
    record MoufangLawProd
      (AP : Set) : Set where
      constructor MoufangLawProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        moufangLawP :
          (eP : Prod AP AP)
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP yP eP == yP ->
          opP (opP (opP xP yP) zP) xP ==
            opP xP
              (opP yP (opP (opP eP zP) xP))
    record MoufangLawHom
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangLaw A1)
      (Mo2 : MoufangLaw A2) :
      Set where
      constructor MoufangLawHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mo1 x1 x2) ==
            op Mo2 (hom x1) (hom x2)
    record MoufangLawRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangLaw A1)
      (Mo2 : MoufangLaw A2) :
      Set where
      constructor MoufangLawRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mo1 x1 x2)
            (op Mo2 y1 y2)
    data MoufangLawLang : Set where
      opL :
        MoufangLawLang ->
        MoufangLawLang -> MoufangLawLang
    data MoufangLawOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> MoufangLawOpenLang n
      opOL :
        MoufangLawOpenLang n ->
        MoufangLawOpenLang n ->
        MoufangLawOpenLang n
    evalTerm :
      (A : Set) ->
      MoufangLaw A ->
      MoufangLawLang -> A
    evalTerm _ Mo (opL x1 x2) =
      op Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MoufangLaw A ->
      MoufangLawOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mo (opOL
                         x1
                         x2) vars =
      op mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
  
  module MoufangLoop where
    record MoufangLoop
      (A : Set) : Set where
      constructor MoufangLoopC
      field
        op : A -> A -> A
        e : A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
        moufangId :
          (x : A) (y : A) (z : A) ->
          op (op z x) (op y z) ==
            op (op z (op x y)) z
    record MoufangLoopSig
      (AS : Set) : Set where
      constructor MoufangLoopSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
        linvS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record MoufangLoopProd
      (AP : Set) : Set where
      constructor MoufangLoopProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
        moufangIdP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP zP xP) (opP yP zP) ==
            opP (opP zP (opP xP yP)) zP
    record MoufangLoopHom
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangLoop A1)
      (Mo2 : MoufangLoop A2) :
      Set where
      constructor MoufangLoopHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mo1 x1 x2) ==
            op Mo2 (hom x1) (hom x2)
        pres-e : hom (e Mo1) == e Mo2
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Mo1 x1 x2) ==
            linv Mo2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Mo1 x1 x2) ==
            rinv Mo2 (hom x1) (hom x2)
    record MoufangLoopRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangLoop A1)
      (Mo2 : MoufangLoop A2) :
      Set where
      constructor MoufangLoopRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mo1 x1 x2)
            (op Mo2 y1 y2)
        interp-e :
          interp (e Mo1) (e Mo2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Mo1 x1 x2)
            (linv Mo2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Mo1 x1 x2)
            (rinv Mo2 y1 y2)
    data MoufangLoopLang : Set where
      opL :
        MoufangLoopLang ->
        MoufangLoopLang ->
        MoufangLoopLang
      eL : MoufangLoopLang
      linvL :
        MoufangLoopLang ->
        MoufangLoopLang ->
        MoufangLoopLang
      rinvL :
        MoufangLoopLang ->
        MoufangLoopLang ->
        MoufangLoopLang
    data MoufangLoopOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> MoufangLoopOpenLang n
      opOL :
        MoufangLoopOpenLang n ->
        MoufangLoopOpenLang n ->
        MoufangLoopOpenLang n
      eOL : MoufangLoopOpenLang n
      linvOL :
        MoufangLoopOpenLang n ->
        MoufangLoopOpenLang n ->
        MoufangLoopOpenLang n
      rinvOL :
        MoufangLoopOpenLang n ->
        MoufangLoopOpenLang n ->
        MoufangLoopOpenLang n
    evalTerm :
      (A : Set) ->
      MoufangLoop A ->
      MoufangLoopLang -> A
    evalTerm _ Mo (opL x1 x2) =
      op Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalTerm _ Mo (eL) = e Mo
    evalTerm _ Mo (linvL x1 x2) =
      linv Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalTerm _ Mo (rinvL x1 x2) =
      rinv Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MoufangLoop A ->
      MoufangLoopOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mo (opOL
                         x1
                         x2) vars =
      op mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
    evalOpenTerm _ n mo (eOL) vars =
      e mo
    evalOpenTerm _ n mo (linvOL
                         x1
                         x2) vars =
      linv mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
    evalOpenTerm _ n mo (rinvOL
                         x1
                         x2) vars =
      rinv mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
  
  module MoufangQuasiGroup where
    record MoufangQuasiGroup
      (A : Set) : Set where
      constructor MoufangQuasiGroupC
      field
        op : A -> A -> A
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
        moufangLaw :
          (e : A) (x : A) (y : A)
          (z : A) ->
          op y e == y ->
          op (op (op x y) z) x ==
            op x (op y (op (op e z) x))
    record MoufangQuasiGroupSig
      (AS : Set) : Set where
      constructor MoufangQuasiGroupSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record MoufangQuasiGroupProd
      (AP : Set) : Set where
      constructor MoufangQuasiGroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
        moufangLawP :
          (eP : Prod AP AP)
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP yP eP == yP ->
          opP (opP (opP xP yP) zP) xP ==
            opP xP
              (opP yP (opP (opP eP zP) xP))
    record MoufangQuasiGroupHom
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangQuasiGroup A1)
      (Mo2 : MoufangQuasiGroup A2) :
      Set where
      constructor MoufangQuasiGroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mo1 x1 x2) ==
            op Mo2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Mo1 x1 x2) ==
            linv Mo2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Mo1 x1 x2) ==
            rinv Mo2 (hom x1) (hom x2)
    record MoufangQuasiGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangQuasiGroup A1)
      (Mo2 : MoufangQuasiGroup A2) :
      Set where
      constructor MoufangQuasiGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mo1 x1 x2)
            (op Mo2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Mo1 x1 x2)
            (linv Mo2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Mo1 x1 x2)
            (rinv Mo2 y1 y2)
    data MoufangQuasiGroupLang
      : Set where
      opL :
        MoufangQuasiGroupLang ->
        MoufangQuasiGroupLang ->
        MoufangQuasiGroupLang
      linvL :
        MoufangQuasiGroupLang ->
        MoufangQuasiGroupLang ->
        MoufangQuasiGroupLang
      rinvL :
        MoufangQuasiGroupLang ->
        MoufangQuasiGroupLang ->
        MoufangQuasiGroupLang
    data MoufangQuasiGroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        MoufangQuasiGroupOpenLang n
      opOL :
        MoufangQuasiGroupOpenLang n ->
        MoufangQuasiGroupOpenLang n ->
        MoufangQuasiGroupOpenLang n
      linvOL :
        MoufangQuasiGroupOpenLang n ->
        MoufangQuasiGroupOpenLang n ->
        MoufangQuasiGroupOpenLang n
      rinvOL :
        MoufangQuasiGroupOpenLang n ->
        MoufangQuasiGroupOpenLang n ->
        MoufangQuasiGroupOpenLang n
    evalTerm :
      (A : Set) ->
      MoufangQuasiGroup A ->
      MoufangQuasiGroupLang -> A
    evalTerm _ Mo (opL x1 x2) =
      op Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalTerm _ Mo (linvL x1 x2) =
      linv Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalTerm _ Mo (rinvL x1 x2) =
      rinv Mo (evalTerm _ Mo x1)
        (evalTerm _ Mo x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MoufangQuasiGroup A ->
      MoufangQuasiGroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mo (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mo (opOL
                         x1
                         x2) vars =
      op mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
    evalOpenTerm _ n mo (linvOL
                         x1
                         x2) vars =
      linv mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
    evalOpenTerm _ n mo (rinvOL
                         x1
                         x2) vars =
      rinv mo
        (evalOpenTerm _ n mo x1 vars)
        (evalOpenTerm _ n mo x2 vars)
  
  module MultCommutativeMonoid where
    record MultCommutativeMonoid
      (A : Set) : Set where
      constructor MultCommutativeMonoidC
      field
        1 : A
        * : A -> A -> A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
    record MultCommutativeMonoidSig
      (AS : Set) : Set where
      constructor MultCommutativeMonoidSigSigC
      field
        1S : AS
        *S : AS -> AS -> AS
    record MultCommutativeMonoidProd
      (AP : Set) : Set where
      constructor MultCommutativeMonoidProdC
      field
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
    record MultCommutativeMonoidHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultCommutativeMonoid A1)
      (Mu2 : MultCommutativeMonoid
         A2) : Set where
      constructor MultCommutativeMonoidHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Mu1) == 1 Mu2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultCommutativeMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultCommutativeMonoid A1)
      (Mu2 : MultCommutativeMonoid
         A2) : Set where
      constructor MultCommutativeMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Mu1) (1 Mu2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultCommutativeMonoidLang
      : Set where
      1L : MultCommutativeMonoidLang
      *L :
        MultCommutativeMonoidLang ->
        MultCommutativeMonoidLang ->
        MultCommutativeMonoidLang
    data MultCommutativeMonoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        MultCommutativeMonoidOpenLang n
      1OL :
        MultCommutativeMonoidOpenLang n
      *OL :
        MultCommutativeMonoidOpenLang
          n ->
        MultCommutativeMonoidOpenLang
          n ->
        MultCommutativeMonoidOpenLang n
    evalTerm :
      (A : Set) ->
      MultCommutativeMonoid A ->
      MultCommutativeMonoidLang -> A
    evalTerm _ Mu (1L) = 1 Mu
    evalTerm _ Mu (*L x1 x2) =
      * Mu (evalTerm _ Mu x1)
        (evalTerm _ Mu x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MultCommutativeMonoid A ->
      MultCommutativeMonoidOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n mu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mu (1OL) vars =
      1 mu
    evalOpenTerm _ n mu (*OL
                         x1
                         x2) vars =
      * mu
        (evalOpenTerm _ n mu x1 vars)
        (evalOpenTerm _ n mu x2 vars)
  
  module MultCommutativeSemigroup where
    record MultCommutativeSemigroup
      (A : Set) : Set where
      constructor MultCommutativeSemigroupC
      field
        * : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
    record MultCommutativeSemigroupSig
      (AS : Set) : Set where
      constructor MultCommutativeSemigroupSigSigC
      field
        *S : AS -> AS -> AS
    record MultCommutativeSemigroupProd
      (AP : Set) : Set where
      constructor MultCommutativeSemigroupProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
    record MultCommutativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultCommutativeSemigroup
         A1)
      (Mu2 : MultCommutativeSemigroup
         A2) : Set where
      constructor MultCommutativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultCommutativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultCommutativeSemigroup
         A1)
      (Mu2 : MultCommutativeSemigroup
         A2) : Set where
      constructor MultCommutativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultCommutativeSemigroupLang
      : Set where
      *L :
        MultCommutativeSemigroupLang ->
        MultCommutativeSemigroupLang ->
        MultCommutativeSemigroupLang
    data MultCommutativeSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        MultCommutativeSemigroupOpenLang
          n
      *OL :
        MultCommutativeSemigroupOpenLang
          n ->
        MultCommutativeSemigroupOpenLang
          n ->
        MultCommutativeSemigroupOpenLang
          n
    evalTerm :
      (A : Set) ->
      MultCommutativeSemigroup A ->
      MultCommutativeSemigroupLang ->
      A
    evalTerm _ Mu (*L x1 x2) =
      * Mu (evalTerm _ Mu x1)
        (evalTerm _ Mu x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MultCommutativeSemigroup A ->
      MultCommutativeSemigroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n mu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mu (*OL
                         x1
                         x2) vars =
      * mu
        (evalOpenTerm _ n mu x1 vars)
        (evalOpenTerm _ n mu x2 vars)
  
  module MultGroup where
    record MultGroup
      (A : Set) : Set where
      constructor MultGroupC
      field
        1 : A
        * : A -> A -> A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        inv : A -> A
        leftInverse_inv_op_1 :
          (x : A) -> * x (inv x) == 1
        rightInverse_inv_op_1 :
          (x : A) -> * (inv x) x == 1
    record MultGroupSig
      (AS : Set) : Set where
      constructor MultGroupSigSigC
      field
        1S : AS
        *S : AS -> AS -> AS
        invS : AS -> AS
    record MultGroupProd
      (AP : Set) : Set where
      constructor MultGroupProdC
      field
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P xP (invP xP) == 1P
        rightInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P (invP xP) xP == 1P
    record MultGroupHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultGroup A1)
      (Mu2 : MultGroup A2) : Set where
      constructor MultGroupHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Mu1) == 1 Mu2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
        pres-inv :
          (x1 : A1) ->
          hom (inv Mu1 x1) ==
            inv Mu2 (hom x1)
    record MultGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultGroup A1)
      (Mu2 : MultGroup A2) : Set where
      constructor MultGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Mu1) (1 Mu2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Mu1 x1) (inv Mu2 y1)
    data MultGroupLang : Set where
      1L : MultGroupLang
      *L :
        MultGroupLang ->
        MultGroupLang -> MultGroupLang
      invL :
        MultGroupLang -> MultGroupLang
    data MultGroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> MultGroupOpenLang n
      1OL : MultGroupOpenLang n
      *OL :
        MultGroupOpenLang n ->
        MultGroupOpenLang n ->
        MultGroupOpenLang n
      invOL :
        MultGroupOpenLang n ->
        MultGroupOpenLang n
    evalTerm :
      (A : Set) ->
      MultGroup A ->
      MultGroupLang -> A
    evalTerm _ Mu (1L) = 1 Mu
    evalTerm _ Mu (*L x1 x2) =
      * Mu (evalTerm _ Mu x1)
        (evalTerm _ Mu x2)
    evalTerm _ Mu (invL x1) =
      inv Mu (evalTerm _ Mu x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MultGroup A ->
      MultGroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mu (1OL) vars =
      1 mu
    evalOpenTerm _ n mu (*OL
                         x1
                         x2) vars =
      * mu
        (evalOpenTerm _ n mu x1 vars)
        (evalOpenTerm _ n mu x2 vars)
    evalOpenTerm _ n mu (invOL
                         x1) vars =
      inv mu
        (evalOpenTerm _ n mu x1 vars)
  
  module MultMagma where
    record MultMagma
      (A : Set) : Set where
      constructor MultMagmaC
      field
        * : A -> A -> A
    record MultMagmaSig
      (AS : Set) : Set where
      constructor MultMagmaSigSigC
      field
        *S : AS -> AS -> AS
    record MultMagmaProd
      (AP : Set) : Set where
      constructor MultMagmaProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record MultMagmaHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultMagma A1)
      (Mu2 : MultMagma A2) : Set where
      constructor MultMagmaHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultMagma A1)
      (Mu2 : MultMagma A2) : Set where
      constructor MultMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultMagmaLang : Set where
      *L :
        MultMagmaLang ->
        MultMagmaLang -> MultMagmaLang
    data MultMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> MultMagmaOpenLang n
      *OL :
        MultMagmaOpenLang n ->
        MultMagmaOpenLang n ->
        MultMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      MultMagma A ->
      MultMagmaLang -> A
    evalTerm _ Mu (*L x1 x2) =
      * Mu (evalTerm _ Mu x1)
        (evalTerm _ Mu x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MultMagma A ->
      MultMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mu (*OL
                         x1
                         x2) vars =
      * mu
        (evalOpenTerm _ n mu x1 vars)
        (evalOpenTerm _ n mu x2 vars)
  
  module MultMeetSemilattice where
    record MultMeetSemilattice
      (A : Set) : Set where
      constructor MultMeetSemilatticeC
      field
        * : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
    record MultMeetSemilatticeSig
      (AS : Set) : Set where
      constructor MultMeetSemilatticeSigSigC
      field
        *S : AS -> AS -> AS
    record MultMeetSemilatticeProd
      (AP : Set) : Set where
      constructor MultMeetSemilatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
    record MultMeetSemilatticeHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultMeetSemilattice A1)
      (Mu2 : MultMeetSemilattice A2) :
      Set where
      constructor MultMeetSemilatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultMeetSemilatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultMeetSemilattice A1)
      (Mu2 : MultMeetSemilattice A2) :
      Set where
      constructor MultMeetSemilatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultMeetSemilatticeLang
      : Set where
      *L :
        MultMeetSemilatticeLang ->
        MultMeetSemilatticeLang ->
        MultMeetSemilatticeLang
    data MultMeetSemilatticeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        MultMeetSemilatticeOpenLang n
      *OL :
        MultMeetSemilatticeOpenLang n ->
        MultMeetSemilatticeOpenLang n ->
        MultMeetSemilatticeOpenLang n
    evalTerm :
      (A : Set) ->
      MultMeetSemilattice A ->
      MultMeetSemilatticeLang -> A
    evalTerm _ Mu (*L x1 x2) =
      * Mu (evalTerm _ Mu x1)
        (evalTerm _ Mu x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MultMeetSemilattice A ->
      MultMeetSemilatticeOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mu (*OL
                         x1
                         x2) vars =
      * mu
        (evalOpenTerm _ n mu x1 vars)
        (evalOpenTerm _ n mu x2 vars)
  
  module MultMonoid where
    record MultMonoid
      (A : Set) : Set where
      constructor MultMonoidC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
    record MultMonoidSig
      (AS : Set) : Set where
      constructor MultMonoidSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
    record MultMonoidProd
      (AP : Set) : Set where
      constructor MultMonoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
    record MultMonoidHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultMonoid A1)
      (Mu2 : MultMonoid A2) :
      Set where
      constructor MultMonoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
        pres-1 : hom (1 Mu1) == 1 Mu2
    record MultMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultMonoid A1)
      (Mu2 : MultMonoid A2) :
      Set where
      constructor MultMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
        interp-1 :
          interp (1 Mu1) (1 Mu2)
    data MultMonoidLang : Set where
      *L :
        MultMonoidLang ->
        MultMonoidLang -> MultMonoidLang
      1L : MultMonoidLang
    data MultMonoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> MultMonoidOpenLang n
      *OL :
        MultMonoidOpenLang n ->
        MultMonoidOpenLang n ->
        MultMonoidOpenLang n
      1OL : MultMonoidOpenLang n
    evalTerm :
      (A : Set) ->
      MultMonoid A ->
      MultMonoidLang -> A
    evalTerm _ Mu (*L x1 x2) =
      * Mu (evalTerm _ Mu x1)
        (evalTerm _ Mu x2)
    evalTerm _ Mu (1L) = 1 Mu
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MultMonoid A ->
      MultMonoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mu (*OL
                         x1
                         x2) vars =
      * mu
        (evalOpenTerm _ n mu x1 vars)
        (evalOpenTerm _ n mu x2 vars)
    evalOpenTerm _ n mu (1OL) vars =
      1 mu
  
  module MultPointedMagma where
    record MultPointedMagma
      (A : Set) : Set where
      constructor MultPointedMagmaC
      field
        1 : A
        * : A -> A -> A
    record MultPointedMagmaSig
      (AS : Set) : Set where
      constructor MultPointedMagmaSigSigC
      field
        1S : AS
        *S : AS -> AS -> AS
    record MultPointedMagmaProd
      (AP : Set) : Set where
      constructor MultPointedMagmaProdC
      field
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record MultPointedMagmaHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultPointedMagma A1)
      (Mu2 : MultPointedMagma A2) :
      Set where
      constructor MultPointedMagmaHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Mu1) == 1 Mu2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultPointedMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultPointedMagma A1)
      (Mu2 : MultPointedMagma A2) :
      Set where
      constructor MultPointedMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Mu1) (1 Mu2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultPointedMagmaLang
      : Set where
      1L : MultPointedMagmaLang
      *L :
        MultPointedMagmaLang ->
        MultPointedMagmaLang ->
        MultPointedMagmaLang
    data MultPointedMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        MultPointedMagmaOpenLang n
      1OL : MultPointedMagmaOpenLang n
      *OL :
        MultPointedMagmaOpenLang n ->
        MultPointedMagmaOpenLang n ->
        MultPointedMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      MultPointedMagma A ->
      MultPointedMagmaLang -> A
    evalTerm _ Mu (1L) = 1 Mu
    evalTerm _ Mu (*L x1 x2) =
      * Mu (evalTerm _ Mu x1)
        (evalTerm _ Mu x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MultPointedMagma A ->
      MultPointedMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mu (1OL) vars =
      1 mu
    evalOpenTerm _ n mu (*OL
                         x1
                         x2) vars =
      * mu
        (evalOpenTerm _ n mu x1 vars)
        (evalOpenTerm _ n mu x2 vars)
  
  module MultPointedSemigroup where
    record MultPointedSemigroup
      (A : Set) : Set where
      constructor MultPointedSemigroupC
      field
        1 : A
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
    record MultPointedSemigroupSig
      (AS : Set) : Set where
      constructor MultPointedSemigroupSigSigC
      field
        1S : AS
        *S : AS -> AS -> AS
    record MultPointedSemigroupProd
      (AP : Set) : Set where
      constructor MultPointedSemigroupProdC
      field
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
    record MultPointedSemigroupHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultPointedSemigroup A1)
      (Mu2 : MultPointedSemigroup
         A2) : Set where
      constructor MultPointedSemigroupHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Mu1) == 1 Mu2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultPointedSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultPointedSemigroup A1)
      (Mu2 : MultPointedSemigroup
         A2) : Set where
      constructor MultPointedSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Mu1) (1 Mu2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultPointedSemigroupLang
      : Set where
      1L : MultPointedSemigroupLang
      *L :
        MultPointedSemigroupLang ->
        MultPointedSemigroupLang ->
        MultPointedSemigroupLang
    data MultPointedSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        MultPointedSemigroupOpenLang n
      1OL :
        MultPointedSemigroupOpenLang n
      *OL :
        MultPointedSemigroupOpenLang
          n ->
        MultPointedSemigroupOpenLang
          n ->
        MultPointedSemigroupOpenLang n
    evalTerm :
      (A : Set) ->
      MultPointedSemigroup A ->
      MultPointedSemigroupLang -> A
    evalTerm _ Mu (1L) = 1 Mu
    evalTerm _ Mu (*L x1 x2) =
      * Mu (evalTerm _ Mu x1)
        (evalTerm _ Mu x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MultPointedSemigroup A ->
      MultPointedSemigroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n mu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mu (1OL) vars =
      1 mu
    evalOpenTerm _ n mu (*OL
                         x1
                         x2) vars =
      * mu
        (evalOpenTerm _ n mu x1 vars)
        (evalOpenTerm _ n mu x2 vars)
  
  module MultSemigroup where
    record MultSemigroup
      (A : Set) : Set where
      constructor MultSemigroupC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
    record MultSemigroupSig
      (AS : Set) : Set where
      constructor MultSemigroupSigSigC
      field
        *S : AS -> AS -> AS
    record MultSemigroupProd
      (AP : Set) : Set where
      constructor MultSemigroupProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
    record MultSemigroupHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultSemigroup A1)
      (Mu2 : MultSemigroup A2) :
      Set where
      constructor MultSemigroupHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultSemigroup A1)
      (Mu2 : MultSemigroup A2) :
      Set where
      constructor MultSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultSemigroupLang
      : Set where
      *L :
        MultSemigroupLang ->
        MultSemigroupLang ->
        MultSemigroupLang
    data MultSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> MultSemigroupOpenLang n
      *OL :
        MultSemigroupOpenLang n ->
        MultSemigroupOpenLang n ->
        MultSemigroupOpenLang n
    evalTerm :
      (A : Set) ->
      MultSemigroup A ->
      MultSemigroupLang -> A
    evalTerm _ Mu (*L x1 x2) =
      * Mu (evalTerm _ Mu x1)
        (evalTerm _ Mu x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MultSemigroup A ->
      MultSemigroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mu (*OL
                         x1
                         x2) vars =
      * mu
        (evalOpenTerm _ n mu x1 vars)
        (evalOpenTerm _ n mu x2 vars)
  
  module MultSemilattice_RingoidSig where
    record MultSemilattice_RingoidSig
      (A : Set) : Set where
      constructor MultSemilattice_RingoidSigC
      field
        * : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        + : A -> A -> A
    record MultSemilattice_RingoidSigSig
      (AS : Set) : Set where
      constructor MultSemilattice_RingoidSigSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record MultSemilattice_RingoidSigProd
      (AP : Set) : Set where
      constructor MultSemilattice_RingoidSigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
    record MultSemilattice_RingoidSigHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultSemilattice_RingoidSig
         A1)
      (Mu2 : MultSemilattice_RingoidSig
         A2) : Set where
      constructor MultSemilattice_RingoidSigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Mu1 x1 x2) ==
            + Mu2 (hom x1) (hom x2)
    record MultSemilattice_RingoidSigRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultSemilattice_RingoidSig
         A1)
      (Mu2 : MultSemilattice_RingoidSig
         A2) : Set where
      constructor MultSemilattice_RingoidSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Mu1 x1 x2)
            (+ Mu2 y1 y2)
    data MultSemilattice_RingoidSigLang
      : Set where
      *L :
        MultSemilattice_RingoidSigLang ->
        MultSemilattice_RingoidSigLang ->
        MultSemilattice_RingoidSigLang
      +L :
        MultSemilattice_RingoidSigLang ->
        MultSemilattice_RingoidSigLang ->
        MultSemilattice_RingoidSigLang
    data MultSemilattice_RingoidSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        MultSemilattice_RingoidSigOpenLang
          n
      *OL :
        MultSemilattice_RingoidSigOpenLang
          n ->
        MultSemilattice_RingoidSigOpenLang
          n ->
        MultSemilattice_RingoidSigOpenLang
          n
      +OL :
        MultSemilattice_RingoidSigOpenLang
          n ->
        MultSemilattice_RingoidSigOpenLang
          n ->
        MultSemilattice_RingoidSigOpenLang
          n
    evalTerm :
      (A : Set) ->
      MultSemilattice_RingoidSig A ->
      MultSemilattice_RingoidSigLang ->
      A
    evalTerm _ Mu (*L x1 x2) =
      * Mu (evalTerm _ Mu x1)
        (evalTerm _ Mu x2)
    evalTerm _ Mu (+L x1 x2) =
      + Mu (evalTerm _ Mu x1)
        (evalTerm _ Mu x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MultSemilattice_RingoidSig A ->
      MultSemilattice_RingoidSigOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n mu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mu (*OL
                         x1
                         x2) vars =
      * mu
        (evalOpenTerm _ n mu x1 vars)
        (evalOpenTerm _ n mu x2 vars)
    evalOpenTerm _ n mu (+OL
                         x1
                         x2) vars =
      + mu
        (evalOpenTerm _ n mu x1 vars)
        (evalOpenTerm _ n mu x2 vars)
  
  module MultUnaryAntiDistribution where
    record MultUnaryAntiDistribution
      (A : Set) : Set where
      constructor MultUnaryAntiDistributionC
      field
        prim : A -> A
        * : A -> A -> A
        antidis_prim_* :
          (x : A) (y : A) ->
          prim (* x y) ==
            * (prim y) (prim x)
    record MultUnaryAntiDistributionSig
      (AS : Set) : Set where
      constructor MultUnaryAntiDistributionSigSigC
      field
        primS : AS -> AS
        *S : AS -> AS -> AS
    record MultUnaryAntiDistributionProd
      (AP : Set) : Set where
      constructor MultUnaryAntiDistributionProdC
      field
        primP : Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        antidis_prim_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (*P xP yP) ==
            *P (primP yP) (primP xP)
    record MultUnaryAntiDistributionHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultUnaryAntiDistribution
         A1)
      (Mu2 : MultUnaryAntiDistribution
         A2) : Set where
      constructor MultUnaryAntiDistributionHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Mu1 x1) ==
            prim Mu2 (hom x1)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultUnaryAntiDistributionRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultUnaryAntiDistribution
         A1)
      (Mu2 : MultUnaryAntiDistribution
         A2) : Set where
      constructor MultUnaryAntiDistributionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Mu1 x1)
            (prim Mu2 y1)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultUnaryAntiDistributionLang
      : Set where
      primL :
        MultUnaryAntiDistributionLang ->
        MultUnaryAntiDistributionLang
      *L :
        MultUnaryAntiDistributionLang ->
        MultUnaryAntiDistributionLang ->
        MultUnaryAntiDistributionLang
    data MultUnaryAntiDistributionOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        MultUnaryAntiDistributionOpenLang
          n
      primOL :
        MultUnaryAntiDistributionOpenLang
          n ->
        MultUnaryAntiDistributionOpenLang
          n
      *OL :
        MultUnaryAntiDistributionOpenLang
          n ->
        MultUnaryAntiDistributionOpenLang
          n ->
        MultUnaryAntiDistributionOpenLang
          n
    evalTerm :
      (A : Set) ->
      MultUnaryAntiDistribution A ->
      MultUnaryAntiDistributionLang ->
      A
    evalTerm _ Mu (primL x1) =
      prim Mu (evalTerm _ Mu x1)
    evalTerm _ Mu (*L x1 x2) =
      * Mu (evalTerm _ Mu x1)
        (evalTerm _ Mu x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MultUnaryAntiDistribution A ->
      MultUnaryAntiDistributionOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n mu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mu (primOL
                         x1) vars =
      prim mu
        (evalOpenTerm _ n mu x1 vars)
    evalOpenTerm _ n mu (*OL
                         x1
                         x2) vars =
      * mu
        (evalOpenTerm _ n mu x1 vars)
        (evalOpenTerm _ n mu x2 vars)
  
  module MultUnital where
    record MultUnital
      (A : Set) : Set where
      constructor MultUnitalC
      field
        1 : A
        * : A -> A -> A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
    record MultUnitalSig
      (AS : Set) : Set where
      constructor MultUnitalSigSigC
      field
        1S : AS
        *S : AS -> AS -> AS
    record MultUnitalProd
      (AP : Set) : Set where
      constructor MultUnitalProdC
      field
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
    record MultUnitalHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultUnital A1)
      (Mu2 : MultUnital A2) :
      Set where
      constructor MultUnitalHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Mu1) == 1 Mu2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultUnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultUnital A1)
      (Mu2 : MultUnital A2) :
      Set where
      constructor MultUnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Mu1) (1 Mu2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultUnitalLang : Set where
      1L : MultUnitalLang
      *L :
        MultUnitalLang ->
        MultUnitalLang -> MultUnitalLang
    data MultUnitalOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> MultUnitalOpenLang n
      1OL : MultUnitalOpenLang n
      *OL :
        MultUnitalOpenLang n ->
        MultUnitalOpenLang n ->
        MultUnitalOpenLang n
    evalTerm :
      (A : Set) ->
      MultUnital A ->
      MultUnitalLang -> A
    evalTerm _ Mu (1L) = 1 Mu
    evalTerm _ Mu (*L x1 x2) =
      * Mu (evalTerm _ Mu x1)
        (evalTerm _ Mu x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      MultUnital A ->
      MultUnitalOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n mu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n mu (1OL) vars =
      1 mu
    evalOpenTerm _ n mu (*OL
                         x1
                         x2) vars =
      * mu
        (evalOpenTerm _ n mu x1 vars)
        (evalOpenTerm _ n mu x2 vars)
  
  module NearRing where
    record NearRing
      (A : Set) : Set where
      constructor NearRingC
      field
        * : A -> A -> A
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record NearRingSig
      (AS : Set) : Set where
      constructor NearRingSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
    record NearRingProd
      (AP : Set) : Set where
      constructor NearRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record NearRingHom
      (A1 : Set) (A2 : Set)
      (Ne1 : NearRing A1)
      (Ne2 : NearRing A2) : Set where
      constructor NearRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ne1 x1 x2) ==
            * Ne2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ne1 x1 x2) ==
            + Ne2 (hom x1) (hom x2)
        pres-0 : hom (0 Ne1) == 0 Ne2
        pres-neg :
          (x1 : A1) ->
          hom (neg Ne1 x1) ==
            neg Ne2 (hom x1)
    record NearRingRelInterp
      (A1 : Set) (A2 : Set)
      (Ne1 : NearRing A1)
      (Ne2 : NearRing A2) : Set where
      constructor NearRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ne1 x1 x2)
            (* Ne2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ne1 x1 x2)
            (+ Ne2 y1 y2)
        interp-0 :
          interp (0 Ne1) (0 Ne2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Ne1 x1) (neg Ne2 y1)
    data NearRingLang : Set where
      *L :
        NearRingLang ->
        NearRingLang -> NearRingLang
      +L :
        NearRingLang ->
        NearRingLang -> NearRingLang
      0L : NearRingLang
      negL :
        NearRingLang -> NearRingLang
    data NearRingOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> NearRingOpenLang n
      *OL :
        NearRingOpenLang n ->
        NearRingOpenLang n ->
        NearRingOpenLang n
      +OL :
        NearRingOpenLang n ->
        NearRingOpenLang n ->
        NearRingOpenLang n
      0OL : NearRingOpenLang n
      negOL :
        NearRingOpenLang n ->
        NearRingOpenLang n
    evalTerm :
      (A : Set) ->
      NearRing A -> NearRingLang -> A
    evalTerm _ Ne (*L x1 x2) =
      * Ne (evalTerm _ Ne x1)
        (evalTerm _ Ne x2)
    evalTerm _ Ne (+L x1 x2) =
      + Ne (evalTerm _ Ne x1)
        (evalTerm _ Ne x2)
    evalTerm _ Ne (0L) = 0 Ne
    evalTerm _ Ne (negL x1) =
      neg Ne (evalTerm _ Ne x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      NearRing A ->
      NearRingOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ne (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ne (*OL
                         x1
                         x2) vars =
      * ne
        (evalOpenTerm _ n ne x1 vars)
        (evalOpenTerm _ n ne x2 vars)
    evalOpenTerm _ n ne (+OL
                         x1
                         x2) vars =
      + ne
        (evalOpenTerm _ n ne x1 vars)
        (evalOpenTerm _ n ne x2 vars)
    evalOpenTerm _ n ne (0OL) vars =
      0 ne
    evalOpenTerm _ n ne (negOL
                         x1) vars =
      neg ne
        (evalOpenTerm _ n ne x1 vars)
  
  module NearSemiring where
    record NearSemiring
      (A : Set) : Set where
      constructor NearSemiringC
      field
        * : A -> A -> A
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record NearSemiringSig
      (AS : Set) : Set where
      constructor NearSemiringSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record NearSemiringProd
      (AP : Set) : Set where
      constructor NearSemiringProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record NearSemiringHom
      (A1 : Set) (A2 : Set)
      (Ne1 : NearSemiring A1)
      (Ne2 : NearSemiring A2) :
      Set where
      constructor NearSemiringHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ne1 x1 x2) ==
            * Ne2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ne1 x1 x2) ==
            + Ne2 (hom x1) (hom x2)
    record NearSemiringRelInterp
      (A1 : Set) (A2 : Set)
      (Ne1 : NearSemiring A1)
      (Ne2 : NearSemiring A2) :
      Set where
      constructor NearSemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ne1 x1 x2)
            (* Ne2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ne1 x1 x2)
            (+ Ne2 y1 y2)
    data NearSemiringLang
      : Set where
      *L :
        NearSemiringLang ->
        NearSemiringLang ->
        NearSemiringLang
      +L :
        NearSemiringLang ->
        NearSemiringLang ->
        NearSemiringLang
    data NearSemiringOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> NearSemiringOpenLang n
      *OL :
        NearSemiringOpenLang n ->
        NearSemiringOpenLang n ->
        NearSemiringOpenLang n
      +OL :
        NearSemiringOpenLang n ->
        NearSemiringOpenLang n ->
        NearSemiringOpenLang n
    evalTerm :
      (A : Set) ->
      NearSemiring A ->
      NearSemiringLang -> A
    evalTerm _ Ne (*L x1 x2) =
      * Ne (evalTerm _ Ne x1)
        (evalTerm _ Ne x2)
    evalTerm _ Ne (+L x1 x2) =
      + Ne (evalTerm _ Ne x1)
        (evalTerm _ Ne x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      NearSemiring A ->
      NearSemiringOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ne (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ne (*OL
                         x1
                         x2) vars =
      * ne
        (evalOpenTerm _ n ne x1 vars)
        (evalOpenTerm _ n ne x2 vars)
    evalOpenTerm _ n ne (+OL
                         x1
                         x2) vars =
      + ne
        (evalOpenTerm _ n ne x1 vars)
        (evalOpenTerm _ n ne x2 vars)
  
  module NonDistributiveAddPreSemiring where
    record NonDistributiveAddPreSemiring
      (A : Set) : Set where
      constructor NonDistributiveAddPreSemiringC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        * : A -> A -> A
    record NonDistributiveAddPreSemiringSig
      (AS : Set) : Set where
      constructor NonDistributiveAddPreSemiringSigSigC
      field
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
    record NonDistributiveAddPreSemiringProd
      (AP : Set) : Set where
      constructor NonDistributiveAddPreSemiringProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record NonDistributiveAddPreSemiringHom
      (A1 : Set) (A2 : Set)
      (No1 : NonDistributiveAddPreSemiring
         A1)
      (No2 : NonDistributiveAddPreSemiring
         A2) : Set where
      constructor NonDistributiveAddPreSemiringHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ No1 x1 x2) ==
            + No2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* No1 x1 x2) ==
            * No2 (hom x1) (hom x2)
    record NonDistributiveAddPreSemiringRelInterp
      (A1 : Set) (A2 : Set)
      (No1 : NonDistributiveAddPreSemiring
         A1)
      (No2 : NonDistributiveAddPreSemiring
         A2) : Set where
      constructor NonDistributiveAddPreSemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ No1 x1 x2)
            (+ No2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* No1 x1 x2)
            (* No2 y1 y2)
    data NonDistributiveAddPreSemiringLang
      : Set where
      +L :
        NonDistributiveAddPreSemiringLang ->
        NonDistributiveAddPreSemiringLang ->
        NonDistributiveAddPreSemiringLang
      *L :
        NonDistributiveAddPreSemiringLang ->
        NonDistributiveAddPreSemiringLang ->
        NonDistributiveAddPreSemiringLang
    data NonDistributiveAddPreSemiringOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        NonDistributiveAddPreSemiringOpenLang
          n
      +OL :
        NonDistributiveAddPreSemiringOpenLang
          n ->
        NonDistributiveAddPreSemiringOpenLang
          n ->
        NonDistributiveAddPreSemiringOpenLang
          n
      *OL :
        NonDistributiveAddPreSemiringOpenLang
          n ->
        NonDistributiveAddPreSemiringOpenLang
          n ->
        NonDistributiveAddPreSemiringOpenLang
          n
    evalTerm :
      (A : Set) ->
      NonDistributiveAddPreSemiring
        A ->
      NonDistributiveAddPreSemiringLang ->
      A
    evalTerm _ No (+L x1 x2) =
      + No (evalTerm _ No x1)
        (evalTerm _ No x2)
    evalTerm _ No (*L x1 x2) =
      * No (evalTerm _ No x1)
        (evalTerm _ No x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      NonDistributiveAddPreSemiring
        A ->
      NonDistributiveAddPreSemiringOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n no (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n no (+OL
                         x1
                         x2) vars =
      + no
        (evalOpenTerm _ n no x1 vars)
        (evalOpenTerm _ n no x2 vars)
    evalOpenTerm _ n no (*OL
                         x1
                         x2) vars =
      * no
        (evalOpenTerm _ n no x1 vars)
        (evalOpenTerm _ n no x2 vars)
  
  module NonassociativeNondistributiveRing where
    record NonassociativeNondistributiveRing
      (A : Set) : Set where
      constructor NonassociativeNondistributiveRingC
      field
        * : A -> A -> A
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        inv : A -> A
        leftInverse_inv_op_1 :
          (x : A) -> * x (inv x) == 1
        rightInverse_inv_op_1 :
          (x : A) -> * (inv x) x == 1
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        + : A -> A -> A
    record NonassociativeNondistributiveRingSig
      (AS : Set) : Set where
      constructor NonassociativeNondistributiveRingSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
        invS : AS -> AS
        +S : AS -> AS -> AS
    record NonassociativeNondistributiveRingProd
      (AP : Set) : Set where
      constructor NonassociativeNondistributiveRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P xP (invP xP) == 1P
        rightInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P (invP xP) xP == 1P
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
    record NonassociativeNondistributiveRingHom
      (A1 : Set) (A2 : Set)
      (No1 : NonassociativeNondistributiveRing
         A1)
      (No2 : NonassociativeNondistributiveRing
         A2) : Set where
      constructor NonassociativeNondistributiveRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* No1 x1 x2) ==
            * No2 (hom x1) (hom x2)
        pres-1 : hom (1 No1) == 1 No2
        pres-inv :
          (x1 : A1) ->
          hom (inv No1 x1) ==
            inv No2 (hom x1)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ No1 x1 x2) ==
            + No2 (hom x1) (hom x2)
    record NonassociativeNondistributiveRingRelInterp
      (A1 : Set) (A2 : Set)
      (No1 : NonassociativeNondistributiveRing
         A1)
      (No2 : NonassociativeNondistributiveRing
         A2) : Set where
      constructor NonassociativeNondistributiveRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* No1 x1 x2)
            (* No2 y1 y2)
        interp-1 :
          interp (1 No1) (1 No2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv No1 x1) (inv No2 y1)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ No1 x1 x2)
            (+ No2 y1 y2)
    data NonassociativeNondistributiveRingLang
      : Set where
      *L :
        NonassociativeNondistributiveRingLang ->
        NonassociativeNondistributiveRingLang ->
        NonassociativeNondistributiveRingLang
      1L :
        NonassociativeNondistributiveRingLang
      invL :
        NonassociativeNondistributiveRingLang ->
        NonassociativeNondistributiveRingLang
      +L :
        NonassociativeNondistributiveRingLang ->
        NonassociativeNondistributiveRingLang ->
        NonassociativeNondistributiveRingLang
    data NonassociativeNondistributiveRingOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        NonassociativeNondistributiveRingOpenLang
          n
      *OL :
        NonassociativeNondistributiveRingOpenLang
          n ->
        NonassociativeNondistributiveRingOpenLang
          n ->
        NonassociativeNondistributiveRingOpenLang
          n
      1OL :
        NonassociativeNondistributiveRingOpenLang
          n
      invOL :
        NonassociativeNondistributiveRingOpenLang
          n ->
        NonassociativeNondistributiveRingOpenLang
          n
      +OL :
        NonassociativeNondistributiveRingOpenLang
          n ->
        NonassociativeNondistributiveRingOpenLang
          n ->
        NonassociativeNondistributiveRingOpenLang
          n
    evalTerm :
      (A : Set) ->
      NonassociativeNondistributiveRing
        A ->
      NonassociativeNondistributiveRingLang ->
      A
    evalTerm _ No (*L x1 x2) =
      * No (evalTerm _ No x1)
        (evalTerm _ No x2)
    evalTerm _ No (1L) = 1 No
    evalTerm _ No (invL x1) =
      inv No (evalTerm _ No x1)
    evalTerm _ No (+L x1 x2) =
      + No (evalTerm _ No x1)
        (evalTerm _ No x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      NonassociativeNondistributiveRing
        A ->
      NonassociativeNondistributiveRingOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n no (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n no (*OL
                         x1
                         x2) vars =
      * no
        (evalOpenTerm _ n no x1 vars)
        (evalOpenTerm _ n no x2 vars)
    evalOpenTerm _ n no (1OL) vars =
      1 no
    evalOpenTerm _ n no (invOL
                         x1) vars =
      inv no
        (evalOpenTerm _ n no x1 vars)
    evalOpenTerm _ n no (+OL
                         x1
                         x2) vars =
      + no
        (evalOpenTerm _ n no x1 vars)
        (evalOpenTerm _ n no x2 vars)
  
  module NonassociativeRing where
    record NonassociativeRing
      (A : Set) : Set where
      constructor NonassociativeRingC
      field
        * : A -> A -> A
        + : A -> A -> A
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        inv : A -> A
        leftInverse_inv_op_1 :
          (x : A) -> * x (inv x) == 1
        rightInverse_inv_op_1 :
          (x : A) -> * (inv x) x == 1
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record NonassociativeRingSig
      (AS : Set) : Set where
      constructor NonassociativeRingSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        1S : AS
        invS : AS -> AS
    record NonassociativeRingProd
      (AP : Set) : Set where
      constructor NonassociativeRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P xP (invP xP) == 1P
        rightInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P (invP xP) xP == 1P
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record NonassociativeRingHom
      (A1 : Set) (A2 : Set)
      (No1 : NonassociativeRing A1)
      (No2 : NonassociativeRing A2) :
      Set where
      constructor NonassociativeRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* No1 x1 x2) ==
            * No2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ No1 x1 x2) ==
            + No2 (hom x1) (hom x2)
        pres-1 : hom (1 No1) == 1 No2
        pres-inv :
          (x1 : A1) ->
          hom (inv No1 x1) ==
            inv No2 (hom x1)
    record NonassociativeRingRelInterp
      (A1 : Set) (A2 : Set)
      (No1 : NonassociativeRing A1)
      (No2 : NonassociativeRing A2) :
      Set where
      constructor NonassociativeRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* No1 x1 x2)
            (* No2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ No1 x1 x2)
            (+ No2 y1 y2)
        interp-1 :
          interp (1 No1) (1 No2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv No1 x1) (inv No2 y1)
    data NonassociativeRingLang
      : Set where
      *L :
        NonassociativeRingLang ->
        NonassociativeRingLang ->
        NonassociativeRingLang
      +L :
        NonassociativeRingLang ->
        NonassociativeRingLang ->
        NonassociativeRingLang
      1L : NonassociativeRingLang
      invL :
        NonassociativeRingLang ->
        NonassociativeRingLang
    data NonassociativeRingOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        NonassociativeRingOpenLang n
      *OL :
        NonassociativeRingOpenLang n ->
        NonassociativeRingOpenLang n ->
        NonassociativeRingOpenLang n
      +OL :
        NonassociativeRingOpenLang n ->
        NonassociativeRingOpenLang n ->
        NonassociativeRingOpenLang n
      1OL :
        NonassociativeRingOpenLang n
      invOL :
        NonassociativeRingOpenLang n ->
        NonassociativeRingOpenLang n
    evalTerm :
      (A : Set) ->
      NonassociativeRing A ->
      NonassociativeRingLang -> A
    evalTerm _ No (*L x1 x2) =
      * No (evalTerm _ No x1)
        (evalTerm _ No x2)
    evalTerm _ No (+L x1 x2) =
      + No (evalTerm _ No x1)
        (evalTerm _ No x2)
    evalTerm _ No (1L) = 1 No
    evalTerm _ No (invL x1) =
      inv No (evalTerm _ No x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      NonassociativeRing A ->
      NonassociativeRingOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n no (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n no (*OL
                         x1
                         x2) vars =
      * no
        (evalOpenTerm _ n no x1 vars)
        (evalOpenTerm _ n no x2 vars)
    evalOpenTerm _ n no (+OL
                         x1
                         x2) vars =
      + no
        (evalOpenTerm _ n no x1 vars)
        (evalOpenTerm _ n no x2 vars)
    evalOpenTerm _ n no (1OL) vars =
      1 no
    evalOpenTerm _ n no (invOL
                         x1) vars =
      inv no
        (evalOpenTerm _ n no x1 vars)
  
  module NormalBand where
    record NormalBand
      (A : Set) : Set where
      constructor NormalBandC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        idempotent_op :
          (x : A) -> op x x == x
        middleCommute_* :
          (x : A) (y : A) (z : A) ->
          op (op (op x y) z) x ==
            op (op (op x z) y) x
    record NormalBandSig
      (AS : Set) : Set where
      constructor NormalBandSigSigC
      field
        opS : AS -> AS -> AS
    record NormalBandProd
      (AP : Set) : Set where
      constructor NormalBandProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        idempotent_opP :
          (xP : Prod AP AP) ->
          opP xP xP == xP
        middleCommute_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP (opP xP yP) zP) xP ==
            opP (opP (opP xP zP) yP) xP
    record NormalBandHom
      (A1 : Set) (A2 : Set)
      (No1 : NormalBand A1)
      (No2 : NormalBand A2) :
      Set where
      constructor NormalBandHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op No1 x1 x2) ==
            op No2 (hom x1) (hom x2)
    record NormalBandRelInterp
      (A1 : Set) (A2 : Set)
      (No1 : NormalBand A1)
      (No2 : NormalBand A2) :
      Set where
      constructor NormalBandRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op No1 x1 x2)
            (op No2 y1 y2)
    data NormalBandLang : Set where
      opL :
        NormalBandLang ->
        NormalBandLang -> NormalBandLang
    data NormalBandOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> NormalBandOpenLang n
      opOL :
        NormalBandOpenLang n ->
        NormalBandOpenLang n ->
        NormalBandOpenLang n
    evalTerm :
      (A : Set) ->
      NormalBand A ->
      NormalBandLang -> A
    evalTerm _ No (opL x1 x2) =
      op No (evalTerm _ No x1)
        (evalTerm _ No x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      NormalBand A ->
      NormalBandOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n no (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n no (opOL
                         x1
                         x2) vars =
      op no
        (evalOpenTerm _ n no x1 vars)
        (evalOpenTerm _ n no x2 vars)
  
  module OrDeMorgran where
    record OrDeMorgran
      (A : Set) : Set where
      constructor OrDeMorgranC
      field
        * : A -> A -> A
        + : A -> A -> A
        prim : A -> A
        orDeMorgan_+_*_prim :
          (x : A) (y : A) (z : A) ->
          prim (+ x y) ==
            * (prim x) (prim y)
    record OrDeMorgranSig
      (AS : Set) : Set where
      constructor OrDeMorgranSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        primS : AS -> AS
    record OrDeMorgranProd
      (AP : Set) : Set where
      constructor OrDeMorgranProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        orDeMorgan_+_*_primP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          primP (+P xP yP) ==
            *P (primP xP) (primP yP)
    record OrDeMorgranHom
      (A1 : Set) (A2 : Set)
      (Or1 : OrDeMorgran A1)
      (Or2 : OrDeMorgran A2) :
      Set where
      constructor OrDeMorgranHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Or1 x1 x2) ==
            * Or2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Or1 x1 x2) ==
            + Or2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Or1 x1) ==
            prim Or2 (hom x1)
    record OrDeMorgranRelInterp
      (A1 : Set) (A2 : Set)
      (Or1 : OrDeMorgran A1)
      (Or2 : OrDeMorgran A2) :
      Set where
      constructor OrDeMorgranRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Or1 x1 x2)
            (* Or2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Or1 x1 x2)
            (+ Or2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Or1 x1)
            (prim Or2 y1)
    data OrDeMorgranLang : Set where
      *L :
        OrDeMorgranLang ->
        OrDeMorgranLang ->
        OrDeMorgranLang
      +L :
        OrDeMorgranLang ->
        OrDeMorgranLang ->
        OrDeMorgranLang
      primL :
        OrDeMorgranLang ->
        OrDeMorgranLang
    data OrDeMorgranOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> OrDeMorgranOpenLang n
      *OL :
        OrDeMorgranOpenLang n ->
        OrDeMorgranOpenLang n ->
        OrDeMorgranOpenLang n
      +OL :
        OrDeMorgranOpenLang n ->
        OrDeMorgranOpenLang n ->
        OrDeMorgranOpenLang n
      primOL :
        OrDeMorgranOpenLang n ->
        OrDeMorgranOpenLang n
    evalTerm :
      (A : Set) ->
      OrDeMorgran A ->
      OrDeMorgranLang -> A
    evalTerm _ Or (*L x1 x2) =
      * Or (evalTerm _ Or x1)
        (evalTerm _ Or x2)
    evalTerm _ Or (+L x1 x2) =
      + Or (evalTerm _ Or x1)
        (evalTerm _ Or x2)
    evalTerm _ Or (primL x1) =
      prim Or (evalTerm _ Or x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      OrDeMorgran A ->
      OrDeMorgranOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n or (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n or (*OL
                         x1
                         x2) vars =
      * or
        (evalOpenTerm _ n or x1 vars)
        (evalOpenTerm _ n or x2 vars)
    evalOpenTerm _ n or (+OL
                         x1
                         x2) vars =
      + or
        (evalOpenTerm _ n or x1 vars)
        (evalOpenTerm _ n or x2 vars)
    evalOpenTerm _ n or (primOL
                         x1) vars =
      prim or
        (evalOpenTerm _ n or x1 vars)
  
  module Pointed where
    record Pointed
      (A : Set) : Set where
      constructor PointedC
      field
        e : A
    record PointedSig
      (AS : Set) : Set where
      constructor PointedSigSigC
      field
        eS : AS
    record PointedProd
      (AP : Set) : Set where
      constructor PointedProdC
      field
        eP : Prod AP AP
    record PointedHom
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed A1)
      (Po2 : Pointed A2) : Set where
      constructor PointedHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Po1) == e Po2
    record PointedRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed A1)
      (Po2 : Pointed A2) : Set where
      constructor PointedRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Po1) (e Po2)
    data PointedLang : Set where
      eL : PointedLang
    data PointedOpenLang
      (n : Nat) : Set where
      v : Fin n -> PointedOpenLang n
      eOL : PointedOpenLang n
    evalTerm :
      (A : Set) ->
      Pointed A -> PointedLang -> A
    evalTerm _ Po (eL) = e Po
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Pointed A ->
      PointedOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (eOL) vars =
      e po
  
  module Pointed0Magma where
    record Pointed0Magma
      (A : Set) : Set where
      constructor Pointed0MagmaC
      field
        0 : A
        op : A -> A -> A
    record Pointed0MagmaSig
      (AS : Set) : Set where
      constructor Pointed0MagmaSigSigC
      field
        0S : AS
        opS : AS -> AS -> AS
    record Pointed0MagmaProd
      (AP : Set) : Set where
      constructor Pointed0MagmaProdC
      field
        0P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record Pointed0MagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed0Magma A1)
      (Po2 : Pointed0Magma A2) :
      Set where
      constructor Pointed0MagmaHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Po1) == 0 Po2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Po1 x1 x2) ==
            op Po2 (hom x1) (hom x2)
    record Pointed0MagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed0Magma A1)
      (Po2 : Pointed0Magma A2) :
      Set where
      constructor Pointed0MagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Po1) (0 Po2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Po1 x1 x2)
            (op Po2 y1 y2)
    data Pointed0MagmaLang
      : Set where
      0L : Pointed0MagmaLang
      opL :
        Pointed0MagmaLang ->
        Pointed0MagmaLang ->
        Pointed0MagmaLang
    data Pointed0MagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> Pointed0MagmaOpenLang n
      0OL : Pointed0MagmaOpenLang n
      opOL :
        Pointed0MagmaOpenLang n ->
        Pointed0MagmaOpenLang n ->
        Pointed0MagmaOpenLang n
    evalTerm :
      (A : Set) ->
      Pointed0Magma A ->
      Pointed0MagmaLang -> A
    evalTerm _ Po (0L) = 0 Po
    evalTerm _ Po (opL x1 x2) =
      op Po (evalTerm _ Po x1)
        (evalTerm _ Po x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Pointed0Magma A ->
      Pointed0MagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (0OL) vars =
      0 po
    evalOpenTerm _ n po (opOL
                         x1
                         x2) vars =
      op po
        (evalOpenTerm _ n po x1 vars)
        (evalOpenTerm _ n po x2 vars)
  
  module Pointed1Magma where
    record Pointed1Magma
      (A : Set) : Set where
      constructor Pointed1MagmaC
      field
        1 : A
        op : A -> A -> A
    record Pointed1MagmaSig
      (AS : Set) : Set where
      constructor Pointed1MagmaSigSigC
      field
        1S : AS
        opS : AS -> AS -> AS
    record Pointed1MagmaProd
      (AP : Set) : Set where
      constructor Pointed1MagmaProdC
      field
        1P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record Pointed1MagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed1Magma A1)
      (Po2 : Pointed1Magma A2) :
      Set where
      constructor Pointed1MagmaHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Po1) == 1 Po2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Po1 x1 x2) ==
            op Po2 (hom x1) (hom x2)
    record Pointed1MagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed1Magma A1)
      (Po2 : Pointed1Magma A2) :
      Set where
      constructor Pointed1MagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Po1) (1 Po2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Po1 x1 x2)
            (op Po2 y1 y2)
    data Pointed1MagmaLang
      : Set where
      1L : Pointed1MagmaLang
      opL :
        Pointed1MagmaLang ->
        Pointed1MagmaLang ->
        Pointed1MagmaLang
    data Pointed1MagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> Pointed1MagmaOpenLang n
      1OL : Pointed1MagmaOpenLang n
      opOL :
        Pointed1MagmaOpenLang n ->
        Pointed1MagmaOpenLang n ->
        Pointed1MagmaOpenLang n
    evalTerm :
      (A : Set) ->
      Pointed1Magma A ->
      Pointed1MagmaLang -> A
    evalTerm _ Po (1L) = 1 Po
    evalTerm _ Po (opL x1 x2) =
      op Po (evalTerm _ Po x1)
        (evalTerm _ Po x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Pointed1Magma A ->
      Pointed1MagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (1OL) vars =
      1 po
    evalOpenTerm _ n po (opOL
                         x1
                         x2) vars =
      op po
        (evalOpenTerm _ n po x1 vars)
        (evalOpenTerm _ n po x2 vars)
  
  module PointedInvolutiveMagma0Sig where
    record PointedInvolutiveMagma0Sig
      (A : Set) : Set where
      constructor PointedInvolutiveMagma0SigC
      field
        * : A -> A -> A
        prim : A -> A
        0 : A
    record PointedInvolutiveMagma0SigSig
      (AS : Set) : Set where
      constructor PointedInvolutiveMagma0SigSigSigC
      field
        *S : AS -> AS -> AS
        primS : AS -> AS
        0S : AS
    record PointedInvolutiveMagma0SigProd
      (AP : Set) : Set where
      constructor PointedInvolutiveMagma0SigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        0P : Prod AP AP
    record PointedInvolutiveMagma0SigHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedInvolutiveMagma0Sig
         A1)
      (Po2 : PointedInvolutiveMagma0Sig
         A2) : Set where
      constructor PointedInvolutiveMagma0SigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Po1 x1 x2) ==
            * Po2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Po1 x1) ==
            prim Po2 (hom x1)
        pres-0 : hom (0 Po1) == 0 Po2
    record PointedInvolutiveMagma0SigRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedInvolutiveMagma0Sig
         A1)
      (Po2 : PointedInvolutiveMagma0Sig
         A2) : Set where
      constructor PointedInvolutiveMagma0SigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Po1 x1 x2)
            (* Po2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Po1 x1)
            (prim Po2 y1)
        interp-0 :
          interp (0 Po1) (0 Po2)
    data PointedInvolutiveMagma0SigLang
      : Set where
      *L :
        PointedInvolutiveMagma0SigLang ->
        PointedInvolutiveMagma0SigLang ->
        PointedInvolutiveMagma0SigLang
      primL :
        PointedInvolutiveMagma0SigLang ->
        PointedInvolutiveMagma0SigLang
      0L :
        PointedInvolutiveMagma0SigLang
    data PointedInvolutiveMagma0SigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        PointedInvolutiveMagma0SigOpenLang
          n
      *OL :
        PointedInvolutiveMagma0SigOpenLang
          n ->
        PointedInvolutiveMagma0SigOpenLang
          n ->
        PointedInvolutiveMagma0SigOpenLang
          n
      primOL :
        PointedInvolutiveMagma0SigOpenLang
          n ->
        PointedInvolutiveMagma0SigOpenLang
          n
      0OL :
        PointedInvolutiveMagma0SigOpenLang
          n
    evalTerm :
      (A : Set) ->
      PointedInvolutiveMagma0Sig A ->
      PointedInvolutiveMagma0SigLang ->
      A
    evalTerm _ Po (*L x1 x2) =
      * Po (evalTerm _ Po x1)
        (evalTerm _ Po x2)
    evalTerm _ Po (primL x1) =
      prim Po (evalTerm _ Po x1)
    evalTerm _ Po (0L) = 0 Po
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PointedInvolutiveMagma0Sig A ->
      PointedInvolutiveMagma0SigOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (*OL
                         x1
                         x2) vars =
      * po
        (evalOpenTerm _ n po x1 vars)
        (evalOpenTerm _ n po x2 vars)
    evalOpenTerm _ n po (primOL
                         x1) vars =
      prim po
        (evalOpenTerm _ n po x1 vars)
    evalOpenTerm _ n po (0OL) vars =
      0 po
  
  module PointedMagma where
    record PointedMagma
      (A : Set) : Set where
      constructor PointedMagmaC
      field
        e : A
        op : A -> A -> A
    record PointedMagmaSig
      (AS : Set) : Set where
      constructor PointedMagmaSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record PointedMagmaProd
      (AP : Set) : Set where
      constructor PointedMagmaProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record PointedMagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedMagma A1)
      (Po2 : PointedMagma A2) :
      Set where
      constructor PointedMagmaHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Po1) == e Po2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Po1 x1 x2) ==
            op Po2 (hom x1) (hom x2)
    record PointedMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedMagma A1)
      (Po2 : PointedMagma A2) :
      Set where
      constructor PointedMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Po1) (e Po2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Po1 x1 x2)
            (op Po2 y1 y2)
    data PointedMagmaLang
      : Set where
      eL : PointedMagmaLang
      opL :
        PointedMagmaLang ->
        PointedMagmaLang ->
        PointedMagmaLang
    data PointedMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> PointedMagmaOpenLang n
      eOL : PointedMagmaOpenLang n
      opOL :
        PointedMagmaOpenLang n ->
        PointedMagmaOpenLang n ->
        PointedMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      PointedMagma A ->
      PointedMagmaLang -> A
    evalTerm _ Po (eL) = e Po
    evalTerm _ Po (opL x1 x2) =
      op Po (evalTerm _ Po x1)
        (evalTerm _ Po x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PointedMagma A ->
      PointedMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (eOL) vars =
      e po
    evalOpenTerm _ n po (opOL
                         x1
                         x2) vars =
      op po
        (evalOpenTerm _ n po x1 vars)
        (evalOpenTerm _ n po x2 vars)
  
  module PointedOne where
    record PointedOne
      (A : Set) : Set where
      constructor PointedOneC
      field
        1 : A
    record PointedOneSig
      (AS : Set) : Set where
      constructor PointedOneSigSigC
      field
        1S : AS
    record PointedOneProd
      (AP : Set) : Set where
      constructor PointedOneProdC
      field
        1P : Prod AP AP
    record PointedOneHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedOne A1)
      (Po2 : PointedOne A2) :
      Set where
      constructor PointedOneHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Po1) == 1 Po2
    record PointedOneRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedOne A1)
      (Po2 : PointedOne A2) :
      Set where
      constructor PointedOneRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Po1) (1 Po2)
    data PointedOneLang : Set where
      1L : PointedOneLang
    data PointedOneOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> PointedOneOpenLang n
      1OL : PointedOneOpenLang n
    evalTerm :
      (A : Set) ->
      PointedOne A ->
      PointedOneLang -> A
    evalTerm _ Po (1L) = 1 Po
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PointedOne A ->
      PointedOneOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (1OL) vars =
      1 po
  
  module PointedPlusMagma where
    record PointedPlusMagma
      (A : Set) : Set where
      constructor PointedPlusMagmaC
      field
        + : A -> A -> A
        e : A
    record PointedPlusMagmaSig
      (AS : Set) : Set where
      constructor PointedPlusMagmaSigSigC
      field
        +S : AS -> AS -> AS
        eS : AS
    record PointedPlusMagmaProd
      (AP : Set) : Set where
      constructor PointedPlusMagmaProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
    record PointedPlusMagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedPlusMagma A1)
      (Po2 : PointedPlusMagma A2) :
      Set where
      constructor PointedPlusMagmaHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Po1 x1 x2) ==
            + Po2 (hom x1) (hom x2)
        pres-e : hom (e Po1) == e Po2
    record PointedPlusMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedPlusMagma A1)
      (Po2 : PointedPlusMagma A2) :
      Set where
      constructor PointedPlusMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Po1 x1 x2)
            (+ Po2 y1 y2)
        interp-e :
          interp (e Po1) (e Po2)
    data PointedPlusMagmaLang
      : Set where
      +L :
        PointedPlusMagmaLang ->
        PointedPlusMagmaLang ->
        PointedPlusMagmaLang
      eL : PointedPlusMagmaLang
    data PointedPlusMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        PointedPlusMagmaOpenLang n
      +OL :
        PointedPlusMagmaOpenLang n ->
        PointedPlusMagmaOpenLang n ->
        PointedPlusMagmaOpenLang n
      eOL : PointedPlusMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      PointedPlusMagma A ->
      PointedPlusMagmaLang -> A
    evalTerm _ Po (+L x1 x2) =
      + Po (evalTerm _ Po x1)
        (evalTerm _ Po x2)
    evalTerm _ Po (eL) = e Po
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PointedPlusMagma A ->
      PointedPlusMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (+OL
                         x1
                         x2) vars =
      + po
        (evalOpenTerm _ n po x1 vars)
        (evalOpenTerm _ n po x2 vars)
    evalOpenTerm _ n po (eOL) vars =
      e po
  
  module PointedSemigroup where
    record PointedSemigroup
      (A : Set) : Set where
      constructor PointedSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        e : A
    record PointedSemigroupSig
      (AS : Set) : Set where
      constructor PointedSemigroupSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record PointedSemigroupProd
      (AP : Set) : Set where
      constructor PointedSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record PointedSemigroupHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedSemigroup A1)
      (Po2 : PointedSemigroup A2) :
      Set where
      constructor PointedSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Po1 x1 x2) ==
            op Po2 (hom x1) (hom x2)
        pres-e : hom (e Po1) == e Po2
    record PointedSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedSemigroup A1)
      (Po2 : PointedSemigroup A2) :
      Set where
      constructor PointedSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Po1 x1 x2)
            (op Po2 y1 y2)
        interp-e :
          interp (e Po1) (e Po2)
    data PointedSemigroupLang
      : Set where
      opL :
        PointedSemigroupLang ->
        PointedSemigroupLang ->
        PointedSemigroupLang
      eL : PointedSemigroupLang
    data PointedSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        PointedSemigroupOpenLang n
      opOL :
        PointedSemigroupOpenLang n ->
        PointedSemigroupOpenLang n ->
        PointedSemigroupOpenLang n
      eOL : PointedSemigroupOpenLang n
    evalTerm :
      (A : Set) ->
      PointedSemigroup A ->
      PointedSemigroupLang -> A
    evalTerm _ Po (opL x1 x2) =
      op Po (evalTerm _ Po x1)
        (evalTerm _ Po x2)
    evalTerm _ Po (eL) = e Po
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PointedSemigroup A ->
      PointedSemigroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (opOL
                         x1
                         x2) vars =
      op po
        (evalOpenTerm _ n po x1 vars)
        (evalOpenTerm _ n po x2 vars)
    evalOpenTerm _ n po (eOL) vars =
      e po
  
  module PointedSteinerMagma where
    record PointedSteinerMagma
      (A : Set) : Set where
      constructor PointedSteinerMagmaC
      field
        op : A -> A -> A
        e : A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
        antiAbsorbent :
          (x : A) (y : A) ->
          op x (op x y) == y
    record PointedSteinerMagmaSig
      (AS : Set) : Set where
      constructor PointedSteinerMagmaSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record PointedSteinerMagmaProd
      (AP : Set) : Set where
      constructor PointedSteinerMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
        antiAbsorbentP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (opP xP yP) == yP
    record PointedSteinerMagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedSteinerMagma A1)
      (Po2 : PointedSteinerMagma A2) :
      Set where
      constructor PointedSteinerMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Po1 x1 x2) ==
            op Po2 (hom x1) (hom x2)
        pres-e : hom (e Po1) == e Po2
    record PointedSteinerMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedSteinerMagma A1)
      (Po2 : PointedSteinerMagma A2) :
      Set where
      constructor PointedSteinerMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Po1 x1 x2)
            (op Po2 y1 y2)
        interp-e :
          interp (e Po1) (e Po2)
    data PointedSteinerMagmaLang
      : Set where
      opL :
        PointedSteinerMagmaLang ->
        PointedSteinerMagmaLang ->
        PointedSteinerMagmaLang
      eL : PointedSteinerMagmaLang
    data PointedSteinerMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        PointedSteinerMagmaOpenLang n
      opOL :
        PointedSteinerMagmaOpenLang n ->
        PointedSteinerMagmaOpenLang n ->
        PointedSteinerMagmaOpenLang n
      eOL :
        PointedSteinerMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      PointedSteinerMagma A ->
      PointedSteinerMagmaLang -> A
    evalTerm _ Po (opL x1 x2) =
      op Po (evalTerm _ Po x1)
        (evalTerm _ Po x2)
    evalTerm _ Po (eL) = e Po
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PointedSteinerMagma A ->
      PointedSteinerMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (opOL
                         x1
                         x2) vars =
      op po
        (evalOpenTerm _ n po x1 vars)
        (evalOpenTerm _ n po x2 vars)
    evalOpenTerm _ n po (eOL) vars =
      e po
  
  module PointedTimesMagma where
    record PointedTimesMagma
      (A : Set) : Set where
      constructor PointedTimesMagmaC
      field
        * : A -> A -> A
        e : A
    record PointedTimesMagmaSig
      (AS : Set) : Set where
      constructor PointedTimesMagmaSigSigC
      field
        *S : AS -> AS -> AS
        eS : AS
    record PointedTimesMagmaProd
      (AP : Set) : Set where
      constructor PointedTimesMagmaProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
    record PointedTimesMagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedTimesMagma A1)
      (Po2 : PointedTimesMagma A2) :
      Set where
      constructor PointedTimesMagmaHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Po1 x1 x2) ==
            * Po2 (hom x1) (hom x2)
        pres-e : hom (e Po1) == e Po2
    record PointedTimesMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedTimesMagma A1)
      (Po2 : PointedTimesMagma A2) :
      Set where
      constructor PointedTimesMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Po1 x1 x2)
            (* Po2 y1 y2)
        interp-e :
          interp (e Po1) (e Po2)
    data PointedTimesMagmaLang
      : Set where
      *L :
        PointedTimesMagmaLang ->
        PointedTimesMagmaLang ->
        PointedTimesMagmaLang
      eL : PointedTimesMagmaLang
    data PointedTimesMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        PointedTimesMagmaOpenLang n
      *OL :
        PointedTimesMagmaOpenLang n ->
        PointedTimesMagmaOpenLang n ->
        PointedTimesMagmaOpenLang n
      eOL :
        PointedTimesMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      PointedTimesMagma A ->
      PointedTimesMagmaLang -> A
    evalTerm _ Po (*L x1 x2) =
      * Po (evalTerm _ Po x1)
        (evalTerm _ Po x2)
    evalTerm _ Po (eL) = e Po
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PointedTimesMagma A ->
      PointedTimesMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (*OL
                         x1
                         x2) vars =
      * po
        (evalOpenTerm _ n po x1 vars)
        (evalOpenTerm _ n po x2 vars)
    evalOpenTerm _ n po (eOL) vars =
      e po
  
  module PointedTimesZeroMagma where
    record PointedTimesZeroMagma
      (A : Set) : Set where
      constructor PointedTimesZeroMagmaC
      field
        0 : A
        * : A -> A -> A
    record PointedTimesZeroMagmaSig
      (AS : Set) : Set where
      constructor PointedTimesZeroMagmaSigSigC
      field
        0S : AS
        *S : AS -> AS -> AS
    record PointedTimesZeroMagmaProd
      (AP : Set) : Set where
      constructor PointedTimesZeroMagmaProdC
      field
        0P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record PointedTimesZeroMagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedTimesZeroMagma A1)
      (Po2 : PointedTimesZeroMagma
         A2) : Set where
      constructor PointedTimesZeroMagmaHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Po1) == 0 Po2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Po1 x1 x2) ==
            * Po2 (hom x1) (hom x2)
    record PointedTimesZeroMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedTimesZeroMagma A1)
      (Po2 : PointedTimesZeroMagma
         A2) : Set where
      constructor PointedTimesZeroMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Po1) (0 Po2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Po1 x1 x2)
            (* Po2 y1 y2)
    data PointedTimesZeroMagmaLang
      : Set where
      0L : PointedTimesZeroMagmaLang
      *L :
        PointedTimesZeroMagmaLang ->
        PointedTimesZeroMagmaLang ->
        PointedTimesZeroMagmaLang
    data PointedTimesZeroMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        PointedTimesZeroMagmaOpenLang n
      0OL :
        PointedTimesZeroMagmaOpenLang n
      *OL :
        PointedTimesZeroMagmaOpenLang
          n ->
        PointedTimesZeroMagmaOpenLang
          n ->
        PointedTimesZeroMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      PointedTimesZeroMagma A ->
      PointedTimesZeroMagmaLang -> A
    evalTerm _ Po (0L) = 0 Po
    evalTerm _ Po (*L x1 x2) =
      * Po (evalTerm _ Po x1)
        (evalTerm _ Po x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PointedTimesZeroMagma A ->
      PointedTimesZeroMagmaOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (0OL) vars =
      0 po
    evalOpenTerm _ n po (*OL
                         x1
                         x2) vars =
      * po
        (evalOpenTerm _ n po x1 vars)
        (evalOpenTerm _ n po x2 vars)
  
  module PointedUnarySystem where
    record PointedUnarySystem
      (A : Set) : Set where
      constructor PointedUnarySystemC
      field
        prim : A -> A
        e : A
    record PointedUnarySystemSig
      (AS : Set) : Set where
      constructor PointedUnarySystemSigSigC
      field
        primS : AS -> AS
        eS : AS
    record PointedUnarySystemProd
      (AP : Set) : Set where
      constructor PointedUnarySystemProdC
      field
        primP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
    record PointedUnarySystemHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedUnarySystem A1)
      (Po2 : PointedUnarySystem A2) :
      Set where
      constructor PointedUnarySystemHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Po1 x1) ==
            prim Po2 (hom x1)
        pres-e : hom (e Po1) == e Po2
    record PointedUnarySystemRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedUnarySystem A1)
      (Po2 : PointedUnarySystem A2) :
      Set where
      constructor PointedUnarySystemRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Po1 x1)
            (prim Po2 y1)
        interp-e :
          interp (e Po1) (e Po2)
    data PointedUnarySystemLang
      : Set where
      primL :
        PointedUnarySystemLang ->
        PointedUnarySystemLang
      eL : PointedUnarySystemLang
    data PointedUnarySystemOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        PointedUnarySystemOpenLang n
      primOL :
        PointedUnarySystemOpenLang n ->
        PointedUnarySystemOpenLang n
      eOL :
        PointedUnarySystemOpenLang n
    evalTerm :
      (A : Set) ->
      PointedUnarySystem A ->
      PointedUnarySystemLang -> A
    evalTerm _ Po (primL x1) =
      prim Po (evalTerm _ Po x1)
    evalTerm _ Po (eL) = e Po
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PointedUnarySystem A ->
      PointedUnarySystemOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (primOL
                         x1) vars =
      prim po
        (evalOpenTerm _ n po x1 vars)
    evalOpenTerm _ n po (eOL) vars =
      e po
  
  module PointedZero where
    record PointedZero
      (A : Set) : Set where
      constructor PointedZeroC
      field
        0 : A
    record PointedZeroSig
      (AS : Set) : Set where
      constructor PointedZeroSigSigC
      field
        0S : AS
    record PointedZeroProd
      (AP : Set) : Set where
      constructor PointedZeroProdC
      field
        0P : Prod AP AP
    record PointedZeroHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedZero A1)
      (Po2 : PointedZero A2) :
      Set where
      constructor PointedZeroHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Po1) == 0 Po2
    record PointedZeroRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedZero A1)
      (Po2 : PointedZero A2) :
      Set where
      constructor PointedZeroRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Po1) (0 Po2)
    data PointedZeroLang : Set where
      0L : PointedZeroLang
    data PointedZeroOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> PointedZeroOpenLang n
      0OL : PointedZeroOpenLang n
    evalTerm :
      (A : Set) ->
      PointedZero A ->
      PointedZeroLang -> A
    evalTerm _ Po (0L) = 0 Po
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PointedZero A ->
      PointedZeroOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n po (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n po (0OL) vars =
      0 po
  
  module PreSemiring where
    record PreSemiring
      (A : Set) : Set where
      constructor PreSemiringC
      field
        * : A -> A -> A
        + : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record PreSemiringSig
      (AS : Set) : Set where
      constructor PreSemiringSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record PreSemiringProd
      (AP : Set) : Set where
      constructor PreSemiringProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record PreSemiringHom
      (A1 : Set) (A2 : Set)
      (Pr1 : PreSemiring A1)
      (Pr2 : PreSemiring A2) :
      Set where
      constructor PreSemiringHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Pr1 x1 x2) ==
            * Pr2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Pr1 x1 x2) ==
            + Pr2 (hom x1) (hom x2)
    record PreSemiringRelInterp
      (A1 : Set) (A2 : Set)
      (Pr1 : PreSemiring A1)
      (Pr2 : PreSemiring A2) :
      Set where
      constructor PreSemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Pr1 x1 x2)
            (* Pr2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Pr1 x1 x2)
            (+ Pr2 y1 y2)
    data PreSemiringLang : Set where
      *L :
        PreSemiringLang ->
        PreSemiringLang ->
        PreSemiringLang
      +L :
        PreSemiringLang ->
        PreSemiringLang ->
        PreSemiringLang
    data PreSemiringOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> PreSemiringOpenLang n
      *OL :
        PreSemiringOpenLang n ->
        PreSemiringOpenLang n ->
        PreSemiringOpenLang n
      +OL :
        PreSemiringOpenLang n ->
        PreSemiringOpenLang n ->
        PreSemiringOpenLang n
    evalTerm :
      (A : Set) ->
      PreSemiring A ->
      PreSemiringLang -> A
    evalTerm _ Pr (*L x1 x2) =
      * Pr (evalTerm _ Pr x1)
        (evalTerm _ Pr x2)
    evalTerm _ Pr (+L x1 x2) =
      + Pr (evalTerm _ Pr x1)
        (evalTerm _ Pr x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PreSemiring A ->
      PreSemiringOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n pr (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n pr (*OL
                         x1
                         x2) vars =
      * pr
        (evalOpenTerm _ n pr x1 vars)
        (evalOpenTerm _ n pr x2 vars)
    evalOpenTerm _ n pr (+OL
                         x1
                         x2) vars =
      + pr
        (evalOpenTerm _ n pr x1 vars)
        (evalOpenTerm _ n pr x2 vars)
  
  module PrimAdditiveGroup where
    record PrimAdditiveGroup
      (A : Set) : Set where
      constructor PrimAdditiveGroupC
      field
        0_ : A
        *_ : A -> A -> A
        lunit_0_ :
          (x : A) -> *_ 0_ x == x
        runit_0_ :
          (x : A) -> *_ x 0_ == x
        associative_*_ :
          (x : A) (y : A) (z : A) ->
          *_ (*_ x y) z == *_ x (*_ y z)
        inv_ : A -> A
        leftInverse_inv_op_0_ :
          (x : A) -> *_ x (inv_ x) == 0_
        rightInverse_inv_op_0_ :
          (x : A) -> *_ (inv_ x) x == 0_
        commutative_*_ :
          (x : A) (y : A) ->
          *_ x y == *_ y x
    record PrimAdditiveGroupSig
      (AS : Set) : Set where
      constructor PrimAdditiveGroupSigSigC
      field
        0_S : AS
        *_S : AS -> AS -> AS
        inv_S : AS -> AS
    record PrimAdditiveGroupProd
      (AP : Set) : Set where
      constructor PrimAdditiveGroupProdC
      field
        0_P : Prod AP AP
        *_P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        inv_P : Prod AP AP -> Prod AP AP
        lunit_0_P :
          (xP : Prod AP AP) ->
          *_P 0_P xP == xP
        runit_0_P :
          (xP : Prod AP AP) ->
          *_P xP 0_P == xP
        associative_*_P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *_P (*_P xP yP) zP ==
            *_P xP (*_P yP zP)
        leftInverse_inv_op_0_P :
          (xP : Prod AP AP) ->
          *_P xP (inv_P xP) == 0_P
        rightInverse_inv_op_0_P :
          (xP : Prod AP AP) ->
          *_P (inv_P xP) xP == 0_P
        commutative_*_P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *_P xP yP == *_P yP xP
    record PrimAdditiveGroupHom
      (A1 : Set) (A2 : Set)
      (Pr1 : PrimAdditiveGroup A1)
      (Pr2 : PrimAdditiveGroup A2) :
      Set where
      constructor PrimAdditiveGroupHomC
      field
        hom : A1 -> A2
        pres-0_ : hom (0_ Pr1) == 0_ Pr2
        pres-*_ :
          (x1 : A1) (x2 : A1) ->
          hom (*_ Pr1 x1 x2) ==
            *_ Pr2 (hom x1) (hom x2)
        pres-inv_ :
          (x1 : A1) ->
          hom (inv_ Pr1 x1) ==
            inv_ Pr2 (hom x1)
    record PrimAdditiveGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Pr1 : PrimAdditiveGroup A1)
      (Pr2 : PrimAdditiveGroup A2) :
      Set where
      constructor PrimAdditiveGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0_ :
          interp (0_ Pr1) (0_ Pr2)
        interp-*_ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (*_ Pr1 x1 x2)
            (*_ Pr2 y1 y2)
        interp-inv_ :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv_ Pr1 x1)
            (inv_ Pr2 y1)
    data PrimAdditiveGroupLang
      : Set where
      0_L : PrimAdditiveGroupLang
      *_L :
        PrimAdditiveGroupLang ->
        PrimAdditiveGroupLang ->
        PrimAdditiveGroupLang
      inv_L :
        PrimAdditiveGroupLang ->
        PrimAdditiveGroupLang
    data PrimAdditiveGroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        PrimAdditiveGroupOpenLang n
      0_OL :
        PrimAdditiveGroupOpenLang n
      *_OL :
        PrimAdditiveGroupOpenLang n ->
        PrimAdditiveGroupOpenLang n ->
        PrimAdditiveGroupOpenLang n
      inv_OL :
        PrimAdditiveGroupOpenLang n ->
        PrimAdditiveGroupOpenLang n
    evalTerm :
      (A : Set) ->
      PrimAdditiveGroup A ->
      PrimAdditiveGroupLang -> A
    evalTerm _ Pr (0_L) = 0_ Pr
    evalTerm _ Pr (*_L x1 x2) =
      *_ Pr (evalTerm _ Pr x1)
        (evalTerm _ Pr x2)
    evalTerm _ Pr (inv_L x1) =
      inv_ Pr (evalTerm _ Pr x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PrimAdditiveGroup A ->
      PrimAdditiveGroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n pr (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n pr (0_OL) vars =
      0_ pr
    evalOpenTerm _ n pr (*_OL
                         x1
                         x2) vars =
      *_ pr
        (evalOpenTerm _ n pr x1 vars)
        (evalOpenTerm _ n pr x2 vars)
    evalOpenTerm _ n pr (inv_OL
                         x1) vars =
      inv_ pr
        (evalOpenTerm _ n pr x1 vars)
  
  module PrimRingoidSig where
    record PrimRingoidSig
      (A : Set) : Set where
      constructor PrimRingoidSigC
      field
        * : A -> A -> A
        + : A -> A -> A
        prim : A -> A
    record PrimRingoidSigSig
      (AS : Set) : Set where
      constructor PrimRingoidSigSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        primS : AS -> AS
    record PrimRingoidSigProd
      (AP : Set) : Set where
      constructor PrimRingoidSigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
    record PrimRingoidSigHom
      (A1 : Set) (A2 : Set)
      (Pr1 : PrimRingoidSig A1)
      (Pr2 : PrimRingoidSig A2) :
      Set where
      constructor PrimRingoidSigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Pr1 x1 x2) ==
            * Pr2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Pr1 x1 x2) ==
            + Pr2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Pr1 x1) ==
            prim Pr2 (hom x1)
    record PrimRingoidSigRelInterp
      (A1 : Set) (A2 : Set)
      (Pr1 : PrimRingoidSig A1)
      (Pr2 : PrimRingoidSig A2) :
      Set where
      constructor PrimRingoidSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Pr1 x1 x2)
            (* Pr2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Pr1 x1 x2)
            (+ Pr2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Pr1 x1)
            (prim Pr2 y1)
    data PrimRingoidSigLang
      : Set where
      *L :
        PrimRingoidSigLang ->
        PrimRingoidSigLang ->
        PrimRingoidSigLang
      +L :
        PrimRingoidSigLang ->
        PrimRingoidSigLang ->
        PrimRingoidSigLang
      primL :
        PrimRingoidSigLang ->
        PrimRingoidSigLang
    data PrimRingoidSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        PrimRingoidSigOpenLang n
      *OL :
        PrimRingoidSigOpenLang n ->
        PrimRingoidSigOpenLang n ->
        PrimRingoidSigOpenLang n
      +OL :
        PrimRingoidSigOpenLang n ->
        PrimRingoidSigOpenLang n ->
        PrimRingoidSigOpenLang n
      primOL :
        PrimRingoidSigOpenLang n ->
        PrimRingoidSigOpenLang n
    evalTerm :
      (A : Set) ->
      PrimRingoidSig A ->
      PrimRingoidSigLang -> A
    evalTerm _ Pr (*L x1 x2) =
      * Pr (evalTerm _ Pr x1)
        (evalTerm _ Pr x2)
    evalTerm _ Pr (+L x1 x2) =
      + Pr (evalTerm _ Pr x1)
        (evalTerm _ Pr x2)
    evalTerm _ Pr (primL x1) =
      prim Pr (evalTerm _ Pr x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PrimRingoidSig A ->
      PrimRingoidSigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n pr (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n pr (*OL
                         x1
                         x2) vars =
      * pr
        (evalOpenTerm _ n pr x1 vars)
        (evalOpenTerm _ n pr x2 vars)
    evalOpenTerm _ n pr (+OL
                         x1
                         x2) vars =
      + pr
        (evalOpenTerm _ n pr x1 vars)
        (evalOpenTerm _ n pr x2 vars)
    evalOpenTerm _ n pr (primOL
                         x1) vars =
      prim pr
        (evalOpenTerm _ n pr x1 vars)
  
  module PseudoInverse where
    record PseudoInverse
      (A : Set) : Set where
      constructor PseudoInverseC
      field
        inv : A -> A
        op : A -> A -> A
        quasiInverse_inv_op_e :
          (x : A) ->
          op (op x (inv x)) x == x
    record PseudoInverseSig
      (AS : Set) : Set where
      constructor PseudoInverseSigSigC
      field
        invS : AS -> AS
        opS : AS -> AS -> AS
    record PseudoInverseProd
      (AP : Set) : Set where
      constructor PseudoInverseProdC
      field
        invP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        quasiInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (opP xP (invP xP)) xP == xP
    record PseudoInverseHom
      (A1 : Set) (A2 : Set)
      (Ps1 : PseudoInverse A1)
      (Ps2 : PseudoInverse A2) :
      Set where
      constructor PseudoInverseHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv Ps1 x1) ==
            inv Ps2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ps1 x1 x2) ==
            op Ps2 (hom x1) (hom x2)
    record PseudoInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Ps1 : PseudoInverse A1)
      (Ps2 : PseudoInverse A2) :
      Set where
      constructor PseudoInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Ps1 x1) (inv Ps2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ps1 x1 x2)
            (op Ps2 y1 y2)
    data PseudoInverseLang
      : Set where
      invL :
        PseudoInverseLang ->
        PseudoInverseLang
      opL :
        PseudoInverseLang ->
        PseudoInverseLang ->
        PseudoInverseLang
    data PseudoInverseOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> PseudoInverseOpenLang n
      invOL :
        PseudoInverseOpenLang n ->
        PseudoInverseOpenLang n
      opOL :
        PseudoInverseOpenLang n ->
        PseudoInverseOpenLang n ->
        PseudoInverseOpenLang n
    evalTerm :
      (A : Set) ->
      PseudoInverse A ->
      PseudoInverseLang -> A
    evalTerm _ Ps (invL x1) =
      inv Ps (evalTerm _ Ps x1)
    evalTerm _ Ps (opL x1 x2) =
      op Ps (evalTerm _ Ps x1)
        (evalTerm _ Ps x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PseudoInverse A ->
      PseudoInverseOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ps (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ps (invOL
                         x1) vars =
      inv ps
        (evalOpenTerm _ n ps x1 vars)
    evalOpenTerm _ n ps (opOL
                         x1
                         x2) vars =
      op ps
        (evalOpenTerm _ n ps x1 vars)
        (evalOpenTerm _ n ps x2 vars)
  
  module PseudoInverseSig where
    record PseudoInverseSig
      (A : Set) : Set where
      constructor PseudoInverseSigC
      field
        inv : A -> A
        op : A -> A -> A
    record PseudoInverseSigSig
      (AS : Set) : Set where
      constructor PseudoInverseSigSigSigC
      field
        invS : AS -> AS
        opS : AS -> AS -> AS
    record PseudoInverseSigProd
      (AP : Set) : Set where
      constructor PseudoInverseSigProdC
      field
        invP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record PseudoInverseSigHom
      (A1 : Set) (A2 : Set)
      (Ps1 : PseudoInverseSig A1)
      (Ps2 : PseudoInverseSig A2) :
      Set where
      constructor PseudoInverseSigHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv Ps1 x1) ==
            inv Ps2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ps1 x1 x2) ==
            op Ps2 (hom x1) (hom x2)
    record PseudoInverseSigRelInterp
      (A1 : Set) (A2 : Set)
      (Ps1 : PseudoInverseSig A1)
      (Ps2 : PseudoInverseSig A2) :
      Set where
      constructor PseudoInverseSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Ps1 x1) (inv Ps2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ps1 x1 x2)
            (op Ps2 y1 y2)
    data PseudoInverseSigLang
      : Set where
      invL :
        PseudoInverseSigLang ->
        PseudoInverseSigLang
      opL :
        PseudoInverseSigLang ->
        PseudoInverseSigLang ->
        PseudoInverseSigLang
    data PseudoInverseSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        PseudoInverseSigOpenLang n
      invOL :
        PseudoInverseSigOpenLang n ->
        PseudoInverseSigOpenLang n
      opOL :
        PseudoInverseSigOpenLang n ->
        PseudoInverseSigOpenLang n ->
        PseudoInverseSigOpenLang n
    evalTerm :
      (A : Set) ->
      PseudoInverseSig A ->
      PseudoInverseSigLang -> A
    evalTerm _ Ps (invL x1) =
      inv Ps (evalTerm _ Ps x1)
    evalTerm _ Ps (opL x1 x2) =
      op Ps (evalTerm _ Ps x1)
        (evalTerm _ Ps x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PseudoInverseSig A ->
      PseudoInverseSigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ps (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ps (invOL
                         x1) vars =
      inv ps
        (evalOpenTerm _ n ps x1 vars)
    evalOpenTerm _ n ps (opOL
                         x1
                         x2) vars =
      op ps
        (evalOpenTerm _ n ps x1 vars)
        (evalOpenTerm _ n ps x2 vars)
  
  module PseudoInvolution where
    record PseudoInvolution
      (A : Set) : Set where
      constructor PseudoInvolutionC
      field
        inv : A -> A
        op : A -> A -> A
        quasiRightInverse_inv_op_e :
          (x : A) ->
          op (op (inv x) x) (inv x) ==
            inv x
    record PseudoInvolutionSig
      (AS : Set) : Set where
      constructor PseudoInvolutionSigSigC
      field
        invS : AS -> AS
        opS : AS -> AS -> AS
    record PseudoInvolutionProd
      (AP : Set) : Set where
      constructor PseudoInvolutionProdC
      field
        invP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        quasiRightInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (opP (invP xP) xP)
            (invP xP) == invP xP
    record PseudoInvolutionHom
      (A1 : Set) (A2 : Set)
      (Ps1 : PseudoInvolution A1)
      (Ps2 : PseudoInvolution A2) :
      Set where
      constructor PseudoInvolutionHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv Ps1 x1) ==
            inv Ps2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ps1 x1 x2) ==
            op Ps2 (hom x1) (hom x2)
    record PseudoInvolutionRelInterp
      (A1 : Set) (A2 : Set)
      (Ps1 : PseudoInvolution A1)
      (Ps2 : PseudoInvolution A2) :
      Set where
      constructor PseudoInvolutionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Ps1 x1) (inv Ps2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ps1 x1 x2)
            (op Ps2 y1 y2)
    data PseudoInvolutionLang
      : Set where
      invL :
        PseudoInvolutionLang ->
        PseudoInvolutionLang
      opL :
        PseudoInvolutionLang ->
        PseudoInvolutionLang ->
        PseudoInvolutionLang
    data PseudoInvolutionOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        PseudoInvolutionOpenLang n
      invOL :
        PseudoInvolutionOpenLang n ->
        PseudoInvolutionOpenLang n
      opOL :
        PseudoInvolutionOpenLang n ->
        PseudoInvolutionOpenLang n ->
        PseudoInvolutionOpenLang n
    evalTerm :
      (A : Set) ->
      PseudoInvolution A ->
      PseudoInvolutionLang -> A
    evalTerm _ Ps (invL x1) =
      inv Ps (evalTerm _ Ps x1)
    evalTerm _ Ps (opL x1 x2) =
      op Ps (evalTerm _ Ps x1)
        (evalTerm _ Ps x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      PseudoInvolution A ->
      PseudoInvolutionOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ps (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ps (invOL
                         x1) vars =
      inv ps
        (evalOpenTerm _ n ps x1 vars)
    evalOpenTerm _ n ps (opOL
                         x1
                         x2) vars =
      op ps
        (evalOpenTerm _ n ps x1 vars)
        (evalOpenTerm _ n ps x2 vars)
  
  module Quandle where
    record Quandle
      (A : Set) : Set where
      constructor QuandleC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
        leftInverse :
          (x : A) (y : A) ->
          <| (|> x y) x == y
        rightInverse :
          (x : A) (y : A) ->
          |> x (<| y x) == y
        idempotent_|> :
          (x : A) -> |> x x == x
        idempotent_<| :
          (x : A) -> <| x x == x
    record QuandleSig
      (AS : Set) : Set where
      constructor QuandleSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record QuandleProd
      (AP : Set) : Set where
      constructor QuandleProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
        leftInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          <|P (|>P xP yP) xP == yP
        rightInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          |>P xP (<|P yP xP) == yP
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
        idempotent_<|P :
          (xP : Prod AP AP) ->
          <|P xP xP == xP
    record QuandleHom
      (A1 : Set) (A2 : Set)
      (Qu1 : Quandle A1)
      (Qu2 : Quandle A2) : Set where
      constructor QuandleHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Qu1 x1 x2) ==
            |> Qu2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Qu1 x1 x2) ==
            <| Qu2 (hom x1) (hom x2)
    record QuandleRelInterp
      (A1 : Set) (A2 : Set)
      (Qu1 : Quandle A1)
      (Qu2 : Quandle A2) : Set where
      constructor QuandleRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Qu1 x1 x2)
            (|> Qu2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Qu1 x1 x2)
            (<| Qu2 y1 y2)
    data QuandleLang : Set where
      |>L :
        QuandleLang ->
        QuandleLang -> QuandleLang
      <|L :
        QuandleLang ->
        QuandleLang -> QuandleLang
    data QuandleOpenLang
      (n : Nat) : Set where
      v : Fin n -> QuandleOpenLang n
      |>OL :
        QuandleOpenLang n ->
        QuandleOpenLang n ->
        QuandleOpenLang n
      <|OL :
        QuandleOpenLang n ->
        QuandleOpenLang n ->
        QuandleOpenLang n
    evalTerm :
      (A : Set) ->
      Quandle A -> QuandleLang -> A
    evalTerm _ Qu (|>L x1 x2) =
      |> Qu (evalTerm _ Qu x1)
        (evalTerm _ Qu x2)
    evalTerm _ Qu (<|L x1 x2) =
      <| Qu (evalTerm _ Qu x1)
        (evalTerm _ Qu x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Quandle A ->
      QuandleOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n qu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n qu (|>OL
                         x1
                         x2) vars =
      |> qu
        (evalOpenTerm _ n qu x1 vars)
        (evalOpenTerm _ n qu x2 vars)
    evalOpenTerm _ n qu (<|OL
                         x1
                         x2) vars =
      <| qu
        (evalOpenTerm _ n qu x1 vars)
        (evalOpenTerm _ n qu x2 vars)
  
  module QuasiGroup where
    record QuasiGroup
      (A : Set) : Set where
      constructor QuasiGroupC
      field
        op : A -> A -> A
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
    record QuasiGroupSig
      (AS : Set) : Set where
      constructor QuasiGroupSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record QuasiGroupProd
      (AP : Set) : Set where
      constructor QuasiGroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
    record QuasiGroupHom
      (A1 : Set) (A2 : Set)
      (Qu1 : QuasiGroup A1)
      (Qu2 : QuasiGroup A2) :
      Set where
      constructor QuasiGroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Qu1 x1 x2) ==
            op Qu2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Qu1 x1 x2) ==
            linv Qu2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Qu1 x1 x2) ==
            rinv Qu2 (hom x1) (hom x2)
    record QuasiGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Qu1 : QuasiGroup A1)
      (Qu2 : QuasiGroup A2) :
      Set where
      constructor QuasiGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Qu1 x1 x2)
            (op Qu2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Qu1 x1 x2)
            (linv Qu2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Qu1 x1 x2)
            (rinv Qu2 y1 y2)
    data QuasiGroupLang : Set where
      opL :
        QuasiGroupLang ->
        QuasiGroupLang -> QuasiGroupLang
      linvL :
        QuasiGroupLang ->
        QuasiGroupLang -> QuasiGroupLang
      rinvL :
        QuasiGroupLang ->
        QuasiGroupLang -> QuasiGroupLang
    data QuasiGroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> QuasiGroupOpenLang n
      opOL :
        QuasiGroupOpenLang n ->
        QuasiGroupOpenLang n ->
        QuasiGroupOpenLang n
      linvOL :
        QuasiGroupOpenLang n ->
        QuasiGroupOpenLang n ->
        QuasiGroupOpenLang n
      rinvOL :
        QuasiGroupOpenLang n ->
        QuasiGroupOpenLang n ->
        QuasiGroupOpenLang n
    evalTerm :
      (A : Set) ->
      QuasiGroup A ->
      QuasiGroupLang -> A
    evalTerm _ Qu (opL x1 x2) =
      op Qu (evalTerm _ Qu x1)
        (evalTerm _ Qu x2)
    evalTerm _ Qu (linvL x1 x2) =
      linv Qu (evalTerm _ Qu x1)
        (evalTerm _ Qu x2)
    evalTerm _ Qu (rinvL x1 x2) =
      rinv Qu (evalTerm _ Qu x1)
        (evalTerm _ Qu x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      QuasiGroup A ->
      QuasiGroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n qu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n qu (opOL
                         x1
                         x2) vars =
      op qu
        (evalOpenTerm _ n qu x1 vars)
        (evalOpenTerm _ n qu x2 vars)
    evalOpenTerm _ n qu (linvOL
                         x1
                         x2) vars =
      linv qu
        (evalOpenTerm _ n qu x1 vars)
        (evalOpenTerm _ n qu x2 vars)
    evalOpenTerm _ n qu (rinvOL
                         x1
                         x2) vars =
      rinv qu
        (evalOpenTerm _ n qu x1 vars)
        (evalOpenTerm _ n qu x2 vars)
  
  module QuasiInverse where
    record QuasiInverse
      (A : Set) : Set where
      constructor QuasiInverseC
      field
        inv : A -> A
        op : A -> A -> A
        quasiInverse_inv_op_e :
          (x : A) ->
          op (op x (inv x)) x == x
        quasiRightInverse_inv_op_e :
          (x : A) ->
          op (op (inv x) x) (inv x) ==
            inv x
    record QuasiInverseSig
      (AS : Set) : Set where
      constructor QuasiInverseSigSigC
      field
        invS : AS -> AS
        opS : AS -> AS -> AS
    record QuasiInverseProd
      (AP : Set) : Set where
      constructor QuasiInverseProdC
      field
        invP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        quasiInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (opP xP (invP xP)) xP == xP
        quasiRightInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (opP (invP xP) xP)
            (invP xP) == invP xP
    record QuasiInverseHom
      (A1 : Set) (A2 : Set)
      (Qu1 : QuasiInverse A1)
      (Qu2 : QuasiInverse A2) :
      Set where
      constructor QuasiInverseHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv Qu1 x1) ==
            inv Qu2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Qu1 x1 x2) ==
            op Qu2 (hom x1) (hom x2)
    record QuasiInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Qu1 : QuasiInverse A1)
      (Qu2 : QuasiInverse A2) :
      Set where
      constructor QuasiInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Qu1 x1) (inv Qu2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Qu1 x1 x2)
            (op Qu2 y1 y2)
    data QuasiInverseLang
      : Set where
      invL :
        QuasiInverseLang ->
        QuasiInverseLang
      opL :
        QuasiInverseLang ->
        QuasiInverseLang ->
        QuasiInverseLang
    data QuasiInverseOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> QuasiInverseOpenLang n
      invOL :
        QuasiInverseOpenLang n ->
        QuasiInverseOpenLang n
      opOL :
        QuasiInverseOpenLang n ->
        QuasiInverseOpenLang n ->
        QuasiInverseOpenLang n
    evalTerm :
      (A : Set) ->
      QuasiInverse A ->
      QuasiInverseLang -> A
    evalTerm _ Qu (invL x1) =
      inv Qu (evalTerm _ Qu x1)
    evalTerm _ Qu (opL x1 x2) =
      op Qu (evalTerm _ Qu x1)
        (evalTerm _ Qu x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      QuasiInverse A ->
      QuasiInverseOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n qu (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n qu (invOL
                         x1) vars =
      inv qu
        (evalOpenTerm _ n qu x1 vars)
    evalOpenTerm _ n qu (opOL
                         x1
                         x2) vars =
      op qu
        (evalOpenTerm _ n qu x1 vars)
        (evalOpenTerm _ n qu x2 vars)
  
  module Rack where
    record Rack
      (A : Set) : Set where
      constructor RackC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
        leftInverse :
          (x : A) (y : A) ->
          <| (|> x y) x == y
        rightInverse :
          (x : A) (y : A) ->
          |> x (<| y x) == y
    record RackSig
      (AS : Set) : Set where
      constructor RackSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record RackProd
      (AP : Set) : Set where
      constructor RackProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
        leftInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          <|P (|>P xP yP) xP == yP
        rightInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          |>P xP (<|P yP xP) == yP
    record RackHom
      (A1 : Set) (A2 : Set)
      (Ra1 : Rack A1)
      (Ra2 : Rack A2) : Set where
      constructor RackHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ra1 x1 x2) ==
            |> Ra2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ra1 x1 x2) ==
            <| Ra2 (hom x1) (hom x2)
    record RackRelInterp
      (A1 : Set) (A2 : Set)
      (Ra1 : Rack A1)
      (Ra2 : Rack A2) : Set where
      constructor RackRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ra1 x1 x2)
            (|> Ra2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ra1 x1 x2)
            (<| Ra2 y1 y2)
    data RackLang : Set where
      |>L :
        RackLang -> RackLang -> RackLang
      <|L :
        RackLang -> RackLang -> RackLang
    data RackOpenLang
      (n : Nat) : Set where
      v : Fin n -> RackOpenLang n
      |>OL :
        RackOpenLang n ->
        RackOpenLang n -> RackOpenLang n
      <|OL :
        RackOpenLang n ->
        RackOpenLang n -> RackOpenLang n
    evalTerm :
      (A : Set) ->
      Rack A -> RackLang -> A
    evalTerm _ Ra (|>L x1 x2) =
      |> Ra (evalTerm _ Ra x1)
        (evalTerm _ Ra x2)
    evalTerm _ Ra (<|L x1 x2) =
      <| Ra (evalTerm _ Ra x1)
        (evalTerm _ Ra x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Rack A ->
      RackOpenLang n -> Vec A n -> A
    evalOpenTerm _ n ra (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ra (|>OL
                         x1
                         x2) vars =
      |> ra
        (evalOpenTerm _ n ra x1 vars)
        (evalOpenTerm _ n ra x2 vars)
    evalOpenTerm _ n ra (<|OL
                         x1
                         x2) vars =
      <| ra
        (evalOpenTerm _ n ra x1 vars)
        (evalOpenTerm _ n ra x2 vars)
  
  module RectangularBand where
    record RectangularBand
      (A : Set) : Set where
      constructor RectangularBandC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        idempotent_op :
          (x : A) -> op x x == x
        middleCommute_* :
          (x : A) (y : A) (z : A) ->
          op (op (op x y) z) x ==
            op (op (op x z) y) x
    record RectangularBandSig
      (AS : Set) : Set where
      constructor RectangularBandSigSigC
      field
        opS : AS -> AS -> AS
    record RectangularBandProd
      (AP : Set) : Set where
      constructor RectangularBandProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        idempotent_opP :
          (xP : Prod AP AP) ->
          opP xP xP == xP
        middleCommute_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP (opP xP yP) zP) xP ==
            opP (opP (opP xP zP) yP) xP
    record RectangularBandHom
      (A1 : Set) (A2 : Set)
      (Re1 : RectangularBand A1)
      (Re2 : RectangularBand A2) :
      Set where
      constructor RectangularBandHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Re1 x1 x2) ==
            op Re2 (hom x1) (hom x2)
    record RectangularBandRelInterp
      (A1 : Set) (A2 : Set)
      (Re1 : RectangularBand A1)
      (Re2 : RectangularBand A2) :
      Set where
      constructor RectangularBandRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Re1 x1 x2)
            (op Re2 y1 y2)
    data RectangularBandLang
      : Set where
      opL :
        RectangularBandLang ->
        RectangularBandLang ->
        RectangularBandLang
    data RectangularBandOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RectangularBandOpenLang n
      opOL :
        RectangularBandOpenLang n ->
        RectangularBandOpenLang n ->
        RectangularBandOpenLang n
    evalTerm :
      (A : Set) ->
      RectangularBand A ->
      RectangularBandLang -> A
    evalTerm _ Re (opL x1 x2) =
      op Re (evalTerm _ Re x1)
        (evalTerm _ Re x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RectangularBand A ->
      RectangularBandOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n re (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n re (opOL
                         x1
                         x2) vars =
      op re
        (evalOpenTerm _ n re x1 vars)
        (evalOpenTerm _ n re x2 vars)
  
  module RegularSemigroup where
    record RegularSemigroup
      (A : Set) : Set where
      constructor RegularSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        inv : A -> A
        quasiInverse_inv_op_e :
          (x : A) ->
          op (op x (inv x)) x == x
    record RegularSemigroupSig
      (AS : Set) : Set where
      constructor RegularSemigroupSigSigC
      field
        opS : AS -> AS -> AS
        invS : AS -> AS
    record RegularSemigroupProd
      (AP : Set) : Set where
      constructor RegularSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        quasiInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (opP xP (invP xP)) xP == xP
    record RegularSemigroupHom
      (A1 : Set) (A2 : Set)
      (Re1 : RegularSemigroup A1)
      (Re2 : RegularSemigroup A2) :
      Set where
      constructor RegularSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Re1 x1 x2) ==
            op Re2 (hom x1) (hom x2)
        pres-inv :
          (x1 : A1) ->
          hom (inv Re1 x1) ==
            inv Re2 (hom x1)
    record RegularSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Re1 : RegularSemigroup A1)
      (Re2 : RegularSemigroup A2) :
      Set where
      constructor RegularSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Re1 x1 x2)
            (op Re2 y1 y2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Re1 x1) (inv Re2 y1)
    data RegularSemigroupLang
      : Set where
      opL :
        RegularSemigroupLang ->
        RegularSemigroupLang ->
        RegularSemigroupLang
      invL :
        RegularSemigroupLang ->
        RegularSemigroupLang
    data RegularSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RegularSemigroupOpenLang n
      opOL :
        RegularSemigroupOpenLang n ->
        RegularSemigroupOpenLang n ->
        RegularSemigroupOpenLang n
      invOL :
        RegularSemigroupOpenLang n ->
        RegularSemigroupOpenLang n
    evalTerm :
      (A : Set) ->
      RegularSemigroup A ->
      RegularSemigroupLang -> A
    evalTerm _ Re (opL x1 x2) =
      op Re (evalTerm _ Re x1)
        (evalTerm _ Re x2)
    evalTerm _ Re (invL x1) =
      inv Re (evalTerm _ Re x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RegularSemigroup A ->
      RegularSemigroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n re (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n re (opOL
                         x1
                         x2) vars =
      op re
        (evalOpenTerm _ n re x1 vars)
        (evalOpenTerm _ n re x2 vars)
    evalOpenTerm _ n re (invOL
                         x1) vars =
      inv re
        (evalOpenTerm _ n re x1 vars)
  
  module Right0 where
    record Right0
      (A : Set) : Set where
      constructor Right0C
      field
        0 : A
        op : A -> A -> A
        rightZero_op_0 :
          (x : A) -> op x 0 == 0
    record Right0Sig
      (AS : Set) : Set where
      constructor Right0SigSigC
      field
        0S : AS
        opS : AS -> AS -> AS
    record Right0Prod
      (AP : Set) : Set where
      constructor Right0ProdC
      field
        0P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          opP xP 0P == 0P
    record Right0Hom
      (A1 : Set) (A2 : Set)
      (Ri1 : Right0 A1)
      (Ri2 : Right0 A2) : Set where
      constructor Right0HomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ri1) == 0 Ri2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record Right0RelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Right0 A1)
      (Ri2 : Right0 A2) : Set where
      constructor Right0RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ri1) (0 Ri2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data Right0Lang : Set where
      0L : Right0Lang
      opL :
        Right0Lang ->
        Right0Lang -> Right0Lang
    data Right0OpenLang
      (n : Nat) : Set where
      v : Fin n -> Right0OpenLang n
      0OL : Right0OpenLang n
      opOL :
        Right0OpenLang n ->
        Right0OpenLang n ->
        Right0OpenLang n
    evalTerm :
      (A : Set) ->
      Right0 A -> Right0Lang -> A
    evalTerm _ Ri (0L) = 0 Ri
    evalTerm _ Ri (opL x1 x2) =
      op Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Right0 A ->
      Right0OpenLang n -> Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (0OL) vars =
      0 ri
    evalOpenTerm _ n ri (opOL
                         x1
                         x2) vars =
      op ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module RightBiMagma where
    record RightBiMagma
      (A : Set) : Set where
      constructor RightBiMagmaC
      field
        op : A -> A -> A
        rinv : A -> A -> A
    record RightBiMagmaSig
      (AS : Set) : Set where
      constructor RightBiMagmaSigSigC
      field
        opS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record RightBiMagmaProd
      (AP : Set) : Set where
      constructor RightBiMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record RightBiMagmaHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightBiMagma A1)
      (Ri2 : RightBiMagma A2) :
      Set where
      constructor RightBiMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Ri1 x1 x2) ==
            rinv Ri2 (hom x1) (hom x2)
    record RightBiMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightBiMagma A1)
      (Ri2 : RightBiMagma A2) :
      Set where
      constructor RightBiMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Ri1 x1 x2)
            (rinv Ri2 y1 y2)
    data RightBiMagmaLang
      : Set where
      opL :
        RightBiMagmaLang ->
        RightBiMagmaLang ->
        RightBiMagmaLang
      rinvL :
        RightBiMagmaLang ->
        RightBiMagmaLang ->
        RightBiMagmaLang
    data RightBiMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> RightBiMagmaOpenLang n
      opOL :
        RightBiMagmaOpenLang n ->
        RightBiMagmaOpenLang n ->
        RightBiMagmaOpenLang n
      rinvOL :
        RightBiMagmaOpenLang n ->
        RightBiMagmaOpenLang n ->
        RightBiMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      RightBiMagma A ->
      RightBiMagmaLang -> A
    evalTerm _ Ri (opL x1 x2) =
      op Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (rinvL x1 x2) =
      rinv Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightBiMagma A ->
      RightBiMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (opOL
                         x1
                         x2) vars =
      op ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (rinvOL
                         x1
                         x2) vars =
      rinv ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module RightBinaryInverse where
    record RightBinaryInverse
      (A : Set) : Set where
      constructor RightBinaryInverseC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        rightInverse :
          (x : A) (y : A) ->
          |> x (<| y x) == y
    record RightBinaryInverseSig
      (AS : Set) : Set where
      constructor RightBinaryInverseSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record RightBinaryInverseProd
      (AP : Set) : Set where
      constructor RightBinaryInverseProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          |>P xP (<|P yP xP) == yP
    record RightBinaryInverseHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightBinaryInverse A1)
      (Ri2 : RightBinaryInverse A2) :
      Set where
      constructor RightBinaryInverseHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ri1 x1 x2) ==
            |> Ri2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
    record RightBinaryInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightBinaryInverse A1)
      (Ri2 : RightBinaryInverse A2) :
      Set where
      constructor RightBinaryInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ri1 x1 x2)
            (|> Ri2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
    data RightBinaryInverseLang
      : Set where
      |>L :
        RightBinaryInverseLang ->
        RightBinaryInverseLang ->
        RightBinaryInverseLang
      <|L :
        RightBinaryInverseLang ->
        RightBinaryInverseLang ->
        RightBinaryInverseLang
    data RightBinaryInverseOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RightBinaryInverseOpenLang n
      |>OL :
        RightBinaryInverseOpenLang n ->
        RightBinaryInverseOpenLang n ->
        RightBinaryInverseOpenLang n
      <|OL :
        RightBinaryInverseOpenLang n ->
        RightBinaryInverseOpenLang n ->
        RightBinaryInverseOpenLang n
    evalTerm :
      (A : Set) ->
      RightBinaryInverse A ->
      RightBinaryInverseLang -> A
    evalTerm _ Ri (|>L x1 x2) =
      |> Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (<|L x1 x2) =
      <| Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightBinaryInverse A ->
      RightBinaryInverseOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (|>OL
                         x1
                         x2) vars =
      |> ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (<|OL
                         x1
                         x2) vars =
      <| ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module RightCancellative where
    record RightCancellative
      (A : Set) : Set where
      constructor RightCancellativeC
      field
        op : A -> A -> A
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
    record RightCancellativeSig
      (AS : Set) : Set where
      constructor RightCancellativeSigSigC
      field
        opS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record RightCancellativeProd
      (AP : Set) : Set where
      constructor RightCancellativeProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
    record RightCancellativeHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellative A1)
      (Ri2 : RightCancellative A2) :
      Set where
      constructor RightCancellativeHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Ri1 x1 x2) ==
            rinv Ri2 (hom x1) (hom x2)
    record RightCancellativeRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellative A1)
      (Ri2 : RightCancellative A2) :
      Set where
      constructor RightCancellativeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Ri1 x1 x2)
            (rinv Ri2 y1 y2)
    data RightCancellativeLang
      : Set where
      opL :
        RightCancellativeLang ->
        RightCancellativeLang ->
        RightCancellativeLang
      rinvL :
        RightCancellativeLang ->
        RightCancellativeLang ->
        RightCancellativeLang
    data RightCancellativeOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RightCancellativeOpenLang n
      opOL :
        RightCancellativeOpenLang n ->
        RightCancellativeOpenLang n ->
        RightCancellativeOpenLang n
      rinvOL :
        RightCancellativeOpenLang n ->
        RightCancellativeOpenLang n ->
        RightCancellativeOpenLang n
    evalTerm :
      (A : Set) ->
      RightCancellative A ->
      RightCancellativeLang -> A
    evalTerm _ Ri (opL x1 x2) =
      op Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (rinvL x1 x2) =
      rinv Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightCancellative A ->
      RightCancellativeOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (opOL
                         x1
                         x2) vars =
      op ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (rinvOL
                         x1
                         x2) vars =
      rinv ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module RightCancellativeMagma where
    record RightCancellativeMagma
      (A : Set) : Set where
      constructor RightCancellativeMagmaC
      field
        op : A -> A -> A
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
    record RightCancellativeMagmaSig
      (AS : Set) : Set where
      constructor RightCancellativeMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record RightCancellativeMagmaProd
      (AP : Set) : Set where
      constructor RightCancellativeMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
    record RightCancellativeMagmaHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellativeMagma
         A1)
      (Ri2 : RightCancellativeMagma
         A2) : Set where
      constructor RightCancellativeMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record RightCancellativeMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellativeMagma
         A1)
      (Ri2 : RightCancellativeMagma
         A2) : Set where
      constructor RightCancellativeMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data RightCancellativeMagmaLang
      : Set where
      opL :
        RightCancellativeMagmaLang ->
        RightCancellativeMagmaLang ->
        RightCancellativeMagmaLang
    data RightCancellativeMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RightCancellativeMagmaOpenLang n
      opOL :
        RightCancellativeMagmaOpenLang
          n ->
        RightCancellativeMagmaOpenLang
          n ->
        RightCancellativeMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      RightCancellativeMagma A ->
      RightCancellativeMagmaLang -> A
    evalTerm _ Ri (opL x1 x2) =
      op Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightCancellativeMagma A ->
      RightCancellativeMagmaOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (opOL
                         x1
                         x2) vars =
      op ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module RightCancellativeOp where
    record RightCancellativeOp
      (A : Set) : Set where
      constructor RightCancellativeOpC
      field
        op : A -> A -> A
        rinv : A -> A -> A
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
    record RightCancellativeOpSig
      (AS : Set) : Set where
      constructor RightCancellativeOpSigSigC
      field
        opS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record RightCancellativeOpProd
      (AP : Set) : Set where
      constructor RightCancellativeOpProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
    record RightCancellativeOpHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellativeOp A1)
      (Ri2 : RightCancellativeOp A2) :
      Set where
      constructor RightCancellativeOpHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Ri1 x1 x2) ==
            rinv Ri2 (hom x1) (hom x2)
    record RightCancellativeOpRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellativeOp A1)
      (Ri2 : RightCancellativeOp A2) :
      Set where
      constructor RightCancellativeOpRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Ri1 x1 x2)
            (rinv Ri2 y1 y2)
    data RightCancellativeOpLang
      : Set where
      opL :
        RightCancellativeOpLang ->
        RightCancellativeOpLang ->
        RightCancellativeOpLang
      rinvL :
        RightCancellativeOpLang ->
        RightCancellativeOpLang ->
        RightCancellativeOpLang
    data RightCancellativeOpOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RightCancellativeOpOpenLang n
      opOL :
        RightCancellativeOpOpenLang n ->
        RightCancellativeOpOpenLang n ->
        RightCancellativeOpOpenLang n
      rinvOL :
        RightCancellativeOpOpenLang n ->
        RightCancellativeOpOpenLang n ->
        RightCancellativeOpOpenLang n
    evalTerm :
      (A : Set) ->
      RightCancellativeOp A ->
      RightCancellativeOpLang -> A
    evalTerm _ Ri (opL x1 x2) =
      op Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (rinvL x1 x2) =
      rinv Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightCancellativeOp A ->
      RightCancellativeOpOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (opOL
                         x1
                         x2) vars =
      op ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (rinvOL
                         x1
                         x2) vars =
      rinv ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module RightCancellativeSemigroup where
    record RightCancellativeSemigroup
      (A : Set) : Set where
      constructor RightCancellativeSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
    record RightCancellativeSemigroupSig
      (AS : Set) : Set where
      constructor RightCancellativeSemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record RightCancellativeSemigroupProd
      (AP : Set) : Set where
      constructor RightCancellativeSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
    record RightCancellativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellativeSemigroup
         A1)
      (Ri2 : RightCancellativeSemigroup
         A2) : Set where
      constructor RightCancellativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record RightCancellativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellativeSemigroup
         A1)
      (Ri2 : RightCancellativeSemigroup
         A2) : Set where
      constructor RightCancellativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data RightCancellativeSemigroupLang
      : Set where
      opL :
        RightCancellativeSemigroupLang ->
        RightCancellativeSemigroupLang ->
        RightCancellativeSemigroupLang
    data RightCancellativeSemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RightCancellativeSemigroupOpenLang
          n
      opOL :
        RightCancellativeSemigroupOpenLang
          n ->
        RightCancellativeSemigroupOpenLang
          n ->
        RightCancellativeSemigroupOpenLang
          n
    evalTerm :
      (A : Set) ->
      RightCancellativeSemigroup A ->
      RightCancellativeSemigroupLang ->
      A
    evalTerm _ Ri (opL x1 x2) =
      op Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightCancellativeSemigroup A ->
      RightCancellativeSemigroupOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (opOL
                         x1
                         x2) vars =
      op ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module RightDistributiveMagma where
    record RightDistributiveMagma
      (A : Set) : Set where
      constructor RightDistributiveMagmaC
      field
        op : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          op (op y z) x ==
            op (op y x) (op z x)
    record RightDistributiveMagmaSig
      (AS : Set) : Set where
      constructor RightDistributiveMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record RightDistributiveMagmaProd
      (AP : Set) : Set where
      constructor RightDistributiveMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP yP zP) xP ==
            opP (opP yP xP) (opP zP xP)
    record RightDistributiveMagmaHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightDistributiveMagma
         A1)
      (Ri2 : RightDistributiveMagma
         A2) : Set where
      constructor RightDistributiveMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record RightDistributiveMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightDistributiveMagma
         A1)
      (Ri2 : RightDistributiveMagma
         A2) : Set where
      constructor RightDistributiveMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data RightDistributiveMagmaLang
      : Set where
      opL :
        RightDistributiveMagmaLang ->
        RightDistributiveMagmaLang ->
        RightDistributiveMagmaLang
    data RightDistributiveMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RightDistributiveMagmaOpenLang n
      opOL :
        RightDistributiveMagmaOpenLang
          n ->
        RightDistributiveMagmaOpenLang
          n ->
        RightDistributiveMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      RightDistributiveMagma A ->
      RightDistributiveMagmaLang -> A
    evalTerm _ Ri (opL x1 x2) =
      op Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightDistributiveMagma A ->
      RightDistributiveMagmaOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (opOL
                         x1
                         x2) vars =
      op ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module RightIdempotence where
    record RightIdempotence
      (A : Set) : Set where
      constructor RightIdempotenceC
      field
        <| : A -> A -> A
        idempotent_<| :
          (x : A) -> <| x x == x
    record RightIdempotenceSig
      (AS : Set) : Set where
      constructor RightIdempotenceSigSigC
      field
        <|S : AS -> AS -> AS
    record RightIdempotenceProd
      (AP : Set) : Set where
      constructor RightIdempotenceProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        idempotent_<|P :
          (xP : Prod AP AP) ->
          <|P xP xP == xP
    record RightIdempotenceHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightIdempotence A1)
      (Ri2 : RightIdempotence A2) :
      Set where
      constructor RightIdempotenceHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
    record RightIdempotenceRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightIdempotence A1)
      (Ri2 : RightIdempotence A2) :
      Set where
      constructor RightIdempotenceRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
    data RightIdempotenceLang
      : Set where
      <|L :
        RightIdempotenceLang ->
        RightIdempotenceLang ->
        RightIdempotenceLang
    data RightIdempotenceOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RightIdempotenceOpenLang n
      <|OL :
        RightIdempotenceOpenLang n ->
        RightIdempotenceOpenLang n ->
        RightIdempotenceOpenLang n
    evalTerm :
      (A : Set) ->
      RightIdempotence A ->
      RightIdempotenceLang -> A
    evalTerm _ Ri (<|L x1 x2) =
      <| Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightIdempotence A ->
      RightIdempotenceOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (<|OL
                         x1
                         x2) vars =
      <| ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module RightInverse where
    record RightInverse
      (A : Set) : Set where
      constructor RightInverseC
      field
        inv : A -> A
        e : A
        op : A -> A -> A
        rightInverse_inv_op_e :
          (x : A) -> op (inv x) x == e
    record RightInverseSig
      (AS : Set) : Set where
      constructor RightInverseSigSigC
      field
        invS : AS -> AS
        eS : AS
        opS : AS -> AS -> AS
    record RightInverseProd
      (AP : Set) : Set where
      constructor RightInverseProdC
      field
        invP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (invP xP) xP == eP
    record RightInverseHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightInverse A1)
      (Ri2 : RightInverse A2) :
      Set where
      constructor RightInverseHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv Ri1 x1) ==
            inv Ri2 (hom x1)
        pres-e : hom (e Ri1) == e Ri2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record RightInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightInverse A1)
      (Ri2 : RightInverse A2) :
      Set where
      constructor RightInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Ri1 x1) (inv Ri2 y1)
        interp-e :
          interp (e Ri1) (e Ri2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data RightInverseLang
      : Set where
      invL :
        RightInverseLang ->
        RightInverseLang
      eL : RightInverseLang
      opL :
        RightInverseLang ->
        RightInverseLang ->
        RightInverseLang
    data RightInverseOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> RightInverseOpenLang n
      invOL :
        RightInverseOpenLang n ->
        RightInverseOpenLang n
      eOL : RightInverseOpenLang n
      opOL :
        RightInverseOpenLang n ->
        RightInverseOpenLang n ->
        RightInverseOpenLang n
    evalTerm :
      (A : Set) ->
      RightInverse A ->
      RightInverseLang -> A
    evalTerm _ Ri (invL x1) =
      inv Ri (evalTerm _ Ri x1)
    evalTerm _ Ri (eL) = e Ri
    evalTerm _ Ri (opL x1 x2) =
      op Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightInverse A ->
      RightInverseOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (invOL
                         x1) vars =
      inv ri
        (evalOpenTerm _ n ri x1 vars)
    evalOpenTerm _ n ri (eOL) vars =
      e ri
    evalOpenTerm _ n ri (opOL
                         x1
                         x2) vars =
      op ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module RightInverseMagma where
    record RightInverseMagma
      (A : Set) : Set where
      constructor RightInverseMagmaC
      field
        rinv : A -> A -> A
    record RightInverseMagmaSig
      (AS : Set) : Set where
      constructor RightInverseMagmaSigSigC
      field
        rinvS : AS -> AS -> AS
    record RightInverseMagmaProd
      (AP : Set) : Set where
      constructor RightInverseMagmaProdC
      field
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record RightInverseMagmaHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightInverseMagma A1)
      (Ri2 : RightInverseMagma A2) :
      Set where
      constructor RightInverseMagmaHomC
      field
        hom : A1 -> A2
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Ri1 x1 x2) ==
            rinv Ri2 (hom x1) (hom x2)
    record RightInverseMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightInverseMagma A1)
      (Ri2 : RightInverseMagma A2) :
      Set where
      constructor RightInverseMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Ri1 x1 x2)
            (rinv Ri2 y1 y2)
    data RightInverseMagmaLang
      : Set where
      rinvL :
        RightInverseMagmaLang ->
        RightInverseMagmaLang ->
        RightInverseMagmaLang
    data RightInverseMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RightInverseMagmaOpenLang n
      rinvOL :
        RightInverseMagmaOpenLang n ->
        RightInverseMagmaOpenLang n ->
        RightInverseMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      RightInverseMagma A ->
      RightInverseMagmaLang -> A
    evalTerm _ Ri (rinvL x1 x2) =
      rinv Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightInverseMagma A ->
      RightInverseMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (rinvOL
                         x1
                         x2) vars =
      rinv ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module RightMonoid where
    record RightMonoid
      (A : Set) : Set where
      constructor RightMonoidC
      field
        op : A -> A -> A
        e : A
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record RightMonoidSig
      (AS : Set) : Set where
      constructor RightMonoidSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record RightMonoidProd
      (AP : Set) : Set where
      constructor RightMonoidProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record RightMonoidHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightMonoid A1)
      (Ri2 : RightMonoid A2) :
      Set where
      constructor RightMonoidHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
        pres-e : hom (e Ri1) == e Ri2
    record RightMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightMonoid A1)
      (Ri2 : RightMonoid A2) :
      Set where
      constructor RightMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
        interp-e :
          interp (e Ri1) (e Ri2)
    data RightMonoidLang : Set where
      opL :
        RightMonoidLang ->
        RightMonoidLang ->
        RightMonoidLang
      eL : RightMonoidLang
    data RightMonoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> RightMonoidOpenLang n
      opOL :
        RightMonoidOpenLang n ->
        RightMonoidOpenLang n ->
        RightMonoidOpenLang n
      eOL : RightMonoidOpenLang n
    evalTerm :
      (A : Set) ->
      RightMonoid A ->
      RightMonoidLang -> A
    evalTerm _ Ri (opL x1 x2) =
      op Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (eL) = e Ri
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightMonoid A ->
      RightMonoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (opOL
                         x1
                         x2) vars =
      op ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (eOL) vars =
      e ri
  
  module RightPreSemiring where
    record RightPreSemiring
      (A : Set) : Set where
      constructor RightPreSemiringC
      field
        * : A -> A -> A
        + : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record RightPreSemiringSig
      (AS : Set) : Set where
      constructor RightPreSemiringSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record RightPreSemiringProd
      (AP : Set) : Set where
      constructor RightPreSemiringProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record RightPreSemiringHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightPreSemiring A1)
      (Ri2 : RightPreSemiring A2) :
      Set where
      constructor RightPreSemiringHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
    record RightPreSemiringRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightPreSemiring A1)
      (Ri2 : RightPreSemiring A2) :
      Set where
      constructor RightPreSemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
    data RightPreSemiringLang
      : Set where
      *L :
        RightPreSemiringLang ->
        RightPreSemiringLang ->
        RightPreSemiringLang
      +L :
        RightPreSemiringLang ->
        RightPreSemiringLang ->
        RightPreSemiringLang
    data RightPreSemiringOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RightPreSemiringOpenLang n
      *OL :
        RightPreSemiringOpenLang n ->
        RightPreSemiringOpenLang n ->
        RightPreSemiringOpenLang n
      +OL :
        RightPreSemiringOpenLang n ->
        RightPreSemiringOpenLang n ->
        RightPreSemiringOpenLang n
    evalTerm :
      (A : Set) ->
      RightPreSemiring A ->
      RightPreSemiringLang -> A
    evalTerm _ Ri (*L x1 x2) =
      * Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (+L x1 x2) =
      + Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightPreSemiring A ->
      RightPreSemiringOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (*OL
                         x1
                         x2) vars =
      * ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (+OL
                         x1
                         x2) vars =
      + ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module RightQuasiGroup where
    record RightQuasiGroup
      (A : Set) : Set where
      constructor RightQuasiGroupC
      field
        op : A -> A -> A
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
    record RightQuasiGroupSig
      (AS : Set) : Set where
      constructor RightQuasiGroupSigSigC
      field
        opS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record RightQuasiGroupProd
      (AP : Set) : Set where
      constructor RightQuasiGroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
    record RightQuasiGroupHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightQuasiGroup A1)
      (Ri2 : RightQuasiGroup A2) :
      Set where
      constructor RightQuasiGroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Ri1 x1 x2) ==
            rinv Ri2 (hom x1) (hom x2)
    record RightQuasiGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightQuasiGroup A1)
      (Ri2 : RightQuasiGroup A2) :
      Set where
      constructor RightQuasiGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Ri1 x1 x2)
            (rinv Ri2 y1 y2)
    data RightQuasiGroupLang
      : Set where
      opL :
        RightQuasiGroupLang ->
        RightQuasiGroupLang ->
        RightQuasiGroupLang
      rinvL :
        RightQuasiGroupLang ->
        RightQuasiGroupLang ->
        RightQuasiGroupLang
    data RightQuasiGroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RightQuasiGroupOpenLang n
      opOL :
        RightQuasiGroupOpenLang n ->
        RightQuasiGroupOpenLang n ->
        RightQuasiGroupOpenLang n
      rinvOL :
        RightQuasiGroupOpenLang n ->
        RightQuasiGroupOpenLang n ->
        RightQuasiGroupOpenLang n
    evalTerm :
      (A : Set) ->
      RightQuasiGroup A ->
      RightQuasiGroupLang -> A
    evalTerm _ Ri (opL x1 x2) =
      op Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (rinvL x1 x2) =
      rinv Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightQuasiGroup A ->
      RightQuasiGroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (opOL
                         x1
                         x2) vars =
      op ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (rinvOL
                         x1
                         x2) vars =
      rinv ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module RightRack where
    record RightRack
      (A : Set) : Set where
      constructor RightRackC
      field
        <| : A -> A -> A
        |> : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
    record RightRackSig
      (AS : Set) : Set where
      constructor RightRackSigSigC
      field
        <|S : AS -> AS -> AS
        |>S : AS -> AS -> AS
    record RightRackProd
      (AP : Set) : Set where
      constructor RightRackProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
    record RightRackHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightRack A1)
      (Ri2 : RightRack A2) : Set where
      constructor RightRackHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ri1 x1 x2) ==
            |> Ri2 (hom x1) (hom x2)
    record RightRackRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightRack A1)
      (Ri2 : RightRack A2) : Set where
      constructor RightRackRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ri1 x1 x2)
            (|> Ri2 y1 y2)
    data RightRackLang : Set where
      <|L :
        RightRackLang ->
        RightRackLang -> RightRackLang
      |>L :
        RightRackLang ->
        RightRackLang -> RightRackLang
    data RightRackOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> RightRackOpenLang n
      <|OL :
        RightRackOpenLang n ->
        RightRackOpenLang n ->
        RightRackOpenLang n
      |>OL :
        RightRackOpenLang n ->
        RightRackOpenLang n ->
        RightRackOpenLang n
    evalTerm :
      (A : Set) ->
      RightRack A ->
      RightRackLang -> A
    evalTerm _ Ri (<|L x1 x2) =
      <| Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (|>L x1 x2) =
      |> Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightRack A ->
      RightRackOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (<|OL
                         x1
                         x2) vars =
      <| ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (|>OL
                         x1
                         x2) vars =
      |> ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module RightRingoid where
    record RightRingoid
      (A : Set) : Set where
      constructor RightRingoidC
      field
        * : A -> A -> A
        + : A -> A -> A
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record RightRingoidSig
      (AS : Set) : Set where
      constructor RightRingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record RightRingoidProd
      (AP : Set) : Set where
      constructor RightRingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record RightRingoidHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightRingoid A1)
      (Ri2 : RightRingoid A2) :
      Set where
      constructor RightRingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
    record RightRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightRingoid A1)
      (Ri2 : RightRingoid A2) :
      Set where
      constructor RightRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
    data RightRingoidLang
      : Set where
      *L :
        RightRingoidLang ->
        RightRingoidLang ->
        RightRingoidLang
      +L :
        RightRingoidLang ->
        RightRingoidLang ->
        RightRingoidLang
    data RightRingoidOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> RightRingoidOpenLang n
      *OL :
        RightRingoidOpenLang n ->
        RightRingoidOpenLang n ->
        RightRingoidOpenLang n
      +OL :
        RightRingoidOpenLang n ->
        RightRingoidOpenLang n ->
        RightRingoidOpenLang n
    evalTerm :
      (A : Set) ->
      RightRingoid A ->
      RightRingoidLang -> A
    evalTerm _ Ri (*L x1 x2) =
      * Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (+L x1 x2) =
      + Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightRingoid A ->
      RightRingoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (*OL
                         x1
                         x2) vars =
      * ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (+OL
                         x1
                         x2) vars =
      + ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module RightSelfInverse where
    record RightSelfInverse
      (A : Set) : Set where
      constructor RightSelfInverseC
      field
        |> : A -> A -> A
        rightSelfInverse_|> :
          (x : A) (y : A) ->
          |> (|> x y) y == x
    record RightSelfInverseSig
      (AS : Set) : Set where
      constructor RightSelfInverseSigSigC
      field
        |>S : AS -> AS -> AS
    record RightSelfInverseProd
      (AP : Set) : Set where
      constructor RightSelfInverseProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightSelfInverse_|>P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          |>P (|>P xP yP) yP == xP
    record RightSelfInverseHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSelfInverse A1)
      (Ri2 : RightSelfInverse A2) :
      Set where
      constructor RightSelfInverseHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ri1 x1 x2) ==
            |> Ri2 (hom x1) (hom x2)
    record RightSelfInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSelfInverse A1)
      (Ri2 : RightSelfInverse A2) :
      Set where
      constructor RightSelfInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ri1 x1 x2)
            (|> Ri2 y1 y2)
    data RightSelfInverseLang
      : Set where
      |>L :
        RightSelfInverseLang ->
        RightSelfInverseLang ->
        RightSelfInverseLang
    data RightSelfInverseOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RightSelfInverseOpenLang n
      |>OL :
        RightSelfInverseOpenLang n ->
        RightSelfInverseOpenLang n ->
        RightSelfInverseOpenLang n
    evalTerm :
      (A : Set) ->
      RightSelfInverse A ->
      RightSelfInverseLang -> A
    evalTerm _ Ri (|>L x1 x2) =
      |> Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightSelfInverse A ->
      RightSelfInverseOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (|>OL
                         x1
                         x2) vars =
      |> ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module RightShelf where
    record RightShelf
      (A : Set) : Set where
      constructor RightShelfC
      field
        <| : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
    record RightShelfSig
      (AS : Set) : Set where
      constructor RightShelfSigSigC
      field
        <|S : AS -> AS -> AS
    record RightShelfProd
      (AP : Set) : Set where
      constructor RightShelfProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
    record RightShelfHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightShelf A1)
      (Ri2 : RightShelf A2) :
      Set where
      constructor RightShelfHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
    record RightShelfRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightShelf A1)
      (Ri2 : RightShelf A2) :
      Set where
      constructor RightShelfRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
    data RightShelfLang : Set where
      <|L :
        RightShelfLang ->
        RightShelfLang -> RightShelfLang
    data RightShelfOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> RightShelfOpenLang n
      <|OL :
        RightShelfOpenLang n ->
        RightShelfOpenLang n ->
        RightShelfOpenLang n
    evalTerm :
      (A : Set) ->
      RightShelf A ->
      RightShelfLang -> A
    evalTerm _ Ri (<|L x1 x2) =
      <| Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightShelf A ->
      RightShelfOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (<|OL
                         x1
                         x2) vars =
      <| ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module RightShelfSig where
    record RightShelfSig
      (A : Set) : Set where
      constructor RightShelfSigC
      field
        <| : A -> A -> A
    record RightShelfSigSig
      (AS : Set) : Set where
      constructor RightShelfSigSigSigC
      field
        <|S : AS -> AS -> AS
    record RightShelfSigProd
      (AP : Set) : Set where
      constructor RightShelfSigProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record RightShelfSigHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightShelfSig A1)
      (Ri2 : RightShelfSig A2) :
      Set where
      constructor RightShelfSigHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
    record RightShelfSigRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightShelfSig A1)
      (Ri2 : RightShelfSig A2) :
      Set where
      constructor RightShelfSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
    data RightShelfSigLang
      : Set where
      <|L :
        RightShelfSigLang ->
        RightShelfSigLang ->
        RightShelfSigLang
    data RightShelfSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> RightShelfSigOpenLang n
      <|OL :
        RightShelfSigOpenLang n ->
        RightShelfSigOpenLang n ->
        RightShelfSigOpenLang n
    evalTerm :
      (A : Set) ->
      RightShelfSig A ->
      RightShelfSigLang -> A
    evalTerm _ Ri (<|L x1 x2) =
      <| Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightShelfSig A ->
      RightShelfSigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (<|OL
                         x1
                         x2) vars =
      <| ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module RightSpindle where
    record RightSpindle
      (A : Set) : Set where
      constructor RightSpindleC
      field
        <| : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
        idempotent_<| :
          (x : A) -> <| x x == x
    record RightSpindleSig
      (AS : Set) : Set where
      constructor RightSpindleSigSigC
      field
        <|S : AS -> AS -> AS
    record RightSpindleProd
      (AP : Set) : Set where
      constructor RightSpindleProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
        idempotent_<|P :
          (xP : Prod AP AP) ->
          <|P xP xP == xP
    record RightSpindleHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSpindle A1)
      (Ri2 : RightSpindle A2) :
      Set where
      constructor RightSpindleHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
    record RightSpindleRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSpindle A1)
      (Ri2 : RightSpindle A2) :
      Set where
      constructor RightSpindleRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
    data RightSpindleLang
      : Set where
      <|L :
        RightSpindleLang ->
        RightSpindleLang ->
        RightSpindleLang
    data RightSpindleOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> RightSpindleOpenLang n
      <|OL :
        RightSpindleOpenLang n ->
        RightSpindleOpenLang n ->
        RightSpindleOpenLang n
    evalTerm :
      (A : Set) ->
      RightSpindle A ->
      RightSpindleLang -> A
    evalTerm _ Ri (<|L x1 x2) =
      <| Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightSpindle A ->
      RightSpindleOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (<|OL
                         x1
                         x2) vars =
      <| ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module RightSpindle_Shelf where
    record RightSpindle_Shelf
      (A : Set) : Set where
      constructor RightSpindle_ShelfC
      field
        <| : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
        idempotent_<| :
          (x : A) -> <| x x == x
        |> : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
    record RightSpindle_ShelfSig
      (AS : Set) : Set where
      constructor RightSpindle_ShelfSigSigC
      field
        <|S : AS -> AS -> AS
        |>S : AS -> AS -> AS
    record RightSpindle_ShelfProd
      (AP : Set) : Set where
      constructor RightSpindle_ShelfProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
        idempotent_<|P :
          (xP : Prod AP AP) ->
          <|P xP xP == xP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
    record RightSpindle_ShelfHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSpindle_Shelf A1)
      (Ri2 : RightSpindle_Shelf A2) :
      Set where
      constructor RightSpindle_ShelfHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ri1 x1 x2) ==
            |> Ri2 (hom x1) (hom x2)
    record RightSpindle_ShelfRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSpindle_Shelf A1)
      (Ri2 : RightSpindle_Shelf A2) :
      Set where
      constructor RightSpindle_ShelfRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ri1 x1 x2)
            (|> Ri2 y1 y2)
    data RightSpindle_ShelfLang
      : Set where
      <|L :
        RightSpindle_ShelfLang ->
        RightSpindle_ShelfLang ->
        RightSpindle_ShelfLang
      |>L :
        RightSpindle_ShelfLang ->
        RightSpindle_ShelfLang ->
        RightSpindle_ShelfLang
    data RightSpindle_ShelfOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RightSpindle_ShelfOpenLang n
      <|OL :
        RightSpindle_ShelfOpenLang n ->
        RightSpindle_ShelfOpenLang n ->
        RightSpindle_ShelfOpenLang n
      |>OL :
        RightSpindle_ShelfOpenLang n ->
        RightSpindle_ShelfOpenLang n ->
        RightSpindle_ShelfOpenLang n
    evalTerm :
      (A : Set) ->
      RightSpindle_Shelf A ->
      RightSpindle_ShelfLang -> A
    evalTerm _ Ri (<|L x1 x2) =
      <| Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (|>L x1 x2) =
      |> Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightSpindle_Shelf A ->
      RightSpindle_ShelfOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (<|OL
                         x1
                         x2) vars =
      <| ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (|>OL
                         x1
                         x2) vars =
      |> ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module RightSpindle_ShelfSig where
    record RightSpindle_ShelfSig
      (A : Set) : Set where
      constructor RightSpindle_ShelfSigC
      field
        <| : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
        idempotent_<| :
          (x : A) -> <| x x == x
        |> : A -> A -> A
    record RightSpindle_ShelfSigSig
      (AS : Set) : Set where
      constructor RightSpindle_ShelfSigSigSigC
      field
        <|S : AS -> AS -> AS
        |>S : AS -> AS -> AS
    record RightSpindle_ShelfSigProd
      (AP : Set) : Set where
      constructor RightSpindle_ShelfSigProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
        idempotent_<|P :
          (xP : Prod AP AP) ->
          <|P xP xP == xP
    record RightSpindle_ShelfSigHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSpindle_ShelfSig A1)
      (Ri2 : RightSpindle_ShelfSig
         A2) : Set where
      constructor RightSpindle_ShelfSigHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ri1 x1 x2) ==
            |> Ri2 (hom x1) (hom x2)
    record RightSpindle_ShelfSigRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSpindle_ShelfSig A1)
      (Ri2 : RightSpindle_ShelfSig
         A2) : Set where
      constructor RightSpindle_ShelfSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ri1 x1 x2)
            (|> Ri2 y1 y2)
    data RightSpindle_ShelfSigLang
      : Set where
      <|L :
        RightSpindle_ShelfSigLang ->
        RightSpindle_ShelfSigLang ->
        RightSpindle_ShelfSigLang
      |>L :
        RightSpindle_ShelfSigLang ->
        RightSpindle_ShelfSigLang ->
        RightSpindle_ShelfSigLang
    data RightSpindle_ShelfSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RightSpindle_ShelfSigOpenLang n
      <|OL :
        RightSpindle_ShelfSigOpenLang
          n ->
        RightSpindle_ShelfSigOpenLang
          n ->
        RightSpindle_ShelfSigOpenLang n
      |>OL :
        RightSpindle_ShelfSigOpenLang
          n ->
        RightSpindle_ShelfSigOpenLang
          n ->
        RightSpindle_ShelfSigOpenLang n
    evalTerm :
      (A : Set) ->
      RightSpindle_ShelfSig A ->
      RightSpindle_ShelfSigLang -> A
    evalTerm _ Ri (<|L x1 x2) =
      <| Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (|>L x1 x2) =
      |> Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightSpindle_ShelfSig A ->
      RightSpindle_ShelfSigOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (<|OL
                         x1
                         x2) vars =
      <| ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (|>OL
                         x1
                         x2) vars =
      |> ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module RightUnital where
    record RightUnital
      (A : Set) : Set where
      constructor RightUnitalC
      field
        e : A
        op : A -> A -> A
        runit_e : (x : A) -> op x e == x
    record RightUnitalSig
      (AS : Set) : Set where
      constructor RightUnitalSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record RightUnitalProd
      (AP : Set) : Set where
      constructor RightUnitalProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
    record RightUnitalHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightUnital A1)
      (Ri2 : RightUnital A2) :
      Set where
      constructor RightUnitalHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Ri1) == e Ri2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record RightUnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightUnital A1)
      (Ri2 : RightUnital A2) :
      Set where
      constructor RightUnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Ri1) (e Ri2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data RightUnitalLang : Set where
      eL : RightUnitalLang
      opL :
        RightUnitalLang ->
        RightUnitalLang ->
        RightUnitalLang
    data RightUnitalOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> RightUnitalOpenLang n
      eOL : RightUnitalOpenLang n
      opOL :
        RightUnitalOpenLang n ->
        RightUnitalOpenLang n ->
        RightUnitalOpenLang n
    evalTerm :
      (A : Set) ->
      RightUnital A ->
      RightUnitalLang -> A
    evalTerm _ Ri (eL) = e Ri
    evalTerm _ Ri (opL x1 x2) =
      op Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightUnital A ->
      RightUnitalOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (eOL) vars =
      e ri
    evalOpenTerm _ n ri (opOL
                         x1
                         x2) vars =
      op ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module RightZero where
    record RightZero
      (A : Set) : Set where
      constructor RightZeroC
      field
        e : A
        op : A -> A -> A
        rightZero_op_e :
          (x : A) -> op x e == e
    record RightZeroSig
      (AS : Set) : Set where
      constructor RightZeroSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record RightZeroProd
      (AP : Set) : Set where
      constructor RightZeroProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightZero_op_eP :
          (xP : Prod AP AP) ->
          opP xP eP == eP
    record RightZeroHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightZero A1)
      (Ri2 : RightZero A2) : Set where
      constructor RightZeroHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Ri1) == e Ri2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record RightZeroRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightZero A1)
      (Ri2 : RightZero A2) : Set where
      constructor RightZeroRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Ri1) (e Ri2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data RightZeroLang : Set where
      eL : RightZeroLang
      opL :
        RightZeroLang ->
        RightZeroLang -> RightZeroLang
    data RightZeroOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> RightZeroOpenLang n
      eOL : RightZeroOpenLang n
      opOL :
        RightZeroOpenLang n ->
        RightZeroOpenLang n ->
        RightZeroOpenLang n
    evalTerm :
      (A : Set) ->
      RightZero A ->
      RightZeroLang -> A
    evalTerm _ Ri (eL) = e Ri
    evalTerm _ Ri (opL x1 x2) =
      op Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RightZero A ->
      RightZeroOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (eOL) vars =
      e ri
    evalOpenTerm _ n ri (opOL
                         x1
                         x2) vars =
      op ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module Ring where
    record Ring
      (A : Set) : Set where
      constructor RingC
      field
        * : A -> A -> A
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
    record RingSig
      (AS : Set) : Set where
      constructor RingSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
        1S : AS
    record RingProd
      (AP : Set) : Set where
      constructor RingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
    record RingHom
      (A1 : Set) (A2 : Set)
      (Ri1 : Ring A1)
      (Ri2 : Ring A2) : Set where
      constructor RingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
        pres-0 : hom (0 Ri1) == 0 Ri2
        pres-neg :
          (x1 : A1) ->
          hom (neg Ri1 x1) ==
            neg Ri2 (hom x1)
        pres-1 : hom (1 Ri1) == 1 Ri2
    record RingRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Ring A1)
      (Ri2 : Ring A2) : Set where
      constructor RingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
        interp-0 :
          interp (0 Ri1) (0 Ri2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Ri1 x1) (neg Ri2 y1)
        interp-1 :
          interp (1 Ri1) (1 Ri2)
    data RingLang : Set where
      *L :
        RingLang -> RingLang -> RingLang
      +L :
        RingLang -> RingLang -> RingLang
      0L : RingLang
      negL : RingLang -> RingLang
      1L : RingLang
    data RingOpenLang
      (n : Nat) : Set where
      v : Fin n -> RingOpenLang n
      *OL :
        RingOpenLang n ->
        RingOpenLang n -> RingOpenLang n
      +OL :
        RingOpenLang n ->
        RingOpenLang n -> RingOpenLang n
      0OL : RingOpenLang n
      negOL :
        RingOpenLang n -> RingOpenLang n
      1OL : RingOpenLang n
    evalTerm :
      (A : Set) ->
      Ring A -> RingLang -> A
    evalTerm _ Ri (*L x1 x2) =
      * Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (+L x1 x2) =
      + Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (0L) = 0 Ri
    evalTerm _ Ri (negL x1) =
      neg Ri (evalTerm _ Ri x1)
    evalTerm _ Ri (1L) = 1 Ri
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Ring A ->
      RingOpenLang n -> Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (*OL
                         x1
                         x2) vars =
      * ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (+OL
                         x1
                         x2) vars =
      + ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (0OL) vars =
      0 ri
    evalOpenTerm _ n ri (negOL
                         x1) vars =
      neg ri
        (evalOpenTerm _ n ri x1 vars)
    evalOpenTerm _ n ri (1OL) vars =
      1 ri
  
  module Ringoid where
    record Ringoid
      (A : Set) : Set where
      constructor RingoidC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record RingoidSig
      (AS : Set) : Set where
      constructor RingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record RingoidProd
      (AP : Set) : Set where
      constructor RingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record RingoidHom
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid A1)
      (Ri2 : Ringoid A2) : Set where
      constructor RingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
    record RingoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid A1)
      (Ri2 : Ringoid A2) : Set where
      constructor RingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
    data RingoidLang : Set where
      *L :
        RingoidLang ->
        RingoidLang -> RingoidLang
      +L :
        RingoidLang ->
        RingoidLang -> RingoidLang
    data RingoidOpenLang
      (n : Nat) : Set where
      v : Fin n -> RingoidOpenLang n
      *OL :
        RingoidOpenLang n ->
        RingoidOpenLang n ->
        RingoidOpenLang n
      +OL :
        RingoidOpenLang n ->
        RingoidOpenLang n ->
        RingoidOpenLang n
    evalTerm :
      (A : Set) ->
      Ringoid A -> RingoidLang -> A
    evalTerm _ Ri (*L x1 x2) =
      * Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (+L x1 x2) =
      + Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Ringoid A ->
      RingoidOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (*OL
                         x1
                         x2) vars =
      * ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (+OL
                         x1
                         x2) vars =
      + ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module Ringoid01Sig where
    record Ringoid01Sig
      (A : Set) : Set where
      constructor Ringoid01SigC
      field
        * : A -> A -> A
        + : A -> A -> A
        0 : A
        1 : A
    record Ringoid01SigSig
      (AS : Set) : Set where
      constructor Ringoid01SigSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        1S : AS
    record Ringoid01SigProd
      (AP : Set) : Set where
      constructor Ringoid01SigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        1P : Prod AP AP
    record Ringoid01SigHom
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid01Sig A1)
      (Ri2 : Ringoid01Sig A2) :
      Set where
      constructor Ringoid01SigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
        pres-0 : hom (0 Ri1) == 0 Ri2
        pres-1 : hom (1 Ri1) == 1 Ri2
    record Ringoid01SigRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid01Sig A1)
      (Ri2 : Ringoid01Sig A2) :
      Set where
      constructor Ringoid01SigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
        interp-0 :
          interp (0 Ri1) (0 Ri2)
        interp-1 :
          interp (1 Ri1) (1 Ri2)
    data Ringoid01SigLang
      : Set where
      *L :
        Ringoid01SigLang ->
        Ringoid01SigLang ->
        Ringoid01SigLang
      +L :
        Ringoid01SigLang ->
        Ringoid01SigLang ->
        Ringoid01SigLang
      0L : Ringoid01SigLang
      1L : Ringoid01SigLang
    data Ringoid01SigOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> Ringoid01SigOpenLang n
      *OL :
        Ringoid01SigOpenLang n ->
        Ringoid01SigOpenLang n ->
        Ringoid01SigOpenLang n
      +OL :
        Ringoid01SigOpenLang n ->
        Ringoid01SigOpenLang n ->
        Ringoid01SigOpenLang n
      0OL : Ringoid01SigOpenLang n
      1OL : Ringoid01SigOpenLang n
    evalTerm :
      (A : Set) ->
      Ringoid01Sig A ->
      Ringoid01SigLang -> A
    evalTerm _ Ri (*L x1 x2) =
      * Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (+L x1 x2) =
      + Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (0L) = 0 Ri
    evalTerm _ Ri (1L) = 1 Ri
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Ringoid01Sig A ->
      Ringoid01SigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (*OL
                         x1
                         x2) vars =
      * ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (+OL
                         x1
                         x2) vars =
      + ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (0OL) vars =
      0 ri
    evalOpenTerm _ n ri (1OL) vars =
      1 ri
  
  module Ringoid0Sig where
    record Ringoid0Sig
      (A : Set) : Set where
      constructor Ringoid0SigC
      field
        0 : A
        + : A -> A -> A
        * : A -> A -> A
    record Ringoid0SigSig
      (AS : Set) : Set where
      constructor Ringoid0SigSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
    record Ringoid0SigProd
      (AP : Set) : Set where
      constructor Ringoid0SigProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record Ringoid0SigHom
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid0Sig A1)
      (Ri2 : Ringoid0Sig A2) :
      Set where
      constructor Ringoid0SigHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ri1) == 0 Ri2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
    record Ringoid0SigRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid0Sig A1)
      (Ri2 : Ringoid0Sig A2) :
      Set where
      constructor Ringoid0SigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ri1) (0 Ri2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
    data Ringoid0SigLang : Set where
      0L : Ringoid0SigLang
      +L :
        Ringoid0SigLang ->
        Ringoid0SigLang ->
        Ringoid0SigLang
      *L :
        Ringoid0SigLang ->
        Ringoid0SigLang ->
        Ringoid0SigLang
    data Ringoid0SigOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> Ringoid0SigOpenLang n
      0OL : Ringoid0SigOpenLang n
      +OL :
        Ringoid0SigOpenLang n ->
        Ringoid0SigOpenLang n ->
        Ringoid0SigOpenLang n
      *OL :
        Ringoid0SigOpenLang n ->
        Ringoid0SigOpenLang n ->
        Ringoid0SigOpenLang n
    evalTerm :
      (A : Set) ->
      Ringoid0Sig A ->
      Ringoid0SigLang -> A
    evalTerm _ Ri (0L) = 0 Ri
    evalTerm _ Ri (+L x1 x2) =
      + Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (*L x1 x2) =
      * Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Ringoid0Sig A ->
      Ringoid0SigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (0OL) vars =
      0 ri
    evalOpenTerm _ n ri (+OL
                         x1
                         x2) vars =
      + ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (*OL
                         x1
                         x2) vars =
      * ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module Ringoid1 where
    record Ringoid1
      (A : Set) : Set where
      constructor Ringoid1C
      field
        * : A -> A -> A
        + : A -> A -> A
        1 : A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record Ringoid1Sig
      (AS : Set) : Set where
      constructor Ringoid1SigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        1S : AS
    record Ringoid1Prod
      (AP : Set) : Set where
      constructor Ringoid1ProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record Ringoid1Hom
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid1 A1)
      (Ri2 : Ringoid1 A2) : Set where
      constructor Ringoid1HomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
        pres-1 : hom (1 Ri1) == 1 Ri2
    record Ringoid1RelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid1 A1)
      (Ri2 : Ringoid1 A2) : Set where
      constructor Ringoid1RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
        interp-1 :
          interp (1 Ri1) (1 Ri2)
    data Ringoid1Lang : Set where
      *L :
        Ringoid1Lang ->
        Ringoid1Lang -> Ringoid1Lang
      +L :
        Ringoid1Lang ->
        Ringoid1Lang -> Ringoid1Lang
      1L : Ringoid1Lang
    data Ringoid1OpenLang
      (n : Nat) : Set where
      v :
        Fin n -> Ringoid1OpenLang n
      *OL :
        Ringoid1OpenLang n ->
        Ringoid1OpenLang n ->
        Ringoid1OpenLang n
      +OL :
        Ringoid1OpenLang n ->
        Ringoid1OpenLang n ->
        Ringoid1OpenLang n
      1OL : Ringoid1OpenLang n
    evalTerm :
      (A : Set) ->
      Ringoid1 A -> Ringoid1Lang -> A
    evalTerm _ Ri (*L x1 x2) =
      * Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (+L x1 x2) =
      + Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (1L) = 1 Ri
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Ringoid1 A ->
      Ringoid1OpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (*OL
                         x1
                         x2) vars =
      * ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (+OL
                         x1
                         x2) vars =
      + ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (1OL) vars =
      1 ri
  
  module Ringoid1Sig where
    record Ringoid1Sig
      (A : Set) : Set where
      constructor Ringoid1SigC
      field
        * : A -> A -> A
        1 : A
        + : A -> A -> A
    record Ringoid1SigSig
      (AS : Set) : Set where
      constructor Ringoid1SigSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
        +S : AS -> AS -> AS
    record Ringoid1SigProd
      (AP : Set) : Set where
      constructor Ringoid1SigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record Ringoid1SigHom
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid1Sig A1)
      (Ri2 : Ringoid1Sig A2) :
      Set where
      constructor Ringoid1SigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-1 : hom (1 Ri1) == 1 Ri2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
    record Ringoid1SigRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid1Sig A1)
      (Ri2 : Ringoid1Sig A2) :
      Set where
      constructor Ringoid1SigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-1 :
          interp (1 Ri1) (1 Ri2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
    data Ringoid1SigLang : Set where
      *L :
        Ringoid1SigLang ->
        Ringoid1SigLang ->
        Ringoid1SigLang
      1L : Ringoid1SigLang
      +L :
        Ringoid1SigLang ->
        Ringoid1SigLang ->
        Ringoid1SigLang
    data Ringoid1SigOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> Ringoid1SigOpenLang n
      *OL :
        Ringoid1SigOpenLang n ->
        Ringoid1SigOpenLang n ->
        Ringoid1SigOpenLang n
      1OL : Ringoid1SigOpenLang n
      +OL :
        Ringoid1SigOpenLang n ->
        Ringoid1SigOpenLang n ->
        Ringoid1SigOpenLang n
    evalTerm :
      (A : Set) ->
      Ringoid1Sig A ->
      Ringoid1SigLang -> A
    evalTerm _ Ri (*L x1 x2) =
      * Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (1L) = 1 Ri
    evalTerm _ Ri (+L x1 x2) =
      + Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Ringoid1Sig A ->
      Ringoid1SigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (*OL
                         x1
                         x2) vars =
      * ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (1OL) vars =
      1 ri
    evalOpenTerm _ n ri (+OL
                         x1
                         x2) vars =
      + ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module RingoidSig where
    record RingoidSig
      (A : Set) : Set where
      constructor RingoidSigC
      field
        * : A -> A -> A
        + : A -> A -> A
    record RingoidSigSig
      (AS : Set) : Set where
      constructor RingoidSigSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record RingoidSigProd
      (AP : Set) : Set where
      constructor RingoidSigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record RingoidSigHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidSig A1)
      (Ri2 : RingoidSig A2) :
      Set where
      constructor RingoidSigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
    record RingoidSigRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidSig A1)
      (Ri2 : RingoidSig A2) :
      Set where
      constructor RingoidSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
    data RingoidSigLang : Set where
      *L :
        RingoidSigLang ->
        RingoidSigLang -> RingoidSigLang
      +L :
        RingoidSigLang ->
        RingoidSigLang -> RingoidSigLang
    data RingoidSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> RingoidSigOpenLang n
      *OL :
        RingoidSigOpenLang n ->
        RingoidSigOpenLang n ->
        RingoidSigOpenLang n
      +OL :
        RingoidSigOpenLang n ->
        RingoidSigOpenLang n ->
        RingoidSigOpenLang n
    evalTerm :
      (A : Set) ->
      RingoidSig A ->
      RingoidSigLang -> A
    evalTerm _ Ri (*L x1 x2) =
      * Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (+L x1 x2) =
      + Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RingoidSig A ->
      RingoidSigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (*OL
                         x1
                         x2) vars =
      * ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (+OL
                         x1
                         x2) vars =
      + ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module RingoidWithAddAntiDistrib where
    record RingoidWithAddAntiDistrib
      (A : Set) : Set where
      constructor RingoidWithAddAntiDistribC
      field
        + : A -> A -> A
        prim : A -> A
        antidis_prim_+ :
          (x : A) (y : A) ->
          prim (+ x y) ==
            + (prim y) (prim x)
        * : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record RingoidWithAddAntiDistribSig
      (AS : Set) : Set where
      constructor RingoidWithAddAntiDistribSigSigC
      field
        +S : AS -> AS -> AS
        primS : AS -> AS
        *S : AS -> AS -> AS
    record RingoidWithAddAntiDistribProd
      (AP : Set) : Set where
      constructor RingoidWithAddAntiDistribProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        antidis_prim_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (+P xP yP) ==
            +P (primP yP) (primP xP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record RingoidWithAddAntiDistribHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidWithAddAntiDistrib
         A1)
      (Ri2 : RingoidWithAddAntiDistrib
         A2) : Set where
      constructor RingoidWithAddAntiDistribHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Ri1 x1) ==
            prim Ri2 (hom x1)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
    record RingoidWithAddAntiDistribRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidWithAddAntiDistrib
         A1)
      (Ri2 : RingoidWithAddAntiDistrib
         A2) : Set where
      constructor RingoidWithAddAntiDistribRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Ri1 x1)
            (prim Ri2 y1)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
    data RingoidWithAddAntiDistribLang
      : Set where
      +L :
        RingoidWithAddAntiDistribLang ->
        RingoidWithAddAntiDistribLang ->
        RingoidWithAddAntiDistribLang
      primL :
        RingoidWithAddAntiDistribLang ->
        RingoidWithAddAntiDistribLang
      *L :
        RingoidWithAddAntiDistribLang ->
        RingoidWithAddAntiDistribLang ->
        RingoidWithAddAntiDistribLang
    data RingoidWithAddAntiDistribOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RingoidWithAddAntiDistribOpenLang
          n
      +OL :
        RingoidWithAddAntiDistribOpenLang
          n ->
        RingoidWithAddAntiDistribOpenLang
          n ->
        RingoidWithAddAntiDistribOpenLang
          n
      primOL :
        RingoidWithAddAntiDistribOpenLang
          n ->
        RingoidWithAddAntiDistribOpenLang
          n
      *OL :
        RingoidWithAddAntiDistribOpenLang
          n ->
        RingoidWithAddAntiDistribOpenLang
          n ->
        RingoidWithAddAntiDistribOpenLang
          n
    evalTerm :
      (A : Set) ->
      RingoidWithAddAntiDistrib A ->
      RingoidWithAddAntiDistribLang ->
      A
    evalTerm _ Ri (+L x1 x2) =
      + Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (primL x1) =
      prim Ri (evalTerm _ Ri x1)
    evalTerm _ Ri (*L x1 x2) =
      * Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RingoidWithAddAntiDistrib A ->
      RingoidWithAddAntiDistribOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (+OL
                         x1
                         x2) vars =
      + ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (primOL
                         x1) vars =
      prim ri
        (evalOpenTerm _ n ri x1 vars)
    evalOpenTerm _ n ri (*OL
                         x1
                         x2) vars =
      * ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module RingoidWithInvolution where
    record RingoidWithInvolution
      (A : Set) : Set where
      constructor RingoidWithInvolutionC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        prim : A -> A
    record RingoidWithInvolutionSig
      (AS : Set) : Set where
      constructor RingoidWithInvolutionSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        primS : AS -> AS
    record RingoidWithInvolutionProd
      (AP : Set) : Set where
      constructor RingoidWithInvolutionProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record RingoidWithInvolutionHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidWithInvolution A1)
      (Ri2 : RingoidWithInvolution
         A2) : Set where
      constructor RingoidWithInvolutionHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Ri1 x1) ==
            prim Ri2 (hom x1)
    record RingoidWithInvolutionRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidWithInvolution A1)
      (Ri2 : RingoidWithInvolution
         A2) : Set where
      constructor RingoidWithInvolutionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Ri1 x1)
            (prim Ri2 y1)
    data RingoidWithInvolutionLang
      : Set where
      *L :
        RingoidWithInvolutionLang ->
        RingoidWithInvolutionLang ->
        RingoidWithInvolutionLang
      +L :
        RingoidWithInvolutionLang ->
        RingoidWithInvolutionLang ->
        RingoidWithInvolutionLang
      primL :
        RingoidWithInvolutionLang ->
        RingoidWithInvolutionLang
    data RingoidWithInvolutionOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RingoidWithInvolutionOpenLang n
      *OL :
        RingoidWithInvolutionOpenLang
          n ->
        RingoidWithInvolutionOpenLang
          n ->
        RingoidWithInvolutionOpenLang n
      +OL :
        RingoidWithInvolutionOpenLang
          n ->
        RingoidWithInvolutionOpenLang
          n ->
        RingoidWithInvolutionOpenLang n
      primOL :
        RingoidWithInvolutionOpenLang
          n ->
        RingoidWithInvolutionOpenLang n
    evalTerm :
      (A : Set) ->
      RingoidWithInvolution A ->
      RingoidWithInvolutionLang -> A
    evalTerm _ Ri (*L x1 x2) =
      * Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (+L x1 x2) =
      + Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (primL x1) =
      prim Ri (evalTerm _ Ri x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RingoidWithInvolution A ->
      RingoidWithInvolutionOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (*OL
                         x1
                         x2) vars =
      * ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (+OL
                         x1
                         x2) vars =
      + ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (primOL
                         x1) vars =
      prim ri
        (evalOpenTerm _ n ri x1 vars)
  
  module RingoidWithMultAntiDistrib where
    record RingoidWithMultAntiDistrib
      (A : Set) : Set where
      constructor RingoidWithMultAntiDistribC
      field
        * : A -> A -> A
        prim : A -> A
        antidis_prim_* :
          (x : A) (y : A) ->
          prim (* x y) ==
            * (prim y) (prim x)
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record RingoidWithMultAntiDistribSig
      (AS : Set) : Set where
      constructor RingoidWithMultAntiDistribSigSigC
      field
        *S : AS -> AS -> AS
        primS : AS -> AS
        +S : AS -> AS -> AS
    record RingoidWithMultAntiDistribProd
      (AP : Set) : Set where
      constructor RingoidWithMultAntiDistribProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        antidis_prim_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (*P xP yP) ==
            *P (primP yP) (primP xP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record RingoidWithMultAntiDistribHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidWithMultAntiDistrib
         A1)
      (Ri2 : RingoidWithMultAntiDistrib
         A2) : Set where
      constructor RingoidWithMultAntiDistribHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Ri1 x1) ==
            prim Ri2 (hom x1)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
    record RingoidWithMultAntiDistribRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidWithMultAntiDistrib
         A1)
      (Ri2 : RingoidWithMultAntiDistrib
         A2) : Set where
      constructor RingoidWithMultAntiDistribRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Ri1 x1)
            (prim Ri2 y1)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
    data RingoidWithMultAntiDistribLang
      : Set where
      *L :
        RingoidWithMultAntiDistribLang ->
        RingoidWithMultAntiDistribLang ->
        RingoidWithMultAntiDistribLang
      primL :
        RingoidWithMultAntiDistribLang ->
        RingoidWithMultAntiDistribLang
      +L :
        RingoidWithMultAntiDistribLang ->
        RingoidWithMultAntiDistribLang ->
        RingoidWithMultAntiDistribLang
    data RingoidWithMultAntiDistribOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        RingoidWithMultAntiDistribOpenLang
          n
      *OL :
        RingoidWithMultAntiDistribOpenLang
          n ->
        RingoidWithMultAntiDistribOpenLang
          n ->
        RingoidWithMultAntiDistribOpenLang
          n
      primOL :
        RingoidWithMultAntiDistribOpenLang
          n ->
        RingoidWithMultAntiDistribOpenLang
          n
      +OL :
        RingoidWithMultAntiDistribOpenLang
          n ->
        RingoidWithMultAntiDistribOpenLang
          n ->
        RingoidWithMultAntiDistribOpenLang
          n
    evalTerm :
      (A : Set) ->
      RingoidWithMultAntiDistrib A ->
      RingoidWithMultAntiDistribLang ->
      A
    evalTerm _ Ri (*L x1 x2) =
      * Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalTerm _ Ri (primL x1) =
      prim Ri (evalTerm _ Ri x1)
    evalTerm _ Ri (+L x1 x2) =
      + Ri (evalTerm _ Ri x1)
        (evalTerm _ Ri x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      RingoidWithMultAntiDistrib A ->
      RingoidWithMultAntiDistribOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n ri (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ri (*OL
                         x1
                         x2) vars =
      * ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
    evalOpenTerm _ n ri (primOL
                         x1) vars =
      prim ri
        (evalOpenTerm _ n ri x1 vars)
    evalOpenTerm _ n ri (+OL
                         x1
                         x2) vars =
      + ri
        (evalOpenTerm _ n ri x1 vars)
        (evalOpenTerm _ n ri x2 vars)
  
  module Rng where
    record Rng (A : Set) : Set where
      constructor RngC
      field
        0 : A
        + : A -> A -> A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record RngSig
      (AS : Set) : Set where
      constructor RngSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        negS : AS -> AS
        *S : AS -> AS -> AS
    record RngProd
      (AP : Set) : Set where
      constructor RngProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record RngHom
      (A1 : Set) (A2 : Set)
      (Rn1 : Rng A1)
      (Rn2 : Rng A2) : Set where
      constructor RngHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Rn1) == 0 Rn2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Rn1 x1 x2) ==
            + Rn2 (hom x1) (hom x2)
        pres-neg :
          (x1 : A1) ->
          hom (neg Rn1 x1) ==
            neg Rn2 (hom x1)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Rn1 x1 x2) ==
            * Rn2 (hom x1) (hom x2)
    record RngRelInterp
      (A1 : Set) (A2 : Set)
      (Rn1 : Rng A1)
      (Rn2 : Rng A2) : Set where
      constructor RngRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Rn1) (0 Rn2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Rn1 x1 x2)
            (+ Rn2 y1 y2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Rn1 x1) (neg Rn2 y1)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Rn1 x1 x2)
            (* Rn2 y1 y2)
    data RngLang : Set where
      0L : RngLang
      +L :
        RngLang -> RngLang -> RngLang
      negL : RngLang -> RngLang
      *L :
        RngLang -> RngLang -> RngLang
    data RngOpenLang
      (n : Nat) : Set where
      v : Fin n -> RngOpenLang n
      0OL : RngOpenLang n
      +OL :
        RngOpenLang n ->
        RngOpenLang n -> RngOpenLang n
      negOL :
        RngOpenLang n -> RngOpenLang n
      *OL :
        RngOpenLang n ->
        RngOpenLang n -> RngOpenLang n
    evalTerm :
      (A : Set) ->
      Rng A -> RngLang -> A
    evalTerm _ Rn (0L) = 0 Rn
    evalTerm _ Rn (+L x1 x2) =
      + Rn (evalTerm _ Rn x1)
        (evalTerm _ Rn x2)
    evalTerm _ Rn (negL x1) =
      neg Rn (evalTerm _ Rn x1)
    evalTerm _ Rn (*L x1 x2) =
      * Rn (evalTerm _ Rn x1)
        (evalTerm _ Rn x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Rng A ->
      RngOpenLang n -> Vec A n -> A
    evalOpenTerm _ n rn (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n rn (0OL) vars =
      0 rn
    evalOpenTerm _ n rn (+OL
                         x1
                         x2) vars =
      + rn
        (evalOpenTerm _ n rn x1 vars)
        (evalOpenTerm _ n rn x2 vars)
    evalOpenTerm _ n rn (negOL
                         x1) vars =
      neg rn
        (evalOpenTerm _ n rn x1 vars)
    evalOpenTerm _ n rn (*OL
                         x1
                         x2) vars =
      * rn
        (evalOpenTerm _ n rn x1 vars)
        (evalOpenTerm _ n rn x2 vars)
  
  module SemiRng where
    record SemiRng
      (A : Set) : Set where
      constructor SemiRngC
      field
        * : A -> A -> A
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record SemiRngSig
      (AS : Set) : Set where
      constructor SemiRngSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
    record SemiRngProd
      (AP : Set) : Set where
      constructor SemiRngProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record SemiRngHom
      (A1 : Set) (A2 : Set)
      (Se1 : SemiRng A1)
      (Se2 : SemiRng A2) : Set where
      constructor SemiRngHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Se1 x1 x2) ==
            * Se2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Se1 x1 x2) ==
            + Se2 (hom x1) (hom x2)
        pres-0 : hom (0 Se1) == 0 Se2
    record SemiRngRelInterp
      (A1 : Set) (A2 : Set)
      (Se1 : SemiRng A1)
      (Se2 : SemiRng A2) : Set where
      constructor SemiRngRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Se1 x1 x2)
            (* Se2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Se1 x1 x2)
            (+ Se2 y1 y2)
        interp-0 :
          interp (0 Se1) (0 Se2)
    data SemiRngLang : Set where
      *L :
        SemiRngLang ->
        SemiRngLang -> SemiRngLang
      +L :
        SemiRngLang ->
        SemiRngLang -> SemiRngLang
      0L : SemiRngLang
    data SemiRngOpenLang
      (n : Nat) : Set where
      v : Fin n -> SemiRngOpenLang n
      *OL :
        SemiRngOpenLang n ->
        SemiRngOpenLang n ->
        SemiRngOpenLang n
      +OL :
        SemiRngOpenLang n ->
        SemiRngOpenLang n ->
        SemiRngOpenLang n
      0OL : SemiRngOpenLang n
    evalTerm :
      (A : Set) ->
      SemiRng A -> SemiRngLang -> A
    evalTerm _ Se (*L x1 x2) =
      * Se (evalTerm _ Se x1)
        (evalTerm _ Se x2)
    evalTerm _ Se (+L x1 x2) =
      + Se (evalTerm _ Se x1)
        (evalTerm _ Se x2)
    evalTerm _ Se (0L) = 0 Se
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      SemiRng A ->
      SemiRngOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n se (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n se (*OL
                         x1
                         x2) vars =
      * se
        (evalOpenTerm _ n se x1 vars)
        (evalOpenTerm _ n se x2 vars)
    evalOpenTerm _ n se (+OL
                         x1
                         x2) vars =
      + se
        (evalOpenTerm _ n se x1 vars)
        (evalOpenTerm _ n se x2 vars)
    evalOpenTerm _ n se (0OL) vars =
      0 se
  
  module SemiRngWithUnit where
    record SemiRngWithUnit
      (A : Set) : Set where
      constructor SemiRngWithUnitC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record SemiRngWithUnitSig
      (AS : Set) : Set where
      constructor SemiRngWithUnitSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
        +S : AS -> AS -> AS
        0S : AS
    record SemiRngWithUnitProd
      (AP : Set) : Set where
      constructor SemiRngWithUnitProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record SemiRngWithUnitHom
      (A1 : Set) (A2 : Set)
      (Se1 : SemiRngWithUnit A1)
      (Se2 : SemiRngWithUnit A2) :
      Set where
      constructor SemiRngWithUnitHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Se1 x1 x2) ==
            * Se2 (hom x1) (hom x2)
        pres-1 : hom (1 Se1) == 1 Se2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Se1 x1 x2) ==
            + Se2 (hom x1) (hom x2)
        pres-0 : hom (0 Se1) == 0 Se2
    record SemiRngWithUnitRelInterp
      (A1 : Set) (A2 : Set)
      (Se1 : SemiRngWithUnit A1)
      (Se2 : SemiRngWithUnit A2) :
      Set where
      constructor SemiRngWithUnitRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Se1 x1 x2)
            (* Se2 y1 y2)
        interp-1 :
          interp (1 Se1) (1 Se2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Se1 x1 x2)
            (+ Se2 y1 y2)
        interp-0 :
          interp (0 Se1) (0 Se2)
    data SemiRngWithUnitLang
      : Set where
      *L :
        SemiRngWithUnitLang ->
        SemiRngWithUnitLang ->
        SemiRngWithUnitLang
      1L : SemiRngWithUnitLang
      +L :
        SemiRngWithUnitLang ->
        SemiRngWithUnitLang ->
        SemiRngWithUnitLang
      0L : SemiRngWithUnitLang
    data SemiRngWithUnitOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        SemiRngWithUnitOpenLang n
      *OL :
        SemiRngWithUnitOpenLang n ->
        SemiRngWithUnitOpenLang n ->
        SemiRngWithUnitOpenLang n
      1OL : SemiRngWithUnitOpenLang n
      +OL :
        SemiRngWithUnitOpenLang n ->
        SemiRngWithUnitOpenLang n ->
        SemiRngWithUnitOpenLang n
      0OL : SemiRngWithUnitOpenLang n
    evalTerm :
      (A : Set) ->
      SemiRngWithUnit A ->
      SemiRngWithUnitLang -> A
    evalTerm _ Se (*L x1 x2) =
      * Se (evalTerm _ Se x1)
        (evalTerm _ Se x2)
    evalTerm _ Se (1L) = 1 Se
    evalTerm _ Se (+L x1 x2) =
      + Se (evalTerm _ Se x1)
        (evalTerm _ Se x2)
    evalTerm _ Se (0L) = 0 Se
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      SemiRngWithUnit A ->
      SemiRngWithUnitOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n se (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n se (*OL
                         x1
                         x2) vars =
      * se
        (evalOpenTerm _ n se x1 vars)
        (evalOpenTerm _ n se x2 vars)
    evalOpenTerm _ n se (1OL) vars =
      1 se
    evalOpenTerm _ n se (+OL
                         x1
                         x2) vars =
      + se
        (evalOpenTerm _ n se x1 vars)
        (evalOpenTerm _ n se x2 vars)
    evalOpenTerm _ n se (0OL) vars =
      0 se
  
  module Semigroup where
    record Semigroup
      (A : Set) : Set where
      constructor SemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record SemigroupSig
      (AS : Set) : Set where
      constructor SemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record SemigroupProd
      (AP : Set) : Set where
      constructor SemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record SemigroupHom
      (A1 : Set) (A2 : Set)
      (Se1 : Semigroup A1)
      (Se2 : Semigroup A2) : Set where
      constructor SemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Se1 x1 x2) ==
            op Se2 (hom x1) (hom x2)
    record SemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Se1 : Semigroup A1)
      (Se2 : Semigroup A2) : Set where
      constructor SemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Se1 x1 x2)
            (op Se2 y1 y2)
    data SemigroupLang : Set where
      opL :
        SemigroupLang ->
        SemigroupLang -> SemigroupLang
    data SemigroupOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> SemigroupOpenLang n
      opOL :
        SemigroupOpenLang n ->
        SemigroupOpenLang n ->
        SemigroupOpenLang n
    evalTerm :
      (A : Set) ->
      Semigroup A ->
      SemigroupLang -> A
    evalTerm _ Se (opL x1 x2) =
      op Se (evalTerm _ Se x1)
        (evalTerm _ Se x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Semigroup A ->
      SemigroupOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n se (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n se (opOL
                         x1
                         x2) vars =
      op se
        (evalOpenTerm _ n se x1 vars)
        (evalOpenTerm _ n se x2 vars)
  
  module Semiring where
    record Semiring
      (A : Set) : Set where
      constructor SemiringC
      field
        0 : A
        + : A -> A -> A
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
    record SemiringSig
      (AS : Set) : Set where
      constructor SemiringSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
        1S : AS
    record SemiringProd
      (AP : Set) : Set where
      constructor SemiringProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
    record SemiringHom
      (A1 : Set) (A2 : Set)
      (Se1 : Semiring A1)
      (Se2 : Semiring A2) : Set where
      constructor SemiringHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Se1) == 0 Se2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Se1 x1 x2) ==
            + Se2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Se1 x1 x2) ==
            * Se2 (hom x1) (hom x2)
        pres-1 : hom (1 Se1) == 1 Se2
    record SemiringRelInterp
      (A1 : Set) (A2 : Set)
      (Se1 : Semiring A1)
      (Se2 : Semiring A2) : Set where
      constructor SemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Se1) (0 Se2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Se1 x1 x2)
            (+ Se2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Se1 x1 x2)
            (* Se2 y1 y2)
        interp-1 :
          interp (1 Se1) (1 Se2)
    data SemiringLang : Set where
      0L : SemiringLang
      +L :
        SemiringLang ->
        SemiringLang -> SemiringLang
      *L :
        SemiringLang ->
        SemiringLang -> SemiringLang
      1L : SemiringLang
    data SemiringOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> SemiringOpenLang n
      0OL : SemiringOpenLang n
      +OL :
        SemiringOpenLang n ->
        SemiringOpenLang n ->
        SemiringOpenLang n
      *OL :
        SemiringOpenLang n ->
        SemiringOpenLang n ->
        SemiringOpenLang n
      1OL : SemiringOpenLang n
    evalTerm :
      (A : Set) ->
      Semiring A -> SemiringLang -> A
    evalTerm _ Se (0L) = 0 Se
    evalTerm _ Se (+L x1 x2) =
      + Se (evalTerm _ Se x1)
        (evalTerm _ Se x2)
    evalTerm _ Se (*L x1 x2) =
      * Se (evalTerm _ Se x1)
        (evalTerm _ Se x2)
    evalTerm _ Se (1L) = 1 Se
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Semiring A ->
      SemiringOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n se (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n se (0OL) vars =
      0 se
    evalOpenTerm _ n se (+OL
                         x1
                         x2) vars =
      + se
        (evalOpenTerm _ n se x1 vars)
        (evalOpenTerm _ n se x2 vars)
    evalOpenTerm _ n se (*OL
                         x1
                         x2) vars =
      * se
        (evalOpenTerm _ n se x1 vars)
        (evalOpenTerm _ n se x2 vars)
    evalOpenTerm _ n se (1OL) vars =
      1 se
  
  module Shelf where
    record Shelf
      (A : Set) : Set where
      constructor ShelfC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
    record ShelfSig
      (AS : Set) : Set where
      constructor ShelfSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record ShelfProd
      (AP : Set) : Set where
      constructor ShelfProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
    record ShelfHom
      (A1 : Set) (A2 : Set)
      (Sh1 : Shelf A1)
      (Sh2 : Shelf A2) : Set where
      constructor ShelfHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Sh1 x1 x2) ==
            |> Sh2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Sh1 x1 x2) ==
            <| Sh2 (hom x1) (hom x2)
    record ShelfRelInterp
      (A1 : Set) (A2 : Set)
      (Sh1 : Shelf A1)
      (Sh2 : Shelf A2) : Set where
      constructor ShelfRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Sh1 x1 x2)
            (|> Sh2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Sh1 x1 x2)
            (<| Sh2 y1 y2)
    data ShelfLang : Set where
      |>L :
        ShelfLang ->
        ShelfLang -> ShelfLang
      <|L :
        ShelfLang ->
        ShelfLang -> ShelfLang
    data ShelfOpenLang
      (n : Nat) : Set where
      v : Fin n -> ShelfOpenLang n
      |>OL :
        ShelfOpenLang n ->
        ShelfOpenLang n ->
        ShelfOpenLang n
      <|OL :
        ShelfOpenLang n ->
        ShelfOpenLang n ->
        ShelfOpenLang n
    evalTerm :
      (A : Set) ->
      Shelf A -> ShelfLang -> A
    evalTerm _ Sh (|>L x1 x2) =
      |> Sh (evalTerm _ Sh x1)
        (evalTerm _ Sh x2)
    evalTerm _ Sh (<|L x1 x2) =
      <| Sh (evalTerm _ Sh x1)
        (evalTerm _ Sh x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Shelf A ->
      ShelfOpenLang n -> Vec A n -> A
    evalOpenTerm _ n sh (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n sh (|>OL
                         x1
                         x2) vars =
      |> sh
        (evalOpenTerm _ n sh x1 vars)
        (evalOpenTerm _ n sh x2 vars)
    evalOpenTerm _ n sh (<|OL
                         x1
                         x2) vars =
      <| sh
        (evalOpenTerm _ n sh x1 vars)
        (evalOpenTerm _ n sh x2 vars)
  
  module ShelfSig where
    record ShelfSig
      (A : Set) : Set where
      constructor ShelfSigC
      field
        |> : A -> A -> A
        <| : A -> A -> A
    record ShelfSigSig
      (AS : Set) : Set where
      constructor ShelfSigSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record ShelfSigProd
      (AP : Set) : Set where
      constructor ShelfSigProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record ShelfSigHom
      (A1 : Set) (A2 : Set)
      (Sh1 : ShelfSig A1)
      (Sh2 : ShelfSig A2) : Set where
      constructor ShelfSigHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Sh1 x1 x2) ==
            |> Sh2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Sh1 x1 x2) ==
            <| Sh2 (hom x1) (hom x2)
    record ShelfSigRelInterp
      (A1 : Set) (A2 : Set)
      (Sh1 : ShelfSig A1)
      (Sh2 : ShelfSig A2) : Set where
      constructor ShelfSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Sh1 x1 x2)
            (|> Sh2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Sh1 x1 x2)
            (<| Sh2 y1 y2)
    data ShelfSigLang : Set where
      |>L :
        ShelfSigLang ->
        ShelfSigLang -> ShelfSigLang
      <|L :
        ShelfSigLang ->
        ShelfSigLang -> ShelfSigLang
    data ShelfSigOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> ShelfSigOpenLang n
      |>OL :
        ShelfSigOpenLang n ->
        ShelfSigOpenLang n ->
        ShelfSigOpenLang n
      <|OL :
        ShelfSigOpenLang n ->
        ShelfSigOpenLang n ->
        ShelfSigOpenLang n
    evalTerm :
      (A : Set) ->
      ShelfSig A -> ShelfSigLang -> A
    evalTerm _ Sh (|>L x1 x2) =
      |> Sh (evalTerm _ Sh x1)
        (evalTerm _ Sh x2)
    evalTerm _ Sh (<|L x1 x2) =
      <| Sh (evalTerm _ Sh x1)
        (evalTerm _ Sh x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      ShelfSig A ->
      ShelfSigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n sh (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n sh (|>OL
                         x1
                         x2) vars =
      |> sh
        (evalOpenTerm _ n sh x1 vars)
        (evalOpenTerm _ n sh x2 vars)
    evalOpenTerm _ n sh (<|OL
                         x1
                         x2) vars =
      <| sh
        (evalOpenTerm _ n sh x1 vars)
        (evalOpenTerm _ n sh x2 vars)
  
  module Sloop where
    record Sloop
      (A : Set) : Set where
      constructor SloopC
      field
        e : A
        op : A -> A -> A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
        antiAbsorbent :
          (x : A) (y : A) ->
          op x (op x y) == y
        unipotence :
          (x : A) -> op x x == e
    record SloopSig
      (AS : Set) : Set where
      constructor SloopSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record SloopProd
      (AP : Set) : Set where
      constructor SloopProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
        antiAbsorbentP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (opP xP yP) == yP
        unipotenceP :
          (xP : Prod AP AP) ->
          opP xP xP == eP
    record SloopHom
      (A1 : Set) (A2 : Set)
      (Sl1 : Sloop A1)
      (Sl2 : Sloop A2) : Set where
      constructor SloopHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Sl1) == e Sl2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Sl1 x1 x2) ==
            op Sl2 (hom x1) (hom x2)
    record SloopRelInterp
      (A1 : Set) (A2 : Set)
      (Sl1 : Sloop A1)
      (Sl2 : Sloop A2) : Set where
      constructor SloopRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Sl1) (e Sl2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Sl1 x1 x2)
            (op Sl2 y1 y2)
    data SloopLang : Set where
      eL : SloopLang
      opL :
        SloopLang ->
        SloopLang -> SloopLang
    data SloopOpenLang
      (n : Nat) : Set where
      v : Fin n -> SloopOpenLang n
      eOL : SloopOpenLang n
      opOL :
        SloopOpenLang n ->
        SloopOpenLang n ->
        SloopOpenLang n
    evalTerm :
      (A : Set) ->
      Sloop A -> SloopLang -> A
    evalTerm _ Sl (eL) = e Sl
    evalTerm _ Sl (opL x1 x2) =
      op Sl (evalTerm _ Sl x1)
        (evalTerm _ Sl x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Sloop A ->
      SloopOpenLang n -> Vec A n -> A
    evalOpenTerm _ n sl (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n sl (eOL) vars =
      e sl
    evalOpenTerm _ n sl (opOL
                         x1
                         x2) vars =
      op sl
        (evalOpenTerm _ n sl x1 vars)
        (evalOpenTerm _ n sl x2 vars)
  
  module Spindle where
    record Spindle
      (A : Set) : Set where
      constructor SpindleC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
        idempotent_|> :
          (x : A) -> |> x x == x
        idempotent_<| :
          (x : A) -> <| x x == x
    record SpindleSig
      (AS : Set) : Set where
      constructor SpindleSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record SpindleProd
      (AP : Set) : Set where
      constructor SpindleProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
        idempotent_<|P :
          (xP : Prod AP AP) ->
          <|P xP xP == xP
    record SpindleHom
      (A1 : Set) (A2 : Set)
      (Sp1 : Spindle A1)
      (Sp2 : Spindle A2) : Set where
      constructor SpindleHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Sp1 x1 x2) ==
            |> Sp2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Sp1 x1 x2) ==
            <| Sp2 (hom x1) (hom x2)
    record SpindleRelInterp
      (A1 : Set) (A2 : Set)
      (Sp1 : Spindle A1)
      (Sp2 : Spindle A2) : Set where
      constructor SpindleRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Sp1 x1 x2)
            (|> Sp2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Sp1 x1 x2)
            (<| Sp2 y1 y2)
    data SpindleLang : Set where
      |>L :
        SpindleLang ->
        SpindleLang -> SpindleLang
      <|L :
        SpindleLang ->
        SpindleLang -> SpindleLang
    data SpindleOpenLang
      (n : Nat) : Set where
      v : Fin n -> SpindleOpenLang n
      |>OL :
        SpindleOpenLang n ->
        SpindleOpenLang n ->
        SpindleOpenLang n
      <|OL :
        SpindleOpenLang n ->
        SpindleOpenLang n ->
        SpindleOpenLang n
    evalTerm :
      (A : Set) ->
      Spindle A -> SpindleLang -> A
    evalTerm _ Sp (|>L x1 x2) =
      |> Sp (evalTerm _ Sp x1)
        (evalTerm _ Sp x2)
    evalTerm _ Sp (<|L x1 x2) =
      <| Sp (evalTerm _ Sp x1)
        (evalTerm _ Sp x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Spindle A ->
      SpindleOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n sp (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n sp (|>OL
                         x1
                         x2) vars =
      |> sp
        (evalOpenTerm _ n sp x1 vars)
        (evalOpenTerm _ n sp x2 vars)
    evalOpenTerm _ n sp (<|OL
                         x1
                         x2) vars =
      <| sp
        (evalOpenTerm _ n sp x1 vars)
        (evalOpenTerm _ n sp x2 vars)
  
  module Squag where
    record Squag
      (A : Set) : Set where
      constructor SquagC
      field
        op : A -> A -> A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
        antiAbsorbent :
          (x : A) (y : A) ->
          op x (op x y) == y
        idempotent_op :
          (x : A) -> op x x == x
    record SquagSig
      (AS : Set) : Set where
      constructor SquagSigSigC
      field
        opS : AS -> AS -> AS
    record SquagProd
      (AP : Set) : Set where
      constructor SquagProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
        antiAbsorbentP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (opP xP yP) == yP
        idempotent_opP :
          (xP : Prod AP AP) ->
          opP xP xP == xP
    record SquagHom
      (A1 : Set) (A2 : Set)
      (Sq1 : Squag A1)
      (Sq2 : Squag A2) : Set where
      constructor SquagHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Sq1 x1 x2) ==
            op Sq2 (hom x1) (hom x2)
    record SquagRelInterp
      (A1 : Set) (A2 : Set)
      (Sq1 : Squag A1)
      (Sq2 : Squag A2) : Set where
      constructor SquagRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Sq1 x1 x2)
            (op Sq2 y1 y2)
    data SquagLang : Set where
      opL :
        SquagLang ->
        SquagLang -> SquagLang
    data SquagOpenLang
      (n : Nat) : Set where
      v : Fin n -> SquagOpenLang n
      opOL :
        SquagOpenLang n ->
        SquagOpenLang n ->
        SquagOpenLang n
    evalTerm :
      (A : Set) ->
      Squag A -> SquagLang -> A
    evalTerm _ Sq (opL x1 x2) =
      op Sq (evalTerm _ Sq x1)
        (evalTerm _ Sq x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Squag A ->
      SquagOpenLang n -> Vec A n -> A
    evalOpenTerm _ n sq (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n sq (opOL
                         x1
                         x2) vars =
      op sq
        (evalOpenTerm _ n sq x1 vars)
        (evalOpenTerm _ n sq x2 vars)
  
  module SteinerMagma where
    record SteinerMagma
      (A : Set) : Set where
      constructor SteinerMagmaC
      field
        op : A -> A -> A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
        antiAbsorbent :
          (x : A) (y : A) ->
          op x (op x y) == y
    record SteinerMagmaSig
      (AS : Set) : Set where
      constructor SteinerMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record SteinerMagmaProd
      (AP : Set) : Set where
      constructor SteinerMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
        antiAbsorbentP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (opP xP yP) == yP
    record SteinerMagmaHom
      (A1 : Set) (A2 : Set)
      (St1 : SteinerMagma A1)
      (St2 : SteinerMagma A2) :
      Set where
      constructor SteinerMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op St1 x1 x2) ==
            op St2 (hom x1) (hom x2)
    record SteinerMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (St1 : SteinerMagma A1)
      (St2 : SteinerMagma A2) :
      Set where
      constructor SteinerMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op St1 x1 x2)
            (op St2 y1 y2)
    data SteinerMagmaLang
      : Set where
      opL :
        SteinerMagmaLang ->
        SteinerMagmaLang ->
        SteinerMagmaLang
    data SteinerMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> SteinerMagmaOpenLang n
      opOL :
        SteinerMagmaOpenLang n ->
        SteinerMagmaOpenLang n ->
        SteinerMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      SteinerMagma A ->
      SteinerMagmaLang -> A
    evalTerm _ St (opL x1 x2) =
      op St (evalTerm _ St x1)
        (evalTerm _ St x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      SteinerMagma A ->
      SteinerMagmaOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n st (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n st (opOL
                         x1
                         x2) vars =
      op st
        (evalOpenTerm _ n st x1 vars)
        (evalOpenTerm _ n st x2 vars)
  
  module TwoPointed where
    record TwoPointed
      (A : Set) : Set where
      constructor TwoPointedC
      field
        e1 : A
        e2 : A
    record TwoPointedSig
      (AS : Set) : Set where
      constructor TwoPointedSigSigC
      field
        e1S : AS
        e2S : AS
    record TwoPointedProd
      (AP : Set) : Set where
      constructor TwoPointedProdC
      field
        e1P : Prod AP AP
        e2P : Prod AP AP
    record TwoPointedHom
      (A1 : Set) (A2 : Set)
      (Tw1 : TwoPointed A1)
      (Tw2 : TwoPointed A2) :
      Set where
      constructor TwoPointedHomC
      field
        hom : A1 -> A2
        pres-e1 : hom (e1 Tw1) == e1 Tw2
        pres-e2 : hom (e2 Tw1) == e2 Tw2
    record TwoPointedRelInterp
      (A1 : Set) (A2 : Set)
      (Tw1 : TwoPointed A1)
      (Tw2 : TwoPointed A2) :
      Set where
      constructor TwoPointedRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e1 :
          interp (e1 Tw1) (e1 Tw2)
        interp-e2 :
          interp (e2 Tw1) (e2 Tw2)
    data TwoPointedLang : Set where
      e1L : TwoPointedLang
      e2L : TwoPointedLang
    data TwoPointedOpenLang
      (n : Nat) : Set where
      v :
        Fin n -> TwoPointedOpenLang n
      e1OL : TwoPointedOpenLang n
      e2OL : TwoPointedOpenLang n
    evalTerm :
      (A : Set) ->
      TwoPointed A ->
      TwoPointedLang -> A
    evalTerm _ Tw (e1L) = e1 Tw
    evalTerm _ Tw (e2L) = e2 Tw
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      TwoPointed A ->
      TwoPointedOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n tw (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n tw (e1OL) vars =
      e1 tw
    evalOpenTerm _ n tw (e2OL) vars =
      e2 tw
  
  module TwoPointed01 where
    record TwoPointed01
      (A : Set) : Set where
      constructor TwoPointed01C
      field
        e1 : A
        e2 : A
    record TwoPointed01Sig
      (AS : Set) : Set where
      constructor TwoPointed01SigSigC
      field
        e1S : AS
        e2S : AS
    record TwoPointed01Prod
      (AP : Set) : Set where
      constructor TwoPointed01ProdC
      field
        e1P : Prod AP AP
        e2P : Prod AP AP
    record TwoPointed01Hom
      (A1 : Set) (A2 : Set)
      (Tw1 : TwoPointed01 A1)
      (Tw2 : TwoPointed01 A2) :
      Set where
      constructor TwoPointed01HomC
      field
        hom : A1 -> A2
        pres-e1 : hom (e1 Tw1) == e1 Tw2
        pres-e2 : hom (e2 Tw1) == e2 Tw2
    record TwoPointed01RelInterp
      (A1 : Set) (A2 : Set)
      (Tw1 : TwoPointed01 A1)
      (Tw2 : TwoPointed01 A2) :
      Set where
      constructor TwoPointed01RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e1 :
          interp (e1 Tw1) (e1 Tw2)
        interp-e2 :
          interp (e2 Tw1) (e2 Tw2)
    data TwoPointed01Lang
      : Set where
      e1L : TwoPointed01Lang
      e2L : TwoPointed01Lang
    data TwoPointed01OpenLang
      (n : Nat) : Set where
      v :
        Fin n -> TwoPointed01OpenLang n
      e1OL : TwoPointed01OpenLang n
      e2OL : TwoPointed01OpenLang n
    evalTerm :
      (A : Set) ->
      TwoPointed01 A ->
      TwoPointed01Lang -> A
    evalTerm _ Tw (e1L) = e1 Tw
    evalTerm _ Tw (e2L) = e2 Tw
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      TwoPointed01 A ->
      TwoPointed01OpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n tw (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n tw (e1OL) vars =
      e1 tw
    evalOpenTerm _ n tw (e2OL) vars =
      e2 tw
  
  module UnaryAntiDistribution where
    record UnaryAntiDistribution
      (A : Set) : Set where
      constructor UnaryAntiDistributionC
      field
        prim : A -> A
        op : A -> A -> A
        antidis_prim_op :
          (x : A) (y : A) ->
          prim (op x y) ==
            op (prim y) (prim x)
    record UnaryAntiDistributionSig
      (AS : Set) : Set where
      constructor UnaryAntiDistributionSigSigC
      field
        primS : AS -> AS
        opS : AS -> AS -> AS
    record UnaryAntiDistributionProd
      (AP : Set) : Set where
      constructor UnaryAntiDistributionProdC
      field
        primP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        antidis_prim_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (opP xP yP) ==
            opP (primP yP) (primP xP)
    record UnaryAntiDistributionHom
      (A1 : Set) (A2 : Set)
      (Un1 : UnaryAntiDistribution A1)
      (Un2 : UnaryAntiDistribution
         A2) : Set where
      constructor UnaryAntiDistributionHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Un1 x1) ==
            prim Un2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Un1 x1 x2) ==
            op Un2 (hom x1) (hom x2)
    record UnaryAntiDistributionRelInterp
      (A1 : Set) (A2 : Set)
      (Un1 : UnaryAntiDistribution A1)
      (Un2 : UnaryAntiDistribution
         A2) : Set where
      constructor UnaryAntiDistributionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Un1 x1)
            (prim Un2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Un1 x1 x2)
            (op Un2 y1 y2)
    data UnaryAntiDistributionLang
      : Set where
      primL :
        UnaryAntiDistributionLang ->
        UnaryAntiDistributionLang
      opL :
        UnaryAntiDistributionLang ->
        UnaryAntiDistributionLang ->
        UnaryAntiDistributionLang
    data UnaryAntiDistributionOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        UnaryAntiDistributionOpenLang n
      primOL :
        UnaryAntiDistributionOpenLang
          n ->
        UnaryAntiDistributionOpenLang n
      opOL :
        UnaryAntiDistributionOpenLang
          n ->
        UnaryAntiDistributionOpenLang
          n ->
        UnaryAntiDistributionOpenLang n
    evalTerm :
      (A : Set) ->
      UnaryAntiDistribution A ->
      UnaryAntiDistributionLang -> A
    evalTerm _ Un (primL x1) =
      prim Un (evalTerm _ Un x1)
    evalTerm _ Un (opL x1 x2) =
      op Un (evalTerm _ Un x1)
        (evalTerm _ Un x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      UnaryAntiDistribution A ->
      UnaryAntiDistributionOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n un (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n un (primOL
                         x1) vars =
      prim un
        (evalOpenTerm _ n un x1 vars)
    evalOpenTerm _ n un (opOL
                         x1
                         x2) vars =
      op un
        (evalOpenTerm _ n un x1 vars)
        (evalOpenTerm _ n un x2 vars)
  
  module UnaryDistributes where
    record UnaryDistributes
      (A : Set) : Set where
      constructor UnaryDistributesC
      field
        prim : A -> A
        op : A -> A -> A
        distribute_prim_op :
          (x : A) (y : A) ->
          prim (op x y) ==
            op (prim x) (prim y)
    record UnaryDistributesSig
      (AS : Set) : Set where
      constructor UnaryDistributesSigSigC
      field
        primS : AS -> AS
        opS : AS -> AS -> AS
    record UnaryDistributesProd
      (AP : Set) : Set where
      constructor UnaryDistributesProdC
      field
        primP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        distribute_prim_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (opP xP yP) ==
            opP (primP xP) (primP yP)
    record UnaryDistributesHom
      (A1 : Set) (A2 : Set)
      (Un1 : UnaryDistributes A1)
      (Un2 : UnaryDistributes A2) :
      Set where
      constructor UnaryDistributesHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Un1 x1) ==
            prim Un2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Un1 x1 x2) ==
            op Un2 (hom x1) (hom x2)
    record UnaryDistributesRelInterp
      (A1 : Set) (A2 : Set)
      (Un1 : UnaryDistributes A1)
      (Un2 : UnaryDistributes A2) :
      Set where
      constructor UnaryDistributesRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Un1 x1)
            (prim Un2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Un1 x1 x2)
            (op Un2 y1 y2)
    data UnaryDistributesLang
      : Set where
      primL :
        UnaryDistributesLang ->
        UnaryDistributesLang
      opL :
        UnaryDistributesLang ->
        UnaryDistributesLang ->
        UnaryDistributesLang
    data UnaryDistributesOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        UnaryDistributesOpenLang n
      primOL :
        UnaryDistributesOpenLang n ->
        UnaryDistributesOpenLang n
      opOL :
        UnaryDistributesOpenLang n ->
        UnaryDistributesOpenLang n ->
        UnaryDistributesOpenLang n
    evalTerm :
      (A : Set) ->
      UnaryDistributes A ->
      UnaryDistributesLang -> A
    evalTerm _ Un (primL x1) =
      prim Un (evalTerm _ Un x1)
    evalTerm _ Un (opL x1 x2) =
      op Un (evalTerm _ Un x1)
        (evalTerm _ Un x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      UnaryDistributes A ->
      UnaryDistributesOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n un (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n un (primOL
                         x1) vars =
      prim un
        (evalOpenTerm _ n un x1 vars)
    evalOpenTerm _ n un (opOL
                         x1
                         x2) vars =
      op un
        (evalOpenTerm _ n un x1 vars)
        (evalOpenTerm _ n un x2 vars)
  
  module UnaryOperation where
    record UnaryOperation
      (A : Set) : Set where
      constructor UnaryOperationC
      field
        prim : A -> A
    record UnaryOperationSig
      (AS : Set) : Set where
      constructor UnaryOperationSigSigC
      field
        primS : AS -> AS
    record UnaryOperationProd
      (AP : Set) : Set where
      constructor UnaryOperationProdC
      field
        primP : Prod AP AP -> Prod AP AP
    record UnaryOperationHom
      (A1 : Set) (A2 : Set)
      (Un1 : UnaryOperation A1)
      (Un2 : UnaryOperation A2) :
      Set where
      constructor UnaryOperationHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Un1 x1) ==
            prim Un2 (hom x1)
    record UnaryOperationRelInterp
      (A1 : Set) (A2 : Set)
      (Un1 : UnaryOperation A1)
      (Un2 : UnaryOperation A2) :
      Set where
      constructor UnaryOperationRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Un1 x1)
            (prim Un2 y1)
    data UnaryOperationLang
      : Set where
      primL :
        UnaryOperationLang ->
        UnaryOperationLang
    data UnaryOperationOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        UnaryOperationOpenLang n
      primOL :
        UnaryOperationOpenLang n ->
        UnaryOperationOpenLang n
    evalTerm :
      (A : Set) ->
      UnaryOperation A ->
      UnaryOperationLang -> A
    evalTerm _ Un (primL x1) =
      prim Un (evalTerm _ Un x1)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      UnaryOperation A ->
      UnaryOperationOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n un (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n un (primOL
                         x1) vars =
      prim un
        (evalOpenTerm _ n un x1 vars)
  
  module UnipotentPointedMagma where
    record UnipotentPointedMagma
      (A : Set) : Set where
      constructor UnipotentPointedMagmaC
      field
        e : A
        op : A -> A -> A
        unipotence :
          (x : A) -> op x x == e
    record UnipotentPointedMagmaSig
      (AS : Set) : Set where
      constructor UnipotentPointedMagmaSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record UnipotentPointedMagmaProd
      (AP : Set) : Set where
      constructor UnipotentPointedMagmaProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        unipotenceP :
          (xP : Prod AP AP) ->
          opP xP xP == eP
    record UnipotentPointedMagmaHom
      (A1 : Set) (A2 : Set)
      (Un1 : UnipotentPointedMagma A1)
      (Un2 : UnipotentPointedMagma
         A2) : Set where
      constructor UnipotentPointedMagmaHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Un1) == e Un2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Un1 x1 x2) ==
            op Un2 (hom x1) (hom x2)
    record UnipotentPointedMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Un1 : UnipotentPointedMagma A1)
      (Un2 : UnipotentPointedMagma
         A2) : Set where
      constructor UnipotentPointedMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Un1) (e Un2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Un1 x1 x2)
            (op Un2 y1 y2)
    data UnipotentPointedMagmaLang
      : Set where
      eL : UnipotentPointedMagmaLang
      opL :
        UnipotentPointedMagmaLang ->
        UnipotentPointedMagmaLang ->
        UnipotentPointedMagmaLang
    data UnipotentPointedMagmaOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        UnipotentPointedMagmaOpenLang n
      eOL :
        UnipotentPointedMagmaOpenLang n
      opOL :
        UnipotentPointedMagmaOpenLang
          n ->
        UnipotentPointedMagmaOpenLang
          n ->
        UnipotentPointedMagmaOpenLang n
    evalTerm :
      (A : Set) ->
      UnipotentPointedMagma A ->
      UnipotentPointedMagmaLang -> A
    evalTerm _ Un (eL) = e Un
    evalTerm _ Un (opL x1 x2) =
      op Un (evalTerm _ Un x1)
        (evalTerm _ Un x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      UnipotentPointedMagma A ->
      UnipotentPointedMagmaOpenLang
        n -> Vec A n -> A
    evalOpenTerm _ n un (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n un (eOL) vars =
      e un
    evalOpenTerm _ n un (opOL
                         x1
                         x2) vars =
      op un
        (evalOpenTerm _ n un x1 vars)
        (evalOpenTerm _ n un x2 vars)
  
  module Unital where
    record Unital
      (A : Set) : Set where
      constructor UnitalC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
    record UnitalSig
      (AS : Set) : Set where
      constructor UnitalSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record UnitalProd
      (AP : Set) : Set where
      constructor UnitalProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
    record UnitalHom
      (A1 : Set) (A2 : Set)
      (Un1 : Unital A1)
      (Un2 : Unital A2) : Set where
      constructor UnitalHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Un1) == e Un2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Un1 x1 x2) ==
            op Un2 (hom x1) (hom x2)
    record UnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Un1 : Unital A1)
      (Un2 : Unital A2) : Set where
      constructor UnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Un1) (e Un2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Un1 x1 x2)
            (op Un2 y1 y2)
    data UnitalLang : Set where
      eL : UnitalLang
      opL :
        UnitalLang ->
        UnitalLang -> UnitalLang
    data UnitalOpenLang
      (n : Nat) : Set where
      v : Fin n -> UnitalOpenLang n
      eOL : UnitalOpenLang n
      opOL :
        UnitalOpenLang n ->
        UnitalOpenLang n ->
        UnitalOpenLang n
    evalTerm :
      (A : Set) ->
      Unital A -> UnitalLang -> A
    evalTerm _ Un (eL) = e Un
    evalTerm _ Un (opL x1 x2) =
      op Un (evalTerm _ Un x1)
        (evalTerm _ Un x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Unital A ->
      UnitalOpenLang n -> Vec A n -> A
    evalOpenTerm _ n un (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n un (eOL) vars =
      e un
    evalOpenTerm _ n un (opOL
                         x1
                         x2) vars =
      op un
        (evalOpenTerm _ n un x1 vars)
        (evalOpenTerm _ n un x2 vars)
  
  module Zero where
    record Zero
      (A : Set) : Set where
      constructor ZeroC
      field
        e : A
        op : A -> A -> A
        leftZero_op_e :
          (x : A) -> op e x == e
        rightZero_op_e :
          (x : A) -> op x e == e
    record ZeroSig
      (AS : Set) : Set where
      constructor ZeroSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record ZeroProd
      (AP : Set) : Set where
      constructor ZeroProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftZero_op_eP :
          (xP : Prod AP AP) ->
          opP eP xP == eP
        rightZero_op_eP :
          (xP : Prod AP AP) ->
          opP xP eP == eP
    record ZeroHom
      (A1 : Set) (A2 : Set)
      (Ze1 : Zero A1)
      (Ze2 : Zero A2) : Set where
      constructor ZeroHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Ze1) == e Ze2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ze1 x1 x2) ==
            op Ze2 (hom x1) (hom x2)
    record ZeroRelInterp
      (A1 : Set) (A2 : Set)
      (Ze1 : Zero A1)
      (Ze2 : Zero A2) : Set where
      constructor ZeroRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Ze1) (e Ze2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ze1 x1 x2)
            (op Ze2 y1 y2)
    data ZeroLang : Set where
      eL : ZeroLang
      opL :
        ZeroLang -> ZeroLang -> ZeroLang
    data ZeroOpenLang
      (n : Nat) : Set where
      v : Fin n -> ZeroOpenLang n
      eOL : ZeroOpenLang n
      opOL :
        ZeroOpenLang n ->
        ZeroOpenLang n -> ZeroOpenLang n
    evalTerm :
      (A : Set) ->
      Zero A -> ZeroLang -> A
    evalTerm _ Ze (eL) = e Ze
    evalTerm _ Ze (opL x1 x2) =
      op Ze (evalTerm _ Ze x1)
        (evalTerm _ Ze x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Zero A ->
      ZeroOpenLang n -> Vec A n -> A
    evalOpenTerm _ n ze (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ze (eOL) vars =
      e ze
    evalOpenTerm _ n ze (opOL
                         x1
                         x2) vars =
      op ze
        (evalOpenTerm _ n ze x1 vars)
        (evalOpenTerm _ n ze x2 vars)
  
  module Zero0 where
    record Zero0
      (A : Set) : Set where
      constructor Zero0C
      field
        0 : A
        * : A -> A -> A
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
    record Zero0Sig
      (AS : Set) : Set where
      constructor Zero0SigSigC
      field
        0S : AS
        *S : AS -> AS -> AS
    record Zero0Prod
      (AP : Set) : Set where
      constructor Zero0ProdC
      field
        0P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
    record Zero0Hom
      (A1 : Set) (A2 : Set)
      (Ze1 : Zero0 A1)
      (Ze2 : Zero0 A2) : Set where
      constructor Zero0HomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ze1) == 0 Ze2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ze1 x1 x2) ==
            * Ze2 (hom x1) (hom x2)
    record Zero0RelInterp
      (A1 : Set) (A2 : Set)
      (Ze1 : Zero0 A1)
      (Ze2 : Zero0 A2) : Set where
      constructor Zero0RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ze1) (0 Ze2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ze1 x1 x2)
            (* Ze2 y1 y2)
    data Zero0Lang : Set where
      0L : Zero0Lang
      *L :
        Zero0Lang ->
        Zero0Lang -> Zero0Lang
    data Zero0OpenLang
      (n : Nat) : Set where
      v : Fin n -> Zero0OpenLang n
      0OL : Zero0OpenLang n
      *OL :
        Zero0OpenLang n ->
        Zero0OpenLang n ->
        Zero0OpenLang n
    evalTerm :
      (A : Set) ->
      Zero0 A -> Zero0Lang -> A
    evalTerm _ Ze (0L) = 0 Ze
    evalTerm _ Ze (*L x1 x2) =
      * Ze (evalTerm _ Ze x1)
        (evalTerm _ Ze x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Zero0 A ->
      Zero0OpenLang n -> Vec A n -> A
    evalOpenTerm _ n ze (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ze (0OL) vars =
      0 ze
    evalOpenTerm _ n ze (*OL
                         x1
                         x2) vars =
      * ze
        (evalOpenTerm _ n ze x1 vars)
        (evalOpenTerm _ n ze x2 vars)
  
  module Zero_Ringoid0Sig where
    record Zero_Ringoid0Sig
      (A : Set) : Set where
      constructor Zero_Ringoid0SigC
      field
        0 : A
        * : A -> A -> A
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
        + : A -> A -> A
    record Zero_Ringoid0SigSig
      (AS : Set) : Set where
      constructor Zero_Ringoid0SigSigSigC
      field
        0S : AS
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record Zero_Ringoid0SigProd
      (AP : Set) : Set where
      constructor Zero_Ringoid0SigProdC
      field
        0P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
    record Zero_Ringoid0SigHom
      (A1 : Set) (A2 : Set)
      (Ze1 : Zero_Ringoid0Sig A1)
      (Ze2 : Zero_Ringoid0Sig A2) :
      Set where
      constructor Zero_Ringoid0SigHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ze1) == 0 Ze2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ze1 x1 x2) ==
            * Ze2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ze1 x1 x2) ==
            + Ze2 (hom x1) (hom x2)
    record Zero_Ringoid0SigRelInterp
      (A1 : Set) (A2 : Set)
      (Ze1 : Zero_Ringoid0Sig A1)
      (Ze2 : Zero_Ringoid0Sig A2) :
      Set where
      constructor Zero_Ringoid0SigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ze1) (0 Ze2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ze1 x1 x2)
            (* Ze2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ze1 x1 x2)
            (+ Ze2 y1 y2)
    data Zero_Ringoid0SigLang
      : Set where
      0L : Zero_Ringoid0SigLang
      *L :
        Zero_Ringoid0SigLang ->
        Zero_Ringoid0SigLang ->
        Zero_Ringoid0SigLang
      +L :
        Zero_Ringoid0SigLang ->
        Zero_Ringoid0SigLang ->
        Zero_Ringoid0SigLang
    data Zero_Ringoid0SigOpenLang
      (n : Nat) : Set where
      v :
        Fin n ->
        Zero_Ringoid0SigOpenLang n
      0OL : Zero_Ringoid0SigOpenLang n
      *OL :
        Zero_Ringoid0SigOpenLang n ->
        Zero_Ringoid0SigOpenLang n ->
        Zero_Ringoid0SigOpenLang n
      +OL :
        Zero_Ringoid0SigOpenLang n ->
        Zero_Ringoid0SigOpenLang n ->
        Zero_Ringoid0SigOpenLang n
    evalTerm :
      (A : Set) ->
      Zero_Ringoid0Sig A ->
      Zero_Ringoid0SigLang -> A
    evalTerm _ Ze (0L) = 0 Ze
    evalTerm _ Ze (*L x1 x2) =
      * Ze (evalTerm _ Ze x1)
        (evalTerm _ Ze x2)
    evalTerm _ Ze (+L x1 x2) =
      + Ze (evalTerm _ Ze x1)
        (evalTerm _ Ze x2)
    evalOpenTerm :
      (A : Set) (n : Nat) ->
      Zero_Ringoid0Sig A ->
      Zero_Ringoid0SigOpenLang n ->
      Vec A n -> A
    evalOpenTerm _ n ze (v
                         fin) vars = lookup _ n fin vars
    evalOpenTerm _ n ze (0OL) vars =
      0 ze
    evalOpenTerm _ n ze (*OL
                         x1
                         x2) vars =
      * ze
        (evalOpenTerm _ n ze x1 vars)
        (evalOpenTerm _ n ze x2 vars)
    evalOpenTerm _ n ze (+OL
                         x1
                         x2) vars =
      + ze
        (evalOpenTerm _ n ze x1 vars)
        (evalOpenTerm _ n ze x2 vars)
  

------------------------------------------------------------------------
-- Checking declarations
------------------------------------------------------------------------
-- Solved Metas: 719151
-- Unsolved Metas: 0
------------------------------------------------------------------------
-- Unsolved problems: 0
------------------------------------------------------------------------
module MathScheme where
  data Prod
    (A : Set) (B : Set) : Set where
    
  module NatNums where
    
  
  data Nat : Set where
    zero : Nat
    suc : Nat -> Nat
  module Prelude where
    
  
  data Fin (n : Nat) : Set where
    fzero :
      (m : Nat) (p : n == suc m) ->
      Fin n
    fsuc :
      (m : Nat) (p : n == suc m)
      (i : Fin m) -> Fin n
  pred : Nat -> Nat
  pred (zero) = zero
  pred (suc n) = n
  data Vec
    (A : Set) (n : Nat) : Set where
    nil : n == zero -> Vec A n
    cons :
      (m : Nat) (p : n == suc m)
      (x : A)
      (xs : Vec A m) -> Vec A n
  data Unit : Set where
    unit : Unit
  EmptyT : Set
  EmptyT = (A : Set) -> A
  subst :
    (A : Set) (x : A) (y : A)
    (P : A -> Set) ->
    x == y -> P x -> P y
  subst _ _ _ P =
    J _ _ _ (\ x y _ -> P x -> P y)
      (\ x p -> p)
  sym :
    (A : Set) (x : A) (y : A) ->
    x == y -> y == x
  sym A x y p =
    subst _ _ _ (\ y -> y == x) p
      refl
  cong :
    (A : Set) (B : Set) (x : A)
    (y : A)
    (f : A -> B) ->
    x == y -> f x == f y
  cong _ _ _ _ f p =
    subst _ _ _ (\ y -> f _ == f y)
      p
      refl
  IsZero : Nat -> Set
  IsZero (zero) = Unit
  IsZero (suc n) = EmptyT
  zeroNOTsuc :
    (n : Nat) ->
    zero == suc n -> EmptyT
  zeroNOTsuc _ p =
    subst _ _ _ IsZero p unit
  trans :
    (A : Set) (x : A) (y : A)
    (z : A) ->
    x == y -> y == z -> x == z
  trans A x _ _ p q =
    subst _ _ _ (\ y -> x == y) q p
  lemma :
    (n : Nat) (m : Nat) ->
    n == suc m ->
    n == zero -> EmptyT
  lemma _ _ p q =
    zeroNOTsuc _
      (trans _ _ _ _ (sym _ _ _ q) p)
  sucInj :
    (n : Nat) (m : Nat) ->
    suc n == suc m -> n == m
  sucInj _ _ p =
    cong _ _ _ _ pred p
  lookup :
    (A : Set) (n : Nat) (i : Fin n)
    (v : Vec A n) -> A
  lookup A n (fzero m p) (nil q) =
    lemma _ _ p q A
  lookup A n (fzero m p) (cons
                          l
                          q
                          x
                          xs) = x
  lookup A n (fsuc m p i) (nil
                           q) = lemma _ _ p q A
  lookup A n (fsuc m p i) (cons
                           l
                           q
                           x
                           xs) =
    lookup _ m i
      (subst _ _ _ (Vec A)
         (sucInj _ _
            (trans _ _ _ _ (sym _ _ _ q) p))
         xs)
  module Code where
    
  
  open NatNums
  data Wrap (A : Set) : Set where
    Q : A -> Wrap A
  data Stage : Set where
    s0 : Stage
    s1 : Stage
  CodeRep :
    (A : Set) (s : Stage) -> Set
  CodeRep A (s0) = A
  CodeRep A (s1) =
    Wrap (CodeRep A s0)
  uncode :
    (A : Set) ->
    CodeRep A s1 -> CodeRep A s0
  uncode _ (Q x) = x
  code :
    (A : Set) ->
    CodeRep A s0 -> CodeRep A s1
  code _ x = Q x
  run :
    (A : Set) -> CodeRep A s1 -> A
  run _ (Q x) = x
  module Staging where
    
  
  open Code
  data Choice : Set where
    Expr : Choice
    Const : Choice
  data Comp
    (A : Set) (s : Stage) :
    Set where
    Computation :
      Choice ->
      CodeRep A s -> Comp A s
  data Staged
    (A : Set) : Set where
    Now : A -> Staged A
    Later : Comp A s1 -> Staged A
  expr :
    (A : Set) ->
    CodeRep A s1 -> Staged A
  expr _ x =
    Later (Computation Expr x)
  const :
    (A : Set) ->
    CodeRep A s1 -> Staged A
  const _ x =
    Later (Computation Const x)
  stage0 :
    (A : Set) -> A -> Staged A
  stage0 _ x = Now x
  stage1 :
    (A : Set) (B : Set) ->
    (A -> B) ->
    (CodeRep A s1 ->
     CodeRep B s1) ->
    Staged A -> Staged B
  stage1 _ _ f g (Now x) =
    Now (f x)
  stage1 _ _ f g (Later
                  (Computation _ x)) =
    expr _ (g x)
  stage2 :
    (A : Set) (B : Set) (C : Set) ->
    (A -> B -> C) ->
    (CodeRep A s1 ->
     CodeRep B s1 -> CodeRep C s1) ->
    Staged A -> Staged B -> Staged C
  stage2 _ _ _ f _ (Now x) (Now
                            y) = stage0 _ (f x y)
  stage2 _ _ _ _ g (Now x) (Later
                            (Computation _ y)) =
    expr _ (g (code _ x) y)
  stage2 _ _ _ _ g (Later
                    (Computation _ x)) (Now y) =
    expr _ (g x (code _ y))
  stage2 _ _ _ _ g (Later
                    (Computation _ x)) (Later
                                        (Computation _ y)) =
    expr _ (g x y)
  codeLift1 :
    (A : Set) (B : Set) ->
    (A -> B) ->
    CodeRep A s1 -> CodeRep B s1
  codeLift1 _ _ f (Q x) = Q (f x)
  codeLift2 :
    (A : Set) (B : Set) (C : Set) ->
    (A -> B -> C) ->
    CodeRep A s1 ->
    CodeRep B s1 -> CodeRep C s1
  codeLift2 _ _ _ f (Q x) (Q y) =
    Q (f x y)
  module AbelianAdditiveGroup where
    record AbelianAdditiveGroup
      (A : Set) : Set where
      constructor AbelianAdditiveGroupC
      field
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
    record AbelianAdditiveGroupSig
      (AS : Set) : Set where
      constructor AbelianAdditiveGroupSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
    record AbelianAdditiveGroupProd
      (AP : Set) : Set where
      constructor AbelianAdditiveGroupProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
    record AbelianAdditiveGroupHom
      (A1 : Set) (A2 : Set)
      (Ab1 : AbelianAdditiveGroup A1)
      (Ab2 : AbelianAdditiveGroup
         A2) : Set where
      constructor AbelianAdditiveGroupHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ab1 x1 x2) ==
            + Ab2 (hom x1) (hom x2)
        pres-0 : hom (0 Ab1) == 0 Ab2
        pres-neg :
          (x1 : A1) ->
          hom (neg Ab1 x1) ==
            neg Ab2 (hom x1)
    record AbelianAdditiveGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ab1 : AbelianAdditiveGroup A1)
      (Ab2 : AbelianAdditiveGroup
         A2) : Set where
      constructor AbelianAdditiveGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ab1 x1 x2)
            (+ Ab2 y1 y2)
        interp-0 :
          interp (0 Ab1) (0 Ab2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Ab1 x1) (neg Ab2 y1)
    data AbelianAdditiveGroupTerm
      : Set where
      +L :
        AbelianAdditiveGroupTerm ->
        AbelianAdditiveGroupTerm ->
        AbelianAdditiveGroupTerm
      0L : AbelianAdditiveGroupTerm
      negL :
        AbelianAdditiveGroupTerm ->
        AbelianAdditiveGroupTerm
    data ClAbelianAdditiveGroupTerm
      (A : Set) : Set where
      sing :
        A ->
        ClAbelianAdditiveGroupTerm A
      +Cl :
        ClAbelianAdditiveGroupTerm A ->
        ClAbelianAdditiveGroupTerm A ->
        ClAbelianAdditiveGroupTerm A
      0Cl :
        ClAbelianAdditiveGroupTerm A
      negCl :
        ClAbelianAdditiveGroupTerm A ->
        ClAbelianAdditiveGroupTerm A
    data OpAbelianAdditiveGroupTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpAbelianAdditiveGroupTerm n
      +OL :
        OpAbelianAdditiveGroupTerm n ->
        OpAbelianAdditiveGroupTerm n ->
        OpAbelianAdditiveGroupTerm n
      0OL :
        OpAbelianAdditiveGroupTerm n
      negOL :
        OpAbelianAdditiveGroupTerm n ->
        OpAbelianAdditiveGroupTerm n
    data OpAbelianAdditiveGroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAbelianAdditiveGroupTerm2 n A
      sing2 :
        A ->
        OpAbelianAdditiveGroupTerm2 n A
      +OL2 :
        OpAbelianAdditiveGroupTerm2 n
          A ->
        OpAbelianAdditiveGroupTerm2 n
          A ->
        OpAbelianAdditiveGroupTerm2 n A
      0OL2 :
        OpAbelianAdditiveGroupTerm2 n A
      negOL2 :
        OpAbelianAdditiveGroupTerm2 n
          A ->
        OpAbelianAdditiveGroupTerm2 n A
    simplifyB :
      AbelianAdditiveGroupTerm ->
      AbelianAdditiveGroupTerm
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (+L x (negL x)) = 0L
    simplifyB (+L (negL x) x) = 0L
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (0L) = 0L
    simplifyB (negL x1) =
      negL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClAbelianAdditiveGroupTerm A ->
      ClAbelianAdditiveGroupTerm A
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (+Cl x (negCl x)) =
      0Cl
    simplifyCl _ (+Cl (negCl x) x) =
      0Cl
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (negCl x1) =
      negCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAbelianAdditiveGroupTerm n ->
      OpAbelianAdditiveGroupTerm n
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (+OL x (negOL x)) =
      0OL
    simplifyOp _ (+OL (negOL x) x) =
      0OL
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (negOL x1) =
      negOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAbelianAdditiveGroupTerm2 n
        A ->
      OpAbelianAdditiveGroupTerm2 n A
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (+OL2
                     x
                     (negOL2 x)) = 0OL2
    simplifyOpE _ _ (+OL2
                     (negOL2 x)
                     x) = 0OL2
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (negOL2 x1) =
      negOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AbelianAdditiveGroup A ->
      AbelianAdditiveGroupTerm -> A
    evalB _ Ab (+L x1 x2) =
      + Ab (evalB _ Ab x1)
        (evalB _ Ab x2)
    evalB _ Ab (0L) = 0 Ab
    evalB _ Ab (negL x1) =
      neg Ab (evalB _ Ab x1)
    evalCl :
      (A : Set) ->
      AbelianAdditiveGroup A ->
      ClAbelianAdditiveGroupTerm A ->
      A
    evalCl _ Ab (sing x1) = x1
    evalCl _ Ab (+Cl x1 x2) =
      + Ab (evalCl _ Ab x1)
        (evalCl _ Ab x2)
    evalCl _ Ab (0Cl) = 0 Ab
    evalCl _ Ab (negCl x1) =
      neg Ab (evalCl _ Ab x1)
    evalOp :
      (A : Set) (n : Nat) ->
      AbelianAdditiveGroup A ->
      Vec A n ->
      OpAbelianAdditiveGroupTerm n ->
      A
    evalOp _ n Ab vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ab vars (+OL x1 x2) =
      + Ab (evalOp _ n Ab vars x1)
        (evalOp _ n Ab vars x2)
    evalOp _ n Ab vars (0OL) = 0 Ab
    evalOp _ n Ab vars (negOL x1) =
      neg Ab (evalOp _ n Ab vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      AbelianAdditiveGroup A ->
      Vec A n ->
      OpAbelianAdditiveGroupTerm2 n
        A -> A
    evalOpE _ n Ab vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ab vars (sing2 x1) =
      x1
    evalOpE _ n Ab vars (+OL2
                         x1
                         x2) =
      + Ab (evalOpE _ n Ab vars x1)
        (evalOpE _ n Ab vars x2)
    evalOpE _ n Ab vars (0OL2) =
      0 Ab
    evalOpE _ n Ab vars (negOL2
                         x1) =
      neg Ab (evalOpE _ n Ab vars x1)
    inductionB :
      (P : AbelianAdditiveGroupTerm ->
           Set) ->
      ((x1 : AbelianAdditiveGroupTerm)
       (x2 : AbelianAdditiveGroupTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      P 0L ->
      ((x1 : AbelianAdditiveGroupTerm) ->
       P x1 -> P (negL x1)) ->
      (x : AbelianAdditiveGroupTerm) ->
      P x
    inductionB p p+l p0l pnegl (+L
                                x1
                                x2) =
      p+l _ _
        (inductionB p p+l p0l pnegl x1)
        (inductionB p p+l p0l pnegl x2)
    inductionB p p+l p0l pnegl (0L) =
      p0l
    inductionB p p+l p0l pnegl (negL
                                x1) =
      pnegl _
        (inductionB p p+l p0l pnegl x1)
    inductionCl :
      (A : Set)
      (P : ClAbelianAdditiveGroupTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClAbelianAdditiveGroupTerm
          A)
       (x2 : ClAbelianAdditiveGroupTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      P 0Cl ->
      ((x1 : ClAbelianAdditiveGroupTerm
          A) -> P x1 -> P (negCl x1)) ->
      (x : ClAbelianAdditiveGroupTerm
         A) -> P x
    inductionCl _ p psing p+cl p0cl pnegcl (sing
                                            x1) = psing x1
    inductionCl _ p psing p+cl p0cl pnegcl (+Cl
                                            x1
                                            x2) =
      p+cl _ _
        (inductionCl _ p psing p+cl p0cl
           pnegcl
           x1)
        (inductionCl _ p psing p+cl p0cl
           pnegcl
           x2)
    inductionCl _ p psing p+cl p0cl pnegcl (0Cl) =
      p0cl
    inductionCl _ p psing p+cl p0cl pnegcl (negCl
                                            x1) =
      pnegcl _
        (inductionCl _ p psing p+cl p0cl
           pnegcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpAbelianAdditiveGroupTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpAbelianAdditiveGroupTerm
          n)
       (x2 : OpAbelianAdditiveGroupTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      P 0OL ->
      ((x1 : OpAbelianAdditiveGroupTerm
          n) -> P x1 -> P (negOL x1)) ->
      (x : OpAbelianAdditiveGroupTerm
         n) -> P x
    inductionOp _ p pv p+ol p0ol pnegol (v
                                         x1) = pv x1
    inductionOp _ p pv p+ol p0ol pnegol (+OL
                                         x1
                                         x2) =
      p+ol _ _
        (inductionOp _ p pv p+ol p0ol
           pnegol
           x1)
        (inductionOp _ p pv p+ol p0ol
           pnegol
           x2)
    inductionOp _ p pv p+ol p0ol pnegol (0OL) =
      p0ol
    inductionOp _ p pv p+ol p0ol pnegol (negOL
                                         x1) =
      pnegol _
        (inductionOp _ p pv p+ol p0ol
           pnegol
           x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAbelianAdditiveGroupTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpAbelianAdditiveGroupTerm2
          n
          A)
       (x2 : OpAbelianAdditiveGroupTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      P 0OL2 ->
      ((x1 : OpAbelianAdditiveGroupTerm2
          n
          A) -> P x1 -> P (negOL2 x1)) ->
      (x : OpAbelianAdditiveGroupTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 pnegol2 (v2
                                                       x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 pnegol2 (sing2
                                                       x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 pnegol2 (+OL2
                                                       x1
                                                       x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p0ol2
           pnegol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p0ol2
           pnegol2
           x2)
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 pnegol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 pnegol2 (negOL2
                                                       x1) =
      pnegol2 _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p0ol2
           pnegol2
           x1)
    +L' :
      AbelianAdditiveGroupTerm ->
      AbelianAdditiveGroupTerm ->
      AbelianAdditiveGroupTerm
    +L' x1 x2 = +L x1 x2
    0L' : AbelianAdditiveGroupTerm
    0L' = 0L
    negL' :
      AbelianAdditiveGroupTerm ->
      AbelianAdditiveGroupTerm
    negL' x1 = negL x1
    stageB :
      AbelianAdditiveGroupTerm ->
      Staged AbelianAdditiveGroupTerm
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (0L) = Now 0L
    stageB (negL x1) =
      stage1 _ _ negL'
        (codeLift1 _ _ negL')
        (stageB x1)
    +Cl' :
      (A : Set) ->
      ClAbelianAdditiveGroupTerm A ->
      ClAbelianAdditiveGroupTerm A ->
      ClAbelianAdditiveGroupTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    0Cl' :
      (A : Set) ->
      ClAbelianAdditiveGroupTerm A
    0Cl' _ = 0Cl
    negCl' :
      (A : Set) ->
      ClAbelianAdditiveGroupTerm A ->
      ClAbelianAdditiveGroupTerm A
    negCl' _ x1 = negCl x1
    stageCl :
      (A : Set) ->
      ClAbelianAdditiveGroupTerm A ->
      Staged
        (ClAbelianAdditiveGroupTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (negCl x1) =
      stage1 _ _ (negCl' _)
        (codeLift1 _ _ (negCl' _))
        (stageCl _ x1)
    +OL' :
      (n : Nat) ->
      OpAbelianAdditiveGroupTerm n ->
      OpAbelianAdditiveGroupTerm n ->
      OpAbelianAdditiveGroupTerm n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      OpAbelianAdditiveGroupTerm n
    0OL' _ = 0OL
    negOL' :
      (n : Nat) ->
      OpAbelianAdditiveGroupTerm n ->
      OpAbelianAdditiveGroupTerm n
    negOL' _ x1 = negOL x1
    stageOp :
      (n : Nat) ->
      OpAbelianAdditiveGroupTerm n ->
      Staged
        (OpAbelianAdditiveGroupTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (0OL) = Now 0OL
    stageOp _ (negOL x1) =
      stage1 _ _ (negOL' _)
        (codeLift1 _ _ (negOL' _))
        (stageOp _ x1)
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAbelianAdditiveGroupTerm2 n
        A ->
      OpAbelianAdditiveGroupTerm2 n
        A ->
      OpAbelianAdditiveGroupTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    0OL2' :
      (n : Nat) (A : Set) ->
      OpAbelianAdditiveGroupTerm2 n A
    0OL2' _ _ = 0OL2
    negOL2' :
      (n : Nat) (A : Set) ->
      OpAbelianAdditiveGroupTerm2 n
        A ->
      OpAbelianAdditiveGroupTerm2 n A
    negOL2' _ _ x1 = negOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAbelianAdditiveGroupTerm2 n
        A ->
      Staged
        (OpAbelianAdditiveGroupTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (negOL2 x1) =
      stage1 _ _ (negOL2' _ _)
        (codeLift1 _ _ (negOL2' _ _))
        (stageOpE _ _ x1)
    record AbelianAdditiveGroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        +T : Repr A -> Repr A -> Repr A
        0T : Repr A
        negT : Repr A -> Repr A
  
  module AbelianGroup where
    record AbelianGroup
      (A : Set) : Set where
      constructor AbelianGroupC
      field
        1 : A
        * : A -> A -> A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        inv : A -> A
        leftInverse_inv_op_1 :
          (x : A) -> * x (inv x) == 1
        rightInverse_inv_op_1 :
          (x : A) -> * (inv x) x == 1
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
    record AbelianGroupSig
      (AS : Set) : Set where
      constructor AbelianGroupSigSigC
      field
        1S : AS
        *S : AS -> AS -> AS
        invS : AS -> AS
    record AbelianGroupProd
      (AP : Set) : Set where
      constructor AbelianGroupProdC
      field
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P xP (invP xP) == 1P
        rightInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P (invP xP) xP == 1P
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
    record AbelianGroupHom
      (A1 : Set) (A2 : Set)
      (Ab1 : AbelianGroup A1)
      (Ab2 : AbelianGroup A2) :
      Set where
      constructor AbelianGroupHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Ab1) == 1 Ab2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ab1 x1 x2) ==
            * Ab2 (hom x1) (hom x2)
        pres-inv :
          (x1 : A1) ->
          hom (inv Ab1 x1) ==
            inv Ab2 (hom x1)
    record AbelianGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ab1 : AbelianGroup A1)
      (Ab2 : AbelianGroup A2) :
      Set where
      constructor AbelianGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Ab1) (1 Ab2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ab1 x1 x2)
            (* Ab2 y1 y2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Ab1 x1) (inv Ab2 y1)
    data AbelianGroupTerm
      : Set where
      1L : AbelianGroupTerm
      *L :
        AbelianGroupTerm ->
        AbelianGroupTerm ->
        AbelianGroupTerm
      invL :
        AbelianGroupTerm ->
        AbelianGroupTerm
    data ClAbelianGroupTerm
      (A : Set) : Set where
      sing :
        A -> ClAbelianGroupTerm A
      1Cl : ClAbelianGroupTerm A
      *Cl :
        ClAbelianGroupTerm A ->
        ClAbelianGroupTerm A ->
        ClAbelianGroupTerm A
      invCl :
        ClAbelianGroupTerm A ->
        ClAbelianGroupTerm A
    data OpAbelianGroupTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpAbelianGroupTerm n
      1OL : OpAbelianGroupTerm n
      *OL :
        OpAbelianGroupTerm n ->
        OpAbelianGroupTerm n ->
        OpAbelianGroupTerm n
      invOL :
        OpAbelianGroupTerm n ->
        OpAbelianGroupTerm n
    data OpAbelianGroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpAbelianGroupTerm2 n A
      sing2 :
        A -> OpAbelianGroupTerm2 n A
      1OL2 : OpAbelianGroupTerm2 n A
      *OL2 :
        OpAbelianGroupTerm2 n A ->
        OpAbelianGroupTerm2 n A ->
        OpAbelianGroupTerm2 n A
      invOL2 :
        OpAbelianGroupTerm2 n A ->
        OpAbelianGroupTerm2 n A
    simplifyB :
      AbelianGroupTerm ->
      AbelianGroupTerm
    simplifyB (*L (1L) x) = x
    simplifyB (*L x (1L)) = x
    simplifyB (*L x (invL x)) = 1L
    simplifyB (*L (invL x) x) = 1L
    simplifyB (1L) = 1L
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (invL x1) =
      invL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClAbelianGroupTerm A ->
      ClAbelianGroupTerm A
    simplifyCl _ (*Cl (1Cl) x) = x
    simplifyCl _ (*Cl x (1Cl)) = x
    simplifyCl _ (*Cl x (invCl x)) =
      1Cl
    simplifyCl _ (*Cl (invCl x) x) =
      1Cl
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (invCl x1) =
      invCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAbelianGroupTerm n ->
      OpAbelianGroupTerm n
    simplifyOp _ (*OL (1OL) x) = x
    simplifyOp _ (*OL x (1OL)) = x
    simplifyOp _ (*OL x (invOL x)) =
      1OL
    simplifyOp _ (*OL (invOL x) x) =
      1OL
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (invOL x1) =
      invOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAbelianGroupTerm2 n A ->
      OpAbelianGroupTerm2 n A
    simplifyOpE _ _ (*OL2
                     (1OL2)
                     x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (1OL2)) = x
    simplifyOpE _ _ (*OL2
                     x
                     (invOL2 x)) = 1OL2
    simplifyOpE _ _ (*OL2
                     (invOL2 x)
                     x) = 1OL2
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (invOL2 x1) =
      invOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AbelianGroup A ->
      AbelianGroupTerm -> A
    evalB _ Ab (1L) = 1 Ab
    evalB _ Ab (*L x1 x2) =
      * Ab (evalB _ Ab x1)
        (evalB _ Ab x2)
    evalB _ Ab (invL x1) =
      inv Ab (evalB _ Ab x1)
    evalCl :
      (A : Set) ->
      AbelianGroup A ->
      ClAbelianGroupTerm A -> A
    evalCl _ Ab (sing x1) = x1
    evalCl _ Ab (1Cl) = 1 Ab
    evalCl _ Ab (*Cl x1 x2) =
      * Ab (evalCl _ Ab x1)
        (evalCl _ Ab x2)
    evalCl _ Ab (invCl x1) =
      inv Ab (evalCl _ Ab x1)
    evalOp :
      (A : Set) (n : Nat) ->
      AbelianGroup A ->
      Vec A n ->
      OpAbelianGroupTerm n -> A
    evalOp _ n Ab vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ab vars (1OL) = 1 Ab
    evalOp _ n Ab vars (*OL x1 x2) =
      * Ab (evalOp _ n Ab vars x1)
        (evalOp _ n Ab vars x2)
    evalOp _ n Ab vars (invOL x1) =
      inv Ab (evalOp _ n Ab vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      AbelianGroup A ->
      Vec A n ->
      OpAbelianGroupTerm2 n A -> A
    evalOpE _ n Ab vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ab vars (sing2 x1) =
      x1
    evalOpE _ n Ab vars (1OL2) =
      1 Ab
    evalOpE _ n Ab vars (*OL2
                         x1
                         x2) =
      * Ab (evalOpE _ n Ab vars x1)
        (evalOpE _ n Ab vars x2)
    evalOpE _ n Ab vars (invOL2
                         x1) =
      inv Ab (evalOpE _ n Ab vars x1)
    inductionB :
      (P : AbelianGroupTerm -> Set) ->
      P 1L ->
      ((x1 : AbelianGroupTerm)
       (x2 : AbelianGroupTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : AbelianGroupTerm) ->
       P x1 -> P (invL x1)) ->
      (x : AbelianGroupTerm) -> P x
    inductionB p p1l p*l pinvl (1L) =
      p1l
    inductionB p p1l p*l pinvl (*L
                                x1
                                x2) =
      p*l _ _
        (inductionB p p1l p*l pinvl x1)
        (inductionB p p1l p*l pinvl x2)
    inductionB p p1l p*l pinvl (invL
                                x1) =
      pinvl _
        (inductionB p p1l p*l pinvl x1)
    inductionCl :
      (A : Set)
      (P : ClAbelianGroupTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 1Cl ->
      ((x1 : ClAbelianGroupTerm A)
       (x2 : ClAbelianGroupTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClAbelianGroupTerm A) ->
       P x1 -> P (invCl x1)) ->
      (x : ClAbelianGroupTerm A) ->
      P x
    inductionCl _ p psing p1cl p*cl pinvcl (sing
                                            x1) = psing x1
    inductionCl _ p psing p1cl p*cl pinvcl (1Cl) =
      p1cl
    inductionCl _ p psing p1cl p*cl pinvcl (*Cl
                                            x1
                                            x2) =
      p*cl _ _
        (inductionCl _ p psing p1cl p*cl
           pinvcl
           x1)
        (inductionCl _ p psing p1cl p*cl
           pinvcl
           x2)
    inductionCl _ p psing p1cl p*cl pinvcl (invCl
                                            x1) =
      pinvcl _
        (inductionCl _ p psing p1cl p*cl
           pinvcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpAbelianGroupTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 1OL ->
      ((x1 : OpAbelianGroupTerm n)
       (x2 : OpAbelianGroupTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpAbelianGroupTerm n) ->
       P x1 -> P (invOL x1)) ->
      (x : OpAbelianGroupTerm n) ->
      P x
    inductionOp _ p pv p1ol p*ol pinvol (v
                                         x1) = pv x1
    inductionOp _ p pv p1ol p*ol pinvol (1OL) =
      p1ol
    inductionOp _ p pv p1ol p*ol pinvol (*OL
                                         x1
                                         x2) =
      p*ol _ _
        (inductionOp _ p pv p1ol p*ol
           pinvol
           x1)
        (inductionOp _ p pv p1ol p*ol
           pinvol
           x2)
    inductionOp _ p pv p1ol p*ol pinvol (invOL
                                         x1) =
      pinvol _
        (inductionOp _ p pv p1ol p*ol
           pinvol
           x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAbelianGroupTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 1OL2 ->
      ((x1 : OpAbelianGroupTerm2 n A)
       (x2 : OpAbelianGroupTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpAbelianGroupTerm2 n
          A) -> P x1 -> P (invOL2 x1)) ->
      (x : OpAbelianGroupTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p1ol2 p*ol2 pinvol2 (v2
                                                       x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p1ol2 p*ol2 pinvol2 (sing2
                                                       x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p1ol2 p*ol2 pinvol2 (1OL2) =
      p1ol2
    inductionOpE _ _ p pv2 psing2 p1ol2 p*ol2 pinvol2 (*OL2
                                                       x1
                                                       x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p1ol2
           p*ol2
           pinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p1ol2
           p*ol2
           pinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 p1ol2 p*ol2 pinvol2 (invOL2
                                                       x1) =
      pinvol2 _
        (inductionOpE _ _ p pv2 psing2
           p1ol2
           p*ol2
           pinvol2
           x1)
    1L' : AbelianGroupTerm
    1L' = 1L
    *L' :
      AbelianGroupTerm ->
      AbelianGroupTerm ->
      AbelianGroupTerm
    *L' x1 x2 = *L x1 x2
    invL' :
      AbelianGroupTerm ->
      AbelianGroupTerm
    invL' x1 = invL x1
    stageB :
      AbelianGroupTerm ->
      Staged AbelianGroupTerm
    stageB (1L) = Now 1L
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (invL x1) =
      stage1 _ _ invL'
        (codeLift1 _ _ invL')
        (stageB x1)
    1Cl' :
      (A : Set) ->
      ClAbelianGroupTerm A
    1Cl' _ = 1Cl
    *Cl' :
      (A : Set) ->
      ClAbelianGroupTerm A ->
      ClAbelianGroupTerm A ->
      ClAbelianGroupTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    invCl' :
      (A : Set) ->
      ClAbelianGroupTerm A ->
      ClAbelianGroupTerm A
    invCl' _ x1 = invCl x1
    stageCl :
      (A : Set) ->
      ClAbelianGroupTerm A ->
      Staged (ClAbelianGroupTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (1Cl) = Now 1Cl
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (invCl x1) =
      stage1 _ _ (invCl' _)
        (codeLift1 _ _ (invCl' _))
        (stageCl _ x1)
    1OL' :
      (n : Nat) ->
      OpAbelianGroupTerm n
    1OL' _ = 1OL
    *OL' :
      (n : Nat) ->
      OpAbelianGroupTerm n ->
      OpAbelianGroupTerm n ->
      OpAbelianGroupTerm n
    *OL' _ x1 x2 = *OL x1 x2
    invOL' :
      (n : Nat) ->
      OpAbelianGroupTerm n ->
      OpAbelianGroupTerm n
    invOL' _ x1 = invOL x1
    stageOp :
      (n : Nat) ->
      OpAbelianGroupTerm n ->
      Staged (OpAbelianGroupTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (1OL) = Now 1OL
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (invOL x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (stageOp _ x1)
    1OL2' :
      (n : Nat) (A : Set) ->
      OpAbelianGroupTerm2 n A
    1OL2' _ _ = 1OL2
    *OL2' :
      (n : Nat) (A : Set) ->
      OpAbelianGroupTerm2 n A ->
      OpAbelianGroupTerm2 n A ->
      OpAbelianGroupTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    invOL2' :
      (n : Nat) (A : Set) ->
      OpAbelianGroupTerm2 n A ->
      OpAbelianGroupTerm2 n A
    invOL2' _ _ x1 = invOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAbelianGroupTerm2 n A ->
      Staged (OpAbelianGroupTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (1OL2) = Now 1OL2
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (invOL2 x1) =
      stage1 _ _ (invOL2' _ _)
        (codeLift1 _ _ (invOL2' _ _))
        (stageOpE _ _ x1)
    record AbelianGroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        1T : Repr A
        *T : Repr A -> Repr A -> Repr A
        invT : Repr A -> Repr A
  
  module Absorption where
    record Absorption
      (A : Set) : Set where
      constructor AbsorptionC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
    record AbsorptionSig
      (AS : Set) : Set where
      constructor AbsorptionSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record AbsorptionProd
      (AP : Set) : Set where
      constructor AbsorptionProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
    record AbsorptionHom
      (A1 : Set) (A2 : Set)
      (Ab1 : Absorption A1)
      (Ab2 : Absorption A2) :
      Set where
      constructor AbsorptionHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ab1 x1 x2) ==
            * Ab2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ab1 x1 x2) ==
            + Ab2 (hom x1) (hom x2)
    record AbsorptionRelInterp
      (A1 : Set) (A2 : Set)
      (Ab1 : Absorption A1)
      (Ab2 : Absorption A2) :
      Set where
      constructor AbsorptionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ab1 x1 x2)
            (* Ab2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ab1 x1 x2)
            (+ Ab2 y1 y2)
    data AbsorptionTerm : Set where
      *L :
        AbsorptionTerm ->
        AbsorptionTerm -> AbsorptionTerm
      +L :
        AbsorptionTerm ->
        AbsorptionTerm -> AbsorptionTerm
    data ClAbsorptionTerm
      (A : Set) : Set where
      sing : A -> ClAbsorptionTerm A
      *Cl :
        ClAbsorptionTerm A ->
        ClAbsorptionTerm A ->
        ClAbsorptionTerm A
      +Cl :
        ClAbsorptionTerm A ->
        ClAbsorptionTerm A ->
        ClAbsorptionTerm A
    data OpAbsorptionTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpAbsorptionTerm n
      *OL :
        OpAbsorptionTerm n ->
        OpAbsorptionTerm n ->
        OpAbsorptionTerm n
      +OL :
        OpAbsorptionTerm n ->
        OpAbsorptionTerm n ->
        OpAbsorptionTerm n
    data OpAbsorptionTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpAbsorptionTerm2 n A
      sing2 :
        A -> OpAbsorptionTerm2 n A
      *OL2 :
        OpAbsorptionTerm2 n A ->
        OpAbsorptionTerm2 n A ->
        OpAbsorptionTerm2 n A
      +OL2 :
        OpAbsorptionTerm2 n A ->
        OpAbsorptionTerm2 n A ->
        OpAbsorptionTerm2 n A
    simplifyB :
      AbsorptionTerm -> AbsorptionTerm
    simplifyB (*L x (+L x y)) = x
    simplifyB (+L x (*L x y)) = x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClAbsorptionTerm A ->
      ClAbsorptionTerm A
    simplifyCl _ (*Cl x (+Cl x y)) =
      x
    simplifyCl _ (+Cl x (*Cl x y)) =
      x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAbsorptionTerm n ->
      OpAbsorptionTerm n
    simplifyOp _ (*OL x (+OL x y)) =
      x
    simplifyOp _ (+OL x (*OL x y)) =
      x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAbsorptionTerm2 n A ->
      OpAbsorptionTerm2 n A
    simplifyOpE _ _ (*OL2
                     x
                     (+OL2 x y)) = x
    simplifyOpE _ _ (+OL2
                     x
                     (*OL2 x y)) = x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Absorption A ->
      AbsorptionTerm -> A
    evalB _ Ab (*L x1 x2) =
      * Ab (evalB _ Ab x1)
        (evalB _ Ab x2)
    evalB _ Ab (+L x1 x2) =
      + Ab (evalB _ Ab x1)
        (evalB _ Ab x2)
    evalCl :
      (A : Set) ->
      Absorption A ->
      ClAbsorptionTerm A -> A
    evalCl _ Ab (sing x1) = x1
    evalCl _ Ab (*Cl x1 x2) =
      * Ab (evalCl _ Ab x1)
        (evalCl _ Ab x2)
    evalCl _ Ab (+Cl x1 x2) =
      + Ab (evalCl _ Ab x1)
        (evalCl _ Ab x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Absorption A ->
      Vec A n ->
      OpAbsorptionTerm n -> A
    evalOp _ n Ab vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ab vars (*OL x1 x2) =
      * Ab (evalOp _ n Ab vars x1)
        (evalOp _ n Ab vars x2)
    evalOp _ n Ab vars (+OL x1 x2) =
      + Ab (evalOp _ n Ab vars x1)
        (evalOp _ n Ab vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Absorption A ->
      Vec A n ->
      OpAbsorptionTerm2 n A -> A
    evalOpE _ n Ab vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ab vars (sing2 x1) =
      x1
    evalOpE _ n Ab vars (*OL2
                         x1
                         x2) =
      * Ab (evalOpE _ n Ab vars x1)
        (evalOpE _ n Ab vars x2)
    evalOpE _ n Ab vars (+OL2
                         x1
                         x2) =
      + Ab (evalOpE _ n Ab vars x1)
        (evalOpE _ n Ab vars x2)
    inductionB :
      (P : AbsorptionTerm -> Set) ->
      ((x1 : AbsorptionTerm)
       (x2 : AbsorptionTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : AbsorptionTerm)
       (x2 : AbsorptionTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : AbsorptionTerm) -> P x
    inductionB p p*l p+l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionB p p*l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClAbsorptionTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClAbsorptionTerm A)
       (x2 : ClAbsorptionTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClAbsorptionTerm A)
       (x2 : ClAbsorptionTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClAbsorptionTerm A) -> P x
    inductionCl _ p psing p*cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p*cl p+cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionCl _ p psing p*cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpAbsorptionTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpAbsorptionTerm n)
       (x2 : OpAbsorptionTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpAbsorptionTerm n)
       (x2 : OpAbsorptionTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpAbsorptionTerm n) -> P x
    inductionOp _ p pv p*ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p*ol p+ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOp _ p pv p*ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAbsorptionTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpAbsorptionTerm2 n A)
       (x2 : OpAbsorptionTerm2 n A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpAbsorptionTerm2 n A)
       (x2 : OpAbsorptionTerm2 n A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpAbsorptionTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    *L' :
      AbsorptionTerm ->
      AbsorptionTerm -> AbsorptionTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      AbsorptionTerm ->
      AbsorptionTerm -> AbsorptionTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      AbsorptionTerm ->
      Staged AbsorptionTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClAbsorptionTerm A ->
      ClAbsorptionTerm A ->
      ClAbsorptionTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClAbsorptionTerm A ->
      ClAbsorptionTerm A ->
      ClAbsorptionTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClAbsorptionTerm A ->
      Staged (ClAbsorptionTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpAbsorptionTerm n ->
      OpAbsorptionTerm n ->
      OpAbsorptionTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpAbsorptionTerm n ->
      OpAbsorptionTerm n ->
      OpAbsorptionTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpAbsorptionTerm n ->
      Staged (OpAbsorptionTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpAbsorptionTerm2 n A ->
      OpAbsorptionTerm2 n A ->
      OpAbsorptionTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAbsorptionTerm2 n A ->
      OpAbsorptionTerm2 n A ->
      OpAbsorptionTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAbsorptionTerm2 n A ->
      Staged (OpAbsorptionTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record AbsorptionTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module AddCommMonWithMultMagma where
    record AddCommMonWithMultMagma
      (A : Set) : Set where
      constructor AddCommMonWithMultMagmaC
      field
        0 : A
        + : A -> A -> A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        * : A -> A -> A
    record AddCommMonWithMultMagmaSig
      (AS : Set) : Set where
      constructor AddCommMonWithMultMagmaSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
    record AddCommMonWithMultMagmaProd
      (AP : Set) : Set where
      constructor AddCommMonWithMultMagmaProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
    record AddCommMonWithMultMagmaHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AddCommMonWithMultMagma
         A1)
      (Ad2 : AddCommMonWithMultMagma
         A2) : Set where
      constructor AddCommMonWithMultMagmaHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ad1 x1 x2) ==
            * Ad2 (hom x1) (hom x2)
    record AddCommMonWithMultMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AddCommMonWithMultMagma
         A1)
      (Ad2 : AddCommMonWithMultMagma
         A2) : Set where
      constructor AddCommMonWithMultMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ad1 x1 x2)
            (* Ad2 y1 y2)
    data AddCommMonWithMultMagmaTerm
      : Set where
      0L :
        AddCommMonWithMultMagmaTerm
      +L :
        AddCommMonWithMultMagmaTerm ->
        AddCommMonWithMultMagmaTerm ->
        AddCommMonWithMultMagmaTerm
      *L :
        AddCommMonWithMultMagmaTerm ->
        AddCommMonWithMultMagmaTerm ->
        AddCommMonWithMultMagmaTerm
    data ClAddCommMonWithMultMagmaTerm
      (A : Set) : Set where
      sing :
        A ->
        ClAddCommMonWithMultMagmaTerm A
      0Cl :
        ClAddCommMonWithMultMagmaTerm A
      +Cl :
        ClAddCommMonWithMultMagmaTerm
          A ->
        ClAddCommMonWithMultMagmaTerm
          A ->
        ClAddCommMonWithMultMagmaTerm A
      *Cl :
        ClAddCommMonWithMultMagmaTerm
          A ->
        ClAddCommMonWithMultMagmaTerm
          A ->
        ClAddCommMonWithMultMagmaTerm A
    data OpAddCommMonWithMultMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpAddCommMonWithMultMagmaTerm n
      0OL :
        OpAddCommMonWithMultMagmaTerm n
      +OL :
        OpAddCommMonWithMultMagmaTerm
          n ->
        OpAddCommMonWithMultMagmaTerm
          n ->
        OpAddCommMonWithMultMagmaTerm n
      *OL :
        OpAddCommMonWithMultMagmaTerm
          n ->
        OpAddCommMonWithMultMagmaTerm
          n ->
        OpAddCommMonWithMultMagmaTerm n
    data OpAddCommMonWithMultMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAddCommMonWithMultMagmaTerm2 n
          A
      sing2 :
        A ->
        OpAddCommMonWithMultMagmaTerm2 n
          A
      0OL2 :
        OpAddCommMonWithMultMagmaTerm2 n
          A
      +OL2 :
        OpAddCommMonWithMultMagmaTerm2 n
          A ->
        OpAddCommMonWithMultMagmaTerm2 n
          A ->
        OpAddCommMonWithMultMagmaTerm2 n
          A
      *OL2 :
        OpAddCommMonWithMultMagmaTerm2 n
          A ->
        OpAddCommMonWithMultMagmaTerm2 n
          A ->
        OpAddCommMonWithMultMagmaTerm2 n
          A
    simplifyB :
      AddCommMonWithMultMagmaTerm ->
      AddCommMonWithMultMagmaTerm
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (0L) = 0L
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClAddCommMonWithMultMagmaTerm
        A ->
      ClAddCommMonWithMultMagmaTerm A
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAddCommMonWithMultMagmaTerm
        n ->
      OpAddCommMonWithMultMagmaTerm n
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAddCommMonWithMultMagmaTerm2 n
        A ->
      OpAddCommMonWithMultMagmaTerm2 n
        A
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AddCommMonWithMultMagma A ->
      AddCommMonWithMultMagmaTerm -> A
    evalB _ Ad (0L) = 0 Ad
    evalB _ Ad (+L x1 x2) =
      + Ad (evalB _ Ad x1)
        (evalB _ Ad x2)
    evalB _ Ad (*L x1 x2) =
      * Ad (evalB _ Ad x1)
        (evalB _ Ad x2)
    evalCl :
      (A : Set) ->
      AddCommMonWithMultMagma A ->
      ClAddCommMonWithMultMagmaTerm
        A -> A
    evalCl _ Ad (sing x1) = x1
    evalCl _ Ad (0Cl) = 0 Ad
    evalCl _ Ad (+Cl x1 x2) =
      + Ad (evalCl _ Ad x1)
        (evalCl _ Ad x2)
    evalCl _ Ad (*Cl x1 x2) =
      * Ad (evalCl _ Ad x1)
        (evalCl _ Ad x2)
    evalOp :
      (A : Set) (n : Nat) ->
      AddCommMonWithMultMagma A ->
      Vec A n ->
      OpAddCommMonWithMultMagmaTerm
        n -> A
    evalOp _ n Ad vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ad vars (0OL) = 0 Ad
    evalOp _ n Ad vars (+OL x1 x2) =
      + Ad (evalOp _ n Ad vars x1)
        (evalOp _ n Ad vars x2)
    evalOp _ n Ad vars (*OL x1 x2) =
      * Ad (evalOp _ n Ad vars x1)
        (evalOp _ n Ad vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      AddCommMonWithMultMagma A ->
      Vec A n ->
      OpAddCommMonWithMultMagmaTerm2 n
        A -> A
    evalOpE _ n Ad vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ad vars (sing2 x1) =
      x1
    evalOpE _ n Ad vars (0OL2) =
      0 Ad
    evalOpE _ n Ad vars (+OL2
                         x1
                         x2) =
      + Ad (evalOpE _ n Ad vars x1)
        (evalOpE _ n Ad vars x2)
    evalOpE _ n Ad vars (*OL2
                         x1
                         x2) =
      * Ad (evalOpE _ n Ad vars x1)
        (evalOpE _ n Ad vars x2)
    inductionB :
      (P : AddCommMonWithMultMagmaTerm ->
           Set) ->
      P 0L ->
      ((x1 : AddCommMonWithMultMagmaTerm)
       (x2 : AddCommMonWithMultMagmaTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      ((x1 : AddCommMonWithMultMagmaTerm)
       (x2 : AddCommMonWithMultMagmaTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      (x : AddCommMonWithMultMagmaTerm) ->
      P x
    inductionB p p0l p+l p*l (0L) =
      p0l
    inductionB p p0l p+l p*l (+L
                              x1
                              x2) =
      p+l _ _
        (inductionB p p0l p+l p*l x1)
        (inductionB p p0l p+l p*l x2)
    inductionB p p0l p+l p*l (*L
                              x1
                              x2) =
      p*l _ _
        (inductionB p p0l p+l p*l x1)
        (inductionB p p0l p+l p*l x2)
    inductionCl :
      (A : Set)
      (P : ClAddCommMonWithMultMagmaTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 0Cl ->
      ((x1 : ClAddCommMonWithMultMagmaTerm
          A)
       (x2 : ClAddCommMonWithMultMagmaTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      ((x1 : ClAddCommMonWithMultMagmaTerm
          A)
       (x2 : ClAddCommMonWithMultMagmaTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      (x : ClAddCommMonWithMultMagmaTerm
         A) -> P x
    inductionCl _ p psing p0cl p+cl p*cl (sing
                                          x1) = psing x1
    inductionCl _ p psing p0cl p+cl p*cl (0Cl) =
      p0cl
    inductionCl _ p psing p0cl p+cl p*cl (+Cl
                                          x1
                                          x2) =
      p+cl _ _
        (inductionCl _ p psing p0cl p+cl
           p*cl
           x1)
        (inductionCl _ p psing p0cl p+cl
           p*cl
           x2)
    inductionCl _ p psing p0cl p+cl p*cl (*Cl
                                          x1
                                          x2) =
      p*cl _ _
        (inductionCl _ p psing p0cl p+cl
           p*cl
           x1)
        (inductionCl _ p psing p0cl p+cl
           p*cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpAddCommMonWithMultMagmaTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 0OL ->
      ((x1 : OpAddCommMonWithMultMagmaTerm
          n)
       (x2 : OpAddCommMonWithMultMagmaTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      ((x1 : OpAddCommMonWithMultMagmaTerm
          n)
       (x2 : OpAddCommMonWithMultMagmaTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      (x : OpAddCommMonWithMultMagmaTerm
         n) -> P x
    inductionOp _ p pv p0ol p+ol p*ol (v
                                       x1) = pv x1
    inductionOp _ p pv p0ol p+ol p*ol (0OL) =
      p0ol
    inductionOp _ p pv p0ol p+ol p*ol (+OL
                                       x1
                                       x2) =
      p+ol _ _
        (inductionOp _ p pv p0ol p+ol
           p*ol
           x1)
        (inductionOp _ p pv p0ol p+ol
           p*ol
           x2)
    inductionOp _ p pv p0ol p+ol p*ol (*OL
                                       x1
                                       x2) =
      p*ol _ _
        (inductionOp _ p pv p0ol p+ol
           p*ol
           x1)
        (inductionOp _ p pv p0ol p+ol
           p*ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAddCommMonWithMultMagmaTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 0OL2 ->
      ((x1 : OpAddCommMonWithMultMagmaTerm2
          n
          A)
       (x2 : OpAddCommMonWithMultMagmaTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      ((x1 : OpAddCommMonWithMultMagmaTerm2
          n
          A)
       (x2 : OpAddCommMonWithMultMagmaTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      (x : OpAddCommMonWithMultMagmaTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 (v2
                                                     x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 (sing2
                                                     x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 (+OL2
                                                     x1
                                                     x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           p*ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 (*OL2
                                                     x1
                                                     x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           p*ol2
           x2)
    0L' :
      AddCommMonWithMultMagmaTerm
    0L' = 0L
    +L' :
      AddCommMonWithMultMagmaTerm ->
      AddCommMonWithMultMagmaTerm ->
      AddCommMonWithMultMagmaTerm
    +L' x1 x2 = +L x1 x2
    *L' :
      AddCommMonWithMultMagmaTerm ->
      AddCommMonWithMultMagmaTerm ->
      AddCommMonWithMultMagmaTerm
    *L' x1 x2 = *L x1 x2
    stageB :
      AddCommMonWithMultMagmaTerm ->
      Staged
        AddCommMonWithMultMagmaTerm
    stageB (0L) = Now 0L
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    0Cl' :
      (A : Set) ->
      ClAddCommMonWithMultMagmaTerm A
    0Cl' _ = 0Cl
    +Cl' :
      (A : Set) ->
      ClAddCommMonWithMultMagmaTerm
        A ->
      ClAddCommMonWithMultMagmaTerm
        A ->
      ClAddCommMonWithMultMagmaTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    *Cl' :
      (A : Set) ->
      ClAddCommMonWithMultMagmaTerm
        A ->
      ClAddCommMonWithMultMagmaTerm
        A ->
      ClAddCommMonWithMultMagmaTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    stageCl :
      (A : Set) ->
      ClAddCommMonWithMultMagmaTerm
        A ->
      Staged
        (ClAddCommMonWithMultMagmaTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    0OL' :
      (n : Nat) ->
      OpAddCommMonWithMultMagmaTerm n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      OpAddCommMonWithMultMagmaTerm
        n ->
      OpAddCommMonWithMultMagmaTerm
        n ->
      OpAddCommMonWithMultMagmaTerm n
    +OL' _ x1 x2 = +OL x1 x2
    *OL' :
      (n : Nat) ->
      OpAddCommMonWithMultMagmaTerm
        n ->
      OpAddCommMonWithMultMagmaTerm
        n ->
      OpAddCommMonWithMultMagmaTerm n
    *OL' _ x1 x2 = *OL x1 x2
    stageOp :
      (n : Nat) ->
      OpAddCommMonWithMultMagmaTerm
        n ->
      Staged
        (OpAddCommMonWithMultMagmaTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (0OL) = Now 0OL
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    0OL2' :
      (n : Nat) (A : Set) ->
      OpAddCommMonWithMultMagmaTerm2 n
        A
    0OL2' _ _ = 0OL2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAddCommMonWithMultMagmaTerm2 n
        A ->
      OpAddCommMonWithMultMagmaTerm2 n
        A ->
      OpAddCommMonWithMultMagmaTerm2 n
        A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    *OL2' :
      (n : Nat) (A : Set) ->
      OpAddCommMonWithMultMagmaTerm2 n
        A ->
      OpAddCommMonWithMultMagmaTerm2 n
        A ->
      OpAddCommMonWithMultMagmaTerm2 n
        A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAddCommMonWithMultMagmaTerm2 n
        A ->
      Staged
        (OpAddCommMonWithMultMagmaTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record AddCommMonWithMultMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        0T : Repr A
        +T : Repr A -> Repr A -> Repr A
        *T : Repr A -> Repr A -> Repr A
  
  module AddCommMonWithMultSemigroup where
    record AddCommMonWithMultSemigroup
      (A : Set) : Set where
      constructor AddCommMonWithMultSemigroupC
      field
        * : A -> A -> A
        0 : A
        + : A -> A -> A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
    record AddCommMonWithMultSemigroupSig
      (AS : Set) : Set where
      constructor AddCommMonWithMultSemigroupSigSigC
      field
        *S : AS -> AS -> AS
        0S : AS
        +S : AS -> AS -> AS
    record AddCommMonWithMultSemigroupProd
      (AP : Set) : Set where
      constructor AddCommMonWithMultSemigroupProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
    record AddCommMonWithMultSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AddCommMonWithMultSemigroup
         A1)
      (Ad2 : AddCommMonWithMultSemigroup
         A2) : Set where
      constructor AddCommMonWithMultSemigroupHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ad1 x1 x2) ==
            * Ad2 (hom x1) (hom x2)
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AddCommMonWithMultSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AddCommMonWithMultSemigroup
         A1)
      (Ad2 : AddCommMonWithMultSemigroup
         A2) : Set where
      constructor AddCommMonWithMultSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ad1 x1 x2)
            (* Ad2 y1 y2)
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AddCommMonWithMultSemigroupTerm
      : Set where
      *L :
        AddCommMonWithMultSemigroupTerm ->
        AddCommMonWithMultSemigroupTerm ->
        AddCommMonWithMultSemigroupTerm
      0L :
        AddCommMonWithMultSemigroupTerm
      +L :
        AddCommMonWithMultSemigroupTerm ->
        AddCommMonWithMultSemigroupTerm ->
        AddCommMonWithMultSemigroupTerm
    data ClAddCommMonWithMultSemigroupTerm
      (A : Set) : Set where
      sing :
        A ->
        ClAddCommMonWithMultSemigroupTerm
          A
      *Cl :
        ClAddCommMonWithMultSemigroupTerm
          A ->
        ClAddCommMonWithMultSemigroupTerm
          A ->
        ClAddCommMonWithMultSemigroupTerm
          A
      0Cl :
        ClAddCommMonWithMultSemigroupTerm
          A
      +Cl :
        ClAddCommMonWithMultSemigroupTerm
          A ->
        ClAddCommMonWithMultSemigroupTerm
          A ->
        ClAddCommMonWithMultSemigroupTerm
          A
    data OpAddCommMonWithMultSemigroupTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpAddCommMonWithMultSemigroupTerm
          n
      *OL :
        OpAddCommMonWithMultSemigroupTerm
          n ->
        OpAddCommMonWithMultSemigroupTerm
          n ->
        OpAddCommMonWithMultSemigroupTerm
          n
      0OL :
        OpAddCommMonWithMultSemigroupTerm
          n
      +OL :
        OpAddCommMonWithMultSemigroupTerm
          n ->
        OpAddCommMonWithMultSemigroupTerm
          n ->
        OpAddCommMonWithMultSemigroupTerm
          n
    data OpAddCommMonWithMultSemigroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAddCommMonWithMultSemigroupTerm2
          n
          A
      sing2 :
        A ->
        OpAddCommMonWithMultSemigroupTerm2
          n
          A
      *OL2 :
        OpAddCommMonWithMultSemigroupTerm2
          n
          A ->
        OpAddCommMonWithMultSemigroupTerm2
          n
          A ->
        OpAddCommMonWithMultSemigroupTerm2
          n
          A
      0OL2 :
        OpAddCommMonWithMultSemigroupTerm2
          n
          A
      +OL2 :
        OpAddCommMonWithMultSemigroupTerm2
          n
          A ->
        OpAddCommMonWithMultSemigroupTerm2
          n
          A ->
        OpAddCommMonWithMultSemigroupTerm2
          n
          A
    simplifyB :
      AddCommMonWithMultSemigroupTerm ->
      AddCommMonWithMultSemigroupTerm
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (0L) = 0L
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClAddCommMonWithMultSemigroupTerm
        A ->
      ClAddCommMonWithMultSemigroupTerm
        A
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAddCommMonWithMultSemigroupTerm
        n ->
      OpAddCommMonWithMultSemigroupTerm
        n
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAddCommMonWithMultSemigroupTerm2
        n
        A ->
      OpAddCommMonWithMultSemigroupTerm2
        n
        A
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AddCommMonWithMultSemigroup A ->
      AddCommMonWithMultSemigroupTerm ->
      A
    evalB _ Ad (*L x1 x2) =
      * Ad (evalB _ Ad x1)
        (evalB _ Ad x2)
    evalB _ Ad (0L) = 0 Ad
    evalB _ Ad (+L x1 x2) =
      + Ad (evalB _ Ad x1)
        (evalB _ Ad x2)
    evalCl :
      (A : Set) ->
      AddCommMonWithMultSemigroup A ->
      ClAddCommMonWithMultSemigroupTerm
        A -> A
    evalCl _ Ad (sing x1) = x1
    evalCl _ Ad (*Cl x1 x2) =
      * Ad (evalCl _ Ad x1)
        (evalCl _ Ad x2)
    evalCl _ Ad (0Cl) = 0 Ad
    evalCl _ Ad (+Cl x1 x2) =
      + Ad (evalCl _ Ad x1)
        (evalCl _ Ad x2)
    evalOp :
      (A : Set) (n : Nat) ->
      AddCommMonWithMultSemigroup A ->
      Vec A n ->
      OpAddCommMonWithMultSemigroupTerm
        n -> A
    evalOp _ n Ad vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ad vars (*OL x1 x2) =
      * Ad (evalOp _ n Ad vars x1)
        (evalOp _ n Ad vars x2)
    evalOp _ n Ad vars (0OL) = 0 Ad
    evalOp _ n Ad vars (+OL x1 x2) =
      + Ad (evalOp _ n Ad vars x1)
        (evalOp _ n Ad vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      AddCommMonWithMultSemigroup A ->
      Vec A n ->
      OpAddCommMonWithMultSemigroupTerm2
        n
        A -> A
    evalOpE _ n Ad vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ad vars (sing2 x1) =
      x1
    evalOpE _ n Ad vars (*OL2
                         x1
                         x2) =
      * Ad (evalOpE _ n Ad vars x1)
        (evalOpE _ n Ad vars x2)
    evalOpE _ n Ad vars (0OL2) =
      0 Ad
    evalOpE _ n Ad vars (+OL2
                         x1
                         x2) =
      + Ad (evalOpE _ n Ad vars x1)
        (evalOpE _ n Ad vars x2)
    inductionB :
      (P : AddCommMonWithMultSemigroupTerm ->
           Set) ->
      ((x1 : AddCommMonWithMultSemigroupTerm)
       (x2 : AddCommMonWithMultSemigroupTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      P 0L ->
      ((x1 : AddCommMonWithMultSemigroupTerm)
       (x2 : AddCommMonWithMultSemigroupTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : AddCommMonWithMultSemigroupTerm) ->
      P x
    inductionB p p*l p0l p+l (*L
                              x1
                              x2) =
      p*l _ _
        (inductionB p p*l p0l p+l x1)
        (inductionB p p*l p0l p+l x2)
    inductionB p p*l p0l p+l (0L) =
      p0l
    inductionB p p*l p0l p+l (+L
                              x1
                              x2) =
      p+l _ _
        (inductionB p p*l p0l p+l x1)
        (inductionB p p*l p0l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClAddCommMonWithMultSemigroupTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClAddCommMonWithMultSemigroupTerm
          A)
       (x2 : ClAddCommMonWithMultSemigroupTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      P 0Cl ->
      ((x1 : ClAddCommMonWithMultSemigroupTerm
          A)
       (x2 : ClAddCommMonWithMultSemigroupTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClAddCommMonWithMultSemigroupTerm
         A) -> P x
    inductionCl _ p psing p*cl p0cl p+cl (sing
                                          x1) = psing x1
    inductionCl _ p psing p*cl p0cl p+cl (*Cl
                                          x1
                                          x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p0cl
           p+cl
           x1)
        (inductionCl _ p psing p*cl p0cl
           p+cl
           x2)
    inductionCl _ p psing p*cl p0cl p+cl (0Cl) =
      p0cl
    inductionCl _ p psing p*cl p0cl p+cl (+Cl
                                          x1
                                          x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p0cl
           p+cl
           x1)
        (inductionCl _ p psing p*cl p0cl
           p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpAddCommMonWithMultSemigroupTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpAddCommMonWithMultSemigroupTerm
          n)
       (x2 : OpAddCommMonWithMultSemigroupTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      P 0OL ->
      ((x1 : OpAddCommMonWithMultSemigroupTerm
          n)
       (x2 : OpAddCommMonWithMultSemigroupTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpAddCommMonWithMultSemigroupTerm
         n) -> P x
    inductionOp _ p pv p*ol p0ol p+ol (v
                                       x1) = pv x1
    inductionOp _ p pv p*ol p0ol p+ol (*OL
                                       x1
                                       x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p0ol
           p+ol
           x1)
        (inductionOp _ p pv p*ol p0ol
           p+ol
           x2)
    inductionOp _ p pv p*ol p0ol p+ol (0OL) =
      p0ol
    inductionOp _ p pv p*ol p0ol p+ol (+OL
                                       x1
                                       x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p0ol
           p+ol
           x1)
        (inductionOp _ p pv p*ol p0ol
           p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAddCommMonWithMultSemigroupTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpAddCommMonWithMultSemigroupTerm2
          n
          A)
       (x2 : OpAddCommMonWithMultSemigroupTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      P 0OL2 ->
      ((x1 : OpAddCommMonWithMultSemigroupTerm2
          n
          A)
       (x2 : OpAddCommMonWithMultSemigroupTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpAddCommMonWithMultSemigroupTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p0ol2 p+ol2 (v2
                                                     x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p0ol2 p+ol2 (sing2
                                                     x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p0ol2 p+ol2 (*OL2
                                                     x1
                                                     x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p0ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p0ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p0ol2 p+ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p*ol2 p0ol2 p+ol2 (+OL2
                                                     x1
                                                     x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p0ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p0ol2
           p+ol2
           x2)
    *L' :
      AddCommMonWithMultSemigroupTerm ->
      AddCommMonWithMultSemigroupTerm ->
      AddCommMonWithMultSemigroupTerm
    *L' x1 x2 = *L x1 x2
    0L' :
      AddCommMonWithMultSemigroupTerm
    0L' = 0L
    +L' :
      AddCommMonWithMultSemigroupTerm ->
      AddCommMonWithMultSemigroupTerm ->
      AddCommMonWithMultSemigroupTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      AddCommMonWithMultSemigroupTerm ->
      Staged
        AddCommMonWithMultSemigroupTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (0L) = Now 0L
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClAddCommMonWithMultSemigroupTerm
        A ->
      ClAddCommMonWithMultSemigroupTerm
        A ->
      ClAddCommMonWithMultSemigroupTerm
        A
    *Cl' _ x1 x2 = *Cl x1 x2
    0Cl' :
      (A : Set) ->
      ClAddCommMonWithMultSemigroupTerm
        A
    0Cl' _ = 0Cl
    +Cl' :
      (A : Set) ->
      ClAddCommMonWithMultSemigroupTerm
        A ->
      ClAddCommMonWithMultSemigroupTerm
        A ->
      ClAddCommMonWithMultSemigroupTerm
        A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClAddCommMonWithMultSemigroupTerm
        A ->
      Staged
        (ClAddCommMonWithMultSemigroupTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpAddCommMonWithMultSemigroupTerm
        n ->
      OpAddCommMonWithMultSemigroupTerm
        n ->
      OpAddCommMonWithMultSemigroupTerm
        n
    *OL' _ x1 x2 = *OL x1 x2
    0OL' :
      (n : Nat) ->
      OpAddCommMonWithMultSemigroupTerm
        n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      OpAddCommMonWithMultSemigroupTerm
        n ->
      OpAddCommMonWithMultSemigroupTerm
        n ->
      OpAddCommMonWithMultSemigroupTerm
        n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpAddCommMonWithMultSemigroupTerm
        n ->
      Staged
        (OpAddCommMonWithMultSemigroupTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (0OL) = Now 0OL
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpAddCommMonWithMultSemigroupTerm2
        n
        A ->
      OpAddCommMonWithMultSemigroupTerm2
        n
        A ->
      OpAddCommMonWithMultSemigroupTerm2
        n
        A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    0OL2' :
      (n : Nat) (A : Set) ->
      OpAddCommMonWithMultSemigroupTerm2
        n
        A
    0OL2' _ _ = 0OL2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAddCommMonWithMultSemigroupTerm2
        n
        A ->
      OpAddCommMonWithMultSemigroupTerm2
        n
        A ->
      OpAddCommMonWithMultSemigroupTerm2
        n
        A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAddCommMonWithMultSemigroupTerm2
        n
        A ->
      Staged
        (OpAddCommMonWithMultSemigroupTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record AddCommMonWithMultSemigroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        0T : Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module AddGroup_RingoidSig where
    record AddGroup_RingoidSig
      (A : Set) : Set where
      constructor AddGroup_RingoidSigC
      field
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        * : A -> A -> A
    record AddGroup_RingoidSigSig
      (AS : Set) : Set where
      constructor AddGroup_RingoidSigSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
        *S : AS -> AS -> AS
    record AddGroup_RingoidSigProd
      (AP : Set) : Set where
      constructor AddGroup_RingoidSigProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
    record AddGroup_RingoidSigHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AddGroup_RingoidSig A1)
      (Ad2 : AddGroup_RingoidSig A2) :
      Set where
      constructor AddGroup_RingoidSigHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-neg :
          (x1 : A1) ->
          hom (neg Ad1 x1) ==
            neg Ad2 (hom x1)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ad1 x1 x2) ==
            * Ad2 (hom x1) (hom x2)
    record AddGroup_RingoidSigRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AddGroup_RingoidSig A1)
      (Ad2 : AddGroup_RingoidSig A2) :
      Set where
      constructor AddGroup_RingoidSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Ad1 x1) (neg Ad2 y1)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ad1 x1 x2)
            (* Ad2 y1 y2)
    data AddGroup_RingoidSigTerm
      : Set where
      +L :
        AddGroup_RingoidSigTerm ->
        AddGroup_RingoidSigTerm ->
        AddGroup_RingoidSigTerm
      0L : AddGroup_RingoidSigTerm
      negL :
        AddGroup_RingoidSigTerm ->
        AddGroup_RingoidSigTerm
      *L :
        AddGroup_RingoidSigTerm ->
        AddGroup_RingoidSigTerm ->
        AddGroup_RingoidSigTerm
    data ClAddGroup_RingoidSigTerm
      (A : Set) : Set where
      sing :
        A -> ClAddGroup_RingoidSigTerm A
      +Cl :
        ClAddGroup_RingoidSigTerm A ->
        ClAddGroup_RingoidSigTerm A ->
        ClAddGroup_RingoidSigTerm A
      0Cl :
        ClAddGroup_RingoidSigTerm A
      negCl :
        ClAddGroup_RingoidSigTerm A ->
        ClAddGroup_RingoidSigTerm A
      *Cl :
        ClAddGroup_RingoidSigTerm A ->
        ClAddGroup_RingoidSigTerm A ->
        ClAddGroup_RingoidSigTerm A
    data OpAddGroup_RingoidSigTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpAddGroup_RingoidSigTerm n
      +OL :
        OpAddGroup_RingoidSigTerm n ->
        OpAddGroup_RingoidSigTerm n ->
        OpAddGroup_RingoidSigTerm n
      0OL :
        OpAddGroup_RingoidSigTerm n
      negOL :
        OpAddGroup_RingoidSigTerm n ->
        OpAddGroup_RingoidSigTerm n
      *OL :
        OpAddGroup_RingoidSigTerm n ->
        OpAddGroup_RingoidSigTerm n ->
        OpAddGroup_RingoidSigTerm n
    data OpAddGroup_RingoidSigTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAddGroup_RingoidSigTerm2 n A
      sing2 :
        A ->
        OpAddGroup_RingoidSigTerm2 n A
      +OL2 :
        OpAddGroup_RingoidSigTerm2 n
          A ->
        OpAddGroup_RingoidSigTerm2 n
          A ->
        OpAddGroup_RingoidSigTerm2 n A
      0OL2 :
        OpAddGroup_RingoidSigTerm2 n A
      negOL2 :
        OpAddGroup_RingoidSigTerm2 n
          A ->
        OpAddGroup_RingoidSigTerm2 n A
      *OL2 :
        OpAddGroup_RingoidSigTerm2 n
          A ->
        OpAddGroup_RingoidSigTerm2 n
          A ->
        OpAddGroup_RingoidSigTerm2 n A
    simplifyB :
      AddGroup_RingoidSigTerm ->
      AddGroup_RingoidSigTerm
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (+L x (negL x)) = 0L
    simplifyB (+L (negL x) x) = 0L
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (0L) = 0L
    simplifyB (negL x1) =
      negL (simplifyB x1)
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClAddGroup_RingoidSigTerm A ->
      ClAddGroup_RingoidSigTerm A
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (+Cl x (negCl x)) =
      0Cl
    simplifyCl _ (+Cl (negCl x) x) =
      0Cl
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (negCl x1) =
      negCl (simplifyCl _ x1)
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAddGroup_RingoidSigTerm n ->
      OpAddGroup_RingoidSigTerm n
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (+OL x (negOL x)) =
      0OL
    simplifyOp _ (+OL (negOL x) x) =
      0OL
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (negOL x1) =
      negOL (simplifyOp _ x1)
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAddGroup_RingoidSigTerm2 n
        A ->
      OpAddGroup_RingoidSigTerm2 n A
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (+OL2
                     x
                     (negOL2 x)) = 0OL2
    simplifyOpE _ _ (+OL2
                     (negOL2 x)
                     x) = 0OL2
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (negOL2 x1) =
      negOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AddGroup_RingoidSig A ->
      AddGroup_RingoidSigTerm -> A
    evalB _ Ad (+L x1 x2) =
      + Ad (evalB _ Ad x1)
        (evalB _ Ad x2)
    evalB _ Ad (0L) = 0 Ad
    evalB _ Ad (negL x1) =
      neg Ad (evalB _ Ad x1)
    evalB _ Ad (*L x1 x2) =
      * Ad (evalB _ Ad x1)
        (evalB _ Ad x2)
    evalCl :
      (A : Set) ->
      AddGroup_RingoidSig A ->
      ClAddGroup_RingoidSigTerm A -> A
    evalCl _ Ad (sing x1) = x1
    evalCl _ Ad (+Cl x1 x2) =
      + Ad (evalCl _ Ad x1)
        (evalCl _ Ad x2)
    evalCl _ Ad (0Cl) = 0 Ad
    evalCl _ Ad (negCl x1) =
      neg Ad (evalCl _ Ad x1)
    evalCl _ Ad (*Cl x1 x2) =
      * Ad (evalCl _ Ad x1)
        (evalCl _ Ad x2)
    evalOp :
      (A : Set) (n : Nat) ->
      AddGroup_RingoidSig A ->
      Vec A n ->
      OpAddGroup_RingoidSigTerm n -> A
    evalOp _ n Ad vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ad vars (+OL x1 x2) =
      + Ad (evalOp _ n Ad vars x1)
        (evalOp _ n Ad vars x2)
    evalOp _ n Ad vars (0OL) = 0 Ad
    evalOp _ n Ad vars (negOL x1) =
      neg Ad (evalOp _ n Ad vars x1)
    evalOp _ n Ad vars (*OL x1 x2) =
      * Ad (evalOp _ n Ad vars x1)
        (evalOp _ n Ad vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      AddGroup_RingoidSig A ->
      Vec A n ->
      OpAddGroup_RingoidSigTerm2 n
        A -> A
    evalOpE _ n Ad vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ad vars (sing2 x1) =
      x1
    evalOpE _ n Ad vars (+OL2
                         x1
                         x2) =
      + Ad (evalOpE _ n Ad vars x1)
        (evalOpE _ n Ad vars x2)
    evalOpE _ n Ad vars (0OL2) =
      0 Ad
    evalOpE _ n Ad vars (negOL2
                         x1) =
      neg Ad (evalOpE _ n Ad vars x1)
    evalOpE _ n Ad vars (*OL2
                         x1
                         x2) =
      * Ad (evalOpE _ n Ad vars x1)
        (evalOpE _ n Ad vars x2)
    inductionB :
      (P : AddGroup_RingoidSigTerm ->
           Set) ->
      ((x1 : AddGroup_RingoidSigTerm)
       (x2 : AddGroup_RingoidSigTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      P 0L ->
      ((x1 : AddGroup_RingoidSigTerm) ->
       P x1 -> P (negL x1)) ->
      ((x1 : AddGroup_RingoidSigTerm)
       (x2 : AddGroup_RingoidSigTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      (x : AddGroup_RingoidSigTerm) ->
      P x
    inductionB p p+l p0l pnegl p*l (+L
                                    x1
                                    x2) =
      p+l _ _
        (inductionB p p+l p0l pnegl p*l
           x1)
        (inductionB p p+l p0l pnegl p*l
           x2)
    inductionB p p+l p0l pnegl p*l (0L) =
      p0l
    inductionB p p+l p0l pnegl p*l (negL
                                    x1) =
      pnegl _
        (inductionB p p+l p0l pnegl p*l
           x1)
    inductionB p p+l p0l pnegl p*l (*L
                                    x1
                                    x2) =
      p*l _ _
        (inductionB p p+l p0l pnegl p*l
           x1)
        (inductionB p p+l p0l pnegl p*l
           x2)
    inductionCl :
      (A : Set)
      (P : ClAddGroup_RingoidSigTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClAddGroup_RingoidSigTerm
          A)
       (x2 : ClAddGroup_RingoidSigTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      P 0Cl ->
      ((x1 : ClAddGroup_RingoidSigTerm
          A) -> P x1 -> P (negCl x1)) ->
      ((x1 : ClAddGroup_RingoidSigTerm
          A)
       (x2 : ClAddGroup_RingoidSigTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      (x : ClAddGroup_RingoidSigTerm
         A) -> P x
    inductionCl _ p psing p+cl p0cl pnegcl p*cl (sing
                                                 x1) = psing x1
    inductionCl _ p psing p+cl p0cl pnegcl p*cl (+Cl
                                                 x1
                                                 x2) =
      p+cl _ _
        (inductionCl _ p psing p+cl p0cl
           pnegcl
           p*cl
           x1)
        (inductionCl _ p psing p+cl p0cl
           pnegcl
           p*cl
           x2)
    inductionCl _ p psing p+cl p0cl pnegcl p*cl (0Cl) =
      p0cl
    inductionCl _ p psing p+cl p0cl pnegcl p*cl (negCl
                                                 x1) =
      pnegcl _
        (inductionCl _ p psing p+cl p0cl
           pnegcl
           p*cl
           x1)
    inductionCl _ p psing p+cl p0cl pnegcl p*cl (*Cl
                                                 x1
                                                 x2) =
      p*cl _ _
        (inductionCl _ p psing p+cl p0cl
           pnegcl
           p*cl
           x1)
        (inductionCl _ p psing p+cl p0cl
           pnegcl
           p*cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpAddGroup_RingoidSigTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpAddGroup_RingoidSigTerm
          n)
       (x2 : OpAddGroup_RingoidSigTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      P 0OL ->
      ((x1 : OpAddGroup_RingoidSigTerm
          n) -> P x1 -> P (negOL x1)) ->
      ((x1 : OpAddGroup_RingoidSigTerm
          n)
       (x2 : OpAddGroup_RingoidSigTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      (x : OpAddGroup_RingoidSigTerm
         n) -> P x
    inductionOp _ p pv p+ol p0ol pnegol p*ol (v
                                              x1) = pv x1
    inductionOp _ p pv p+ol p0ol pnegol p*ol (+OL
                                              x1
                                              x2) =
      p+ol _ _
        (inductionOp _ p pv p+ol p0ol
           pnegol
           p*ol
           x1)
        (inductionOp _ p pv p+ol p0ol
           pnegol
           p*ol
           x2)
    inductionOp _ p pv p+ol p0ol pnegol p*ol (0OL) =
      p0ol
    inductionOp _ p pv p+ol p0ol pnegol p*ol (negOL
                                              x1) =
      pnegol _
        (inductionOp _ p pv p+ol p0ol
           pnegol
           p*ol
           x1)
    inductionOp _ p pv p+ol p0ol pnegol p*ol (*OL
                                              x1
                                              x2) =
      p*ol _ _
        (inductionOp _ p pv p+ol p0ol
           pnegol
           p*ol
           x1)
        (inductionOp _ p pv p+ol p0ol
           pnegol
           p*ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAddGroup_RingoidSigTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpAddGroup_RingoidSigTerm2
          n
          A)
       (x2 : OpAddGroup_RingoidSigTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      P 0OL2 ->
      ((x1 : OpAddGroup_RingoidSigTerm2
          n
          A) -> P x1 -> P (negOL2 x1)) ->
      ((x1 : OpAddGroup_RingoidSigTerm2
          n
          A)
       (x2 : OpAddGroup_RingoidSigTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      (x : OpAddGroup_RingoidSigTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 (v2
                                                             x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 (sing2
                                                             x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 (+OL2
                                                             x1
                                                             x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p0ol2
           pnegol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p0ol2
           pnegol2
           p*ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 (negOL2
                                                             x1) =
      pnegol2 _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p0ol2
           pnegol2
           p*ol2
           x1)
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 pnegol2 p*ol2 (*OL2
                                                             x1
                                                             x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p0ol2
           pnegol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p0ol2
           pnegol2
           p*ol2
           x2)
    +L' :
      AddGroup_RingoidSigTerm ->
      AddGroup_RingoidSigTerm ->
      AddGroup_RingoidSigTerm
    +L' x1 x2 = +L x1 x2
    0L' : AddGroup_RingoidSigTerm
    0L' = 0L
    negL' :
      AddGroup_RingoidSigTerm ->
      AddGroup_RingoidSigTerm
    negL' x1 = negL x1
    *L' :
      AddGroup_RingoidSigTerm ->
      AddGroup_RingoidSigTerm ->
      AddGroup_RingoidSigTerm
    *L' x1 x2 = *L x1 x2
    stageB :
      AddGroup_RingoidSigTerm ->
      Staged AddGroup_RingoidSigTerm
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (0L) = Now 0L
    stageB (negL x1) =
      stage1 _ _ negL'
        (codeLift1 _ _ negL')
        (stageB x1)
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    +Cl' :
      (A : Set) ->
      ClAddGroup_RingoidSigTerm A ->
      ClAddGroup_RingoidSigTerm A ->
      ClAddGroup_RingoidSigTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    0Cl' :
      (A : Set) ->
      ClAddGroup_RingoidSigTerm A
    0Cl' _ = 0Cl
    negCl' :
      (A : Set) ->
      ClAddGroup_RingoidSigTerm A ->
      ClAddGroup_RingoidSigTerm A
    negCl' _ x1 = negCl x1
    *Cl' :
      (A : Set) ->
      ClAddGroup_RingoidSigTerm A ->
      ClAddGroup_RingoidSigTerm A ->
      ClAddGroup_RingoidSigTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    stageCl :
      (A : Set) ->
      ClAddGroup_RingoidSigTerm A ->
      Staged
        (ClAddGroup_RingoidSigTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (negCl x1) =
      stage1 _ _ (negCl' _)
        (codeLift1 _ _ (negCl' _))
        (stageCl _ x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    +OL' :
      (n : Nat) ->
      OpAddGroup_RingoidSigTerm n ->
      OpAddGroup_RingoidSigTerm n ->
      OpAddGroup_RingoidSigTerm n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      OpAddGroup_RingoidSigTerm n
    0OL' _ = 0OL
    negOL' :
      (n : Nat) ->
      OpAddGroup_RingoidSigTerm n ->
      OpAddGroup_RingoidSigTerm n
    negOL' _ x1 = negOL x1
    *OL' :
      (n : Nat) ->
      OpAddGroup_RingoidSigTerm n ->
      OpAddGroup_RingoidSigTerm n ->
      OpAddGroup_RingoidSigTerm n
    *OL' _ x1 x2 = *OL x1 x2
    stageOp :
      (n : Nat) ->
      OpAddGroup_RingoidSigTerm n ->
      Staged
        (OpAddGroup_RingoidSigTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (0OL) = Now 0OL
    stageOp _ (negOL x1) =
      stage1 _ _ (negOL' _)
        (codeLift1 _ _ (negOL' _))
        (stageOp _ x1)
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAddGroup_RingoidSigTerm2 n
        A ->
      OpAddGroup_RingoidSigTerm2 n
        A ->
      OpAddGroup_RingoidSigTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    0OL2' :
      (n : Nat) (A : Set) ->
      OpAddGroup_RingoidSigTerm2 n A
    0OL2' _ _ = 0OL2
    negOL2' :
      (n : Nat) (A : Set) ->
      OpAddGroup_RingoidSigTerm2 n
        A ->
      OpAddGroup_RingoidSigTerm2 n A
    negOL2' _ _ x1 = negOL2 x1
    *OL2' :
      (n : Nat) (A : Set) ->
      OpAddGroup_RingoidSigTerm2 n
        A ->
      OpAddGroup_RingoidSigTerm2 n
        A ->
      OpAddGroup_RingoidSigTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAddGroup_RingoidSigTerm2 n
        A ->
      Staged
        (OpAddGroup_RingoidSigTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (negOL2 x1) =
      stage1 _ _ (negOL2' _ _)
        (codeLift1 _ _ (negOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record AddGroup_RingoidSigTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        +T : Repr A -> Repr A -> Repr A
        0T : Repr A
        negT : Repr A -> Repr A
        *T : Repr A -> Repr A -> Repr A
  
  module AdditiveCommutativeMonoid where
    record AdditiveCommutativeMonoid
      (A : Set) : Set where
      constructor AdditiveCommutativeMonoidC
      field
        0 : A
        + : A -> A -> A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
    record AdditiveCommutativeMonoidSig
      (AS : Set) : Set where
      constructor AdditiveCommutativeMonoidSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
    record AdditiveCommutativeMonoidProd
      (AP : Set) : Set where
      constructor AdditiveCommutativeMonoidProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
    record AdditiveCommutativeMonoidHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveCommutativeMonoid
         A1)
      (Ad2 : AdditiveCommutativeMonoid
         A2) : Set where
      constructor AdditiveCommutativeMonoidHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveCommutativeMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveCommutativeMonoid
         A1)
      (Ad2 : AdditiveCommutativeMonoid
         A2) : Set where
      constructor AdditiveCommutativeMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveCommutativeMonoidTerm
      : Set where
      0L :
        AdditiveCommutativeMonoidTerm
      +L :
        AdditiveCommutativeMonoidTerm ->
        AdditiveCommutativeMonoidTerm ->
        AdditiveCommutativeMonoidTerm
    data ClAdditiveCommutativeMonoidTerm
      (A : Set) : Set where
      sing :
        A ->
        ClAdditiveCommutativeMonoidTerm
          A
      0Cl :
        ClAdditiveCommutativeMonoidTerm
          A
      +Cl :
        ClAdditiveCommutativeMonoidTerm
          A ->
        ClAdditiveCommutativeMonoidTerm
          A ->
        ClAdditiveCommutativeMonoidTerm
          A
    data OpAdditiveCommutativeMonoidTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpAdditiveCommutativeMonoidTerm
          n
      0OL :
        OpAdditiveCommutativeMonoidTerm
          n
      +OL :
        OpAdditiveCommutativeMonoidTerm
          n ->
        OpAdditiveCommutativeMonoidTerm
          n ->
        OpAdditiveCommutativeMonoidTerm
          n
    data OpAdditiveCommutativeMonoidTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAdditiveCommutativeMonoidTerm2
          n
          A
      sing2 :
        A ->
        OpAdditiveCommutativeMonoidTerm2
          n
          A
      0OL2 :
        OpAdditiveCommutativeMonoidTerm2
          n
          A
      +OL2 :
        OpAdditiveCommutativeMonoidTerm2
          n
          A ->
        OpAdditiveCommutativeMonoidTerm2
          n
          A ->
        OpAdditiveCommutativeMonoidTerm2
          n
          A
    simplifyB :
      AdditiveCommutativeMonoidTerm ->
      AdditiveCommutativeMonoidTerm
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (0L) = 0L
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClAdditiveCommutativeMonoidTerm
        A ->
      ClAdditiveCommutativeMonoidTerm
        A
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAdditiveCommutativeMonoidTerm
        n ->
      OpAdditiveCommutativeMonoidTerm
        n
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAdditiveCommutativeMonoidTerm2
        n
        A ->
      OpAdditiveCommutativeMonoidTerm2
        n
        A
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AdditiveCommutativeMonoid A ->
      AdditiveCommutativeMonoidTerm ->
      A
    evalB _ Ad (0L) = 0 Ad
    evalB _ Ad (+L x1 x2) =
      + Ad (evalB _ Ad x1)
        (evalB _ Ad x2)
    evalCl :
      (A : Set) ->
      AdditiveCommutativeMonoid A ->
      ClAdditiveCommutativeMonoidTerm
        A -> A
    evalCl _ Ad (sing x1) = x1
    evalCl _ Ad (0Cl) = 0 Ad
    evalCl _ Ad (+Cl x1 x2) =
      + Ad (evalCl _ Ad x1)
        (evalCl _ Ad x2)
    evalOp :
      (A : Set) (n : Nat) ->
      AdditiveCommutativeMonoid A ->
      Vec A n ->
      OpAdditiveCommutativeMonoidTerm
        n -> A
    evalOp _ n Ad vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ad vars (0OL) = 0 Ad
    evalOp _ n Ad vars (+OL x1 x2) =
      + Ad (evalOp _ n Ad vars x1)
        (evalOp _ n Ad vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      AdditiveCommutativeMonoid A ->
      Vec A n ->
      OpAdditiveCommutativeMonoidTerm2
        n
        A -> A
    evalOpE _ n Ad vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ad vars (sing2 x1) =
      x1
    evalOpE _ n Ad vars (0OL2) =
      0 Ad
    evalOpE _ n Ad vars (+OL2
                         x1
                         x2) =
      + Ad (evalOpE _ n Ad vars x1)
        (evalOpE _ n Ad vars x2)
    inductionB :
      (P : AdditiveCommutativeMonoidTerm ->
           Set) ->
      P 0L ->
      ((x1 : AdditiveCommutativeMonoidTerm)
       (x2 : AdditiveCommutativeMonoidTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : AdditiveCommutativeMonoidTerm) ->
      P x
    inductionB p p0l p+l (0L) = p0l
    inductionB p p0l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p0l p+l x1)
        (inductionB p p0l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClAdditiveCommutativeMonoidTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 0Cl ->
      ((x1 : ClAdditiveCommutativeMonoidTerm
          A)
       (x2 : ClAdditiveCommutativeMonoidTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClAdditiveCommutativeMonoidTerm
         A) -> P x
    inductionCl _ p psing p0cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p0cl p+cl (0Cl) =
      p0cl
    inductionCl _ p psing p0cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p0cl p+cl
           x1)
        (inductionCl _ p psing p0cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpAdditiveCommutativeMonoidTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 0OL ->
      ((x1 : OpAdditiveCommutativeMonoidTerm
          n)
       (x2 : OpAdditiveCommutativeMonoidTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpAdditiveCommutativeMonoidTerm
         n) -> P x
    inductionOp _ p pv p0ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p0ol p+ol (0OL) =
      p0ol
    inductionOp _ p pv p0ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p0ol p+ol
           x1)
        (inductionOp _ p pv p0ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAdditiveCommutativeMonoidTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 0OL2 ->
      ((x1 : OpAdditiveCommutativeMonoidTerm2
          n
          A)
       (x2 : OpAdditiveCommutativeMonoidTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpAdditiveCommutativeMonoidTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           x2)
    0L' :
      AdditiveCommutativeMonoidTerm
    0L' = 0L
    +L' :
      AdditiveCommutativeMonoidTerm ->
      AdditiveCommutativeMonoidTerm ->
      AdditiveCommutativeMonoidTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      AdditiveCommutativeMonoidTerm ->
      Staged
        AdditiveCommutativeMonoidTerm
    stageB (0L) = Now 0L
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    0Cl' :
      (A : Set) ->
      ClAdditiveCommutativeMonoidTerm
        A
    0Cl' _ = 0Cl
    +Cl' :
      (A : Set) ->
      ClAdditiveCommutativeMonoidTerm
        A ->
      ClAdditiveCommutativeMonoidTerm
        A ->
      ClAdditiveCommutativeMonoidTerm
        A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClAdditiveCommutativeMonoidTerm
        A ->
      Staged
        (ClAdditiveCommutativeMonoidTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    0OL' :
      (n : Nat) ->
      OpAdditiveCommutativeMonoidTerm
        n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      OpAdditiveCommutativeMonoidTerm
        n ->
      OpAdditiveCommutativeMonoidTerm
        n ->
      OpAdditiveCommutativeMonoidTerm
        n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpAdditiveCommutativeMonoidTerm
        n ->
      Staged
        (OpAdditiveCommutativeMonoidTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (0OL) = Now 0OL
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    0OL2' :
      (n : Nat) (A : Set) ->
      OpAdditiveCommutativeMonoidTerm2
        n
        A
    0OL2' _ _ = 0OL2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAdditiveCommutativeMonoidTerm2
        n
        A ->
      OpAdditiveCommutativeMonoidTerm2
        n
        A ->
      OpAdditiveCommutativeMonoidTerm2
        n
        A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAdditiveCommutativeMonoidTerm2
        n
        A ->
      Staged
        (OpAdditiveCommutativeMonoidTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record AdditiveCommutativeMonoidTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        0T : Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module AdditiveCommutativeSemigroup where
    record AdditiveCommutativeSemigroup
      (A : Set) : Set where
      constructor AdditiveCommutativeSemigroupC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record AdditiveCommutativeSemigroupSig
      (AS : Set) : Set where
      constructor AdditiveCommutativeSemigroupSigSigC
      field
        +S : AS -> AS -> AS
    record AdditiveCommutativeSemigroupProd
      (AP : Set) : Set where
      constructor AdditiveCommutativeSemigroupProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record AdditiveCommutativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveCommutativeSemigroup
         A1)
      (Ad2 : AdditiveCommutativeSemigroup
         A2) : Set where
      constructor AdditiveCommutativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveCommutativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveCommutativeSemigroup
         A1)
      (Ad2 : AdditiveCommutativeSemigroup
         A2) : Set where
      constructor AdditiveCommutativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveCommutativeSemigroupTerm
      : Set where
      +L :
        AdditiveCommutativeSemigroupTerm ->
        AdditiveCommutativeSemigroupTerm ->
        AdditiveCommutativeSemigroupTerm
    data ClAdditiveCommutativeSemigroupTerm
      (A : Set) : Set where
      sing :
        A ->
        ClAdditiveCommutativeSemigroupTerm
          A
      +Cl :
        ClAdditiveCommutativeSemigroupTerm
          A ->
        ClAdditiveCommutativeSemigroupTerm
          A ->
        ClAdditiveCommutativeSemigroupTerm
          A
    data OpAdditiveCommutativeSemigroupTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpAdditiveCommutativeSemigroupTerm
          n
      +OL :
        OpAdditiveCommutativeSemigroupTerm
          n ->
        OpAdditiveCommutativeSemigroupTerm
          n ->
        OpAdditiveCommutativeSemigroupTerm
          n
    data OpAdditiveCommutativeSemigroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAdditiveCommutativeSemigroupTerm2
          n
          A
      sing2 :
        A ->
        OpAdditiveCommutativeSemigroupTerm2
          n
          A
      +OL2 :
        OpAdditiveCommutativeSemigroupTerm2
          n
          A ->
        OpAdditiveCommutativeSemigroupTerm2
          n
          A ->
        OpAdditiveCommutativeSemigroupTerm2
          n
          A
    simplifyB :
      AdditiveCommutativeSemigroupTerm ->
      AdditiveCommutativeSemigroupTerm
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClAdditiveCommutativeSemigroupTerm
        A ->
      ClAdditiveCommutativeSemigroupTerm
        A
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAdditiveCommutativeSemigroupTerm
        n ->
      OpAdditiveCommutativeSemigroupTerm
        n
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAdditiveCommutativeSemigroupTerm2
        n
        A ->
      OpAdditiveCommutativeSemigroupTerm2
        n
        A
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AdditiveCommutativeSemigroup
        A ->
      AdditiveCommutativeSemigroupTerm ->
      A
    evalB _ Ad (+L x1 x2) =
      + Ad (evalB _ Ad x1)
        (evalB _ Ad x2)
    evalCl :
      (A : Set) ->
      AdditiveCommutativeSemigroup
        A ->
      ClAdditiveCommutativeSemigroupTerm
        A -> A
    evalCl _ Ad (sing x1) = x1
    evalCl _ Ad (+Cl x1 x2) =
      + Ad (evalCl _ Ad x1)
        (evalCl _ Ad x2)
    evalOp :
      (A : Set) (n : Nat) ->
      AdditiveCommutativeSemigroup
        A ->
      Vec A n ->
      OpAdditiveCommutativeSemigroupTerm
        n -> A
    evalOp _ n Ad vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ad vars (+OL x1 x2) =
      + Ad (evalOp _ n Ad vars x1)
        (evalOp _ n Ad vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      AdditiveCommutativeSemigroup
        A ->
      Vec A n ->
      OpAdditiveCommutativeSemigroupTerm2
        n
        A -> A
    evalOpE _ n Ad vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ad vars (sing2 x1) =
      x1
    evalOpE _ n Ad vars (+OL2
                         x1
                         x2) =
      + Ad (evalOpE _ n Ad vars x1)
        (evalOpE _ n Ad vars x2)
    inductionB :
      (P : AdditiveCommutativeSemigroupTerm ->
           Set) ->
      ((x1 : AdditiveCommutativeSemigroupTerm)
       (x2 : AdditiveCommutativeSemigroupTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : AdditiveCommutativeSemigroupTerm) ->
      P x
    inductionB p p+l (+L x1 x2) =
      p+l _ _ (inductionB p p+l x1)
        (inductionB p p+l x2)
    inductionCl :
      (A : Set)
      (P : ClAdditiveCommutativeSemigroupTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClAdditiveCommutativeSemigroupTerm
          A)
       (x2 : ClAdditiveCommutativeSemigroupTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClAdditiveCommutativeSemigroupTerm
         A) -> P x
    inductionCl _ p psing p+cl (sing
                                x1) = psing x1
    inductionCl _ p psing p+cl (+Cl
                                x1
                                x2) =
      p+cl _ _
        (inductionCl _ p psing p+cl x1)
        (inductionCl _ p psing p+cl x2)
    inductionOp :
      (n : Nat)
      (P : OpAdditiveCommutativeSemigroupTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpAdditiveCommutativeSemigroupTerm
          n)
       (x2 : OpAdditiveCommutativeSemigroupTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpAdditiveCommutativeSemigroupTerm
         n) -> P x
    inductionOp _ p pv p+ol (v x1) =
      pv x1
    inductionOp _ p pv p+ol (+OL
                             x1
                             x2) =
      p+ol _ _
        (inductionOp _ p pv p+ol x1)
        (inductionOp _ p pv p+ol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAdditiveCommutativeSemigroupTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpAdditiveCommutativeSemigroupTerm2
          n
          A)
       (x2 : OpAdditiveCommutativeSemigroupTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpAdditiveCommutativeSemigroupTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p+ol2 (v2
                                         x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 (sing2
                                         x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 (+OL2
                                         x1
                                         x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           x2)
    +L' :
      AdditiveCommutativeSemigroupTerm ->
      AdditiveCommutativeSemigroupTerm ->
      AdditiveCommutativeSemigroupTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      AdditiveCommutativeSemigroupTerm ->
      Staged
        AdditiveCommutativeSemigroupTerm
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    +Cl' :
      (A : Set) ->
      ClAdditiveCommutativeSemigroupTerm
        A ->
      ClAdditiveCommutativeSemigroupTerm
        A ->
      ClAdditiveCommutativeSemigroupTerm
        A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClAdditiveCommutativeSemigroupTerm
        A ->
      Staged
        (ClAdditiveCommutativeSemigroupTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    +OL' :
      (n : Nat) ->
      OpAdditiveCommutativeSemigroupTerm
        n ->
      OpAdditiveCommutativeSemigroupTerm
        n ->
      OpAdditiveCommutativeSemigroupTerm
        n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpAdditiveCommutativeSemigroupTerm
        n ->
      Staged
        (OpAdditiveCommutativeSemigroupTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAdditiveCommutativeSemigroupTerm2
        n
        A ->
      OpAdditiveCommutativeSemigroupTerm2
        n
        A ->
      OpAdditiveCommutativeSemigroupTerm2
        n
        A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAdditiveCommutativeSemigroupTerm2
        n
        A ->
      Staged
        (OpAdditiveCommutativeSemigroupTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record AdditiveCommutativeSemigroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        +T : Repr A -> Repr A -> Repr A
  
  module AdditiveGroup where
    record AdditiveGroup
      (A : Set) : Set where
      constructor AdditiveGroupC
      field
        0 : A
        + : A -> A -> A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
    record AdditiveGroupSig
      (AS : Set) : Set where
      constructor AdditiveGroupSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        negS : AS -> AS
    record AdditiveGroupProd
      (AP : Set) : Set where
      constructor AdditiveGroupProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
    record AdditiveGroupHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveGroup A1)
      (Ad2 : AdditiveGroup A2) :
      Set where
      constructor AdditiveGroupHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
        pres-neg :
          (x1 : A1) ->
          hom (neg Ad1 x1) ==
            neg Ad2 (hom x1)
    record AdditiveGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveGroup A1)
      (Ad2 : AdditiveGroup A2) :
      Set where
      constructor AdditiveGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Ad1 x1) (neg Ad2 y1)
    data AdditiveGroupTerm
      : Set where
      0L : AdditiveGroupTerm
      +L :
        AdditiveGroupTerm ->
        AdditiveGroupTerm ->
        AdditiveGroupTerm
      negL :
        AdditiveGroupTerm ->
        AdditiveGroupTerm
    data ClAdditiveGroupTerm
      (A : Set) : Set where
      sing :
        A -> ClAdditiveGroupTerm A
      0Cl : ClAdditiveGroupTerm A
      +Cl :
        ClAdditiveGroupTerm A ->
        ClAdditiveGroupTerm A ->
        ClAdditiveGroupTerm A
      negCl :
        ClAdditiveGroupTerm A ->
        ClAdditiveGroupTerm A
    data OpAdditiveGroupTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpAdditiveGroupTerm n
      0OL : OpAdditiveGroupTerm n
      +OL :
        OpAdditiveGroupTerm n ->
        OpAdditiveGroupTerm n ->
        OpAdditiveGroupTerm n
      negOL :
        OpAdditiveGroupTerm n ->
        OpAdditiveGroupTerm n
    data OpAdditiveGroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAdditiveGroupTerm2 n A
      sing2 :
        A -> OpAdditiveGroupTerm2 n A
      0OL2 : OpAdditiveGroupTerm2 n A
      +OL2 :
        OpAdditiveGroupTerm2 n A ->
        OpAdditiveGroupTerm2 n A ->
        OpAdditiveGroupTerm2 n A
      negOL2 :
        OpAdditiveGroupTerm2 n A ->
        OpAdditiveGroupTerm2 n A
    simplifyB :
      AdditiveGroupTerm ->
      AdditiveGroupTerm
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (+L x (negL x)) = 0L
    simplifyB (+L (negL x) x) = 0L
    simplifyB (0L) = 0L
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (negL x1) =
      negL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClAdditiveGroupTerm A ->
      ClAdditiveGroupTerm A
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (+Cl x (negCl x)) =
      0Cl
    simplifyCl _ (+Cl (negCl x) x) =
      0Cl
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (negCl x1) =
      negCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAdditiveGroupTerm n ->
      OpAdditiveGroupTerm n
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (+OL x (negOL x)) =
      0OL
    simplifyOp _ (+OL (negOL x) x) =
      0OL
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (negOL x1) =
      negOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAdditiveGroupTerm2 n A ->
      OpAdditiveGroupTerm2 n A
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (+OL2
                     x
                     (negOL2 x)) = 0OL2
    simplifyOpE _ _ (+OL2
                     (negOL2 x)
                     x) = 0OL2
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (negOL2 x1) =
      negOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AdditiveGroup A ->
      AdditiveGroupTerm -> A
    evalB _ Ad (0L) = 0 Ad
    evalB _ Ad (+L x1 x2) =
      + Ad (evalB _ Ad x1)
        (evalB _ Ad x2)
    evalB _ Ad (negL x1) =
      neg Ad (evalB _ Ad x1)
    evalCl :
      (A : Set) ->
      AdditiveGroup A ->
      ClAdditiveGroupTerm A -> A
    evalCl _ Ad (sing x1) = x1
    evalCl _ Ad (0Cl) = 0 Ad
    evalCl _ Ad (+Cl x1 x2) =
      + Ad (evalCl _ Ad x1)
        (evalCl _ Ad x2)
    evalCl _ Ad (negCl x1) =
      neg Ad (evalCl _ Ad x1)
    evalOp :
      (A : Set) (n : Nat) ->
      AdditiveGroup A ->
      Vec A n ->
      OpAdditiveGroupTerm n -> A
    evalOp _ n Ad vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ad vars (0OL) = 0 Ad
    evalOp _ n Ad vars (+OL x1 x2) =
      + Ad (evalOp _ n Ad vars x1)
        (evalOp _ n Ad vars x2)
    evalOp _ n Ad vars (negOL x1) =
      neg Ad (evalOp _ n Ad vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      AdditiveGroup A ->
      Vec A n ->
      OpAdditiveGroupTerm2 n A -> A
    evalOpE _ n Ad vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ad vars (sing2 x1) =
      x1
    evalOpE _ n Ad vars (0OL2) =
      0 Ad
    evalOpE _ n Ad vars (+OL2
                         x1
                         x2) =
      + Ad (evalOpE _ n Ad vars x1)
        (evalOpE _ n Ad vars x2)
    evalOpE _ n Ad vars (negOL2
                         x1) =
      neg Ad (evalOpE _ n Ad vars x1)
    inductionB :
      (P : AdditiveGroupTerm ->
           Set) ->
      P 0L ->
      ((x1 : AdditiveGroupTerm)
       (x2 : AdditiveGroupTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      ((x1 : AdditiveGroupTerm) ->
       P x1 -> P (negL x1)) ->
      (x : AdditiveGroupTerm) -> P x
    inductionB p p0l p+l pnegl (0L) =
      p0l
    inductionB p p0l p+l pnegl (+L
                                x1
                                x2) =
      p+l _ _
        (inductionB p p0l p+l pnegl x1)
        (inductionB p p0l p+l pnegl x2)
    inductionB p p0l p+l pnegl (negL
                                x1) =
      pnegl _
        (inductionB p p0l p+l pnegl x1)
    inductionCl :
      (A : Set)
      (P : ClAdditiveGroupTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 0Cl ->
      ((x1 : ClAdditiveGroupTerm A)
       (x2 : ClAdditiveGroupTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      ((x1 : ClAdditiveGroupTerm A) ->
       P x1 -> P (negCl x1)) ->
      (x : ClAdditiveGroupTerm A) ->
      P x
    inductionCl _ p psing p0cl p+cl pnegcl (sing
                                            x1) = psing x1
    inductionCl _ p psing p0cl p+cl pnegcl (0Cl) =
      p0cl
    inductionCl _ p psing p0cl p+cl pnegcl (+Cl
                                            x1
                                            x2) =
      p+cl _ _
        (inductionCl _ p psing p0cl p+cl
           pnegcl
           x1)
        (inductionCl _ p psing p0cl p+cl
           pnegcl
           x2)
    inductionCl _ p psing p0cl p+cl pnegcl (negCl
                                            x1) =
      pnegcl _
        (inductionCl _ p psing p0cl p+cl
           pnegcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpAdditiveGroupTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 0OL ->
      ((x1 : OpAdditiveGroupTerm n)
       (x2 : OpAdditiveGroupTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      ((x1 : OpAdditiveGroupTerm n) ->
       P x1 -> P (negOL x1)) ->
      (x : OpAdditiveGroupTerm n) ->
      P x
    inductionOp _ p pv p0ol p+ol pnegol (v
                                         x1) = pv x1
    inductionOp _ p pv p0ol p+ol pnegol (0OL) =
      p0ol
    inductionOp _ p pv p0ol p+ol pnegol (+OL
                                         x1
                                         x2) =
      p+ol _ _
        (inductionOp _ p pv p0ol p+ol
           pnegol
           x1)
        (inductionOp _ p pv p0ol p+ol
           pnegol
           x2)
    inductionOp _ p pv p0ol p+ol pnegol (negOL
                                         x1) =
      pnegol _
        (inductionOp _ p pv p0ol p+ol
           pnegol
           x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAdditiveGroupTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 0OL2 ->
      ((x1 : OpAdditiveGroupTerm2 n A)
       (x2 : OpAdditiveGroupTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      ((x1 : OpAdditiveGroupTerm2 n
          A) -> P x1 -> P (negOL2 x1)) ->
      (x : OpAdditiveGroupTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 pnegol2 (v2
                                                       x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 pnegol2 (sing2
                                                       x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 pnegol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 pnegol2 (+OL2
                                                       x1
                                                       x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           pnegol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           pnegol2
           x2)
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 pnegol2 (negOL2
                                                       x1) =
      pnegol2 _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           pnegol2
           x1)
    0L' : AdditiveGroupTerm
    0L' = 0L
    +L' :
      AdditiveGroupTerm ->
      AdditiveGroupTerm ->
      AdditiveGroupTerm
    +L' x1 x2 = +L x1 x2
    negL' :
      AdditiveGroupTerm ->
      AdditiveGroupTerm
    negL' x1 = negL x1
    stageB :
      AdditiveGroupTerm ->
      Staged AdditiveGroupTerm
    stageB (0L) = Now 0L
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (negL x1) =
      stage1 _ _ negL'
        (codeLift1 _ _ negL')
        (stageB x1)
    0Cl' :
      (A : Set) ->
      ClAdditiveGroupTerm A
    0Cl' _ = 0Cl
    +Cl' :
      (A : Set) ->
      ClAdditiveGroupTerm A ->
      ClAdditiveGroupTerm A ->
      ClAdditiveGroupTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    negCl' :
      (A : Set) ->
      ClAdditiveGroupTerm A ->
      ClAdditiveGroupTerm A
    negCl' _ x1 = negCl x1
    stageCl :
      (A : Set) ->
      ClAdditiveGroupTerm A ->
      Staged (ClAdditiveGroupTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (negCl x1) =
      stage1 _ _ (negCl' _)
        (codeLift1 _ _ (negCl' _))
        (stageCl _ x1)
    0OL' :
      (n : Nat) ->
      OpAdditiveGroupTerm n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      OpAdditiveGroupTerm n ->
      OpAdditiveGroupTerm n ->
      OpAdditiveGroupTerm n
    +OL' _ x1 x2 = +OL x1 x2
    negOL' :
      (n : Nat) ->
      OpAdditiveGroupTerm n ->
      OpAdditiveGroupTerm n
    negOL' _ x1 = negOL x1
    stageOp :
      (n : Nat) ->
      OpAdditiveGroupTerm n ->
      Staged (OpAdditiveGroupTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (0OL) = Now 0OL
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (negOL x1) =
      stage1 _ _ (negOL' _)
        (codeLift1 _ _ (negOL' _))
        (stageOp _ x1)
    0OL2' :
      (n : Nat) (A : Set) ->
      OpAdditiveGroupTerm2 n A
    0OL2' _ _ = 0OL2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAdditiveGroupTerm2 n A ->
      OpAdditiveGroupTerm2 n A ->
      OpAdditiveGroupTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    negOL2' :
      (n : Nat) (A : Set) ->
      OpAdditiveGroupTerm2 n A ->
      OpAdditiveGroupTerm2 n A
    negOL2' _ _ x1 = negOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAdditiveGroupTerm2 n A ->
      Staged
        (OpAdditiveGroupTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (negOL2 x1) =
      stage1 _ _ (negOL2' _ _)
        (codeLift1 _ _ (negOL2' _ _))
        (stageOpE _ _ x1)
    record AdditiveGroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        0T : Repr A
        +T : Repr A -> Repr A -> Repr A
        negT : Repr A -> Repr A
  
  module AdditiveMagma where
    record AdditiveMagma
      (A : Set) : Set where
      constructor AdditiveMagmaC
      field
        + : A -> A -> A
    record AdditiveMagmaSig
      (AS : Set) : Set where
      constructor AdditiveMagmaSigSigC
      field
        +S : AS -> AS -> AS
    record AdditiveMagmaProd
      (AP : Set) : Set where
      constructor AdditiveMagmaProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record AdditiveMagmaHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveMagma A1)
      (Ad2 : AdditiveMagma A2) :
      Set where
      constructor AdditiveMagmaHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveMagma A1)
      (Ad2 : AdditiveMagma A2) :
      Set where
      constructor AdditiveMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveMagmaTerm
      : Set where
      +L :
        AdditiveMagmaTerm ->
        AdditiveMagmaTerm ->
        AdditiveMagmaTerm
    data ClAdditiveMagmaTerm
      (A : Set) : Set where
      sing :
        A -> ClAdditiveMagmaTerm A
      +Cl :
        ClAdditiveMagmaTerm A ->
        ClAdditiveMagmaTerm A ->
        ClAdditiveMagmaTerm A
    data OpAdditiveMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpAdditiveMagmaTerm n
      +OL :
        OpAdditiveMagmaTerm n ->
        OpAdditiveMagmaTerm n ->
        OpAdditiveMagmaTerm n
    data OpAdditiveMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAdditiveMagmaTerm2 n A
      sing2 :
        A -> OpAdditiveMagmaTerm2 n A
      +OL2 :
        OpAdditiveMagmaTerm2 n A ->
        OpAdditiveMagmaTerm2 n A ->
        OpAdditiveMagmaTerm2 n A
    simplifyB :
      AdditiveMagmaTerm ->
      AdditiveMagmaTerm
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClAdditiveMagmaTerm A ->
      ClAdditiveMagmaTerm A
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAdditiveMagmaTerm n ->
      OpAdditiveMagmaTerm n
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAdditiveMagmaTerm2 n A ->
      OpAdditiveMagmaTerm2 n A
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AdditiveMagma A ->
      AdditiveMagmaTerm -> A
    evalB _ Ad (+L x1 x2) =
      + Ad (evalB _ Ad x1)
        (evalB _ Ad x2)
    evalCl :
      (A : Set) ->
      AdditiveMagma A ->
      ClAdditiveMagmaTerm A -> A
    evalCl _ Ad (sing x1) = x1
    evalCl _ Ad (+Cl x1 x2) =
      + Ad (evalCl _ Ad x1)
        (evalCl _ Ad x2)
    evalOp :
      (A : Set) (n : Nat) ->
      AdditiveMagma A ->
      Vec A n ->
      OpAdditiveMagmaTerm n -> A
    evalOp _ n Ad vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ad vars (+OL x1 x2) =
      + Ad (evalOp _ n Ad vars x1)
        (evalOp _ n Ad vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      AdditiveMagma A ->
      Vec A n ->
      OpAdditiveMagmaTerm2 n A -> A
    evalOpE _ n Ad vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ad vars (sing2 x1) =
      x1
    evalOpE _ n Ad vars (+OL2
                         x1
                         x2) =
      + Ad (evalOpE _ n Ad vars x1)
        (evalOpE _ n Ad vars x2)
    inductionB :
      (P : AdditiveMagmaTerm ->
           Set) ->
      ((x1 : AdditiveMagmaTerm)
       (x2 : AdditiveMagmaTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : AdditiveMagmaTerm) -> P x
    inductionB p p+l (+L x1 x2) =
      p+l _ _ (inductionB p p+l x1)
        (inductionB p p+l x2)
    inductionCl :
      (A : Set)
      (P : ClAdditiveMagmaTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClAdditiveMagmaTerm A)
       (x2 : ClAdditiveMagmaTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClAdditiveMagmaTerm A) ->
      P x
    inductionCl _ p psing p+cl (sing
                                x1) = psing x1
    inductionCl _ p psing p+cl (+Cl
                                x1
                                x2) =
      p+cl _ _
        (inductionCl _ p psing p+cl x1)
        (inductionCl _ p psing p+cl x2)
    inductionOp :
      (n : Nat)
      (P : OpAdditiveMagmaTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpAdditiveMagmaTerm n)
       (x2 : OpAdditiveMagmaTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpAdditiveMagmaTerm n) ->
      P x
    inductionOp _ p pv p+ol (v x1) =
      pv x1
    inductionOp _ p pv p+ol (+OL
                             x1
                             x2) =
      p+ol _ _
        (inductionOp _ p pv p+ol x1)
        (inductionOp _ p pv p+ol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAdditiveMagmaTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpAdditiveMagmaTerm2 n A)
       (x2 : OpAdditiveMagmaTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpAdditiveMagmaTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p+ol2 (v2
                                         x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 (sing2
                                         x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 (+OL2
                                         x1
                                         x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           x2)
    +L' :
      AdditiveMagmaTerm ->
      AdditiveMagmaTerm ->
      AdditiveMagmaTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      AdditiveMagmaTerm ->
      Staged AdditiveMagmaTerm
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    +Cl' :
      (A : Set) ->
      ClAdditiveMagmaTerm A ->
      ClAdditiveMagmaTerm A ->
      ClAdditiveMagmaTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClAdditiveMagmaTerm A ->
      Staged (ClAdditiveMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    +OL' :
      (n : Nat) ->
      OpAdditiveMagmaTerm n ->
      OpAdditiveMagmaTerm n ->
      OpAdditiveMagmaTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpAdditiveMagmaTerm n ->
      Staged (OpAdditiveMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAdditiveMagmaTerm2 n A ->
      OpAdditiveMagmaTerm2 n A ->
      OpAdditiveMagmaTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAdditiveMagmaTerm2 n A ->
      Staged
        (OpAdditiveMagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record AdditiveMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        +T : Repr A -> Repr A -> Repr A
  
  module AdditiveMonoid where
    record AdditiveMonoid
      (A : Set) : Set where
      constructor AdditiveMonoidC
      field
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
    record AdditiveMonoidSig
      (AS : Set) : Set where
      constructor AdditiveMonoidSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
    record AdditiveMonoidProd
      (AP : Set) : Set where
      constructor AdditiveMonoidProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
    record AdditiveMonoidHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveMonoid A1)
      (Ad2 : AdditiveMonoid A2) :
      Set where
      constructor AdditiveMonoidHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
        pres-0 : hom (0 Ad1) == 0 Ad2
    record AdditiveMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveMonoid A1)
      (Ad2 : AdditiveMonoid A2) :
      Set where
      constructor AdditiveMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
        interp-0 :
          interp (0 Ad1) (0 Ad2)
    data AdditiveMonoidTerm
      : Set where
      +L :
        AdditiveMonoidTerm ->
        AdditiveMonoidTerm ->
        AdditiveMonoidTerm
      0L : AdditiveMonoidTerm
    data ClAdditiveMonoidTerm
      (A : Set) : Set where
      sing :
        A -> ClAdditiveMonoidTerm A
      +Cl :
        ClAdditiveMonoidTerm A ->
        ClAdditiveMonoidTerm A ->
        ClAdditiveMonoidTerm A
      0Cl : ClAdditiveMonoidTerm A
    data OpAdditiveMonoidTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpAdditiveMonoidTerm n
      +OL :
        OpAdditiveMonoidTerm n ->
        OpAdditiveMonoidTerm n ->
        OpAdditiveMonoidTerm n
      0OL : OpAdditiveMonoidTerm n
    data OpAdditiveMonoidTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAdditiveMonoidTerm2 n A
      sing2 :
        A -> OpAdditiveMonoidTerm2 n A
      +OL2 :
        OpAdditiveMonoidTerm2 n A ->
        OpAdditiveMonoidTerm2 n A ->
        OpAdditiveMonoidTerm2 n A
      0OL2 : OpAdditiveMonoidTerm2 n A
    simplifyB :
      AdditiveMonoidTerm ->
      AdditiveMonoidTerm
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (0L) = 0L
    simplifyCl :
      (A : Set) ->
      ClAdditiveMonoidTerm A ->
      ClAdditiveMonoidTerm A
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAdditiveMonoidTerm n ->
      OpAdditiveMonoidTerm n
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAdditiveMonoidTerm2 n A ->
      OpAdditiveMonoidTerm2 n A
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AdditiveMonoid A ->
      AdditiveMonoidTerm -> A
    evalB _ Ad (+L x1 x2) =
      + Ad (evalB _ Ad x1)
        (evalB _ Ad x2)
    evalB _ Ad (0L) = 0 Ad
    evalCl :
      (A : Set) ->
      AdditiveMonoid A ->
      ClAdditiveMonoidTerm A -> A
    evalCl _ Ad (sing x1) = x1
    evalCl _ Ad (+Cl x1 x2) =
      + Ad (evalCl _ Ad x1)
        (evalCl _ Ad x2)
    evalCl _ Ad (0Cl) = 0 Ad
    evalOp :
      (A : Set) (n : Nat) ->
      AdditiveMonoid A ->
      Vec A n ->
      OpAdditiveMonoidTerm n -> A
    evalOp _ n Ad vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ad vars (+OL x1 x2) =
      + Ad (evalOp _ n Ad vars x1)
        (evalOp _ n Ad vars x2)
    evalOp _ n Ad vars (0OL) = 0 Ad
    evalOpE :
      (A : Set) (n : Nat) ->
      AdditiveMonoid A ->
      Vec A n ->
      OpAdditiveMonoidTerm2 n A -> A
    evalOpE _ n Ad vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ad vars (sing2 x1) =
      x1
    evalOpE _ n Ad vars (+OL2
                         x1
                         x2) =
      + Ad (evalOpE _ n Ad vars x1)
        (evalOpE _ n Ad vars x2)
    evalOpE _ n Ad vars (0OL2) =
      0 Ad
    inductionB :
      (P : AdditiveMonoidTerm ->
           Set) ->
      ((x1 : AdditiveMonoidTerm)
       (x2 : AdditiveMonoidTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      P 0L ->
      (x : AdditiveMonoidTerm) -> P x
    inductionB p p+l p0l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p+l p0l x1)
        (inductionB p p+l p0l x2)
    inductionB p p+l p0l (0L) = p0l
    inductionCl :
      (A : Set)
      (P : ClAdditiveMonoidTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClAdditiveMonoidTerm A)
       (x2 : ClAdditiveMonoidTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      P 0Cl ->
      (x : ClAdditiveMonoidTerm A) ->
      P x
    inductionCl _ p psing p+cl p0cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p+cl p0cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p+cl p0cl
           x1)
        (inductionCl _ p psing p+cl p0cl
           x2)
    inductionCl _ p psing p+cl p0cl (0Cl) =
      p0cl
    inductionOp :
      (n : Nat)
      (P : OpAdditiveMonoidTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpAdditiveMonoidTerm n)
       (x2 : OpAdditiveMonoidTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      P 0OL ->
      (x : OpAdditiveMonoidTerm n) ->
      P x
    inductionOp _ p pv p+ol p0ol (v
                                  x1) = pv x1
    inductionOp _ p pv p+ol p0ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p+ol p0ol
           x1)
        (inductionOp _ p pv p+ol p0ol
           x2)
    inductionOp _ p pv p+ol p0ol (0OL) =
      p0ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAdditiveMonoidTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpAdditiveMonoidTerm2 n
          A)
       (x2 : OpAdditiveMonoidTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      P 0OL2 ->
      (x : OpAdditiveMonoidTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p0ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p0ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 (0OL2) =
      p0ol2
    +L' :
      AdditiveMonoidTerm ->
      AdditiveMonoidTerm ->
      AdditiveMonoidTerm
    +L' x1 x2 = +L x1 x2
    0L' : AdditiveMonoidTerm
    0L' = 0L
    stageB :
      AdditiveMonoidTerm ->
      Staged AdditiveMonoidTerm
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (0L) = Now 0L
    +Cl' :
      (A : Set) ->
      ClAdditiveMonoidTerm A ->
      ClAdditiveMonoidTerm A ->
      ClAdditiveMonoidTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    0Cl' :
      (A : Set) ->
      ClAdditiveMonoidTerm A
    0Cl' _ = 0Cl
    stageCl :
      (A : Set) ->
      ClAdditiveMonoidTerm A ->
      Staged (ClAdditiveMonoidTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (0Cl) = Now 0Cl
    +OL' :
      (n : Nat) ->
      OpAdditiveMonoidTerm n ->
      OpAdditiveMonoidTerm n ->
      OpAdditiveMonoidTerm n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      OpAdditiveMonoidTerm n
    0OL' _ = 0OL
    stageOp :
      (n : Nat) ->
      OpAdditiveMonoidTerm n ->
      Staged (OpAdditiveMonoidTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (0OL) = Now 0OL
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAdditiveMonoidTerm2 n A ->
      OpAdditiveMonoidTerm2 n A ->
      OpAdditiveMonoidTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    0OL2' :
      (n : Nat) (A : Set) ->
      OpAdditiveMonoidTerm2 n A
    0OL2' _ _ = 0OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAdditiveMonoidTerm2 n A ->
      Staged
        (OpAdditiveMonoidTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (0OL2) = Now 0OL2
    record AdditiveMonoidTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        +T : Repr A -> Repr A -> Repr A
        0T : Repr A
  
  module AdditivePointedMagma where
    record AdditivePointedMagma
      (A : Set) : Set where
      constructor AdditivePointedMagmaC
      field
        0 : A
        + : A -> A -> A
    record AdditivePointedMagmaSig
      (AS : Set) : Set where
      constructor AdditivePointedMagmaSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
    record AdditivePointedMagmaProd
      (AP : Set) : Set where
      constructor AdditivePointedMagmaProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record AdditivePointedMagmaHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditivePointedMagma A1)
      (Ad2 : AdditivePointedMagma
         A2) : Set where
      constructor AdditivePointedMagmaHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditivePointedMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditivePointedMagma A1)
      (Ad2 : AdditivePointedMagma
         A2) : Set where
      constructor AdditivePointedMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditivePointedMagmaTerm
      : Set where
      0L : AdditivePointedMagmaTerm
      +L :
        AdditivePointedMagmaTerm ->
        AdditivePointedMagmaTerm ->
        AdditivePointedMagmaTerm
    data ClAdditivePointedMagmaTerm
      (A : Set) : Set where
      sing :
        A ->
        ClAdditivePointedMagmaTerm A
      0Cl :
        ClAdditivePointedMagmaTerm A
      +Cl :
        ClAdditivePointedMagmaTerm A ->
        ClAdditivePointedMagmaTerm A ->
        ClAdditivePointedMagmaTerm A
    data OpAdditivePointedMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpAdditivePointedMagmaTerm n
      0OL :
        OpAdditivePointedMagmaTerm n
      +OL :
        OpAdditivePointedMagmaTerm n ->
        OpAdditivePointedMagmaTerm n ->
        OpAdditivePointedMagmaTerm n
    data OpAdditivePointedMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAdditivePointedMagmaTerm2 n A
      sing2 :
        A ->
        OpAdditivePointedMagmaTerm2 n A
      0OL2 :
        OpAdditivePointedMagmaTerm2 n A
      +OL2 :
        OpAdditivePointedMagmaTerm2 n
          A ->
        OpAdditivePointedMagmaTerm2 n
          A ->
        OpAdditivePointedMagmaTerm2 n A
    simplifyB :
      AdditivePointedMagmaTerm ->
      AdditivePointedMagmaTerm
    simplifyB (0L) = 0L
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClAdditivePointedMagmaTerm A ->
      ClAdditivePointedMagmaTerm A
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAdditivePointedMagmaTerm n ->
      OpAdditivePointedMagmaTerm n
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAdditivePointedMagmaTerm2 n
        A ->
      OpAdditivePointedMagmaTerm2 n A
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AdditivePointedMagma A ->
      AdditivePointedMagmaTerm -> A
    evalB _ Ad (0L) = 0 Ad
    evalB _ Ad (+L x1 x2) =
      + Ad (evalB _ Ad x1)
        (evalB _ Ad x2)
    evalCl :
      (A : Set) ->
      AdditivePointedMagma A ->
      ClAdditivePointedMagmaTerm A ->
      A
    evalCl _ Ad (sing x1) = x1
    evalCl _ Ad (0Cl) = 0 Ad
    evalCl _ Ad (+Cl x1 x2) =
      + Ad (evalCl _ Ad x1)
        (evalCl _ Ad x2)
    evalOp :
      (A : Set) (n : Nat) ->
      AdditivePointedMagma A ->
      Vec A n ->
      OpAdditivePointedMagmaTerm n ->
      A
    evalOp _ n Ad vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ad vars (0OL) = 0 Ad
    evalOp _ n Ad vars (+OL x1 x2) =
      + Ad (evalOp _ n Ad vars x1)
        (evalOp _ n Ad vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      AdditivePointedMagma A ->
      Vec A n ->
      OpAdditivePointedMagmaTerm2 n
        A -> A
    evalOpE _ n Ad vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ad vars (sing2 x1) =
      x1
    evalOpE _ n Ad vars (0OL2) =
      0 Ad
    evalOpE _ n Ad vars (+OL2
                         x1
                         x2) =
      + Ad (evalOpE _ n Ad vars x1)
        (evalOpE _ n Ad vars x2)
    inductionB :
      (P : AdditivePointedMagmaTerm ->
           Set) ->
      P 0L ->
      ((x1 : AdditivePointedMagmaTerm)
       (x2 : AdditivePointedMagmaTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : AdditivePointedMagmaTerm) ->
      P x
    inductionB p p0l p+l (0L) = p0l
    inductionB p p0l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p0l p+l x1)
        (inductionB p p0l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClAdditivePointedMagmaTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 0Cl ->
      ((x1 : ClAdditivePointedMagmaTerm
          A)
       (x2 : ClAdditivePointedMagmaTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClAdditivePointedMagmaTerm
         A) -> P x
    inductionCl _ p psing p0cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p0cl p+cl (0Cl) =
      p0cl
    inductionCl _ p psing p0cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p0cl p+cl
           x1)
        (inductionCl _ p psing p0cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpAdditivePointedMagmaTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 0OL ->
      ((x1 : OpAdditivePointedMagmaTerm
          n)
       (x2 : OpAdditivePointedMagmaTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpAdditivePointedMagmaTerm
         n) -> P x
    inductionOp _ p pv p0ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p0ol p+ol (0OL) =
      p0ol
    inductionOp _ p pv p0ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p0ol p+ol
           x1)
        (inductionOp _ p pv p0ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAdditivePointedMagmaTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 0OL2 ->
      ((x1 : OpAdditivePointedMagmaTerm2
          n
          A)
       (x2 : OpAdditivePointedMagmaTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpAdditivePointedMagmaTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           x2)
    0L' : AdditivePointedMagmaTerm
    0L' = 0L
    +L' :
      AdditivePointedMagmaTerm ->
      AdditivePointedMagmaTerm ->
      AdditivePointedMagmaTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      AdditivePointedMagmaTerm ->
      Staged AdditivePointedMagmaTerm
    stageB (0L) = Now 0L
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    0Cl' :
      (A : Set) ->
      ClAdditivePointedMagmaTerm A
    0Cl' _ = 0Cl
    +Cl' :
      (A : Set) ->
      ClAdditivePointedMagmaTerm A ->
      ClAdditivePointedMagmaTerm A ->
      ClAdditivePointedMagmaTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClAdditivePointedMagmaTerm A ->
      Staged
        (ClAdditivePointedMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    0OL' :
      (n : Nat) ->
      OpAdditivePointedMagmaTerm n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      OpAdditivePointedMagmaTerm n ->
      OpAdditivePointedMagmaTerm n ->
      OpAdditivePointedMagmaTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpAdditivePointedMagmaTerm n ->
      Staged
        (OpAdditivePointedMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (0OL) = Now 0OL
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    0OL2' :
      (n : Nat) (A : Set) ->
      OpAdditivePointedMagmaTerm2 n A
    0OL2' _ _ = 0OL2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAdditivePointedMagmaTerm2 n
        A ->
      OpAdditivePointedMagmaTerm2 n
        A ->
      OpAdditivePointedMagmaTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAdditivePointedMagmaTerm2 n
        A ->
      Staged
        (OpAdditivePointedMagmaTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record AdditivePointedMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        0T : Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module AdditivePointedSemigroup where
    record AdditivePointedSemigroup
      (A : Set) : Set where
      constructor AdditivePointedSemigroupC
      field
        0 : A
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record AdditivePointedSemigroupSig
      (AS : Set) : Set where
      constructor AdditivePointedSemigroupSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
    record AdditivePointedSemigroupProd
      (AP : Set) : Set where
      constructor AdditivePointedSemigroupProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record AdditivePointedSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditivePointedSemigroup
         A1)
      (Ad2 : AdditivePointedSemigroup
         A2) : Set where
      constructor AdditivePointedSemigroupHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditivePointedSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditivePointedSemigroup
         A1)
      (Ad2 : AdditivePointedSemigroup
         A2) : Set where
      constructor AdditivePointedSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditivePointedSemigroupTerm
      : Set where
      0L :
        AdditivePointedSemigroupTerm
      +L :
        AdditivePointedSemigroupTerm ->
        AdditivePointedSemigroupTerm ->
        AdditivePointedSemigroupTerm
    data ClAdditivePointedSemigroupTerm
      (A : Set) : Set where
      sing :
        A ->
        ClAdditivePointedSemigroupTerm A
      0Cl :
        ClAdditivePointedSemigroupTerm A
      +Cl :
        ClAdditivePointedSemigroupTerm
          A ->
        ClAdditivePointedSemigroupTerm
          A ->
        ClAdditivePointedSemigroupTerm A
    data OpAdditivePointedSemigroupTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpAdditivePointedSemigroupTerm n
      0OL :
        OpAdditivePointedSemigroupTerm n
      +OL :
        OpAdditivePointedSemigroupTerm
          n ->
        OpAdditivePointedSemigroupTerm
          n ->
        OpAdditivePointedSemigroupTerm n
    data OpAdditivePointedSemigroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAdditivePointedSemigroupTerm2
          n
          A
      sing2 :
        A ->
        OpAdditivePointedSemigroupTerm2
          n
          A
      0OL2 :
        OpAdditivePointedSemigroupTerm2
          n
          A
      +OL2 :
        OpAdditivePointedSemigroupTerm2
          n
          A ->
        OpAdditivePointedSemigroupTerm2
          n
          A ->
        OpAdditivePointedSemigroupTerm2
          n
          A
    simplifyB :
      AdditivePointedSemigroupTerm ->
      AdditivePointedSemigroupTerm
    simplifyB (0L) = 0L
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClAdditivePointedSemigroupTerm
        A ->
      ClAdditivePointedSemigroupTerm A
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAdditivePointedSemigroupTerm
        n ->
      OpAdditivePointedSemigroupTerm n
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAdditivePointedSemigroupTerm2
        n
        A ->
      OpAdditivePointedSemigroupTerm2
        n
        A
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AdditivePointedSemigroup A ->
      AdditivePointedSemigroupTerm ->
      A
    evalB _ Ad (0L) = 0 Ad
    evalB _ Ad (+L x1 x2) =
      + Ad (evalB _ Ad x1)
        (evalB _ Ad x2)
    evalCl :
      (A : Set) ->
      AdditivePointedSemigroup A ->
      ClAdditivePointedSemigroupTerm
        A -> A
    evalCl _ Ad (sing x1) = x1
    evalCl _ Ad (0Cl) = 0 Ad
    evalCl _ Ad (+Cl x1 x2) =
      + Ad (evalCl _ Ad x1)
        (evalCl _ Ad x2)
    evalOp :
      (A : Set) (n : Nat) ->
      AdditivePointedSemigroup A ->
      Vec A n ->
      OpAdditivePointedSemigroupTerm
        n -> A
    evalOp _ n Ad vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ad vars (0OL) = 0 Ad
    evalOp _ n Ad vars (+OL x1 x2) =
      + Ad (evalOp _ n Ad vars x1)
        (evalOp _ n Ad vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      AdditivePointedSemigroup A ->
      Vec A n ->
      OpAdditivePointedSemigroupTerm2
        n
        A -> A
    evalOpE _ n Ad vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ad vars (sing2 x1) =
      x1
    evalOpE _ n Ad vars (0OL2) =
      0 Ad
    evalOpE _ n Ad vars (+OL2
                         x1
                         x2) =
      + Ad (evalOpE _ n Ad vars x1)
        (evalOpE _ n Ad vars x2)
    inductionB :
      (P : AdditivePointedSemigroupTerm ->
           Set) ->
      P 0L ->
      ((x1 : AdditivePointedSemigroupTerm)
       (x2 : AdditivePointedSemigroupTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : AdditivePointedSemigroupTerm) ->
      P x
    inductionB p p0l p+l (0L) = p0l
    inductionB p p0l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p0l p+l x1)
        (inductionB p p0l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClAdditivePointedSemigroupTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 0Cl ->
      ((x1 : ClAdditivePointedSemigroupTerm
          A)
       (x2 : ClAdditivePointedSemigroupTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClAdditivePointedSemigroupTerm
         A) -> P x
    inductionCl _ p psing p0cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p0cl p+cl (0Cl) =
      p0cl
    inductionCl _ p psing p0cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p0cl p+cl
           x1)
        (inductionCl _ p psing p0cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpAdditivePointedSemigroupTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 0OL ->
      ((x1 : OpAdditivePointedSemigroupTerm
          n)
       (x2 : OpAdditivePointedSemigroupTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpAdditivePointedSemigroupTerm
         n) -> P x
    inductionOp _ p pv p0ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p0ol p+ol (0OL) =
      p0ol
    inductionOp _ p pv p0ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p0ol p+ol
           x1)
        (inductionOp _ p pv p0ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAdditivePointedSemigroupTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 0OL2 ->
      ((x1 : OpAdditivePointedSemigroupTerm2
          n
          A)
       (x2 : OpAdditivePointedSemigroupTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpAdditivePointedSemigroupTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           x2)
    0L' :
      AdditivePointedSemigroupTerm
    0L' = 0L
    +L' :
      AdditivePointedSemigroupTerm ->
      AdditivePointedSemigroupTerm ->
      AdditivePointedSemigroupTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      AdditivePointedSemigroupTerm ->
      Staged
        AdditivePointedSemigroupTerm
    stageB (0L) = Now 0L
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    0Cl' :
      (A : Set) ->
      ClAdditivePointedSemigroupTerm A
    0Cl' _ = 0Cl
    +Cl' :
      (A : Set) ->
      ClAdditivePointedSemigroupTerm
        A ->
      ClAdditivePointedSemigroupTerm
        A ->
      ClAdditivePointedSemigroupTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClAdditivePointedSemigroupTerm
        A ->
      Staged
        (ClAdditivePointedSemigroupTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    0OL' :
      (n : Nat) ->
      OpAdditivePointedSemigroupTerm n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      OpAdditivePointedSemigroupTerm
        n ->
      OpAdditivePointedSemigroupTerm
        n ->
      OpAdditivePointedSemigroupTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpAdditivePointedSemigroupTerm
        n ->
      Staged
        (OpAdditivePointedSemigroupTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (0OL) = Now 0OL
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    0OL2' :
      (n : Nat) (A : Set) ->
      OpAdditivePointedSemigroupTerm2
        n
        A
    0OL2' _ _ = 0OL2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAdditivePointedSemigroupTerm2
        n
        A ->
      OpAdditivePointedSemigroupTerm2
        n
        A ->
      OpAdditivePointedSemigroupTerm2
        n
        A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAdditivePointedSemigroupTerm2
        n
        A ->
      Staged
        (OpAdditivePointedSemigroupTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record AdditivePointedSemigroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        0T : Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module AdditiveSemigroup where
    record AdditiveSemigroup
      (A : Set) : Set where
      constructor AdditiveSemigroupC
      field
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record AdditiveSemigroupSig
      (AS : Set) : Set where
      constructor AdditiveSemigroupSigSigC
      field
        +S : AS -> AS -> AS
    record AdditiveSemigroupProd
      (AP : Set) : Set where
      constructor AdditiveSemigroupProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record AdditiveSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveSemigroup A1)
      (Ad2 : AdditiveSemigroup A2) :
      Set where
      constructor AdditiveSemigroupHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveSemigroup A1)
      (Ad2 : AdditiveSemigroup A2) :
      Set where
      constructor AdditiveSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveSemigroupTerm
      : Set where
      +L :
        AdditiveSemigroupTerm ->
        AdditiveSemigroupTerm ->
        AdditiveSemigroupTerm
    data ClAdditiveSemigroupTerm
      (A : Set) : Set where
      sing :
        A -> ClAdditiveSemigroupTerm A
      +Cl :
        ClAdditiveSemigroupTerm A ->
        ClAdditiveSemigroupTerm A ->
        ClAdditiveSemigroupTerm A
    data OpAdditiveSemigroupTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpAdditiveSemigroupTerm n
      +OL :
        OpAdditiveSemigroupTerm n ->
        OpAdditiveSemigroupTerm n ->
        OpAdditiveSemigroupTerm n
    data OpAdditiveSemigroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAdditiveSemigroupTerm2 n A
      sing2 :
        A ->
        OpAdditiveSemigroupTerm2 n A
      +OL2 :
        OpAdditiveSemigroupTerm2 n A ->
        OpAdditiveSemigroupTerm2 n A ->
        OpAdditiveSemigroupTerm2 n A
    simplifyB :
      AdditiveSemigroupTerm ->
      AdditiveSemigroupTerm
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClAdditiveSemigroupTerm A ->
      ClAdditiveSemigroupTerm A
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAdditiveSemigroupTerm n ->
      OpAdditiveSemigroupTerm n
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAdditiveSemigroupTerm2 n A ->
      OpAdditiveSemigroupTerm2 n A
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AdditiveSemigroup A ->
      AdditiveSemigroupTerm -> A
    evalB _ Ad (+L x1 x2) =
      + Ad (evalB _ Ad x1)
        (evalB _ Ad x2)
    evalCl :
      (A : Set) ->
      AdditiveSemigroup A ->
      ClAdditiveSemigroupTerm A -> A
    evalCl _ Ad (sing x1) = x1
    evalCl _ Ad (+Cl x1 x2) =
      + Ad (evalCl _ Ad x1)
        (evalCl _ Ad x2)
    evalOp :
      (A : Set) (n : Nat) ->
      AdditiveSemigroup A ->
      Vec A n ->
      OpAdditiveSemigroupTerm n -> A
    evalOp _ n Ad vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ad vars (+OL x1 x2) =
      + Ad (evalOp _ n Ad vars x1)
        (evalOp _ n Ad vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      AdditiveSemigroup A ->
      Vec A n ->
      OpAdditiveSemigroupTerm2 n A ->
      A
    evalOpE _ n Ad vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ad vars (sing2 x1) =
      x1
    evalOpE _ n Ad vars (+OL2
                         x1
                         x2) =
      + Ad (evalOpE _ n Ad vars x1)
        (evalOpE _ n Ad vars x2)
    inductionB :
      (P : AdditiveSemigroupTerm ->
           Set) ->
      ((x1 : AdditiveSemigroupTerm)
       (x2 : AdditiveSemigroupTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : AdditiveSemigroupTerm) ->
      P x
    inductionB p p+l (+L x1 x2) =
      p+l _ _ (inductionB p p+l x1)
        (inductionB p p+l x2)
    inductionCl :
      (A : Set)
      (P : ClAdditiveSemigroupTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClAdditiveSemigroupTerm
          A)
       (x2 : ClAdditiveSemigroupTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClAdditiveSemigroupTerm
         A) -> P x
    inductionCl _ p psing p+cl (sing
                                x1) = psing x1
    inductionCl _ p psing p+cl (+Cl
                                x1
                                x2) =
      p+cl _ _
        (inductionCl _ p psing p+cl x1)
        (inductionCl _ p psing p+cl x2)
    inductionOp :
      (n : Nat)
      (P : OpAdditiveSemigroupTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpAdditiveSemigroupTerm
          n)
       (x2 : OpAdditiveSemigroupTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpAdditiveSemigroupTerm
         n) -> P x
    inductionOp _ p pv p+ol (v x1) =
      pv x1
    inductionOp _ p pv p+ol (+OL
                             x1
                             x2) =
      p+ol _ _
        (inductionOp _ p pv p+ol x1)
        (inductionOp _ p pv p+ol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAdditiveSemigroupTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpAdditiveSemigroupTerm2
          n
          A)
       (x2 : OpAdditiveSemigroupTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpAdditiveSemigroupTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p+ol2 (v2
                                         x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 (sing2
                                         x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 (+OL2
                                         x1
                                         x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           x2)
    +L' :
      AdditiveSemigroupTerm ->
      AdditiveSemigroupTerm ->
      AdditiveSemigroupTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      AdditiveSemigroupTerm ->
      Staged AdditiveSemigroupTerm
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    +Cl' :
      (A : Set) ->
      ClAdditiveSemigroupTerm A ->
      ClAdditiveSemigroupTerm A ->
      ClAdditiveSemigroupTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClAdditiveSemigroupTerm A ->
      Staged
        (ClAdditiveSemigroupTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    +OL' :
      (n : Nat) ->
      OpAdditiveSemigroupTerm n ->
      OpAdditiveSemigroupTerm n ->
      OpAdditiveSemigroupTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpAdditiveSemigroupTerm n ->
      Staged
        (OpAdditiveSemigroupTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAdditiveSemigroupTerm2 n A ->
      OpAdditiveSemigroupTerm2 n A ->
      OpAdditiveSemigroupTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAdditiveSemigroupTerm2 n A ->
      Staged
        (OpAdditiveSemigroupTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record AdditiveSemigroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        +T : Repr A -> Repr A -> Repr A
  
  module AdditiveUnaryAntiDistribution where
    record AdditiveUnaryAntiDistribution
      (A : Set) : Set where
      constructor AdditiveUnaryAntiDistributionC
      field
        prim : A -> A
        + : A -> A -> A
        antidis_prim_+ :
          (x : A) (y : A) ->
          prim (+ x y) ==
            + (prim y) (prim x)
    record AdditiveUnaryAntiDistributionSig
      (AS : Set) : Set where
      constructor AdditiveUnaryAntiDistributionSigSigC
      field
        primS : AS -> AS
        +S : AS -> AS -> AS
    record AdditiveUnaryAntiDistributionProd
      (AP : Set) : Set where
      constructor AdditiveUnaryAntiDistributionProdC
      field
        primP : Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        antidis_prim_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (+P xP yP) ==
            +P (primP yP) (primP xP)
    record AdditiveUnaryAntiDistributionHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveUnaryAntiDistribution
         A1)
      (Ad2 : AdditiveUnaryAntiDistribution
         A2) : Set where
      constructor AdditiveUnaryAntiDistributionHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Ad1 x1) ==
            prim Ad2 (hom x1)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveUnaryAntiDistributionRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveUnaryAntiDistribution
         A1)
      (Ad2 : AdditiveUnaryAntiDistribution
         A2) : Set where
      constructor AdditiveUnaryAntiDistributionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Ad1 x1)
            (prim Ad2 y1)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveUnaryAntiDistributionTerm
      : Set where
      primL :
        AdditiveUnaryAntiDistributionTerm ->
        AdditiveUnaryAntiDistributionTerm
      +L :
        AdditiveUnaryAntiDistributionTerm ->
        AdditiveUnaryAntiDistributionTerm ->
        AdditiveUnaryAntiDistributionTerm
    data ClAdditiveUnaryAntiDistributionTerm
      (A : Set) : Set where
      sing :
        A ->
        ClAdditiveUnaryAntiDistributionTerm
          A
      primCl :
        ClAdditiveUnaryAntiDistributionTerm
          A ->
        ClAdditiveUnaryAntiDistributionTerm
          A
      +Cl :
        ClAdditiveUnaryAntiDistributionTerm
          A ->
        ClAdditiveUnaryAntiDistributionTerm
          A ->
        ClAdditiveUnaryAntiDistributionTerm
          A
    data OpAdditiveUnaryAntiDistributionTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpAdditiveUnaryAntiDistributionTerm
          n
      primOL :
        OpAdditiveUnaryAntiDistributionTerm
          n ->
        OpAdditiveUnaryAntiDistributionTerm
          n
      +OL :
        OpAdditiveUnaryAntiDistributionTerm
          n ->
        OpAdditiveUnaryAntiDistributionTerm
          n ->
        OpAdditiveUnaryAntiDistributionTerm
          n
    data OpAdditiveUnaryAntiDistributionTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAdditiveUnaryAntiDistributionTerm2
          n
          A
      sing2 :
        A ->
        OpAdditiveUnaryAntiDistributionTerm2
          n
          A
      primOL2 :
        OpAdditiveUnaryAntiDistributionTerm2
          n
          A ->
        OpAdditiveUnaryAntiDistributionTerm2
          n
          A
      +OL2 :
        OpAdditiveUnaryAntiDistributionTerm2
          n
          A ->
        OpAdditiveUnaryAntiDistributionTerm2
          n
          A ->
        OpAdditiveUnaryAntiDistributionTerm2
          n
          A
    simplifyB :
      AdditiveUnaryAntiDistributionTerm ->
      AdditiveUnaryAntiDistributionTerm
    simplifyB (+L
               (primL y)
               (primL x)) = primL (+L x y)
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClAdditiveUnaryAntiDistributionTerm
        A ->
      ClAdditiveUnaryAntiDistributionTerm
        A
    simplifyCl _ (+Cl
                  (primCl y)
                  (primCl x)) = primCl (+Cl x y)
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAdditiveUnaryAntiDistributionTerm
        n ->
      OpAdditiveUnaryAntiDistributionTerm
        n
    simplifyOp _ (+OL
                  (primOL y)
                  (primOL x)) = primOL (+OL x y)
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAdditiveUnaryAntiDistributionTerm2
        n
        A ->
      OpAdditiveUnaryAntiDistributionTerm2
        n
        A
    simplifyOpE _ _ (+OL2
                     (primOL2 y)
                     (primOL2 x)) =
      primOL2 (+OL2 x y)
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AdditiveUnaryAntiDistribution
        A ->
      AdditiveUnaryAntiDistributionTerm ->
      A
    evalB _ Ad (primL x1) =
      prim Ad (evalB _ Ad x1)
    evalB _ Ad (+L x1 x2) =
      + Ad (evalB _ Ad x1)
        (evalB _ Ad x2)
    evalCl :
      (A : Set) ->
      AdditiveUnaryAntiDistribution
        A ->
      ClAdditiveUnaryAntiDistributionTerm
        A -> A
    evalCl _ Ad (sing x1) = x1
    evalCl _ Ad (primCl x1) =
      prim Ad (evalCl _ Ad x1)
    evalCl _ Ad (+Cl x1 x2) =
      + Ad (evalCl _ Ad x1)
        (evalCl _ Ad x2)
    evalOp :
      (A : Set) (n : Nat) ->
      AdditiveUnaryAntiDistribution
        A ->
      Vec A n ->
      OpAdditiveUnaryAntiDistributionTerm
        n -> A
    evalOp _ n Ad vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ad vars (primOL x1) =
      prim Ad (evalOp _ n Ad vars x1)
    evalOp _ n Ad vars (+OL x1 x2) =
      + Ad (evalOp _ n Ad vars x1)
        (evalOp _ n Ad vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      AdditiveUnaryAntiDistribution
        A ->
      Vec A n ->
      OpAdditiveUnaryAntiDistributionTerm2
        n
        A -> A
    evalOpE _ n Ad vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ad vars (sing2 x1) =
      x1
    evalOpE _ n Ad vars (primOL2
                         x1) =
      prim Ad (evalOpE _ n Ad vars x1)
    evalOpE _ n Ad vars (+OL2
                         x1
                         x2) =
      + Ad (evalOpE _ n Ad vars x1)
        (evalOpE _ n Ad vars x2)
    inductionB :
      (P : AdditiveUnaryAntiDistributionTerm ->
           Set) ->
      ((x1 : AdditiveUnaryAntiDistributionTerm) ->
       P x1 -> P (primL x1)) ->
      ((x1 : AdditiveUnaryAntiDistributionTerm)
       (x2 : AdditiveUnaryAntiDistributionTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : AdditiveUnaryAntiDistributionTerm) ->
      P x
    inductionB p ppriml p+l (primL
                             x1) =
      ppriml _
        (inductionB p ppriml p+l x1)
    inductionB p ppriml p+l (+L
                             x1
                             x2) =
      p+l _ _
        (inductionB p ppriml p+l x1)
        (inductionB p ppriml p+l x2)
    inductionCl :
      (A : Set)
      (P : ClAdditiveUnaryAntiDistributionTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClAdditiveUnaryAntiDistributionTerm
          A) -> P x1 -> P (primCl x1)) ->
      ((x1 : ClAdditiveUnaryAntiDistributionTerm
          A)
       (x2 : ClAdditiveUnaryAntiDistributionTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClAdditiveUnaryAntiDistributionTerm
         A) -> P x
    inductionCl _ p psing pprimcl p+cl (sing
                                        x1) = psing x1
    inductionCl _ p psing pprimcl p+cl (primCl
                                        x1) =
      pprimcl _
        (inductionCl _ p psing pprimcl
           p+cl
           x1)
    inductionCl _ p psing pprimcl p+cl (+Cl
                                        x1
                                        x2) =
      p+cl _ _
        (inductionCl _ p psing pprimcl
           p+cl
           x1)
        (inductionCl _ p psing pprimcl
           p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpAdditiveUnaryAntiDistributionTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpAdditiveUnaryAntiDistributionTerm
          n) -> P x1 -> P (primOL x1)) ->
      ((x1 : OpAdditiveUnaryAntiDistributionTerm
          n)
       (x2 : OpAdditiveUnaryAntiDistributionTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpAdditiveUnaryAntiDistributionTerm
         n) -> P x
    inductionOp _ p pv pprimol p+ol (v
                                     x1) = pv x1
    inductionOp _ p pv pprimol p+ol (primOL
                                     x1) =
      pprimol _
        (inductionOp _ p pv pprimol p+ol
           x1)
    inductionOp _ p pv pprimol p+ol (+OL
                                     x1
                                     x2) =
      p+ol _ _
        (inductionOp _ p pv pprimol p+ol
           x1)
        (inductionOp _ p pv pprimol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAdditiveUnaryAntiDistributionTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpAdditiveUnaryAntiDistributionTerm2
          n
          A) -> P x1 -> P (primOL2 x1)) ->
      ((x1 : OpAdditiveUnaryAntiDistributionTerm2
          n
          A)
       (x2 : OpAdditiveUnaryAntiDistributionTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpAdditiveUnaryAntiDistributionTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 pprimol2 p+ol2 (v2
                                                  x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 p+ol2 (sing2
                                                  x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 p+ol2 (primOL2
                                                  x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           p+ol2
           x1)
    inductionOpE _ _ p pv2 psing2 pprimol2 p+ol2 (+OL2
                                                  x1
                                                  x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           p+ol2
           x2)
    primL' :
      AdditiveUnaryAntiDistributionTerm ->
      AdditiveUnaryAntiDistributionTerm
    primL' x1 = primL x1
    +L' :
      AdditiveUnaryAntiDistributionTerm ->
      AdditiveUnaryAntiDistributionTerm ->
      AdditiveUnaryAntiDistributionTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      AdditiveUnaryAntiDistributionTerm ->
      Staged
        AdditiveUnaryAntiDistributionTerm
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    primCl' :
      (A : Set) ->
      ClAdditiveUnaryAntiDistributionTerm
        A ->
      ClAdditiveUnaryAntiDistributionTerm
        A
    primCl' _ x1 = primCl x1
    +Cl' :
      (A : Set) ->
      ClAdditiveUnaryAntiDistributionTerm
        A ->
      ClAdditiveUnaryAntiDistributionTerm
        A ->
      ClAdditiveUnaryAntiDistributionTerm
        A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClAdditiveUnaryAntiDistributionTerm
        A ->
      Staged
        (ClAdditiveUnaryAntiDistributionTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    primOL' :
      (n : Nat) ->
      OpAdditiveUnaryAntiDistributionTerm
        n ->
      OpAdditiveUnaryAntiDistributionTerm
        n
    primOL' _ x1 = primOL x1
    +OL' :
      (n : Nat) ->
      OpAdditiveUnaryAntiDistributionTerm
        n ->
      OpAdditiveUnaryAntiDistributionTerm
        n ->
      OpAdditiveUnaryAntiDistributionTerm
        n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpAdditiveUnaryAntiDistributionTerm
        n ->
      Staged
        (OpAdditiveUnaryAntiDistributionTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    primOL2' :
      (n : Nat) (A : Set) ->
      OpAdditiveUnaryAntiDistributionTerm2
        n
        A ->
      OpAdditiveUnaryAntiDistributionTerm2
        n
        A
    primOL2' _ _ x1 = primOL2 x1
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAdditiveUnaryAntiDistributionTerm2
        n
        A ->
      OpAdditiveUnaryAntiDistributionTerm2
        n
        A ->
      OpAdditiveUnaryAntiDistributionTerm2
        n
        A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAdditiveUnaryAntiDistributionTerm2
        n
        A ->
      Staged
        (OpAdditiveUnaryAntiDistributionTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record AdditiveUnaryAntiDistributionTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        primT : Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module AdditiveUnital where
    record AdditiveUnital
      (A : Set) : Set where
      constructor AdditiveUnitalC
      field
        0 : A
        + : A -> A -> A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
    record AdditiveUnitalSig
      (AS : Set) : Set where
      constructor AdditiveUnitalSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
    record AdditiveUnitalProd
      (AP : Set) : Set where
      constructor AdditiveUnitalProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
    record AdditiveUnitalHom
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveUnital A1)
      (Ad2 : AdditiveUnital A2) :
      Set where
      constructor AdditiveUnitalHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ad1) == 0 Ad2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ad1 x1 x2) ==
            + Ad2 (hom x1) (hom x2)
    record AdditiveUnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Ad1 : AdditiveUnital A1)
      (Ad2 : AdditiveUnital A2) :
      Set where
      constructor AdditiveUnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ad1) (0 Ad2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ad1 x1 x2)
            (+ Ad2 y1 y2)
    data AdditiveUnitalTerm
      : Set where
      0L : AdditiveUnitalTerm
      +L :
        AdditiveUnitalTerm ->
        AdditiveUnitalTerm ->
        AdditiveUnitalTerm
    data ClAdditiveUnitalTerm
      (A : Set) : Set where
      sing :
        A -> ClAdditiveUnitalTerm A
      0Cl : ClAdditiveUnitalTerm A
      +Cl :
        ClAdditiveUnitalTerm A ->
        ClAdditiveUnitalTerm A ->
        ClAdditiveUnitalTerm A
    data OpAdditiveUnitalTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpAdditiveUnitalTerm n
      0OL : OpAdditiveUnitalTerm n
      +OL :
        OpAdditiveUnitalTerm n ->
        OpAdditiveUnitalTerm n ->
        OpAdditiveUnitalTerm n
    data OpAdditiveUnitalTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAdditiveUnitalTerm2 n A
      sing2 :
        A -> OpAdditiveUnitalTerm2 n A
      0OL2 : OpAdditiveUnitalTerm2 n A
      +OL2 :
        OpAdditiveUnitalTerm2 n A ->
        OpAdditiveUnitalTerm2 n A ->
        OpAdditiveUnitalTerm2 n A
    simplifyB :
      AdditiveUnitalTerm ->
      AdditiveUnitalTerm
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (0L) = 0L
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClAdditiveUnitalTerm A ->
      ClAdditiveUnitalTerm A
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAdditiveUnitalTerm n ->
      OpAdditiveUnitalTerm n
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAdditiveUnitalTerm2 n A ->
      OpAdditiveUnitalTerm2 n A
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AdditiveUnital A ->
      AdditiveUnitalTerm -> A
    evalB _ Ad (0L) = 0 Ad
    evalB _ Ad (+L x1 x2) =
      + Ad (evalB _ Ad x1)
        (evalB _ Ad x2)
    evalCl :
      (A : Set) ->
      AdditiveUnital A ->
      ClAdditiveUnitalTerm A -> A
    evalCl _ Ad (sing x1) = x1
    evalCl _ Ad (0Cl) = 0 Ad
    evalCl _ Ad (+Cl x1 x2) =
      + Ad (evalCl _ Ad x1)
        (evalCl _ Ad x2)
    evalOp :
      (A : Set) (n : Nat) ->
      AdditiveUnital A ->
      Vec A n ->
      OpAdditiveUnitalTerm n -> A
    evalOp _ n Ad vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ad vars (0OL) = 0 Ad
    evalOp _ n Ad vars (+OL x1 x2) =
      + Ad (evalOp _ n Ad vars x1)
        (evalOp _ n Ad vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      AdditiveUnital A ->
      Vec A n ->
      OpAdditiveUnitalTerm2 n A -> A
    evalOpE _ n Ad vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ad vars (sing2 x1) =
      x1
    evalOpE _ n Ad vars (0OL2) =
      0 Ad
    evalOpE _ n Ad vars (+OL2
                         x1
                         x2) =
      + Ad (evalOpE _ n Ad vars x1)
        (evalOpE _ n Ad vars x2)
    inductionB :
      (P : AdditiveUnitalTerm ->
           Set) ->
      P 0L ->
      ((x1 : AdditiveUnitalTerm)
       (x2 : AdditiveUnitalTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : AdditiveUnitalTerm) -> P x
    inductionB p p0l p+l (0L) = p0l
    inductionB p p0l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p0l p+l x1)
        (inductionB p p0l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClAdditiveUnitalTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 0Cl ->
      ((x1 : ClAdditiveUnitalTerm A)
       (x2 : ClAdditiveUnitalTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClAdditiveUnitalTerm A) ->
      P x
    inductionCl _ p psing p0cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p0cl p+cl (0Cl) =
      p0cl
    inductionCl _ p psing p0cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p0cl p+cl
           x1)
        (inductionCl _ p psing p0cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpAdditiveUnitalTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 0OL ->
      ((x1 : OpAdditiveUnitalTerm n)
       (x2 : OpAdditiveUnitalTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpAdditiveUnitalTerm n) ->
      P x
    inductionOp _ p pv p0ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p0ol p+ol (0OL) =
      p0ol
    inductionOp _ p pv p0ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p0ol p+ol
           x1)
        (inductionOp _ p pv p0ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAdditiveUnitalTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 0OL2 ->
      ((x1 : OpAdditiveUnitalTerm2 n
          A)
       (x2 : OpAdditiveUnitalTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpAdditiveUnitalTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           x2)
    0L' : AdditiveUnitalTerm
    0L' = 0L
    +L' :
      AdditiveUnitalTerm ->
      AdditiveUnitalTerm ->
      AdditiveUnitalTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      AdditiveUnitalTerm ->
      Staged AdditiveUnitalTerm
    stageB (0L) = Now 0L
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    0Cl' :
      (A : Set) ->
      ClAdditiveUnitalTerm A
    0Cl' _ = 0Cl
    +Cl' :
      (A : Set) ->
      ClAdditiveUnitalTerm A ->
      ClAdditiveUnitalTerm A ->
      ClAdditiveUnitalTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClAdditiveUnitalTerm A ->
      Staged (ClAdditiveUnitalTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    0OL' :
      (n : Nat) ->
      OpAdditiveUnitalTerm n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      OpAdditiveUnitalTerm n ->
      OpAdditiveUnitalTerm n ->
      OpAdditiveUnitalTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpAdditiveUnitalTerm n ->
      Staged (OpAdditiveUnitalTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (0OL) = Now 0OL
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    0OL2' :
      (n : Nat) (A : Set) ->
      OpAdditiveUnitalTerm2 n A
    0OL2' _ _ = 0OL2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAdditiveUnitalTerm2 n A ->
      OpAdditiveUnitalTerm2 n A ->
      OpAdditiveUnitalTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAdditiveUnitalTerm2 n A ->
      Staged
        (OpAdditiveUnitalTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record AdditiveUnitalTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        0T : Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module AndDeMorgan where
    record AndDeMorgan
      (A : Set) : Set where
      constructor AndDeMorganC
      field
        * : A -> A -> A
        + : A -> A -> A
        prim : A -> A
        andDeMorgan_*_+_prim :
          (x : A) (y : A) (z : A) ->
          prim (* x y) ==
            + (prim x) (prim y)
    record AndDeMorganSig
      (AS : Set) : Set where
      constructor AndDeMorganSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        primS : AS -> AS
    record AndDeMorganProd
      (AP : Set) : Set where
      constructor AndDeMorganProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        andDeMorgan_*_+_primP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          primP (*P xP yP) ==
            +P (primP xP) (primP yP)
    record AndDeMorganHom
      (A1 : Set) (A2 : Set)
      (An1 : AndDeMorgan A1)
      (An2 : AndDeMorgan A2) :
      Set where
      constructor AndDeMorganHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* An1 x1 x2) ==
            * An2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ An1 x1 x2) ==
            + An2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim An1 x1) ==
            prim An2 (hom x1)
    record AndDeMorganRelInterp
      (A1 : Set) (A2 : Set)
      (An1 : AndDeMorgan A1)
      (An2 : AndDeMorgan A2) :
      Set where
      constructor AndDeMorganRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* An1 x1 x2)
            (* An2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ An1 x1 x2)
            (+ An2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim An1 x1)
            (prim An2 y1)
    data AndDeMorganTerm : Set where
      *L :
        AndDeMorganTerm ->
        AndDeMorganTerm ->
        AndDeMorganTerm
      +L :
        AndDeMorganTerm ->
        AndDeMorganTerm ->
        AndDeMorganTerm
      primL :
        AndDeMorganTerm ->
        AndDeMorganTerm
    data ClAndDeMorganTerm
      (A : Set) : Set where
      sing :
        A -> ClAndDeMorganTerm A
      *Cl :
        ClAndDeMorganTerm A ->
        ClAndDeMorganTerm A ->
        ClAndDeMorganTerm A
      +Cl :
        ClAndDeMorganTerm A ->
        ClAndDeMorganTerm A ->
        ClAndDeMorganTerm A
      primCl :
        ClAndDeMorganTerm A ->
        ClAndDeMorganTerm A
    data OpAndDeMorganTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpAndDeMorganTerm n
      *OL :
        OpAndDeMorganTerm n ->
        OpAndDeMorganTerm n ->
        OpAndDeMorganTerm n
      +OL :
        OpAndDeMorganTerm n ->
        OpAndDeMorganTerm n ->
        OpAndDeMorganTerm n
      primOL :
        OpAndDeMorganTerm n ->
        OpAndDeMorganTerm n
    data OpAndDeMorganTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpAndDeMorganTerm2 n A
      sing2 :
        A -> OpAndDeMorganTerm2 n A
      *OL2 :
        OpAndDeMorganTerm2 n A ->
        OpAndDeMorganTerm2 n A ->
        OpAndDeMorganTerm2 n A
      +OL2 :
        OpAndDeMorganTerm2 n A ->
        OpAndDeMorganTerm2 n A ->
        OpAndDeMorganTerm2 n A
      primOL2 :
        OpAndDeMorganTerm2 n A ->
        OpAndDeMorganTerm2 n A
    simplifyB :
      AndDeMorganTerm ->
      AndDeMorganTerm
    simplifyB (+L
               (primL x)
               (primL y)) = primL (*L x y)
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClAndDeMorganTerm A ->
      ClAndDeMorganTerm A
    simplifyCl _ (+Cl
                  (primCl x)
                  (primCl y)) = primCl (*Cl x y)
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAndDeMorganTerm n ->
      OpAndDeMorganTerm n
    simplifyOp _ (+OL
                  (primOL x)
                  (primOL y)) = primOL (*OL x y)
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAndDeMorganTerm2 n A ->
      OpAndDeMorganTerm2 n A
    simplifyOpE _ _ (+OL2
                     (primOL2 x)
                     (primOL2 y)) =
      primOL2 (*OL2 x y)
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AndDeMorgan A ->
      AndDeMorganTerm -> A
    evalB _ An (*L x1 x2) =
      * An (evalB _ An x1)
        (evalB _ An x2)
    evalB _ An (+L x1 x2) =
      + An (evalB _ An x1)
        (evalB _ An x2)
    evalB _ An (primL x1) =
      prim An (evalB _ An x1)
    evalCl :
      (A : Set) ->
      AndDeMorgan A ->
      ClAndDeMorganTerm A -> A
    evalCl _ An (sing x1) = x1
    evalCl _ An (*Cl x1 x2) =
      * An (evalCl _ An x1)
        (evalCl _ An x2)
    evalCl _ An (+Cl x1 x2) =
      + An (evalCl _ An x1)
        (evalCl _ An x2)
    evalCl _ An (primCl x1) =
      prim An (evalCl _ An x1)
    evalOp :
      (A : Set) (n : Nat) ->
      AndDeMorgan A ->
      Vec A n ->
      OpAndDeMorganTerm n -> A
    evalOp _ n An vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n An vars (*OL x1 x2) =
      * An (evalOp _ n An vars x1)
        (evalOp _ n An vars x2)
    evalOp _ n An vars (+OL x1 x2) =
      + An (evalOp _ n An vars x1)
        (evalOp _ n An vars x2)
    evalOp _ n An vars (primOL x1) =
      prim An (evalOp _ n An vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      AndDeMorgan A ->
      Vec A n ->
      OpAndDeMorganTerm2 n A -> A
    evalOpE _ n An vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n An vars (sing2 x1) =
      x1
    evalOpE _ n An vars (*OL2
                         x1
                         x2) =
      * An (evalOpE _ n An vars x1)
        (evalOpE _ n An vars x2)
    evalOpE _ n An vars (+OL2
                         x1
                         x2) =
      + An (evalOpE _ n An vars x1)
        (evalOpE _ n An vars x2)
    evalOpE _ n An vars (primOL2
                         x1) =
      prim An (evalOpE _ n An vars x1)
    inductionB :
      (P : AndDeMorganTerm -> Set) ->
      ((x1 : AndDeMorganTerm)
       (x2 : AndDeMorganTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : AndDeMorganTerm)
       (x2 : AndDeMorganTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      ((x1 : AndDeMorganTerm) ->
       P x1 -> P (primL x1)) ->
      (x : AndDeMorganTerm) -> P x
    inductionB p p*l p+l ppriml (*L
                                 x1
                                 x2) =
      p*l _ _
        (inductionB p p*l p+l ppriml x1)
        (inductionB p p*l p+l ppriml x2)
    inductionB p p*l p+l ppriml (+L
                                 x1
                                 x2) =
      p+l _ _
        (inductionB p p*l p+l ppriml x1)
        (inductionB p p*l p+l ppriml x2)
    inductionB p p*l p+l ppriml (primL
                                 x1) =
      ppriml _
        (inductionB p p*l p+l ppriml x1)
    inductionCl :
      (A : Set)
      (P : ClAndDeMorganTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClAndDeMorganTerm A)
       (x2 : ClAndDeMorganTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClAndDeMorganTerm A)
       (x2 : ClAndDeMorganTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      ((x1 : ClAndDeMorganTerm A) ->
       P x1 -> P (primCl x1)) ->
      (x : ClAndDeMorganTerm A) -> P x
    inductionCl _ p psing p*cl p+cl pprimcl (sing
                                             x1) = psing x1
    inductionCl _ p psing p*cl p+cl pprimcl (*Cl
                                             x1
                                             x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x1)
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x2)
    inductionCl _ p psing p*cl p+cl pprimcl (+Cl
                                             x1
                                             x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x1)
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x2)
    inductionCl _ p psing p*cl p+cl pprimcl (primCl
                                             x1) =
      pprimcl _
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpAndDeMorganTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpAndDeMorganTerm n)
       (x2 : OpAndDeMorganTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpAndDeMorganTerm n)
       (x2 : OpAndDeMorganTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      ((x1 : OpAndDeMorganTerm n) ->
       P x1 -> P (primOL x1)) ->
      (x : OpAndDeMorganTerm n) -> P x
    inductionOp _ p pv p*ol p+ol pprimol (v
                                          x1) = pv x1
    inductionOp _ p pv p*ol p+ol pprimol (*OL
                                          x1
                                          x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x1)
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x2)
    inductionOp _ p pv p*ol p+ol pprimol (+OL
                                          x1
                                          x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x1)
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x2)
    inductionOp _ p pv p*ol p+ol pprimol (primOL
                                          x1) =
      pprimol _
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAndDeMorganTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpAndDeMorganTerm2 n A)
       (x2 : OpAndDeMorganTerm2 n A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpAndDeMorganTerm2 n A)
       (x2 : OpAndDeMorganTerm2 n A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      ((x1 : OpAndDeMorganTerm2 n
          A) -> P x1 -> P (primOL2 x1)) ->
      (x : OpAndDeMorganTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (v2
                                                        x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (sing2
                                                        x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (*OL2
                                                        x1
                                                        x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (+OL2
                                                        x1
                                                        x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (primOL2
                                                        x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x1)
    *L' :
      AndDeMorganTerm ->
      AndDeMorganTerm ->
      AndDeMorganTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      AndDeMorganTerm ->
      AndDeMorganTerm ->
      AndDeMorganTerm
    +L' x1 x2 = +L x1 x2
    primL' :
      AndDeMorganTerm ->
      AndDeMorganTerm
    primL' x1 = primL x1
    stageB :
      AndDeMorganTerm ->
      Staged AndDeMorganTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    *Cl' :
      (A : Set) ->
      ClAndDeMorganTerm A ->
      ClAndDeMorganTerm A ->
      ClAndDeMorganTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClAndDeMorganTerm A ->
      ClAndDeMorganTerm A ->
      ClAndDeMorganTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    primCl' :
      (A : Set) ->
      ClAndDeMorganTerm A ->
      ClAndDeMorganTerm A
    primCl' _ x1 = primCl x1
    stageCl :
      (A : Set) ->
      ClAndDeMorganTerm A ->
      Staged (ClAndDeMorganTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    *OL' :
      (n : Nat) ->
      OpAndDeMorganTerm n ->
      OpAndDeMorganTerm n ->
      OpAndDeMorganTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpAndDeMorganTerm n ->
      OpAndDeMorganTerm n ->
      OpAndDeMorganTerm n
    +OL' _ x1 x2 = +OL x1 x2
    primOL' :
      (n : Nat) ->
      OpAndDeMorganTerm n ->
      OpAndDeMorganTerm n
    primOL' _ x1 = primOL x1
    stageOp :
      (n : Nat) ->
      OpAndDeMorganTerm n ->
      Staged (OpAndDeMorganTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpAndDeMorganTerm2 n A ->
      OpAndDeMorganTerm2 n A ->
      OpAndDeMorganTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAndDeMorganTerm2 n A ->
      OpAndDeMorganTerm2 n A ->
      OpAndDeMorganTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    primOL2' :
      (n : Nat) (A : Set) ->
      OpAndDeMorganTerm2 n A ->
      OpAndDeMorganTerm2 n A
    primOL2' _ _ x1 = primOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAndDeMorganTerm2 n A ->
      Staged (OpAndDeMorganTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    record AndDeMorganTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
        primT : Repr A -> Repr A
  
  module AntiAbsorbent where
    record AntiAbsorbent
      (A : Set) : Set where
      constructor AntiAbsorbentC
      field
        op : A -> A -> A
        antiAbsorbent :
          (x : A) (y : A) ->
          op x (op x y) == y
    record AntiAbsorbentSig
      (AS : Set) : Set where
      constructor AntiAbsorbentSigSigC
      field
        opS : AS -> AS -> AS
    record AntiAbsorbentProd
      (AP : Set) : Set where
      constructor AntiAbsorbentProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        antiAbsorbentP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (opP xP yP) == yP
    record AntiAbsorbentHom
      (A1 : Set) (A2 : Set)
      (An1 : AntiAbsorbent A1)
      (An2 : AntiAbsorbent A2) :
      Set where
      constructor AntiAbsorbentHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op An1 x1 x2) ==
            op An2 (hom x1) (hom x2)
    record AntiAbsorbentRelInterp
      (A1 : Set) (A2 : Set)
      (An1 : AntiAbsorbent A1)
      (An2 : AntiAbsorbent A2) :
      Set where
      constructor AntiAbsorbentRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op An1 x1 x2)
            (op An2 y1 y2)
    data AntiAbsorbentTerm
      : Set where
      opL :
        AntiAbsorbentTerm ->
        AntiAbsorbentTerm ->
        AntiAbsorbentTerm
    data ClAntiAbsorbentTerm
      (A : Set) : Set where
      sing :
        A -> ClAntiAbsorbentTerm A
      opCl :
        ClAntiAbsorbentTerm A ->
        ClAntiAbsorbentTerm A ->
        ClAntiAbsorbentTerm A
    data OpAntiAbsorbentTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpAntiAbsorbentTerm n
      opOL :
        OpAntiAbsorbentTerm n ->
        OpAntiAbsorbentTerm n ->
        OpAntiAbsorbentTerm n
    data OpAntiAbsorbentTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAntiAbsorbentTerm2 n A
      sing2 :
        A -> OpAntiAbsorbentTerm2 n A
      opOL2 :
        OpAntiAbsorbentTerm2 n A ->
        OpAntiAbsorbentTerm2 n A ->
        OpAntiAbsorbentTerm2 n A
    simplifyB :
      AntiAbsorbentTerm ->
      AntiAbsorbentTerm
    simplifyB (opL x (opL x y)) = y
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClAntiAbsorbentTerm A ->
      ClAntiAbsorbentTerm A
    simplifyCl _ (opCl
                  x
                  (opCl x y)) = y
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAntiAbsorbentTerm n ->
      OpAntiAbsorbentTerm n
    simplifyOp _ (opOL
                  x
                  (opOL x y)) = y
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAntiAbsorbentTerm2 n A ->
      OpAntiAbsorbentTerm2 n A
    simplifyOpE _ _ (opOL2
                     x
                     (opOL2 x y)) = y
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AntiAbsorbent A ->
      AntiAbsorbentTerm -> A
    evalB _ An (opL x1 x2) =
      op An (evalB _ An x1)
        (evalB _ An x2)
    evalCl :
      (A : Set) ->
      AntiAbsorbent A ->
      ClAntiAbsorbentTerm A -> A
    evalCl _ An (sing x1) = x1
    evalCl _ An (opCl x1 x2) =
      op An (evalCl _ An x1)
        (evalCl _ An x2)
    evalOp :
      (A : Set) (n : Nat) ->
      AntiAbsorbent A ->
      Vec A n ->
      OpAntiAbsorbentTerm n -> A
    evalOp _ n An vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n An vars (opOL
                        x1
                        x2) =
      op An (evalOp _ n An vars x1)
        (evalOp _ n An vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      AntiAbsorbent A ->
      Vec A n ->
      OpAntiAbsorbentTerm2 n A -> A
    evalOpE _ n An vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n An vars (sing2 x1) =
      x1
    evalOpE _ n An vars (opOL2
                         x1
                         x2) =
      op An (evalOpE _ n An vars x1)
        (evalOpE _ n An vars x2)
    inductionB :
      (P : AntiAbsorbentTerm ->
           Set) ->
      ((x1 : AntiAbsorbentTerm)
       (x2 : AntiAbsorbentTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : AntiAbsorbentTerm) -> P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClAntiAbsorbentTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClAntiAbsorbentTerm A)
       (x2 : ClAntiAbsorbentTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClAntiAbsorbentTerm A) ->
      P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpAntiAbsorbentTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpAntiAbsorbentTerm n)
       (x2 : OpAntiAbsorbentTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpAntiAbsorbentTerm n) ->
      P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAntiAbsorbentTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpAntiAbsorbentTerm2 n A)
       (x2 : OpAntiAbsorbentTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpAntiAbsorbentTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      AntiAbsorbentTerm ->
      AntiAbsorbentTerm ->
      AntiAbsorbentTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      AntiAbsorbentTerm ->
      Staged AntiAbsorbentTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClAntiAbsorbentTerm A ->
      ClAntiAbsorbentTerm A ->
      ClAntiAbsorbentTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClAntiAbsorbentTerm A ->
      Staged (ClAntiAbsorbentTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpAntiAbsorbentTerm n ->
      OpAntiAbsorbentTerm n ->
      OpAntiAbsorbentTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpAntiAbsorbentTerm n ->
      Staged (OpAntiAbsorbentTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpAntiAbsorbentTerm2 n A ->
      OpAntiAbsorbentTerm2 n A ->
      OpAntiAbsorbentTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAntiAbsorbentTerm2 n A ->
      Staged
        (OpAntiAbsorbentTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record AntiAbsorbentTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module AntiCommutativeRing where
    record AntiCommutativeRing
      (A : Set) : Set where
      constructor AntiCommutativeRingC
      field
        * : A -> A -> A
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
        antiCommutative :
          (x : A) (y : A) ->
          * x y == neg (* y x)
    record AntiCommutativeRingSig
      (AS : Set) : Set where
      constructor AntiCommutativeRingSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
        1S : AS
    record AntiCommutativeRingProd
      (AP : Set) : Set where
      constructor AntiCommutativeRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
        antiCommutativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == negP (*P yP xP)
    record AntiCommutativeRingHom
      (A1 : Set) (A2 : Set)
      (An1 : AntiCommutativeRing A1)
      (An2 : AntiCommutativeRing A2) :
      Set where
      constructor AntiCommutativeRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* An1 x1 x2) ==
            * An2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ An1 x1 x2) ==
            + An2 (hom x1) (hom x2)
        pres-0 : hom (0 An1) == 0 An2
        pres-neg :
          (x1 : A1) ->
          hom (neg An1 x1) ==
            neg An2 (hom x1)
        pres-1 : hom (1 An1) == 1 An2
    record AntiCommutativeRingRelInterp
      (A1 : Set) (A2 : Set)
      (An1 : AntiCommutativeRing A1)
      (An2 : AntiCommutativeRing A2) :
      Set where
      constructor AntiCommutativeRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* An1 x1 x2)
            (* An2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ An1 x1 x2)
            (+ An2 y1 y2)
        interp-0 :
          interp (0 An1) (0 An2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg An1 x1) (neg An2 y1)
        interp-1 :
          interp (1 An1) (1 An2)
    data AntiCommutativeRingTerm
      : Set where
      *L :
        AntiCommutativeRingTerm ->
        AntiCommutativeRingTerm ->
        AntiCommutativeRingTerm
      +L :
        AntiCommutativeRingTerm ->
        AntiCommutativeRingTerm ->
        AntiCommutativeRingTerm
      0L : AntiCommutativeRingTerm
      negL :
        AntiCommutativeRingTerm ->
        AntiCommutativeRingTerm
      1L : AntiCommutativeRingTerm
    data ClAntiCommutativeRingTerm
      (A : Set) : Set where
      sing :
        A -> ClAntiCommutativeRingTerm A
      *Cl :
        ClAntiCommutativeRingTerm A ->
        ClAntiCommutativeRingTerm A ->
        ClAntiCommutativeRingTerm A
      +Cl :
        ClAntiCommutativeRingTerm A ->
        ClAntiCommutativeRingTerm A ->
        ClAntiCommutativeRingTerm A
      0Cl :
        ClAntiCommutativeRingTerm A
      negCl :
        ClAntiCommutativeRingTerm A ->
        ClAntiCommutativeRingTerm A
      1Cl :
        ClAntiCommutativeRingTerm A
    data OpAntiCommutativeRingTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpAntiCommutativeRingTerm n
      *OL :
        OpAntiCommutativeRingTerm n ->
        OpAntiCommutativeRingTerm n ->
        OpAntiCommutativeRingTerm n
      +OL :
        OpAntiCommutativeRingTerm n ->
        OpAntiCommutativeRingTerm n ->
        OpAntiCommutativeRingTerm n
      0OL :
        OpAntiCommutativeRingTerm n
      negOL :
        OpAntiCommutativeRingTerm n ->
        OpAntiCommutativeRingTerm n
      1OL :
        OpAntiCommutativeRingTerm n
    data OpAntiCommutativeRingTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAntiCommutativeRingTerm2 n A
      sing2 :
        A ->
        OpAntiCommutativeRingTerm2 n A
      *OL2 :
        OpAntiCommutativeRingTerm2 n
          A ->
        OpAntiCommutativeRingTerm2 n
          A ->
        OpAntiCommutativeRingTerm2 n A
      +OL2 :
        OpAntiCommutativeRingTerm2 n
          A ->
        OpAntiCommutativeRingTerm2 n
          A ->
        OpAntiCommutativeRingTerm2 n A
      0OL2 :
        OpAntiCommutativeRingTerm2 n A
      negOL2 :
        OpAntiCommutativeRingTerm2 n
          A ->
        OpAntiCommutativeRingTerm2 n A
      1OL2 :
        OpAntiCommutativeRingTerm2 n A
    simplifyB :
      AntiCommutativeRingTerm ->
      AntiCommutativeRingTerm
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (+L
               (*L x y)
               (*L x z)) = *L x (+L y z)
    simplifyB (+L
               (*L y x)
               (*L z x)) = *L (+L y z) x
    simplifyB (+L x (negL x)) = 0L
    simplifyB (+L (negL x) x) = 0L
    simplifyB (*L (1L) x) = x
    simplifyB (*L x (1L)) = x
    simplifyB (*L (0L) x) = 0L
    simplifyB (*L x (0L)) = 0L
    simplifyB (negL (*L y x)) =
      *L x y
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (0L) = 0L
    simplifyB (negL x1) =
      negL (simplifyB x1)
    simplifyB (1L) = 1L
    simplifyCl :
      (A : Set) ->
      ClAntiCommutativeRingTerm A ->
      ClAntiCommutativeRingTerm A
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (+Cl
                  (*Cl x y)
                  (*Cl x z)) = *Cl x (+Cl y z)
    simplifyCl _ (+Cl
                  (*Cl y x)
                  (*Cl z x)) = *Cl (+Cl y z) x
    simplifyCl _ (+Cl x (negCl x)) =
      0Cl
    simplifyCl _ (+Cl (negCl x) x) =
      0Cl
    simplifyCl _ (*Cl (1Cl) x) = x
    simplifyCl _ (*Cl x (1Cl)) = x
    simplifyCl _ (*Cl (0Cl) x) = 0Cl
    simplifyCl _ (*Cl x (0Cl)) = 0Cl
    simplifyCl _ (negCl (*Cl y x)) =
      *Cl x y
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (negCl x1) =
      negCl (simplifyCl _ x1)
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAntiCommutativeRingTerm n ->
      OpAntiCommutativeRingTerm n
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (+OL
                  (*OL x y)
                  (*OL x z)) = *OL x (+OL y z)
    simplifyOp _ (+OL
                  (*OL y x)
                  (*OL z x)) = *OL (+OL y z) x
    simplifyOp _ (+OL x (negOL x)) =
      0OL
    simplifyOp _ (+OL (negOL x) x) =
      0OL
    simplifyOp _ (*OL (1OL) x) = x
    simplifyOp _ (*OL x (1OL)) = x
    simplifyOp _ (*OL (0OL) x) = 0OL
    simplifyOp _ (*OL x (0OL)) = 0OL
    simplifyOp _ (negOL (*OL y x)) =
      *OL x y
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (negOL x1) =
      negOL (simplifyOp _ x1)
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAntiCommutativeRingTerm2 n
        A ->
      OpAntiCommutativeRingTerm2 n A
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (+OL2
                     (*OL2 x y)
                     (*OL2 x z)) = *OL2 x (+OL2 y z)
    simplifyOpE _ _ (+OL2
                     (*OL2 y x)
                     (*OL2 z x)) = *OL2 (+OL2 y z) x
    simplifyOpE _ _ (+OL2
                     x
                     (negOL2 x)) = 0OL2
    simplifyOpE _ _ (+OL2
                     (negOL2 x)
                     x) = 0OL2
    simplifyOpE _ _ (*OL2
                     (1OL2)
                     x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (1OL2)) = x
    simplifyOpE _ _ (*OL2
                     (0OL2)
                     x) = 0OL2
    simplifyOpE _ _ (*OL2
                     x
                     (0OL2)) = 0OL2
    simplifyOpE _ _ (negOL2
                     (*OL2 y x)) = *OL2 x y
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (negOL2 x1) =
      negOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AntiCommutativeRing A ->
      AntiCommutativeRingTerm -> A
    evalB _ An (*L x1 x2) =
      * An (evalB _ An x1)
        (evalB _ An x2)
    evalB _ An (+L x1 x2) =
      + An (evalB _ An x1)
        (evalB _ An x2)
    evalB _ An (0L) = 0 An
    evalB _ An (negL x1) =
      neg An (evalB _ An x1)
    evalB _ An (1L) = 1 An
    evalCl :
      (A : Set) ->
      AntiCommutativeRing A ->
      ClAntiCommutativeRingTerm A -> A
    evalCl _ An (sing x1) = x1
    evalCl _ An (*Cl x1 x2) =
      * An (evalCl _ An x1)
        (evalCl _ An x2)
    evalCl _ An (+Cl x1 x2) =
      + An (evalCl _ An x1)
        (evalCl _ An x2)
    evalCl _ An (0Cl) = 0 An
    evalCl _ An (negCl x1) =
      neg An (evalCl _ An x1)
    evalCl _ An (1Cl) = 1 An
    evalOp :
      (A : Set) (n : Nat) ->
      AntiCommutativeRing A ->
      Vec A n ->
      OpAntiCommutativeRingTerm n -> A
    evalOp _ n An vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n An vars (*OL x1 x2) =
      * An (evalOp _ n An vars x1)
        (evalOp _ n An vars x2)
    evalOp _ n An vars (+OL x1 x2) =
      + An (evalOp _ n An vars x1)
        (evalOp _ n An vars x2)
    evalOp _ n An vars (0OL) = 0 An
    evalOp _ n An vars (negOL x1) =
      neg An (evalOp _ n An vars x1)
    evalOp _ n An vars (1OL) = 1 An
    evalOpE :
      (A : Set) (n : Nat) ->
      AntiCommutativeRing A ->
      Vec A n ->
      OpAntiCommutativeRingTerm2 n
        A -> A
    evalOpE _ n An vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n An vars (sing2 x1) =
      x1
    evalOpE _ n An vars (*OL2
                         x1
                         x2) =
      * An (evalOpE _ n An vars x1)
        (evalOpE _ n An vars x2)
    evalOpE _ n An vars (+OL2
                         x1
                         x2) =
      + An (evalOpE _ n An vars x1)
        (evalOpE _ n An vars x2)
    evalOpE _ n An vars (0OL2) =
      0 An
    evalOpE _ n An vars (negOL2
                         x1) =
      neg An (evalOpE _ n An vars x1)
    evalOpE _ n An vars (1OL2) =
      1 An
    inductionB :
      (P : AntiCommutativeRingTerm ->
           Set) ->
      ((x1 : AntiCommutativeRingTerm)
       (x2 : AntiCommutativeRingTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : AntiCommutativeRingTerm)
       (x2 : AntiCommutativeRingTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      P 0L ->
      ((x1 : AntiCommutativeRingTerm) ->
       P x1 -> P (negL x1)) ->
      P 1L ->
      (x : AntiCommutativeRingTerm) ->
      P x
    inductionB p p*l p+l p0l pnegl p1l (*L
                                        x1
                                        x2) =
      p*l _ _
        (inductionB p p*l p+l p0l pnegl
           p1l
           x1)
        (inductionB p p*l p+l p0l pnegl
           p1l
           x2)
    inductionB p p*l p+l p0l pnegl p1l (+L
                                        x1
                                        x2) =
      p+l _ _
        (inductionB p p*l p+l p0l pnegl
           p1l
           x1)
        (inductionB p p*l p+l p0l pnegl
           p1l
           x2)
    inductionB p p*l p+l p0l pnegl p1l (0L) =
      p0l
    inductionB p p*l p+l p0l pnegl p1l (negL
                                        x1) =
      pnegl _
        (inductionB p p*l p+l p0l pnegl
           p1l
           x1)
    inductionB p p*l p+l p0l pnegl p1l (1L) =
      p1l
    inductionCl :
      (A : Set)
      (P : ClAntiCommutativeRingTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClAntiCommutativeRingTerm
          A)
       (x2 : ClAntiCommutativeRingTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClAntiCommutativeRingTerm
          A)
       (x2 : ClAntiCommutativeRingTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      P 0Cl ->
      ((x1 : ClAntiCommutativeRingTerm
          A) -> P x1 -> P (negCl x1)) ->
      P 1Cl ->
      (x : ClAntiCommutativeRingTerm
         A) -> P x
    inductionCl _ p psing p*cl p+cl p0cl pnegcl p1cl (sing
                                                      x1) = psing x1
    inductionCl _ p psing p*cl p+cl p0cl pnegcl p1cl (*Cl
                                                      x1
                                                      x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           p0cl
           pnegcl
           p1cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           p0cl
           pnegcl
           p1cl
           x2)
    inductionCl _ p psing p*cl p+cl p0cl pnegcl p1cl (+Cl
                                                      x1
                                                      x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           p0cl
           pnegcl
           p1cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           p0cl
           pnegcl
           p1cl
           x2)
    inductionCl _ p psing p*cl p+cl p0cl pnegcl p1cl (0Cl) =
      p0cl
    inductionCl _ p psing p*cl p+cl p0cl pnegcl p1cl (negCl
                                                      x1) =
      pnegcl _
        (inductionCl _ p psing p*cl p+cl
           p0cl
           pnegcl
           p1cl
           x1)
    inductionCl _ p psing p*cl p+cl p0cl pnegcl p1cl (1Cl) =
      p1cl
    inductionOp :
      (n : Nat)
      (P : OpAntiCommutativeRingTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpAntiCommutativeRingTerm
          n)
       (x2 : OpAntiCommutativeRingTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpAntiCommutativeRingTerm
          n)
       (x2 : OpAntiCommutativeRingTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      P 0OL ->
      ((x1 : OpAntiCommutativeRingTerm
          n) -> P x1 -> P (negOL x1)) ->
      P 1OL ->
      (x : OpAntiCommutativeRingTerm
         n) -> P x
    inductionOp _ p pv p*ol p+ol p0ol pnegol p1ol (v
                                                   x1) = pv x1
    inductionOp _ p pv p*ol p+ol p0ol pnegol p1ol (*OL
                                                   x1
                                                   x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           p0ol
           pnegol
           p1ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           p0ol
           pnegol
           p1ol
           x2)
    inductionOp _ p pv p*ol p+ol p0ol pnegol p1ol (+OL
                                                   x1
                                                   x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           p0ol
           pnegol
           p1ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           p0ol
           pnegol
           p1ol
           x2)
    inductionOp _ p pv p*ol p+ol p0ol pnegol p1ol (0OL) =
      p0ol
    inductionOp _ p pv p*ol p+ol p0ol pnegol p1ol (negOL
                                                   x1) =
      pnegol _
        (inductionOp _ p pv p*ol p+ol
           p0ol
           pnegol
           p1ol
           x1)
    inductionOp _ p pv p*ol p+ol p0ol pnegol p1ol (1OL) =
      p1ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAntiCommutativeRingTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpAntiCommutativeRingTerm2
          n
          A)
       (x2 : OpAntiCommutativeRingTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpAntiCommutativeRingTerm2
          n
          A)
       (x2 : OpAntiCommutativeRingTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      P 0OL2 ->
      ((x1 : OpAntiCommutativeRingTerm2
          n
          A) -> P x1 -> P (negOL2 x1)) ->
      P 1OL2 ->
      (x : OpAntiCommutativeRingTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 (v2
                                                                   x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 (sing2
                                                                   x1) =
      psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 (*OL2
                                                                   x1
                                                                   x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           pnegol2
           p1ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           pnegol2
           p1ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 (+OL2
                                                                   x1
                                                                   x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           pnegol2
           p1ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           pnegol2
           p1ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 (negOL2
                                                                   x1) =
      pnegol2 _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           pnegol2
           p1ol2
           x1)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 (1OL2) =
      p1ol2
    *L' :
      AntiCommutativeRingTerm ->
      AntiCommutativeRingTerm ->
      AntiCommutativeRingTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      AntiCommutativeRingTerm ->
      AntiCommutativeRingTerm ->
      AntiCommutativeRingTerm
    +L' x1 x2 = +L x1 x2
    0L' : AntiCommutativeRingTerm
    0L' = 0L
    negL' :
      AntiCommutativeRingTerm ->
      AntiCommutativeRingTerm
    negL' x1 = negL x1
    1L' : AntiCommutativeRingTerm
    1L' = 1L
    stageB :
      AntiCommutativeRingTerm ->
      Staged AntiCommutativeRingTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (0L) = Now 0L
    stageB (negL x1) =
      stage1 _ _ negL'
        (codeLift1 _ _ negL')
        (stageB x1)
    stageB (1L) = Now 1L
    *Cl' :
      (A : Set) ->
      ClAntiCommutativeRingTerm A ->
      ClAntiCommutativeRingTerm A ->
      ClAntiCommutativeRingTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClAntiCommutativeRingTerm A ->
      ClAntiCommutativeRingTerm A ->
      ClAntiCommutativeRingTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    0Cl' :
      (A : Set) ->
      ClAntiCommutativeRingTerm A
    0Cl' _ = 0Cl
    negCl' :
      (A : Set) ->
      ClAntiCommutativeRingTerm A ->
      ClAntiCommutativeRingTerm A
    negCl' _ x1 = negCl x1
    1Cl' :
      (A : Set) ->
      ClAntiCommutativeRingTerm A
    1Cl' _ = 1Cl
    stageCl :
      (A : Set) ->
      ClAntiCommutativeRingTerm A ->
      Staged
        (ClAntiCommutativeRingTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (negCl x1) =
      stage1 _ _ (negCl' _)
        (codeLift1 _ _ (negCl' _))
        (stageCl _ x1)
    stageCl _ (1Cl) = Now 1Cl
    *OL' :
      (n : Nat) ->
      OpAntiCommutativeRingTerm n ->
      OpAntiCommutativeRingTerm n ->
      OpAntiCommutativeRingTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpAntiCommutativeRingTerm n ->
      OpAntiCommutativeRingTerm n ->
      OpAntiCommutativeRingTerm n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      OpAntiCommutativeRingTerm n
    0OL' _ = 0OL
    negOL' :
      (n : Nat) ->
      OpAntiCommutativeRingTerm n ->
      OpAntiCommutativeRingTerm n
    negOL' _ x1 = negOL x1
    1OL' :
      (n : Nat) ->
      OpAntiCommutativeRingTerm n
    1OL' _ = 1OL
    stageOp :
      (n : Nat) ->
      OpAntiCommutativeRingTerm n ->
      Staged
        (OpAntiCommutativeRingTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (0OL) = Now 0OL
    stageOp _ (negOL x1) =
      stage1 _ _ (negOL' _)
        (codeLift1 _ _ (negOL' _))
        (stageOp _ x1)
    stageOp _ (1OL) = Now 1OL
    *OL2' :
      (n : Nat) (A : Set) ->
      OpAntiCommutativeRingTerm2 n
        A ->
      OpAntiCommutativeRingTerm2 n
        A ->
      OpAntiCommutativeRingTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAntiCommutativeRingTerm2 n
        A ->
      OpAntiCommutativeRingTerm2 n
        A ->
      OpAntiCommutativeRingTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    0OL2' :
      (n : Nat) (A : Set) ->
      OpAntiCommutativeRingTerm2 n A
    0OL2' _ _ = 0OL2
    negOL2' :
      (n : Nat) (A : Set) ->
      OpAntiCommutativeRingTerm2 n
        A ->
      OpAntiCommutativeRingTerm2 n A
    negOL2' _ _ x1 = negOL2 x1
    1OL2' :
      (n : Nat) (A : Set) ->
      OpAntiCommutativeRingTerm2 n A
    1OL2' _ _ = 1OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAntiCommutativeRingTerm2 n
        A ->
      Staged
        (OpAntiCommutativeRingTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (negOL2 x1) =
      stage1 _ _ (negOL2' _ _)
        (codeLift1 _ _ (negOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (1OL2) = Now 1OL2
    record AntiCommutativeRingTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
        0T : Repr A
        negT : Repr A -> Repr A
        1T : Repr A
  
  module AssocPlusRingoid where
    record AssocPlusRingoid
      (A : Set) : Set where
      constructor AssocPlusRingoidC
      field
        + : A -> A -> A
        * : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record AssocPlusRingoidSig
      (AS : Set) : Set where
      constructor AssocPlusRingoidSigSigC
      field
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
    record AssocPlusRingoidProd
      (AP : Set) : Set where
      constructor AssocPlusRingoidProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record AssocPlusRingoidHom
      (A1 : Set) (A2 : Set)
      (As1 : AssocPlusRingoid A1)
      (As2 : AssocPlusRingoid A2) :
      Set where
      constructor AssocPlusRingoidHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ As1 x1 x2) ==
            + As2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* As1 x1 x2) ==
            * As2 (hom x1) (hom x2)
    record AssocPlusRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (As1 : AssocPlusRingoid A1)
      (As2 : AssocPlusRingoid A2) :
      Set where
      constructor AssocPlusRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ As1 x1 x2)
            (+ As2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* As1 x1 x2)
            (* As2 y1 y2)
    data AssocPlusRingoidTerm
      : Set where
      +L :
        AssocPlusRingoidTerm ->
        AssocPlusRingoidTerm ->
        AssocPlusRingoidTerm
      *L :
        AssocPlusRingoidTerm ->
        AssocPlusRingoidTerm ->
        AssocPlusRingoidTerm
    data ClAssocPlusRingoidTerm
      (A : Set) : Set where
      sing :
        A -> ClAssocPlusRingoidTerm A
      +Cl :
        ClAssocPlusRingoidTerm A ->
        ClAssocPlusRingoidTerm A ->
        ClAssocPlusRingoidTerm A
      *Cl :
        ClAssocPlusRingoidTerm A ->
        ClAssocPlusRingoidTerm A ->
        ClAssocPlusRingoidTerm A
    data OpAssocPlusRingoidTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpAssocPlusRingoidTerm n
      +OL :
        OpAssocPlusRingoidTerm n ->
        OpAssocPlusRingoidTerm n ->
        OpAssocPlusRingoidTerm n
      *OL :
        OpAssocPlusRingoidTerm n ->
        OpAssocPlusRingoidTerm n ->
        OpAssocPlusRingoidTerm n
    data OpAssocPlusRingoidTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAssocPlusRingoidTerm2 n A
      sing2 :
        A -> OpAssocPlusRingoidTerm2 n A
      +OL2 :
        OpAssocPlusRingoidTerm2 n A ->
        OpAssocPlusRingoidTerm2 n A ->
        OpAssocPlusRingoidTerm2 n A
      *OL2 :
        OpAssocPlusRingoidTerm2 n A ->
        OpAssocPlusRingoidTerm2 n A ->
        OpAssocPlusRingoidTerm2 n A
    simplifyB :
      AssocPlusRingoidTerm ->
      AssocPlusRingoidTerm
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClAssocPlusRingoidTerm A ->
      ClAssocPlusRingoidTerm A
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAssocPlusRingoidTerm n ->
      OpAssocPlusRingoidTerm n
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAssocPlusRingoidTerm2 n A ->
      OpAssocPlusRingoidTerm2 n A
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AssocPlusRingoid A ->
      AssocPlusRingoidTerm -> A
    evalB _ As (+L x1 x2) =
      + As (evalB _ As x1)
        (evalB _ As x2)
    evalB _ As (*L x1 x2) =
      * As (evalB _ As x1)
        (evalB _ As x2)
    evalCl :
      (A : Set) ->
      AssocPlusRingoid A ->
      ClAssocPlusRingoidTerm A -> A
    evalCl _ As (sing x1) = x1
    evalCl _ As (+Cl x1 x2) =
      + As (evalCl _ As x1)
        (evalCl _ As x2)
    evalCl _ As (*Cl x1 x2) =
      * As (evalCl _ As x1)
        (evalCl _ As x2)
    evalOp :
      (A : Set) (n : Nat) ->
      AssocPlusRingoid A ->
      Vec A n ->
      OpAssocPlusRingoidTerm n -> A
    evalOp _ n As vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n As vars (+OL x1 x2) =
      + As (evalOp _ n As vars x1)
        (evalOp _ n As vars x2)
    evalOp _ n As vars (*OL x1 x2) =
      * As (evalOp _ n As vars x1)
        (evalOp _ n As vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      AssocPlusRingoid A ->
      Vec A n ->
      OpAssocPlusRingoidTerm2 n A -> A
    evalOpE _ n As vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n As vars (sing2 x1) =
      x1
    evalOpE _ n As vars (+OL2
                         x1
                         x2) =
      + As (evalOpE _ n As vars x1)
        (evalOpE _ n As vars x2)
    evalOpE _ n As vars (*OL2
                         x1
                         x2) =
      * As (evalOpE _ n As vars x1)
        (evalOpE _ n As vars x2)
    inductionB :
      (P : AssocPlusRingoidTerm ->
           Set) ->
      ((x1 : AssocPlusRingoidTerm)
       (x2 : AssocPlusRingoidTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      ((x1 : AssocPlusRingoidTerm)
       (x2 : AssocPlusRingoidTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      (x : AssocPlusRingoidTerm) ->
      P x
    inductionB p p+l p*l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p+l p*l x1)
        (inductionB p p+l p*l x2)
    inductionB p p+l p*l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p+l p*l x1)
        (inductionB p p+l p*l x2)
    inductionCl :
      (A : Set)
      (P : ClAssocPlusRingoidTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClAssocPlusRingoidTerm A)
       (x2 : ClAssocPlusRingoidTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      ((x1 : ClAssocPlusRingoidTerm A)
       (x2 : ClAssocPlusRingoidTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      (x : ClAssocPlusRingoidTerm
         A) -> P x
    inductionCl _ p psing p+cl p*cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p+cl p*cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p+cl p*cl
           x1)
        (inductionCl _ p psing p+cl p*cl
           x2)
    inductionCl _ p psing p+cl p*cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p+cl p*cl
           x1)
        (inductionCl _ p psing p+cl p*cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpAssocPlusRingoidTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpAssocPlusRingoidTerm n)
       (x2 : OpAssocPlusRingoidTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      ((x1 : OpAssocPlusRingoidTerm n)
       (x2 : OpAssocPlusRingoidTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      (x : OpAssocPlusRingoidTerm
         n) -> P x
    inductionOp _ p pv p+ol p*ol (v
                                  x1) = pv x1
    inductionOp _ p pv p+ol p*ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p+ol p*ol
           x1)
        (inductionOp _ p pv p+ol p*ol
           x2)
    inductionOp _ p pv p+ol p*ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p+ol p*ol
           x1)
        (inductionOp _ p pv p+ol p*ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAssocPlusRingoidTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpAssocPlusRingoidTerm2 n
          A)
       (x2 : OpAssocPlusRingoidTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      ((x1 : OpAssocPlusRingoidTerm2 n
          A)
       (x2 : OpAssocPlusRingoidTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      (x : OpAssocPlusRingoidTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p+ol2 p*ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 p*ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 p*ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p*ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p+ol2 p*ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p*ol2
           x2)
    +L' :
      AssocPlusRingoidTerm ->
      AssocPlusRingoidTerm ->
      AssocPlusRingoidTerm
    +L' x1 x2 = +L x1 x2
    *L' :
      AssocPlusRingoidTerm ->
      AssocPlusRingoidTerm ->
      AssocPlusRingoidTerm
    *L' x1 x2 = *L x1 x2
    stageB :
      AssocPlusRingoidTerm ->
      Staged AssocPlusRingoidTerm
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    +Cl' :
      (A : Set) ->
      ClAssocPlusRingoidTerm A ->
      ClAssocPlusRingoidTerm A ->
      ClAssocPlusRingoidTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    *Cl' :
      (A : Set) ->
      ClAssocPlusRingoidTerm A ->
      ClAssocPlusRingoidTerm A ->
      ClAssocPlusRingoidTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    stageCl :
      (A : Set) ->
      ClAssocPlusRingoidTerm A ->
      Staged
        (ClAssocPlusRingoidTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    +OL' :
      (n : Nat) ->
      OpAssocPlusRingoidTerm n ->
      OpAssocPlusRingoidTerm n ->
      OpAssocPlusRingoidTerm n
    +OL' _ x1 x2 = +OL x1 x2
    *OL' :
      (n : Nat) ->
      OpAssocPlusRingoidTerm n ->
      OpAssocPlusRingoidTerm n ->
      OpAssocPlusRingoidTerm n
    *OL' _ x1 x2 = *OL x1 x2
    stageOp :
      (n : Nat) ->
      OpAssocPlusRingoidTerm n ->
      Staged
        (OpAssocPlusRingoidTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAssocPlusRingoidTerm2 n A ->
      OpAssocPlusRingoidTerm2 n A ->
      OpAssocPlusRingoidTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    *OL2' :
      (n : Nat) (A : Set) ->
      OpAssocPlusRingoidTerm2 n A ->
      OpAssocPlusRingoidTerm2 n A ->
      OpAssocPlusRingoidTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAssocPlusRingoidTerm2 n A ->
      Staged
        (OpAssocPlusRingoidTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record AssocPlusRingoidTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        +T : Repr A -> Repr A -> Repr A
        *T : Repr A -> Repr A -> Repr A
  
  module AssocTimesRingoid where
    record AssocTimesRingoid
      (A : Set) : Set where
      constructor AssocTimesRingoidC
      field
        * : A -> A -> A
        + : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
    record AssocTimesRingoidSig
      (AS : Set) : Set where
      constructor AssocTimesRingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record AssocTimesRingoidProd
      (AP : Set) : Set where
      constructor AssocTimesRingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
    record AssocTimesRingoidHom
      (A1 : Set) (A2 : Set)
      (As1 : AssocTimesRingoid A1)
      (As2 : AssocTimesRingoid A2) :
      Set where
      constructor AssocTimesRingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* As1 x1 x2) ==
            * As2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ As1 x1 x2) ==
            + As2 (hom x1) (hom x2)
    record AssocTimesRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (As1 : AssocTimesRingoid A1)
      (As2 : AssocTimesRingoid A2) :
      Set where
      constructor AssocTimesRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* As1 x1 x2)
            (* As2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ As1 x1 x2)
            (+ As2 y1 y2)
    data AssocTimesRingoidTerm
      : Set where
      *L :
        AssocTimesRingoidTerm ->
        AssocTimesRingoidTerm ->
        AssocTimesRingoidTerm
      +L :
        AssocTimesRingoidTerm ->
        AssocTimesRingoidTerm ->
        AssocTimesRingoidTerm
    data ClAssocTimesRingoidTerm
      (A : Set) : Set where
      sing :
        A -> ClAssocTimesRingoidTerm A
      *Cl :
        ClAssocTimesRingoidTerm A ->
        ClAssocTimesRingoidTerm A ->
        ClAssocTimesRingoidTerm A
      +Cl :
        ClAssocTimesRingoidTerm A ->
        ClAssocTimesRingoidTerm A ->
        ClAssocTimesRingoidTerm A
    data OpAssocTimesRingoidTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpAssocTimesRingoidTerm n
      *OL :
        OpAssocTimesRingoidTerm n ->
        OpAssocTimesRingoidTerm n ->
        OpAssocTimesRingoidTerm n
      +OL :
        OpAssocTimesRingoidTerm n ->
        OpAssocTimesRingoidTerm n ->
        OpAssocTimesRingoidTerm n
    data OpAssocTimesRingoidTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAssocTimesRingoidTerm2 n A
      sing2 :
        A ->
        OpAssocTimesRingoidTerm2 n A
      *OL2 :
        OpAssocTimesRingoidTerm2 n A ->
        OpAssocTimesRingoidTerm2 n A ->
        OpAssocTimesRingoidTerm2 n A
      +OL2 :
        OpAssocTimesRingoidTerm2 n A ->
        OpAssocTimesRingoidTerm2 n A ->
        OpAssocTimesRingoidTerm2 n A
    simplifyB :
      AssocTimesRingoidTerm ->
      AssocTimesRingoidTerm
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClAssocTimesRingoidTerm A ->
      ClAssocTimesRingoidTerm A
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAssocTimesRingoidTerm n ->
      OpAssocTimesRingoidTerm n
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAssocTimesRingoidTerm2 n A ->
      OpAssocTimesRingoidTerm2 n A
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AssocTimesRingoid A ->
      AssocTimesRingoidTerm -> A
    evalB _ As (*L x1 x2) =
      * As (evalB _ As x1)
        (evalB _ As x2)
    evalB _ As (+L x1 x2) =
      + As (evalB _ As x1)
        (evalB _ As x2)
    evalCl :
      (A : Set) ->
      AssocTimesRingoid A ->
      ClAssocTimesRingoidTerm A -> A
    evalCl _ As (sing x1) = x1
    evalCl _ As (*Cl x1 x2) =
      * As (evalCl _ As x1)
        (evalCl _ As x2)
    evalCl _ As (+Cl x1 x2) =
      + As (evalCl _ As x1)
        (evalCl _ As x2)
    evalOp :
      (A : Set) (n : Nat) ->
      AssocTimesRingoid A ->
      Vec A n ->
      OpAssocTimesRingoidTerm n -> A
    evalOp _ n As vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n As vars (*OL x1 x2) =
      * As (evalOp _ n As vars x1)
        (evalOp _ n As vars x2)
    evalOp _ n As vars (+OL x1 x2) =
      + As (evalOp _ n As vars x1)
        (evalOp _ n As vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      AssocTimesRingoid A ->
      Vec A n ->
      OpAssocTimesRingoidTerm2 n A ->
      A
    evalOpE _ n As vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n As vars (sing2 x1) =
      x1
    evalOpE _ n As vars (*OL2
                         x1
                         x2) =
      * As (evalOpE _ n As vars x1)
        (evalOpE _ n As vars x2)
    evalOpE _ n As vars (+OL2
                         x1
                         x2) =
      + As (evalOpE _ n As vars x1)
        (evalOpE _ n As vars x2)
    inductionB :
      (P : AssocTimesRingoidTerm ->
           Set) ->
      ((x1 : AssocTimesRingoidTerm)
       (x2 : AssocTimesRingoidTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : AssocTimesRingoidTerm)
       (x2 : AssocTimesRingoidTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : AssocTimesRingoidTerm) ->
      P x
    inductionB p p*l p+l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionB p p*l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClAssocTimesRingoidTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClAssocTimesRingoidTerm
          A)
       (x2 : ClAssocTimesRingoidTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClAssocTimesRingoidTerm
          A)
       (x2 : ClAssocTimesRingoidTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClAssocTimesRingoidTerm
         A) -> P x
    inductionCl _ p psing p*cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p*cl p+cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionCl _ p psing p*cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpAssocTimesRingoidTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpAssocTimesRingoidTerm
          n)
       (x2 : OpAssocTimesRingoidTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpAssocTimesRingoidTerm
          n)
       (x2 : OpAssocTimesRingoidTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpAssocTimesRingoidTerm
         n) -> P x
    inductionOp _ p pv p*ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p*ol p+ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOp _ p pv p*ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAssocTimesRingoidTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpAssocTimesRingoidTerm2
          n
          A)
       (x2 : OpAssocTimesRingoidTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpAssocTimesRingoidTerm2
          n
          A)
       (x2 : OpAssocTimesRingoidTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpAssocTimesRingoidTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    *L' :
      AssocTimesRingoidTerm ->
      AssocTimesRingoidTerm ->
      AssocTimesRingoidTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      AssocTimesRingoidTerm ->
      AssocTimesRingoidTerm ->
      AssocTimesRingoidTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      AssocTimesRingoidTerm ->
      Staged AssocTimesRingoidTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClAssocTimesRingoidTerm A ->
      ClAssocTimesRingoidTerm A ->
      ClAssocTimesRingoidTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClAssocTimesRingoidTerm A ->
      ClAssocTimesRingoidTerm A ->
      ClAssocTimesRingoidTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClAssocTimesRingoidTerm A ->
      Staged
        (ClAssocTimesRingoidTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpAssocTimesRingoidTerm n ->
      OpAssocTimesRingoidTerm n ->
      OpAssocTimesRingoidTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpAssocTimesRingoidTerm n ->
      OpAssocTimesRingoidTerm n ->
      OpAssocTimesRingoidTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpAssocTimesRingoidTerm n ->
      Staged
        (OpAssocTimesRingoidTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpAssocTimesRingoidTerm2 n A ->
      OpAssocTimesRingoidTerm2 n A ->
      OpAssocTimesRingoidTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAssocTimesRingoidTerm2 n A ->
      OpAssocTimesRingoidTerm2 n A ->
      OpAssocTimesRingoidTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAssocTimesRingoidTerm2 n A ->
      Staged
        (OpAssocTimesRingoidTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record AssocTimesRingoidTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module AssociativeLeftRingoid where
    record AssociativeLeftRingoid
      (A : Set) : Set where
      constructor AssociativeLeftRingoidC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
    record AssociativeLeftRingoidSig
      (AS : Set) : Set where
      constructor AssociativeLeftRingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record AssociativeLeftRingoidProd
      (AP : Set) : Set where
      constructor AssociativeLeftRingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
    record AssociativeLeftRingoidHom
      (A1 : Set) (A2 : Set)
      (As1 : AssociativeLeftRingoid
         A1)
      (As2 : AssociativeLeftRingoid
         A2) : Set where
      constructor AssociativeLeftRingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* As1 x1 x2) ==
            * As2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ As1 x1 x2) ==
            + As2 (hom x1) (hom x2)
    record AssociativeLeftRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (As1 : AssociativeLeftRingoid
         A1)
      (As2 : AssociativeLeftRingoid
         A2) : Set where
      constructor AssociativeLeftRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* As1 x1 x2)
            (* As2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ As1 x1 x2)
            (+ As2 y1 y2)
    data AssociativeLeftRingoidTerm
      : Set where
      *L :
        AssociativeLeftRingoidTerm ->
        AssociativeLeftRingoidTerm ->
        AssociativeLeftRingoidTerm
      +L :
        AssociativeLeftRingoidTerm ->
        AssociativeLeftRingoidTerm ->
        AssociativeLeftRingoidTerm
    data ClAssociativeLeftRingoidTerm
      (A : Set) : Set where
      sing :
        A ->
        ClAssociativeLeftRingoidTerm A
      *Cl :
        ClAssociativeLeftRingoidTerm
          A ->
        ClAssociativeLeftRingoidTerm
          A ->
        ClAssociativeLeftRingoidTerm A
      +Cl :
        ClAssociativeLeftRingoidTerm
          A ->
        ClAssociativeLeftRingoidTerm
          A ->
        ClAssociativeLeftRingoidTerm A
    data OpAssociativeLeftRingoidTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpAssociativeLeftRingoidTerm n
      *OL :
        OpAssociativeLeftRingoidTerm
          n ->
        OpAssociativeLeftRingoidTerm
          n ->
        OpAssociativeLeftRingoidTerm n
      +OL :
        OpAssociativeLeftRingoidTerm
          n ->
        OpAssociativeLeftRingoidTerm
          n ->
        OpAssociativeLeftRingoidTerm n
    data OpAssociativeLeftRingoidTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAssociativeLeftRingoidTerm2 n
          A
      sing2 :
        A ->
        OpAssociativeLeftRingoidTerm2 n
          A
      *OL2 :
        OpAssociativeLeftRingoidTerm2 n
          A ->
        OpAssociativeLeftRingoidTerm2 n
          A ->
        OpAssociativeLeftRingoidTerm2 n
          A
      +OL2 :
        OpAssociativeLeftRingoidTerm2 n
          A ->
        OpAssociativeLeftRingoidTerm2 n
          A ->
        OpAssociativeLeftRingoidTerm2 n
          A
    simplifyB :
      AssociativeLeftRingoidTerm ->
      AssociativeLeftRingoidTerm
    simplifyB (+L
               (*L x y)
               (*L x z)) = *L x (+L y z)
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClAssociativeLeftRingoidTerm
        A ->
      ClAssociativeLeftRingoidTerm A
    simplifyCl _ (+Cl
                  (*Cl x y)
                  (*Cl x z)) = *Cl x (+Cl y z)
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAssociativeLeftRingoidTerm
        n ->
      OpAssociativeLeftRingoidTerm n
    simplifyOp _ (+OL
                  (*OL x y)
                  (*OL x z)) = *OL x (+OL y z)
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAssociativeLeftRingoidTerm2 n
        A ->
      OpAssociativeLeftRingoidTerm2 n
        A
    simplifyOpE _ _ (+OL2
                     (*OL2 x y)
                     (*OL2 x z)) = *OL2 x (+OL2 y z)
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AssociativeLeftRingoid A ->
      AssociativeLeftRingoidTerm -> A
    evalB _ As (*L x1 x2) =
      * As (evalB _ As x1)
        (evalB _ As x2)
    evalB _ As (+L x1 x2) =
      + As (evalB _ As x1)
        (evalB _ As x2)
    evalCl :
      (A : Set) ->
      AssociativeLeftRingoid A ->
      ClAssociativeLeftRingoidTerm
        A -> A
    evalCl _ As (sing x1) = x1
    evalCl _ As (*Cl x1 x2) =
      * As (evalCl _ As x1)
        (evalCl _ As x2)
    evalCl _ As (+Cl x1 x2) =
      + As (evalCl _ As x1)
        (evalCl _ As x2)
    evalOp :
      (A : Set) (n : Nat) ->
      AssociativeLeftRingoid A ->
      Vec A n ->
      OpAssociativeLeftRingoidTerm
        n -> A
    evalOp _ n As vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n As vars (*OL x1 x2) =
      * As (evalOp _ n As vars x1)
        (evalOp _ n As vars x2)
    evalOp _ n As vars (+OL x1 x2) =
      + As (evalOp _ n As vars x1)
        (evalOp _ n As vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      AssociativeLeftRingoid A ->
      Vec A n ->
      OpAssociativeLeftRingoidTerm2 n
        A -> A
    evalOpE _ n As vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n As vars (sing2 x1) =
      x1
    evalOpE _ n As vars (*OL2
                         x1
                         x2) =
      * As (evalOpE _ n As vars x1)
        (evalOpE _ n As vars x2)
    evalOpE _ n As vars (+OL2
                         x1
                         x2) =
      + As (evalOpE _ n As vars x1)
        (evalOpE _ n As vars x2)
    inductionB :
      (P : AssociativeLeftRingoidTerm ->
           Set) ->
      ((x1 : AssociativeLeftRingoidTerm)
       (x2 : AssociativeLeftRingoidTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : AssociativeLeftRingoidTerm)
       (x2 : AssociativeLeftRingoidTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : AssociativeLeftRingoidTerm) ->
      P x
    inductionB p p*l p+l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionB p p*l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClAssociativeLeftRingoidTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClAssociativeLeftRingoidTerm
          A)
       (x2 : ClAssociativeLeftRingoidTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClAssociativeLeftRingoidTerm
          A)
       (x2 : ClAssociativeLeftRingoidTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClAssociativeLeftRingoidTerm
         A) -> P x
    inductionCl _ p psing p*cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p*cl p+cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionCl _ p psing p*cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpAssociativeLeftRingoidTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpAssociativeLeftRingoidTerm
          n)
       (x2 : OpAssociativeLeftRingoidTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpAssociativeLeftRingoidTerm
          n)
       (x2 : OpAssociativeLeftRingoidTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpAssociativeLeftRingoidTerm
         n) -> P x
    inductionOp _ p pv p*ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p*ol p+ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOp _ p pv p*ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAssociativeLeftRingoidTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpAssociativeLeftRingoidTerm2
          n
          A)
       (x2 : OpAssociativeLeftRingoidTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpAssociativeLeftRingoidTerm2
          n
          A)
       (x2 : OpAssociativeLeftRingoidTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpAssociativeLeftRingoidTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    *L' :
      AssociativeLeftRingoidTerm ->
      AssociativeLeftRingoidTerm ->
      AssociativeLeftRingoidTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      AssociativeLeftRingoidTerm ->
      AssociativeLeftRingoidTerm ->
      AssociativeLeftRingoidTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      AssociativeLeftRingoidTerm ->
      Staged
        AssociativeLeftRingoidTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClAssociativeLeftRingoidTerm
        A ->
      ClAssociativeLeftRingoidTerm
        A ->
      ClAssociativeLeftRingoidTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClAssociativeLeftRingoidTerm
        A ->
      ClAssociativeLeftRingoidTerm
        A ->
      ClAssociativeLeftRingoidTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClAssociativeLeftRingoidTerm
        A ->
      Staged
        (ClAssociativeLeftRingoidTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpAssociativeLeftRingoidTerm
        n ->
      OpAssociativeLeftRingoidTerm
        n ->
      OpAssociativeLeftRingoidTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpAssociativeLeftRingoidTerm
        n ->
      OpAssociativeLeftRingoidTerm
        n ->
      OpAssociativeLeftRingoidTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpAssociativeLeftRingoidTerm
        n ->
      Staged
        (OpAssociativeLeftRingoidTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpAssociativeLeftRingoidTerm2 n
        A ->
      OpAssociativeLeftRingoidTerm2 n
        A ->
      OpAssociativeLeftRingoidTerm2 n
        A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAssociativeLeftRingoidTerm2 n
        A ->
      OpAssociativeLeftRingoidTerm2 n
        A ->
      OpAssociativeLeftRingoidTerm2 n
        A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAssociativeLeftRingoidTerm2 n
        A ->
      Staged
        (OpAssociativeLeftRingoidTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record AssociativeLeftRingoidTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module AssociativeNonDistributiveRingoid where
    record AssociativeNonDistributiveRingoid
      (A : Set) : Set where
      constructor AssociativeNonDistributiveRingoidC
      field
        * : A -> A -> A
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
    record AssociativeNonDistributiveRingoidSig
      (AS : Set) : Set where
      constructor AssociativeNonDistributiveRingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record AssociativeNonDistributiveRingoidProd
      (AP : Set) : Set where
      constructor AssociativeNonDistributiveRingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
    record AssociativeNonDistributiveRingoidHom
      (A1 : Set) (A2 : Set)
      (As1 : AssociativeNonDistributiveRingoid
         A1)
      (As2 : AssociativeNonDistributiveRingoid
         A2) : Set where
      constructor AssociativeNonDistributiveRingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* As1 x1 x2) ==
            * As2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ As1 x1 x2) ==
            + As2 (hom x1) (hom x2)
    record AssociativeNonDistributiveRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (As1 : AssociativeNonDistributiveRingoid
         A1)
      (As2 : AssociativeNonDistributiveRingoid
         A2) : Set where
      constructor AssociativeNonDistributiveRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* As1 x1 x2)
            (* As2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ As1 x1 x2)
            (+ As2 y1 y2)
    data AssociativeNonDistributiveRingoidTerm
      : Set where
      *L :
        AssociativeNonDistributiveRingoidTerm ->
        AssociativeNonDistributiveRingoidTerm ->
        AssociativeNonDistributiveRingoidTerm
      +L :
        AssociativeNonDistributiveRingoidTerm ->
        AssociativeNonDistributiveRingoidTerm ->
        AssociativeNonDistributiveRingoidTerm
    data ClAssociativeNonDistributiveRingoidTerm
      (A : Set) : Set where
      sing :
        A ->
        ClAssociativeNonDistributiveRingoidTerm
          A
      *Cl :
        ClAssociativeNonDistributiveRingoidTerm
          A ->
        ClAssociativeNonDistributiveRingoidTerm
          A ->
        ClAssociativeNonDistributiveRingoidTerm
          A
      +Cl :
        ClAssociativeNonDistributiveRingoidTerm
          A ->
        ClAssociativeNonDistributiveRingoidTerm
          A ->
        ClAssociativeNonDistributiveRingoidTerm
          A
    data OpAssociativeNonDistributiveRingoidTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpAssociativeNonDistributiveRingoidTerm
          n
      *OL :
        OpAssociativeNonDistributiveRingoidTerm
          n ->
        OpAssociativeNonDistributiveRingoidTerm
          n ->
        OpAssociativeNonDistributiveRingoidTerm
          n
      +OL :
        OpAssociativeNonDistributiveRingoidTerm
          n ->
        OpAssociativeNonDistributiveRingoidTerm
          n ->
        OpAssociativeNonDistributiveRingoidTerm
          n
    data OpAssociativeNonDistributiveRingoidTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAssociativeNonDistributiveRingoidTerm2
          n
          A
      sing2 :
        A ->
        OpAssociativeNonDistributiveRingoidTerm2
          n
          A
      *OL2 :
        OpAssociativeNonDistributiveRingoidTerm2
          n
          A ->
        OpAssociativeNonDistributiveRingoidTerm2
          n
          A ->
        OpAssociativeNonDistributiveRingoidTerm2
          n
          A
      +OL2 :
        OpAssociativeNonDistributiveRingoidTerm2
          n
          A ->
        OpAssociativeNonDistributiveRingoidTerm2
          n
          A ->
        OpAssociativeNonDistributiveRingoidTerm2
          n
          A
    simplifyB :
      AssociativeNonDistributiveRingoidTerm ->
      AssociativeNonDistributiveRingoidTerm
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClAssociativeNonDistributiveRingoidTerm
        A ->
      ClAssociativeNonDistributiveRingoidTerm
        A
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAssociativeNonDistributiveRingoidTerm
        n ->
      OpAssociativeNonDistributiveRingoidTerm
        n
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAssociativeNonDistributiveRingoidTerm2
        n
        A ->
      OpAssociativeNonDistributiveRingoidTerm2
        n
        A
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AssociativeNonDistributiveRingoid
        A ->
      AssociativeNonDistributiveRingoidTerm ->
      A
    evalB _ As (*L x1 x2) =
      * As (evalB _ As x1)
        (evalB _ As x2)
    evalB _ As (+L x1 x2) =
      + As (evalB _ As x1)
        (evalB _ As x2)
    evalCl :
      (A : Set) ->
      AssociativeNonDistributiveRingoid
        A ->
      ClAssociativeNonDistributiveRingoidTerm
        A -> A
    evalCl _ As (sing x1) = x1
    evalCl _ As (*Cl x1 x2) =
      * As (evalCl _ As x1)
        (evalCl _ As x2)
    evalCl _ As (+Cl x1 x2) =
      + As (evalCl _ As x1)
        (evalCl _ As x2)
    evalOp :
      (A : Set) (n : Nat) ->
      AssociativeNonDistributiveRingoid
        A ->
      Vec A n ->
      OpAssociativeNonDistributiveRingoidTerm
        n -> A
    evalOp _ n As vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n As vars (*OL x1 x2) =
      * As (evalOp _ n As vars x1)
        (evalOp _ n As vars x2)
    evalOp _ n As vars (+OL x1 x2) =
      + As (evalOp _ n As vars x1)
        (evalOp _ n As vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      AssociativeNonDistributiveRingoid
        A ->
      Vec A n ->
      OpAssociativeNonDistributiveRingoidTerm2
        n
        A -> A
    evalOpE _ n As vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n As vars (sing2 x1) =
      x1
    evalOpE _ n As vars (*OL2
                         x1
                         x2) =
      * As (evalOpE _ n As vars x1)
        (evalOpE _ n As vars x2)
    evalOpE _ n As vars (+OL2
                         x1
                         x2) =
      + As (evalOpE _ n As vars x1)
        (evalOpE _ n As vars x2)
    inductionB :
      (P : AssociativeNonDistributiveRingoidTerm ->
           Set) ->
      ((x1 : AssociativeNonDistributiveRingoidTerm)
       (x2 : AssociativeNonDistributiveRingoidTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : AssociativeNonDistributiveRingoidTerm)
       (x2 : AssociativeNonDistributiveRingoidTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : AssociativeNonDistributiveRingoidTerm) ->
      P x
    inductionB p p*l p+l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionB p p*l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClAssociativeNonDistributiveRingoidTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClAssociativeNonDistributiveRingoidTerm
          A)
       (x2 : ClAssociativeNonDistributiveRingoidTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClAssociativeNonDistributiveRingoidTerm
          A)
       (x2 : ClAssociativeNonDistributiveRingoidTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClAssociativeNonDistributiveRingoidTerm
         A) -> P x
    inductionCl _ p psing p*cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p*cl p+cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionCl _ p psing p*cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpAssociativeNonDistributiveRingoidTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpAssociativeNonDistributiveRingoidTerm
          n)
       (x2 : OpAssociativeNonDistributiveRingoidTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpAssociativeNonDistributiveRingoidTerm
          n)
       (x2 : OpAssociativeNonDistributiveRingoidTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpAssociativeNonDistributiveRingoidTerm
         n) -> P x
    inductionOp _ p pv p*ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p*ol p+ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOp _ p pv p*ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAssociativeNonDistributiveRingoidTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpAssociativeNonDistributiveRingoidTerm2
          n
          A)
       (x2 : OpAssociativeNonDistributiveRingoidTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpAssociativeNonDistributiveRingoidTerm2
          n
          A)
       (x2 : OpAssociativeNonDistributiveRingoidTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpAssociativeNonDistributiveRingoidTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    *L' :
      AssociativeNonDistributiveRingoidTerm ->
      AssociativeNonDistributiveRingoidTerm ->
      AssociativeNonDistributiveRingoidTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      AssociativeNonDistributiveRingoidTerm ->
      AssociativeNonDistributiveRingoidTerm ->
      AssociativeNonDistributiveRingoidTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      AssociativeNonDistributiveRingoidTerm ->
      Staged
        AssociativeNonDistributiveRingoidTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClAssociativeNonDistributiveRingoidTerm
        A ->
      ClAssociativeNonDistributiveRingoidTerm
        A ->
      ClAssociativeNonDistributiveRingoidTerm
        A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClAssociativeNonDistributiveRingoidTerm
        A ->
      ClAssociativeNonDistributiveRingoidTerm
        A ->
      ClAssociativeNonDistributiveRingoidTerm
        A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClAssociativeNonDistributiveRingoidTerm
        A ->
      Staged
        (ClAssociativeNonDistributiveRingoidTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpAssociativeNonDistributiveRingoidTerm
        n ->
      OpAssociativeNonDistributiveRingoidTerm
        n ->
      OpAssociativeNonDistributiveRingoidTerm
        n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpAssociativeNonDistributiveRingoidTerm
        n ->
      OpAssociativeNonDistributiveRingoidTerm
        n ->
      OpAssociativeNonDistributiveRingoidTerm
        n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpAssociativeNonDistributiveRingoidTerm
        n ->
      Staged
        (OpAssociativeNonDistributiveRingoidTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpAssociativeNonDistributiveRingoidTerm2
        n
        A ->
      OpAssociativeNonDistributiveRingoidTerm2
        n
        A ->
      OpAssociativeNonDistributiveRingoidTerm2
        n
        A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAssociativeNonDistributiveRingoidTerm2
        n
        A ->
      OpAssociativeNonDistributiveRingoidTerm2
        n
        A ->
      OpAssociativeNonDistributiveRingoidTerm2
        n
        A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAssociativeNonDistributiveRingoidTerm2
        n
        A ->
      Staged
        (OpAssociativeNonDistributiveRingoidTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record AssociativeNonDistributiveRingoidTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module AssociativeRightRingoid where
    record AssociativeRightRingoid
      (A : Set) : Set where
      constructor AssociativeRightRingoidC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        + : A -> A -> A
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record AssociativeRightRingoidSig
      (AS : Set) : Set where
      constructor AssociativeRightRingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record AssociativeRightRingoidProd
      (AP : Set) : Set where
      constructor AssociativeRightRingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record AssociativeRightRingoidHom
      (A1 : Set) (A2 : Set)
      (As1 : AssociativeRightRingoid
         A1)
      (As2 : AssociativeRightRingoid
         A2) : Set where
      constructor AssociativeRightRingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* As1 x1 x2) ==
            * As2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ As1 x1 x2) ==
            + As2 (hom x1) (hom x2)
    record AssociativeRightRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (As1 : AssociativeRightRingoid
         A1)
      (As2 : AssociativeRightRingoid
         A2) : Set where
      constructor AssociativeRightRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* As1 x1 x2)
            (* As2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ As1 x1 x2)
            (+ As2 y1 y2)
    data AssociativeRightRingoidTerm
      : Set where
      *L :
        AssociativeRightRingoidTerm ->
        AssociativeRightRingoidTerm ->
        AssociativeRightRingoidTerm
      +L :
        AssociativeRightRingoidTerm ->
        AssociativeRightRingoidTerm ->
        AssociativeRightRingoidTerm
    data ClAssociativeRightRingoidTerm
      (A : Set) : Set where
      sing :
        A ->
        ClAssociativeRightRingoidTerm A
      *Cl :
        ClAssociativeRightRingoidTerm
          A ->
        ClAssociativeRightRingoidTerm
          A ->
        ClAssociativeRightRingoidTerm A
      +Cl :
        ClAssociativeRightRingoidTerm
          A ->
        ClAssociativeRightRingoidTerm
          A ->
        ClAssociativeRightRingoidTerm A
    data OpAssociativeRightRingoidTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpAssociativeRightRingoidTerm n
      *OL :
        OpAssociativeRightRingoidTerm
          n ->
        OpAssociativeRightRingoidTerm
          n ->
        OpAssociativeRightRingoidTerm n
      +OL :
        OpAssociativeRightRingoidTerm
          n ->
        OpAssociativeRightRingoidTerm
          n ->
        OpAssociativeRightRingoidTerm n
    data OpAssociativeRightRingoidTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpAssociativeRightRingoidTerm2 n
          A
      sing2 :
        A ->
        OpAssociativeRightRingoidTerm2 n
          A
      *OL2 :
        OpAssociativeRightRingoidTerm2 n
          A ->
        OpAssociativeRightRingoidTerm2 n
          A ->
        OpAssociativeRightRingoidTerm2 n
          A
      +OL2 :
        OpAssociativeRightRingoidTerm2 n
          A ->
        OpAssociativeRightRingoidTerm2 n
          A ->
        OpAssociativeRightRingoidTerm2 n
          A
    simplifyB :
      AssociativeRightRingoidTerm ->
      AssociativeRightRingoidTerm
    simplifyB (+L
               (*L y x)
               (*L z x)) = *L (+L y z) x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClAssociativeRightRingoidTerm
        A ->
      ClAssociativeRightRingoidTerm A
    simplifyCl _ (+Cl
                  (*Cl y x)
                  (*Cl z x)) = *Cl (+Cl y z) x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpAssociativeRightRingoidTerm
        n ->
      OpAssociativeRightRingoidTerm n
    simplifyOp _ (+OL
                  (*OL y x)
                  (*OL z x)) = *OL (+OL y z) x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpAssociativeRightRingoidTerm2 n
        A ->
      OpAssociativeRightRingoidTerm2 n
        A
    simplifyOpE _ _ (+OL2
                     (*OL2 y x)
                     (*OL2 z x)) = *OL2 (+OL2 y z) x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      AssociativeRightRingoid A ->
      AssociativeRightRingoidTerm -> A
    evalB _ As (*L x1 x2) =
      * As (evalB _ As x1)
        (evalB _ As x2)
    evalB _ As (+L x1 x2) =
      + As (evalB _ As x1)
        (evalB _ As x2)
    evalCl :
      (A : Set) ->
      AssociativeRightRingoid A ->
      ClAssociativeRightRingoidTerm
        A -> A
    evalCl _ As (sing x1) = x1
    evalCl _ As (*Cl x1 x2) =
      * As (evalCl _ As x1)
        (evalCl _ As x2)
    evalCl _ As (+Cl x1 x2) =
      + As (evalCl _ As x1)
        (evalCl _ As x2)
    evalOp :
      (A : Set) (n : Nat) ->
      AssociativeRightRingoid A ->
      Vec A n ->
      OpAssociativeRightRingoidTerm
        n -> A
    evalOp _ n As vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n As vars (*OL x1 x2) =
      * As (evalOp _ n As vars x1)
        (evalOp _ n As vars x2)
    evalOp _ n As vars (+OL x1 x2) =
      + As (evalOp _ n As vars x1)
        (evalOp _ n As vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      AssociativeRightRingoid A ->
      Vec A n ->
      OpAssociativeRightRingoidTerm2 n
        A -> A
    evalOpE _ n As vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n As vars (sing2 x1) =
      x1
    evalOpE _ n As vars (*OL2
                         x1
                         x2) =
      * As (evalOpE _ n As vars x1)
        (evalOpE _ n As vars x2)
    evalOpE _ n As vars (+OL2
                         x1
                         x2) =
      + As (evalOpE _ n As vars x1)
        (evalOpE _ n As vars x2)
    inductionB :
      (P : AssociativeRightRingoidTerm ->
           Set) ->
      ((x1 : AssociativeRightRingoidTerm)
       (x2 : AssociativeRightRingoidTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : AssociativeRightRingoidTerm)
       (x2 : AssociativeRightRingoidTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : AssociativeRightRingoidTerm) ->
      P x
    inductionB p p*l p+l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionB p p*l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClAssociativeRightRingoidTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClAssociativeRightRingoidTerm
          A)
       (x2 : ClAssociativeRightRingoidTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClAssociativeRightRingoidTerm
          A)
       (x2 : ClAssociativeRightRingoidTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClAssociativeRightRingoidTerm
         A) -> P x
    inductionCl _ p psing p*cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p*cl p+cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionCl _ p psing p*cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpAssociativeRightRingoidTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpAssociativeRightRingoidTerm
          n)
       (x2 : OpAssociativeRightRingoidTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpAssociativeRightRingoidTerm
          n)
       (x2 : OpAssociativeRightRingoidTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpAssociativeRightRingoidTerm
         n) -> P x
    inductionOp _ p pv p*ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p*ol p+ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOp _ p pv p*ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpAssociativeRightRingoidTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpAssociativeRightRingoidTerm2
          n
          A)
       (x2 : OpAssociativeRightRingoidTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpAssociativeRightRingoidTerm2
          n
          A)
       (x2 : OpAssociativeRightRingoidTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpAssociativeRightRingoidTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    *L' :
      AssociativeRightRingoidTerm ->
      AssociativeRightRingoidTerm ->
      AssociativeRightRingoidTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      AssociativeRightRingoidTerm ->
      AssociativeRightRingoidTerm ->
      AssociativeRightRingoidTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      AssociativeRightRingoidTerm ->
      Staged
        AssociativeRightRingoidTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClAssociativeRightRingoidTerm
        A ->
      ClAssociativeRightRingoidTerm
        A ->
      ClAssociativeRightRingoidTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClAssociativeRightRingoidTerm
        A ->
      ClAssociativeRightRingoidTerm
        A ->
      ClAssociativeRightRingoidTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClAssociativeRightRingoidTerm
        A ->
      Staged
        (ClAssociativeRightRingoidTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpAssociativeRightRingoidTerm
        n ->
      OpAssociativeRightRingoidTerm
        n ->
      OpAssociativeRightRingoidTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpAssociativeRightRingoidTerm
        n ->
      OpAssociativeRightRingoidTerm
        n ->
      OpAssociativeRightRingoidTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpAssociativeRightRingoidTerm
        n ->
      Staged
        (OpAssociativeRightRingoidTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpAssociativeRightRingoidTerm2 n
        A ->
      OpAssociativeRightRingoidTerm2 n
        A ->
      OpAssociativeRightRingoidTerm2 n
        A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpAssociativeRightRingoidTerm2 n
        A ->
      OpAssociativeRightRingoidTerm2 n
        A ->
      OpAssociativeRightRingoidTerm2 n
        A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpAssociativeRightRingoidTerm2 n
        A ->
      Staged
        (OpAssociativeRightRingoidTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record AssociativeRightRingoidTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module Band where
    record Band
      (A : Set) : Set where
      constructor BandC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        idempotent_op :
          (x : A) -> op x x == x
    record BandSig
      (AS : Set) : Set where
      constructor BandSigSigC
      field
        opS : AS -> AS -> AS
    record BandProd
      (AP : Set) : Set where
      constructor BandProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        idempotent_opP :
          (xP : Prod AP AP) ->
          opP xP xP == xP
    record BandHom
      (A1 : Set) (A2 : Set)
      (Ba1 : Band A1)
      (Ba2 : Band A2) : Set where
      constructor BandHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ba1 x1 x2) ==
            op Ba2 (hom x1) (hom x2)
    record BandRelInterp
      (A1 : Set) (A2 : Set)
      (Ba1 : Band A1)
      (Ba2 : Band A2) : Set where
      constructor BandRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ba1 x1 x2)
            (op Ba2 y1 y2)
    data BandTerm : Set where
      opL :
        BandTerm -> BandTerm -> BandTerm
    data ClBandTerm
      (A : Set) : Set where
      sing : A -> ClBandTerm A
      opCl :
        ClBandTerm A ->
        ClBandTerm A -> ClBandTerm A
    data OpBandTerm
      (n : Nat) : Set where
      v : Fin n -> OpBandTerm n
      opOL :
        OpBandTerm n ->
        OpBandTerm n -> OpBandTerm n
    data OpBandTerm2
      (n : Nat) (A : Set) : Set where
      v2 : Fin n -> OpBandTerm2 n A
      sing2 : A -> OpBandTerm2 n A
      opOL2 :
        OpBandTerm2 n A ->
        OpBandTerm2 n A ->
        OpBandTerm2 n A
    simplifyB : BandTerm -> BandTerm
    simplifyB (opL x x) = x
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClBandTerm A -> ClBandTerm A
    simplifyCl _ (opCl x x) = x
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpBandTerm n -> OpBandTerm n
    simplifyOp _ (opOL x x) = x
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpBandTerm2 n A ->
      OpBandTerm2 n A
    simplifyOpE _ _ (opOL2 x x) = x
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Band A -> BandTerm -> A
    evalB _ Ba (opL x1 x2) =
      op Ba (evalB _ Ba x1)
        (evalB _ Ba x2)
    evalCl :
      (A : Set) ->
      Band A -> ClBandTerm A -> A
    evalCl _ Ba (sing x1) = x1
    evalCl _ Ba (opCl x1 x2) =
      op Ba (evalCl _ Ba x1)
        (evalCl _ Ba x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Band A ->
      Vec A n -> OpBandTerm n -> A
    evalOp _ n Ba vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ba vars (opOL
                        x1
                        x2) =
      op Ba (evalOp _ n Ba vars x1)
        (evalOp _ n Ba vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Band A ->
      Vec A n -> OpBandTerm2 n A -> A
    evalOpE _ n Ba vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ba vars (sing2 x1) =
      x1
    evalOpE _ n Ba vars (opOL2
                         x1
                         x2) =
      op Ba (evalOpE _ n Ba vars x1)
        (evalOpE _ n Ba vars x2)
    inductionB :
      (P : BandTerm -> Set) ->
      ((x1 : BandTerm)
       (x2 : BandTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : BandTerm) -> P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClBandTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClBandTerm A)
       (x2 : ClBandTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClBandTerm A) -> P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpBandTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpBandTerm n)
       (x2 : OpBandTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpBandTerm n) -> P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpBandTerm2 n A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpBandTerm2 n A)
       (x2 : OpBandTerm2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpBandTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      BandTerm -> BandTerm -> BandTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      BandTerm -> Staged BandTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClBandTerm A ->
      ClBandTerm A -> ClBandTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClBandTerm A ->
      Staged (ClBandTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpBandTerm n ->
      OpBandTerm n -> OpBandTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpBandTerm n ->
      Staged (OpBandTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpBandTerm2 n A ->
      OpBandTerm2 n A ->
      OpBandTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpBandTerm2 n A ->
      Staged (OpBandTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record BandTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module BinaryInverse where
    record BinaryInverse
      (A : Set) : Set where
      constructor BinaryInverseC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftInverse :
          (x : A) (y : A) ->
          <| (|> x y) x == y
        rightInverse :
          (x : A) (y : A) ->
          |> x (<| y x) == y
    record BinaryInverseSig
      (AS : Set) : Set where
      constructor BinaryInverseSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record BinaryInverseProd
      (AP : Set) : Set where
      constructor BinaryInverseProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          <|P (|>P xP yP) xP == yP
        rightInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          |>P xP (<|P yP xP) == yP
    record BinaryInverseHom
      (A1 : Set) (A2 : Set)
      (Bi1 : BinaryInverse A1)
      (Bi2 : BinaryInverse A2) :
      Set where
      constructor BinaryInverseHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Bi1 x1 x2) ==
            |> Bi2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Bi1 x1 x2) ==
            <| Bi2 (hom x1) (hom x2)
    record BinaryInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Bi1 : BinaryInverse A1)
      (Bi2 : BinaryInverse A2) :
      Set where
      constructor BinaryInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Bi1 x1 x2)
            (|> Bi2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Bi1 x1 x2)
            (<| Bi2 y1 y2)
    data BinaryInverseTerm
      : Set where
      |>L :
        BinaryInverseTerm ->
        BinaryInverseTerm ->
        BinaryInverseTerm
      <|L :
        BinaryInverseTerm ->
        BinaryInverseTerm ->
        BinaryInverseTerm
    data ClBinaryInverseTerm
      (A : Set) : Set where
      sing :
        A -> ClBinaryInverseTerm A
      |>Cl :
        ClBinaryInverseTerm A ->
        ClBinaryInverseTerm A ->
        ClBinaryInverseTerm A
      <|Cl :
        ClBinaryInverseTerm A ->
        ClBinaryInverseTerm A ->
        ClBinaryInverseTerm A
    data OpBinaryInverseTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpBinaryInverseTerm n
      |>OL :
        OpBinaryInverseTerm n ->
        OpBinaryInverseTerm n ->
        OpBinaryInverseTerm n
      <|OL :
        OpBinaryInverseTerm n ->
        OpBinaryInverseTerm n ->
        OpBinaryInverseTerm n
    data OpBinaryInverseTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpBinaryInverseTerm2 n A
      sing2 :
        A -> OpBinaryInverseTerm2 n A
      |>OL2 :
        OpBinaryInverseTerm2 n A ->
        OpBinaryInverseTerm2 n A ->
        OpBinaryInverseTerm2 n A
      <|OL2 :
        OpBinaryInverseTerm2 n A ->
        OpBinaryInverseTerm2 n A ->
        OpBinaryInverseTerm2 n A
    simplifyB :
      BinaryInverseTerm ->
      BinaryInverseTerm
    simplifyB (<|L (|>L x y) x) = y
    simplifyB (|>L x (<|L y x)) = y
    simplifyB (|>L x1 x2) =
      |>L (simplifyB x1)
        (simplifyB x2)
    simplifyB (<|L x1 x2) =
      <|L (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClBinaryInverseTerm A ->
      ClBinaryInverseTerm A
    simplifyCl _ (<|Cl
                  (|>Cl x y)
                  x) = y
    simplifyCl _ (|>Cl
                  x
                  (<|Cl y x)) = y
    simplifyCl _ (|>Cl x1 x2) =
      |>Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (<|Cl x1 x2) =
      <|Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpBinaryInverseTerm n ->
      OpBinaryInverseTerm n
    simplifyOp _ (<|OL
                  (|>OL x y)
                  x) = y
    simplifyOp _ (|>OL
                  x
                  (<|OL y x)) = y
    simplifyOp _ (|>OL x1 x2) =
      |>OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (<|OL x1 x2) =
      <|OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpBinaryInverseTerm2 n A ->
      OpBinaryInverseTerm2 n A
    simplifyOpE _ _ (<|OL2
                     (|>OL2 x y)
                     x) = y
    simplifyOpE _ _ (|>OL2
                     x
                     (<|OL2 y x)) = y
    simplifyOpE _ _ (|>OL2 x1 x2) =
      |>OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (<|OL2 x1 x2) =
      <|OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      BinaryInverse A ->
      BinaryInverseTerm -> A
    evalB _ Bi (|>L x1 x2) =
      |> Bi (evalB _ Bi x1)
        (evalB _ Bi x2)
    evalB _ Bi (<|L x1 x2) =
      <| Bi (evalB _ Bi x1)
        (evalB _ Bi x2)
    evalCl :
      (A : Set) ->
      BinaryInverse A ->
      ClBinaryInverseTerm A -> A
    evalCl _ Bi (sing x1) = x1
    evalCl _ Bi (|>Cl x1 x2) =
      |> Bi (evalCl _ Bi x1)
        (evalCl _ Bi x2)
    evalCl _ Bi (<|Cl x1 x2) =
      <| Bi (evalCl _ Bi x1)
        (evalCl _ Bi x2)
    evalOp :
      (A : Set) (n : Nat) ->
      BinaryInverse A ->
      Vec A n ->
      OpBinaryInverseTerm n -> A
    evalOp _ n Bi vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Bi vars (|>OL
                        x1
                        x2) =
      |> Bi (evalOp _ n Bi vars x1)
        (evalOp _ n Bi vars x2)
    evalOp _ n Bi vars (<|OL
                        x1
                        x2) =
      <| Bi (evalOp _ n Bi vars x1)
        (evalOp _ n Bi vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      BinaryInverse A ->
      Vec A n ->
      OpBinaryInverseTerm2 n A -> A
    evalOpE _ n Bi vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Bi vars (sing2 x1) =
      x1
    evalOpE _ n Bi vars (|>OL2
                         x1
                         x2) =
      |> Bi (evalOpE _ n Bi vars x1)
        (evalOpE _ n Bi vars x2)
    evalOpE _ n Bi vars (<|OL2
                         x1
                         x2) =
      <| Bi (evalOpE _ n Bi vars x1)
        (evalOpE _ n Bi vars x2)
    inductionB :
      (P : BinaryInverseTerm ->
           Set) ->
      ((x1 : BinaryInverseTerm)
       (x2 : BinaryInverseTerm) ->
       P x1 ->
       P x2 -> P (|>L x1 x2)) ->
      ((x1 : BinaryInverseTerm)
       (x2 : BinaryInverseTerm) ->
       P x1 ->
       P x2 -> P (<|L x1 x2)) ->
      (x : BinaryInverseTerm) -> P x
    inductionB p p|>l p<|l (|>L
                            x1
                            x2) =
      p|>l _ _
        (inductionB p p|>l p<|l x1)
        (inductionB p p|>l p<|l x2)
    inductionB p p|>l p<|l (<|L
                            x1
                            x2) =
      p<|l _ _
        (inductionB p p|>l p<|l x1)
        (inductionB p p|>l p<|l x2)
    inductionCl :
      (A : Set)
      (P : ClBinaryInverseTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClBinaryInverseTerm A)
       (x2 : ClBinaryInverseTerm A) ->
       P x1 ->
       P x2 -> P (|>Cl x1 x2)) ->
      ((x1 : ClBinaryInverseTerm A)
       (x2 : ClBinaryInverseTerm A) ->
       P x1 ->
       P x2 -> P (<|Cl x1 x2)) ->
      (x : ClBinaryInverseTerm A) ->
      P x
    inductionCl _ p psing p|>cl p<|cl (sing
                                       x1) = psing x1
    inductionCl _ p psing p|>cl p<|cl (|>Cl
                                       x1
                                       x2) =
      p|>cl _ _
        (inductionCl _ p psing p|>cl
           p<|cl
           x1)
        (inductionCl _ p psing p|>cl
           p<|cl
           x2)
    inductionCl _ p psing p|>cl p<|cl (<|Cl
                                       x1
                                       x2) =
      p<|cl _ _
        (inductionCl _ p psing p|>cl
           p<|cl
           x1)
        (inductionCl _ p psing p|>cl
           p<|cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpBinaryInverseTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpBinaryInverseTerm n)
       (x2 : OpBinaryInverseTerm n) ->
       P x1 ->
       P x2 -> P (|>OL x1 x2)) ->
      ((x1 : OpBinaryInverseTerm n)
       (x2 : OpBinaryInverseTerm n) ->
       P x1 ->
       P x2 -> P (<|OL x1 x2)) ->
      (x : OpBinaryInverseTerm n) ->
      P x
    inductionOp _ p pv p|>ol p<|ol (v
                                    x1) = pv x1
    inductionOp _ p pv p|>ol p<|ol (|>OL
                                    x1
                                    x2) =
      p|>ol _ _
        (inductionOp _ p pv p|>ol p<|ol
           x1)
        (inductionOp _ p pv p|>ol p<|ol
           x2)
    inductionOp _ p pv p|>ol p<|ol (<|OL
                                    x1
                                    x2) =
      p<|ol _ _
        (inductionOp _ p pv p|>ol p<|ol
           x1)
        (inductionOp _ p pv p|>ol p<|ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpBinaryInverseTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpBinaryInverseTerm2 n A)
       (x2 : OpBinaryInverseTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (|>OL2 x1 x2)) ->
      ((x1 : OpBinaryInverseTerm2 n A)
       (x2 : OpBinaryInverseTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (<|OL2 x1 x2)) ->
      (x : OpBinaryInverseTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (v2
                                                 x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (sing2
                                                 x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (|>OL2
                                                 x1
                                                 x2) =
      p|>ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (<|OL2
                                                 x1
                                                 x2) =
      p<|ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x2)
    |>L' :
      BinaryInverseTerm ->
      BinaryInverseTerm ->
      BinaryInverseTerm
    |>L' x1 x2 = |>L x1 x2
    <|L' :
      BinaryInverseTerm ->
      BinaryInverseTerm ->
      BinaryInverseTerm
    <|L' x1 x2 = <|L x1 x2
    stageB :
      BinaryInverseTerm ->
      Staged BinaryInverseTerm
    stageB (|>L x1 x2) =
      stage2 _ _ _ |>L'
        (codeLift2 _ _ _ |>L')
        (stageB x1)
        (stageB x2)
    stageB (<|L x1 x2) =
      stage2 _ _ _ <|L'
        (codeLift2 _ _ _ <|L')
        (stageB x1)
        (stageB x2)
    |>Cl' :
      (A : Set) ->
      ClBinaryInverseTerm A ->
      ClBinaryInverseTerm A ->
      ClBinaryInverseTerm A
    |>Cl' _ x1 x2 = |>Cl x1 x2
    <|Cl' :
      (A : Set) ->
      ClBinaryInverseTerm A ->
      ClBinaryInverseTerm A ->
      ClBinaryInverseTerm A
    <|Cl' _ x1 x2 = <|Cl x1 x2
    stageCl :
      (A : Set) ->
      ClBinaryInverseTerm A ->
      Staged (ClBinaryInverseTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (|>Cl x1 x2) =
      stage2 _ _ _ (|>Cl' _)
        (codeLift2 _ _ _ (|>Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (<|Cl x1 x2) =
      stage2 _ _ _ (<|Cl' _)
        (codeLift2 _ _ _ (<|Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    |>OL' :
      (n : Nat) ->
      OpBinaryInverseTerm n ->
      OpBinaryInverseTerm n ->
      OpBinaryInverseTerm n
    |>OL' _ x1 x2 = |>OL x1 x2
    <|OL' :
      (n : Nat) ->
      OpBinaryInverseTerm n ->
      OpBinaryInverseTerm n ->
      OpBinaryInverseTerm n
    <|OL' _ x1 x2 = <|OL x1 x2
    stageOp :
      (n : Nat) ->
      OpBinaryInverseTerm n ->
      Staged (OpBinaryInverseTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (|>OL x1 x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (<|OL x1 x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    |>OL2' :
      (n : Nat) (A : Set) ->
      OpBinaryInverseTerm2 n A ->
      OpBinaryInverseTerm2 n A ->
      OpBinaryInverseTerm2 n A
    |>OL2' _ _ x1 x2 = |>OL2 x1 x2
    <|OL2' :
      (n : Nat) (A : Set) ->
      OpBinaryInverseTerm2 n A ->
      OpBinaryInverseTerm2 n A ->
      OpBinaryInverseTerm2 n A
    <|OL2' _ _ x1 x2 = <|OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpBinaryInverseTerm2 n A ->
      Staged
        (OpBinaryInverseTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (|>OL2 x1 x2) =
      stage2 _ _ _ (|>OL2' _ _)
        (codeLift2 _ _ _ (|>OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (<|OL2 x1 x2) =
      stage2 _ _ _ (<|OL2' _ _)
        (codeLift2 _ _ _ (<|OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record BinaryInverseTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        |>T : Repr A -> Repr A -> Repr A
        <|T : Repr A -> Repr A -> Repr A
  
  module BooleanGroup where
    record BooleanGroup
      (A : Set) : Set where
      constructor BooleanGroupC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        unipotence :
          (x : A) -> op x x == e
    record BooleanGroupSig
      (AS : Set) : Set where
      constructor BooleanGroupSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record BooleanGroupProd
      (AP : Set) : Set where
      constructor BooleanGroupProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        unipotenceP :
          (xP : Prod AP AP) ->
          opP xP xP == eP
    record BooleanGroupHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BooleanGroup A1)
      (Bo2 : BooleanGroup A2) :
      Set where
      constructor BooleanGroupHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Bo1) == e Bo2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Bo1 x1 x2) ==
            op Bo2 (hom x1) (hom x2)
    record BooleanGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BooleanGroup A1)
      (Bo2 : BooleanGroup A2) :
      Set where
      constructor BooleanGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Bo1) (e Bo2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Bo1 x1 x2)
            (op Bo2 y1 y2)
    data BooleanGroupTerm
      : Set where
      eL : BooleanGroupTerm
      opL :
        BooleanGroupTerm ->
        BooleanGroupTerm ->
        BooleanGroupTerm
    data ClBooleanGroupTerm
      (A : Set) : Set where
      sing :
        A -> ClBooleanGroupTerm A
      eCl : ClBooleanGroupTerm A
      opCl :
        ClBooleanGroupTerm A ->
        ClBooleanGroupTerm A ->
        ClBooleanGroupTerm A
    data OpBooleanGroupTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpBooleanGroupTerm n
      eOL : OpBooleanGroupTerm n
      opOL :
        OpBooleanGroupTerm n ->
        OpBooleanGroupTerm n ->
        OpBooleanGroupTerm n
    data OpBooleanGroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpBooleanGroupTerm2 n A
      sing2 :
        A -> OpBooleanGroupTerm2 n A
      eOL2 : OpBooleanGroupTerm2 n A
      opOL2 :
        OpBooleanGroupTerm2 n A ->
        OpBooleanGroupTerm2 n A ->
        OpBooleanGroupTerm2 n A
    simplifyB :
      BooleanGroupTerm ->
      BooleanGroupTerm
    simplifyB (opL (eL) x) = x
    simplifyB (opL x (eL)) = x
    simplifyB (opL x x) = eL
    simplifyB (eL) = eL
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClBooleanGroupTerm A ->
      ClBooleanGroupTerm A
    simplifyCl _ (opCl (eCl) x) = x
    simplifyCl _ (opCl x (eCl)) = x
    simplifyCl _ (opCl x x) = eCl
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpBooleanGroupTerm n ->
      OpBooleanGroupTerm n
    simplifyOp _ (opOL (eOL) x) = x
    simplifyOp _ (opOL x (eOL)) = x
    simplifyOp _ (opOL x x) = eOL
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpBooleanGroupTerm2 n A ->
      OpBooleanGroupTerm2 n A
    simplifyOpE _ _ (opOL2
                     (eOL2)
                     x) = x
    simplifyOpE _ _ (opOL2
                     x
                     (eOL2)) = x
    simplifyOpE _ _ (opOL2 x x) =
      eOL2
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      BooleanGroup A ->
      BooleanGroupTerm -> A
    evalB _ Bo (eL) = e Bo
    evalB _ Bo (opL x1 x2) =
      op Bo (evalB _ Bo x1)
        (evalB _ Bo x2)
    evalCl :
      (A : Set) ->
      BooleanGroup A ->
      ClBooleanGroupTerm A -> A
    evalCl _ Bo (sing x1) = x1
    evalCl _ Bo (eCl) = e Bo
    evalCl _ Bo (opCl x1 x2) =
      op Bo (evalCl _ Bo x1)
        (evalCl _ Bo x2)
    evalOp :
      (A : Set) (n : Nat) ->
      BooleanGroup A ->
      Vec A n ->
      OpBooleanGroupTerm n -> A
    evalOp _ n Bo vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Bo vars (eOL) = e Bo
    evalOp _ n Bo vars (opOL
                        x1
                        x2) =
      op Bo (evalOp _ n Bo vars x1)
        (evalOp _ n Bo vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      BooleanGroup A ->
      Vec A n ->
      OpBooleanGroupTerm2 n A -> A
    evalOpE _ n Bo vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Bo vars (sing2 x1) =
      x1
    evalOpE _ n Bo vars (eOL2) =
      e Bo
    evalOpE _ n Bo vars (opOL2
                         x1
                         x2) =
      op Bo (evalOpE _ n Bo vars x1)
        (evalOpE _ n Bo vars x2)
    inductionB :
      (P : BooleanGroupTerm -> Set) ->
      P eL ->
      ((x1 : BooleanGroupTerm)
       (x2 : BooleanGroupTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : BooleanGroupTerm) -> P x
    inductionB p pel popl (eL) = pel
    inductionB p pel popl (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p pel popl x1)
        (inductionB p pel popl x2)
    inductionCl :
      (A : Set)
      (P : ClBooleanGroupTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P eCl ->
      ((x1 : ClBooleanGroupTerm A)
       (x2 : ClBooleanGroupTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClBooleanGroupTerm A) ->
      P x
    inductionCl _ p psing pecl popcl (sing
                                      x1) = psing x1
    inductionCl _ p psing pecl popcl (eCl) =
      pecl
    inductionCl _ p psing pecl popcl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing pecl
           popcl
           x1)
        (inductionCl _ p psing pecl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpBooleanGroupTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P eOL ->
      ((x1 : OpBooleanGroupTerm n)
       (x2 : OpBooleanGroupTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpBooleanGroupTerm n) ->
      P x
    inductionOp _ p pv peol popol (v
                                   x1) = pv x1
    inductionOp _ p pv peol popol (eOL) =
      peol
    inductionOp _ p pv peol popol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv peol popol
           x1)
        (inductionOp _ p pv peol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpBooleanGroupTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P eOL2 ->
      ((x1 : OpBooleanGroupTerm2 n A)
       (x2 : OpBooleanGroupTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpBooleanGroupTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x2)
    eL' : BooleanGroupTerm
    eL' = eL
    opL' :
      BooleanGroupTerm ->
      BooleanGroupTerm ->
      BooleanGroupTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      BooleanGroupTerm ->
      Staged BooleanGroupTerm
    stageB (eL) = Now eL
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    eCl' :
      (A : Set) ->
      ClBooleanGroupTerm A
    eCl' _ = eCl
    opCl' :
      (A : Set) ->
      ClBooleanGroupTerm A ->
      ClBooleanGroupTerm A ->
      ClBooleanGroupTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClBooleanGroupTerm A ->
      Staged (ClBooleanGroupTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (eCl) = Now eCl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    eOL' :
      (n : Nat) ->
      OpBooleanGroupTerm n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      OpBooleanGroupTerm n ->
      OpBooleanGroupTerm n ->
      OpBooleanGroupTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpBooleanGroupTerm n ->
      Staged (OpBooleanGroupTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (eOL) = Now eOL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    eOL2' :
      (n : Nat) (A : Set) ->
      OpBooleanGroupTerm2 n A
    eOL2' _ _ = eOL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpBooleanGroupTerm2 n A ->
      OpBooleanGroupTerm2 n A ->
      OpBooleanGroupTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpBooleanGroupTerm2 n A ->
      Staged (OpBooleanGroupTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record BooleanGroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        eT : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module BooleanRing where
    record BooleanRing
      (A : Set) : Set where
      constructor BooleanRingC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
        idempotent_* :
          (x : A) -> * x x == x
    record BooleanRingSig
      (AS : Set) : Set where
      constructor BooleanRingSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
    record BooleanRingProd
      (AP : Set) : Set where
      constructor BooleanRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
    record BooleanRingHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BooleanRing A1)
      (Bo2 : BooleanRing A2) :
      Set where
      constructor BooleanRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
        pres-1 : hom (1 Bo1) == 1 Bo2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
        pres-0 : hom (0 Bo1) == 0 Bo2
        pres-neg :
          (x1 : A1) ->
          hom (neg Bo1 x1) ==
            neg Bo2 (hom x1)
    record BooleanRingRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BooleanRing A1)
      (Bo2 : BooleanRing A2) :
      Set where
      constructor BooleanRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
        interp-1 :
          interp (1 Bo1) (1 Bo2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
        interp-0 :
          interp (0 Bo1) (0 Bo2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Bo1 x1) (neg Bo2 y1)
    data BooleanRingTerm : Set where
      *L :
        BooleanRingTerm ->
        BooleanRingTerm ->
        BooleanRingTerm
      1L : BooleanRingTerm
      +L :
        BooleanRingTerm ->
        BooleanRingTerm ->
        BooleanRingTerm
      0L : BooleanRingTerm
      negL :
        BooleanRingTerm ->
        BooleanRingTerm
    data ClBooleanRingTerm
      (A : Set) : Set where
      sing :
        A -> ClBooleanRingTerm A
      *Cl :
        ClBooleanRingTerm A ->
        ClBooleanRingTerm A ->
        ClBooleanRingTerm A
      1Cl : ClBooleanRingTerm A
      +Cl :
        ClBooleanRingTerm A ->
        ClBooleanRingTerm A ->
        ClBooleanRingTerm A
      0Cl : ClBooleanRingTerm A
      negCl :
        ClBooleanRingTerm A ->
        ClBooleanRingTerm A
    data OpBooleanRingTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpBooleanRingTerm n
      *OL :
        OpBooleanRingTerm n ->
        OpBooleanRingTerm n ->
        OpBooleanRingTerm n
      1OL : OpBooleanRingTerm n
      +OL :
        OpBooleanRingTerm n ->
        OpBooleanRingTerm n ->
        OpBooleanRingTerm n
      0OL : OpBooleanRingTerm n
      negOL :
        OpBooleanRingTerm n ->
        OpBooleanRingTerm n
    data OpBooleanRingTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpBooleanRingTerm2 n A
      sing2 :
        A -> OpBooleanRingTerm2 n A
      *OL2 :
        OpBooleanRingTerm2 n A ->
        OpBooleanRingTerm2 n A ->
        OpBooleanRingTerm2 n A
      1OL2 : OpBooleanRingTerm2 n A
      +OL2 :
        OpBooleanRingTerm2 n A ->
        OpBooleanRingTerm2 n A ->
        OpBooleanRingTerm2 n A
      0OL2 : OpBooleanRingTerm2 n A
      negOL2 :
        OpBooleanRingTerm2 n A ->
        OpBooleanRingTerm2 n A
    simplifyB :
      BooleanRingTerm ->
      BooleanRingTerm
    simplifyB (*L (1L) x) = x
    simplifyB (*L x (1L)) = x
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (+L
               (*L x y)
               (*L x z)) = *L x (+L y z)
    simplifyB (+L
               (*L y x)
               (*L z x)) = *L (+L y z) x
    simplifyB (+L x (negL x)) = 0L
    simplifyB (+L (negL x) x) = 0L
    simplifyB (*L (0L) x) = 0L
    simplifyB (*L x (0L)) = 0L
    simplifyB (*L x x) = x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (1L) = 1L
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (0L) = 0L
    simplifyB (negL x1) =
      negL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClBooleanRingTerm A ->
      ClBooleanRingTerm A
    simplifyCl _ (*Cl (1Cl) x) = x
    simplifyCl _ (*Cl x (1Cl)) = x
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (+Cl
                  (*Cl x y)
                  (*Cl x z)) = *Cl x (+Cl y z)
    simplifyCl _ (+Cl
                  (*Cl y x)
                  (*Cl z x)) = *Cl (+Cl y z) x
    simplifyCl _ (+Cl x (negCl x)) =
      0Cl
    simplifyCl _ (+Cl (negCl x) x) =
      0Cl
    simplifyCl _ (*Cl (0Cl) x) = 0Cl
    simplifyCl _ (*Cl x (0Cl)) = 0Cl
    simplifyCl _ (*Cl x x) = x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (negCl x1) =
      negCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpBooleanRingTerm n ->
      OpBooleanRingTerm n
    simplifyOp _ (*OL (1OL) x) = x
    simplifyOp _ (*OL x (1OL)) = x
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (+OL
                  (*OL x y)
                  (*OL x z)) = *OL x (+OL y z)
    simplifyOp _ (+OL
                  (*OL y x)
                  (*OL z x)) = *OL (+OL y z) x
    simplifyOp _ (+OL x (negOL x)) =
      0OL
    simplifyOp _ (+OL (negOL x) x) =
      0OL
    simplifyOp _ (*OL (0OL) x) = 0OL
    simplifyOp _ (*OL x (0OL)) = 0OL
    simplifyOp _ (*OL x x) = x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (negOL x1) =
      negOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpBooleanRingTerm2 n A ->
      OpBooleanRingTerm2 n A
    simplifyOpE _ _ (*OL2
                     (1OL2)
                     x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (1OL2)) = x
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (+OL2
                     (*OL2 x y)
                     (*OL2 x z)) = *OL2 x (+OL2 y z)
    simplifyOpE _ _ (+OL2
                     (*OL2 y x)
                     (*OL2 z x)) = *OL2 (+OL2 y z) x
    simplifyOpE _ _ (+OL2
                     x
                     (negOL2 x)) = 0OL2
    simplifyOpE _ _ (+OL2
                     (negOL2 x)
                     x) = 0OL2
    simplifyOpE _ _ (*OL2
                     (0OL2)
                     x) = 0OL2
    simplifyOpE _ _ (*OL2
                     x
                     (0OL2)) = 0OL2
    simplifyOpE _ _ (*OL2 x x) = x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (negOL2 x1) =
      negOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      BooleanRing A ->
      BooleanRingTerm -> A
    evalB _ Bo (*L x1 x2) =
      * Bo (evalB _ Bo x1)
        (evalB _ Bo x2)
    evalB _ Bo (1L) = 1 Bo
    evalB _ Bo (+L x1 x2) =
      + Bo (evalB _ Bo x1)
        (evalB _ Bo x2)
    evalB _ Bo (0L) = 0 Bo
    evalB _ Bo (negL x1) =
      neg Bo (evalB _ Bo x1)
    evalCl :
      (A : Set) ->
      BooleanRing A ->
      ClBooleanRingTerm A -> A
    evalCl _ Bo (sing x1) = x1
    evalCl _ Bo (*Cl x1 x2) =
      * Bo (evalCl _ Bo x1)
        (evalCl _ Bo x2)
    evalCl _ Bo (1Cl) = 1 Bo
    evalCl _ Bo (+Cl x1 x2) =
      + Bo (evalCl _ Bo x1)
        (evalCl _ Bo x2)
    evalCl _ Bo (0Cl) = 0 Bo
    evalCl _ Bo (negCl x1) =
      neg Bo (evalCl _ Bo x1)
    evalOp :
      (A : Set) (n : Nat) ->
      BooleanRing A ->
      Vec A n ->
      OpBooleanRingTerm n -> A
    evalOp _ n Bo vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Bo vars (*OL x1 x2) =
      * Bo (evalOp _ n Bo vars x1)
        (evalOp _ n Bo vars x2)
    evalOp _ n Bo vars (1OL) = 1 Bo
    evalOp _ n Bo vars (+OL x1 x2) =
      + Bo (evalOp _ n Bo vars x1)
        (evalOp _ n Bo vars x2)
    evalOp _ n Bo vars (0OL) = 0 Bo
    evalOp _ n Bo vars (negOL x1) =
      neg Bo (evalOp _ n Bo vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      BooleanRing A ->
      Vec A n ->
      OpBooleanRingTerm2 n A -> A
    evalOpE _ n Bo vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Bo vars (sing2 x1) =
      x1
    evalOpE _ n Bo vars (*OL2
                         x1
                         x2) =
      * Bo (evalOpE _ n Bo vars x1)
        (evalOpE _ n Bo vars x2)
    evalOpE _ n Bo vars (1OL2) =
      1 Bo
    evalOpE _ n Bo vars (+OL2
                         x1
                         x2) =
      + Bo (evalOpE _ n Bo vars x1)
        (evalOpE _ n Bo vars x2)
    evalOpE _ n Bo vars (0OL2) =
      0 Bo
    evalOpE _ n Bo vars (negOL2
                         x1) =
      neg Bo (evalOpE _ n Bo vars x1)
    inductionB :
      (P : BooleanRingTerm -> Set) ->
      ((x1 : BooleanRingTerm)
       (x2 : BooleanRingTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      P 1L ->
      ((x1 : BooleanRingTerm)
       (x2 : BooleanRingTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      P 0L ->
      ((x1 : BooleanRingTerm) ->
       P x1 -> P (negL x1)) ->
      (x : BooleanRingTerm) -> P x
    inductionB p p*l p1l p+l p0l pnegl (*L
                                        x1
                                        x2) =
      p*l _ _
        (inductionB p p*l p1l p+l p0l
           pnegl
           x1)
        (inductionB p p*l p1l p+l p0l
           pnegl
           x2)
    inductionB p p*l p1l p+l p0l pnegl (1L) =
      p1l
    inductionB p p*l p1l p+l p0l pnegl (+L
                                        x1
                                        x2) =
      p+l _ _
        (inductionB p p*l p1l p+l p0l
           pnegl
           x1)
        (inductionB p p*l p1l p+l p0l
           pnegl
           x2)
    inductionB p p*l p1l p+l p0l pnegl (0L) =
      p0l
    inductionB p p*l p1l p+l p0l pnegl (negL
                                        x1) =
      pnegl _
        (inductionB p p*l p1l p+l p0l
           pnegl
           x1)
    inductionCl :
      (A : Set)
      (P : ClBooleanRingTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClBooleanRingTerm A)
       (x2 : ClBooleanRingTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      P 1Cl ->
      ((x1 : ClBooleanRingTerm A)
       (x2 : ClBooleanRingTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      P 0Cl ->
      ((x1 : ClBooleanRingTerm A) ->
       P x1 -> P (negCl x1)) ->
      (x : ClBooleanRingTerm A) -> P x
    inductionCl _ p psing p*cl p1cl p+cl p0cl pnegcl (sing
                                                      x1) = psing x1
    inductionCl _ p psing p*cl p1cl p+cl p0cl pnegcl (*Cl
                                                      x1
                                                      x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p1cl
           p+cl
           p0cl
           pnegcl
           x1)
        (inductionCl _ p psing p*cl p1cl
           p+cl
           p0cl
           pnegcl
           x2)
    inductionCl _ p psing p*cl p1cl p+cl p0cl pnegcl (1Cl) =
      p1cl
    inductionCl _ p psing p*cl p1cl p+cl p0cl pnegcl (+Cl
                                                      x1
                                                      x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p1cl
           p+cl
           p0cl
           pnegcl
           x1)
        (inductionCl _ p psing p*cl p1cl
           p+cl
           p0cl
           pnegcl
           x2)
    inductionCl _ p psing p*cl p1cl p+cl p0cl pnegcl (0Cl) =
      p0cl
    inductionCl _ p psing p*cl p1cl p+cl p0cl pnegcl (negCl
                                                      x1) =
      pnegcl _
        (inductionCl _ p psing p*cl p1cl
           p+cl
           p0cl
           pnegcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpBooleanRingTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpBooleanRingTerm n)
       (x2 : OpBooleanRingTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      P 1OL ->
      ((x1 : OpBooleanRingTerm n)
       (x2 : OpBooleanRingTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      P 0OL ->
      ((x1 : OpBooleanRingTerm n) ->
       P x1 -> P (negOL x1)) ->
      (x : OpBooleanRingTerm n) -> P x
    inductionOp _ p pv p*ol p1ol p+ol p0ol pnegol (v
                                                   x1) = pv x1
    inductionOp _ p pv p*ol p1ol p+ol p0ol pnegol (*OL
                                                   x1
                                                   x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p1ol
           p+ol
           p0ol
           pnegol
           x1)
        (inductionOp _ p pv p*ol p1ol
           p+ol
           p0ol
           pnegol
           x2)
    inductionOp _ p pv p*ol p1ol p+ol p0ol pnegol (1OL) =
      p1ol
    inductionOp _ p pv p*ol p1ol p+ol p0ol pnegol (+OL
                                                   x1
                                                   x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p1ol
           p+ol
           p0ol
           pnegol
           x1)
        (inductionOp _ p pv p*ol p1ol
           p+ol
           p0ol
           pnegol
           x2)
    inductionOp _ p pv p*ol p1ol p+ol p0ol pnegol (0OL) =
      p0ol
    inductionOp _ p pv p*ol p1ol p+ol p0ol pnegol (negOL
                                                   x1) =
      pnegol _
        (inductionOp _ p pv p*ol p1ol
           p+ol
           p0ol
           pnegol
           x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpBooleanRingTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpBooleanRingTerm2 n A)
       (x2 : OpBooleanRingTerm2 n A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      P 1OL2 ->
      ((x1 : OpBooleanRingTerm2 n A)
       (x2 : OpBooleanRingTerm2 n A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      P 0OL2 ->
      ((x1 : OpBooleanRingTerm2 n
          A) -> P x1 -> P (negOL2 x1)) ->
      (x : OpBooleanRingTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 pnegol2 (v2
                                                                   x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 pnegol2 (sing2
                                                                   x1) =
      psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 pnegol2 (*OL2
                                                                   x1
                                                                   x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           p+ol2
           p0ol2
           pnegol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           p+ol2
           p0ol2
           pnegol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 pnegol2 (1OL2) =
      p1ol2
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 pnegol2 (+OL2
                                                                   x1
                                                                   x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           p+ol2
           p0ol2
           pnegol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           p+ol2
           p0ol2
           pnegol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 pnegol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 pnegol2 (negOL2
                                                                   x1) =
      pnegol2 _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           p+ol2
           p0ol2
           pnegol2
           x1)
    *L' :
      BooleanRingTerm ->
      BooleanRingTerm ->
      BooleanRingTerm
    *L' x1 x2 = *L x1 x2
    1L' : BooleanRingTerm
    1L' = 1L
    +L' :
      BooleanRingTerm ->
      BooleanRingTerm ->
      BooleanRingTerm
    +L' x1 x2 = +L x1 x2
    0L' : BooleanRingTerm
    0L' = 0L
    negL' :
      BooleanRingTerm ->
      BooleanRingTerm
    negL' x1 = negL x1
    stageB :
      BooleanRingTerm ->
      Staged BooleanRingTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (1L) = Now 1L
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (0L) = Now 0L
    stageB (negL x1) =
      stage1 _ _ negL'
        (codeLift1 _ _ negL')
        (stageB x1)
    *Cl' :
      (A : Set) ->
      ClBooleanRingTerm A ->
      ClBooleanRingTerm A ->
      ClBooleanRingTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    1Cl' :
      (A : Set) -> ClBooleanRingTerm A
    1Cl' _ = 1Cl
    +Cl' :
      (A : Set) ->
      ClBooleanRingTerm A ->
      ClBooleanRingTerm A ->
      ClBooleanRingTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    0Cl' :
      (A : Set) -> ClBooleanRingTerm A
    0Cl' _ = 0Cl
    negCl' :
      (A : Set) ->
      ClBooleanRingTerm A ->
      ClBooleanRingTerm A
    negCl' _ x1 = negCl x1
    stageCl :
      (A : Set) ->
      ClBooleanRingTerm A ->
      Staged (ClBooleanRingTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (1Cl) = Now 1Cl
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (negCl x1) =
      stage1 _ _ (negCl' _)
        (codeLift1 _ _ (negCl' _))
        (stageCl _ x1)
    *OL' :
      (n : Nat) ->
      OpBooleanRingTerm n ->
      OpBooleanRingTerm n ->
      OpBooleanRingTerm n
    *OL' _ x1 x2 = *OL x1 x2
    1OL' :
      (n : Nat) -> OpBooleanRingTerm n
    1OL' _ = 1OL
    +OL' :
      (n : Nat) ->
      OpBooleanRingTerm n ->
      OpBooleanRingTerm n ->
      OpBooleanRingTerm n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) -> OpBooleanRingTerm n
    0OL' _ = 0OL
    negOL' :
      (n : Nat) ->
      OpBooleanRingTerm n ->
      OpBooleanRingTerm n
    negOL' _ x1 = negOL x1
    stageOp :
      (n : Nat) ->
      OpBooleanRingTerm n ->
      Staged (OpBooleanRingTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (1OL) = Now 1OL
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (0OL) = Now 0OL
    stageOp _ (negOL x1) =
      stage1 _ _ (negOL' _)
        (codeLift1 _ _ (negOL' _))
        (stageOp _ x1)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpBooleanRingTerm2 n A ->
      OpBooleanRingTerm2 n A ->
      OpBooleanRingTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    1OL2' :
      (n : Nat) (A : Set) ->
      OpBooleanRingTerm2 n A
    1OL2' _ _ = 1OL2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpBooleanRingTerm2 n A ->
      OpBooleanRingTerm2 n A ->
      OpBooleanRingTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    0OL2' :
      (n : Nat) (A : Set) ->
      OpBooleanRingTerm2 n A
    0OL2' _ _ = 0OL2
    negOL2' :
      (n : Nat) (A : Set) ->
      OpBooleanRingTerm2 n A ->
      OpBooleanRingTerm2 n A
    negOL2' _ _ x1 = negOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpBooleanRingTerm2 n A ->
      Staged (OpBooleanRingTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (1OL2) = Now 1OL2
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (negOL2 x1) =
      stage1 _ _ (negOL2' _ _)
        (codeLift1 _ _ (negOL2' _ _))
        (stageOpE _ _ x1)
    record BooleanRingTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        1T : Repr A
        +T : Repr A -> Repr A -> Repr A
        0T : Repr A
        negT : Repr A -> Repr A
  
  module BoundedDistributiveLattice where
    record BoundedDistributiveLattice
      (A : Set) : Set where
      constructor BoundedDistributiveLatticeC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
        leftModular_*_+ :
          (x : A) (y : A) (z : A) ->
          + (* x y) (* x z) ==
            * x (+ y (* x z))
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
    record BoundedDistributiveLatticeSig
      (AS : Set) : Set where
      constructor BoundedDistributiveLatticeSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        1S : AS
    record BoundedDistributiveLatticeProd
      (AP : Set) : Set where
      constructor BoundedDistributiveLatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        1P : Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
        leftModular_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (*P xP yP) (*P xP zP) ==
            *P xP (+P yP (*P xP zP))
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
    record BoundedDistributiveLatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedDistributiveLattice
         A1)
      (Bo2 : BoundedDistributiveLattice
         A2) : Set where
      constructor BoundedDistributiveLatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
        pres-0 : hom (0 Bo1) == 0 Bo2
        pres-1 : hom (1 Bo1) == 1 Bo2
    record BoundedDistributiveLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedDistributiveLattice
         A1)
      (Bo2 : BoundedDistributiveLattice
         A2) : Set where
      constructor BoundedDistributiveLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
        interp-0 :
          interp (0 Bo1) (0 Bo2)
        interp-1 :
          interp (1 Bo1) (1 Bo2)
    data BoundedDistributiveLatticeTerm
      : Set where
      *L :
        BoundedDistributiveLatticeTerm ->
        BoundedDistributiveLatticeTerm ->
        BoundedDistributiveLatticeTerm
      +L :
        BoundedDistributiveLatticeTerm ->
        BoundedDistributiveLatticeTerm ->
        BoundedDistributiveLatticeTerm
      0L :
        BoundedDistributiveLatticeTerm
      1L :
        BoundedDistributiveLatticeTerm
    data ClBoundedDistributiveLatticeTerm
      (A : Set) : Set where
      sing :
        A ->
        ClBoundedDistributiveLatticeTerm
          A
      *Cl :
        ClBoundedDistributiveLatticeTerm
          A ->
        ClBoundedDistributiveLatticeTerm
          A ->
        ClBoundedDistributiveLatticeTerm
          A
      +Cl :
        ClBoundedDistributiveLatticeTerm
          A ->
        ClBoundedDistributiveLatticeTerm
          A ->
        ClBoundedDistributiveLatticeTerm
          A
      0Cl :
        ClBoundedDistributiveLatticeTerm
          A
      1Cl :
        ClBoundedDistributiveLatticeTerm
          A
    data OpBoundedDistributiveLatticeTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpBoundedDistributiveLatticeTerm
          n
      *OL :
        OpBoundedDistributiveLatticeTerm
          n ->
        OpBoundedDistributiveLatticeTerm
          n ->
        OpBoundedDistributiveLatticeTerm
          n
      +OL :
        OpBoundedDistributiveLatticeTerm
          n ->
        OpBoundedDistributiveLatticeTerm
          n ->
        OpBoundedDistributiveLatticeTerm
          n
      0OL :
        OpBoundedDistributiveLatticeTerm
          n
      1OL :
        OpBoundedDistributiveLatticeTerm
          n
    data OpBoundedDistributiveLatticeTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpBoundedDistributiveLatticeTerm2
          n
          A
      sing2 :
        A ->
        OpBoundedDistributiveLatticeTerm2
          n
          A
      *OL2 :
        OpBoundedDistributiveLatticeTerm2
          n
          A ->
        OpBoundedDistributiveLatticeTerm2
          n
          A ->
        OpBoundedDistributiveLatticeTerm2
          n
          A
      +OL2 :
        OpBoundedDistributiveLatticeTerm2
          n
          A ->
        OpBoundedDistributiveLatticeTerm2
          n
          A ->
        OpBoundedDistributiveLatticeTerm2
          n
          A
      0OL2 :
        OpBoundedDistributiveLatticeTerm2
          n
          A
      1OL2 :
        OpBoundedDistributiveLatticeTerm2
          n
          A
    simplifyB :
      BoundedDistributiveLatticeTerm ->
      BoundedDistributiveLatticeTerm
    simplifyB (*L x x) = x
    simplifyB (+L x x) = x
    simplifyB (*L x (+L x y)) = x
    simplifyB (+L x (*L x y)) = x
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (*L (1L) x) = x
    simplifyB (*L x (1L)) = x
    simplifyB (+L
               (*L x y)
               (*L x z)) = *L x (+L y z)
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (0L) = 0L
    simplifyB (1L) = 1L
    simplifyCl :
      (A : Set) ->
      ClBoundedDistributiveLatticeTerm
        A ->
      ClBoundedDistributiveLatticeTerm
        A
    simplifyCl _ (*Cl x x) = x
    simplifyCl _ (+Cl x x) = x
    simplifyCl _ (*Cl x (+Cl x y)) =
      x
    simplifyCl _ (+Cl x (*Cl x y)) =
      x
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (*Cl (1Cl) x) = x
    simplifyCl _ (*Cl x (1Cl)) = x
    simplifyCl _ (+Cl
                  (*Cl x y)
                  (*Cl x z)) = *Cl x (+Cl y z)
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpBoundedDistributiveLatticeTerm
        n ->
      OpBoundedDistributiveLatticeTerm
        n
    simplifyOp _ (*OL x x) = x
    simplifyOp _ (+OL x x) = x
    simplifyOp _ (*OL x (+OL x y)) =
      x
    simplifyOp _ (+OL x (*OL x y)) =
      x
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (*OL (1OL) x) = x
    simplifyOp _ (*OL x (1OL)) = x
    simplifyOp _ (+OL
                  (*OL x y)
                  (*OL x z)) = *OL x (+OL y z)
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpBoundedDistributiveLatticeTerm2
        n
        A ->
      OpBoundedDistributiveLatticeTerm2
        n
        A
    simplifyOpE _ _ (*OL2 x x) = x
    simplifyOpE _ _ (+OL2 x x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (+OL2 x y)) = x
    simplifyOpE _ _ (+OL2
                     x
                     (*OL2 x y)) = x
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (*OL2
                     (1OL2)
                     x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (1OL2)) = x
    simplifyOpE _ _ (+OL2
                     (*OL2 x y)
                     (*OL2 x z)) = *OL2 x (+OL2 y z)
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      BoundedDistributiveLattice A ->
      BoundedDistributiveLatticeTerm ->
      A
    evalB _ Bo (*L x1 x2) =
      * Bo (evalB _ Bo x1)
        (evalB _ Bo x2)
    evalB _ Bo (+L x1 x2) =
      + Bo (evalB _ Bo x1)
        (evalB _ Bo x2)
    evalB _ Bo (0L) = 0 Bo
    evalB _ Bo (1L) = 1 Bo
    evalCl :
      (A : Set) ->
      BoundedDistributiveLattice A ->
      ClBoundedDistributiveLatticeTerm
        A -> A
    evalCl _ Bo (sing x1) = x1
    evalCl _ Bo (*Cl x1 x2) =
      * Bo (evalCl _ Bo x1)
        (evalCl _ Bo x2)
    evalCl _ Bo (+Cl x1 x2) =
      + Bo (evalCl _ Bo x1)
        (evalCl _ Bo x2)
    evalCl _ Bo (0Cl) = 0 Bo
    evalCl _ Bo (1Cl) = 1 Bo
    evalOp :
      (A : Set) (n : Nat) ->
      BoundedDistributiveLattice A ->
      Vec A n ->
      OpBoundedDistributiveLatticeTerm
        n -> A
    evalOp _ n Bo vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Bo vars (*OL x1 x2) =
      * Bo (evalOp _ n Bo vars x1)
        (evalOp _ n Bo vars x2)
    evalOp _ n Bo vars (+OL x1 x2) =
      + Bo (evalOp _ n Bo vars x1)
        (evalOp _ n Bo vars x2)
    evalOp _ n Bo vars (0OL) = 0 Bo
    evalOp _ n Bo vars (1OL) = 1 Bo
    evalOpE :
      (A : Set) (n : Nat) ->
      BoundedDistributiveLattice A ->
      Vec A n ->
      OpBoundedDistributiveLatticeTerm2
        n
        A -> A
    evalOpE _ n Bo vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Bo vars (sing2 x1) =
      x1
    evalOpE _ n Bo vars (*OL2
                         x1
                         x2) =
      * Bo (evalOpE _ n Bo vars x1)
        (evalOpE _ n Bo vars x2)
    evalOpE _ n Bo vars (+OL2
                         x1
                         x2) =
      + Bo (evalOpE _ n Bo vars x1)
        (evalOpE _ n Bo vars x2)
    evalOpE _ n Bo vars (0OL2) =
      0 Bo
    evalOpE _ n Bo vars (1OL2) =
      1 Bo
    inductionB :
      (P : BoundedDistributiveLatticeTerm ->
           Set) ->
      ((x1 : BoundedDistributiveLatticeTerm)
       (x2 : BoundedDistributiveLatticeTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : BoundedDistributiveLatticeTerm)
       (x2 : BoundedDistributiveLatticeTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      P 0L ->
      P 1L ->
      (x : BoundedDistributiveLatticeTerm) ->
      P x
    inductionB p p*l p+l p0l p1l (*L
                                  x1
                                  x2) =
      p*l _ _
        (inductionB p p*l p+l p0l p1l
           x1)
        (inductionB p p*l p+l p0l p1l
           x2)
    inductionB p p*l p+l p0l p1l (+L
                                  x1
                                  x2) =
      p+l _ _
        (inductionB p p*l p+l p0l p1l
           x1)
        (inductionB p p*l p+l p0l p1l
           x2)
    inductionB p p*l p+l p0l p1l (0L) =
      p0l
    inductionB p p*l p+l p0l p1l (1L) =
      p1l
    inductionCl :
      (A : Set)
      (P : ClBoundedDistributiveLatticeTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClBoundedDistributiveLatticeTerm
          A)
       (x2 : ClBoundedDistributiveLatticeTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClBoundedDistributiveLatticeTerm
          A)
       (x2 : ClBoundedDistributiveLatticeTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      P 0Cl ->
      P 1Cl ->
      (x : ClBoundedDistributiveLatticeTerm
         A) -> P x
    inductionCl _ p psing p*cl p+cl p0cl p1cl (sing
                                               x1) = psing x1
    inductionCl _ p psing p*cl p+cl p0cl p1cl (*Cl
                                               x1
                                               x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           p0cl
           p1cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           p0cl
           p1cl
           x2)
    inductionCl _ p psing p*cl p+cl p0cl p1cl (+Cl
                                               x1
                                               x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           p0cl
           p1cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           p0cl
           p1cl
           x2)
    inductionCl _ p psing p*cl p+cl p0cl p1cl (0Cl) =
      p0cl
    inductionCl _ p psing p*cl p+cl p0cl p1cl (1Cl) =
      p1cl
    inductionOp :
      (n : Nat)
      (P : OpBoundedDistributiveLatticeTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpBoundedDistributiveLatticeTerm
          n)
       (x2 : OpBoundedDistributiveLatticeTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpBoundedDistributiveLatticeTerm
          n)
       (x2 : OpBoundedDistributiveLatticeTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      P 0OL ->
      P 1OL ->
      (x : OpBoundedDistributiveLatticeTerm
         n) -> P x
    inductionOp _ p pv p*ol p+ol p0ol p1ol (v
                                            x1) = pv x1
    inductionOp _ p pv p*ol p+ol p0ol p1ol (*OL
                                            x1
                                            x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           p0ol
           p1ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           p0ol
           p1ol
           x2)
    inductionOp _ p pv p*ol p+ol p0ol p1ol (+OL
                                            x1
                                            x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           p0ol
           p1ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           p0ol
           p1ol
           x2)
    inductionOp _ p pv p*ol p+ol p0ol p1ol (0OL) =
      p0ol
    inductionOp _ p pv p*ol p+ol p0ol p1ol (1OL) =
      p1ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpBoundedDistributiveLatticeTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpBoundedDistributiveLatticeTerm2
          n
          A)
       (x2 : OpBoundedDistributiveLatticeTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpBoundedDistributiveLatticeTerm2
          n
          A)
       (x2 : OpBoundedDistributiveLatticeTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      P 0OL2 ->
      P 1OL2 ->
      (x : OpBoundedDistributiveLatticeTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (v2
                                                           x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (sing2
                                                           x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (*OL2
                                                           x1
                                                           x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           p1ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           p1ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (+OL2
                                                           x1
                                                           x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           p1ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           p1ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (1OL2) =
      p1ol2
    *L' :
      BoundedDistributiveLatticeTerm ->
      BoundedDistributiveLatticeTerm ->
      BoundedDistributiveLatticeTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      BoundedDistributiveLatticeTerm ->
      BoundedDistributiveLatticeTerm ->
      BoundedDistributiveLatticeTerm
    +L' x1 x2 = +L x1 x2
    0L' :
      BoundedDistributiveLatticeTerm
    0L' = 0L
    1L' :
      BoundedDistributiveLatticeTerm
    1L' = 1L
    stageB :
      BoundedDistributiveLatticeTerm ->
      Staged
        BoundedDistributiveLatticeTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (0L) = Now 0L
    stageB (1L) = Now 1L
    *Cl' :
      (A : Set) ->
      ClBoundedDistributiveLatticeTerm
        A ->
      ClBoundedDistributiveLatticeTerm
        A ->
      ClBoundedDistributiveLatticeTerm
        A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClBoundedDistributiveLatticeTerm
        A ->
      ClBoundedDistributiveLatticeTerm
        A ->
      ClBoundedDistributiveLatticeTerm
        A
    +Cl' _ x1 x2 = +Cl x1 x2
    0Cl' :
      (A : Set) ->
      ClBoundedDistributiveLatticeTerm
        A
    0Cl' _ = 0Cl
    1Cl' :
      (A : Set) ->
      ClBoundedDistributiveLatticeTerm
        A
    1Cl' _ = 1Cl
    stageCl :
      (A : Set) ->
      ClBoundedDistributiveLatticeTerm
        A ->
      Staged
        (ClBoundedDistributiveLatticeTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (1Cl) = Now 1Cl
    *OL' :
      (n : Nat) ->
      OpBoundedDistributiveLatticeTerm
        n ->
      OpBoundedDistributiveLatticeTerm
        n ->
      OpBoundedDistributiveLatticeTerm
        n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpBoundedDistributiveLatticeTerm
        n ->
      OpBoundedDistributiveLatticeTerm
        n ->
      OpBoundedDistributiveLatticeTerm
        n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      OpBoundedDistributiveLatticeTerm
        n
    0OL' _ = 0OL
    1OL' :
      (n : Nat) ->
      OpBoundedDistributiveLatticeTerm
        n
    1OL' _ = 1OL
    stageOp :
      (n : Nat) ->
      OpBoundedDistributiveLatticeTerm
        n ->
      Staged
        (OpBoundedDistributiveLatticeTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (0OL) = Now 0OL
    stageOp _ (1OL) = Now 1OL
    *OL2' :
      (n : Nat) (A : Set) ->
      OpBoundedDistributiveLatticeTerm2
        n
        A ->
      OpBoundedDistributiveLatticeTerm2
        n
        A ->
      OpBoundedDistributiveLatticeTerm2
        n
        A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpBoundedDistributiveLatticeTerm2
        n
        A ->
      OpBoundedDistributiveLatticeTerm2
        n
        A ->
      OpBoundedDistributiveLatticeTerm2
        n
        A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    0OL2' :
      (n : Nat) (A : Set) ->
      OpBoundedDistributiveLatticeTerm2
        n
        A
    0OL2' _ _ = 0OL2
    1OL2' :
      (n : Nat) (A : Set) ->
      OpBoundedDistributiveLatticeTerm2
        n
        A
    1OL2' _ _ = 1OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpBoundedDistributiveLatticeTerm2
        n
        A ->
      Staged
        (OpBoundedDistributiveLatticeTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (1OL2) = Now 1OL2
    record BoundedDistributiveLatticeTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
        0T : Repr A
        1T : Repr A
  
  module BoundedJoinLattice where
    record BoundedJoinLattice
      (A : Set) : Set where
      constructor BoundedJoinLatticeC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        * : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
    record BoundedJoinLatticeSig
      (AS : Set) : Set where
      constructor BoundedJoinLatticeSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
        *S : AS -> AS -> AS
    record BoundedJoinLatticeProd
      (AP : Set) : Set where
      constructor BoundedJoinLatticeProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
    record BoundedJoinLatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedJoinLattice A1)
      (Bo2 : BoundedJoinLattice A2) :
      Set where
      constructor BoundedJoinLatticeHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
        pres-0 : hom (0 Bo1) == 0 Bo2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
    record BoundedJoinLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedJoinLattice A1)
      (Bo2 : BoundedJoinLattice A2) :
      Set where
      constructor BoundedJoinLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
        interp-0 :
          interp (0 Bo1) (0 Bo2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
    data BoundedJoinLatticeTerm
      : Set where
      +L :
        BoundedJoinLatticeTerm ->
        BoundedJoinLatticeTerm ->
        BoundedJoinLatticeTerm
      0L : BoundedJoinLatticeTerm
      *L :
        BoundedJoinLatticeTerm ->
        BoundedJoinLatticeTerm ->
        BoundedJoinLatticeTerm
    data ClBoundedJoinLatticeTerm
      (A : Set) : Set where
      sing :
        A -> ClBoundedJoinLatticeTerm A
      +Cl :
        ClBoundedJoinLatticeTerm A ->
        ClBoundedJoinLatticeTerm A ->
        ClBoundedJoinLatticeTerm A
      0Cl : ClBoundedJoinLatticeTerm A
      *Cl :
        ClBoundedJoinLatticeTerm A ->
        ClBoundedJoinLatticeTerm A ->
        ClBoundedJoinLatticeTerm A
    data OpBoundedJoinLatticeTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpBoundedJoinLatticeTerm n
      +OL :
        OpBoundedJoinLatticeTerm n ->
        OpBoundedJoinLatticeTerm n ->
        OpBoundedJoinLatticeTerm n
      0OL : OpBoundedJoinLatticeTerm n
      *OL :
        OpBoundedJoinLatticeTerm n ->
        OpBoundedJoinLatticeTerm n ->
        OpBoundedJoinLatticeTerm n
    data OpBoundedJoinLatticeTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpBoundedJoinLatticeTerm2 n A
      sing2 :
        A ->
        OpBoundedJoinLatticeTerm2 n A
      +OL2 :
        OpBoundedJoinLatticeTerm2 n A ->
        OpBoundedJoinLatticeTerm2 n A ->
        OpBoundedJoinLatticeTerm2 n A
      0OL2 :
        OpBoundedJoinLatticeTerm2 n A
      *OL2 :
        OpBoundedJoinLatticeTerm2 n A ->
        OpBoundedJoinLatticeTerm2 n A ->
        OpBoundedJoinLatticeTerm2 n A
    simplifyB :
      BoundedJoinLatticeTerm ->
      BoundedJoinLatticeTerm
    simplifyB (+L x x) = x
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (*L x x) = x
    simplifyB (*L x (+L x y)) = x
    simplifyB (+L x (*L x y)) = x
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (0L) = 0L
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClBoundedJoinLatticeTerm A ->
      ClBoundedJoinLatticeTerm A
    simplifyCl _ (+Cl x x) = x
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (*Cl x x) = x
    simplifyCl _ (*Cl x (+Cl x y)) =
      x
    simplifyCl _ (+Cl x (*Cl x y)) =
      x
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpBoundedJoinLatticeTerm n ->
      OpBoundedJoinLatticeTerm n
    simplifyOp _ (+OL x x) = x
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (*OL x x) = x
    simplifyOp _ (*OL x (+OL x y)) =
      x
    simplifyOp _ (+OL x (*OL x y)) =
      x
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpBoundedJoinLatticeTerm2 n A ->
      OpBoundedJoinLatticeTerm2 n A
    simplifyOpE _ _ (+OL2 x x) = x
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (*OL2 x x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (+OL2 x y)) = x
    simplifyOpE _ _ (+OL2
                     x
                     (*OL2 x y)) = x
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      BoundedJoinLattice A ->
      BoundedJoinLatticeTerm -> A
    evalB _ Bo (+L x1 x2) =
      + Bo (evalB _ Bo x1)
        (evalB _ Bo x2)
    evalB _ Bo (0L) = 0 Bo
    evalB _ Bo (*L x1 x2) =
      * Bo (evalB _ Bo x1)
        (evalB _ Bo x2)
    evalCl :
      (A : Set) ->
      BoundedJoinLattice A ->
      ClBoundedJoinLatticeTerm A -> A
    evalCl _ Bo (sing x1) = x1
    evalCl _ Bo (+Cl x1 x2) =
      + Bo (evalCl _ Bo x1)
        (evalCl _ Bo x2)
    evalCl _ Bo (0Cl) = 0 Bo
    evalCl _ Bo (*Cl x1 x2) =
      * Bo (evalCl _ Bo x1)
        (evalCl _ Bo x2)
    evalOp :
      (A : Set) (n : Nat) ->
      BoundedJoinLattice A ->
      Vec A n ->
      OpBoundedJoinLatticeTerm n -> A
    evalOp _ n Bo vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Bo vars (+OL x1 x2) =
      + Bo (evalOp _ n Bo vars x1)
        (evalOp _ n Bo vars x2)
    evalOp _ n Bo vars (0OL) = 0 Bo
    evalOp _ n Bo vars (*OL x1 x2) =
      * Bo (evalOp _ n Bo vars x1)
        (evalOp _ n Bo vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      BoundedJoinLattice A ->
      Vec A n ->
      OpBoundedJoinLatticeTerm2 n A ->
      A
    evalOpE _ n Bo vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Bo vars (sing2 x1) =
      x1
    evalOpE _ n Bo vars (+OL2
                         x1
                         x2) =
      + Bo (evalOpE _ n Bo vars x1)
        (evalOpE _ n Bo vars x2)
    evalOpE _ n Bo vars (0OL2) =
      0 Bo
    evalOpE _ n Bo vars (*OL2
                         x1
                         x2) =
      * Bo (evalOpE _ n Bo vars x1)
        (evalOpE _ n Bo vars x2)
    inductionB :
      (P : BoundedJoinLatticeTerm ->
           Set) ->
      ((x1 : BoundedJoinLatticeTerm)
       (x2 : BoundedJoinLatticeTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      P 0L ->
      ((x1 : BoundedJoinLatticeTerm)
       (x2 : BoundedJoinLatticeTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      (x : BoundedJoinLatticeTerm) ->
      P x
    inductionB p p+l p0l p*l (+L
                              x1
                              x2) =
      p+l _ _
        (inductionB p p+l p0l p*l x1)
        (inductionB p p+l p0l p*l x2)
    inductionB p p+l p0l p*l (0L) =
      p0l
    inductionB p p+l p0l p*l (*L
                              x1
                              x2) =
      p*l _ _
        (inductionB p p+l p0l p*l x1)
        (inductionB p p+l p0l p*l x2)
    inductionCl :
      (A : Set)
      (P : ClBoundedJoinLatticeTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClBoundedJoinLatticeTerm
          A)
       (x2 : ClBoundedJoinLatticeTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      P 0Cl ->
      ((x1 : ClBoundedJoinLatticeTerm
          A)
       (x2 : ClBoundedJoinLatticeTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      (x : ClBoundedJoinLatticeTerm
         A) -> P x
    inductionCl _ p psing p+cl p0cl p*cl (sing
                                          x1) = psing x1
    inductionCl _ p psing p+cl p0cl p*cl (+Cl
                                          x1
                                          x2) =
      p+cl _ _
        (inductionCl _ p psing p+cl p0cl
           p*cl
           x1)
        (inductionCl _ p psing p+cl p0cl
           p*cl
           x2)
    inductionCl _ p psing p+cl p0cl p*cl (0Cl) =
      p0cl
    inductionCl _ p psing p+cl p0cl p*cl (*Cl
                                          x1
                                          x2) =
      p*cl _ _
        (inductionCl _ p psing p+cl p0cl
           p*cl
           x1)
        (inductionCl _ p psing p+cl p0cl
           p*cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpBoundedJoinLatticeTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpBoundedJoinLatticeTerm
          n)
       (x2 : OpBoundedJoinLatticeTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      P 0OL ->
      ((x1 : OpBoundedJoinLatticeTerm
          n)
       (x2 : OpBoundedJoinLatticeTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      (x : OpBoundedJoinLatticeTerm
         n) -> P x
    inductionOp _ p pv p+ol p0ol p*ol (v
                                       x1) = pv x1
    inductionOp _ p pv p+ol p0ol p*ol (+OL
                                       x1
                                       x2) =
      p+ol _ _
        (inductionOp _ p pv p+ol p0ol
           p*ol
           x1)
        (inductionOp _ p pv p+ol p0ol
           p*ol
           x2)
    inductionOp _ p pv p+ol p0ol p*ol (0OL) =
      p0ol
    inductionOp _ p pv p+ol p0ol p*ol (*OL
                                       x1
                                       x2) =
      p*ol _ _
        (inductionOp _ p pv p+ol p0ol
           p*ol
           x1)
        (inductionOp _ p pv p+ol p0ol
           p*ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpBoundedJoinLatticeTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpBoundedJoinLatticeTerm2
          n
          A)
       (x2 : OpBoundedJoinLatticeTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      P 0OL2 ->
      ((x1 : OpBoundedJoinLatticeTerm2
          n
          A)
       (x2 : OpBoundedJoinLatticeTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      (x : OpBoundedJoinLatticeTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 p*ol2 (v2
                                                     x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 p*ol2 (sing2
                                                     x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 p*ol2 (+OL2
                                                     x1
                                                     x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p0ol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p0ol2
           p*ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 p*ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 p*ol2 (*OL2
                                                     x1
                                                     x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p0ol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p0ol2
           p*ol2
           x2)
    +L' :
      BoundedJoinLatticeTerm ->
      BoundedJoinLatticeTerm ->
      BoundedJoinLatticeTerm
    +L' x1 x2 = +L x1 x2
    0L' : BoundedJoinLatticeTerm
    0L' = 0L
    *L' :
      BoundedJoinLatticeTerm ->
      BoundedJoinLatticeTerm ->
      BoundedJoinLatticeTerm
    *L' x1 x2 = *L x1 x2
    stageB :
      BoundedJoinLatticeTerm ->
      Staged BoundedJoinLatticeTerm
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (0L) = Now 0L
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    +Cl' :
      (A : Set) ->
      ClBoundedJoinLatticeTerm A ->
      ClBoundedJoinLatticeTerm A ->
      ClBoundedJoinLatticeTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    0Cl' :
      (A : Set) ->
      ClBoundedJoinLatticeTerm A
    0Cl' _ = 0Cl
    *Cl' :
      (A : Set) ->
      ClBoundedJoinLatticeTerm A ->
      ClBoundedJoinLatticeTerm A ->
      ClBoundedJoinLatticeTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    stageCl :
      (A : Set) ->
      ClBoundedJoinLatticeTerm A ->
      Staged
        (ClBoundedJoinLatticeTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    +OL' :
      (n : Nat) ->
      OpBoundedJoinLatticeTerm n ->
      OpBoundedJoinLatticeTerm n ->
      OpBoundedJoinLatticeTerm n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      OpBoundedJoinLatticeTerm n
    0OL' _ = 0OL
    *OL' :
      (n : Nat) ->
      OpBoundedJoinLatticeTerm n ->
      OpBoundedJoinLatticeTerm n ->
      OpBoundedJoinLatticeTerm n
    *OL' _ x1 x2 = *OL x1 x2
    stageOp :
      (n : Nat) ->
      OpBoundedJoinLatticeTerm n ->
      Staged
        (OpBoundedJoinLatticeTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (0OL) = Now 0OL
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    +OL2' :
      (n : Nat) (A : Set) ->
      OpBoundedJoinLatticeTerm2 n A ->
      OpBoundedJoinLatticeTerm2 n A ->
      OpBoundedJoinLatticeTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    0OL2' :
      (n : Nat) (A : Set) ->
      OpBoundedJoinLatticeTerm2 n A
    0OL2' _ _ = 0OL2
    *OL2' :
      (n : Nat) (A : Set) ->
      OpBoundedJoinLatticeTerm2 n A ->
      OpBoundedJoinLatticeTerm2 n A ->
      OpBoundedJoinLatticeTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpBoundedJoinLatticeTerm2 n A ->
      Staged
        (OpBoundedJoinLatticeTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record BoundedJoinLatticeTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        +T : Repr A -> Repr A -> Repr A
        0T : Repr A
        *T : Repr A -> Repr A -> Repr A
  
  module BoundedJoinSemilattice where
    record BoundedJoinSemilattice
      (A : Set) : Set where
      constructor BoundedJoinSemilatticeC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        idempotent_+ :
          (x : A) -> + x x == x
    record BoundedJoinSemilatticeSig
      (AS : Set) : Set where
      constructor BoundedJoinSemilatticeSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
    record BoundedJoinSemilatticeProd
      (AP : Set) : Set where
      constructor BoundedJoinSemilatticeProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record BoundedJoinSemilatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedJoinSemilattice
         A1)
      (Bo2 : BoundedJoinSemilattice
         A2) : Set where
      constructor BoundedJoinSemilatticeHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
        pres-0 : hom (0 Bo1) == 0 Bo2
    record BoundedJoinSemilatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedJoinSemilattice
         A1)
      (Bo2 : BoundedJoinSemilattice
         A2) : Set where
      constructor BoundedJoinSemilatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
        interp-0 :
          interp (0 Bo1) (0 Bo2)
    data BoundedJoinSemilatticeTerm
      : Set where
      +L :
        BoundedJoinSemilatticeTerm ->
        BoundedJoinSemilatticeTerm ->
        BoundedJoinSemilatticeTerm
      0L : BoundedJoinSemilatticeTerm
    data ClBoundedJoinSemilatticeTerm
      (A : Set) : Set where
      sing :
        A ->
        ClBoundedJoinSemilatticeTerm A
      +Cl :
        ClBoundedJoinSemilatticeTerm
          A ->
        ClBoundedJoinSemilatticeTerm
          A ->
        ClBoundedJoinSemilatticeTerm A
      0Cl :
        ClBoundedJoinSemilatticeTerm A
    data OpBoundedJoinSemilatticeTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpBoundedJoinSemilatticeTerm n
      +OL :
        OpBoundedJoinSemilatticeTerm
          n ->
        OpBoundedJoinSemilatticeTerm
          n ->
        OpBoundedJoinSemilatticeTerm n
      0OL :
        OpBoundedJoinSemilatticeTerm n
    data OpBoundedJoinSemilatticeTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpBoundedJoinSemilatticeTerm2 n
          A
      sing2 :
        A ->
        OpBoundedJoinSemilatticeTerm2 n
          A
      +OL2 :
        OpBoundedJoinSemilatticeTerm2 n
          A ->
        OpBoundedJoinSemilatticeTerm2 n
          A ->
        OpBoundedJoinSemilatticeTerm2 n
          A
      0OL2 :
        OpBoundedJoinSemilatticeTerm2 n
          A
    simplifyB :
      BoundedJoinSemilatticeTerm ->
      BoundedJoinSemilatticeTerm
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (+L x x) = x
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (0L) = 0L
    simplifyCl :
      (A : Set) ->
      ClBoundedJoinSemilatticeTerm
        A ->
      ClBoundedJoinSemilatticeTerm A
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (+Cl x x) = x
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpBoundedJoinSemilatticeTerm
        n ->
      OpBoundedJoinSemilatticeTerm n
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (+OL x x) = x
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpBoundedJoinSemilatticeTerm2 n
        A ->
      OpBoundedJoinSemilatticeTerm2 n
        A
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (+OL2 x x) = x
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      BoundedJoinSemilattice A ->
      BoundedJoinSemilatticeTerm -> A
    evalB _ Bo (+L x1 x2) =
      + Bo (evalB _ Bo x1)
        (evalB _ Bo x2)
    evalB _ Bo (0L) = 0 Bo
    evalCl :
      (A : Set) ->
      BoundedJoinSemilattice A ->
      ClBoundedJoinSemilatticeTerm
        A -> A
    evalCl _ Bo (sing x1) = x1
    evalCl _ Bo (+Cl x1 x2) =
      + Bo (evalCl _ Bo x1)
        (evalCl _ Bo x2)
    evalCl _ Bo (0Cl) = 0 Bo
    evalOp :
      (A : Set) (n : Nat) ->
      BoundedJoinSemilattice A ->
      Vec A n ->
      OpBoundedJoinSemilatticeTerm
        n -> A
    evalOp _ n Bo vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Bo vars (+OL x1 x2) =
      + Bo (evalOp _ n Bo vars x1)
        (evalOp _ n Bo vars x2)
    evalOp _ n Bo vars (0OL) = 0 Bo
    evalOpE :
      (A : Set) (n : Nat) ->
      BoundedJoinSemilattice A ->
      Vec A n ->
      OpBoundedJoinSemilatticeTerm2 n
        A -> A
    evalOpE _ n Bo vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Bo vars (sing2 x1) =
      x1
    evalOpE _ n Bo vars (+OL2
                         x1
                         x2) =
      + Bo (evalOpE _ n Bo vars x1)
        (evalOpE _ n Bo vars x2)
    evalOpE _ n Bo vars (0OL2) =
      0 Bo
    inductionB :
      (P : BoundedJoinSemilatticeTerm ->
           Set) ->
      ((x1 : BoundedJoinSemilatticeTerm)
       (x2 : BoundedJoinSemilatticeTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      P 0L ->
      (x : BoundedJoinSemilatticeTerm) ->
      P x
    inductionB p p+l p0l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p+l p0l x1)
        (inductionB p p+l p0l x2)
    inductionB p p+l p0l (0L) = p0l
    inductionCl :
      (A : Set)
      (P : ClBoundedJoinSemilatticeTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClBoundedJoinSemilatticeTerm
          A)
       (x2 : ClBoundedJoinSemilatticeTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      P 0Cl ->
      (x : ClBoundedJoinSemilatticeTerm
         A) -> P x
    inductionCl _ p psing p+cl p0cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p+cl p0cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p+cl p0cl
           x1)
        (inductionCl _ p psing p+cl p0cl
           x2)
    inductionCl _ p psing p+cl p0cl (0Cl) =
      p0cl
    inductionOp :
      (n : Nat)
      (P : OpBoundedJoinSemilatticeTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpBoundedJoinSemilatticeTerm
          n)
       (x2 : OpBoundedJoinSemilatticeTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      P 0OL ->
      (x : OpBoundedJoinSemilatticeTerm
         n) -> P x
    inductionOp _ p pv p+ol p0ol (v
                                  x1) = pv x1
    inductionOp _ p pv p+ol p0ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p+ol p0ol
           x1)
        (inductionOp _ p pv p+ol p0ol
           x2)
    inductionOp _ p pv p+ol p0ol (0OL) =
      p0ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpBoundedJoinSemilatticeTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpBoundedJoinSemilatticeTerm2
          n
          A)
       (x2 : OpBoundedJoinSemilatticeTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      P 0OL2 ->
      (x : OpBoundedJoinSemilatticeTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p0ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p0ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 (0OL2) =
      p0ol2
    +L' :
      BoundedJoinSemilatticeTerm ->
      BoundedJoinSemilatticeTerm ->
      BoundedJoinSemilatticeTerm
    +L' x1 x2 = +L x1 x2
    0L' : BoundedJoinSemilatticeTerm
    0L' = 0L
    stageB :
      BoundedJoinSemilatticeTerm ->
      Staged
        BoundedJoinSemilatticeTerm
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (0L) = Now 0L
    +Cl' :
      (A : Set) ->
      ClBoundedJoinSemilatticeTerm
        A ->
      ClBoundedJoinSemilatticeTerm
        A ->
      ClBoundedJoinSemilatticeTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    0Cl' :
      (A : Set) ->
      ClBoundedJoinSemilatticeTerm A
    0Cl' _ = 0Cl
    stageCl :
      (A : Set) ->
      ClBoundedJoinSemilatticeTerm
        A ->
      Staged
        (ClBoundedJoinSemilatticeTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (0Cl) = Now 0Cl
    +OL' :
      (n : Nat) ->
      OpBoundedJoinSemilatticeTerm
        n ->
      OpBoundedJoinSemilatticeTerm
        n ->
      OpBoundedJoinSemilatticeTerm n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      OpBoundedJoinSemilatticeTerm n
    0OL' _ = 0OL
    stageOp :
      (n : Nat) ->
      OpBoundedJoinSemilatticeTerm
        n ->
      Staged
        (OpBoundedJoinSemilatticeTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (0OL) = Now 0OL
    +OL2' :
      (n : Nat) (A : Set) ->
      OpBoundedJoinSemilatticeTerm2 n
        A ->
      OpBoundedJoinSemilatticeTerm2 n
        A ->
      OpBoundedJoinSemilatticeTerm2 n
        A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    0OL2' :
      (n : Nat) (A : Set) ->
      OpBoundedJoinSemilatticeTerm2 n
        A
    0OL2' _ _ = 0OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpBoundedJoinSemilatticeTerm2 n
        A ->
      Staged
        (OpBoundedJoinSemilatticeTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (0OL2) = Now 0OL2
    record BoundedJoinSemilatticeTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        +T : Repr A -> Repr A -> Repr A
        0T : Repr A
  
  module BoundedLattice where
    record BoundedLattice
      (A : Set) : Set where
      constructor BoundedLatticeC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
    record BoundedLatticeSig
      (AS : Set) : Set where
      constructor BoundedLatticeSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        1S : AS
    record BoundedLatticeProd
      (AP : Set) : Set where
      constructor BoundedLatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        1P : Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
    record BoundedLatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedLattice A1)
      (Bo2 : BoundedLattice A2) :
      Set where
      constructor BoundedLatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
        pres-0 : hom (0 Bo1) == 0 Bo2
        pres-1 : hom (1 Bo1) == 1 Bo2
    record BoundedLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedLattice A1)
      (Bo2 : BoundedLattice A2) :
      Set where
      constructor BoundedLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
        interp-0 :
          interp (0 Bo1) (0 Bo2)
        interp-1 :
          interp (1 Bo1) (1 Bo2)
    data BoundedLatticeTerm
      : Set where
      *L :
        BoundedLatticeTerm ->
        BoundedLatticeTerm ->
        BoundedLatticeTerm
      +L :
        BoundedLatticeTerm ->
        BoundedLatticeTerm ->
        BoundedLatticeTerm
      0L : BoundedLatticeTerm
      1L : BoundedLatticeTerm
    data ClBoundedLatticeTerm
      (A : Set) : Set where
      sing :
        A -> ClBoundedLatticeTerm A
      *Cl :
        ClBoundedLatticeTerm A ->
        ClBoundedLatticeTerm A ->
        ClBoundedLatticeTerm A
      +Cl :
        ClBoundedLatticeTerm A ->
        ClBoundedLatticeTerm A ->
        ClBoundedLatticeTerm A
      0Cl : ClBoundedLatticeTerm A
      1Cl : ClBoundedLatticeTerm A
    data OpBoundedLatticeTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpBoundedLatticeTerm n
      *OL :
        OpBoundedLatticeTerm n ->
        OpBoundedLatticeTerm n ->
        OpBoundedLatticeTerm n
      +OL :
        OpBoundedLatticeTerm n ->
        OpBoundedLatticeTerm n ->
        OpBoundedLatticeTerm n
      0OL : OpBoundedLatticeTerm n
      1OL : OpBoundedLatticeTerm n
    data OpBoundedLatticeTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpBoundedLatticeTerm2 n A
      sing2 :
        A -> OpBoundedLatticeTerm2 n A
      *OL2 :
        OpBoundedLatticeTerm2 n A ->
        OpBoundedLatticeTerm2 n A ->
        OpBoundedLatticeTerm2 n A
      +OL2 :
        OpBoundedLatticeTerm2 n A ->
        OpBoundedLatticeTerm2 n A ->
        OpBoundedLatticeTerm2 n A
      0OL2 : OpBoundedLatticeTerm2 n A
      1OL2 : OpBoundedLatticeTerm2 n A
    simplifyB :
      BoundedLatticeTerm ->
      BoundedLatticeTerm
    simplifyB (*L x x) = x
    simplifyB (+L x x) = x
    simplifyB (*L x (+L x y)) = x
    simplifyB (+L x (*L x y)) = x
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (*L (1L) x) = x
    simplifyB (*L x (1L)) = x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (0L) = 0L
    simplifyB (1L) = 1L
    simplifyCl :
      (A : Set) ->
      ClBoundedLatticeTerm A ->
      ClBoundedLatticeTerm A
    simplifyCl _ (*Cl x x) = x
    simplifyCl _ (+Cl x x) = x
    simplifyCl _ (*Cl x (+Cl x y)) =
      x
    simplifyCl _ (+Cl x (*Cl x y)) =
      x
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (*Cl (1Cl) x) = x
    simplifyCl _ (*Cl x (1Cl)) = x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpBoundedLatticeTerm n ->
      OpBoundedLatticeTerm n
    simplifyOp _ (*OL x x) = x
    simplifyOp _ (+OL x x) = x
    simplifyOp _ (*OL x (+OL x y)) =
      x
    simplifyOp _ (+OL x (*OL x y)) =
      x
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (*OL (1OL) x) = x
    simplifyOp _ (*OL x (1OL)) = x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpBoundedLatticeTerm2 n A ->
      OpBoundedLatticeTerm2 n A
    simplifyOpE _ _ (*OL2 x x) = x
    simplifyOpE _ _ (+OL2 x x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (+OL2 x y)) = x
    simplifyOpE _ _ (+OL2
                     x
                     (*OL2 x y)) = x
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (*OL2
                     (1OL2)
                     x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (1OL2)) = x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      BoundedLattice A ->
      BoundedLatticeTerm -> A
    evalB _ Bo (*L x1 x2) =
      * Bo (evalB _ Bo x1)
        (evalB _ Bo x2)
    evalB _ Bo (+L x1 x2) =
      + Bo (evalB _ Bo x1)
        (evalB _ Bo x2)
    evalB _ Bo (0L) = 0 Bo
    evalB _ Bo (1L) = 1 Bo
    evalCl :
      (A : Set) ->
      BoundedLattice A ->
      ClBoundedLatticeTerm A -> A
    evalCl _ Bo (sing x1) = x1
    evalCl _ Bo (*Cl x1 x2) =
      * Bo (evalCl _ Bo x1)
        (evalCl _ Bo x2)
    evalCl _ Bo (+Cl x1 x2) =
      + Bo (evalCl _ Bo x1)
        (evalCl _ Bo x2)
    evalCl _ Bo (0Cl) = 0 Bo
    evalCl _ Bo (1Cl) = 1 Bo
    evalOp :
      (A : Set) (n : Nat) ->
      BoundedLattice A ->
      Vec A n ->
      OpBoundedLatticeTerm n -> A
    evalOp _ n Bo vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Bo vars (*OL x1 x2) =
      * Bo (evalOp _ n Bo vars x1)
        (evalOp _ n Bo vars x2)
    evalOp _ n Bo vars (+OL x1 x2) =
      + Bo (evalOp _ n Bo vars x1)
        (evalOp _ n Bo vars x2)
    evalOp _ n Bo vars (0OL) = 0 Bo
    evalOp _ n Bo vars (1OL) = 1 Bo
    evalOpE :
      (A : Set) (n : Nat) ->
      BoundedLattice A ->
      Vec A n ->
      OpBoundedLatticeTerm2 n A -> A
    evalOpE _ n Bo vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Bo vars (sing2 x1) =
      x1
    evalOpE _ n Bo vars (*OL2
                         x1
                         x2) =
      * Bo (evalOpE _ n Bo vars x1)
        (evalOpE _ n Bo vars x2)
    evalOpE _ n Bo vars (+OL2
                         x1
                         x2) =
      + Bo (evalOpE _ n Bo vars x1)
        (evalOpE _ n Bo vars x2)
    evalOpE _ n Bo vars (0OL2) =
      0 Bo
    evalOpE _ n Bo vars (1OL2) =
      1 Bo
    inductionB :
      (P : BoundedLatticeTerm ->
           Set) ->
      ((x1 : BoundedLatticeTerm)
       (x2 : BoundedLatticeTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : BoundedLatticeTerm)
       (x2 : BoundedLatticeTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      P 0L ->
      P 1L ->
      (x : BoundedLatticeTerm) -> P x
    inductionB p p*l p+l p0l p1l (*L
                                  x1
                                  x2) =
      p*l _ _
        (inductionB p p*l p+l p0l p1l
           x1)
        (inductionB p p*l p+l p0l p1l
           x2)
    inductionB p p*l p+l p0l p1l (+L
                                  x1
                                  x2) =
      p+l _ _
        (inductionB p p*l p+l p0l p1l
           x1)
        (inductionB p p*l p+l p0l p1l
           x2)
    inductionB p p*l p+l p0l p1l (0L) =
      p0l
    inductionB p p*l p+l p0l p1l (1L) =
      p1l
    inductionCl :
      (A : Set)
      (P : ClBoundedLatticeTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClBoundedLatticeTerm A)
       (x2 : ClBoundedLatticeTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClBoundedLatticeTerm A)
       (x2 : ClBoundedLatticeTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      P 0Cl ->
      P 1Cl ->
      (x : ClBoundedLatticeTerm A) ->
      P x
    inductionCl _ p psing p*cl p+cl p0cl p1cl (sing
                                               x1) = psing x1
    inductionCl _ p psing p*cl p+cl p0cl p1cl (*Cl
                                               x1
                                               x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           p0cl
           p1cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           p0cl
           p1cl
           x2)
    inductionCl _ p psing p*cl p+cl p0cl p1cl (+Cl
                                               x1
                                               x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           p0cl
           p1cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           p0cl
           p1cl
           x2)
    inductionCl _ p psing p*cl p+cl p0cl p1cl (0Cl) =
      p0cl
    inductionCl _ p psing p*cl p+cl p0cl p1cl (1Cl) =
      p1cl
    inductionOp :
      (n : Nat)
      (P : OpBoundedLatticeTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpBoundedLatticeTerm n)
       (x2 : OpBoundedLatticeTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpBoundedLatticeTerm n)
       (x2 : OpBoundedLatticeTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      P 0OL ->
      P 1OL ->
      (x : OpBoundedLatticeTerm n) ->
      P x
    inductionOp _ p pv p*ol p+ol p0ol p1ol (v
                                            x1) = pv x1
    inductionOp _ p pv p*ol p+ol p0ol p1ol (*OL
                                            x1
                                            x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           p0ol
           p1ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           p0ol
           p1ol
           x2)
    inductionOp _ p pv p*ol p+ol p0ol p1ol (+OL
                                            x1
                                            x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           p0ol
           p1ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           p0ol
           p1ol
           x2)
    inductionOp _ p pv p*ol p+ol p0ol p1ol (0OL) =
      p0ol
    inductionOp _ p pv p*ol p+ol p0ol p1ol (1OL) =
      p1ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpBoundedLatticeTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpBoundedLatticeTerm2 n
          A)
       (x2 : OpBoundedLatticeTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpBoundedLatticeTerm2 n
          A)
       (x2 : OpBoundedLatticeTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      P 0OL2 ->
      P 1OL2 ->
      (x : OpBoundedLatticeTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (v2
                                                           x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (sing2
                                                           x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (*OL2
                                                           x1
                                                           x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           p1ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           p1ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (+OL2
                                                           x1
                                                           x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           p1ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           p1ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (1OL2) =
      p1ol2
    *L' :
      BoundedLatticeTerm ->
      BoundedLatticeTerm ->
      BoundedLatticeTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      BoundedLatticeTerm ->
      BoundedLatticeTerm ->
      BoundedLatticeTerm
    +L' x1 x2 = +L x1 x2
    0L' : BoundedLatticeTerm
    0L' = 0L
    1L' : BoundedLatticeTerm
    1L' = 1L
    stageB :
      BoundedLatticeTerm ->
      Staged BoundedLatticeTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (0L) = Now 0L
    stageB (1L) = Now 1L
    *Cl' :
      (A : Set) ->
      ClBoundedLatticeTerm A ->
      ClBoundedLatticeTerm A ->
      ClBoundedLatticeTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClBoundedLatticeTerm A ->
      ClBoundedLatticeTerm A ->
      ClBoundedLatticeTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    0Cl' :
      (A : Set) ->
      ClBoundedLatticeTerm A
    0Cl' _ = 0Cl
    1Cl' :
      (A : Set) ->
      ClBoundedLatticeTerm A
    1Cl' _ = 1Cl
    stageCl :
      (A : Set) ->
      ClBoundedLatticeTerm A ->
      Staged (ClBoundedLatticeTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (1Cl) = Now 1Cl
    *OL' :
      (n : Nat) ->
      OpBoundedLatticeTerm n ->
      OpBoundedLatticeTerm n ->
      OpBoundedLatticeTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpBoundedLatticeTerm n ->
      OpBoundedLatticeTerm n ->
      OpBoundedLatticeTerm n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      OpBoundedLatticeTerm n
    0OL' _ = 0OL
    1OL' :
      (n : Nat) ->
      OpBoundedLatticeTerm n
    1OL' _ = 1OL
    stageOp :
      (n : Nat) ->
      OpBoundedLatticeTerm n ->
      Staged (OpBoundedLatticeTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (0OL) = Now 0OL
    stageOp _ (1OL) = Now 1OL
    *OL2' :
      (n : Nat) (A : Set) ->
      OpBoundedLatticeTerm2 n A ->
      OpBoundedLatticeTerm2 n A ->
      OpBoundedLatticeTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpBoundedLatticeTerm2 n A ->
      OpBoundedLatticeTerm2 n A ->
      OpBoundedLatticeTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    0OL2' :
      (n : Nat) (A : Set) ->
      OpBoundedLatticeTerm2 n A
    0OL2' _ _ = 0OL2
    1OL2' :
      (n : Nat) (A : Set) ->
      OpBoundedLatticeTerm2 n A
    1OL2' _ _ = 1OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpBoundedLatticeTerm2 n A ->
      Staged
        (OpBoundedLatticeTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (1OL2) = Now 1OL2
    record BoundedLatticeTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
        0T : Repr A
        1T : Repr A
  
  module BoundedMeetLattice where
    record BoundedMeetLattice
      (A : Set) : Set where
      constructor BoundedMeetLatticeC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
    record BoundedMeetLatticeSig
      (AS : Set) : Set where
      constructor BoundedMeetLatticeSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
        +S : AS -> AS -> AS
    record BoundedMeetLatticeProd
      (AP : Set) : Set where
      constructor BoundedMeetLatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
    record BoundedMeetLatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedMeetLattice A1)
      (Bo2 : BoundedMeetLattice A2) :
      Set where
      constructor BoundedMeetLatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
        pres-1 : hom (1 Bo1) == 1 Bo2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
    record BoundedMeetLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedMeetLattice A1)
      (Bo2 : BoundedMeetLattice A2) :
      Set where
      constructor BoundedMeetLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
        interp-1 :
          interp (1 Bo1) (1 Bo2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
    data BoundedMeetLatticeTerm
      : Set where
      *L :
        BoundedMeetLatticeTerm ->
        BoundedMeetLatticeTerm ->
        BoundedMeetLatticeTerm
      1L : BoundedMeetLatticeTerm
      +L :
        BoundedMeetLatticeTerm ->
        BoundedMeetLatticeTerm ->
        BoundedMeetLatticeTerm
    data ClBoundedMeetLatticeTerm
      (A : Set) : Set where
      sing :
        A -> ClBoundedMeetLatticeTerm A
      *Cl :
        ClBoundedMeetLatticeTerm A ->
        ClBoundedMeetLatticeTerm A ->
        ClBoundedMeetLatticeTerm A
      1Cl : ClBoundedMeetLatticeTerm A
      +Cl :
        ClBoundedMeetLatticeTerm A ->
        ClBoundedMeetLatticeTerm A ->
        ClBoundedMeetLatticeTerm A
    data OpBoundedMeetLatticeTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpBoundedMeetLatticeTerm n
      *OL :
        OpBoundedMeetLatticeTerm n ->
        OpBoundedMeetLatticeTerm n ->
        OpBoundedMeetLatticeTerm n
      1OL : OpBoundedMeetLatticeTerm n
      +OL :
        OpBoundedMeetLatticeTerm n ->
        OpBoundedMeetLatticeTerm n ->
        OpBoundedMeetLatticeTerm n
    data OpBoundedMeetLatticeTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpBoundedMeetLatticeTerm2 n A
      sing2 :
        A ->
        OpBoundedMeetLatticeTerm2 n A
      *OL2 :
        OpBoundedMeetLatticeTerm2 n A ->
        OpBoundedMeetLatticeTerm2 n A ->
        OpBoundedMeetLatticeTerm2 n A
      1OL2 :
        OpBoundedMeetLatticeTerm2 n A
      +OL2 :
        OpBoundedMeetLatticeTerm2 n A ->
        OpBoundedMeetLatticeTerm2 n A ->
        OpBoundedMeetLatticeTerm2 n A
    simplifyB :
      BoundedMeetLatticeTerm ->
      BoundedMeetLatticeTerm
    simplifyB (*L x x) = x
    simplifyB (*L (1L) x) = x
    simplifyB (*L x (1L)) = x
    simplifyB (+L x x) = x
    simplifyB (*L x (+L x y)) = x
    simplifyB (+L x (*L x y)) = x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (1L) = 1L
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClBoundedMeetLatticeTerm A ->
      ClBoundedMeetLatticeTerm A
    simplifyCl _ (*Cl x x) = x
    simplifyCl _ (*Cl (1Cl) x) = x
    simplifyCl _ (*Cl x (1Cl)) = x
    simplifyCl _ (+Cl x x) = x
    simplifyCl _ (*Cl x (+Cl x y)) =
      x
    simplifyCl _ (+Cl x (*Cl x y)) =
      x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpBoundedMeetLatticeTerm n ->
      OpBoundedMeetLatticeTerm n
    simplifyOp _ (*OL x x) = x
    simplifyOp _ (*OL (1OL) x) = x
    simplifyOp _ (*OL x (1OL)) = x
    simplifyOp _ (+OL x x) = x
    simplifyOp _ (*OL x (+OL x y)) =
      x
    simplifyOp _ (+OL x (*OL x y)) =
      x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpBoundedMeetLatticeTerm2 n A ->
      OpBoundedMeetLatticeTerm2 n A
    simplifyOpE _ _ (*OL2 x x) = x
    simplifyOpE _ _ (*OL2
                     (1OL2)
                     x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (1OL2)) = x
    simplifyOpE _ _ (+OL2 x x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (+OL2 x y)) = x
    simplifyOpE _ _ (+OL2
                     x
                     (*OL2 x y)) = x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      BoundedMeetLattice A ->
      BoundedMeetLatticeTerm -> A
    evalB _ Bo (*L x1 x2) =
      * Bo (evalB _ Bo x1)
        (evalB _ Bo x2)
    evalB _ Bo (1L) = 1 Bo
    evalB _ Bo (+L x1 x2) =
      + Bo (evalB _ Bo x1)
        (evalB _ Bo x2)
    evalCl :
      (A : Set) ->
      BoundedMeetLattice A ->
      ClBoundedMeetLatticeTerm A -> A
    evalCl _ Bo (sing x1) = x1
    evalCl _ Bo (*Cl x1 x2) =
      * Bo (evalCl _ Bo x1)
        (evalCl _ Bo x2)
    evalCl _ Bo (1Cl) = 1 Bo
    evalCl _ Bo (+Cl x1 x2) =
      + Bo (evalCl _ Bo x1)
        (evalCl _ Bo x2)
    evalOp :
      (A : Set) (n : Nat) ->
      BoundedMeetLattice A ->
      Vec A n ->
      OpBoundedMeetLatticeTerm n -> A
    evalOp _ n Bo vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Bo vars (*OL x1 x2) =
      * Bo (evalOp _ n Bo vars x1)
        (evalOp _ n Bo vars x2)
    evalOp _ n Bo vars (1OL) = 1 Bo
    evalOp _ n Bo vars (+OL x1 x2) =
      + Bo (evalOp _ n Bo vars x1)
        (evalOp _ n Bo vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      BoundedMeetLattice A ->
      Vec A n ->
      OpBoundedMeetLatticeTerm2 n A ->
      A
    evalOpE _ n Bo vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Bo vars (sing2 x1) =
      x1
    evalOpE _ n Bo vars (*OL2
                         x1
                         x2) =
      * Bo (evalOpE _ n Bo vars x1)
        (evalOpE _ n Bo vars x2)
    evalOpE _ n Bo vars (1OL2) =
      1 Bo
    evalOpE _ n Bo vars (+OL2
                         x1
                         x2) =
      + Bo (evalOpE _ n Bo vars x1)
        (evalOpE _ n Bo vars x2)
    inductionB :
      (P : BoundedMeetLatticeTerm ->
           Set) ->
      ((x1 : BoundedMeetLatticeTerm)
       (x2 : BoundedMeetLatticeTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      P 1L ->
      ((x1 : BoundedMeetLatticeTerm)
       (x2 : BoundedMeetLatticeTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : BoundedMeetLatticeTerm) ->
      P x
    inductionB p p*l p1l p+l (*L
                              x1
                              x2) =
      p*l _ _
        (inductionB p p*l p1l p+l x1)
        (inductionB p p*l p1l p+l x2)
    inductionB p p*l p1l p+l (1L) =
      p1l
    inductionB p p*l p1l p+l (+L
                              x1
                              x2) =
      p+l _ _
        (inductionB p p*l p1l p+l x1)
        (inductionB p p*l p1l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClBoundedMeetLatticeTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClBoundedMeetLatticeTerm
          A)
       (x2 : ClBoundedMeetLatticeTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      P 1Cl ->
      ((x1 : ClBoundedMeetLatticeTerm
          A)
       (x2 : ClBoundedMeetLatticeTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClBoundedMeetLatticeTerm
         A) -> P x
    inductionCl _ p psing p*cl p1cl p+cl (sing
                                          x1) = psing x1
    inductionCl _ p psing p*cl p1cl p+cl (*Cl
                                          x1
                                          x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p1cl
           p+cl
           x1)
        (inductionCl _ p psing p*cl p1cl
           p+cl
           x2)
    inductionCl _ p psing p*cl p1cl p+cl (1Cl) =
      p1cl
    inductionCl _ p psing p*cl p1cl p+cl (+Cl
                                          x1
                                          x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p1cl
           p+cl
           x1)
        (inductionCl _ p psing p*cl p1cl
           p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpBoundedMeetLatticeTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpBoundedMeetLatticeTerm
          n)
       (x2 : OpBoundedMeetLatticeTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      P 1OL ->
      ((x1 : OpBoundedMeetLatticeTerm
          n)
       (x2 : OpBoundedMeetLatticeTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpBoundedMeetLatticeTerm
         n) -> P x
    inductionOp _ p pv p*ol p1ol p+ol (v
                                       x1) = pv x1
    inductionOp _ p pv p*ol p1ol p+ol (*OL
                                       x1
                                       x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p1ol
           p+ol
           x1)
        (inductionOp _ p pv p*ol p1ol
           p+ol
           x2)
    inductionOp _ p pv p*ol p1ol p+ol (1OL) =
      p1ol
    inductionOp _ p pv p*ol p1ol p+ol (+OL
                                       x1
                                       x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p1ol
           p+ol
           x1)
        (inductionOp _ p pv p*ol p1ol
           p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpBoundedMeetLatticeTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpBoundedMeetLatticeTerm2
          n
          A)
       (x2 : OpBoundedMeetLatticeTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      P 1OL2 ->
      ((x1 : OpBoundedMeetLatticeTerm2
          n
          A)
       (x2 : OpBoundedMeetLatticeTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpBoundedMeetLatticeTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 (v2
                                                     x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 (sing2
                                                     x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 (*OL2
                                                     x1
                                                     x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 (1OL2) =
      p1ol2
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 (+OL2
                                                     x1
                                                     x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           p+ol2
           x2)
    *L' :
      BoundedMeetLatticeTerm ->
      BoundedMeetLatticeTerm ->
      BoundedMeetLatticeTerm
    *L' x1 x2 = *L x1 x2
    1L' : BoundedMeetLatticeTerm
    1L' = 1L
    +L' :
      BoundedMeetLatticeTerm ->
      BoundedMeetLatticeTerm ->
      BoundedMeetLatticeTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      BoundedMeetLatticeTerm ->
      Staged BoundedMeetLatticeTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (1L) = Now 1L
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClBoundedMeetLatticeTerm A ->
      ClBoundedMeetLatticeTerm A ->
      ClBoundedMeetLatticeTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    1Cl' :
      (A : Set) ->
      ClBoundedMeetLatticeTerm A
    1Cl' _ = 1Cl
    +Cl' :
      (A : Set) ->
      ClBoundedMeetLatticeTerm A ->
      ClBoundedMeetLatticeTerm A ->
      ClBoundedMeetLatticeTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClBoundedMeetLatticeTerm A ->
      Staged
        (ClBoundedMeetLatticeTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (1Cl) = Now 1Cl
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpBoundedMeetLatticeTerm n ->
      OpBoundedMeetLatticeTerm n ->
      OpBoundedMeetLatticeTerm n
    *OL' _ x1 x2 = *OL x1 x2
    1OL' :
      (n : Nat) ->
      OpBoundedMeetLatticeTerm n
    1OL' _ = 1OL
    +OL' :
      (n : Nat) ->
      OpBoundedMeetLatticeTerm n ->
      OpBoundedMeetLatticeTerm n ->
      OpBoundedMeetLatticeTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpBoundedMeetLatticeTerm n ->
      Staged
        (OpBoundedMeetLatticeTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (1OL) = Now 1OL
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpBoundedMeetLatticeTerm2 n A ->
      OpBoundedMeetLatticeTerm2 n A ->
      OpBoundedMeetLatticeTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    1OL2' :
      (n : Nat) (A : Set) ->
      OpBoundedMeetLatticeTerm2 n A
    1OL2' _ _ = 1OL2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpBoundedMeetLatticeTerm2 n A ->
      OpBoundedMeetLatticeTerm2 n A ->
      OpBoundedMeetLatticeTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpBoundedMeetLatticeTerm2 n A ->
      Staged
        (OpBoundedMeetLatticeTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (1OL2) = Now 1OL2
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record BoundedMeetLatticeTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        1T : Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module BoundedMeetSemilattice where
    record BoundedMeetSemilattice
      (A : Set) : Set where
      constructor BoundedMeetSemilatticeC
      field
        * : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        idempotent_* :
          (x : A) -> * x x == x
    record BoundedMeetSemilatticeSig
      (AS : Set) : Set where
      constructor BoundedMeetSemilatticeSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
    record BoundedMeetSemilatticeProd
      (AP : Set) : Set where
      constructor BoundedMeetSemilatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
    record BoundedMeetSemilatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedMeetSemilattice
         A1)
      (Bo2 : BoundedMeetSemilattice
         A2) : Set where
      constructor BoundedMeetSemilatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
        pres-1 : hom (1 Bo1) == 1 Bo2
    record BoundedMeetSemilatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedMeetSemilattice
         A1)
      (Bo2 : BoundedMeetSemilattice
         A2) : Set where
      constructor BoundedMeetSemilatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
        interp-1 :
          interp (1 Bo1) (1 Bo2)
    data BoundedMeetSemilatticeTerm
      : Set where
      *L :
        BoundedMeetSemilatticeTerm ->
        BoundedMeetSemilatticeTerm ->
        BoundedMeetSemilatticeTerm
      1L : BoundedMeetSemilatticeTerm
    data ClBoundedMeetSemilatticeTerm
      (A : Set) : Set where
      sing :
        A ->
        ClBoundedMeetSemilatticeTerm A
      *Cl :
        ClBoundedMeetSemilatticeTerm
          A ->
        ClBoundedMeetSemilatticeTerm
          A ->
        ClBoundedMeetSemilatticeTerm A
      1Cl :
        ClBoundedMeetSemilatticeTerm A
    data OpBoundedMeetSemilatticeTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpBoundedMeetSemilatticeTerm n
      *OL :
        OpBoundedMeetSemilatticeTerm
          n ->
        OpBoundedMeetSemilatticeTerm
          n ->
        OpBoundedMeetSemilatticeTerm n
      1OL :
        OpBoundedMeetSemilatticeTerm n
    data OpBoundedMeetSemilatticeTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpBoundedMeetSemilatticeTerm2 n
          A
      sing2 :
        A ->
        OpBoundedMeetSemilatticeTerm2 n
          A
      *OL2 :
        OpBoundedMeetSemilatticeTerm2 n
          A ->
        OpBoundedMeetSemilatticeTerm2 n
          A ->
        OpBoundedMeetSemilatticeTerm2 n
          A
      1OL2 :
        OpBoundedMeetSemilatticeTerm2 n
          A
    simplifyB :
      BoundedMeetSemilatticeTerm ->
      BoundedMeetSemilatticeTerm
    simplifyB (*L (1L) x) = x
    simplifyB (*L x (1L)) = x
    simplifyB (*L x x) = x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (1L) = 1L
    simplifyCl :
      (A : Set) ->
      ClBoundedMeetSemilatticeTerm
        A ->
      ClBoundedMeetSemilatticeTerm A
    simplifyCl _ (*Cl (1Cl) x) = x
    simplifyCl _ (*Cl x (1Cl)) = x
    simplifyCl _ (*Cl x x) = x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpBoundedMeetSemilatticeTerm
        n ->
      OpBoundedMeetSemilatticeTerm n
    simplifyOp _ (*OL (1OL) x) = x
    simplifyOp _ (*OL x (1OL)) = x
    simplifyOp _ (*OL x x) = x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpBoundedMeetSemilatticeTerm2 n
        A ->
      OpBoundedMeetSemilatticeTerm2 n
        A
    simplifyOpE _ _ (*OL2
                     (1OL2)
                     x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (1OL2)) = x
    simplifyOpE _ _ (*OL2 x x) = x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      BoundedMeetSemilattice A ->
      BoundedMeetSemilatticeTerm -> A
    evalB _ Bo (*L x1 x2) =
      * Bo (evalB _ Bo x1)
        (evalB _ Bo x2)
    evalB _ Bo (1L) = 1 Bo
    evalCl :
      (A : Set) ->
      BoundedMeetSemilattice A ->
      ClBoundedMeetSemilatticeTerm
        A -> A
    evalCl _ Bo (sing x1) = x1
    evalCl _ Bo (*Cl x1 x2) =
      * Bo (evalCl _ Bo x1)
        (evalCl _ Bo x2)
    evalCl _ Bo (1Cl) = 1 Bo
    evalOp :
      (A : Set) (n : Nat) ->
      BoundedMeetSemilattice A ->
      Vec A n ->
      OpBoundedMeetSemilatticeTerm
        n -> A
    evalOp _ n Bo vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Bo vars (*OL x1 x2) =
      * Bo (evalOp _ n Bo vars x1)
        (evalOp _ n Bo vars x2)
    evalOp _ n Bo vars (1OL) = 1 Bo
    evalOpE :
      (A : Set) (n : Nat) ->
      BoundedMeetSemilattice A ->
      Vec A n ->
      OpBoundedMeetSemilatticeTerm2 n
        A -> A
    evalOpE _ n Bo vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Bo vars (sing2 x1) =
      x1
    evalOpE _ n Bo vars (*OL2
                         x1
                         x2) =
      * Bo (evalOpE _ n Bo vars x1)
        (evalOpE _ n Bo vars x2)
    evalOpE _ n Bo vars (1OL2) =
      1 Bo
    inductionB :
      (P : BoundedMeetSemilatticeTerm ->
           Set) ->
      ((x1 : BoundedMeetSemilatticeTerm)
       (x2 : BoundedMeetSemilatticeTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      P 1L ->
      (x : BoundedMeetSemilatticeTerm) ->
      P x
    inductionB p p*l p1l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p*l p1l x1)
        (inductionB p p*l p1l x2)
    inductionB p p*l p1l (1L) = p1l
    inductionCl :
      (A : Set)
      (P : ClBoundedMeetSemilatticeTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClBoundedMeetSemilatticeTerm
          A)
       (x2 : ClBoundedMeetSemilatticeTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      P 1Cl ->
      (x : ClBoundedMeetSemilatticeTerm
         A) -> P x
    inductionCl _ p psing p*cl p1cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p*cl p1cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p1cl
           x1)
        (inductionCl _ p psing p*cl p1cl
           x2)
    inductionCl _ p psing p*cl p1cl (1Cl) =
      p1cl
    inductionOp :
      (n : Nat)
      (P : OpBoundedMeetSemilatticeTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpBoundedMeetSemilatticeTerm
          n)
       (x2 : OpBoundedMeetSemilatticeTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      P 1OL ->
      (x : OpBoundedMeetSemilatticeTerm
         n) -> P x
    inductionOp _ p pv p*ol p1ol (v
                                  x1) = pv x1
    inductionOp _ p pv p*ol p1ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p1ol
           x1)
        (inductionOp _ p pv p*ol p1ol
           x2)
    inductionOp _ p pv p*ol p1ol (1OL) =
      p1ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpBoundedMeetSemilatticeTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpBoundedMeetSemilatticeTerm2
          n
          A)
       (x2 : OpBoundedMeetSemilatticeTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      P 1OL2 ->
      (x : OpBoundedMeetSemilatticeTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 (1OL2) =
      p1ol2
    *L' :
      BoundedMeetSemilatticeTerm ->
      BoundedMeetSemilatticeTerm ->
      BoundedMeetSemilatticeTerm
    *L' x1 x2 = *L x1 x2
    1L' : BoundedMeetSemilatticeTerm
    1L' = 1L
    stageB :
      BoundedMeetSemilatticeTerm ->
      Staged
        BoundedMeetSemilatticeTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (1L) = Now 1L
    *Cl' :
      (A : Set) ->
      ClBoundedMeetSemilatticeTerm
        A ->
      ClBoundedMeetSemilatticeTerm
        A ->
      ClBoundedMeetSemilatticeTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    1Cl' :
      (A : Set) ->
      ClBoundedMeetSemilatticeTerm A
    1Cl' _ = 1Cl
    stageCl :
      (A : Set) ->
      ClBoundedMeetSemilatticeTerm
        A ->
      Staged
        (ClBoundedMeetSemilatticeTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (1Cl) = Now 1Cl
    *OL' :
      (n : Nat) ->
      OpBoundedMeetSemilatticeTerm
        n ->
      OpBoundedMeetSemilatticeTerm
        n ->
      OpBoundedMeetSemilatticeTerm n
    *OL' _ x1 x2 = *OL x1 x2
    1OL' :
      (n : Nat) ->
      OpBoundedMeetSemilatticeTerm n
    1OL' _ = 1OL
    stageOp :
      (n : Nat) ->
      OpBoundedMeetSemilatticeTerm
        n ->
      Staged
        (OpBoundedMeetSemilatticeTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (1OL) = Now 1OL
    *OL2' :
      (n : Nat) (A : Set) ->
      OpBoundedMeetSemilatticeTerm2 n
        A ->
      OpBoundedMeetSemilatticeTerm2 n
        A ->
      OpBoundedMeetSemilatticeTerm2 n
        A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    1OL2' :
      (n : Nat) (A : Set) ->
      OpBoundedMeetSemilatticeTerm2 n
        A
    1OL2' _ _ = 1OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpBoundedMeetSemilatticeTerm2 n
        A ->
      Staged
        (OpBoundedMeetSemilatticeTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (1OL2) = Now 1OL2
    record BoundedMeetSemilatticeTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        1T : Repr A
  
  module BoundedModularLattice where
    record BoundedModularLattice
      (A : Set) : Set where
      constructor BoundedModularLatticeC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        leftModular_*_+ :
          (x : A) (y : A) (z : A) ->
          + (* x y) (* x z) ==
            * x (+ y (* x z))
    record BoundedModularLatticeSig
      (AS : Set) : Set where
      constructor BoundedModularLatticeSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        1S : AS
    record BoundedModularLatticeProd
      (AP : Set) : Set where
      constructor BoundedModularLatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        1P : Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        leftModular_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (*P xP yP) (*P xP zP) ==
            *P xP (+P yP (*P xP zP))
    record BoundedModularLatticeHom
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedModularLattice A1)
      (Bo2 : BoundedModularLattice
         A2) : Set where
      constructor BoundedModularLatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Bo1 x1 x2) ==
            * Bo2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Bo1 x1 x2) ==
            + Bo2 (hom x1) (hom x2)
        pres-0 : hom (0 Bo1) == 0 Bo2
        pres-1 : hom (1 Bo1) == 1 Bo2
    record BoundedModularLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Bo1 : BoundedModularLattice A1)
      (Bo2 : BoundedModularLattice
         A2) : Set where
      constructor BoundedModularLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Bo1 x1 x2)
            (* Bo2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Bo1 x1 x2)
            (+ Bo2 y1 y2)
        interp-0 :
          interp (0 Bo1) (0 Bo2)
        interp-1 :
          interp (1 Bo1) (1 Bo2)
    data BoundedModularLatticeTerm
      : Set where
      *L :
        BoundedModularLatticeTerm ->
        BoundedModularLatticeTerm ->
        BoundedModularLatticeTerm
      +L :
        BoundedModularLatticeTerm ->
        BoundedModularLatticeTerm ->
        BoundedModularLatticeTerm
      0L : BoundedModularLatticeTerm
      1L : BoundedModularLatticeTerm
    data ClBoundedModularLatticeTerm
      (A : Set) : Set where
      sing :
        A ->
        ClBoundedModularLatticeTerm A
      *Cl :
        ClBoundedModularLatticeTerm A ->
        ClBoundedModularLatticeTerm A ->
        ClBoundedModularLatticeTerm A
      +Cl :
        ClBoundedModularLatticeTerm A ->
        ClBoundedModularLatticeTerm A ->
        ClBoundedModularLatticeTerm A
      0Cl :
        ClBoundedModularLatticeTerm A
      1Cl :
        ClBoundedModularLatticeTerm A
    data OpBoundedModularLatticeTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpBoundedModularLatticeTerm n
      *OL :
        OpBoundedModularLatticeTerm n ->
        OpBoundedModularLatticeTerm n ->
        OpBoundedModularLatticeTerm n
      +OL :
        OpBoundedModularLatticeTerm n ->
        OpBoundedModularLatticeTerm n ->
        OpBoundedModularLatticeTerm n
      0OL :
        OpBoundedModularLatticeTerm n
      1OL :
        OpBoundedModularLatticeTerm n
    data OpBoundedModularLatticeTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpBoundedModularLatticeTerm2 n A
      sing2 :
        A ->
        OpBoundedModularLatticeTerm2 n A
      *OL2 :
        OpBoundedModularLatticeTerm2 n
          A ->
        OpBoundedModularLatticeTerm2 n
          A ->
        OpBoundedModularLatticeTerm2 n A
      +OL2 :
        OpBoundedModularLatticeTerm2 n
          A ->
        OpBoundedModularLatticeTerm2 n
          A ->
        OpBoundedModularLatticeTerm2 n A
      0OL2 :
        OpBoundedModularLatticeTerm2 n A
      1OL2 :
        OpBoundedModularLatticeTerm2 n A
    simplifyB :
      BoundedModularLatticeTerm ->
      BoundedModularLatticeTerm
    simplifyB (*L x x) = x
    simplifyB (+L x x) = x
    simplifyB (*L x (+L x y)) = x
    simplifyB (+L x (*L x y)) = x
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (*L (1L) x) = x
    simplifyB (*L x (1L)) = x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (0L) = 0L
    simplifyB (1L) = 1L
    simplifyCl :
      (A : Set) ->
      ClBoundedModularLatticeTerm A ->
      ClBoundedModularLatticeTerm A
    simplifyCl _ (*Cl x x) = x
    simplifyCl _ (+Cl x x) = x
    simplifyCl _ (*Cl x (+Cl x y)) =
      x
    simplifyCl _ (+Cl x (*Cl x y)) =
      x
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (*Cl (1Cl) x) = x
    simplifyCl _ (*Cl x (1Cl)) = x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpBoundedModularLatticeTerm n ->
      OpBoundedModularLatticeTerm n
    simplifyOp _ (*OL x x) = x
    simplifyOp _ (+OL x x) = x
    simplifyOp _ (*OL x (+OL x y)) =
      x
    simplifyOp _ (+OL x (*OL x y)) =
      x
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (*OL (1OL) x) = x
    simplifyOp _ (*OL x (1OL)) = x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpBoundedModularLatticeTerm2 n
        A ->
      OpBoundedModularLatticeTerm2 n A
    simplifyOpE _ _ (*OL2 x x) = x
    simplifyOpE _ _ (+OL2 x x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (+OL2 x y)) = x
    simplifyOpE _ _ (+OL2
                     x
                     (*OL2 x y)) = x
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (*OL2
                     (1OL2)
                     x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (1OL2)) = x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      BoundedModularLattice A ->
      BoundedModularLatticeTerm -> A
    evalB _ Bo (*L x1 x2) =
      * Bo (evalB _ Bo x1)
        (evalB _ Bo x2)
    evalB _ Bo (+L x1 x2) =
      + Bo (evalB _ Bo x1)
        (evalB _ Bo x2)
    evalB _ Bo (0L) = 0 Bo
    evalB _ Bo (1L) = 1 Bo
    evalCl :
      (A : Set) ->
      BoundedModularLattice A ->
      ClBoundedModularLatticeTerm A ->
      A
    evalCl _ Bo (sing x1) = x1
    evalCl _ Bo (*Cl x1 x2) =
      * Bo (evalCl _ Bo x1)
        (evalCl _ Bo x2)
    evalCl _ Bo (+Cl x1 x2) =
      + Bo (evalCl _ Bo x1)
        (evalCl _ Bo x2)
    evalCl _ Bo (0Cl) = 0 Bo
    evalCl _ Bo (1Cl) = 1 Bo
    evalOp :
      (A : Set) (n : Nat) ->
      BoundedModularLattice A ->
      Vec A n ->
      OpBoundedModularLatticeTerm n ->
      A
    evalOp _ n Bo vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Bo vars (*OL x1 x2) =
      * Bo (evalOp _ n Bo vars x1)
        (evalOp _ n Bo vars x2)
    evalOp _ n Bo vars (+OL x1 x2) =
      + Bo (evalOp _ n Bo vars x1)
        (evalOp _ n Bo vars x2)
    evalOp _ n Bo vars (0OL) = 0 Bo
    evalOp _ n Bo vars (1OL) = 1 Bo
    evalOpE :
      (A : Set) (n : Nat) ->
      BoundedModularLattice A ->
      Vec A n ->
      OpBoundedModularLatticeTerm2 n
        A -> A
    evalOpE _ n Bo vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Bo vars (sing2 x1) =
      x1
    evalOpE _ n Bo vars (*OL2
                         x1
                         x2) =
      * Bo (evalOpE _ n Bo vars x1)
        (evalOpE _ n Bo vars x2)
    evalOpE _ n Bo vars (+OL2
                         x1
                         x2) =
      + Bo (evalOpE _ n Bo vars x1)
        (evalOpE _ n Bo vars x2)
    evalOpE _ n Bo vars (0OL2) =
      0 Bo
    evalOpE _ n Bo vars (1OL2) =
      1 Bo
    inductionB :
      (P : BoundedModularLatticeTerm ->
           Set) ->
      ((x1 : BoundedModularLatticeTerm)
       (x2 : BoundedModularLatticeTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : BoundedModularLatticeTerm)
       (x2 : BoundedModularLatticeTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      P 0L ->
      P 1L ->
      (x : BoundedModularLatticeTerm) ->
      P x
    inductionB p p*l p+l p0l p1l (*L
                                  x1
                                  x2) =
      p*l _ _
        (inductionB p p*l p+l p0l p1l
           x1)
        (inductionB p p*l p+l p0l p1l
           x2)
    inductionB p p*l p+l p0l p1l (+L
                                  x1
                                  x2) =
      p+l _ _
        (inductionB p p*l p+l p0l p1l
           x1)
        (inductionB p p*l p+l p0l p1l
           x2)
    inductionB p p*l p+l p0l p1l (0L) =
      p0l
    inductionB p p*l p+l p0l p1l (1L) =
      p1l
    inductionCl :
      (A : Set)
      (P : ClBoundedModularLatticeTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClBoundedModularLatticeTerm
          A)
       (x2 : ClBoundedModularLatticeTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClBoundedModularLatticeTerm
          A)
       (x2 : ClBoundedModularLatticeTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      P 0Cl ->
      P 1Cl ->
      (x : ClBoundedModularLatticeTerm
         A) -> P x
    inductionCl _ p psing p*cl p+cl p0cl p1cl (sing
                                               x1) = psing x1
    inductionCl _ p psing p*cl p+cl p0cl p1cl (*Cl
                                               x1
                                               x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           p0cl
           p1cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           p0cl
           p1cl
           x2)
    inductionCl _ p psing p*cl p+cl p0cl p1cl (+Cl
                                               x1
                                               x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           p0cl
           p1cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           p0cl
           p1cl
           x2)
    inductionCl _ p psing p*cl p+cl p0cl p1cl (0Cl) =
      p0cl
    inductionCl _ p psing p*cl p+cl p0cl p1cl (1Cl) =
      p1cl
    inductionOp :
      (n : Nat)
      (P : OpBoundedModularLatticeTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpBoundedModularLatticeTerm
          n)
       (x2 : OpBoundedModularLatticeTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpBoundedModularLatticeTerm
          n)
       (x2 : OpBoundedModularLatticeTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      P 0OL ->
      P 1OL ->
      (x : OpBoundedModularLatticeTerm
         n) -> P x
    inductionOp _ p pv p*ol p+ol p0ol p1ol (v
                                            x1) = pv x1
    inductionOp _ p pv p*ol p+ol p0ol p1ol (*OL
                                            x1
                                            x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           p0ol
           p1ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           p0ol
           p1ol
           x2)
    inductionOp _ p pv p*ol p+ol p0ol p1ol (+OL
                                            x1
                                            x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           p0ol
           p1ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           p0ol
           p1ol
           x2)
    inductionOp _ p pv p*ol p+ol p0ol p1ol (0OL) =
      p0ol
    inductionOp _ p pv p*ol p+ol p0ol p1ol (1OL) =
      p1ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpBoundedModularLatticeTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpBoundedModularLatticeTerm2
          n
          A)
       (x2 : OpBoundedModularLatticeTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpBoundedModularLatticeTerm2
          n
          A)
       (x2 : OpBoundedModularLatticeTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      P 0OL2 ->
      P 1OL2 ->
      (x : OpBoundedModularLatticeTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (v2
                                                           x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (sing2
                                                           x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (*OL2
                                                           x1
                                                           x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           p1ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           p1ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (+OL2
                                                           x1
                                                           x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           p1ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           p1ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (1OL2) =
      p1ol2
    *L' :
      BoundedModularLatticeTerm ->
      BoundedModularLatticeTerm ->
      BoundedModularLatticeTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      BoundedModularLatticeTerm ->
      BoundedModularLatticeTerm ->
      BoundedModularLatticeTerm
    +L' x1 x2 = +L x1 x2
    0L' : BoundedModularLatticeTerm
    0L' = 0L
    1L' : BoundedModularLatticeTerm
    1L' = 1L
    stageB :
      BoundedModularLatticeTerm ->
      Staged BoundedModularLatticeTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (0L) = Now 0L
    stageB (1L) = Now 1L
    *Cl' :
      (A : Set) ->
      ClBoundedModularLatticeTerm A ->
      ClBoundedModularLatticeTerm A ->
      ClBoundedModularLatticeTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClBoundedModularLatticeTerm A ->
      ClBoundedModularLatticeTerm A ->
      ClBoundedModularLatticeTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    0Cl' :
      (A : Set) ->
      ClBoundedModularLatticeTerm A
    0Cl' _ = 0Cl
    1Cl' :
      (A : Set) ->
      ClBoundedModularLatticeTerm A
    1Cl' _ = 1Cl
    stageCl :
      (A : Set) ->
      ClBoundedModularLatticeTerm A ->
      Staged
        (ClBoundedModularLatticeTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (1Cl) = Now 1Cl
    *OL' :
      (n : Nat) ->
      OpBoundedModularLatticeTerm n ->
      OpBoundedModularLatticeTerm n ->
      OpBoundedModularLatticeTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpBoundedModularLatticeTerm n ->
      OpBoundedModularLatticeTerm n ->
      OpBoundedModularLatticeTerm n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      OpBoundedModularLatticeTerm n
    0OL' _ = 0OL
    1OL' :
      (n : Nat) ->
      OpBoundedModularLatticeTerm n
    1OL' _ = 1OL
    stageOp :
      (n : Nat) ->
      OpBoundedModularLatticeTerm n ->
      Staged
        (OpBoundedModularLatticeTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (0OL) = Now 0OL
    stageOp _ (1OL) = Now 1OL
    *OL2' :
      (n : Nat) (A : Set) ->
      OpBoundedModularLatticeTerm2 n
        A ->
      OpBoundedModularLatticeTerm2 n
        A ->
      OpBoundedModularLatticeTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpBoundedModularLatticeTerm2 n
        A ->
      OpBoundedModularLatticeTerm2 n
        A ->
      OpBoundedModularLatticeTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    0OL2' :
      (n : Nat) (A : Set) ->
      OpBoundedModularLatticeTerm2 n A
    0OL2' _ _ = 0OL2
    1OL2' :
      (n : Nat) (A : Set) ->
      OpBoundedModularLatticeTerm2 n A
    1OL2' _ _ = 1OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpBoundedModularLatticeTerm2 n
        A ->
      Staged
        (OpBoundedModularLatticeTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (1OL2) = Now 1OL2
    record BoundedModularLatticeTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
        0T : Repr A
        1T : Repr A
  
  module CancellativeCommutativeMonoid where
    record CancellativeCommutativeMonoid
      (A : Set) : Set where
      constructor CancellativeCommutativeMonoidC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CancellativeCommutativeMonoidSig
      (AS : Set) : Set where
      constructor CancellativeCommutativeMonoidSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record CancellativeCommutativeMonoidProd
      (AP : Set) : Set where
      constructor CancellativeCommutativeMonoidProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CancellativeCommutativeMonoidHom
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeCommutativeMonoid
         A1)
      (Ca2 : CancellativeCommutativeMonoid
         A2) : Set where
      constructor CancellativeCommutativeMonoidHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Ca1) == e Ca2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ca1 x1 x2) ==
            op Ca2 (hom x1) (hom x2)
    record CancellativeCommutativeMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeCommutativeMonoid
         A1)
      (Ca2 : CancellativeCommutativeMonoid
         A2) : Set where
      constructor CancellativeCommutativeMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Ca1) (e Ca2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ca1 x1 x2)
            (op Ca2 y1 y2)
    data CancellativeCommutativeMonoidTerm
      : Set where
      eL :
        CancellativeCommutativeMonoidTerm
      opL :
        CancellativeCommutativeMonoidTerm ->
        CancellativeCommutativeMonoidTerm ->
        CancellativeCommutativeMonoidTerm
    data ClCancellativeCommutativeMonoidTerm
      (A : Set) : Set where
      sing :
        A ->
        ClCancellativeCommutativeMonoidTerm
          A
      eCl :
        ClCancellativeCommutativeMonoidTerm
          A
      opCl :
        ClCancellativeCommutativeMonoidTerm
          A ->
        ClCancellativeCommutativeMonoidTerm
          A ->
        ClCancellativeCommutativeMonoidTerm
          A
    data OpCancellativeCommutativeMonoidTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpCancellativeCommutativeMonoidTerm
          n
      eOL :
        OpCancellativeCommutativeMonoidTerm
          n
      opOL :
        OpCancellativeCommutativeMonoidTerm
          n ->
        OpCancellativeCommutativeMonoidTerm
          n ->
        OpCancellativeCommutativeMonoidTerm
          n
    data OpCancellativeCommutativeMonoidTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpCancellativeCommutativeMonoidTerm2
          n
          A
      sing2 :
        A ->
        OpCancellativeCommutativeMonoidTerm2
          n
          A
      eOL2 :
        OpCancellativeCommutativeMonoidTerm2
          n
          A
      opOL2 :
        OpCancellativeCommutativeMonoidTerm2
          n
          A ->
        OpCancellativeCommutativeMonoidTerm2
          n
          A ->
        OpCancellativeCommutativeMonoidTerm2
          n
          A
    simplifyB :
      CancellativeCommutativeMonoidTerm ->
      CancellativeCommutativeMonoidTerm
    simplifyB (opL (eL) x) = x
    simplifyB (opL x (eL)) = x
    simplifyB (eL) = eL
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClCancellativeCommutativeMonoidTerm
        A ->
      ClCancellativeCommutativeMonoidTerm
        A
    simplifyCl _ (opCl (eCl) x) = x
    simplifyCl _ (opCl x (eCl)) = x
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpCancellativeCommutativeMonoidTerm
        n ->
      OpCancellativeCommutativeMonoidTerm
        n
    simplifyOp _ (opOL (eOL) x) = x
    simplifyOp _ (opOL x (eOL)) = x
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpCancellativeCommutativeMonoidTerm2
        n
        A ->
      OpCancellativeCommutativeMonoidTerm2
        n
        A
    simplifyOpE _ _ (opOL2
                     (eOL2)
                     x) = x
    simplifyOpE _ _ (opOL2
                     x
                     (eOL2)) = x
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      CancellativeCommutativeMonoid
        A ->
      CancellativeCommutativeMonoidTerm ->
      A
    evalB _ Ca (eL) = e Ca
    evalB _ Ca (opL x1 x2) =
      op Ca (evalB _ Ca x1)
        (evalB _ Ca x2)
    evalCl :
      (A : Set) ->
      CancellativeCommutativeMonoid
        A ->
      ClCancellativeCommutativeMonoidTerm
        A -> A
    evalCl _ Ca (sing x1) = x1
    evalCl _ Ca (eCl) = e Ca
    evalCl _ Ca (opCl x1 x2) =
      op Ca (evalCl _ Ca x1)
        (evalCl _ Ca x2)
    evalOp :
      (A : Set) (n : Nat) ->
      CancellativeCommutativeMonoid
        A ->
      Vec A n ->
      OpCancellativeCommutativeMonoidTerm
        n -> A
    evalOp _ n Ca vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ca vars (eOL) = e Ca
    evalOp _ n Ca vars (opOL
                        x1
                        x2) =
      op Ca (evalOp _ n Ca vars x1)
        (evalOp _ n Ca vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      CancellativeCommutativeMonoid
        A ->
      Vec A n ->
      OpCancellativeCommutativeMonoidTerm2
        n
        A -> A
    evalOpE _ n Ca vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ca vars (sing2 x1) =
      x1
    evalOpE _ n Ca vars (eOL2) =
      e Ca
    evalOpE _ n Ca vars (opOL2
                         x1
                         x2) =
      op Ca (evalOpE _ n Ca vars x1)
        (evalOpE _ n Ca vars x2)
    inductionB :
      (P : CancellativeCommutativeMonoidTerm ->
           Set) ->
      P eL ->
      ((x1 : CancellativeCommutativeMonoidTerm)
       (x2 : CancellativeCommutativeMonoidTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : CancellativeCommutativeMonoidTerm) ->
      P x
    inductionB p pel popl (eL) = pel
    inductionB p pel popl (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p pel popl x1)
        (inductionB p pel popl x2)
    inductionCl :
      (A : Set)
      (P : ClCancellativeCommutativeMonoidTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P eCl ->
      ((x1 : ClCancellativeCommutativeMonoidTerm
          A)
       (x2 : ClCancellativeCommutativeMonoidTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClCancellativeCommutativeMonoidTerm
         A) -> P x
    inductionCl _ p psing pecl popcl (sing
                                      x1) = psing x1
    inductionCl _ p psing pecl popcl (eCl) =
      pecl
    inductionCl _ p psing pecl popcl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing pecl
           popcl
           x1)
        (inductionCl _ p psing pecl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpCancellativeCommutativeMonoidTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P eOL ->
      ((x1 : OpCancellativeCommutativeMonoidTerm
          n)
       (x2 : OpCancellativeCommutativeMonoidTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpCancellativeCommutativeMonoidTerm
         n) -> P x
    inductionOp _ p pv peol popol (v
                                   x1) = pv x1
    inductionOp _ p pv peol popol (eOL) =
      peol
    inductionOp _ p pv peol popol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv peol popol
           x1)
        (inductionOp _ p pv peol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpCancellativeCommutativeMonoidTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P eOL2 ->
      ((x1 : OpCancellativeCommutativeMonoidTerm2
          n
          A)
       (x2 : OpCancellativeCommutativeMonoidTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpCancellativeCommutativeMonoidTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x2)
    eL' :
      CancellativeCommutativeMonoidTerm
    eL' = eL
    opL' :
      CancellativeCommutativeMonoidTerm ->
      CancellativeCommutativeMonoidTerm ->
      CancellativeCommutativeMonoidTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      CancellativeCommutativeMonoidTerm ->
      Staged
        CancellativeCommutativeMonoidTerm
    stageB (eL) = Now eL
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    eCl' :
      (A : Set) ->
      ClCancellativeCommutativeMonoidTerm
        A
    eCl' _ = eCl
    opCl' :
      (A : Set) ->
      ClCancellativeCommutativeMonoidTerm
        A ->
      ClCancellativeCommutativeMonoidTerm
        A ->
      ClCancellativeCommutativeMonoidTerm
        A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClCancellativeCommutativeMonoidTerm
        A ->
      Staged
        (ClCancellativeCommutativeMonoidTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (eCl) = Now eCl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    eOL' :
      (n : Nat) ->
      OpCancellativeCommutativeMonoidTerm
        n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      OpCancellativeCommutativeMonoidTerm
        n ->
      OpCancellativeCommutativeMonoidTerm
        n ->
      OpCancellativeCommutativeMonoidTerm
        n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpCancellativeCommutativeMonoidTerm
        n ->
      Staged
        (OpCancellativeCommutativeMonoidTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (eOL) = Now eOL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    eOL2' :
      (n : Nat) (A : Set) ->
      OpCancellativeCommutativeMonoidTerm2
        n
        A
    eOL2' _ _ = eOL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpCancellativeCommutativeMonoidTerm2
        n
        A ->
      OpCancellativeCommutativeMonoidTerm2
        n
        A ->
      OpCancellativeCommutativeMonoidTerm2
        n
        A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpCancellativeCommutativeMonoidTerm2
        n
        A ->
      Staged
        (OpCancellativeCommutativeMonoidTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record CancellativeCommutativeMonoidTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        eT : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module CancellativeCommutativeSemigroup where
    record CancellativeCommutativeSemigroup
      (A : Set) : Set where
      constructor CancellativeCommutativeSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
    record CancellativeCommutativeSemigroupSig
      (AS : Set) : Set where
      constructor CancellativeCommutativeSemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record CancellativeCommutativeSemigroupProd
      (AP : Set) : Set where
      constructor CancellativeCommutativeSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
    record CancellativeCommutativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeCommutativeSemigroup
         A1)
      (Ca2 : CancellativeCommutativeSemigroup
         A2) : Set where
      constructor CancellativeCommutativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ca1 x1 x2) ==
            op Ca2 (hom x1) (hom x2)
    record CancellativeCommutativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeCommutativeSemigroup
         A1)
      (Ca2 : CancellativeCommutativeSemigroup
         A2) : Set where
      constructor CancellativeCommutativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ca1 x1 x2)
            (op Ca2 y1 y2)
    data CancellativeCommutativeSemigroupTerm
      : Set where
      opL :
        CancellativeCommutativeSemigroupTerm ->
        CancellativeCommutativeSemigroupTerm ->
        CancellativeCommutativeSemigroupTerm
    data ClCancellativeCommutativeSemigroupTerm
      (A : Set) : Set where
      sing :
        A ->
        ClCancellativeCommutativeSemigroupTerm
          A
      opCl :
        ClCancellativeCommutativeSemigroupTerm
          A ->
        ClCancellativeCommutativeSemigroupTerm
          A ->
        ClCancellativeCommutativeSemigroupTerm
          A
    data OpCancellativeCommutativeSemigroupTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpCancellativeCommutativeSemigroupTerm
          n
      opOL :
        OpCancellativeCommutativeSemigroupTerm
          n ->
        OpCancellativeCommutativeSemigroupTerm
          n ->
        OpCancellativeCommutativeSemigroupTerm
          n
    data OpCancellativeCommutativeSemigroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpCancellativeCommutativeSemigroupTerm2
          n
          A
      sing2 :
        A ->
        OpCancellativeCommutativeSemigroupTerm2
          n
          A
      opOL2 :
        OpCancellativeCommutativeSemigroupTerm2
          n
          A ->
        OpCancellativeCommutativeSemigroupTerm2
          n
          A ->
        OpCancellativeCommutativeSemigroupTerm2
          n
          A
    simplifyB :
      CancellativeCommutativeSemigroupTerm ->
      CancellativeCommutativeSemigroupTerm
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClCancellativeCommutativeSemigroupTerm
        A ->
      ClCancellativeCommutativeSemigroupTerm
        A
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpCancellativeCommutativeSemigroupTerm
        n ->
      OpCancellativeCommutativeSemigroupTerm
        n
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpCancellativeCommutativeSemigroupTerm2
        n
        A ->
      OpCancellativeCommutativeSemigroupTerm2
        n
        A
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      CancellativeCommutativeSemigroup
        A ->
      CancellativeCommutativeSemigroupTerm ->
      A
    evalB _ Ca (opL x1 x2) =
      op Ca (evalB _ Ca x1)
        (evalB _ Ca x2)
    evalCl :
      (A : Set) ->
      CancellativeCommutativeSemigroup
        A ->
      ClCancellativeCommutativeSemigroupTerm
        A -> A
    evalCl _ Ca (sing x1) = x1
    evalCl _ Ca (opCl x1 x2) =
      op Ca (evalCl _ Ca x1)
        (evalCl _ Ca x2)
    evalOp :
      (A : Set) (n : Nat) ->
      CancellativeCommutativeSemigroup
        A ->
      Vec A n ->
      OpCancellativeCommutativeSemigroupTerm
        n -> A
    evalOp _ n Ca vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ca vars (opOL
                        x1
                        x2) =
      op Ca (evalOp _ n Ca vars x1)
        (evalOp _ n Ca vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      CancellativeCommutativeSemigroup
        A ->
      Vec A n ->
      OpCancellativeCommutativeSemigroupTerm2
        n
        A -> A
    evalOpE _ n Ca vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ca vars (sing2 x1) =
      x1
    evalOpE _ n Ca vars (opOL2
                         x1
                         x2) =
      op Ca (evalOpE _ n Ca vars x1)
        (evalOpE _ n Ca vars x2)
    inductionB :
      (P : CancellativeCommutativeSemigroupTerm ->
           Set) ->
      ((x1 : CancellativeCommutativeSemigroupTerm)
       (x2 : CancellativeCommutativeSemigroupTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : CancellativeCommutativeSemigroupTerm) ->
      P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClCancellativeCommutativeSemigroupTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClCancellativeCommutativeSemigroupTerm
          A)
       (x2 : ClCancellativeCommutativeSemigroupTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClCancellativeCommutativeSemigroupTerm
         A) -> P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpCancellativeCommutativeSemigroupTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpCancellativeCommutativeSemigroupTerm
          n)
       (x2 : OpCancellativeCommutativeSemigroupTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpCancellativeCommutativeSemigroupTerm
         n) -> P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpCancellativeCommutativeSemigroupTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpCancellativeCommutativeSemigroupTerm2
          n
          A)
       (x2 : OpCancellativeCommutativeSemigroupTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpCancellativeCommutativeSemigroupTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      CancellativeCommutativeSemigroupTerm ->
      CancellativeCommutativeSemigroupTerm ->
      CancellativeCommutativeSemigroupTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      CancellativeCommutativeSemigroupTerm ->
      Staged
        CancellativeCommutativeSemigroupTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClCancellativeCommutativeSemigroupTerm
        A ->
      ClCancellativeCommutativeSemigroupTerm
        A ->
      ClCancellativeCommutativeSemigroupTerm
        A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClCancellativeCommutativeSemigroupTerm
        A ->
      Staged
        (ClCancellativeCommutativeSemigroupTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpCancellativeCommutativeSemigroupTerm
        n ->
      OpCancellativeCommutativeSemigroupTerm
        n ->
      OpCancellativeCommutativeSemigroupTerm
        n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpCancellativeCommutativeSemigroupTerm
        n ->
      Staged
        (OpCancellativeCommutativeSemigroupTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpCancellativeCommutativeSemigroupTerm2
        n
        A ->
      OpCancellativeCommutativeSemigroupTerm2
        n
        A ->
      OpCancellativeCommutativeSemigroupTerm2
        n
        A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpCancellativeCommutativeSemigroupTerm2
        n
        A ->
      Staged
        (OpCancellativeCommutativeSemigroupTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record CancellativeCommutativeSemigroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module CancellativeMagma where
    record CancellativeMagma
      (A : Set) : Set where
      constructor CancellativeMagmaC
      field
        op : A -> A -> A
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
    record CancellativeMagmaSig
      (AS : Set) : Set where
      constructor CancellativeMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record CancellativeMagmaProd
      (AP : Set) : Set where
      constructor CancellativeMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
    record CancellativeMagmaHom
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeMagma A1)
      (Ca2 : CancellativeMagma A2) :
      Set where
      constructor CancellativeMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ca1 x1 x2) ==
            op Ca2 (hom x1) (hom x2)
    record CancellativeMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeMagma A1)
      (Ca2 : CancellativeMagma A2) :
      Set where
      constructor CancellativeMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ca1 x1 x2)
            (op Ca2 y1 y2)
    data CancellativeMagmaTerm
      : Set where
      opL :
        CancellativeMagmaTerm ->
        CancellativeMagmaTerm ->
        CancellativeMagmaTerm
    data ClCancellativeMagmaTerm
      (A : Set) : Set where
      sing :
        A -> ClCancellativeMagmaTerm A
      opCl :
        ClCancellativeMagmaTerm A ->
        ClCancellativeMagmaTerm A ->
        ClCancellativeMagmaTerm A
    data OpCancellativeMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpCancellativeMagmaTerm n
      opOL :
        OpCancellativeMagmaTerm n ->
        OpCancellativeMagmaTerm n ->
        OpCancellativeMagmaTerm n
    data OpCancellativeMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpCancellativeMagmaTerm2 n A
      sing2 :
        A ->
        OpCancellativeMagmaTerm2 n A
      opOL2 :
        OpCancellativeMagmaTerm2 n A ->
        OpCancellativeMagmaTerm2 n A ->
        OpCancellativeMagmaTerm2 n A
    simplifyB :
      CancellativeMagmaTerm ->
      CancellativeMagmaTerm
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClCancellativeMagmaTerm A ->
      ClCancellativeMagmaTerm A
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpCancellativeMagmaTerm n ->
      OpCancellativeMagmaTerm n
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpCancellativeMagmaTerm2 n A ->
      OpCancellativeMagmaTerm2 n A
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      CancellativeMagma A ->
      CancellativeMagmaTerm -> A
    evalB _ Ca (opL x1 x2) =
      op Ca (evalB _ Ca x1)
        (evalB _ Ca x2)
    evalCl :
      (A : Set) ->
      CancellativeMagma A ->
      ClCancellativeMagmaTerm A -> A
    evalCl _ Ca (sing x1) = x1
    evalCl _ Ca (opCl x1 x2) =
      op Ca (evalCl _ Ca x1)
        (evalCl _ Ca x2)
    evalOp :
      (A : Set) (n : Nat) ->
      CancellativeMagma A ->
      Vec A n ->
      OpCancellativeMagmaTerm n -> A
    evalOp _ n Ca vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ca vars (opOL
                        x1
                        x2) =
      op Ca (evalOp _ n Ca vars x1)
        (evalOp _ n Ca vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      CancellativeMagma A ->
      Vec A n ->
      OpCancellativeMagmaTerm2 n A ->
      A
    evalOpE _ n Ca vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ca vars (sing2 x1) =
      x1
    evalOpE _ n Ca vars (opOL2
                         x1
                         x2) =
      op Ca (evalOpE _ n Ca vars x1)
        (evalOpE _ n Ca vars x2)
    inductionB :
      (P : CancellativeMagmaTerm ->
           Set) ->
      ((x1 : CancellativeMagmaTerm)
       (x2 : CancellativeMagmaTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : CancellativeMagmaTerm) ->
      P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClCancellativeMagmaTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClCancellativeMagmaTerm
          A)
       (x2 : ClCancellativeMagmaTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClCancellativeMagmaTerm
         A) -> P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpCancellativeMagmaTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpCancellativeMagmaTerm
          n)
       (x2 : OpCancellativeMagmaTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpCancellativeMagmaTerm
         n) -> P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpCancellativeMagmaTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpCancellativeMagmaTerm2
          n
          A)
       (x2 : OpCancellativeMagmaTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpCancellativeMagmaTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      CancellativeMagmaTerm ->
      CancellativeMagmaTerm ->
      CancellativeMagmaTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      CancellativeMagmaTerm ->
      Staged CancellativeMagmaTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClCancellativeMagmaTerm A ->
      ClCancellativeMagmaTerm A ->
      ClCancellativeMagmaTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClCancellativeMagmaTerm A ->
      Staged
        (ClCancellativeMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpCancellativeMagmaTerm n ->
      OpCancellativeMagmaTerm n ->
      OpCancellativeMagmaTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpCancellativeMagmaTerm n ->
      Staged
        (OpCancellativeMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpCancellativeMagmaTerm2 n A ->
      OpCancellativeMagmaTerm2 n A ->
      OpCancellativeMagmaTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpCancellativeMagmaTerm2 n A ->
      Staged
        (OpCancellativeMagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record CancellativeMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module CancellativeMonoid where
    record CancellativeMonoid
      (A : Set) : Set where
      constructor CancellativeMonoidC
      field
        op : A -> A -> A
        e : A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
    record CancellativeMonoidSig
      (AS : Set) : Set where
      constructor CancellativeMonoidSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record CancellativeMonoidProd
      (AP : Set) : Set where
      constructor CancellativeMonoidProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
    record CancellativeMonoidHom
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeMonoid A1)
      (Ca2 : CancellativeMonoid A2) :
      Set where
      constructor CancellativeMonoidHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ca1 x1 x2) ==
            op Ca2 (hom x1) (hom x2)
        pres-e : hom (e Ca1) == e Ca2
    record CancellativeMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeMonoid A1)
      (Ca2 : CancellativeMonoid A2) :
      Set where
      constructor CancellativeMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ca1 x1 x2)
            (op Ca2 y1 y2)
        interp-e :
          interp (e Ca1) (e Ca2)
    data CancellativeMonoidTerm
      : Set where
      opL :
        CancellativeMonoidTerm ->
        CancellativeMonoidTerm ->
        CancellativeMonoidTerm
      eL : CancellativeMonoidTerm
    data ClCancellativeMonoidTerm
      (A : Set) : Set where
      sing :
        A -> ClCancellativeMonoidTerm A
      opCl :
        ClCancellativeMonoidTerm A ->
        ClCancellativeMonoidTerm A ->
        ClCancellativeMonoidTerm A
      eCl : ClCancellativeMonoidTerm A
    data OpCancellativeMonoidTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpCancellativeMonoidTerm n
      opOL :
        OpCancellativeMonoidTerm n ->
        OpCancellativeMonoidTerm n ->
        OpCancellativeMonoidTerm n
      eOL : OpCancellativeMonoidTerm n
    data OpCancellativeMonoidTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpCancellativeMonoidTerm2 n A
      sing2 :
        A ->
        OpCancellativeMonoidTerm2 n A
      opOL2 :
        OpCancellativeMonoidTerm2 n A ->
        OpCancellativeMonoidTerm2 n A ->
        OpCancellativeMonoidTerm2 n A
      eOL2 :
        OpCancellativeMonoidTerm2 n A
    simplifyB :
      CancellativeMonoidTerm ->
      CancellativeMonoidTerm
    simplifyB (opL (eL) x) = x
    simplifyB (opL x (eL)) = x
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (eL) = eL
    simplifyCl :
      (A : Set) ->
      ClCancellativeMonoidTerm A ->
      ClCancellativeMonoidTerm A
    simplifyCl _ (opCl (eCl) x) = x
    simplifyCl _ (opCl x (eCl)) = x
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpCancellativeMonoidTerm n ->
      OpCancellativeMonoidTerm n
    simplifyOp _ (opOL (eOL) x) = x
    simplifyOp _ (opOL x (eOL)) = x
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpCancellativeMonoidTerm2 n A ->
      OpCancellativeMonoidTerm2 n A
    simplifyOpE _ _ (opOL2
                     (eOL2)
                     x) = x
    simplifyOpE _ _ (opOL2
                     x
                     (eOL2)) = x
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      CancellativeMonoid A ->
      CancellativeMonoidTerm -> A
    evalB _ Ca (opL x1 x2) =
      op Ca (evalB _ Ca x1)
        (evalB _ Ca x2)
    evalB _ Ca (eL) = e Ca
    evalCl :
      (A : Set) ->
      CancellativeMonoid A ->
      ClCancellativeMonoidTerm A -> A
    evalCl _ Ca (sing x1) = x1
    evalCl _ Ca (opCl x1 x2) =
      op Ca (evalCl _ Ca x1)
        (evalCl _ Ca x2)
    evalCl _ Ca (eCl) = e Ca
    evalOp :
      (A : Set) (n : Nat) ->
      CancellativeMonoid A ->
      Vec A n ->
      OpCancellativeMonoidTerm n -> A
    evalOp _ n Ca vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ca vars (opOL
                        x1
                        x2) =
      op Ca (evalOp _ n Ca vars x1)
        (evalOp _ n Ca vars x2)
    evalOp _ n Ca vars (eOL) = e Ca
    evalOpE :
      (A : Set) (n : Nat) ->
      CancellativeMonoid A ->
      Vec A n ->
      OpCancellativeMonoidTerm2 n A ->
      A
    evalOpE _ n Ca vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ca vars (sing2 x1) =
      x1
    evalOpE _ n Ca vars (opOL2
                         x1
                         x2) =
      op Ca (evalOpE _ n Ca vars x1)
        (evalOpE _ n Ca vars x2)
    evalOpE _ n Ca vars (eOL2) =
      e Ca
    inductionB :
      (P : CancellativeMonoidTerm ->
           Set) ->
      ((x1 : CancellativeMonoidTerm)
       (x2 : CancellativeMonoidTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      P eL ->
      (x : CancellativeMonoidTerm) ->
      P x
    inductionB p popl pel (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p popl pel x1)
        (inductionB p popl pel x2)
    inductionB p popl pel (eL) = pel
    inductionCl :
      (A : Set)
      (P : ClCancellativeMonoidTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClCancellativeMonoidTerm
          A)
       (x2 : ClCancellativeMonoidTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      P eCl ->
      (x : ClCancellativeMonoidTerm
         A) -> P x
    inductionCl _ p psing popcl pecl (sing
                                      x1) = psing x1
    inductionCl _ p psing popcl pecl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing popcl
           pecl
           x1)
        (inductionCl _ p psing popcl
           pecl
           x2)
    inductionCl _ p psing popcl pecl (eCl) =
      pecl
    inductionOp :
      (n : Nat)
      (P : OpCancellativeMonoidTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpCancellativeMonoidTerm
          n)
       (x2 : OpCancellativeMonoidTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      P eOL ->
      (x : OpCancellativeMonoidTerm
         n) -> P x
    inductionOp _ p pv popol peol (v
                                   x1) = pv x1
    inductionOp _ p pv popol peol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv popol peol
           x1)
        (inductionOp _ p pv popol peol
           x2)
    inductionOp _ p pv popol peol (eOL) =
      peol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpCancellativeMonoidTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpCancellativeMonoidTerm2
          n
          A)
       (x2 : OpCancellativeMonoidTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      P eOL2 ->
      (x : OpCancellativeMonoidTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (eOL2) =
      peol2
    opL' :
      CancellativeMonoidTerm ->
      CancellativeMonoidTerm ->
      CancellativeMonoidTerm
    opL' x1 x2 = opL x1 x2
    eL' : CancellativeMonoidTerm
    eL' = eL
    stageB :
      CancellativeMonoidTerm ->
      Staged CancellativeMonoidTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (eL) = Now eL
    opCl' :
      (A : Set) ->
      ClCancellativeMonoidTerm A ->
      ClCancellativeMonoidTerm A ->
      ClCancellativeMonoidTerm A
    opCl' _ x1 x2 = opCl x1 x2
    eCl' :
      (A : Set) ->
      ClCancellativeMonoidTerm A
    eCl' _ = eCl
    stageCl :
      (A : Set) ->
      ClCancellativeMonoidTerm A ->
      Staged
        (ClCancellativeMonoidTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (eCl) = Now eCl
    opOL' :
      (n : Nat) ->
      OpCancellativeMonoidTerm n ->
      OpCancellativeMonoidTerm n ->
      OpCancellativeMonoidTerm n
    opOL' _ x1 x2 = opOL x1 x2
    eOL' :
      (n : Nat) ->
      OpCancellativeMonoidTerm n
    eOL' _ = eOL
    stageOp :
      (n : Nat) ->
      OpCancellativeMonoidTerm n ->
      Staged
        (OpCancellativeMonoidTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (eOL) = Now eOL
    opOL2' :
      (n : Nat) (A : Set) ->
      OpCancellativeMonoidTerm2 n A ->
      OpCancellativeMonoidTerm2 n A ->
      OpCancellativeMonoidTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    eOL2' :
      (n : Nat) (A : Set) ->
      OpCancellativeMonoidTerm2 n A
    eOL2' _ _ = eOL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpCancellativeMonoidTerm2 n A ->
      Staged
        (OpCancellativeMonoidTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (eOL2) = Now eOL2
    record CancellativeMonoidTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
        eT : Repr A
  
  module CancellativeSemigroup where
    record CancellativeSemigroup
      (A : Set) : Set where
      constructor CancellativeSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
    record CancellativeSemigroupSig
      (AS : Set) : Set where
      constructor CancellativeSemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record CancellativeSemigroupProd
      (AP : Set) : Set where
      constructor CancellativeSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
    record CancellativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeSemigroup A1)
      (Ca2 : CancellativeSemigroup
         A2) : Set where
      constructor CancellativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ca1 x1 x2) ==
            op Ca2 (hom x1) (hom x2)
    record CancellativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ca1 : CancellativeSemigroup A1)
      (Ca2 : CancellativeSemigroup
         A2) : Set where
      constructor CancellativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ca1 x1 x2)
            (op Ca2 y1 y2)
    data CancellativeSemigroupTerm
      : Set where
      opL :
        CancellativeSemigroupTerm ->
        CancellativeSemigroupTerm ->
        CancellativeSemigroupTerm
    data ClCancellativeSemigroupTerm
      (A : Set) : Set where
      sing :
        A ->
        ClCancellativeSemigroupTerm A
      opCl :
        ClCancellativeSemigroupTerm A ->
        ClCancellativeSemigroupTerm A ->
        ClCancellativeSemigroupTerm A
    data OpCancellativeSemigroupTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpCancellativeSemigroupTerm n
      opOL :
        OpCancellativeSemigroupTerm n ->
        OpCancellativeSemigroupTerm n ->
        OpCancellativeSemigroupTerm n
    data OpCancellativeSemigroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpCancellativeSemigroupTerm2 n A
      sing2 :
        A ->
        OpCancellativeSemigroupTerm2 n A
      opOL2 :
        OpCancellativeSemigroupTerm2 n
          A ->
        OpCancellativeSemigroupTerm2 n
          A ->
        OpCancellativeSemigroupTerm2 n A
    simplifyB :
      CancellativeSemigroupTerm ->
      CancellativeSemigroupTerm
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClCancellativeSemigroupTerm A ->
      ClCancellativeSemigroupTerm A
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpCancellativeSemigroupTerm n ->
      OpCancellativeSemigroupTerm n
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpCancellativeSemigroupTerm2 n
        A ->
      OpCancellativeSemigroupTerm2 n A
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      CancellativeSemigroup A ->
      CancellativeSemigroupTerm -> A
    evalB _ Ca (opL x1 x2) =
      op Ca (evalB _ Ca x1)
        (evalB _ Ca x2)
    evalCl :
      (A : Set) ->
      CancellativeSemigroup A ->
      ClCancellativeSemigroupTerm A ->
      A
    evalCl _ Ca (sing x1) = x1
    evalCl _ Ca (opCl x1 x2) =
      op Ca (evalCl _ Ca x1)
        (evalCl _ Ca x2)
    evalOp :
      (A : Set) (n : Nat) ->
      CancellativeSemigroup A ->
      Vec A n ->
      OpCancellativeSemigroupTerm n ->
      A
    evalOp _ n Ca vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ca vars (opOL
                        x1
                        x2) =
      op Ca (evalOp _ n Ca vars x1)
        (evalOp _ n Ca vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      CancellativeSemigroup A ->
      Vec A n ->
      OpCancellativeSemigroupTerm2 n
        A -> A
    evalOpE _ n Ca vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ca vars (sing2 x1) =
      x1
    evalOpE _ n Ca vars (opOL2
                         x1
                         x2) =
      op Ca (evalOpE _ n Ca vars x1)
        (evalOpE _ n Ca vars x2)
    inductionB :
      (P : CancellativeSemigroupTerm ->
           Set) ->
      ((x1 : CancellativeSemigroupTerm)
       (x2 : CancellativeSemigroupTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : CancellativeSemigroupTerm) ->
      P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClCancellativeSemigroupTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClCancellativeSemigroupTerm
          A)
       (x2 : ClCancellativeSemigroupTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClCancellativeSemigroupTerm
         A) -> P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpCancellativeSemigroupTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpCancellativeSemigroupTerm
          n)
       (x2 : OpCancellativeSemigroupTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpCancellativeSemigroupTerm
         n) -> P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpCancellativeSemigroupTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpCancellativeSemigroupTerm2
          n
          A)
       (x2 : OpCancellativeSemigroupTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpCancellativeSemigroupTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      CancellativeSemigroupTerm ->
      CancellativeSemigroupTerm ->
      CancellativeSemigroupTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      CancellativeSemigroupTerm ->
      Staged CancellativeSemigroupTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClCancellativeSemigroupTerm A ->
      ClCancellativeSemigroupTerm A ->
      ClCancellativeSemigroupTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClCancellativeSemigroupTerm A ->
      Staged
        (ClCancellativeSemigroupTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpCancellativeSemigroupTerm n ->
      OpCancellativeSemigroupTerm n ->
      OpCancellativeSemigroupTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpCancellativeSemigroupTerm n ->
      Staged
        (OpCancellativeSemigroupTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpCancellativeSemigroupTerm2 n
        A ->
      OpCancellativeSemigroupTerm2 n
        A ->
      OpCancellativeSemigroupTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpCancellativeSemigroupTerm2 n
        A ->
      Staged
        (OpCancellativeSemigroupTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record CancellativeSemigroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module Carrier where
    record Carrier
      (A : Set) : Set where
      constructor CarrierC
      field
        
    record CarrierSig
      (AS : Set) : Set where
      constructor CarrierSigSigC
      field
        
    record CarrierProd
      (AP : Set) : Set where
      constructor CarrierProdC
      field
        
    record CarrierHom
      (A1 : Set) (A2 : Set)
      (Ca1 : Carrier A1)
      (Ca2 : Carrier A2) : Set where
      constructor CarrierHomC
      field
        hom : A1 -> A2
    record CarrierRelInterp
      (A1 : Set) (A2 : Set)
      (Ca1 : Carrier A1)
      (Ca2 : Carrier A2) : Set where
      constructor CarrierRelInterpC
      field
        interp : A1 -> A2 -> Set
    data CarrierTerm : Set where
      
    data ClCarrierTerm
      (A : Set) : Set where
      sing : A -> ClCarrierTerm A
    data OpCarrierTerm
      (n : Nat) : Set where
      v : Fin n -> OpCarrierTerm n
    data OpCarrierTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpCarrierTerm2 n A
      sing2 : A -> OpCarrierTerm2 n A
    simplifyB :
      CarrierTerm -> CarrierTerm
    simplifyCl :
      (A : Set) ->
      ClCarrierTerm A ->
      ClCarrierTerm A
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpCarrierTerm n ->
      OpCarrierTerm n
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpCarrierTerm2 n A ->
      OpCarrierTerm2 n A
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Carrier A -> CarrierTerm -> A
    evalCl :
      (A : Set) ->
      Carrier A ->
      ClCarrierTerm A -> A
    evalCl _ Ca (sing x1) = x1
    evalOp :
      (A : Set) (n : Nat) ->
      Carrier A ->
      Vec A n -> OpCarrierTerm n -> A
    evalOp _ n Ca vars (v x1) =
      lookup _ n x1 vars
    evalOpE :
      (A : Set) (n : Nat) ->
      Carrier A ->
      Vec A n ->
      OpCarrierTerm2 n A -> A
    evalOpE _ n Ca vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ca vars (sing2 x1) =
      x1
    inductionB :
      (P : CarrierTerm -> Set)
      (x : CarrierTerm) -> P x
    inductionCl :
      (A : Set)
      (P : ClCarrierTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      (x : ClCarrierTerm A) -> P x
    inductionCl _ p psing (sing
                           x1) = psing x1
    inductionOp :
      (n : Nat)
      (P : OpCarrierTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      (x : OpCarrierTerm n) -> P x
    inductionOp _ p pv (v x1) =
      pv x1
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpCarrierTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      (x : OpCarrierTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 (v2
                                   x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 (sing2
                                   x1) = psing2 x1
    stageB :
      CarrierTerm ->
      Staged CarrierTerm
    stageCl :
      (A : Set) ->
      ClCarrierTerm A ->
      Staged (ClCarrierTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageOp :
      (n : Nat) ->
      OpCarrierTerm n ->
      Staged (OpCarrierTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOpE :
      (n : Nat) (A : Set) ->
      OpCarrierTerm2 n A ->
      Staged (OpCarrierTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    record CarrierTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        
  
  module CommutativeAdditiveMagma where
    record CommutativeAdditiveMagma
      (A : Set) : Set where
      constructor CommutativeAdditiveMagmaC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
    record CommutativeAdditiveMagmaSig
      (AS : Set) : Set where
      constructor CommutativeAdditiveMagmaSigSigC
      field
        +S : AS -> AS -> AS
    record CommutativeAdditiveMagmaProd
      (AP : Set) : Set where
      constructor CommutativeAdditiveMagmaProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
    record CommutativeAdditiveMagmaHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeAdditiveMagma
         A1)
      (Co2 : CommutativeAdditiveMagma
         A2) : Set where
      constructor CommutativeAdditiveMagmaHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Co1 x1 x2) ==
            + Co2 (hom x1) (hom x2)
    record CommutativeAdditiveMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeAdditiveMagma
         A1)
      (Co2 : CommutativeAdditiveMagma
         A2) : Set where
      constructor CommutativeAdditiveMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Co1 x1 x2)
            (+ Co2 y1 y2)
    data CommutativeAdditiveMagmaTerm
      : Set where
      +L :
        CommutativeAdditiveMagmaTerm ->
        CommutativeAdditiveMagmaTerm ->
        CommutativeAdditiveMagmaTerm
    data ClCommutativeAdditiveMagmaTerm
      (A : Set) : Set where
      sing :
        A ->
        ClCommutativeAdditiveMagmaTerm A
      +Cl :
        ClCommutativeAdditiveMagmaTerm
          A ->
        ClCommutativeAdditiveMagmaTerm
          A ->
        ClCommutativeAdditiveMagmaTerm A
    data OpCommutativeAdditiveMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpCommutativeAdditiveMagmaTerm n
      +OL :
        OpCommutativeAdditiveMagmaTerm
          n ->
        OpCommutativeAdditiveMagmaTerm
          n ->
        OpCommutativeAdditiveMagmaTerm n
    data OpCommutativeAdditiveMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpCommutativeAdditiveMagmaTerm2
          n
          A
      sing2 :
        A ->
        OpCommutativeAdditiveMagmaTerm2
          n
          A
      +OL2 :
        OpCommutativeAdditiveMagmaTerm2
          n
          A ->
        OpCommutativeAdditiveMagmaTerm2
          n
          A ->
        OpCommutativeAdditiveMagmaTerm2
          n
          A
    simplifyB :
      CommutativeAdditiveMagmaTerm ->
      CommutativeAdditiveMagmaTerm
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClCommutativeAdditiveMagmaTerm
        A ->
      ClCommutativeAdditiveMagmaTerm A
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpCommutativeAdditiveMagmaTerm
        n ->
      OpCommutativeAdditiveMagmaTerm n
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpCommutativeAdditiveMagmaTerm2
        n
        A ->
      OpCommutativeAdditiveMagmaTerm2
        n
        A
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      CommutativeAdditiveMagma A ->
      CommutativeAdditiveMagmaTerm ->
      A
    evalB _ Co (+L x1 x2) =
      + Co (evalB _ Co x1)
        (evalB _ Co x2)
    evalCl :
      (A : Set) ->
      CommutativeAdditiveMagma A ->
      ClCommutativeAdditiveMagmaTerm
        A -> A
    evalCl _ Co (sing x1) = x1
    evalCl _ Co (+Cl x1 x2) =
      + Co (evalCl _ Co x1)
        (evalCl _ Co x2)
    evalOp :
      (A : Set) (n : Nat) ->
      CommutativeAdditiveMagma A ->
      Vec A n ->
      OpCommutativeAdditiveMagmaTerm
        n -> A
    evalOp _ n Co vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Co vars (+OL x1 x2) =
      + Co (evalOp _ n Co vars x1)
        (evalOp _ n Co vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      CommutativeAdditiveMagma A ->
      Vec A n ->
      OpCommutativeAdditiveMagmaTerm2
        n
        A -> A
    evalOpE _ n Co vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Co vars (sing2 x1) =
      x1
    evalOpE _ n Co vars (+OL2
                         x1
                         x2) =
      + Co (evalOpE _ n Co vars x1)
        (evalOpE _ n Co vars x2)
    inductionB :
      (P : CommutativeAdditiveMagmaTerm ->
           Set) ->
      ((x1 : CommutativeAdditiveMagmaTerm)
       (x2 : CommutativeAdditiveMagmaTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : CommutativeAdditiveMagmaTerm) ->
      P x
    inductionB p p+l (+L x1 x2) =
      p+l _ _ (inductionB p p+l x1)
        (inductionB p p+l x2)
    inductionCl :
      (A : Set)
      (P : ClCommutativeAdditiveMagmaTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClCommutativeAdditiveMagmaTerm
          A)
       (x2 : ClCommutativeAdditiveMagmaTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClCommutativeAdditiveMagmaTerm
         A) -> P x
    inductionCl _ p psing p+cl (sing
                                x1) = psing x1
    inductionCl _ p psing p+cl (+Cl
                                x1
                                x2) =
      p+cl _ _
        (inductionCl _ p psing p+cl x1)
        (inductionCl _ p psing p+cl x2)
    inductionOp :
      (n : Nat)
      (P : OpCommutativeAdditiveMagmaTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpCommutativeAdditiveMagmaTerm
          n)
       (x2 : OpCommutativeAdditiveMagmaTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpCommutativeAdditiveMagmaTerm
         n) -> P x
    inductionOp _ p pv p+ol (v x1) =
      pv x1
    inductionOp _ p pv p+ol (+OL
                             x1
                             x2) =
      p+ol _ _
        (inductionOp _ p pv p+ol x1)
        (inductionOp _ p pv p+ol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpCommutativeAdditiveMagmaTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpCommutativeAdditiveMagmaTerm2
          n
          A)
       (x2 : OpCommutativeAdditiveMagmaTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpCommutativeAdditiveMagmaTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p+ol2 (v2
                                         x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 (sing2
                                         x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 (+OL2
                                         x1
                                         x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           x2)
    +L' :
      CommutativeAdditiveMagmaTerm ->
      CommutativeAdditiveMagmaTerm ->
      CommutativeAdditiveMagmaTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      CommutativeAdditiveMagmaTerm ->
      Staged
        CommutativeAdditiveMagmaTerm
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    +Cl' :
      (A : Set) ->
      ClCommutativeAdditiveMagmaTerm
        A ->
      ClCommutativeAdditiveMagmaTerm
        A ->
      ClCommutativeAdditiveMagmaTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClCommutativeAdditiveMagmaTerm
        A ->
      Staged
        (ClCommutativeAdditiveMagmaTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    +OL' :
      (n : Nat) ->
      OpCommutativeAdditiveMagmaTerm
        n ->
      OpCommutativeAdditiveMagmaTerm
        n ->
      OpCommutativeAdditiveMagmaTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpCommutativeAdditiveMagmaTerm
        n ->
      Staged
        (OpCommutativeAdditiveMagmaTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    +OL2' :
      (n : Nat) (A : Set) ->
      OpCommutativeAdditiveMagmaTerm2
        n
        A ->
      OpCommutativeAdditiveMagmaTerm2
        n
        A ->
      OpCommutativeAdditiveMagmaTerm2
        n
        A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpCommutativeAdditiveMagmaTerm2
        n
        A ->
      Staged
        (OpCommutativeAdditiveMagmaTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record CommutativeAdditiveMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        +T : Repr A -> Repr A -> Repr A
  
  module CommutativeGroup where
    record CommutativeGroup
      (A : Set) : Set where
      constructor CommutativeGroupC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        inv : A -> A
        leftInverse_inv_op_e :
          (x : A) -> op x (inv x) == e
        rightInverse_inv_op_e :
          (x : A) -> op (inv x) x == e
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CommutativeGroupSig
      (AS : Set) : Set where
      constructor CommutativeGroupSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
        invS : AS -> AS
    record CommutativeGroupProd
      (AP : Set) : Set where
      constructor CommutativeGroupProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP xP (invP xP) == eP
        rightInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (invP xP) xP == eP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CommutativeGroupHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeGroup A1)
      (Co2 : CommutativeGroup A2) :
      Set where
      constructor CommutativeGroupHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Co1) == e Co2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
        pres-inv :
          (x1 : A1) ->
          hom (inv Co1 x1) ==
            inv Co2 (hom x1)
    record CommutativeGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeGroup A1)
      (Co2 : CommutativeGroup A2) :
      Set where
      constructor CommutativeGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Co1) (e Co2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Co1 x1) (inv Co2 y1)
    data CommutativeGroupTerm
      : Set where
      eL : CommutativeGroupTerm
      opL :
        CommutativeGroupTerm ->
        CommutativeGroupTerm ->
        CommutativeGroupTerm
      invL :
        CommutativeGroupTerm ->
        CommutativeGroupTerm
    data ClCommutativeGroupTerm
      (A : Set) : Set where
      sing :
        A -> ClCommutativeGroupTerm A
      eCl : ClCommutativeGroupTerm A
      opCl :
        ClCommutativeGroupTerm A ->
        ClCommutativeGroupTerm A ->
        ClCommutativeGroupTerm A
      invCl :
        ClCommutativeGroupTerm A ->
        ClCommutativeGroupTerm A
    data OpCommutativeGroupTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpCommutativeGroupTerm n
      eOL : OpCommutativeGroupTerm n
      opOL :
        OpCommutativeGroupTerm n ->
        OpCommutativeGroupTerm n ->
        OpCommutativeGroupTerm n
      invOL :
        OpCommutativeGroupTerm n ->
        OpCommutativeGroupTerm n
    data OpCommutativeGroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpCommutativeGroupTerm2 n A
      sing2 :
        A -> OpCommutativeGroupTerm2 n A
      eOL2 :
        OpCommutativeGroupTerm2 n A
      opOL2 :
        OpCommutativeGroupTerm2 n A ->
        OpCommutativeGroupTerm2 n A ->
        OpCommutativeGroupTerm2 n A
      invOL2 :
        OpCommutativeGroupTerm2 n A ->
        OpCommutativeGroupTerm2 n A
    simplifyB :
      CommutativeGroupTerm ->
      CommutativeGroupTerm
    simplifyB (opL (eL) x) = x
    simplifyB (opL x (eL)) = x
    simplifyB (opL x (invL x)) = eL
    simplifyB (opL (invL x) x) = eL
    simplifyB (eL) = eL
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (invL x1) =
      invL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClCommutativeGroupTerm A ->
      ClCommutativeGroupTerm A
    simplifyCl _ (opCl (eCl) x) = x
    simplifyCl _ (opCl x (eCl)) = x
    simplifyCl _ (opCl
                  x
                  (invCl x)) = eCl
    simplifyCl _ (opCl
                  (invCl x)
                  x) = eCl
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (invCl x1) =
      invCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpCommutativeGroupTerm n ->
      OpCommutativeGroupTerm n
    simplifyOp _ (opOL (eOL) x) = x
    simplifyOp _ (opOL x (eOL)) = x
    simplifyOp _ (opOL
                  x
                  (invOL x)) = eOL
    simplifyOp _ (opOL
                  (invOL x)
                  x) = eOL
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (invOL x1) =
      invOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpCommutativeGroupTerm2 n A ->
      OpCommutativeGroupTerm2 n A
    simplifyOpE _ _ (opOL2
                     (eOL2)
                     x) = x
    simplifyOpE _ _ (opOL2
                     x
                     (eOL2)) = x
    simplifyOpE _ _ (opOL2
                     x
                     (invOL2 x)) = eOL2
    simplifyOpE _ _ (opOL2
                     (invOL2 x)
                     x) = eOL2
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (invOL2 x1) =
      invOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      CommutativeGroup A ->
      CommutativeGroupTerm -> A
    evalB _ Co (eL) = e Co
    evalB _ Co (opL x1 x2) =
      op Co (evalB _ Co x1)
        (evalB _ Co x2)
    evalB _ Co (invL x1) =
      inv Co (evalB _ Co x1)
    evalCl :
      (A : Set) ->
      CommutativeGroup A ->
      ClCommutativeGroupTerm A -> A
    evalCl _ Co (sing x1) = x1
    evalCl _ Co (eCl) = e Co
    evalCl _ Co (opCl x1 x2) =
      op Co (evalCl _ Co x1)
        (evalCl _ Co x2)
    evalCl _ Co (invCl x1) =
      inv Co (evalCl _ Co x1)
    evalOp :
      (A : Set) (n : Nat) ->
      CommutativeGroup A ->
      Vec A n ->
      OpCommutativeGroupTerm n -> A
    evalOp _ n Co vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Co vars (eOL) = e Co
    evalOp _ n Co vars (opOL
                        x1
                        x2) =
      op Co (evalOp _ n Co vars x1)
        (evalOp _ n Co vars x2)
    evalOp _ n Co vars (invOL x1) =
      inv Co (evalOp _ n Co vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      CommutativeGroup A ->
      Vec A n ->
      OpCommutativeGroupTerm2 n A -> A
    evalOpE _ n Co vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Co vars (sing2 x1) =
      x1
    evalOpE _ n Co vars (eOL2) =
      e Co
    evalOpE _ n Co vars (opOL2
                         x1
                         x2) =
      op Co (evalOpE _ n Co vars x1)
        (evalOpE _ n Co vars x2)
    evalOpE _ n Co vars (invOL2
                         x1) =
      inv Co (evalOpE _ n Co vars x1)
    inductionB :
      (P : CommutativeGroupTerm ->
           Set) ->
      P eL ->
      ((x1 : CommutativeGroupTerm)
       (x2 : CommutativeGroupTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      ((x1 : CommutativeGroupTerm) ->
       P x1 -> P (invL x1)) ->
      (x : CommutativeGroupTerm) ->
      P x
    inductionB p pel popl pinvl (eL) =
      pel
    inductionB p pel popl pinvl (opL
                                 x1
                                 x2) =
      popl _ _
        (inductionB p pel popl pinvl x1)
        (inductionB p pel popl pinvl x2)
    inductionB p pel popl pinvl (invL
                                 x1) =
      pinvl _
        (inductionB p pel popl pinvl x1)
    inductionCl :
      (A : Set)
      (P : ClCommutativeGroupTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P eCl ->
      ((x1 : ClCommutativeGroupTerm A)
       (x2 : ClCommutativeGroupTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      ((x1 : ClCommutativeGroupTerm
          A) -> P x1 -> P (invCl x1)) ->
      (x : ClCommutativeGroupTerm
         A) -> P x
    inductionCl _ p psing pecl popcl pinvcl (sing
                                             x1) = psing x1
    inductionCl _ p psing pecl popcl pinvcl (eCl) =
      pecl
    inductionCl _ p psing pecl popcl pinvcl (opCl
                                             x1
                                             x2) =
      popcl _ _
        (inductionCl _ p psing pecl
           popcl
           pinvcl
           x1)
        (inductionCl _ p psing pecl
           popcl
           pinvcl
           x2)
    inductionCl _ p psing pecl popcl pinvcl (invCl
                                             x1) =
      pinvcl _
        (inductionCl _ p psing pecl
           popcl
           pinvcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpCommutativeGroupTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P eOL ->
      ((x1 : OpCommutativeGroupTerm n)
       (x2 : OpCommutativeGroupTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      ((x1 : OpCommutativeGroupTerm
          n) -> P x1 -> P (invOL x1)) ->
      (x : OpCommutativeGroupTerm
         n) -> P x
    inductionOp _ p pv peol popol pinvol (v
                                          x1) = pv x1
    inductionOp _ p pv peol popol pinvol (eOL) =
      peol
    inductionOp _ p pv peol popol pinvol (opOL
                                          x1
                                          x2) =
      popol _ _
        (inductionOp _ p pv peol popol
           pinvol
           x1)
        (inductionOp _ p pv peol popol
           pinvol
           x2)
    inductionOp _ p pv peol popol pinvol (invOL
                                          x1) =
      pinvol _
        (inductionOp _ p pv peol popol
           pinvol
           x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpCommutativeGroupTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P eOL2 ->
      ((x1 : OpCommutativeGroupTerm2 n
          A)
       (x2 : OpCommutativeGroupTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      ((x1 : OpCommutativeGroupTerm2 n
          A) -> P x1 -> P (invOL2 x1)) ->
      (x : OpCommutativeGroupTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 peol2 popol2 pinvol2 (v2
                                                        x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 pinvol2 (sing2
                                                        x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 pinvol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 peol2 popol2 pinvol2 (opOL2
                                                        x1
                                                        x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           pinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           pinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 peol2 popol2 pinvol2 (invOL2
                                                        x1) =
      pinvol2 _
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           pinvol2
           x1)
    eL' : CommutativeGroupTerm
    eL' = eL
    opL' :
      CommutativeGroupTerm ->
      CommutativeGroupTerm ->
      CommutativeGroupTerm
    opL' x1 x2 = opL x1 x2
    invL' :
      CommutativeGroupTerm ->
      CommutativeGroupTerm
    invL' x1 = invL x1
    stageB :
      CommutativeGroupTerm ->
      Staged CommutativeGroupTerm
    stageB (eL) = Now eL
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (invL x1) =
      stage1 _ _ invL'
        (codeLift1 _ _ invL')
        (stageB x1)
    eCl' :
      (A : Set) ->
      ClCommutativeGroupTerm A
    eCl' _ = eCl
    opCl' :
      (A : Set) ->
      ClCommutativeGroupTerm A ->
      ClCommutativeGroupTerm A ->
      ClCommutativeGroupTerm A
    opCl' _ x1 x2 = opCl x1 x2
    invCl' :
      (A : Set) ->
      ClCommutativeGroupTerm A ->
      ClCommutativeGroupTerm A
    invCl' _ x1 = invCl x1
    stageCl :
      (A : Set) ->
      ClCommutativeGroupTerm A ->
      Staged
        (ClCommutativeGroupTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (eCl) = Now eCl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (invCl x1) =
      stage1 _ _ (invCl' _)
        (codeLift1 _ _ (invCl' _))
        (stageCl _ x1)
    eOL' :
      (n : Nat) ->
      OpCommutativeGroupTerm n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      OpCommutativeGroupTerm n ->
      OpCommutativeGroupTerm n ->
      OpCommutativeGroupTerm n
    opOL' _ x1 x2 = opOL x1 x2
    invOL' :
      (n : Nat) ->
      OpCommutativeGroupTerm n ->
      OpCommutativeGroupTerm n
    invOL' _ x1 = invOL x1
    stageOp :
      (n : Nat) ->
      OpCommutativeGroupTerm n ->
      Staged
        (OpCommutativeGroupTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (eOL) = Now eOL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (invOL x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (stageOp _ x1)
    eOL2' :
      (n : Nat) (A : Set) ->
      OpCommutativeGroupTerm2 n A
    eOL2' _ _ = eOL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpCommutativeGroupTerm2 n A ->
      OpCommutativeGroupTerm2 n A ->
      OpCommutativeGroupTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    invOL2' :
      (n : Nat) (A : Set) ->
      OpCommutativeGroupTerm2 n A ->
      OpCommutativeGroupTerm2 n A
    invOL2' _ _ x1 = invOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpCommutativeGroupTerm2 n A ->
      Staged
        (OpCommutativeGroupTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (invOL2 x1) =
      stage1 _ _ (invOL2' _ _)
        (codeLift1 _ _ (invOL2' _ _))
        (stageOpE _ _ x1)
    record CommutativeGroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        eT : Repr A
        opT : Repr A -> Repr A -> Repr A
        invT : Repr A -> Repr A
  
  module CommutativeMagma where
    record CommutativeMagma
      (A : Set) : Set where
      constructor CommutativeMagmaC
      field
        op : A -> A -> A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CommutativeMagmaSig
      (AS : Set) : Set where
      constructor CommutativeMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record CommutativeMagmaProd
      (AP : Set) : Set where
      constructor CommutativeMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CommutativeMagmaHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMagma A1)
      (Co2 : CommutativeMagma A2) :
      Set where
      constructor CommutativeMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
    record CommutativeMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMagma A1)
      (Co2 : CommutativeMagma A2) :
      Set where
      constructor CommutativeMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
    data CommutativeMagmaTerm
      : Set where
      opL :
        CommutativeMagmaTerm ->
        CommutativeMagmaTerm ->
        CommutativeMagmaTerm
    data ClCommutativeMagmaTerm
      (A : Set) : Set where
      sing :
        A -> ClCommutativeMagmaTerm A
      opCl :
        ClCommutativeMagmaTerm A ->
        ClCommutativeMagmaTerm A ->
        ClCommutativeMagmaTerm A
    data OpCommutativeMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpCommutativeMagmaTerm n
      opOL :
        OpCommutativeMagmaTerm n ->
        OpCommutativeMagmaTerm n ->
        OpCommutativeMagmaTerm n
    data OpCommutativeMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpCommutativeMagmaTerm2 n A
      sing2 :
        A -> OpCommutativeMagmaTerm2 n A
      opOL2 :
        OpCommutativeMagmaTerm2 n A ->
        OpCommutativeMagmaTerm2 n A ->
        OpCommutativeMagmaTerm2 n A
    simplifyB :
      CommutativeMagmaTerm ->
      CommutativeMagmaTerm
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClCommutativeMagmaTerm A ->
      ClCommutativeMagmaTerm A
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpCommutativeMagmaTerm n ->
      OpCommutativeMagmaTerm n
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpCommutativeMagmaTerm2 n A ->
      OpCommutativeMagmaTerm2 n A
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      CommutativeMagma A ->
      CommutativeMagmaTerm -> A
    evalB _ Co (opL x1 x2) =
      op Co (evalB _ Co x1)
        (evalB _ Co x2)
    evalCl :
      (A : Set) ->
      CommutativeMagma A ->
      ClCommutativeMagmaTerm A -> A
    evalCl _ Co (sing x1) = x1
    evalCl _ Co (opCl x1 x2) =
      op Co (evalCl _ Co x1)
        (evalCl _ Co x2)
    evalOp :
      (A : Set) (n : Nat) ->
      CommutativeMagma A ->
      Vec A n ->
      OpCommutativeMagmaTerm n -> A
    evalOp _ n Co vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Co vars (opOL
                        x1
                        x2) =
      op Co (evalOp _ n Co vars x1)
        (evalOp _ n Co vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      CommutativeMagma A ->
      Vec A n ->
      OpCommutativeMagmaTerm2 n A -> A
    evalOpE _ n Co vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Co vars (sing2 x1) =
      x1
    evalOpE _ n Co vars (opOL2
                         x1
                         x2) =
      op Co (evalOpE _ n Co vars x1)
        (evalOpE _ n Co vars x2)
    inductionB :
      (P : CommutativeMagmaTerm ->
           Set) ->
      ((x1 : CommutativeMagmaTerm)
       (x2 : CommutativeMagmaTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : CommutativeMagmaTerm) ->
      P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClCommutativeMagmaTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClCommutativeMagmaTerm A)
       (x2 : ClCommutativeMagmaTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClCommutativeMagmaTerm
         A) -> P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpCommutativeMagmaTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpCommutativeMagmaTerm n)
       (x2 : OpCommutativeMagmaTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpCommutativeMagmaTerm
         n) -> P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpCommutativeMagmaTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpCommutativeMagmaTerm2 n
          A)
       (x2 : OpCommutativeMagmaTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpCommutativeMagmaTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      CommutativeMagmaTerm ->
      CommutativeMagmaTerm ->
      CommutativeMagmaTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      CommutativeMagmaTerm ->
      Staged CommutativeMagmaTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClCommutativeMagmaTerm A ->
      ClCommutativeMagmaTerm A ->
      ClCommutativeMagmaTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClCommutativeMagmaTerm A ->
      Staged
        (ClCommutativeMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpCommutativeMagmaTerm n ->
      OpCommutativeMagmaTerm n ->
      OpCommutativeMagmaTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpCommutativeMagmaTerm n ->
      Staged
        (OpCommutativeMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpCommutativeMagmaTerm2 n A ->
      OpCommutativeMagmaTerm2 n A ->
      OpCommutativeMagmaTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpCommutativeMagmaTerm2 n A ->
      Staged
        (OpCommutativeMagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record CommutativeMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module CommutativeMonoid where
    record CommutativeMonoid
      (A : Set) : Set where
      constructor CommutativeMonoidC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        e : A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CommutativeMonoidSig
      (AS : Set) : Set where
      constructor CommutativeMonoidSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record CommutativeMonoidProd
      (AP : Set) : Set where
      constructor CommutativeMonoidProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CommutativeMonoidHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMonoid A1)
      (Co2 : CommutativeMonoid A2) :
      Set where
      constructor CommutativeMonoidHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
        pres-e : hom (e Co1) == e Co2
    record CommutativeMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMonoid A1)
      (Co2 : CommutativeMonoid A2) :
      Set where
      constructor CommutativeMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
        interp-e :
          interp (e Co1) (e Co2)
    data CommutativeMonoidTerm
      : Set where
      opL :
        CommutativeMonoidTerm ->
        CommutativeMonoidTerm ->
        CommutativeMonoidTerm
      eL : CommutativeMonoidTerm
    data ClCommutativeMonoidTerm
      (A : Set) : Set where
      sing :
        A -> ClCommutativeMonoidTerm A
      opCl :
        ClCommutativeMonoidTerm A ->
        ClCommutativeMonoidTerm A ->
        ClCommutativeMonoidTerm A
      eCl : ClCommutativeMonoidTerm A
    data OpCommutativeMonoidTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpCommutativeMonoidTerm n
      opOL :
        OpCommutativeMonoidTerm n ->
        OpCommutativeMonoidTerm n ->
        OpCommutativeMonoidTerm n
      eOL : OpCommutativeMonoidTerm n
    data OpCommutativeMonoidTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpCommutativeMonoidTerm2 n A
      sing2 :
        A ->
        OpCommutativeMonoidTerm2 n A
      opOL2 :
        OpCommutativeMonoidTerm2 n A ->
        OpCommutativeMonoidTerm2 n A ->
        OpCommutativeMonoidTerm2 n A
      eOL2 :
        OpCommutativeMonoidTerm2 n A
    simplifyB :
      CommutativeMonoidTerm ->
      CommutativeMonoidTerm
    simplifyB (opL (eL) x) = x
    simplifyB (opL x (eL)) = x
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (eL) = eL
    simplifyCl :
      (A : Set) ->
      ClCommutativeMonoidTerm A ->
      ClCommutativeMonoidTerm A
    simplifyCl _ (opCl (eCl) x) = x
    simplifyCl _ (opCl x (eCl)) = x
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpCommutativeMonoidTerm n ->
      OpCommutativeMonoidTerm n
    simplifyOp _ (opOL (eOL) x) = x
    simplifyOp _ (opOL x (eOL)) = x
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpCommutativeMonoidTerm2 n A ->
      OpCommutativeMonoidTerm2 n A
    simplifyOpE _ _ (opOL2
                     (eOL2)
                     x) = x
    simplifyOpE _ _ (opOL2
                     x
                     (eOL2)) = x
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      CommutativeMonoid A ->
      CommutativeMonoidTerm -> A
    evalB _ Co (opL x1 x2) =
      op Co (evalB _ Co x1)
        (evalB _ Co x2)
    evalB _ Co (eL) = e Co
    evalCl :
      (A : Set) ->
      CommutativeMonoid A ->
      ClCommutativeMonoidTerm A -> A
    evalCl _ Co (sing x1) = x1
    evalCl _ Co (opCl x1 x2) =
      op Co (evalCl _ Co x1)
        (evalCl _ Co x2)
    evalCl _ Co (eCl) = e Co
    evalOp :
      (A : Set) (n : Nat) ->
      CommutativeMonoid A ->
      Vec A n ->
      OpCommutativeMonoidTerm n -> A
    evalOp _ n Co vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Co vars (opOL
                        x1
                        x2) =
      op Co (evalOp _ n Co vars x1)
        (evalOp _ n Co vars x2)
    evalOp _ n Co vars (eOL) = e Co
    evalOpE :
      (A : Set) (n : Nat) ->
      CommutativeMonoid A ->
      Vec A n ->
      OpCommutativeMonoidTerm2 n A ->
      A
    evalOpE _ n Co vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Co vars (sing2 x1) =
      x1
    evalOpE _ n Co vars (opOL2
                         x1
                         x2) =
      op Co (evalOpE _ n Co vars x1)
        (evalOpE _ n Co vars x2)
    evalOpE _ n Co vars (eOL2) =
      e Co
    inductionB :
      (P : CommutativeMonoidTerm ->
           Set) ->
      ((x1 : CommutativeMonoidTerm)
       (x2 : CommutativeMonoidTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      P eL ->
      (x : CommutativeMonoidTerm) ->
      P x
    inductionB p popl pel (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p popl pel x1)
        (inductionB p popl pel x2)
    inductionB p popl pel (eL) = pel
    inductionCl :
      (A : Set)
      (P : ClCommutativeMonoidTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClCommutativeMonoidTerm
          A)
       (x2 : ClCommutativeMonoidTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      P eCl ->
      (x : ClCommutativeMonoidTerm
         A) -> P x
    inductionCl _ p psing popcl pecl (sing
                                      x1) = psing x1
    inductionCl _ p psing popcl pecl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing popcl
           pecl
           x1)
        (inductionCl _ p psing popcl
           pecl
           x2)
    inductionCl _ p psing popcl pecl (eCl) =
      pecl
    inductionOp :
      (n : Nat)
      (P : OpCommutativeMonoidTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpCommutativeMonoidTerm
          n)
       (x2 : OpCommutativeMonoidTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      P eOL ->
      (x : OpCommutativeMonoidTerm
         n) -> P x
    inductionOp _ p pv popol peol (v
                                   x1) = pv x1
    inductionOp _ p pv popol peol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv popol peol
           x1)
        (inductionOp _ p pv popol peol
           x2)
    inductionOp _ p pv popol peol (eOL) =
      peol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpCommutativeMonoidTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpCommutativeMonoidTerm2
          n
          A)
       (x2 : OpCommutativeMonoidTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      P eOL2 ->
      (x : OpCommutativeMonoidTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (eOL2) =
      peol2
    opL' :
      CommutativeMonoidTerm ->
      CommutativeMonoidTerm ->
      CommutativeMonoidTerm
    opL' x1 x2 = opL x1 x2
    eL' : CommutativeMonoidTerm
    eL' = eL
    stageB :
      CommutativeMonoidTerm ->
      Staged CommutativeMonoidTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (eL) = Now eL
    opCl' :
      (A : Set) ->
      ClCommutativeMonoidTerm A ->
      ClCommutativeMonoidTerm A ->
      ClCommutativeMonoidTerm A
    opCl' _ x1 x2 = opCl x1 x2
    eCl' :
      (A : Set) ->
      ClCommutativeMonoidTerm A
    eCl' _ = eCl
    stageCl :
      (A : Set) ->
      ClCommutativeMonoidTerm A ->
      Staged
        (ClCommutativeMonoidTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (eCl) = Now eCl
    opOL' :
      (n : Nat) ->
      OpCommutativeMonoidTerm n ->
      OpCommutativeMonoidTerm n ->
      OpCommutativeMonoidTerm n
    opOL' _ x1 x2 = opOL x1 x2
    eOL' :
      (n : Nat) ->
      OpCommutativeMonoidTerm n
    eOL' _ = eOL
    stageOp :
      (n : Nat) ->
      OpCommutativeMonoidTerm n ->
      Staged
        (OpCommutativeMonoidTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (eOL) = Now eOL
    opOL2' :
      (n : Nat) (A : Set) ->
      OpCommutativeMonoidTerm2 n A ->
      OpCommutativeMonoidTerm2 n A ->
      OpCommutativeMonoidTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    eOL2' :
      (n : Nat) (A : Set) ->
      OpCommutativeMonoidTerm2 n A
    eOL2' _ _ = eOL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpCommutativeMonoidTerm2 n A ->
      Staged
        (OpCommutativeMonoidTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (eOL2) = Now eOL2
    record CommutativeMonoidTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
        eT : Repr A
  
  module CommutativeMonoid1 where
    record CommutativeMonoid1
      (A : Set) : Set where
      constructor CommutativeMonoid1C
      field
        1 : A
        op : A -> A -> A
        lunit_1 : (x : A) -> op 1 x == x
        runit_1 : (x : A) -> op x 1 == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CommutativeMonoid1Sig
      (AS : Set) : Set where
      constructor CommutativeMonoid1SigSigC
      field
        1S : AS
        opS : AS -> AS -> AS
    record CommutativeMonoid1Prod
      (AP : Set) : Set where
      constructor CommutativeMonoid1ProdC
      field
        1P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          opP 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          opP xP 1P == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CommutativeMonoid1Hom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMonoid1 A1)
      (Co2 : CommutativeMonoid1 A2) :
      Set where
      constructor CommutativeMonoid1HomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Co1) == 1 Co2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
    record CommutativeMonoid1RelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeMonoid1 A1)
      (Co2 : CommutativeMonoid1 A2) :
      Set where
      constructor CommutativeMonoid1RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Co1) (1 Co2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
    data CommutativeMonoid1LTerm
      : Set where
      1L : CommutativeMonoid1LTerm
      opL :
        CommutativeMonoid1LTerm ->
        CommutativeMonoid1LTerm ->
        CommutativeMonoid1LTerm
    data ClCommutativeMonoid1ClTerm
      (A : Set) : Set where
      sing :
        A ->
        ClCommutativeMonoid1ClTerm A
      1Cl :
        ClCommutativeMonoid1ClTerm A
      opCl :
        ClCommutativeMonoid1ClTerm A ->
        ClCommutativeMonoid1ClTerm A ->
        ClCommutativeMonoid1ClTerm A
    data OpCommutativeMonoid1OLTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpCommutativeMonoid1OLTerm n
      1OL :
        OpCommutativeMonoid1OLTerm n
      opOL :
        OpCommutativeMonoid1OLTerm n ->
        OpCommutativeMonoid1OLTerm n ->
        OpCommutativeMonoid1OLTerm n
    data OpCommutativeMonoid1OL2Term2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpCommutativeMonoid1OL2Term2 n A
      sing2 :
        A ->
        OpCommutativeMonoid1OL2Term2 n A
      1OL2 :
        OpCommutativeMonoid1OL2Term2 n A
      opOL2 :
        OpCommutativeMonoid1OL2Term2 n
          A ->
        OpCommutativeMonoid1OL2Term2 n
          A ->
        OpCommutativeMonoid1OL2Term2 n A
    simplifyB :
      CommutativeMonoid1LTerm ->
      CommutativeMonoid1LTerm
    simplifyB (opL (1L) x) = x
    simplifyB (opL x (1L)) = x
    simplifyB (1L) = 1L
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClCommutativeMonoid1ClTerm A ->
      ClCommutativeMonoid1ClTerm A
    simplifyCl _ (opCl (1Cl) x) = x
    simplifyCl _ (opCl x (1Cl)) = x
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpCommutativeMonoid1OLTerm n ->
      OpCommutativeMonoid1OLTerm n
    simplifyOp _ (opOL (1OL) x) = x
    simplifyOp _ (opOL x (1OL)) = x
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpCommutativeMonoid1OL2Term2 n
        A ->
      OpCommutativeMonoid1OL2Term2 n A
    simplifyOpE _ _ (opOL2
                     (1OL2)
                     x) = x
    simplifyOpE _ _ (opOL2
                     x
                     (1OL2)) = x
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      CommutativeMonoid1 A ->
      CommutativeMonoid1LTerm -> A
    evalB _ Co (1L) = 1 Co
    evalB _ Co (opL x1 x2) =
      op Co (evalB _ Co x1)
        (evalB _ Co x2)
    evalCl :
      (A : Set) ->
      CommutativeMonoid1 A ->
      ClCommutativeMonoid1ClTerm A ->
      A
    evalCl _ Co (sing x1) = x1
    evalCl _ Co (1Cl) = 1 Co
    evalCl _ Co (opCl x1 x2) =
      op Co (evalCl _ Co x1)
        (evalCl _ Co x2)
    evalOp :
      (A : Set) (n : Nat) ->
      CommutativeMonoid1 A ->
      Vec A n ->
      OpCommutativeMonoid1OLTerm n ->
      A
    evalOp _ n Co vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Co vars (1OL) = 1 Co
    evalOp _ n Co vars (opOL
                        x1
                        x2) =
      op Co (evalOp _ n Co vars x1)
        (evalOp _ n Co vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      CommutativeMonoid1 A ->
      Vec A n ->
      OpCommutativeMonoid1OL2Term2 n
        A -> A
    evalOpE _ n Co vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Co vars (sing2 x1) =
      x1
    evalOpE _ n Co vars (1OL2) =
      1 Co
    evalOpE _ n Co vars (opOL2
                         x1
                         x2) =
      op Co (evalOpE _ n Co vars x1)
        (evalOpE _ n Co vars x2)
    inductionB :
      (P : CommutativeMonoid1LTerm ->
           Set) ->
      P 1L ->
      ((x1 : CommutativeMonoid1LTerm)
       (x2 : CommutativeMonoid1LTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : CommutativeMonoid1LTerm) ->
      P x
    inductionB p p1l popl (1L) = p1l
    inductionB p p1l popl (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p p1l popl x1)
        (inductionB p p1l popl x2)
    inductionCl :
      (A : Set)
      (P : ClCommutativeMonoid1ClTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 1Cl ->
      ((x1 : ClCommutativeMonoid1ClTerm
          A)
       (x2 : ClCommutativeMonoid1ClTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClCommutativeMonoid1ClTerm
         A) -> P x
    inductionCl _ p psing p1cl popcl (sing
                                      x1) = psing x1
    inductionCl _ p psing p1cl popcl (1Cl) =
      p1cl
    inductionCl _ p psing p1cl popcl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing p1cl
           popcl
           x1)
        (inductionCl _ p psing p1cl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpCommutativeMonoid1OLTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 1OL ->
      ((x1 : OpCommutativeMonoid1OLTerm
          n)
       (x2 : OpCommutativeMonoid1OLTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpCommutativeMonoid1OLTerm
         n) -> P x
    inductionOp _ p pv p1ol popol (v
                                   x1) = pv x1
    inductionOp _ p pv p1ol popol (1OL) =
      p1ol
    inductionOp _ p pv p1ol popol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv p1ol popol
           x1)
        (inductionOp _ p pv p1ol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpCommutativeMonoid1OL2Term2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 1OL2 ->
      ((x1 : OpCommutativeMonoid1OL2Term2
          n
          A)
       (x2 : OpCommutativeMonoid1OL2Term2
          n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpCommutativeMonoid1OL2Term2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p1ol2 popol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p1ol2 popol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p1ol2 popol2 (1OL2) =
      p1ol2
    inductionOpE _ _ p pv2 psing2 p1ol2 popol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p1ol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p1ol2
           popol2
           x2)
    1L' : CommutativeMonoid1LTerm
    1L' = 1L
    opL' :
      CommutativeMonoid1LTerm ->
      CommutativeMonoid1LTerm ->
      CommutativeMonoid1LTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      CommutativeMonoid1LTerm ->
      Staged CommutativeMonoid1LTerm
    stageB (1L) = Now 1L
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    1Cl' :
      (A : Set) ->
      ClCommutativeMonoid1ClTerm A
    1Cl' _ = 1Cl
    opCl' :
      (A : Set) ->
      ClCommutativeMonoid1ClTerm A ->
      ClCommutativeMonoid1ClTerm A ->
      ClCommutativeMonoid1ClTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClCommutativeMonoid1ClTerm A ->
      Staged
        (ClCommutativeMonoid1ClTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (1Cl) = Now 1Cl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    1OL' :
      (n : Nat) ->
      OpCommutativeMonoid1OLTerm n
    1OL' _ = 1OL
    opOL' :
      (n : Nat) ->
      OpCommutativeMonoid1OLTerm n ->
      OpCommutativeMonoid1OLTerm n ->
      OpCommutativeMonoid1OLTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpCommutativeMonoid1OLTerm n ->
      Staged
        (OpCommutativeMonoid1OLTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (1OL) = Now 1OL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    1OL2' :
      (n : Nat) (A : Set) ->
      OpCommutativeMonoid1OL2Term2 n A
    1OL2' _ _ = 1OL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpCommutativeMonoid1OL2Term2 n
        A ->
      OpCommutativeMonoid1OL2Term2 n
        A ->
      OpCommutativeMonoid1OL2Term2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpCommutativeMonoid1OL2Term2 n
        A ->
      Staged
        (OpCommutativeMonoid1OL2Term2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (1OL2) = Now 1OL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record CommutativeMonoid1Tagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        1T : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module CommutativePointedMagma where
    record CommutativePointedMagma
      (A : Set) : Set where
      constructor CommutativePointedMagmaC
      field
        op : A -> A -> A
        e : A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record CommutativePointedMagmaSig
      (AS : Set) : Set where
      constructor CommutativePointedMagmaSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record CommutativePointedMagmaProd
      (AP : Set) : Set where
      constructor CommutativePointedMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record CommutativePointedMagmaHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativePointedMagma
         A1)
      (Co2 : CommutativePointedMagma
         A2) : Set where
      constructor CommutativePointedMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
        pres-e : hom (e Co1) == e Co2
    record CommutativePointedMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativePointedMagma
         A1)
      (Co2 : CommutativePointedMagma
         A2) : Set where
      constructor CommutativePointedMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
        interp-e :
          interp (e Co1) (e Co2)
    data CommutativePointedMagmaTerm
      : Set where
      opL :
        CommutativePointedMagmaTerm ->
        CommutativePointedMagmaTerm ->
        CommutativePointedMagmaTerm
      eL : CommutativePointedMagmaTerm
    data ClCommutativePointedMagmaTerm
      (A : Set) : Set where
      sing :
        A ->
        ClCommutativePointedMagmaTerm A
      opCl :
        ClCommutativePointedMagmaTerm
          A ->
        ClCommutativePointedMagmaTerm
          A ->
        ClCommutativePointedMagmaTerm A
      eCl :
        ClCommutativePointedMagmaTerm A
    data OpCommutativePointedMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpCommutativePointedMagmaTerm n
      opOL :
        OpCommutativePointedMagmaTerm
          n ->
        OpCommutativePointedMagmaTerm
          n ->
        OpCommutativePointedMagmaTerm n
      eOL :
        OpCommutativePointedMagmaTerm n
    data OpCommutativePointedMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpCommutativePointedMagmaTerm2 n
          A
      sing2 :
        A ->
        OpCommutativePointedMagmaTerm2 n
          A
      opOL2 :
        OpCommutativePointedMagmaTerm2 n
          A ->
        OpCommutativePointedMagmaTerm2 n
          A ->
        OpCommutativePointedMagmaTerm2 n
          A
      eOL2 :
        OpCommutativePointedMagmaTerm2 n
          A
    simplifyB :
      CommutativePointedMagmaTerm ->
      CommutativePointedMagmaTerm
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (eL) = eL
    simplifyCl :
      (A : Set) ->
      ClCommutativePointedMagmaTerm
        A ->
      ClCommutativePointedMagmaTerm A
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpCommutativePointedMagmaTerm
        n ->
      OpCommutativePointedMagmaTerm n
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpCommutativePointedMagmaTerm2 n
        A ->
      OpCommutativePointedMagmaTerm2 n
        A
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      CommutativePointedMagma A ->
      CommutativePointedMagmaTerm -> A
    evalB _ Co (opL x1 x2) =
      op Co (evalB _ Co x1)
        (evalB _ Co x2)
    evalB _ Co (eL) = e Co
    evalCl :
      (A : Set) ->
      CommutativePointedMagma A ->
      ClCommutativePointedMagmaTerm
        A -> A
    evalCl _ Co (sing x1) = x1
    evalCl _ Co (opCl x1 x2) =
      op Co (evalCl _ Co x1)
        (evalCl _ Co x2)
    evalCl _ Co (eCl) = e Co
    evalOp :
      (A : Set) (n : Nat) ->
      CommutativePointedMagma A ->
      Vec A n ->
      OpCommutativePointedMagmaTerm
        n -> A
    evalOp _ n Co vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Co vars (opOL
                        x1
                        x2) =
      op Co (evalOp _ n Co vars x1)
        (evalOp _ n Co vars x2)
    evalOp _ n Co vars (eOL) = e Co
    evalOpE :
      (A : Set) (n : Nat) ->
      CommutativePointedMagma A ->
      Vec A n ->
      OpCommutativePointedMagmaTerm2 n
        A -> A
    evalOpE _ n Co vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Co vars (sing2 x1) =
      x1
    evalOpE _ n Co vars (opOL2
                         x1
                         x2) =
      op Co (evalOpE _ n Co vars x1)
        (evalOpE _ n Co vars x2)
    evalOpE _ n Co vars (eOL2) =
      e Co
    inductionB :
      (P : CommutativePointedMagmaTerm ->
           Set) ->
      ((x1 : CommutativePointedMagmaTerm)
       (x2 : CommutativePointedMagmaTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      P eL ->
      (x : CommutativePointedMagmaTerm) ->
      P x
    inductionB p popl pel (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p popl pel x1)
        (inductionB p popl pel x2)
    inductionB p popl pel (eL) = pel
    inductionCl :
      (A : Set)
      (P : ClCommutativePointedMagmaTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClCommutativePointedMagmaTerm
          A)
       (x2 : ClCommutativePointedMagmaTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      P eCl ->
      (x : ClCommutativePointedMagmaTerm
         A) -> P x
    inductionCl _ p psing popcl pecl (sing
                                      x1) = psing x1
    inductionCl _ p psing popcl pecl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing popcl
           pecl
           x1)
        (inductionCl _ p psing popcl
           pecl
           x2)
    inductionCl _ p psing popcl pecl (eCl) =
      pecl
    inductionOp :
      (n : Nat)
      (P : OpCommutativePointedMagmaTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpCommutativePointedMagmaTerm
          n)
       (x2 : OpCommutativePointedMagmaTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      P eOL ->
      (x : OpCommutativePointedMagmaTerm
         n) -> P x
    inductionOp _ p pv popol peol (v
                                   x1) = pv x1
    inductionOp _ p pv popol peol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv popol peol
           x1)
        (inductionOp _ p pv popol peol
           x2)
    inductionOp _ p pv popol peol (eOL) =
      peol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpCommutativePointedMagmaTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpCommutativePointedMagmaTerm2
          n
          A)
       (x2 : OpCommutativePointedMagmaTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      P eOL2 ->
      (x : OpCommutativePointedMagmaTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (eOL2) =
      peol2
    opL' :
      CommutativePointedMagmaTerm ->
      CommutativePointedMagmaTerm ->
      CommutativePointedMagmaTerm
    opL' x1 x2 = opL x1 x2
    eL' :
      CommutativePointedMagmaTerm
    eL' = eL
    stageB :
      CommutativePointedMagmaTerm ->
      Staged
        CommutativePointedMagmaTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (eL) = Now eL
    opCl' :
      (A : Set) ->
      ClCommutativePointedMagmaTerm
        A ->
      ClCommutativePointedMagmaTerm
        A ->
      ClCommutativePointedMagmaTerm A
    opCl' _ x1 x2 = opCl x1 x2
    eCl' :
      (A : Set) ->
      ClCommutativePointedMagmaTerm A
    eCl' _ = eCl
    stageCl :
      (A : Set) ->
      ClCommutativePointedMagmaTerm
        A ->
      Staged
        (ClCommutativePointedMagmaTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (eCl) = Now eCl
    opOL' :
      (n : Nat) ->
      OpCommutativePointedMagmaTerm
        n ->
      OpCommutativePointedMagmaTerm
        n ->
      OpCommutativePointedMagmaTerm n
    opOL' _ x1 x2 = opOL x1 x2
    eOL' :
      (n : Nat) ->
      OpCommutativePointedMagmaTerm n
    eOL' _ = eOL
    stageOp :
      (n : Nat) ->
      OpCommutativePointedMagmaTerm
        n ->
      Staged
        (OpCommutativePointedMagmaTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (eOL) = Now eOL
    opOL2' :
      (n : Nat) (A : Set) ->
      OpCommutativePointedMagmaTerm2 n
        A ->
      OpCommutativePointedMagmaTerm2 n
        A ->
      OpCommutativePointedMagmaTerm2 n
        A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    eOL2' :
      (n : Nat) (A : Set) ->
      OpCommutativePointedMagmaTerm2 n
        A
    eOL2' _ _ = eOL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpCommutativePointedMagmaTerm2 n
        A ->
      Staged
        (OpCommutativePointedMagmaTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (eOL2) = Now eOL2
    record CommutativePointedMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
        eT : Repr A
  
  module CommutativeRing where
    record CommutativeRing
      (A : Set) : Set where
      constructor CommutativeRingC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
    record CommutativeRingSig
      (AS : Set) : Set where
      constructor CommutativeRingSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
    record CommutativeRingProd
      (AP : Set) : Set where
      constructor CommutativeRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
    record CommutativeRingHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeRing A1)
      (Co2 : CommutativeRing A2) :
      Set where
      constructor CommutativeRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Co1 x1 x2) ==
            * Co2 (hom x1) (hom x2)
        pres-1 : hom (1 Co1) == 1 Co2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Co1 x1 x2) ==
            + Co2 (hom x1) (hom x2)
        pres-0 : hom (0 Co1) == 0 Co2
        pres-neg :
          (x1 : A1) ->
          hom (neg Co1 x1) ==
            neg Co2 (hom x1)
    record CommutativeRingRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeRing A1)
      (Co2 : CommutativeRing A2) :
      Set where
      constructor CommutativeRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Co1 x1 x2)
            (* Co2 y1 y2)
        interp-1 :
          interp (1 Co1) (1 Co2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Co1 x1 x2)
            (+ Co2 y1 y2)
        interp-0 :
          interp (0 Co1) (0 Co2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Co1 x1) (neg Co2 y1)
    data CommutativeRingTerm
      : Set where
      *L :
        CommutativeRingTerm ->
        CommutativeRingTerm ->
        CommutativeRingTerm
      1L : CommutativeRingTerm
      +L :
        CommutativeRingTerm ->
        CommutativeRingTerm ->
        CommutativeRingTerm
      0L : CommutativeRingTerm
      negL :
        CommutativeRingTerm ->
        CommutativeRingTerm
    data ClCommutativeRingTerm
      (A : Set) : Set where
      sing :
        A -> ClCommutativeRingTerm A
      *Cl :
        ClCommutativeRingTerm A ->
        ClCommutativeRingTerm A ->
        ClCommutativeRingTerm A
      1Cl : ClCommutativeRingTerm A
      +Cl :
        ClCommutativeRingTerm A ->
        ClCommutativeRingTerm A ->
        ClCommutativeRingTerm A
      0Cl : ClCommutativeRingTerm A
      negCl :
        ClCommutativeRingTerm A ->
        ClCommutativeRingTerm A
    data OpCommutativeRingTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpCommutativeRingTerm n
      *OL :
        OpCommutativeRingTerm n ->
        OpCommutativeRingTerm n ->
        OpCommutativeRingTerm n
      1OL : OpCommutativeRingTerm n
      +OL :
        OpCommutativeRingTerm n ->
        OpCommutativeRingTerm n ->
        OpCommutativeRingTerm n
      0OL : OpCommutativeRingTerm n
      negOL :
        OpCommutativeRingTerm n ->
        OpCommutativeRingTerm n
    data OpCommutativeRingTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpCommutativeRingTerm2 n A
      sing2 :
        A -> OpCommutativeRingTerm2 n A
      *OL2 :
        OpCommutativeRingTerm2 n A ->
        OpCommutativeRingTerm2 n A ->
        OpCommutativeRingTerm2 n A
      1OL2 :
        OpCommutativeRingTerm2 n A
      +OL2 :
        OpCommutativeRingTerm2 n A ->
        OpCommutativeRingTerm2 n A ->
        OpCommutativeRingTerm2 n A
      0OL2 :
        OpCommutativeRingTerm2 n A
      negOL2 :
        OpCommutativeRingTerm2 n A ->
        OpCommutativeRingTerm2 n A
    simplifyB :
      CommutativeRingTerm ->
      CommutativeRingTerm
    simplifyB (*L (1L) x) = x
    simplifyB (*L x (1L)) = x
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (+L
               (*L x y)
               (*L x z)) = *L x (+L y z)
    simplifyB (+L
               (*L y x)
               (*L z x)) = *L (+L y z) x
    simplifyB (+L x (negL x)) = 0L
    simplifyB (+L (negL x) x) = 0L
    simplifyB (*L (0L) x) = 0L
    simplifyB (*L x (0L)) = 0L
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (1L) = 1L
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (0L) = 0L
    simplifyB (negL x1) =
      negL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClCommutativeRingTerm A ->
      ClCommutativeRingTerm A
    simplifyCl _ (*Cl (1Cl) x) = x
    simplifyCl _ (*Cl x (1Cl)) = x
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (+Cl
                  (*Cl x y)
                  (*Cl x z)) = *Cl x (+Cl y z)
    simplifyCl _ (+Cl
                  (*Cl y x)
                  (*Cl z x)) = *Cl (+Cl y z) x
    simplifyCl _ (+Cl x (negCl x)) =
      0Cl
    simplifyCl _ (+Cl (negCl x) x) =
      0Cl
    simplifyCl _ (*Cl (0Cl) x) = 0Cl
    simplifyCl _ (*Cl x (0Cl)) = 0Cl
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (negCl x1) =
      negCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpCommutativeRingTerm n ->
      OpCommutativeRingTerm n
    simplifyOp _ (*OL (1OL) x) = x
    simplifyOp _ (*OL x (1OL)) = x
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (+OL
                  (*OL x y)
                  (*OL x z)) = *OL x (+OL y z)
    simplifyOp _ (+OL
                  (*OL y x)
                  (*OL z x)) = *OL (+OL y z) x
    simplifyOp _ (+OL x (negOL x)) =
      0OL
    simplifyOp _ (+OL (negOL x) x) =
      0OL
    simplifyOp _ (*OL (0OL) x) = 0OL
    simplifyOp _ (*OL x (0OL)) = 0OL
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (negOL x1) =
      negOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpCommutativeRingTerm2 n A ->
      OpCommutativeRingTerm2 n A
    simplifyOpE _ _ (*OL2
                     (1OL2)
                     x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (1OL2)) = x
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (+OL2
                     (*OL2 x y)
                     (*OL2 x z)) = *OL2 x (+OL2 y z)
    simplifyOpE _ _ (+OL2
                     (*OL2 y x)
                     (*OL2 z x)) = *OL2 (+OL2 y z) x
    simplifyOpE _ _ (+OL2
                     x
                     (negOL2 x)) = 0OL2
    simplifyOpE _ _ (+OL2
                     (negOL2 x)
                     x) = 0OL2
    simplifyOpE _ _ (*OL2
                     (0OL2)
                     x) = 0OL2
    simplifyOpE _ _ (*OL2
                     x
                     (0OL2)) = 0OL2
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (negOL2 x1) =
      negOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      CommutativeRing A ->
      CommutativeRingTerm -> A
    evalB _ Co (*L x1 x2) =
      * Co (evalB _ Co x1)
        (evalB _ Co x2)
    evalB _ Co (1L) = 1 Co
    evalB _ Co (+L x1 x2) =
      + Co (evalB _ Co x1)
        (evalB _ Co x2)
    evalB _ Co (0L) = 0 Co
    evalB _ Co (negL x1) =
      neg Co (evalB _ Co x1)
    evalCl :
      (A : Set) ->
      CommutativeRing A ->
      ClCommutativeRingTerm A -> A
    evalCl _ Co (sing x1) = x1
    evalCl _ Co (*Cl x1 x2) =
      * Co (evalCl _ Co x1)
        (evalCl _ Co x2)
    evalCl _ Co (1Cl) = 1 Co
    evalCl _ Co (+Cl x1 x2) =
      + Co (evalCl _ Co x1)
        (evalCl _ Co x2)
    evalCl _ Co (0Cl) = 0 Co
    evalCl _ Co (negCl x1) =
      neg Co (evalCl _ Co x1)
    evalOp :
      (A : Set) (n : Nat) ->
      CommutativeRing A ->
      Vec A n ->
      OpCommutativeRingTerm n -> A
    evalOp _ n Co vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Co vars (*OL x1 x2) =
      * Co (evalOp _ n Co vars x1)
        (evalOp _ n Co vars x2)
    evalOp _ n Co vars (1OL) = 1 Co
    evalOp _ n Co vars (+OL x1 x2) =
      + Co (evalOp _ n Co vars x1)
        (evalOp _ n Co vars x2)
    evalOp _ n Co vars (0OL) = 0 Co
    evalOp _ n Co vars (negOL x1) =
      neg Co (evalOp _ n Co vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      CommutativeRing A ->
      Vec A n ->
      OpCommutativeRingTerm2 n A -> A
    evalOpE _ n Co vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Co vars (sing2 x1) =
      x1
    evalOpE _ n Co vars (*OL2
                         x1
                         x2) =
      * Co (evalOpE _ n Co vars x1)
        (evalOpE _ n Co vars x2)
    evalOpE _ n Co vars (1OL2) =
      1 Co
    evalOpE _ n Co vars (+OL2
                         x1
                         x2) =
      + Co (evalOpE _ n Co vars x1)
        (evalOpE _ n Co vars x2)
    evalOpE _ n Co vars (0OL2) =
      0 Co
    evalOpE _ n Co vars (negOL2
                         x1) =
      neg Co (evalOpE _ n Co vars x1)
    inductionB :
      (P : CommutativeRingTerm ->
           Set) ->
      ((x1 : CommutativeRingTerm)
       (x2 : CommutativeRingTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      P 1L ->
      ((x1 : CommutativeRingTerm)
       (x2 : CommutativeRingTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      P 0L ->
      ((x1 : CommutativeRingTerm) ->
       P x1 -> P (negL x1)) ->
      (x : CommutativeRingTerm) -> P x
    inductionB p p*l p1l p+l p0l pnegl (*L
                                        x1
                                        x2) =
      p*l _ _
        (inductionB p p*l p1l p+l p0l
           pnegl
           x1)
        (inductionB p p*l p1l p+l p0l
           pnegl
           x2)
    inductionB p p*l p1l p+l p0l pnegl (1L) =
      p1l
    inductionB p p*l p1l p+l p0l pnegl (+L
                                        x1
                                        x2) =
      p+l _ _
        (inductionB p p*l p1l p+l p0l
           pnegl
           x1)
        (inductionB p p*l p1l p+l p0l
           pnegl
           x2)
    inductionB p p*l p1l p+l p0l pnegl (0L) =
      p0l
    inductionB p p*l p1l p+l p0l pnegl (negL
                                        x1) =
      pnegl _
        (inductionB p p*l p1l p+l p0l
           pnegl
           x1)
    inductionCl :
      (A : Set)
      (P : ClCommutativeRingTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClCommutativeRingTerm A)
       (x2 : ClCommutativeRingTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      P 1Cl ->
      ((x1 : ClCommutativeRingTerm A)
       (x2 : ClCommutativeRingTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      P 0Cl ->
      ((x1 : ClCommutativeRingTerm
          A) -> P x1 -> P (negCl x1)) ->
      (x : ClCommutativeRingTerm A) ->
      P x
    inductionCl _ p psing p*cl p1cl p+cl p0cl pnegcl (sing
                                                      x1) = psing x1
    inductionCl _ p psing p*cl p1cl p+cl p0cl pnegcl (*Cl
                                                      x1
                                                      x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p1cl
           p+cl
           p0cl
           pnegcl
           x1)
        (inductionCl _ p psing p*cl p1cl
           p+cl
           p0cl
           pnegcl
           x2)
    inductionCl _ p psing p*cl p1cl p+cl p0cl pnegcl (1Cl) =
      p1cl
    inductionCl _ p psing p*cl p1cl p+cl p0cl pnegcl (+Cl
                                                      x1
                                                      x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p1cl
           p+cl
           p0cl
           pnegcl
           x1)
        (inductionCl _ p psing p*cl p1cl
           p+cl
           p0cl
           pnegcl
           x2)
    inductionCl _ p psing p*cl p1cl p+cl p0cl pnegcl (0Cl) =
      p0cl
    inductionCl _ p psing p*cl p1cl p+cl p0cl pnegcl (negCl
                                                      x1) =
      pnegcl _
        (inductionCl _ p psing p*cl p1cl
           p+cl
           p0cl
           pnegcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpCommutativeRingTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpCommutativeRingTerm n)
       (x2 : OpCommutativeRingTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      P 1OL ->
      ((x1 : OpCommutativeRingTerm n)
       (x2 : OpCommutativeRingTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      P 0OL ->
      ((x1 : OpCommutativeRingTerm
          n) -> P x1 -> P (negOL x1)) ->
      (x : OpCommutativeRingTerm n) ->
      P x
    inductionOp _ p pv p*ol p1ol p+ol p0ol pnegol (v
                                                   x1) = pv x1
    inductionOp _ p pv p*ol p1ol p+ol p0ol pnegol (*OL
                                                   x1
                                                   x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p1ol
           p+ol
           p0ol
           pnegol
           x1)
        (inductionOp _ p pv p*ol p1ol
           p+ol
           p0ol
           pnegol
           x2)
    inductionOp _ p pv p*ol p1ol p+ol p0ol pnegol (1OL) =
      p1ol
    inductionOp _ p pv p*ol p1ol p+ol p0ol pnegol (+OL
                                                   x1
                                                   x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p1ol
           p+ol
           p0ol
           pnegol
           x1)
        (inductionOp _ p pv p*ol p1ol
           p+ol
           p0ol
           pnegol
           x2)
    inductionOp _ p pv p*ol p1ol p+ol p0ol pnegol (0OL) =
      p0ol
    inductionOp _ p pv p*ol p1ol p+ol p0ol pnegol (negOL
                                                   x1) =
      pnegol _
        (inductionOp _ p pv p*ol p1ol
           p+ol
           p0ol
           pnegol
           x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpCommutativeRingTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpCommutativeRingTerm2 n
          A)
       (x2 : OpCommutativeRingTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      P 1OL2 ->
      ((x1 : OpCommutativeRingTerm2 n
          A)
       (x2 : OpCommutativeRingTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      P 0OL2 ->
      ((x1 : OpCommutativeRingTerm2 n
          A) -> P x1 -> P (negOL2 x1)) ->
      (x : OpCommutativeRingTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 pnegol2 (v2
                                                                   x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 pnegol2 (sing2
                                                                   x1) =
      psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 pnegol2 (*OL2
                                                                   x1
                                                                   x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           p+ol2
           p0ol2
           pnegol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           p+ol2
           p0ol2
           pnegol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 pnegol2 (1OL2) =
      p1ol2
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 pnegol2 (+OL2
                                                                   x1
                                                                   x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           p+ol2
           p0ol2
           pnegol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           p+ol2
           p0ol2
           pnegol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 pnegol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 pnegol2 (negOL2
                                                                   x1) =
      pnegol2 _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           p+ol2
           p0ol2
           pnegol2
           x1)
    *L' :
      CommutativeRingTerm ->
      CommutativeRingTerm ->
      CommutativeRingTerm
    *L' x1 x2 = *L x1 x2
    1L' : CommutativeRingTerm
    1L' = 1L
    +L' :
      CommutativeRingTerm ->
      CommutativeRingTerm ->
      CommutativeRingTerm
    +L' x1 x2 = +L x1 x2
    0L' : CommutativeRingTerm
    0L' = 0L
    negL' :
      CommutativeRingTerm ->
      CommutativeRingTerm
    negL' x1 = negL x1
    stageB :
      CommutativeRingTerm ->
      Staged CommutativeRingTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (1L) = Now 1L
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (0L) = Now 0L
    stageB (negL x1) =
      stage1 _ _ negL'
        (codeLift1 _ _ negL')
        (stageB x1)
    *Cl' :
      (A : Set) ->
      ClCommutativeRingTerm A ->
      ClCommutativeRingTerm A ->
      ClCommutativeRingTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    1Cl' :
      (A : Set) ->
      ClCommutativeRingTerm A
    1Cl' _ = 1Cl
    +Cl' :
      (A : Set) ->
      ClCommutativeRingTerm A ->
      ClCommutativeRingTerm A ->
      ClCommutativeRingTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    0Cl' :
      (A : Set) ->
      ClCommutativeRingTerm A
    0Cl' _ = 0Cl
    negCl' :
      (A : Set) ->
      ClCommutativeRingTerm A ->
      ClCommutativeRingTerm A
    negCl' _ x1 = negCl x1
    stageCl :
      (A : Set) ->
      ClCommutativeRingTerm A ->
      Staged (ClCommutativeRingTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (1Cl) = Now 1Cl
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (negCl x1) =
      stage1 _ _ (negCl' _)
        (codeLift1 _ _ (negCl' _))
        (stageCl _ x1)
    *OL' :
      (n : Nat) ->
      OpCommutativeRingTerm n ->
      OpCommutativeRingTerm n ->
      OpCommutativeRingTerm n
    *OL' _ x1 x2 = *OL x1 x2
    1OL' :
      (n : Nat) ->
      OpCommutativeRingTerm n
    1OL' _ = 1OL
    +OL' :
      (n : Nat) ->
      OpCommutativeRingTerm n ->
      OpCommutativeRingTerm n ->
      OpCommutativeRingTerm n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      OpCommutativeRingTerm n
    0OL' _ = 0OL
    negOL' :
      (n : Nat) ->
      OpCommutativeRingTerm n ->
      OpCommutativeRingTerm n
    negOL' _ x1 = negOL x1
    stageOp :
      (n : Nat) ->
      OpCommutativeRingTerm n ->
      Staged (OpCommutativeRingTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (1OL) = Now 1OL
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (0OL) = Now 0OL
    stageOp _ (negOL x1) =
      stage1 _ _ (negOL' _)
        (codeLift1 _ _ (negOL' _))
        (stageOp _ x1)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpCommutativeRingTerm2 n A ->
      OpCommutativeRingTerm2 n A ->
      OpCommutativeRingTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    1OL2' :
      (n : Nat) (A : Set) ->
      OpCommutativeRingTerm2 n A
    1OL2' _ _ = 1OL2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpCommutativeRingTerm2 n A ->
      OpCommutativeRingTerm2 n A ->
      OpCommutativeRingTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    0OL2' :
      (n : Nat) (A : Set) ->
      OpCommutativeRingTerm2 n A
    0OL2' _ _ = 0OL2
    negOL2' :
      (n : Nat) (A : Set) ->
      OpCommutativeRingTerm2 n A ->
      OpCommutativeRingTerm2 n A
    negOL2' _ _ x1 = negOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpCommutativeRingTerm2 n A ->
      Staged
        (OpCommutativeRingTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (1OL2) = Now 1OL2
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (negOL2 x1) =
      stage1 _ _ (negOL2' _ _)
        (codeLift1 _ _ (negOL2' _ _))
        (stageOpE _ _ x1)
    record CommutativeRingTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        1T : Repr A
        +T : Repr A -> Repr A -> Repr A
        0T : Repr A
        negT : Repr A -> Repr A
  
  module CommutativeSemigroup where
    record CommutativeSemigroup
      (A : Set) : Set where
      constructor CommutativeSemigroupC
      field
        op : A -> A -> A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record CommutativeSemigroupSig
      (AS : Set) : Set where
      constructor CommutativeSemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record CommutativeSemigroupProd
      (AP : Set) : Set where
      constructor CommutativeSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record CommutativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeSemigroup A1)
      (Co2 : CommutativeSemigroup
         A2) : Set where
      constructor CommutativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Co1 x1 x2) ==
            op Co2 (hom x1) (hom x2)
    record CommutativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : CommutativeSemigroup A1)
      (Co2 : CommutativeSemigroup
         A2) : Set where
      constructor CommutativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Co1 x1 x2)
            (op Co2 y1 y2)
    data CommutativeSemigroupTerm
      : Set where
      opL :
        CommutativeSemigroupTerm ->
        CommutativeSemigroupTerm ->
        CommutativeSemigroupTerm
    data ClCommutativeSemigroupTerm
      (A : Set) : Set where
      sing :
        A ->
        ClCommutativeSemigroupTerm A
      opCl :
        ClCommutativeSemigroupTerm A ->
        ClCommutativeSemigroupTerm A ->
        ClCommutativeSemigroupTerm A
    data OpCommutativeSemigroupTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpCommutativeSemigroupTerm n
      opOL :
        OpCommutativeSemigroupTerm n ->
        OpCommutativeSemigroupTerm n ->
        OpCommutativeSemigroupTerm n
    data OpCommutativeSemigroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpCommutativeSemigroupTerm2 n A
      sing2 :
        A ->
        OpCommutativeSemigroupTerm2 n A
      opOL2 :
        OpCommutativeSemigroupTerm2 n
          A ->
        OpCommutativeSemigroupTerm2 n
          A ->
        OpCommutativeSemigroupTerm2 n A
    simplifyB :
      CommutativeSemigroupTerm ->
      CommutativeSemigroupTerm
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClCommutativeSemigroupTerm A ->
      ClCommutativeSemigroupTerm A
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpCommutativeSemigroupTerm n ->
      OpCommutativeSemigroupTerm n
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpCommutativeSemigroupTerm2 n
        A ->
      OpCommutativeSemigroupTerm2 n A
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      CommutativeSemigroup A ->
      CommutativeSemigroupTerm -> A
    evalB _ Co (opL x1 x2) =
      op Co (evalB _ Co x1)
        (evalB _ Co x2)
    evalCl :
      (A : Set) ->
      CommutativeSemigroup A ->
      ClCommutativeSemigroupTerm A ->
      A
    evalCl _ Co (sing x1) = x1
    evalCl _ Co (opCl x1 x2) =
      op Co (evalCl _ Co x1)
        (evalCl _ Co x2)
    evalOp :
      (A : Set) (n : Nat) ->
      CommutativeSemigroup A ->
      Vec A n ->
      OpCommutativeSemigroupTerm n ->
      A
    evalOp _ n Co vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Co vars (opOL
                        x1
                        x2) =
      op Co (evalOp _ n Co vars x1)
        (evalOp _ n Co vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      CommutativeSemigroup A ->
      Vec A n ->
      OpCommutativeSemigroupTerm2 n
        A -> A
    evalOpE _ n Co vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Co vars (sing2 x1) =
      x1
    evalOpE _ n Co vars (opOL2
                         x1
                         x2) =
      op Co (evalOpE _ n Co vars x1)
        (evalOpE _ n Co vars x2)
    inductionB :
      (P : CommutativeSemigroupTerm ->
           Set) ->
      ((x1 : CommutativeSemigroupTerm)
       (x2 : CommutativeSemigroupTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : CommutativeSemigroupTerm) ->
      P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClCommutativeSemigroupTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClCommutativeSemigroupTerm
          A)
       (x2 : ClCommutativeSemigroupTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClCommutativeSemigroupTerm
         A) -> P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpCommutativeSemigroupTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpCommutativeSemigroupTerm
          n)
       (x2 : OpCommutativeSemigroupTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpCommutativeSemigroupTerm
         n) -> P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpCommutativeSemigroupTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpCommutativeSemigroupTerm2
          n
          A)
       (x2 : OpCommutativeSemigroupTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpCommutativeSemigroupTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      CommutativeSemigroupTerm ->
      CommutativeSemigroupTerm ->
      CommutativeSemigroupTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      CommutativeSemigroupTerm ->
      Staged CommutativeSemigroupTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClCommutativeSemigroupTerm A ->
      ClCommutativeSemigroupTerm A ->
      ClCommutativeSemigroupTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClCommutativeSemigroupTerm A ->
      Staged
        (ClCommutativeSemigroupTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpCommutativeSemigroupTerm n ->
      OpCommutativeSemigroupTerm n ->
      OpCommutativeSemigroupTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpCommutativeSemigroupTerm n ->
      Staged
        (OpCommutativeSemigroupTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpCommutativeSemigroupTerm2 n
        A ->
      OpCommutativeSemigroupTerm2 n
        A ->
      OpCommutativeSemigroupTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpCommutativeSemigroupTerm2 n
        A ->
      Staged
        (OpCommutativeSemigroupTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record CommutativeSemigroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module ComplementSig where
    record ComplementSig
      (A : Set) : Set where
      constructor ComplementSigC
      field
        compl : A -> A
    record ComplementSigSig
      (AS : Set) : Set where
      constructor ComplementSigSigSigC
      field
        complS : AS -> AS
    record ComplementSigProd
      (AP : Set) : Set where
      constructor ComplementSigProdC
      field
        complP :
          Prod AP AP -> Prod AP AP
    record ComplementSigHom
      (A1 : Set) (A2 : Set)
      (Co1 : ComplementSig A1)
      (Co2 : ComplementSig A2) :
      Set where
      constructor ComplementSigHomC
      field
        hom : A1 -> A2
        pres-compl :
          (x1 : A1) ->
          hom (compl Co1 x1) ==
            compl Co2 (hom x1)
    record ComplementSigRelInterp
      (A1 : Set) (A2 : Set)
      (Co1 : ComplementSig A1)
      (Co2 : ComplementSig A2) :
      Set where
      constructor ComplementSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-compl :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (compl Co1 x1)
            (compl Co2 y1)
    data ComplementSigTerm
      : Set where
      complL :
        ComplementSigTerm ->
        ComplementSigTerm
    data ClComplementSigTerm
      (A : Set) : Set where
      sing :
        A -> ClComplementSigTerm A
      complCl :
        ClComplementSigTerm A ->
        ClComplementSigTerm A
    data OpComplementSigTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpComplementSigTerm n
      complOL :
        OpComplementSigTerm n ->
        OpComplementSigTerm n
    data OpComplementSigTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpComplementSigTerm2 n A
      sing2 :
        A -> OpComplementSigTerm2 n A
      complOL2 :
        OpComplementSigTerm2 n A ->
        OpComplementSigTerm2 n A
    simplifyB :
      ComplementSigTerm ->
      ComplementSigTerm
    simplifyB (complL x1) =
      complL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClComplementSigTerm A ->
      ClComplementSigTerm A
    simplifyCl _ (complCl x1) =
      complCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpComplementSigTerm n ->
      OpComplementSigTerm n
    simplifyOp _ (complOL x1) =
      complOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpComplementSigTerm2 n A ->
      OpComplementSigTerm2 n A
    simplifyOpE _ _ (complOL2 x1) =
      complOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      ComplementSig A ->
      ComplementSigTerm -> A
    evalB _ Co (complL x1) =
      compl Co (evalB _ Co x1)
    evalCl :
      (A : Set) ->
      ComplementSig A ->
      ClComplementSigTerm A -> A
    evalCl _ Co (sing x1) = x1
    evalCl _ Co (complCl x1) =
      compl Co (evalCl _ Co x1)
    evalOp :
      (A : Set) (n : Nat) ->
      ComplementSig A ->
      Vec A n ->
      OpComplementSigTerm n -> A
    evalOp _ n Co vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Co vars (complOL
                        x1) =
      compl Co (evalOp _ n Co vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      ComplementSig A ->
      Vec A n ->
      OpComplementSigTerm2 n A -> A
    evalOpE _ n Co vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Co vars (sing2 x1) =
      x1
    evalOpE _ n Co vars (complOL2
                         x1) =
      compl Co
        (evalOpE _ n Co vars x1)
    inductionB :
      (P : ComplementSigTerm ->
           Set) ->
      ((x1 : ComplementSigTerm) ->
       P x1 -> P (complL x1)) ->
      (x : ComplementSigTerm) -> P x
    inductionB p pcompll (complL
                          x1) =
      pcompll _
        (inductionB p pcompll x1)
    inductionCl :
      (A : Set)
      (P : ClComplementSigTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClComplementSigTerm A) ->
       P x1 -> P (complCl x1)) ->
      (x : ClComplementSigTerm A) ->
      P x
    inductionCl _ p psing pcomplcl (sing
                                    x1) = psing x1
    inductionCl _ p psing pcomplcl (complCl
                                    x1) =
      pcomplcl _
        (inductionCl _ p psing pcomplcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpComplementSigTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpComplementSigTerm n) ->
       P x1 -> P (complOL x1)) ->
      (x : OpComplementSigTerm n) ->
      P x
    inductionOp _ p pv pcomplol (v
                                 x1) = pv x1
    inductionOp _ p pv pcomplol (complOL
                                 x1) =
      pcomplol _
        (inductionOp _ p pv pcomplol x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpComplementSigTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpComplementSigTerm2 n
          A) ->
       P x1 -> P (complOL2 x1)) ->
      (x : OpComplementSigTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 pcomplol2 (v2
                                             x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pcomplol2 (sing2
                                             x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pcomplol2 (complOL2
                                             x1) =
      pcomplol2 _
        (inductionOpE _ _ p pv2 psing2
           pcomplol2
           x1)
    complL' :
      ComplementSigTerm ->
      ComplementSigTerm
    complL' x1 = complL x1
    stageB :
      ComplementSigTerm ->
      Staged ComplementSigTerm
    stageB (complL x1) =
      stage1 _ _ complL'
        (codeLift1 _ _ complL')
        (stageB x1)
    complCl' :
      (A : Set) ->
      ClComplementSigTerm A ->
      ClComplementSigTerm A
    complCl' _ x1 = complCl x1
    stageCl :
      (A : Set) ->
      ClComplementSigTerm A ->
      Staged (ClComplementSigTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (complCl x1) =
      stage1 _ _ (complCl' _)
        (codeLift1 _ _ (complCl' _))
        (stageCl _ x1)
    complOL' :
      (n : Nat) ->
      OpComplementSigTerm n ->
      OpComplementSigTerm n
    complOL' _ x1 = complOL x1
    stageOp :
      (n : Nat) ->
      OpComplementSigTerm n ->
      Staged (OpComplementSigTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (complOL x1) =
      stage1 _ _ (complOL' _)
        (codeLift1 _ _ (complOL' _))
        (stageOp _ x1)
    complOL2' :
      (n : Nat) (A : Set) ->
      OpComplementSigTerm2 n A ->
      OpComplementSigTerm2 n A
    complOL2' _ _ x1 = complOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpComplementSigTerm2 n A ->
      Staged
        (OpComplementSigTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (complOL2 x1) =
      stage1 _ _ (complOL2' _ _)
        (codeLift1 _ _ (complOL2' _ _))
        (stageOpE _ _ x1)
    record ComplementSigTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        complT : Repr A -> Repr A
  
  module DistributiveLattice where
    record DistributiveLattice
      (A : Set) : Set where
      constructor DistributiveLatticeC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
        leftModular_*_+ :
          (x : A) (y : A) (z : A) ->
          + (* x y) (* x z) ==
            * x (+ y (* x z))
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
    record DistributiveLatticeSig
      (AS : Set) : Set where
      constructor DistributiveLatticeSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record DistributiveLatticeProd
      (AP : Set) : Set where
      constructor DistributiveLatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
        leftModular_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (*P xP yP) (*P xP zP) ==
            *P xP (+P yP (*P xP zP))
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
    record DistributiveLatticeHom
      (A1 : Set) (A2 : Set)
      (Di1 : DistributiveLattice A1)
      (Di2 : DistributiveLattice A2) :
      Set where
      constructor DistributiveLatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Di1 x1 x2) ==
            * Di2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Di1 x1 x2) ==
            + Di2 (hom x1) (hom x2)
    record DistributiveLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Di1 : DistributiveLattice A1)
      (Di2 : DistributiveLattice A2) :
      Set where
      constructor DistributiveLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Di1 x1 x2)
            (* Di2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Di1 x1 x2)
            (+ Di2 y1 y2)
    data DistributiveLatticeTerm
      : Set where
      *L :
        DistributiveLatticeTerm ->
        DistributiveLatticeTerm ->
        DistributiveLatticeTerm
      +L :
        DistributiveLatticeTerm ->
        DistributiveLatticeTerm ->
        DistributiveLatticeTerm
    data ClDistributiveLatticeTerm
      (A : Set) : Set where
      sing :
        A -> ClDistributiveLatticeTerm A
      *Cl :
        ClDistributiveLatticeTerm A ->
        ClDistributiveLatticeTerm A ->
        ClDistributiveLatticeTerm A
      +Cl :
        ClDistributiveLatticeTerm A ->
        ClDistributiveLatticeTerm A ->
        ClDistributiveLatticeTerm A
    data OpDistributiveLatticeTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpDistributiveLatticeTerm n
      *OL :
        OpDistributiveLatticeTerm n ->
        OpDistributiveLatticeTerm n ->
        OpDistributiveLatticeTerm n
      +OL :
        OpDistributiveLatticeTerm n ->
        OpDistributiveLatticeTerm n ->
        OpDistributiveLatticeTerm n
    data OpDistributiveLatticeTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpDistributiveLatticeTerm2 n A
      sing2 :
        A ->
        OpDistributiveLatticeTerm2 n A
      *OL2 :
        OpDistributiveLatticeTerm2 n
          A ->
        OpDistributiveLatticeTerm2 n
          A ->
        OpDistributiveLatticeTerm2 n A
      +OL2 :
        OpDistributiveLatticeTerm2 n
          A ->
        OpDistributiveLatticeTerm2 n
          A ->
        OpDistributiveLatticeTerm2 n A
    simplifyB :
      DistributiveLatticeTerm ->
      DistributiveLatticeTerm
    simplifyB (*L x x) = x
    simplifyB (+L x x) = x
    simplifyB (*L x (+L x y)) = x
    simplifyB (+L x (*L x y)) = x
    simplifyB (+L
               (*L x y)
               (*L x z)) = *L x (+L y z)
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClDistributiveLatticeTerm A ->
      ClDistributiveLatticeTerm A
    simplifyCl _ (*Cl x x) = x
    simplifyCl _ (+Cl x x) = x
    simplifyCl _ (*Cl x (+Cl x y)) =
      x
    simplifyCl _ (+Cl x (*Cl x y)) =
      x
    simplifyCl _ (+Cl
                  (*Cl x y)
                  (*Cl x z)) = *Cl x (+Cl y z)
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpDistributiveLatticeTerm n ->
      OpDistributiveLatticeTerm n
    simplifyOp _ (*OL x x) = x
    simplifyOp _ (+OL x x) = x
    simplifyOp _ (*OL x (+OL x y)) =
      x
    simplifyOp _ (+OL x (*OL x y)) =
      x
    simplifyOp _ (+OL
                  (*OL x y)
                  (*OL x z)) = *OL x (+OL y z)
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpDistributiveLatticeTerm2 n
        A ->
      OpDistributiveLatticeTerm2 n A
    simplifyOpE _ _ (*OL2 x x) = x
    simplifyOpE _ _ (+OL2 x x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (+OL2 x y)) = x
    simplifyOpE _ _ (+OL2
                     x
                     (*OL2 x y)) = x
    simplifyOpE _ _ (+OL2
                     (*OL2 x y)
                     (*OL2 x z)) = *OL2 x (+OL2 y z)
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      DistributiveLattice A ->
      DistributiveLatticeTerm -> A
    evalB _ Di (*L x1 x2) =
      * Di (evalB _ Di x1)
        (evalB _ Di x2)
    evalB _ Di (+L x1 x2) =
      + Di (evalB _ Di x1)
        (evalB _ Di x2)
    evalCl :
      (A : Set) ->
      DistributiveLattice A ->
      ClDistributiveLatticeTerm A -> A
    evalCl _ Di (sing x1) = x1
    evalCl _ Di (*Cl x1 x2) =
      * Di (evalCl _ Di x1)
        (evalCl _ Di x2)
    evalCl _ Di (+Cl x1 x2) =
      + Di (evalCl _ Di x1)
        (evalCl _ Di x2)
    evalOp :
      (A : Set) (n : Nat) ->
      DistributiveLattice A ->
      Vec A n ->
      OpDistributiveLatticeTerm n -> A
    evalOp _ n Di vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Di vars (*OL x1 x2) =
      * Di (evalOp _ n Di vars x1)
        (evalOp _ n Di vars x2)
    evalOp _ n Di vars (+OL x1 x2) =
      + Di (evalOp _ n Di vars x1)
        (evalOp _ n Di vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      DistributiveLattice A ->
      Vec A n ->
      OpDistributiveLatticeTerm2 n
        A -> A
    evalOpE _ n Di vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Di vars (sing2 x1) =
      x1
    evalOpE _ n Di vars (*OL2
                         x1
                         x2) =
      * Di (evalOpE _ n Di vars x1)
        (evalOpE _ n Di vars x2)
    evalOpE _ n Di vars (+OL2
                         x1
                         x2) =
      + Di (evalOpE _ n Di vars x1)
        (evalOpE _ n Di vars x2)
    inductionB :
      (P : DistributiveLatticeTerm ->
           Set) ->
      ((x1 : DistributiveLatticeTerm)
       (x2 : DistributiveLatticeTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : DistributiveLatticeTerm)
       (x2 : DistributiveLatticeTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : DistributiveLatticeTerm) ->
      P x
    inductionB p p*l p+l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionB p p*l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClDistributiveLatticeTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClDistributiveLatticeTerm
          A)
       (x2 : ClDistributiveLatticeTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClDistributiveLatticeTerm
          A)
       (x2 : ClDistributiveLatticeTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClDistributiveLatticeTerm
         A) -> P x
    inductionCl _ p psing p*cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p*cl p+cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionCl _ p psing p*cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpDistributiveLatticeTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpDistributiveLatticeTerm
          n)
       (x2 : OpDistributiveLatticeTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpDistributiveLatticeTerm
          n)
       (x2 : OpDistributiveLatticeTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpDistributiveLatticeTerm
         n) -> P x
    inductionOp _ p pv p*ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p*ol p+ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOp _ p pv p*ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpDistributiveLatticeTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpDistributiveLatticeTerm2
          n
          A)
       (x2 : OpDistributiveLatticeTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpDistributiveLatticeTerm2
          n
          A)
       (x2 : OpDistributiveLatticeTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpDistributiveLatticeTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    *L' :
      DistributiveLatticeTerm ->
      DistributiveLatticeTerm ->
      DistributiveLatticeTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      DistributiveLatticeTerm ->
      DistributiveLatticeTerm ->
      DistributiveLatticeTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      DistributiveLatticeTerm ->
      Staged DistributiveLatticeTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClDistributiveLatticeTerm A ->
      ClDistributiveLatticeTerm A ->
      ClDistributiveLatticeTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClDistributiveLatticeTerm A ->
      ClDistributiveLatticeTerm A ->
      ClDistributiveLatticeTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClDistributiveLatticeTerm A ->
      Staged
        (ClDistributiveLatticeTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpDistributiveLatticeTerm n ->
      OpDistributiveLatticeTerm n ->
      OpDistributiveLatticeTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpDistributiveLatticeTerm n ->
      OpDistributiveLatticeTerm n ->
      OpDistributiveLatticeTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpDistributiveLatticeTerm n ->
      Staged
        (OpDistributiveLatticeTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpDistributiveLatticeTerm2 n
        A ->
      OpDistributiveLatticeTerm2 n
        A ->
      OpDistributiveLatticeTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpDistributiveLatticeTerm2 n
        A ->
      OpDistributiveLatticeTerm2 n
        A ->
      OpDistributiveLatticeTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpDistributiveLatticeTerm2 n
        A ->
      Staged
        (OpDistributiveLatticeTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record DistributiveLatticeTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module DoubleMonoid where
    record DoubleMonoid
      (A : Set) : Set where
      constructor DoubleMonoidC
      field
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
    record DoubleMonoidSig
      (AS : Set) : Set where
      constructor DoubleMonoidSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
        *S : AS -> AS -> AS
        1S : AS
    record DoubleMonoidProd
      (AP : Set) : Set where
      constructor DoubleMonoidProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
    record DoubleMonoidHom
      (A1 : Set) (A2 : Set)
      (Do1 : DoubleMonoid A1)
      (Do2 : DoubleMonoid A2) :
      Set where
      constructor DoubleMonoidHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Do1 x1 x2) ==
            + Do2 (hom x1) (hom x2)
        pres-0 : hom (0 Do1) == 0 Do2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Do1 x1 x2) ==
            * Do2 (hom x1) (hom x2)
        pres-1 : hom (1 Do1) == 1 Do2
    record DoubleMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Do1 : DoubleMonoid A1)
      (Do2 : DoubleMonoid A2) :
      Set where
      constructor DoubleMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Do1 x1 x2)
            (+ Do2 y1 y2)
        interp-0 :
          interp (0 Do1) (0 Do2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Do1 x1 x2)
            (* Do2 y1 y2)
        interp-1 :
          interp (1 Do1) (1 Do2)
    data DoubleMonoidTerm
      : Set where
      +L :
        DoubleMonoidTerm ->
        DoubleMonoidTerm ->
        DoubleMonoidTerm
      0L : DoubleMonoidTerm
      *L :
        DoubleMonoidTerm ->
        DoubleMonoidTerm ->
        DoubleMonoidTerm
      1L : DoubleMonoidTerm
    data ClDoubleMonoidTerm
      (A : Set) : Set where
      sing :
        A -> ClDoubleMonoidTerm A
      +Cl :
        ClDoubleMonoidTerm A ->
        ClDoubleMonoidTerm A ->
        ClDoubleMonoidTerm A
      0Cl : ClDoubleMonoidTerm A
      *Cl :
        ClDoubleMonoidTerm A ->
        ClDoubleMonoidTerm A ->
        ClDoubleMonoidTerm A
      1Cl : ClDoubleMonoidTerm A
    data OpDoubleMonoidTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpDoubleMonoidTerm n
      +OL :
        OpDoubleMonoidTerm n ->
        OpDoubleMonoidTerm n ->
        OpDoubleMonoidTerm n
      0OL : OpDoubleMonoidTerm n
      *OL :
        OpDoubleMonoidTerm n ->
        OpDoubleMonoidTerm n ->
        OpDoubleMonoidTerm n
      1OL : OpDoubleMonoidTerm n
    data OpDoubleMonoidTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpDoubleMonoidTerm2 n A
      sing2 :
        A -> OpDoubleMonoidTerm2 n A
      +OL2 :
        OpDoubleMonoidTerm2 n A ->
        OpDoubleMonoidTerm2 n A ->
        OpDoubleMonoidTerm2 n A
      0OL2 : OpDoubleMonoidTerm2 n A
      *OL2 :
        OpDoubleMonoidTerm2 n A ->
        OpDoubleMonoidTerm2 n A ->
        OpDoubleMonoidTerm2 n A
      1OL2 : OpDoubleMonoidTerm2 n A
    simplifyB :
      DoubleMonoidTerm ->
      DoubleMonoidTerm
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (*L (1L) x) = x
    simplifyB (*L x (1L)) = x
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (0L) = 0L
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (1L) = 1L
    simplifyCl :
      (A : Set) ->
      ClDoubleMonoidTerm A ->
      ClDoubleMonoidTerm A
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (*Cl (1Cl) x) = x
    simplifyCl _ (*Cl x (1Cl)) = x
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpDoubleMonoidTerm n ->
      OpDoubleMonoidTerm n
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (*OL (1OL) x) = x
    simplifyOp _ (*OL x (1OL)) = x
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpDoubleMonoidTerm2 n A ->
      OpDoubleMonoidTerm2 n A
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (*OL2
                     (1OL2)
                     x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (1OL2)) = x
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      DoubleMonoid A ->
      DoubleMonoidTerm -> A
    evalB _ Do (+L x1 x2) =
      + Do (evalB _ Do x1)
        (evalB _ Do x2)
    evalB _ Do (0L) = 0 Do
    evalB _ Do (*L x1 x2) =
      * Do (evalB _ Do x1)
        (evalB _ Do x2)
    evalB _ Do (1L) = 1 Do
    evalCl :
      (A : Set) ->
      DoubleMonoid A ->
      ClDoubleMonoidTerm A -> A
    evalCl _ Do (sing x1) = x1
    evalCl _ Do (+Cl x1 x2) =
      + Do (evalCl _ Do x1)
        (evalCl _ Do x2)
    evalCl _ Do (0Cl) = 0 Do
    evalCl _ Do (*Cl x1 x2) =
      * Do (evalCl _ Do x1)
        (evalCl _ Do x2)
    evalCl _ Do (1Cl) = 1 Do
    evalOp :
      (A : Set) (n : Nat) ->
      DoubleMonoid A ->
      Vec A n ->
      OpDoubleMonoidTerm n -> A
    evalOp _ n Do vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Do vars (+OL x1 x2) =
      + Do (evalOp _ n Do vars x1)
        (evalOp _ n Do vars x2)
    evalOp _ n Do vars (0OL) = 0 Do
    evalOp _ n Do vars (*OL x1 x2) =
      * Do (evalOp _ n Do vars x1)
        (evalOp _ n Do vars x2)
    evalOp _ n Do vars (1OL) = 1 Do
    evalOpE :
      (A : Set) (n : Nat) ->
      DoubleMonoid A ->
      Vec A n ->
      OpDoubleMonoidTerm2 n A -> A
    evalOpE _ n Do vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Do vars (sing2 x1) =
      x1
    evalOpE _ n Do vars (+OL2
                         x1
                         x2) =
      + Do (evalOpE _ n Do vars x1)
        (evalOpE _ n Do vars x2)
    evalOpE _ n Do vars (0OL2) =
      0 Do
    evalOpE _ n Do vars (*OL2
                         x1
                         x2) =
      * Do (evalOpE _ n Do vars x1)
        (evalOpE _ n Do vars x2)
    evalOpE _ n Do vars (1OL2) =
      1 Do
    inductionB :
      (P : DoubleMonoidTerm -> Set) ->
      ((x1 : DoubleMonoidTerm)
       (x2 : DoubleMonoidTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      P 0L ->
      ((x1 : DoubleMonoidTerm)
       (x2 : DoubleMonoidTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      P 1L ->
      (x : DoubleMonoidTerm) -> P x
    inductionB p p+l p0l p*l p1l (+L
                                  x1
                                  x2) =
      p+l _ _
        (inductionB p p+l p0l p*l p1l
           x1)
        (inductionB p p+l p0l p*l p1l
           x2)
    inductionB p p+l p0l p*l p1l (0L) =
      p0l
    inductionB p p+l p0l p*l p1l (*L
                                  x1
                                  x2) =
      p*l _ _
        (inductionB p p+l p0l p*l p1l
           x1)
        (inductionB p p+l p0l p*l p1l
           x2)
    inductionB p p+l p0l p*l p1l (1L) =
      p1l
    inductionCl :
      (A : Set)
      (P : ClDoubleMonoidTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClDoubleMonoidTerm A)
       (x2 : ClDoubleMonoidTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      P 0Cl ->
      ((x1 : ClDoubleMonoidTerm A)
       (x2 : ClDoubleMonoidTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      P 1Cl ->
      (x : ClDoubleMonoidTerm A) ->
      P x
    inductionCl _ p psing p+cl p0cl p*cl p1cl (sing
                                               x1) = psing x1
    inductionCl _ p psing p+cl p0cl p*cl p1cl (+Cl
                                               x1
                                               x2) =
      p+cl _ _
        (inductionCl _ p psing p+cl p0cl
           p*cl
           p1cl
           x1)
        (inductionCl _ p psing p+cl p0cl
           p*cl
           p1cl
           x2)
    inductionCl _ p psing p+cl p0cl p*cl p1cl (0Cl) =
      p0cl
    inductionCl _ p psing p+cl p0cl p*cl p1cl (*Cl
                                               x1
                                               x2) =
      p*cl _ _
        (inductionCl _ p psing p+cl p0cl
           p*cl
           p1cl
           x1)
        (inductionCl _ p psing p+cl p0cl
           p*cl
           p1cl
           x2)
    inductionCl _ p psing p+cl p0cl p*cl p1cl (1Cl) =
      p1cl
    inductionOp :
      (n : Nat)
      (P : OpDoubleMonoidTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpDoubleMonoidTerm n)
       (x2 : OpDoubleMonoidTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      P 0OL ->
      ((x1 : OpDoubleMonoidTerm n)
       (x2 : OpDoubleMonoidTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      P 1OL ->
      (x : OpDoubleMonoidTerm n) ->
      P x
    inductionOp _ p pv p+ol p0ol p*ol p1ol (v
                                            x1) = pv x1
    inductionOp _ p pv p+ol p0ol p*ol p1ol (+OL
                                            x1
                                            x2) =
      p+ol _ _
        (inductionOp _ p pv p+ol p0ol
           p*ol
           p1ol
           x1)
        (inductionOp _ p pv p+ol p0ol
           p*ol
           p1ol
           x2)
    inductionOp _ p pv p+ol p0ol p*ol p1ol (0OL) =
      p0ol
    inductionOp _ p pv p+ol p0ol p*ol p1ol (*OL
                                            x1
                                            x2) =
      p*ol _ _
        (inductionOp _ p pv p+ol p0ol
           p*ol
           p1ol
           x1)
        (inductionOp _ p pv p+ol p0ol
           p*ol
           p1ol
           x2)
    inductionOp _ p pv p+ol p0ol p*ol p1ol (1OL) =
      p1ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpDoubleMonoidTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpDoubleMonoidTerm2 n A)
       (x2 : OpDoubleMonoidTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      P 0OL2 ->
      ((x1 : OpDoubleMonoidTerm2 n A)
       (x2 : OpDoubleMonoidTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      P 1OL2 ->
      (x : OpDoubleMonoidTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 p*ol2 p1ol2 (v2
                                                           x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 p*ol2 p1ol2 (sing2
                                                           x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 p*ol2 p1ol2 (+OL2
                                                           x1
                                                           x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p0ol2
           p*ol2
           p1ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p0ol2
           p*ol2
           p1ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 p*ol2 p1ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 p*ol2 p1ol2 (*OL2
                                                           x1
                                                           x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p0ol2
           p*ol2
           p1ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p0ol2
           p*ol2
           p1ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 p*ol2 p1ol2 (1OL2) =
      p1ol2
    +L' :
      DoubleMonoidTerm ->
      DoubleMonoidTerm ->
      DoubleMonoidTerm
    +L' x1 x2 = +L x1 x2
    0L' : DoubleMonoidTerm
    0L' = 0L
    *L' :
      DoubleMonoidTerm ->
      DoubleMonoidTerm ->
      DoubleMonoidTerm
    *L' x1 x2 = *L x1 x2
    1L' : DoubleMonoidTerm
    1L' = 1L
    stageB :
      DoubleMonoidTerm ->
      Staged DoubleMonoidTerm
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (0L) = Now 0L
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (1L) = Now 1L
    +Cl' :
      (A : Set) ->
      ClDoubleMonoidTerm A ->
      ClDoubleMonoidTerm A ->
      ClDoubleMonoidTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    0Cl' :
      (A : Set) ->
      ClDoubleMonoidTerm A
    0Cl' _ = 0Cl
    *Cl' :
      (A : Set) ->
      ClDoubleMonoidTerm A ->
      ClDoubleMonoidTerm A ->
      ClDoubleMonoidTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    1Cl' :
      (A : Set) ->
      ClDoubleMonoidTerm A
    1Cl' _ = 1Cl
    stageCl :
      (A : Set) ->
      ClDoubleMonoidTerm A ->
      Staged (ClDoubleMonoidTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (1Cl) = Now 1Cl
    +OL' :
      (n : Nat) ->
      OpDoubleMonoidTerm n ->
      OpDoubleMonoidTerm n ->
      OpDoubleMonoidTerm n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      OpDoubleMonoidTerm n
    0OL' _ = 0OL
    *OL' :
      (n : Nat) ->
      OpDoubleMonoidTerm n ->
      OpDoubleMonoidTerm n ->
      OpDoubleMonoidTerm n
    *OL' _ x1 x2 = *OL x1 x2
    1OL' :
      (n : Nat) ->
      OpDoubleMonoidTerm n
    1OL' _ = 1OL
    stageOp :
      (n : Nat) ->
      OpDoubleMonoidTerm n ->
      Staged (OpDoubleMonoidTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (0OL) = Now 0OL
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (1OL) = Now 1OL
    +OL2' :
      (n : Nat) (A : Set) ->
      OpDoubleMonoidTerm2 n A ->
      OpDoubleMonoidTerm2 n A ->
      OpDoubleMonoidTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    0OL2' :
      (n : Nat) (A : Set) ->
      OpDoubleMonoidTerm2 n A
    0OL2' _ _ = 0OL2
    *OL2' :
      (n : Nat) (A : Set) ->
      OpDoubleMonoidTerm2 n A ->
      OpDoubleMonoidTerm2 n A ->
      OpDoubleMonoidTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    1OL2' :
      (n : Nat) (A : Set) ->
      OpDoubleMonoidTerm2 n A
    1OL2' _ _ = 1OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpDoubleMonoidTerm2 n A ->
      Staged (OpDoubleMonoidTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (1OL2) = Now 1OL2
    record DoubleMonoidTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        +T : Repr A -> Repr A -> Repr A
        0T : Repr A
        *T : Repr A -> Repr A -> Repr A
        1T : Repr A
  
  module DualDeMorgan where
    record DualDeMorgan
      (A : Set) : Set where
      constructor DualDeMorganC
      field
        * : A -> A -> A
        + : A -> A -> A
        prim : A -> A
        andDeMorgan_*_+_prim :
          (x : A) (y : A) (z : A) ->
          prim (* x y) ==
            + (prim x) (prim y)
        orDeMorgan_+_*_prim :
          (x : A) (y : A) (z : A) ->
          prim (+ x y) ==
            * (prim x) (prim y)
    record DualDeMorganSig
      (AS : Set) : Set where
      constructor DualDeMorganSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        primS : AS -> AS
    record DualDeMorganProd
      (AP : Set) : Set where
      constructor DualDeMorganProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        andDeMorgan_*_+_primP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          primP (*P xP yP) ==
            +P (primP xP) (primP yP)
        orDeMorgan_+_*_primP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          primP (+P xP yP) ==
            *P (primP xP) (primP yP)
    record DualDeMorganHom
      (A1 : Set) (A2 : Set)
      (Du1 : DualDeMorgan A1)
      (Du2 : DualDeMorgan A2) :
      Set where
      constructor DualDeMorganHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Du1 x1 x2) ==
            * Du2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Du1 x1 x2) ==
            + Du2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Du1 x1) ==
            prim Du2 (hom x1)
    record DualDeMorganRelInterp
      (A1 : Set) (A2 : Set)
      (Du1 : DualDeMorgan A1)
      (Du2 : DualDeMorgan A2) :
      Set where
      constructor DualDeMorganRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Du1 x1 x2)
            (* Du2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Du1 x1 x2)
            (+ Du2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Du1 x1)
            (prim Du2 y1)
    data DualDeMorganTerm
      : Set where
      *L :
        DualDeMorganTerm ->
        DualDeMorganTerm ->
        DualDeMorganTerm
      +L :
        DualDeMorganTerm ->
        DualDeMorganTerm ->
        DualDeMorganTerm
      primL :
        DualDeMorganTerm ->
        DualDeMorganTerm
    data ClDualDeMorganTerm
      (A : Set) : Set where
      sing :
        A -> ClDualDeMorganTerm A
      *Cl :
        ClDualDeMorganTerm A ->
        ClDualDeMorganTerm A ->
        ClDualDeMorganTerm A
      +Cl :
        ClDualDeMorganTerm A ->
        ClDualDeMorganTerm A ->
        ClDualDeMorganTerm A
      primCl :
        ClDualDeMorganTerm A ->
        ClDualDeMorganTerm A
    data OpDualDeMorganTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpDualDeMorganTerm n
      *OL :
        OpDualDeMorganTerm n ->
        OpDualDeMorganTerm n ->
        OpDualDeMorganTerm n
      +OL :
        OpDualDeMorganTerm n ->
        OpDualDeMorganTerm n ->
        OpDualDeMorganTerm n
      primOL :
        OpDualDeMorganTerm n ->
        OpDualDeMorganTerm n
    data OpDualDeMorganTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpDualDeMorganTerm2 n A
      sing2 :
        A -> OpDualDeMorganTerm2 n A
      *OL2 :
        OpDualDeMorganTerm2 n A ->
        OpDualDeMorganTerm2 n A ->
        OpDualDeMorganTerm2 n A
      +OL2 :
        OpDualDeMorganTerm2 n A ->
        OpDualDeMorganTerm2 n A ->
        OpDualDeMorganTerm2 n A
      primOL2 :
        OpDualDeMorganTerm2 n A ->
        OpDualDeMorganTerm2 n A
    simplifyB :
      DualDeMorganTerm ->
      DualDeMorganTerm
    simplifyB (+L
               (primL x)
               (primL y)) = primL (*L x y)
    simplifyB (*L
               (primL x)
               (primL y)) = primL (+L x y)
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClDualDeMorganTerm A ->
      ClDualDeMorganTerm A
    simplifyCl _ (+Cl
                  (primCl x)
                  (primCl y)) = primCl (*Cl x y)
    simplifyCl _ (*Cl
                  (primCl x)
                  (primCl y)) = primCl (+Cl x y)
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpDualDeMorganTerm n ->
      OpDualDeMorganTerm n
    simplifyOp _ (+OL
                  (primOL x)
                  (primOL y)) = primOL (*OL x y)
    simplifyOp _ (*OL
                  (primOL x)
                  (primOL y)) = primOL (+OL x y)
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpDualDeMorganTerm2 n A ->
      OpDualDeMorganTerm2 n A
    simplifyOpE _ _ (+OL2
                     (primOL2 x)
                     (primOL2 y)) =
      primOL2 (*OL2 x y)
    simplifyOpE _ _ (*OL2
                     (primOL2 x)
                     (primOL2 y)) =
      primOL2 (+OL2 x y)
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      DualDeMorgan A ->
      DualDeMorganTerm -> A
    evalB _ Du (*L x1 x2) =
      * Du (evalB _ Du x1)
        (evalB _ Du x2)
    evalB _ Du (+L x1 x2) =
      + Du (evalB _ Du x1)
        (evalB _ Du x2)
    evalB _ Du (primL x1) =
      prim Du (evalB _ Du x1)
    evalCl :
      (A : Set) ->
      DualDeMorgan A ->
      ClDualDeMorganTerm A -> A
    evalCl _ Du (sing x1) = x1
    evalCl _ Du (*Cl x1 x2) =
      * Du (evalCl _ Du x1)
        (evalCl _ Du x2)
    evalCl _ Du (+Cl x1 x2) =
      + Du (evalCl _ Du x1)
        (evalCl _ Du x2)
    evalCl _ Du (primCl x1) =
      prim Du (evalCl _ Du x1)
    evalOp :
      (A : Set) (n : Nat) ->
      DualDeMorgan A ->
      Vec A n ->
      OpDualDeMorganTerm n -> A
    evalOp _ n Du vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Du vars (*OL x1 x2) =
      * Du (evalOp _ n Du vars x1)
        (evalOp _ n Du vars x2)
    evalOp _ n Du vars (+OL x1 x2) =
      + Du (evalOp _ n Du vars x1)
        (evalOp _ n Du vars x2)
    evalOp _ n Du vars (primOL x1) =
      prim Du (evalOp _ n Du vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      DualDeMorgan A ->
      Vec A n ->
      OpDualDeMorganTerm2 n A -> A
    evalOpE _ n Du vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Du vars (sing2 x1) =
      x1
    evalOpE _ n Du vars (*OL2
                         x1
                         x2) =
      * Du (evalOpE _ n Du vars x1)
        (evalOpE _ n Du vars x2)
    evalOpE _ n Du vars (+OL2
                         x1
                         x2) =
      + Du (evalOpE _ n Du vars x1)
        (evalOpE _ n Du vars x2)
    evalOpE _ n Du vars (primOL2
                         x1) =
      prim Du (evalOpE _ n Du vars x1)
    inductionB :
      (P : DualDeMorganTerm -> Set) ->
      ((x1 : DualDeMorganTerm)
       (x2 : DualDeMorganTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : DualDeMorganTerm)
       (x2 : DualDeMorganTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      ((x1 : DualDeMorganTerm) ->
       P x1 -> P (primL x1)) ->
      (x : DualDeMorganTerm) -> P x
    inductionB p p*l p+l ppriml (*L
                                 x1
                                 x2) =
      p*l _ _
        (inductionB p p*l p+l ppriml x1)
        (inductionB p p*l p+l ppriml x2)
    inductionB p p*l p+l ppriml (+L
                                 x1
                                 x2) =
      p+l _ _
        (inductionB p p*l p+l ppriml x1)
        (inductionB p p*l p+l ppriml x2)
    inductionB p p*l p+l ppriml (primL
                                 x1) =
      ppriml _
        (inductionB p p*l p+l ppriml x1)
    inductionCl :
      (A : Set)
      (P : ClDualDeMorganTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClDualDeMorganTerm A)
       (x2 : ClDualDeMorganTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClDualDeMorganTerm A)
       (x2 : ClDualDeMorganTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      ((x1 : ClDualDeMorganTerm A) ->
       P x1 -> P (primCl x1)) ->
      (x : ClDualDeMorganTerm A) ->
      P x
    inductionCl _ p psing p*cl p+cl pprimcl (sing
                                             x1) = psing x1
    inductionCl _ p psing p*cl p+cl pprimcl (*Cl
                                             x1
                                             x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x1)
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x2)
    inductionCl _ p psing p*cl p+cl pprimcl (+Cl
                                             x1
                                             x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x1)
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x2)
    inductionCl _ p psing p*cl p+cl pprimcl (primCl
                                             x1) =
      pprimcl _
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpDualDeMorganTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpDualDeMorganTerm n)
       (x2 : OpDualDeMorganTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpDualDeMorganTerm n)
       (x2 : OpDualDeMorganTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      ((x1 : OpDualDeMorganTerm n) ->
       P x1 -> P (primOL x1)) ->
      (x : OpDualDeMorganTerm n) ->
      P x
    inductionOp _ p pv p*ol p+ol pprimol (v
                                          x1) = pv x1
    inductionOp _ p pv p*ol p+ol pprimol (*OL
                                          x1
                                          x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x1)
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x2)
    inductionOp _ p pv p*ol p+ol pprimol (+OL
                                          x1
                                          x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x1)
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x2)
    inductionOp _ p pv p*ol p+ol pprimol (primOL
                                          x1) =
      pprimol _
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpDualDeMorganTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpDualDeMorganTerm2 n A)
       (x2 : OpDualDeMorganTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpDualDeMorganTerm2 n A)
       (x2 : OpDualDeMorganTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      ((x1 : OpDualDeMorganTerm2 n
          A) -> P x1 -> P (primOL2 x1)) ->
      (x : OpDualDeMorganTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (v2
                                                        x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (sing2
                                                        x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (*OL2
                                                        x1
                                                        x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (+OL2
                                                        x1
                                                        x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (primOL2
                                                        x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x1)
    *L' :
      DualDeMorganTerm ->
      DualDeMorganTerm ->
      DualDeMorganTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      DualDeMorganTerm ->
      DualDeMorganTerm ->
      DualDeMorganTerm
    +L' x1 x2 = +L x1 x2
    primL' :
      DualDeMorganTerm ->
      DualDeMorganTerm
    primL' x1 = primL x1
    stageB :
      DualDeMorganTerm ->
      Staged DualDeMorganTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    *Cl' :
      (A : Set) ->
      ClDualDeMorganTerm A ->
      ClDualDeMorganTerm A ->
      ClDualDeMorganTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClDualDeMorganTerm A ->
      ClDualDeMorganTerm A ->
      ClDualDeMorganTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    primCl' :
      (A : Set) ->
      ClDualDeMorganTerm A ->
      ClDualDeMorganTerm A
    primCl' _ x1 = primCl x1
    stageCl :
      (A : Set) ->
      ClDualDeMorganTerm A ->
      Staged (ClDualDeMorganTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    *OL' :
      (n : Nat) ->
      OpDualDeMorganTerm n ->
      OpDualDeMorganTerm n ->
      OpDualDeMorganTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpDualDeMorganTerm n ->
      OpDualDeMorganTerm n ->
      OpDualDeMorganTerm n
    +OL' _ x1 x2 = +OL x1 x2
    primOL' :
      (n : Nat) ->
      OpDualDeMorganTerm n ->
      OpDualDeMorganTerm n
    primOL' _ x1 = primOL x1
    stageOp :
      (n : Nat) ->
      OpDualDeMorganTerm n ->
      Staged (OpDualDeMorganTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpDualDeMorganTerm2 n A ->
      OpDualDeMorganTerm2 n A ->
      OpDualDeMorganTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpDualDeMorganTerm2 n A ->
      OpDualDeMorganTerm2 n A ->
      OpDualDeMorganTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    primOL2' :
      (n : Nat) (A : Set) ->
      OpDualDeMorganTerm2 n A ->
      OpDualDeMorganTerm2 n A
    primOL2' _ _ x1 = primOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpDualDeMorganTerm2 n A ->
      Staged (OpDualDeMorganTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    record DualDeMorganTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
        primT : Repr A -> Repr A
  
  module DualSemilattices where
    record DualSemilattices
      (A : Set) : Set where
      constructor DualSemilatticesC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
    record DualSemilatticesSig
      (AS : Set) : Set where
      constructor DualSemilatticesSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record DualSemilatticesProd
      (AP : Set) : Set where
      constructor DualSemilatticesProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record DualSemilatticesHom
      (A1 : Set) (A2 : Set)
      (Du1 : DualSemilattices A1)
      (Du2 : DualSemilattices A2) :
      Set where
      constructor DualSemilatticesHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Du1 x1 x2) ==
            * Du2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Du1 x1 x2) ==
            + Du2 (hom x1) (hom x2)
    record DualSemilatticesRelInterp
      (A1 : Set) (A2 : Set)
      (Du1 : DualSemilattices A1)
      (Du2 : DualSemilattices A2) :
      Set where
      constructor DualSemilatticesRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Du1 x1 x2)
            (* Du2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Du1 x1 x2)
            (+ Du2 y1 y2)
    data DualSemilatticesTerm
      : Set where
      *L :
        DualSemilatticesTerm ->
        DualSemilatticesTerm ->
        DualSemilatticesTerm
      +L :
        DualSemilatticesTerm ->
        DualSemilatticesTerm ->
        DualSemilatticesTerm
    data ClDualSemilatticesTerm
      (A : Set) : Set where
      sing :
        A -> ClDualSemilatticesTerm A
      *Cl :
        ClDualSemilatticesTerm A ->
        ClDualSemilatticesTerm A ->
        ClDualSemilatticesTerm A
      +Cl :
        ClDualSemilatticesTerm A ->
        ClDualSemilatticesTerm A ->
        ClDualSemilatticesTerm A
    data OpDualSemilatticesTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpDualSemilatticesTerm n
      *OL :
        OpDualSemilatticesTerm n ->
        OpDualSemilatticesTerm n ->
        OpDualSemilatticesTerm n
      +OL :
        OpDualSemilatticesTerm n ->
        OpDualSemilatticesTerm n ->
        OpDualSemilatticesTerm n
    data OpDualSemilatticesTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpDualSemilatticesTerm2 n A
      sing2 :
        A -> OpDualSemilatticesTerm2 n A
      *OL2 :
        OpDualSemilatticesTerm2 n A ->
        OpDualSemilatticesTerm2 n A ->
        OpDualSemilatticesTerm2 n A
      +OL2 :
        OpDualSemilatticesTerm2 n A ->
        OpDualSemilatticesTerm2 n A ->
        OpDualSemilatticesTerm2 n A
    simplifyB :
      DualSemilatticesTerm ->
      DualSemilatticesTerm
    simplifyB (*L x x) = x
    simplifyB (+L x x) = x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClDualSemilatticesTerm A ->
      ClDualSemilatticesTerm A
    simplifyCl _ (*Cl x x) = x
    simplifyCl _ (+Cl x x) = x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpDualSemilatticesTerm n ->
      OpDualSemilatticesTerm n
    simplifyOp _ (*OL x x) = x
    simplifyOp _ (+OL x x) = x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpDualSemilatticesTerm2 n A ->
      OpDualSemilatticesTerm2 n A
    simplifyOpE _ _ (*OL2 x x) = x
    simplifyOpE _ _ (+OL2 x x) = x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      DualSemilattices A ->
      DualSemilatticesTerm -> A
    evalB _ Du (*L x1 x2) =
      * Du (evalB _ Du x1)
        (evalB _ Du x2)
    evalB _ Du (+L x1 x2) =
      + Du (evalB _ Du x1)
        (evalB _ Du x2)
    evalCl :
      (A : Set) ->
      DualSemilattices A ->
      ClDualSemilatticesTerm A -> A
    evalCl _ Du (sing x1) = x1
    evalCl _ Du (*Cl x1 x2) =
      * Du (evalCl _ Du x1)
        (evalCl _ Du x2)
    evalCl _ Du (+Cl x1 x2) =
      + Du (evalCl _ Du x1)
        (evalCl _ Du x2)
    evalOp :
      (A : Set) (n : Nat) ->
      DualSemilattices A ->
      Vec A n ->
      OpDualSemilatticesTerm n -> A
    evalOp _ n Du vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Du vars (*OL x1 x2) =
      * Du (evalOp _ n Du vars x1)
        (evalOp _ n Du vars x2)
    evalOp _ n Du vars (+OL x1 x2) =
      + Du (evalOp _ n Du vars x1)
        (evalOp _ n Du vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      DualSemilattices A ->
      Vec A n ->
      OpDualSemilatticesTerm2 n A -> A
    evalOpE _ n Du vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Du vars (sing2 x1) =
      x1
    evalOpE _ n Du vars (*OL2
                         x1
                         x2) =
      * Du (evalOpE _ n Du vars x1)
        (evalOpE _ n Du vars x2)
    evalOpE _ n Du vars (+OL2
                         x1
                         x2) =
      + Du (evalOpE _ n Du vars x1)
        (evalOpE _ n Du vars x2)
    inductionB :
      (P : DualSemilatticesTerm ->
           Set) ->
      ((x1 : DualSemilatticesTerm)
       (x2 : DualSemilatticesTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : DualSemilatticesTerm)
       (x2 : DualSemilatticesTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : DualSemilatticesTerm) ->
      P x
    inductionB p p*l p+l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionB p p*l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClDualSemilatticesTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClDualSemilatticesTerm A)
       (x2 : ClDualSemilatticesTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClDualSemilatticesTerm A)
       (x2 : ClDualSemilatticesTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClDualSemilatticesTerm
         A) -> P x
    inductionCl _ p psing p*cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p*cl p+cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionCl _ p psing p*cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpDualSemilatticesTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpDualSemilatticesTerm n)
       (x2 : OpDualSemilatticesTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpDualSemilatticesTerm n)
       (x2 : OpDualSemilatticesTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpDualSemilatticesTerm
         n) -> P x
    inductionOp _ p pv p*ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p*ol p+ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOp _ p pv p*ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpDualSemilatticesTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpDualSemilatticesTerm2 n
          A)
       (x2 : OpDualSemilatticesTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpDualSemilatticesTerm2 n
          A)
       (x2 : OpDualSemilatticesTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpDualSemilatticesTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    *L' :
      DualSemilatticesTerm ->
      DualSemilatticesTerm ->
      DualSemilatticesTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      DualSemilatticesTerm ->
      DualSemilatticesTerm ->
      DualSemilatticesTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      DualSemilatticesTerm ->
      Staged DualSemilatticesTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClDualSemilatticesTerm A ->
      ClDualSemilatticesTerm A ->
      ClDualSemilatticesTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClDualSemilatticesTerm A ->
      ClDualSemilatticesTerm A ->
      ClDualSemilatticesTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClDualSemilatticesTerm A ->
      Staged
        (ClDualSemilatticesTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpDualSemilatticesTerm n ->
      OpDualSemilatticesTerm n ->
      OpDualSemilatticesTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpDualSemilatticesTerm n ->
      OpDualSemilatticesTerm n ->
      OpDualSemilatticesTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpDualSemilatticesTerm n ->
      Staged
        (OpDualSemilatticesTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpDualSemilatticesTerm2 n A ->
      OpDualSemilatticesTerm2 n A ->
      OpDualSemilatticesTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpDualSemilatticesTerm2 n A ->
      OpDualSemilatticesTerm2 n A ->
      OpDualSemilatticesTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpDualSemilatticesTerm2 n A ->
      Staged
        (OpDualSemilatticesTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record DualSemilatticesTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module Empty where
    record Empty : Set where
      constructor EmptyC
      field
        
  
  module FixedPoint where
    record FixedPoint
      (A : Set) : Set where
      constructor FixedPointC
      field
        prim : A -> A
        e : A
        fixes_prim_e : prim e == e
    record FixedPointSig
      (AS : Set) : Set where
      constructor FixedPointSigSigC
      field
        primS : AS -> AS
        eS : AS
    record FixedPointProd
      (AP : Set) : Set where
      constructor FixedPointProdC
      field
        primP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        fixes_prim_eP : primP eP == eP
    record FixedPointHom
      (A1 : Set) (A2 : Set)
      (Fi1 : FixedPoint A1)
      (Fi2 : FixedPoint A2) :
      Set where
      constructor FixedPointHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Fi1 x1) ==
            prim Fi2 (hom x1)
        pres-e : hom (e Fi1) == e Fi2
    record FixedPointRelInterp
      (A1 : Set) (A2 : Set)
      (Fi1 : FixedPoint A1)
      (Fi2 : FixedPoint A2) :
      Set where
      constructor FixedPointRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Fi1 x1)
            (prim Fi2 y1)
        interp-e :
          interp (e Fi1) (e Fi2)
    data FixedPointTerm : Set where
      primL :
        FixedPointTerm -> FixedPointTerm
      eL : FixedPointTerm
    data ClFixedPointTerm
      (A : Set) : Set where
      sing : A -> ClFixedPointTerm A
      primCl :
        ClFixedPointTerm A ->
        ClFixedPointTerm A
      eCl : ClFixedPointTerm A
    data OpFixedPointTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpFixedPointTerm n
      primOL :
        OpFixedPointTerm n ->
        OpFixedPointTerm n
      eOL : OpFixedPointTerm n
    data OpFixedPointTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpFixedPointTerm2 n A
      sing2 :
        A -> OpFixedPointTerm2 n A
      primOL2 :
        OpFixedPointTerm2 n A ->
        OpFixedPointTerm2 n A
      eOL2 : OpFixedPointTerm2 n A
    simplifyB :
      FixedPointTerm -> FixedPointTerm
    simplifyB (primL (eL)) = eL
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyB (eL) = eL
    simplifyCl :
      (A : Set) ->
      ClFixedPointTerm A ->
      ClFixedPointTerm A
    simplifyCl _ (primCl (eCl)) =
      eCl
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpFixedPointTerm n ->
      OpFixedPointTerm n
    simplifyOp _ (primOL (eOL)) =
      eOL
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpFixedPointTerm2 n A ->
      OpFixedPointTerm2 n A
    simplifyOpE _ _ (primOL2
                     (eOL2)) = eOL2
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      FixedPoint A ->
      FixedPointTerm -> A
    evalB _ Fi (primL x1) =
      prim Fi (evalB _ Fi x1)
    evalB _ Fi (eL) = e Fi
    evalCl :
      (A : Set) ->
      FixedPoint A ->
      ClFixedPointTerm A -> A
    evalCl _ Fi (sing x1) = x1
    evalCl _ Fi (primCl x1) =
      prim Fi (evalCl _ Fi x1)
    evalCl _ Fi (eCl) = e Fi
    evalOp :
      (A : Set) (n : Nat) ->
      FixedPoint A ->
      Vec A n ->
      OpFixedPointTerm n -> A
    evalOp _ n Fi vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Fi vars (primOL x1) =
      prim Fi (evalOp _ n Fi vars x1)
    evalOp _ n Fi vars (eOL) = e Fi
    evalOpE :
      (A : Set) (n : Nat) ->
      FixedPoint A ->
      Vec A n ->
      OpFixedPointTerm2 n A -> A
    evalOpE _ n Fi vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Fi vars (sing2 x1) =
      x1
    evalOpE _ n Fi vars (primOL2
                         x1) =
      prim Fi (evalOpE _ n Fi vars x1)
    evalOpE _ n Fi vars (eOL2) =
      e Fi
    inductionB :
      (P : FixedPointTerm -> Set) ->
      ((x1 : FixedPointTerm) ->
       P x1 -> P (primL x1)) ->
      P eL ->
      (x : FixedPointTerm) -> P x
    inductionB p ppriml pel (primL
                             x1) =
      ppriml _
        (inductionB p ppriml pel x1)
    inductionB p ppriml pel (eL) =
      pel
    inductionCl :
      (A : Set)
      (P : ClFixedPointTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClFixedPointTerm A) ->
       P x1 -> P (primCl x1)) ->
      P eCl ->
      (x : ClFixedPointTerm A) -> P x
    inductionCl _ p psing pprimcl pecl (sing
                                        x1) = psing x1
    inductionCl _ p psing pprimcl pecl (primCl
                                        x1) =
      pprimcl _
        (inductionCl _ p psing pprimcl
           pecl
           x1)
    inductionCl _ p psing pprimcl pecl (eCl) =
      pecl
    inductionOp :
      (n : Nat)
      (P : OpFixedPointTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpFixedPointTerm n) ->
       P x1 -> P (primOL x1)) ->
      P eOL ->
      (x : OpFixedPointTerm n) -> P x
    inductionOp _ p pv pprimol peol (v
                                     x1) = pv x1
    inductionOp _ p pv pprimol peol (primOL
                                     x1) =
      pprimol _
        (inductionOp _ p pv pprimol peol
           x1)
    inductionOp _ p pv pprimol peol (eOL) =
      peol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpFixedPointTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpFixedPointTerm2 n A) ->
       P x1 -> P (primOL2 x1)) ->
      P eOL2 ->
      (x : OpFixedPointTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 pprimol2 peol2 (v2
                                                  x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 peol2 (sing2
                                                  x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 peol2 (primOL2
                                                  x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           peol2
           x1)
    inductionOpE _ _ p pv2 psing2 pprimol2 peol2 (eOL2) =
      peol2
    primL' :
      FixedPointTerm -> FixedPointTerm
    primL' x1 = primL x1
    eL' : FixedPointTerm
    eL' = eL
    stageB :
      FixedPointTerm ->
      Staged FixedPointTerm
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    stageB (eL) = Now eL
    primCl' :
      (A : Set) ->
      ClFixedPointTerm A ->
      ClFixedPointTerm A
    primCl' _ x1 = primCl x1
    eCl' :
      (A : Set) -> ClFixedPointTerm A
    eCl' _ = eCl
    stageCl :
      (A : Set) ->
      ClFixedPointTerm A ->
      Staged (ClFixedPointTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    stageCl _ (eCl) = Now eCl
    primOL' :
      (n : Nat) ->
      OpFixedPointTerm n ->
      OpFixedPointTerm n
    primOL' _ x1 = primOL x1
    eOL' :
      (n : Nat) -> OpFixedPointTerm n
    eOL' _ = eOL
    stageOp :
      (n : Nat) ->
      OpFixedPointTerm n ->
      Staged (OpFixedPointTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    stageOp _ (eOL) = Now eOL
    primOL2' :
      (n : Nat) (A : Set) ->
      OpFixedPointTerm2 n A ->
      OpFixedPointTerm2 n A
    primOL2' _ _ x1 = primOL2 x1
    eOL2' :
      (n : Nat) (A : Set) ->
      OpFixedPointTerm2 n A
    eOL2' _ _ = eOL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpFixedPointTerm2 n A ->
      Staged (OpFixedPointTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (eOL2) = Now eOL2
    record FixedPointTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        primT : Repr A -> Repr A
        eT : Repr A
  
  module Group where
    record Group
      (A : Set) : Set where
      constructor GroupC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        inv : A -> A
        leftInverse_inv_op_e :
          (x : A) -> op x (inv x) == e
        rightInverse_inv_op_e :
          (x : A) -> op (inv x) x == e
    record GroupSig
      (AS : Set) : Set where
      constructor GroupSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
        invS : AS -> AS
    record GroupProd
      (AP : Set) : Set where
      constructor GroupProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP xP (invP xP) == eP
        rightInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (invP xP) xP == eP
    record GroupHom
      (A1 : Set) (A2 : Set)
      (Gr1 : Group A1)
      (Gr2 : Group A2) : Set where
      constructor GroupHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Gr1) == e Gr2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Gr1 x1 x2) ==
            op Gr2 (hom x1) (hom x2)
        pres-inv :
          (x1 : A1) ->
          hom (inv Gr1 x1) ==
            inv Gr2 (hom x1)
    record GroupRelInterp
      (A1 : Set) (A2 : Set)
      (Gr1 : Group A1)
      (Gr2 : Group A2) : Set where
      constructor GroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Gr1) (e Gr2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Gr1 x1 x2)
            (op Gr2 y1 y2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Gr1 x1) (inv Gr2 y1)
    data GroupTerm : Set where
      eL : GroupTerm
      opL :
        GroupTerm ->
        GroupTerm -> GroupTerm
      invL : GroupTerm -> GroupTerm
    data ClGroupTerm
      (A : Set) : Set where
      sing : A -> ClGroupTerm A
      eCl : ClGroupTerm A
      opCl :
        ClGroupTerm A ->
        ClGroupTerm A -> ClGroupTerm A
      invCl :
        ClGroupTerm A -> ClGroupTerm A
    data OpGroupTerm
      (n : Nat) : Set where
      v : Fin n -> OpGroupTerm n
      eOL : OpGroupTerm n
      opOL :
        OpGroupTerm n ->
        OpGroupTerm n -> OpGroupTerm n
      invOL :
        OpGroupTerm n -> OpGroupTerm n
    data OpGroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 : Fin n -> OpGroupTerm2 n A
      sing2 : A -> OpGroupTerm2 n A
      eOL2 : OpGroupTerm2 n A
      opOL2 :
        OpGroupTerm2 n A ->
        OpGroupTerm2 n A ->
        OpGroupTerm2 n A
      invOL2 :
        OpGroupTerm2 n A ->
        OpGroupTerm2 n A
    simplifyB :
      GroupTerm -> GroupTerm
    simplifyB (opL (eL) x) = x
    simplifyB (opL x (eL)) = x
    simplifyB (opL x (invL x)) = eL
    simplifyB (opL (invL x) x) = eL
    simplifyB (eL) = eL
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (invL x1) =
      invL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClGroupTerm A -> ClGroupTerm A
    simplifyCl _ (opCl (eCl) x) = x
    simplifyCl _ (opCl x (eCl)) = x
    simplifyCl _ (opCl
                  x
                  (invCl x)) = eCl
    simplifyCl _ (opCl
                  (invCl x)
                  x) = eCl
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (invCl x1) =
      invCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpGroupTerm n -> OpGroupTerm n
    simplifyOp _ (opOL (eOL) x) = x
    simplifyOp _ (opOL x (eOL)) = x
    simplifyOp _ (opOL
                  x
                  (invOL x)) = eOL
    simplifyOp _ (opOL
                  (invOL x)
                  x) = eOL
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (invOL x1) =
      invOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpGroupTerm2 n A ->
      OpGroupTerm2 n A
    simplifyOpE _ _ (opOL2
                     (eOL2)
                     x) = x
    simplifyOpE _ _ (opOL2
                     x
                     (eOL2)) = x
    simplifyOpE _ _ (opOL2
                     x
                     (invOL2 x)) = eOL2
    simplifyOpE _ _ (opOL2
                     (invOL2 x)
                     x) = eOL2
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (invOL2 x1) =
      invOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Group A -> GroupTerm -> A
    evalB _ Gr (eL) = e Gr
    evalB _ Gr (opL x1 x2) =
      op Gr (evalB _ Gr x1)
        (evalB _ Gr x2)
    evalB _ Gr (invL x1) =
      inv Gr (evalB _ Gr x1)
    evalCl :
      (A : Set) ->
      Group A -> ClGroupTerm A -> A
    evalCl _ Gr (sing x1) = x1
    evalCl _ Gr (eCl) = e Gr
    evalCl _ Gr (opCl x1 x2) =
      op Gr (evalCl _ Gr x1)
        (evalCl _ Gr x2)
    evalCl _ Gr (invCl x1) =
      inv Gr (evalCl _ Gr x1)
    evalOp :
      (A : Set) (n : Nat) ->
      Group A ->
      Vec A n -> OpGroupTerm n -> A
    evalOp _ n Gr vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Gr vars (eOL) = e Gr
    evalOp _ n Gr vars (opOL
                        x1
                        x2) =
      op Gr (evalOp _ n Gr vars x1)
        (evalOp _ n Gr vars x2)
    evalOp _ n Gr vars (invOL x1) =
      inv Gr (evalOp _ n Gr vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      Group A ->
      Vec A n -> OpGroupTerm2 n A -> A
    evalOpE _ n Gr vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Gr vars (sing2 x1) =
      x1
    evalOpE _ n Gr vars (eOL2) =
      e Gr
    evalOpE _ n Gr vars (opOL2
                         x1
                         x2) =
      op Gr (evalOpE _ n Gr vars x1)
        (evalOpE _ n Gr vars x2)
    evalOpE _ n Gr vars (invOL2
                         x1) =
      inv Gr (evalOpE _ n Gr vars x1)
    inductionB :
      (P : GroupTerm -> Set) ->
      P eL ->
      ((x1 : GroupTerm)
       (x2 : GroupTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      ((x1 : GroupTerm) ->
       P x1 -> P (invL x1)) ->
      (x : GroupTerm) -> P x
    inductionB p pel popl pinvl (eL) =
      pel
    inductionB p pel popl pinvl (opL
                                 x1
                                 x2) =
      popl _ _
        (inductionB p pel popl pinvl x1)
        (inductionB p pel popl pinvl x2)
    inductionB p pel popl pinvl (invL
                                 x1) =
      pinvl _
        (inductionB p pel popl pinvl x1)
    inductionCl :
      (A : Set)
      (P : ClGroupTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P eCl ->
      ((x1 : ClGroupTerm A)
       (x2 : ClGroupTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      ((x1 : ClGroupTerm A) ->
       P x1 -> P (invCl x1)) ->
      (x : ClGroupTerm A) -> P x
    inductionCl _ p psing pecl popcl pinvcl (sing
                                             x1) = psing x1
    inductionCl _ p psing pecl popcl pinvcl (eCl) =
      pecl
    inductionCl _ p psing pecl popcl pinvcl (opCl
                                             x1
                                             x2) =
      popcl _ _
        (inductionCl _ p psing pecl
           popcl
           pinvcl
           x1)
        (inductionCl _ p psing pecl
           popcl
           pinvcl
           x2)
    inductionCl _ p psing pecl popcl pinvcl (invCl
                                             x1) =
      pinvcl _
        (inductionCl _ p psing pecl
           popcl
           pinvcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpGroupTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P eOL ->
      ((x1 : OpGroupTerm n)
       (x2 : OpGroupTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      ((x1 : OpGroupTerm n) ->
       P x1 -> P (invOL x1)) ->
      (x : OpGroupTerm n) -> P x
    inductionOp _ p pv peol popol pinvol (v
                                          x1) = pv x1
    inductionOp _ p pv peol popol pinvol (eOL) =
      peol
    inductionOp _ p pv peol popol pinvol (opOL
                                          x1
                                          x2) =
      popol _ _
        (inductionOp _ p pv peol popol
           pinvol
           x1)
        (inductionOp _ p pv peol popol
           pinvol
           x2)
    inductionOp _ p pv peol popol pinvol (invOL
                                          x1) =
      pinvol _
        (inductionOp _ p pv peol popol
           pinvol
           x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpGroupTerm2 n A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P eOL2 ->
      ((x1 : OpGroupTerm2 n A)
       (x2 : OpGroupTerm2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      ((x1 : OpGroupTerm2 n A) ->
       P x1 -> P (invOL2 x1)) ->
      (x : OpGroupTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 peol2 popol2 pinvol2 (v2
                                                        x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 pinvol2 (sing2
                                                        x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 pinvol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 peol2 popol2 pinvol2 (opOL2
                                                        x1
                                                        x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           pinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           pinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 peol2 popol2 pinvol2 (invOL2
                                                        x1) =
      pinvol2 _
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           pinvol2
           x1)
    eL' : GroupTerm
    eL' = eL
    opL' :
      GroupTerm ->
      GroupTerm -> GroupTerm
    opL' x1 x2 = opL x1 x2
    invL' : GroupTerm -> GroupTerm
    invL' x1 = invL x1
    stageB :
      GroupTerm -> Staged GroupTerm
    stageB (eL) = Now eL
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (invL x1) =
      stage1 _ _ invL'
        (codeLift1 _ _ invL')
        (stageB x1)
    eCl' :
      (A : Set) -> ClGroupTerm A
    eCl' _ = eCl
    opCl' :
      (A : Set) ->
      ClGroupTerm A ->
      ClGroupTerm A -> ClGroupTerm A
    opCl' _ x1 x2 = opCl x1 x2
    invCl' :
      (A : Set) ->
      ClGroupTerm A -> ClGroupTerm A
    invCl' _ x1 = invCl x1
    stageCl :
      (A : Set) ->
      ClGroupTerm A ->
      Staged (ClGroupTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (eCl) = Now eCl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (invCl x1) =
      stage1 _ _ (invCl' _)
        (codeLift1 _ _ (invCl' _))
        (stageCl _ x1)
    eOL' :
      (n : Nat) -> OpGroupTerm n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      OpGroupTerm n ->
      OpGroupTerm n -> OpGroupTerm n
    opOL' _ x1 x2 = opOL x1 x2
    invOL' :
      (n : Nat) ->
      OpGroupTerm n -> OpGroupTerm n
    invOL' _ x1 = invOL x1
    stageOp :
      (n : Nat) ->
      OpGroupTerm n ->
      Staged (OpGroupTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (eOL) = Now eOL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (invOL x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (stageOp _ x1)
    eOL2' :
      (n : Nat) (A : Set) ->
      OpGroupTerm2 n A
    eOL2' _ _ = eOL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpGroupTerm2 n A ->
      OpGroupTerm2 n A ->
      OpGroupTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    invOL2' :
      (n : Nat) (A : Set) ->
      OpGroupTerm2 n A ->
      OpGroupTerm2 n A
    invOL2' _ _ x1 = invOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpGroupTerm2 n A ->
      Staged (OpGroupTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (invOL2 x1) =
      stage1 _ _ (invOL2' _ _)
        (codeLift1 _ _ (invOL2' _ _))
        (stageOpE _ _ x1)
    record GroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        eT : Repr A
        opT : Repr A -> Repr A -> Repr A
        invT : Repr A -> Repr A
  
  module Group1 where
    record Group1
      (A : Set) : Set where
      constructor Group1C
      field
        1 : A
        op : A -> A -> A
        lunit_1 : (x : A) -> op 1 x == x
        runit_1 : (x : A) -> op x 1 == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        inv : A -> A
        leftInverse_inv_op_1 :
          (x : A) -> op x (inv x) == 1
        rightInverse_inv_op_1 :
          (x : A) -> op (inv x) x == 1
    record Group1Sig
      (AS : Set) : Set where
      constructor Group1SigSigC
      field
        1S : AS
        opS : AS -> AS -> AS
        invS : AS -> AS
    record Group1Prod
      (AP : Set) : Set where
      constructor Group1ProdC
      field
        1P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          opP 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          opP xP 1P == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          opP xP (invP xP) == 1P
        rightInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          opP (invP xP) xP == 1P
    record Group1Hom
      (A1 : Set) (A2 : Set)
      (Gr1 : Group1 A1)
      (Gr2 : Group1 A2) : Set where
      constructor Group1HomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Gr1) == 1 Gr2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Gr1 x1 x2) ==
            op Gr2 (hom x1) (hom x2)
        pres-inv :
          (x1 : A1) ->
          hom (inv Gr1 x1) ==
            inv Gr2 (hom x1)
    record Group1RelInterp
      (A1 : Set) (A2 : Set)
      (Gr1 : Group1 A1)
      (Gr2 : Group1 A2) : Set where
      constructor Group1RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Gr1) (1 Gr2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Gr1 x1 x2)
            (op Gr2 y1 y2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Gr1 x1) (inv Gr2 y1)
    data Group1LTerm : Set where
      1L : Group1LTerm
      opL :
        Group1LTerm ->
        Group1LTerm -> Group1LTerm
      invL :
        Group1LTerm -> Group1LTerm
    data ClGroup1ClTerm
      (A : Set) : Set where
      sing : A -> ClGroup1ClTerm A
      1Cl : ClGroup1ClTerm A
      opCl :
        ClGroup1ClTerm A ->
        ClGroup1ClTerm A ->
        ClGroup1ClTerm A
      invCl :
        ClGroup1ClTerm A ->
        ClGroup1ClTerm A
    data OpGroup1OLTerm
      (n : Nat) : Set where
      v : Fin n -> OpGroup1OLTerm n
      1OL : OpGroup1OLTerm n
      opOL :
        OpGroup1OLTerm n ->
        OpGroup1OLTerm n ->
        OpGroup1OLTerm n
      invOL :
        OpGroup1OLTerm n ->
        OpGroup1OLTerm n
    data OpGroup1OL2Term2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpGroup1OL2Term2 n A
      sing2 :
        A -> OpGroup1OL2Term2 n A
      1OL2 : OpGroup1OL2Term2 n A
      opOL2 :
        OpGroup1OL2Term2 n A ->
        OpGroup1OL2Term2 n A ->
        OpGroup1OL2Term2 n A
      invOL2 :
        OpGroup1OL2Term2 n A ->
        OpGroup1OL2Term2 n A
    simplifyB :
      Group1LTerm -> Group1LTerm
    simplifyB (opL (1L) x) = x
    simplifyB (opL x (1L)) = x
    simplifyB (opL x (invL x)) = 1L
    simplifyB (opL (invL x) x) = 1L
    simplifyB (1L) = 1L
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (invL x1) =
      invL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClGroup1ClTerm A ->
      ClGroup1ClTerm A
    simplifyCl _ (opCl (1Cl) x) = x
    simplifyCl _ (opCl x (1Cl)) = x
    simplifyCl _ (opCl
                  x
                  (invCl x)) = 1Cl
    simplifyCl _ (opCl
                  (invCl x)
                  x) = 1Cl
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (invCl x1) =
      invCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpGroup1OLTerm n ->
      OpGroup1OLTerm n
    simplifyOp _ (opOL (1OL) x) = x
    simplifyOp _ (opOL x (1OL)) = x
    simplifyOp _ (opOL
                  x
                  (invOL x)) = 1OL
    simplifyOp _ (opOL
                  (invOL x)
                  x) = 1OL
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (invOL x1) =
      invOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpGroup1OL2Term2 n A ->
      OpGroup1OL2Term2 n A
    simplifyOpE _ _ (opOL2
                     (1OL2)
                     x) = x
    simplifyOpE _ _ (opOL2
                     x
                     (1OL2)) = x
    simplifyOpE _ _ (opOL2
                     x
                     (invOL2 x)) = 1OL2
    simplifyOpE _ _ (opOL2
                     (invOL2 x)
                     x) = 1OL2
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (invOL2 x1) =
      invOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Group1 A -> Group1LTerm -> A
    evalB _ Gr (1L) = 1 Gr
    evalB _ Gr (opL x1 x2) =
      op Gr (evalB _ Gr x1)
        (evalB _ Gr x2)
    evalB _ Gr (invL x1) =
      inv Gr (evalB _ Gr x1)
    evalCl :
      (A : Set) ->
      Group1 A ->
      ClGroup1ClTerm A -> A
    evalCl _ Gr (sing x1) = x1
    evalCl _ Gr (1Cl) = 1 Gr
    evalCl _ Gr (opCl x1 x2) =
      op Gr (evalCl _ Gr x1)
        (evalCl _ Gr x2)
    evalCl _ Gr (invCl x1) =
      inv Gr (evalCl _ Gr x1)
    evalOp :
      (A : Set) (n : Nat) ->
      Group1 A ->
      Vec A n -> OpGroup1OLTerm n -> A
    evalOp _ n Gr vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Gr vars (1OL) = 1 Gr
    evalOp _ n Gr vars (opOL
                        x1
                        x2) =
      op Gr (evalOp _ n Gr vars x1)
        (evalOp _ n Gr vars x2)
    evalOp _ n Gr vars (invOL x1) =
      inv Gr (evalOp _ n Gr vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      Group1 A ->
      Vec A n ->
      OpGroup1OL2Term2 n A -> A
    evalOpE _ n Gr vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Gr vars (sing2 x1) =
      x1
    evalOpE _ n Gr vars (1OL2) =
      1 Gr
    evalOpE _ n Gr vars (opOL2
                         x1
                         x2) =
      op Gr (evalOpE _ n Gr vars x1)
        (evalOpE _ n Gr vars x2)
    evalOpE _ n Gr vars (invOL2
                         x1) =
      inv Gr (evalOpE _ n Gr vars x1)
    inductionB :
      (P : Group1LTerm -> Set) ->
      P 1L ->
      ((x1 : Group1LTerm)
       (x2 : Group1LTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      ((x1 : Group1LTerm) ->
       P x1 -> P (invL x1)) ->
      (x : Group1LTerm) -> P x
    inductionB p p1l popl pinvl (1L) =
      p1l
    inductionB p p1l popl pinvl (opL
                                 x1
                                 x2) =
      popl _ _
        (inductionB p p1l popl pinvl x1)
        (inductionB p p1l popl pinvl x2)
    inductionB p p1l popl pinvl (invL
                                 x1) =
      pinvl _
        (inductionB p p1l popl pinvl x1)
    inductionCl :
      (A : Set)
      (P : ClGroup1ClTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 1Cl ->
      ((x1 : ClGroup1ClTerm A)
       (x2 : ClGroup1ClTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      ((x1 : ClGroup1ClTerm A) ->
       P x1 -> P (invCl x1)) ->
      (x : ClGroup1ClTerm A) -> P x
    inductionCl _ p psing p1cl popcl pinvcl (sing
                                             x1) = psing x1
    inductionCl _ p psing p1cl popcl pinvcl (1Cl) =
      p1cl
    inductionCl _ p psing p1cl popcl pinvcl (opCl
                                             x1
                                             x2) =
      popcl _ _
        (inductionCl _ p psing p1cl
           popcl
           pinvcl
           x1)
        (inductionCl _ p psing p1cl
           popcl
           pinvcl
           x2)
    inductionCl _ p psing p1cl popcl pinvcl (invCl
                                             x1) =
      pinvcl _
        (inductionCl _ p psing p1cl
           popcl
           pinvcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpGroup1OLTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 1OL ->
      ((x1 : OpGroup1OLTerm n)
       (x2 : OpGroup1OLTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      ((x1 : OpGroup1OLTerm n) ->
       P x1 -> P (invOL x1)) ->
      (x : OpGroup1OLTerm n) -> P x
    inductionOp _ p pv p1ol popol pinvol (v
                                          x1) = pv x1
    inductionOp _ p pv p1ol popol pinvol (1OL) =
      p1ol
    inductionOp _ p pv p1ol popol pinvol (opOL
                                          x1
                                          x2) =
      popol _ _
        (inductionOp _ p pv p1ol popol
           pinvol
           x1)
        (inductionOp _ p pv p1ol popol
           pinvol
           x2)
    inductionOp _ p pv p1ol popol pinvol (invOL
                                          x1) =
      pinvol _
        (inductionOp _ p pv p1ol popol
           pinvol
           x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpGroup1OL2Term2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 1OL2 ->
      ((x1 : OpGroup1OL2Term2 n A)
       (x2 : OpGroup1OL2Term2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      ((x1 : OpGroup1OL2Term2 n A) ->
       P x1 -> P (invOL2 x1)) ->
      (x : OpGroup1OL2Term2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p1ol2 popol2 pinvol2 (v2
                                                        x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p1ol2 popol2 pinvol2 (sing2
                                                        x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p1ol2 popol2 pinvol2 (1OL2) =
      p1ol2
    inductionOpE _ _ p pv2 psing2 p1ol2 popol2 pinvol2 (opOL2
                                                        x1
                                                        x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p1ol2
           popol2
           pinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p1ol2
           popol2
           pinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 p1ol2 popol2 pinvol2 (invOL2
                                                        x1) =
      pinvol2 _
        (inductionOpE _ _ p pv2 psing2
           p1ol2
           popol2
           pinvol2
           x1)
    1L' : Group1LTerm
    1L' = 1L
    opL' :
      Group1LTerm ->
      Group1LTerm -> Group1LTerm
    opL' x1 x2 = opL x1 x2
    invL' :
      Group1LTerm -> Group1LTerm
    invL' x1 = invL x1
    stageB :
      Group1LTerm ->
      Staged Group1LTerm
    stageB (1L) = Now 1L
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (invL x1) =
      stage1 _ _ invL'
        (codeLift1 _ _ invL')
        (stageB x1)
    1Cl' :
      (A : Set) -> ClGroup1ClTerm A
    1Cl' _ = 1Cl
    opCl' :
      (A : Set) ->
      ClGroup1ClTerm A ->
      ClGroup1ClTerm A ->
      ClGroup1ClTerm A
    opCl' _ x1 x2 = opCl x1 x2
    invCl' :
      (A : Set) ->
      ClGroup1ClTerm A ->
      ClGroup1ClTerm A
    invCl' _ x1 = invCl x1
    stageCl :
      (A : Set) ->
      ClGroup1ClTerm A ->
      Staged (ClGroup1ClTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (1Cl) = Now 1Cl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (invCl x1) =
      stage1 _ _ (invCl' _)
        (codeLift1 _ _ (invCl' _))
        (stageCl _ x1)
    1OL' :
      (n : Nat) -> OpGroup1OLTerm n
    1OL' _ = 1OL
    opOL' :
      (n : Nat) ->
      OpGroup1OLTerm n ->
      OpGroup1OLTerm n ->
      OpGroup1OLTerm n
    opOL' _ x1 x2 = opOL x1 x2
    invOL' :
      (n : Nat) ->
      OpGroup1OLTerm n ->
      OpGroup1OLTerm n
    invOL' _ x1 = invOL x1
    stageOp :
      (n : Nat) ->
      OpGroup1OLTerm n ->
      Staged (OpGroup1OLTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (1OL) = Now 1OL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (invOL x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (stageOp _ x1)
    1OL2' :
      (n : Nat) (A : Set) ->
      OpGroup1OL2Term2 n A
    1OL2' _ _ = 1OL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpGroup1OL2Term2 n A ->
      OpGroup1OL2Term2 n A ->
      OpGroup1OL2Term2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    invOL2' :
      (n : Nat) (A : Set) ->
      OpGroup1OL2Term2 n A ->
      OpGroup1OL2Term2 n A
    invOL2' _ _ x1 = invOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpGroup1OL2Term2 n A ->
      Staged (OpGroup1OL2Term2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (1OL2) = Now 1OL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (invOL2 x1) =
      stage1 _ _ (invOL2' _ _)
        (codeLift1 _ _ (invOL2' _ _))
        (stageOpE _ _ x1)
    record Group1Tagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        1T : Repr A
        opT : Repr A -> Repr A -> Repr A
        invT : Repr A -> Repr A
  
  module IdempotentAdditiveMagma where
    record IdempotentAdditiveMagma
      (A : Set) : Set where
      constructor IdempotentAdditiveMagmaC
      field
        + : A -> A -> A
        idempotent_+ :
          (x : A) -> + x x == x
    record IdempotentAdditiveMagmaSig
      (AS : Set) : Set where
      constructor IdempotentAdditiveMagmaSigSigC
      field
        +S : AS -> AS -> AS
    record IdempotentAdditiveMagmaProd
      (AP : Set) : Set where
      constructor IdempotentAdditiveMagmaProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record IdempotentAdditiveMagmaHom
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentAdditiveMagma
         A1)
      (Id2 : IdempotentAdditiveMagma
         A2) : Set where
      constructor IdempotentAdditiveMagmaHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Id1 x1 x2) ==
            + Id2 (hom x1) (hom x2)
    record IdempotentAdditiveMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentAdditiveMagma
         A1)
      (Id2 : IdempotentAdditiveMagma
         A2) : Set where
      constructor IdempotentAdditiveMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Id1 x1 x2)
            (+ Id2 y1 y2)
    data IdempotentAdditiveMagmaTerm
      : Set where
      +L :
        IdempotentAdditiveMagmaTerm ->
        IdempotentAdditiveMagmaTerm ->
        IdempotentAdditiveMagmaTerm
    data ClIdempotentAdditiveMagmaTerm
      (A : Set) : Set where
      sing :
        A ->
        ClIdempotentAdditiveMagmaTerm A
      +Cl :
        ClIdempotentAdditiveMagmaTerm
          A ->
        ClIdempotentAdditiveMagmaTerm
          A ->
        ClIdempotentAdditiveMagmaTerm A
    data OpIdempotentAdditiveMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpIdempotentAdditiveMagmaTerm n
      +OL :
        OpIdempotentAdditiveMagmaTerm
          n ->
        OpIdempotentAdditiveMagmaTerm
          n ->
        OpIdempotentAdditiveMagmaTerm n
    data OpIdempotentAdditiveMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpIdempotentAdditiveMagmaTerm2 n
          A
      sing2 :
        A ->
        OpIdempotentAdditiveMagmaTerm2 n
          A
      +OL2 :
        OpIdempotentAdditiveMagmaTerm2 n
          A ->
        OpIdempotentAdditiveMagmaTerm2 n
          A ->
        OpIdempotentAdditiveMagmaTerm2 n
          A
    simplifyB :
      IdempotentAdditiveMagmaTerm ->
      IdempotentAdditiveMagmaTerm
    simplifyB (+L x x) = x
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClIdempotentAdditiveMagmaTerm
        A ->
      ClIdempotentAdditiveMagmaTerm A
    simplifyCl _ (+Cl x x) = x
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpIdempotentAdditiveMagmaTerm
        n ->
      OpIdempotentAdditiveMagmaTerm n
    simplifyOp _ (+OL x x) = x
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpIdempotentAdditiveMagmaTerm2 n
        A ->
      OpIdempotentAdditiveMagmaTerm2 n
        A
    simplifyOpE _ _ (+OL2 x x) = x
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      IdempotentAdditiveMagma A ->
      IdempotentAdditiveMagmaTerm -> A
    evalB _ Id (+L x1 x2) =
      + Id (evalB _ Id x1)
        (evalB _ Id x2)
    evalCl :
      (A : Set) ->
      IdempotentAdditiveMagma A ->
      ClIdempotentAdditiveMagmaTerm
        A -> A
    evalCl _ Id (sing x1) = x1
    evalCl _ Id (+Cl x1 x2) =
      + Id (evalCl _ Id x1)
        (evalCl _ Id x2)
    evalOp :
      (A : Set) (n : Nat) ->
      IdempotentAdditiveMagma A ->
      Vec A n ->
      OpIdempotentAdditiveMagmaTerm
        n -> A
    evalOp _ n Id vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Id vars (+OL x1 x2) =
      + Id (evalOp _ n Id vars x1)
        (evalOp _ n Id vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      IdempotentAdditiveMagma A ->
      Vec A n ->
      OpIdempotentAdditiveMagmaTerm2 n
        A -> A
    evalOpE _ n Id vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Id vars (sing2 x1) =
      x1
    evalOpE _ n Id vars (+OL2
                         x1
                         x2) =
      + Id (evalOpE _ n Id vars x1)
        (evalOpE _ n Id vars x2)
    inductionB :
      (P : IdempotentAdditiveMagmaTerm ->
           Set) ->
      ((x1 : IdempotentAdditiveMagmaTerm)
       (x2 : IdempotentAdditiveMagmaTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : IdempotentAdditiveMagmaTerm) ->
      P x
    inductionB p p+l (+L x1 x2) =
      p+l _ _ (inductionB p p+l x1)
        (inductionB p p+l x2)
    inductionCl :
      (A : Set)
      (P : ClIdempotentAdditiveMagmaTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClIdempotentAdditiveMagmaTerm
          A)
       (x2 : ClIdempotentAdditiveMagmaTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClIdempotentAdditiveMagmaTerm
         A) -> P x
    inductionCl _ p psing p+cl (sing
                                x1) = psing x1
    inductionCl _ p psing p+cl (+Cl
                                x1
                                x2) =
      p+cl _ _
        (inductionCl _ p psing p+cl x1)
        (inductionCl _ p psing p+cl x2)
    inductionOp :
      (n : Nat)
      (P : OpIdempotentAdditiveMagmaTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpIdempotentAdditiveMagmaTerm
          n)
       (x2 : OpIdempotentAdditiveMagmaTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpIdempotentAdditiveMagmaTerm
         n) -> P x
    inductionOp _ p pv p+ol (v x1) =
      pv x1
    inductionOp _ p pv p+ol (+OL
                             x1
                             x2) =
      p+ol _ _
        (inductionOp _ p pv p+ol x1)
        (inductionOp _ p pv p+ol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpIdempotentAdditiveMagmaTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpIdempotentAdditiveMagmaTerm2
          n
          A)
       (x2 : OpIdempotentAdditiveMagmaTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpIdempotentAdditiveMagmaTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p+ol2 (v2
                                         x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 (sing2
                                         x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 (+OL2
                                         x1
                                         x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           x2)
    +L' :
      IdempotentAdditiveMagmaTerm ->
      IdempotentAdditiveMagmaTerm ->
      IdempotentAdditiveMagmaTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      IdempotentAdditiveMagmaTerm ->
      Staged
        IdempotentAdditiveMagmaTerm
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    +Cl' :
      (A : Set) ->
      ClIdempotentAdditiveMagmaTerm
        A ->
      ClIdempotentAdditiveMagmaTerm
        A ->
      ClIdempotentAdditiveMagmaTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClIdempotentAdditiveMagmaTerm
        A ->
      Staged
        (ClIdempotentAdditiveMagmaTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    +OL' :
      (n : Nat) ->
      OpIdempotentAdditiveMagmaTerm
        n ->
      OpIdempotentAdditiveMagmaTerm
        n ->
      OpIdempotentAdditiveMagmaTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpIdempotentAdditiveMagmaTerm
        n ->
      Staged
        (OpIdempotentAdditiveMagmaTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    +OL2' :
      (n : Nat) (A : Set) ->
      OpIdempotentAdditiveMagmaTerm2 n
        A ->
      OpIdempotentAdditiveMagmaTerm2 n
        A ->
      OpIdempotentAdditiveMagmaTerm2 n
        A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpIdempotentAdditiveMagmaTerm2 n
        A ->
      Staged
        (OpIdempotentAdditiveMagmaTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record IdempotentAdditiveMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        +T : Repr A -> Repr A -> Repr A
  
  module IdempotentMagma where
    record IdempotentMagma
      (A : Set) : Set where
      constructor IdempotentMagmaC
      field
        op : A -> A -> A
        idempotent_op :
          (x : A) -> op x x == x
    record IdempotentMagmaSig
      (AS : Set) : Set where
      constructor IdempotentMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record IdempotentMagmaProd
      (AP : Set) : Set where
      constructor IdempotentMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        idempotent_opP :
          (xP : Prod AP AP) ->
          opP xP xP == xP
    record IdempotentMagmaHom
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentMagma A1)
      (Id2 : IdempotentMagma A2) :
      Set where
      constructor IdempotentMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Id1 x1 x2) ==
            op Id2 (hom x1) (hom x2)
    record IdempotentMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentMagma A1)
      (Id2 : IdempotentMagma A2) :
      Set where
      constructor IdempotentMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Id1 x1 x2)
            (op Id2 y1 y2)
    data IdempotentMagmaTerm
      : Set where
      opL :
        IdempotentMagmaTerm ->
        IdempotentMagmaTerm ->
        IdempotentMagmaTerm
    data ClIdempotentMagmaTerm
      (A : Set) : Set where
      sing :
        A -> ClIdempotentMagmaTerm A
      opCl :
        ClIdempotentMagmaTerm A ->
        ClIdempotentMagmaTerm A ->
        ClIdempotentMagmaTerm A
    data OpIdempotentMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpIdempotentMagmaTerm n
      opOL :
        OpIdempotentMagmaTerm n ->
        OpIdempotentMagmaTerm n ->
        OpIdempotentMagmaTerm n
    data OpIdempotentMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpIdempotentMagmaTerm2 n A
      sing2 :
        A -> OpIdempotentMagmaTerm2 n A
      opOL2 :
        OpIdempotentMagmaTerm2 n A ->
        OpIdempotentMagmaTerm2 n A ->
        OpIdempotentMagmaTerm2 n A
    simplifyB :
      IdempotentMagmaTerm ->
      IdempotentMagmaTerm
    simplifyB (opL x x) = x
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClIdempotentMagmaTerm A ->
      ClIdempotentMagmaTerm A
    simplifyCl _ (opCl x x) = x
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpIdempotentMagmaTerm n ->
      OpIdempotentMagmaTerm n
    simplifyOp _ (opOL x x) = x
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpIdempotentMagmaTerm2 n A ->
      OpIdempotentMagmaTerm2 n A
    simplifyOpE _ _ (opOL2 x x) = x
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      IdempotentMagma A ->
      IdempotentMagmaTerm -> A
    evalB _ Id (opL x1 x2) =
      op Id (evalB _ Id x1)
        (evalB _ Id x2)
    evalCl :
      (A : Set) ->
      IdempotentMagma A ->
      ClIdempotentMagmaTerm A -> A
    evalCl _ Id (sing x1) = x1
    evalCl _ Id (opCl x1 x2) =
      op Id (evalCl _ Id x1)
        (evalCl _ Id x2)
    evalOp :
      (A : Set) (n : Nat) ->
      IdempotentMagma A ->
      Vec A n ->
      OpIdempotentMagmaTerm n -> A
    evalOp _ n Id vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Id vars (opOL
                        x1
                        x2) =
      op Id (evalOp _ n Id vars x1)
        (evalOp _ n Id vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      IdempotentMagma A ->
      Vec A n ->
      OpIdempotentMagmaTerm2 n A -> A
    evalOpE _ n Id vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Id vars (sing2 x1) =
      x1
    evalOpE _ n Id vars (opOL2
                         x1
                         x2) =
      op Id (evalOpE _ n Id vars x1)
        (evalOpE _ n Id vars x2)
    inductionB :
      (P : IdempotentMagmaTerm ->
           Set) ->
      ((x1 : IdempotentMagmaTerm)
       (x2 : IdempotentMagmaTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : IdempotentMagmaTerm) -> P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClIdempotentMagmaTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClIdempotentMagmaTerm A)
       (x2 : ClIdempotentMagmaTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClIdempotentMagmaTerm A) ->
      P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpIdempotentMagmaTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpIdempotentMagmaTerm n)
       (x2 : OpIdempotentMagmaTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpIdempotentMagmaTerm n) ->
      P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpIdempotentMagmaTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpIdempotentMagmaTerm2 n
          A)
       (x2 : OpIdempotentMagmaTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpIdempotentMagmaTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      IdempotentMagmaTerm ->
      IdempotentMagmaTerm ->
      IdempotentMagmaTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      IdempotentMagmaTerm ->
      Staged IdempotentMagmaTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClIdempotentMagmaTerm A ->
      ClIdempotentMagmaTerm A ->
      ClIdempotentMagmaTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClIdempotentMagmaTerm A ->
      Staged (ClIdempotentMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpIdempotentMagmaTerm n ->
      OpIdempotentMagmaTerm n ->
      OpIdempotentMagmaTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpIdempotentMagmaTerm n ->
      Staged (OpIdempotentMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpIdempotentMagmaTerm2 n A ->
      OpIdempotentMagmaTerm2 n A ->
      OpIdempotentMagmaTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpIdempotentMagmaTerm2 n A ->
      Staged
        (OpIdempotentMagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record IdempotentMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module IdempotentMultMagma where
    record IdempotentMultMagma
      (A : Set) : Set where
      constructor IdempotentMultMagmaC
      field
        * : A -> A -> A
        idempotent_* :
          (x : A) -> * x x == x
    record IdempotentMultMagmaSig
      (AS : Set) : Set where
      constructor IdempotentMultMagmaSigSigC
      field
        *S : AS -> AS -> AS
    record IdempotentMultMagmaProd
      (AP : Set) : Set where
      constructor IdempotentMultMagmaProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
    record IdempotentMultMagmaHom
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentMultMagma A1)
      (Id2 : IdempotentMultMagma A2) :
      Set where
      constructor IdempotentMultMagmaHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Id1 x1 x2) ==
            * Id2 (hom x1) (hom x2)
    record IdempotentMultMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentMultMagma A1)
      (Id2 : IdempotentMultMagma A2) :
      Set where
      constructor IdempotentMultMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Id1 x1 x2)
            (* Id2 y1 y2)
    data IdempotentMultMagmaTerm
      : Set where
      *L :
        IdempotentMultMagmaTerm ->
        IdempotentMultMagmaTerm ->
        IdempotentMultMagmaTerm
    data ClIdempotentMultMagmaTerm
      (A : Set) : Set where
      sing :
        A -> ClIdempotentMultMagmaTerm A
      *Cl :
        ClIdempotentMultMagmaTerm A ->
        ClIdempotentMultMagmaTerm A ->
        ClIdempotentMultMagmaTerm A
    data OpIdempotentMultMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpIdempotentMultMagmaTerm n
      *OL :
        OpIdempotentMultMagmaTerm n ->
        OpIdempotentMultMagmaTerm n ->
        OpIdempotentMultMagmaTerm n
    data OpIdempotentMultMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpIdempotentMultMagmaTerm2 n A
      sing2 :
        A ->
        OpIdempotentMultMagmaTerm2 n A
      *OL2 :
        OpIdempotentMultMagmaTerm2 n
          A ->
        OpIdempotentMultMagmaTerm2 n
          A ->
        OpIdempotentMultMagmaTerm2 n A
    simplifyB :
      IdempotentMultMagmaTerm ->
      IdempotentMultMagmaTerm
    simplifyB (*L x x) = x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClIdempotentMultMagmaTerm A ->
      ClIdempotentMultMagmaTerm A
    simplifyCl _ (*Cl x x) = x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpIdempotentMultMagmaTerm n ->
      OpIdempotentMultMagmaTerm n
    simplifyOp _ (*OL x x) = x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpIdempotentMultMagmaTerm2 n
        A ->
      OpIdempotentMultMagmaTerm2 n A
    simplifyOpE _ _ (*OL2 x x) = x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      IdempotentMultMagma A ->
      IdempotentMultMagmaTerm -> A
    evalB _ Id (*L x1 x2) =
      * Id (evalB _ Id x1)
        (evalB _ Id x2)
    evalCl :
      (A : Set) ->
      IdempotentMultMagma A ->
      ClIdempotentMultMagmaTerm A -> A
    evalCl _ Id (sing x1) = x1
    evalCl _ Id (*Cl x1 x2) =
      * Id (evalCl _ Id x1)
        (evalCl _ Id x2)
    evalOp :
      (A : Set) (n : Nat) ->
      IdempotentMultMagma A ->
      Vec A n ->
      OpIdempotentMultMagmaTerm n -> A
    evalOp _ n Id vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Id vars (*OL x1 x2) =
      * Id (evalOp _ n Id vars x1)
        (evalOp _ n Id vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      IdempotentMultMagma A ->
      Vec A n ->
      OpIdempotentMultMagmaTerm2 n
        A -> A
    evalOpE _ n Id vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Id vars (sing2 x1) =
      x1
    evalOpE _ n Id vars (*OL2
                         x1
                         x2) =
      * Id (evalOpE _ n Id vars x1)
        (evalOpE _ n Id vars x2)
    inductionB :
      (P : IdempotentMultMagmaTerm ->
           Set) ->
      ((x1 : IdempotentMultMagmaTerm)
       (x2 : IdempotentMultMagmaTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      (x : IdempotentMultMagmaTerm) ->
      P x
    inductionB p p*l (*L x1 x2) =
      p*l _ _ (inductionB p p*l x1)
        (inductionB p p*l x2)
    inductionCl :
      (A : Set)
      (P : ClIdempotentMultMagmaTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClIdempotentMultMagmaTerm
          A)
       (x2 : ClIdempotentMultMagmaTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      (x : ClIdempotentMultMagmaTerm
         A) -> P x
    inductionCl _ p psing p*cl (sing
                                x1) = psing x1
    inductionCl _ p psing p*cl (*Cl
                                x1
                                x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl x1)
        (inductionCl _ p psing p*cl x2)
    inductionOp :
      (n : Nat)
      (P : OpIdempotentMultMagmaTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpIdempotentMultMagmaTerm
          n)
       (x2 : OpIdempotentMultMagmaTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      (x : OpIdempotentMultMagmaTerm
         n) -> P x
    inductionOp _ p pv p*ol (v x1) =
      pv x1
    inductionOp _ p pv p*ol (*OL
                             x1
                             x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol x1)
        (inductionOp _ p pv p*ol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpIdempotentMultMagmaTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpIdempotentMultMagmaTerm2
          n
          A)
       (x2 : OpIdempotentMultMagmaTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      (x : OpIdempotentMultMagmaTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 (v2
                                         x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 (sing2
                                         x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 (*OL2
                                         x1
                                         x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           x2)
    *L' :
      IdempotentMultMagmaTerm ->
      IdempotentMultMagmaTerm ->
      IdempotentMultMagmaTerm
    *L' x1 x2 = *L x1 x2
    stageB :
      IdempotentMultMagmaTerm ->
      Staged IdempotentMultMagmaTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClIdempotentMultMagmaTerm A ->
      ClIdempotentMultMagmaTerm A ->
      ClIdempotentMultMagmaTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    stageCl :
      (A : Set) ->
      ClIdempotentMultMagmaTerm A ->
      Staged
        (ClIdempotentMultMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpIdempotentMultMagmaTerm n ->
      OpIdempotentMultMagmaTerm n ->
      OpIdempotentMultMagmaTerm n
    *OL' _ x1 x2 = *OL x1 x2
    stageOp :
      (n : Nat) ->
      OpIdempotentMultMagmaTerm n ->
      Staged
        (OpIdempotentMultMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpIdempotentMultMagmaTerm2 n
        A ->
      OpIdempotentMultMagmaTerm2 n
        A ->
      OpIdempotentMultMagmaTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpIdempotentMultMagmaTerm2 n
        A ->
      Staged
        (OpIdempotentMultMagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record IdempotentMultMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
  
  module IdempotentSemiRng where
    record IdempotentSemiRng
      (A : Set) : Set where
      constructor IdempotentSemiRngC
      field
        + : A -> A -> A
        * : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        idempotent_+ :
          (x : A) -> + x x == x
    record IdempotentSemiRngSig
      (AS : Set) : Set where
      constructor IdempotentSemiRngSigSigC
      field
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
        0S : AS
    record IdempotentSemiRngProd
      (AP : Set) : Set where
      constructor IdempotentSemiRngProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record IdempotentSemiRngHom
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentSemiRng A1)
      (Id2 : IdempotentSemiRng A2) :
      Set where
      constructor IdempotentSemiRngHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Id1 x1 x2) ==
            + Id2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Id1 x1 x2) ==
            * Id2 (hom x1) (hom x2)
        pres-0 : hom (0 Id1) == 0 Id2
    record IdempotentSemiRngRelInterp
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentSemiRng A1)
      (Id2 : IdempotentSemiRng A2) :
      Set where
      constructor IdempotentSemiRngRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Id1 x1 x2)
            (+ Id2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Id1 x1 x2)
            (* Id2 y1 y2)
        interp-0 :
          interp (0 Id1) (0 Id2)
    data IdempotentSemiRngTerm
      : Set where
      +L :
        IdempotentSemiRngTerm ->
        IdempotentSemiRngTerm ->
        IdempotentSemiRngTerm
      *L :
        IdempotentSemiRngTerm ->
        IdempotentSemiRngTerm ->
        IdempotentSemiRngTerm
      0L : IdempotentSemiRngTerm
    data ClIdempotentSemiRngTerm
      (A : Set) : Set where
      sing :
        A -> ClIdempotentSemiRngTerm A
      +Cl :
        ClIdempotentSemiRngTerm A ->
        ClIdempotentSemiRngTerm A ->
        ClIdempotentSemiRngTerm A
      *Cl :
        ClIdempotentSemiRngTerm A ->
        ClIdempotentSemiRngTerm A ->
        ClIdempotentSemiRngTerm A
      0Cl : ClIdempotentSemiRngTerm A
    data OpIdempotentSemiRngTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpIdempotentSemiRngTerm n
      +OL :
        OpIdempotentSemiRngTerm n ->
        OpIdempotentSemiRngTerm n ->
        OpIdempotentSemiRngTerm n
      *OL :
        OpIdempotentSemiRngTerm n ->
        OpIdempotentSemiRngTerm n ->
        OpIdempotentSemiRngTerm n
      0OL : OpIdempotentSemiRngTerm n
    data OpIdempotentSemiRngTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpIdempotentSemiRngTerm2 n A
      sing2 :
        A ->
        OpIdempotentSemiRngTerm2 n A
      +OL2 :
        OpIdempotentSemiRngTerm2 n A ->
        OpIdempotentSemiRngTerm2 n A ->
        OpIdempotentSemiRngTerm2 n A
      *OL2 :
        OpIdempotentSemiRngTerm2 n A ->
        OpIdempotentSemiRngTerm2 n A ->
        OpIdempotentSemiRngTerm2 n A
      0OL2 :
        OpIdempotentSemiRngTerm2 n A
    simplifyB :
      IdempotentSemiRngTerm ->
      IdempotentSemiRngTerm
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (+L
               (*L x y)
               (*L x z)) = *L x (+L y z)
    simplifyB (+L
               (*L y x)
               (*L z x)) = *L (+L y z) x
    simplifyB (+L x x) = x
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (0L) = 0L
    simplifyCl :
      (A : Set) ->
      ClIdempotentSemiRngTerm A ->
      ClIdempotentSemiRngTerm A
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (+Cl
                  (*Cl x y)
                  (*Cl x z)) = *Cl x (+Cl y z)
    simplifyCl _ (+Cl
                  (*Cl y x)
                  (*Cl z x)) = *Cl (+Cl y z) x
    simplifyCl _ (+Cl x x) = x
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpIdempotentSemiRngTerm n ->
      OpIdempotentSemiRngTerm n
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (+OL
                  (*OL x y)
                  (*OL x z)) = *OL x (+OL y z)
    simplifyOp _ (+OL
                  (*OL y x)
                  (*OL z x)) = *OL (+OL y z) x
    simplifyOp _ (+OL x x) = x
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpIdempotentSemiRngTerm2 n A ->
      OpIdempotentSemiRngTerm2 n A
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (+OL2
                     (*OL2 x y)
                     (*OL2 x z)) = *OL2 x (+OL2 y z)
    simplifyOpE _ _ (+OL2
                     (*OL2 y x)
                     (*OL2 z x)) = *OL2 (+OL2 y z) x
    simplifyOpE _ _ (+OL2 x x) = x
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      IdempotentSemiRng A ->
      IdempotentSemiRngTerm -> A
    evalB _ Id (+L x1 x2) =
      + Id (evalB _ Id x1)
        (evalB _ Id x2)
    evalB _ Id (*L x1 x2) =
      * Id (evalB _ Id x1)
        (evalB _ Id x2)
    evalB _ Id (0L) = 0 Id
    evalCl :
      (A : Set) ->
      IdempotentSemiRng A ->
      ClIdempotentSemiRngTerm A -> A
    evalCl _ Id (sing x1) = x1
    evalCl _ Id (+Cl x1 x2) =
      + Id (evalCl _ Id x1)
        (evalCl _ Id x2)
    evalCl _ Id (*Cl x1 x2) =
      * Id (evalCl _ Id x1)
        (evalCl _ Id x2)
    evalCl _ Id (0Cl) = 0 Id
    evalOp :
      (A : Set) (n : Nat) ->
      IdempotentSemiRng A ->
      Vec A n ->
      OpIdempotentSemiRngTerm n -> A
    evalOp _ n Id vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Id vars (+OL x1 x2) =
      + Id (evalOp _ n Id vars x1)
        (evalOp _ n Id vars x2)
    evalOp _ n Id vars (*OL x1 x2) =
      * Id (evalOp _ n Id vars x1)
        (evalOp _ n Id vars x2)
    evalOp _ n Id vars (0OL) = 0 Id
    evalOpE :
      (A : Set) (n : Nat) ->
      IdempotentSemiRng A ->
      Vec A n ->
      OpIdempotentSemiRngTerm2 n A ->
      A
    evalOpE _ n Id vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Id vars (sing2 x1) =
      x1
    evalOpE _ n Id vars (+OL2
                         x1
                         x2) =
      + Id (evalOpE _ n Id vars x1)
        (evalOpE _ n Id vars x2)
    evalOpE _ n Id vars (*OL2
                         x1
                         x2) =
      * Id (evalOpE _ n Id vars x1)
        (evalOpE _ n Id vars x2)
    evalOpE _ n Id vars (0OL2) =
      0 Id
    inductionB :
      (P : IdempotentSemiRngTerm ->
           Set) ->
      ((x1 : IdempotentSemiRngTerm)
       (x2 : IdempotentSemiRngTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      ((x1 : IdempotentSemiRngTerm)
       (x2 : IdempotentSemiRngTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      P 0L ->
      (x : IdempotentSemiRngTerm) ->
      P x
    inductionB p p+l p*l p0l (+L
                              x1
                              x2) =
      p+l _ _
        (inductionB p p+l p*l p0l x1)
        (inductionB p p+l p*l p0l x2)
    inductionB p p+l p*l p0l (*L
                              x1
                              x2) =
      p*l _ _
        (inductionB p p+l p*l p0l x1)
        (inductionB p p+l p*l p0l x2)
    inductionB p p+l p*l p0l (0L) =
      p0l
    inductionCl :
      (A : Set)
      (P : ClIdempotentSemiRngTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClIdempotentSemiRngTerm
          A)
       (x2 : ClIdempotentSemiRngTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      ((x1 : ClIdempotentSemiRngTerm
          A)
       (x2 : ClIdempotentSemiRngTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      P 0Cl ->
      (x : ClIdempotentSemiRngTerm
         A) -> P x
    inductionCl _ p psing p+cl p*cl p0cl (sing
                                          x1) = psing x1
    inductionCl _ p psing p+cl p*cl p0cl (+Cl
                                          x1
                                          x2) =
      p+cl _ _
        (inductionCl _ p psing p+cl p*cl
           p0cl
           x1)
        (inductionCl _ p psing p+cl p*cl
           p0cl
           x2)
    inductionCl _ p psing p+cl p*cl p0cl (*Cl
                                          x1
                                          x2) =
      p*cl _ _
        (inductionCl _ p psing p+cl p*cl
           p0cl
           x1)
        (inductionCl _ p psing p+cl p*cl
           p0cl
           x2)
    inductionCl _ p psing p+cl p*cl p0cl (0Cl) =
      p0cl
    inductionOp :
      (n : Nat)
      (P : OpIdempotentSemiRngTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpIdempotentSemiRngTerm
          n)
       (x2 : OpIdempotentSemiRngTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      ((x1 : OpIdempotentSemiRngTerm
          n)
       (x2 : OpIdempotentSemiRngTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      P 0OL ->
      (x : OpIdempotentSemiRngTerm
         n) -> P x
    inductionOp _ p pv p+ol p*ol p0ol (v
                                       x1) = pv x1
    inductionOp _ p pv p+ol p*ol p0ol (+OL
                                       x1
                                       x2) =
      p+ol _ _
        (inductionOp _ p pv p+ol p*ol
           p0ol
           x1)
        (inductionOp _ p pv p+ol p*ol
           p0ol
           x2)
    inductionOp _ p pv p+ol p*ol p0ol (*OL
                                       x1
                                       x2) =
      p*ol _ _
        (inductionOp _ p pv p+ol p*ol
           p0ol
           x1)
        (inductionOp _ p pv p+ol p*ol
           p0ol
           x2)
    inductionOp _ p pv p+ol p*ol p0ol (0OL) =
      p0ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpIdempotentSemiRngTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpIdempotentSemiRngTerm2
          n
          A)
       (x2 : OpIdempotentSemiRngTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      ((x1 : OpIdempotentSemiRngTerm2
          n
          A)
       (x2 : OpIdempotentSemiRngTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      P 0OL2 ->
      (x : OpIdempotentSemiRngTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p+ol2 p*ol2 p0ol2 (v2
                                                     x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 p*ol2 p0ol2 (sing2
                                                     x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 p*ol2 p0ol2 (+OL2
                                                     x1
                                                     x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p*ol2
           p0ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p*ol2
           p0ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p+ol2 p*ol2 p0ol2 (*OL2
                                                     x1
                                                     x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p*ol2
           p0ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p*ol2
           p0ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p+ol2 p*ol2 p0ol2 (0OL2) =
      p0ol2
    +L' :
      IdempotentSemiRngTerm ->
      IdempotentSemiRngTerm ->
      IdempotentSemiRngTerm
    +L' x1 x2 = +L x1 x2
    *L' :
      IdempotentSemiRngTerm ->
      IdempotentSemiRngTerm ->
      IdempotentSemiRngTerm
    *L' x1 x2 = *L x1 x2
    0L' : IdempotentSemiRngTerm
    0L' = 0L
    stageB :
      IdempotentSemiRngTerm ->
      Staged IdempotentSemiRngTerm
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (0L) = Now 0L
    +Cl' :
      (A : Set) ->
      ClIdempotentSemiRngTerm A ->
      ClIdempotentSemiRngTerm A ->
      ClIdempotentSemiRngTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    *Cl' :
      (A : Set) ->
      ClIdempotentSemiRngTerm A ->
      ClIdempotentSemiRngTerm A ->
      ClIdempotentSemiRngTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    0Cl' :
      (A : Set) ->
      ClIdempotentSemiRngTerm A
    0Cl' _ = 0Cl
    stageCl :
      (A : Set) ->
      ClIdempotentSemiRngTerm A ->
      Staged
        (ClIdempotentSemiRngTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (0Cl) = Now 0Cl
    +OL' :
      (n : Nat) ->
      OpIdempotentSemiRngTerm n ->
      OpIdempotentSemiRngTerm n ->
      OpIdempotentSemiRngTerm n
    +OL' _ x1 x2 = +OL x1 x2
    *OL' :
      (n : Nat) ->
      OpIdempotentSemiRngTerm n ->
      OpIdempotentSemiRngTerm n ->
      OpIdempotentSemiRngTerm n
    *OL' _ x1 x2 = *OL x1 x2
    0OL' :
      (n : Nat) ->
      OpIdempotentSemiRngTerm n
    0OL' _ = 0OL
    stageOp :
      (n : Nat) ->
      OpIdempotentSemiRngTerm n ->
      Staged
        (OpIdempotentSemiRngTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (0OL) = Now 0OL
    +OL2' :
      (n : Nat) (A : Set) ->
      OpIdempotentSemiRngTerm2 n A ->
      OpIdempotentSemiRngTerm2 n A ->
      OpIdempotentSemiRngTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    *OL2' :
      (n : Nat) (A : Set) ->
      OpIdempotentSemiRngTerm2 n A ->
      OpIdempotentSemiRngTerm2 n A ->
      OpIdempotentSemiRngTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    0OL2' :
      (n : Nat) (A : Set) ->
      OpIdempotentSemiRngTerm2 n A
    0OL2' _ _ = 0OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpIdempotentSemiRngTerm2 n A ->
      Staged
        (OpIdempotentSemiRngTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (0OL2) = Now 0OL2
    record IdempotentSemiRngTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        +T : Repr A -> Repr A -> Repr A
        *T : Repr A -> Repr A -> Repr A
        0T : Repr A
  
  module IdempotentSemiring where
    record IdempotentSemiring
      (A : Set) : Set where
      constructor IdempotentSemiringC
      field
        + : A -> A -> A
        0 : A
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
        idempotent_+ :
          (x : A) -> + x x == x
    record IdempotentSemiringSig
      (AS : Set) : Set where
      constructor IdempotentSemiringSigSigC
      field
        +S : AS -> AS -> AS
        0S : AS
        *S : AS -> AS -> AS
        1S : AS
    record IdempotentSemiringProd
      (AP : Set) : Set where
      constructor IdempotentSemiringProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record IdempotentSemiringHom
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentSemiring A1)
      (Id2 : IdempotentSemiring A2) :
      Set where
      constructor IdempotentSemiringHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Id1 x1 x2) ==
            + Id2 (hom x1) (hom x2)
        pres-0 : hom (0 Id1) == 0 Id2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Id1 x1 x2) ==
            * Id2 (hom x1) (hom x2)
        pres-1 : hom (1 Id1) == 1 Id2
    record IdempotentSemiringRelInterp
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentSemiring A1)
      (Id2 : IdempotentSemiring A2) :
      Set where
      constructor IdempotentSemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Id1 x1 x2)
            (+ Id2 y1 y2)
        interp-0 :
          interp (0 Id1) (0 Id2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Id1 x1 x2)
            (* Id2 y1 y2)
        interp-1 :
          interp (1 Id1) (1 Id2)
    data IdempotentSemiringTerm
      : Set where
      +L :
        IdempotentSemiringTerm ->
        IdempotentSemiringTerm ->
        IdempotentSemiringTerm
      0L : IdempotentSemiringTerm
      *L :
        IdempotentSemiringTerm ->
        IdempotentSemiringTerm ->
        IdempotentSemiringTerm
      1L : IdempotentSemiringTerm
    data ClIdempotentSemiringTerm
      (A : Set) : Set where
      sing :
        A -> ClIdempotentSemiringTerm A
      +Cl :
        ClIdempotentSemiringTerm A ->
        ClIdempotentSemiringTerm A ->
        ClIdempotentSemiringTerm A
      0Cl : ClIdempotentSemiringTerm A
      *Cl :
        ClIdempotentSemiringTerm A ->
        ClIdempotentSemiringTerm A ->
        ClIdempotentSemiringTerm A
      1Cl : ClIdempotentSemiringTerm A
    data OpIdempotentSemiringTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpIdempotentSemiringTerm n
      +OL :
        OpIdempotentSemiringTerm n ->
        OpIdempotentSemiringTerm n ->
        OpIdempotentSemiringTerm n
      0OL : OpIdempotentSemiringTerm n
      *OL :
        OpIdempotentSemiringTerm n ->
        OpIdempotentSemiringTerm n ->
        OpIdempotentSemiringTerm n
      1OL : OpIdempotentSemiringTerm n
    data OpIdempotentSemiringTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpIdempotentSemiringTerm2 n A
      sing2 :
        A ->
        OpIdempotentSemiringTerm2 n A
      +OL2 :
        OpIdempotentSemiringTerm2 n A ->
        OpIdempotentSemiringTerm2 n A ->
        OpIdempotentSemiringTerm2 n A
      0OL2 :
        OpIdempotentSemiringTerm2 n A
      *OL2 :
        OpIdempotentSemiringTerm2 n A ->
        OpIdempotentSemiringTerm2 n A ->
        OpIdempotentSemiringTerm2 n A
      1OL2 :
        OpIdempotentSemiringTerm2 n A
    simplifyB :
      IdempotentSemiringTerm ->
      IdempotentSemiringTerm
    simplifyB (*L (1L) x) = x
    simplifyB (*L x (1L)) = x
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (+L
               (*L x y)
               (*L x z)) = *L x (+L y z)
    simplifyB (+L
               (*L y x)
               (*L z x)) = *L (+L y z) x
    simplifyB (*L (0L) x) = 0L
    simplifyB (*L x (0L)) = 0L
    simplifyB (+L x x) = x
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (0L) = 0L
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (1L) = 1L
    simplifyCl :
      (A : Set) ->
      ClIdempotentSemiringTerm A ->
      ClIdempotentSemiringTerm A
    simplifyCl _ (*Cl (1Cl) x) = x
    simplifyCl _ (*Cl x (1Cl)) = x
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (+Cl
                  (*Cl x y)
                  (*Cl x z)) = *Cl x (+Cl y z)
    simplifyCl _ (+Cl
                  (*Cl y x)
                  (*Cl z x)) = *Cl (+Cl y z) x
    simplifyCl _ (*Cl (0Cl) x) = 0Cl
    simplifyCl _ (*Cl x (0Cl)) = 0Cl
    simplifyCl _ (+Cl x x) = x
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpIdempotentSemiringTerm n ->
      OpIdempotentSemiringTerm n
    simplifyOp _ (*OL (1OL) x) = x
    simplifyOp _ (*OL x (1OL)) = x
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (+OL
                  (*OL x y)
                  (*OL x z)) = *OL x (+OL y z)
    simplifyOp _ (+OL
                  (*OL y x)
                  (*OL z x)) = *OL (+OL y z) x
    simplifyOp _ (*OL (0OL) x) = 0OL
    simplifyOp _ (*OL x (0OL)) = 0OL
    simplifyOp _ (+OL x x) = x
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpIdempotentSemiringTerm2 n A ->
      OpIdempotentSemiringTerm2 n A
    simplifyOpE _ _ (*OL2
                     (1OL2)
                     x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (1OL2)) = x
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (+OL2
                     (*OL2 x y)
                     (*OL2 x z)) = *OL2 x (+OL2 y z)
    simplifyOpE _ _ (+OL2
                     (*OL2 y x)
                     (*OL2 z x)) = *OL2 (+OL2 y z) x
    simplifyOpE _ _ (*OL2
                     (0OL2)
                     x) = 0OL2
    simplifyOpE _ _ (*OL2
                     x
                     (0OL2)) = 0OL2
    simplifyOpE _ _ (+OL2 x x) = x
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      IdempotentSemiring A ->
      IdempotentSemiringTerm -> A
    evalB _ Id (+L x1 x2) =
      + Id (evalB _ Id x1)
        (evalB _ Id x2)
    evalB _ Id (0L) = 0 Id
    evalB _ Id (*L x1 x2) =
      * Id (evalB _ Id x1)
        (evalB _ Id x2)
    evalB _ Id (1L) = 1 Id
    evalCl :
      (A : Set) ->
      IdempotentSemiring A ->
      ClIdempotentSemiringTerm A -> A
    evalCl _ Id (sing x1) = x1
    evalCl _ Id (+Cl x1 x2) =
      + Id (evalCl _ Id x1)
        (evalCl _ Id x2)
    evalCl _ Id (0Cl) = 0 Id
    evalCl _ Id (*Cl x1 x2) =
      * Id (evalCl _ Id x1)
        (evalCl _ Id x2)
    evalCl _ Id (1Cl) = 1 Id
    evalOp :
      (A : Set) (n : Nat) ->
      IdempotentSemiring A ->
      Vec A n ->
      OpIdempotentSemiringTerm n -> A
    evalOp _ n Id vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Id vars (+OL x1 x2) =
      + Id (evalOp _ n Id vars x1)
        (evalOp _ n Id vars x2)
    evalOp _ n Id vars (0OL) = 0 Id
    evalOp _ n Id vars (*OL x1 x2) =
      * Id (evalOp _ n Id vars x1)
        (evalOp _ n Id vars x2)
    evalOp _ n Id vars (1OL) = 1 Id
    evalOpE :
      (A : Set) (n : Nat) ->
      IdempotentSemiring A ->
      Vec A n ->
      OpIdempotentSemiringTerm2 n A ->
      A
    evalOpE _ n Id vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Id vars (sing2 x1) =
      x1
    evalOpE _ n Id vars (+OL2
                         x1
                         x2) =
      + Id (evalOpE _ n Id vars x1)
        (evalOpE _ n Id vars x2)
    evalOpE _ n Id vars (0OL2) =
      0 Id
    evalOpE _ n Id vars (*OL2
                         x1
                         x2) =
      * Id (evalOpE _ n Id vars x1)
        (evalOpE _ n Id vars x2)
    evalOpE _ n Id vars (1OL2) =
      1 Id
    inductionB :
      (P : IdempotentSemiringTerm ->
           Set) ->
      ((x1 : IdempotentSemiringTerm)
       (x2 : IdempotentSemiringTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      P 0L ->
      ((x1 : IdempotentSemiringTerm)
       (x2 : IdempotentSemiringTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      P 1L ->
      (x : IdempotentSemiringTerm) ->
      P x
    inductionB p p+l p0l p*l p1l (+L
                                  x1
                                  x2) =
      p+l _ _
        (inductionB p p+l p0l p*l p1l
           x1)
        (inductionB p p+l p0l p*l p1l
           x2)
    inductionB p p+l p0l p*l p1l (0L) =
      p0l
    inductionB p p+l p0l p*l p1l (*L
                                  x1
                                  x2) =
      p*l _ _
        (inductionB p p+l p0l p*l p1l
           x1)
        (inductionB p p+l p0l p*l p1l
           x2)
    inductionB p p+l p0l p*l p1l (1L) =
      p1l
    inductionCl :
      (A : Set)
      (P : ClIdempotentSemiringTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClIdempotentSemiringTerm
          A)
       (x2 : ClIdempotentSemiringTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      P 0Cl ->
      ((x1 : ClIdempotentSemiringTerm
          A)
       (x2 : ClIdempotentSemiringTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      P 1Cl ->
      (x : ClIdempotentSemiringTerm
         A) -> P x
    inductionCl _ p psing p+cl p0cl p*cl p1cl (sing
                                               x1) = psing x1
    inductionCl _ p psing p+cl p0cl p*cl p1cl (+Cl
                                               x1
                                               x2) =
      p+cl _ _
        (inductionCl _ p psing p+cl p0cl
           p*cl
           p1cl
           x1)
        (inductionCl _ p psing p+cl p0cl
           p*cl
           p1cl
           x2)
    inductionCl _ p psing p+cl p0cl p*cl p1cl (0Cl) =
      p0cl
    inductionCl _ p psing p+cl p0cl p*cl p1cl (*Cl
                                               x1
                                               x2) =
      p*cl _ _
        (inductionCl _ p psing p+cl p0cl
           p*cl
           p1cl
           x1)
        (inductionCl _ p psing p+cl p0cl
           p*cl
           p1cl
           x2)
    inductionCl _ p psing p+cl p0cl p*cl p1cl (1Cl) =
      p1cl
    inductionOp :
      (n : Nat)
      (P : OpIdempotentSemiringTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpIdempotentSemiringTerm
          n)
       (x2 : OpIdempotentSemiringTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      P 0OL ->
      ((x1 : OpIdempotentSemiringTerm
          n)
       (x2 : OpIdempotentSemiringTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      P 1OL ->
      (x : OpIdempotentSemiringTerm
         n) -> P x
    inductionOp _ p pv p+ol p0ol p*ol p1ol (v
                                            x1) = pv x1
    inductionOp _ p pv p+ol p0ol p*ol p1ol (+OL
                                            x1
                                            x2) =
      p+ol _ _
        (inductionOp _ p pv p+ol p0ol
           p*ol
           p1ol
           x1)
        (inductionOp _ p pv p+ol p0ol
           p*ol
           p1ol
           x2)
    inductionOp _ p pv p+ol p0ol p*ol p1ol (0OL) =
      p0ol
    inductionOp _ p pv p+ol p0ol p*ol p1ol (*OL
                                            x1
                                            x2) =
      p*ol _ _
        (inductionOp _ p pv p+ol p0ol
           p*ol
           p1ol
           x1)
        (inductionOp _ p pv p+ol p0ol
           p*ol
           p1ol
           x2)
    inductionOp _ p pv p+ol p0ol p*ol p1ol (1OL) =
      p1ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpIdempotentSemiringTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpIdempotentSemiringTerm2
          n
          A)
       (x2 : OpIdempotentSemiringTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      P 0OL2 ->
      ((x1 : OpIdempotentSemiringTerm2
          n
          A)
       (x2 : OpIdempotentSemiringTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      P 1OL2 ->
      (x : OpIdempotentSemiringTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 p*ol2 p1ol2 (v2
                                                           x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 p*ol2 p1ol2 (sing2
                                                           x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 p*ol2 p1ol2 (+OL2
                                                           x1
                                                           x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p0ol2
           p*ol2
           p1ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p0ol2
           p*ol2
           p1ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 p*ol2 p1ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 p*ol2 p1ol2 (*OL2
                                                           x1
                                                           x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p0ol2
           p*ol2
           p1ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p0ol2
           p*ol2
           p1ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p+ol2 p0ol2 p*ol2 p1ol2 (1OL2) =
      p1ol2
    +L' :
      IdempotentSemiringTerm ->
      IdempotentSemiringTerm ->
      IdempotentSemiringTerm
    +L' x1 x2 = +L x1 x2
    0L' : IdempotentSemiringTerm
    0L' = 0L
    *L' :
      IdempotentSemiringTerm ->
      IdempotentSemiringTerm ->
      IdempotentSemiringTerm
    *L' x1 x2 = *L x1 x2
    1L' : IdempotentSemiringTerm
    1L' = 1L
    stageB :
      IdempotentSemiringTerm ->
      Staged IdempotentSemiringTerm
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (0L) = Now 0L
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (1L) = Now 1L
    +Cl' :
      (A : Set) ->
      ClIdempotentSemiringTerm A ->
      ClIdempotentSemiringTerm A ->
      ClIdempotentSemiringTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    0Cl' :
      (A : Set) ->
      ClIdempotentSemiringTerm A
    0Cl' _ = 0Cl
    *Cl' :
      (A : Set) ->
      ClIdempotentSemiringTerm A ->
      ClIdempotentSemiringTerm A ->
      ClIdempotentSemiringTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    1Cl' :
      (A : Set) ->
      ClIdempotentSemiringTerm A
    1Cl' _ = 1Cl
    stageCl :
      (A : Set) ->
      ClIdempotentSemiringTerm A ->
      Staged
        (ClIdempotentSemiringTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (1Cl) = Now 1Cl
    +OL' :
      (n : Nat) ->
      OpIdempotentSemiringTerm n ->
      OpIdempotentSemiringTerm n ->
      OpIdempotentSemiringTerm n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      OpIdempotentSemiringTerm n
    0OL' _ = 0OL
    *OL' :
      (n : Nat) ->
      OpIdempotentSemiringTerm n ->
      OpIdempotentSemiringTerm n ->
      OpIdempotentSemiringTerm n
    *OL' _ x1 x2 = *OL x1 x2
    1OL' :
      (n : Nat) ->
      OpIdempotentSemiringTerm n
    1OL' _ = 1OL
    stageOp :
      (n : Nat) ->
      OpIdempotentSemiringTerm n ->
      Staged
        (OpIdempotentSemiringTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (0OL) = Now 0OL
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (1OL) = Now 1OL
    +OL2' :
      (n : Nat) (A : Set) ->
      OpIdempotentSemiringTerm2 n A ->
      OpIdempotentSemiringTerm2 n A ->
      OpIdempotentSemiringTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    0OL2' :
      (n : Nat) (A : Set) ->
      OpIdempotentSemiringTerm2 n A
    0OL2' _ _ = 0OL2
    *OL2' :
      (n : Nat) (A : Set) ->
      OpIdempotentSemiringTerm2 n A ->
      OpIdempotentSemiringTerm2 n A ->
      OpIdempotentSemiringTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    1OL2' :
      (n : Nat) (A : Set) ->
      OpIdempotentSemiringTerm2 n A
    1OL2' _ _ = 1OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpIdempotentSemiringTerm2 n A ->
      Staged
        (OpIdempotentSemiringTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (1OL2) = Now 1OL2
    record IdempotentSemiringTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        +T : Repr A -> Repr A -> Repr A
        0T : Repr A
        *T : Repr A -> Repr A -> Repr A
        1T : Repr A
  
  module IdempotentUnary where
    record IdempotentUnary
      (A : Set) : Set where
      constructor IdempotentUnaryC
      field
        prim : A -> A
        idempotent_prim :
          (x : A) ->
          prim (prim x) == prim x
    record IdempotentUnarySig
      (AS : Set) : Set where
      constructor IdempotentUnarySigSigC
      field
        primS : AS -> AS
    record IdempotentUnaryProd
      (AP : Set) : Set where
      constructor IdempotentUnaryProdC
      field
        primP : Prod AP AP -> Prod AP AP
        idempotent_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == primP xP
    record IdempotentUnaryHom
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentUnary A1)
      (Id2 : IdempotentUnary A2) :
      Set where
      constructor IdempotentUnaryHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Id1 x1) ==
            prim Id2 (hom x1)
    record IdempotentUnaryRelInterp
      (A1 : Set) (A2 : Set)
      (Id1 : IdempotentUnary A1)
      (Id2 : IdempotentUnary A2) :
      Set where
      constructor IdempotentUnaryRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Id1 x1)
            (prim Id2 y1)
    data IdempotentUnaryTerm
      : Set where
      primL :
        IdempotentUnaryTerm ->
        IdempotentUnaryTerm
    data ClIdempotentUnaryTerm
      (A : Set) : Set where
      sing :
        A -> ClIdempotentUnaryTerm A
      primCl :
        ClIdempotentUnaryTerm A ->
        ClIdempotentUnaryTerm A
    data OpIdempotentUnaryTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpIdempotentUnaryTerm n
      primOL :
        OpIdempotentUnaryTerm n ->
        OpIdempotentUnaryTerm n
    data OpIdempotentUnaryTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpIdempotentUnaryTerm2 n A
      sing2 :
        A -> OpIdempotentUnaryTerm2 n A
      primOL2 :
        OpIdempotentUnaryTerm2 n A ->
        OpIdempotentUnaryTerm2 n A
    simplifyB :
      IdempotentUnaryTerm ->
      IdempotentUnaryTerm
    simplifyB (primL (primL x)) =
      primL x
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClIdempotentUnaryTerm A ->
      ClIdempotentUnaryTerm A
    simplifyCl _ (primCl
                  (primCl x)) = primCl x
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpIdempotentUnaryTerm n ->
      OpIdempotentUnaryTerm n
    simplifyOp _ (primOL
                  (primOL x)) = primOL x
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpIdempotentUnaryTerm2 n A ->
      OpIdempotentUnaryTerm2 n A
    simplifyOpE _ _ (primOL2
                     (primOL2 x)) = primOL2 x
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      IdempotentUnary A ->
      IdempotentUnaryTerm -> A
    evalB _ Id (primL x1) =
      prim Id (evalB _ Id x1)
    evalCl :
      (A : Set) ->
      IdempotentUnary A ->
      ClIdempotentUnaryTerm A -> A
    evalCl _ Id (sing x1) = x1
    evalCl _ Id (primCl x1) =
      prim Id (evalCl _ Id x1)
    evalOp :
      (A : Set) (n : Nat) ->
      IdempotentUnary A ->
      Vec A n ->
      OpIdempotentUnaryTerm n -> A
    evalOp _ n Id vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Id vars (primOL x1) =
      prim Id (evalOp _ n Id vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      IdempotentUnary A ->
      Vec A n ->
      OpIdempotentUnaryTerm2 n A -> A
    evalOpE _ n Id vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Id vars (sing2 x1) =
      x1
    evalOpE _ n Id vars (primOL2
                         x1) =
      prim Id (evalOpE _ n Id vars x1)
    inductionB :
      (P : IdempotentUnaryTerm ->
           Set) ->
      ((x1 : IdempotentUnaryTerm) ->
       P x1 -> P (primL x1)) ->
      (x : IdempotentUnaryTerm) -> P x
    inductionB p ppriml (primL x1) =
      ppriml _
        (inductionB p ppriml x1)
    inductionCl :
      (A : Set)
      (P : ClIdempotentUnaryTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClIdempotentUnaryTerm
          A) -> P x1 -> P (primCl x1)) ->
      (x : ClIdempotentUnaryTerm A) ->
      P x
    inductionCl _ p psing pprimcl (sing
                                   x1) = psing x1
    inductionCl _ p psing pprimcl (primCl
                                   x1) =
      pprimcl _
        (inductionCl _ p psing pprimcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpIdempotentUnaryTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpIdempotentUnaryTerm
          n) -> P x1 -> P (primOL x1)) ->
      (x : OpIdempotentUnaryTerm n) ->
      P x
    inductionOp _ p pv pprimol (v
                                x1) = pv x1
    inductionOp _ p pv pprimol (primOL
                                x1) =
      pprimol _
        (inductionOp _ p pv pprimol x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpIdempotentUnaryTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpIdempotentUnaryTerm2 n
          A) -> P x1 -> P (primOL2 x1)) ->
      (x : OpIdempotentUnaryTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 pprimol2 (v2
                                            x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 (sing2
                                            x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 (primOL2
                                            x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           x1)
    primL' :
      IdempotentUnaryTerm ->
      IdempotentUnaryTerm
    primL' x1 = primL x1
    stageB :
      IdempotentUnaryTerm ->
      Staged IdempotentUnaryTerm
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    primCl' :
      (A : Set) ->
      ClIdempotentUnaryTerm A ->
      ClIdempotentUnaryTerm A
    primCl' _ x1 = primCl x1
    stageCl :
      (A : Set) ->
      ClIdempotentUnaryTerm A ->
      Staged (ClIdempotentUnaryTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    primOL' :
      (n : Nat) ->
      OpIdempotentUnaryTerm n ->
      OpIdempotentUnaryTerm n
    primOL' _ x1 = primOL x1
    stageOp :
      (n : Nat) ->
      OpIdempotentUnaryTerm n ->
      Staged (OpIdempotentUnaryTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    primOL2' :
      (n : Nat) (A : Set) ->
      OpIdempotentUnaryTerm2 n A ->
      OpIdempotentUnaryTerm2 n A
    primOL2' _ _ x1 = primOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpIdempotentUnaryTerm2 n A ->
      Staged
        (OpIdempotentUnaryTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    record IdempotentUnaryTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        primT : Repr A -> Repr A
  
  module Inverse where
    record Inverse
      (A : Set) : Set where
      constructor InverseC
      field
        inv : A -> A
        e : A
        op : A -> A -> A
        leftInverse_inv_op_e :
          (x : A) -> op x (inv x) == e
        rightInverse_inv_op_e :
          (x : A) -> op (inv x) x == e
    record InverseSig
      (AS : Set) : Set where
      constructor InverseSigSigC
      field
        invS : AS -> AS
        eS : AS
        opS : AS -> AS -> AS
    record InverseProd
      (AP : Set) : Set where
      constructor InverseProdC
      field
        invP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP xP (invP xP) == eP
        rightInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (invP xP) xP == eP
    record InverseHom
      (A1 : Set) (A2 : Set)
      (In1 : Inverse A1)
      (In2 : Inverse A2) : Set where
      constructor InverseHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv In1 x1) ==
            inv In2 (hom x1)
        pres-e : hom (e In1) == e In2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
    record InverseRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : Inverse A1)
      (In2 : Inverse A2) : Set where
      constructor InverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv In1 x1) (inv In2 y1)
        interp-e :
          interp (e In1) (e In2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
    data InverseLTerm : Set where
      invL :
        InverseLTerm -> InverseLTerm
      eL : InverseLTerm
      opL :
        InverseLTerm ->
        InverseLTerm -> InverseLTerm
    data ClInverseClTerm
      (A : Set) : Set where
      sing : A -> ClInverseClTerm A
      invCl :
        ClInverseClTerm A ->
        ClInverseClTerm A
      eCl : ClInverseClTerm A
      opCl :
        ClInverseClTerm A ->
        ClInverseClTerm A ->
        ClInverseClTerm A
    data OpInverseOLTerm
      (n : Nat) : Set where
      v : Fin n -> OpInverseOLTerm n
      invOL :
        OpInverseOLTerm n ->
        OpInverseOLTerm n
      eOL : OpInverseOLTerm n
      opOL :
        OpInverseOLTerm n ->
        OpInverseOLTerm n ->
        OpInverseOLTerm n
    data OpInverseOL2Term2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpInverseOL2Term2 n A
      sing2 :
        A -> OpInverseOL2Term2 n A
      invOL2 :
        OpInverseOL2Term2 n A ->
        OpInverseOL2Term2 n A
      eOL2 : OpInverseOL2Term2 n A
      opOL2 :
        OpInverseOL2Term2 n A ->
        OpInverseOL2Term2 n A ->
        OpInverseOL2Term2 n A
    simplifyB :
      InverseLTerm -> InverseLTerm
    simplifyB (opL x (invL x)) = eL
    simplifyB (opL (invL x) x) = eL
    simplifyB (invL x1) =
      invL (simplifyB x1)
    simplifyB (eL) = eL
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClInverseClTerm A ->
      ClInverseClTerm A
    simplifyCl _ (opCl
                  x
                  (invCl x)) = eCl
    simplifyCl _ (opCl
                  (invCl x)
                  x) = eCl
    simplifyCl _ (invCl x1) =
      invCl (simplifyCl _ x1)
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpInverseOLTerm n ->
      OpInverseOLTerm n
    simplifyOp _ (opOL
                  x
                  (invOL x)) = eOL
    simplifyOp _ (opOL
                  (invOL x)
                  x) = eOL
    simplifyOp _ (invOL x1) =
      invOL (simplifyOp _ x1)
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpInverseOL2Term2 n A ->
      OpInverseOL2Term2 n A
    simplifyOpE _ _ (opOL2
                     x
                     (invOL2 x)) = eOL2
    simplifyOpE _ _ (opOL2
                     (invOL2 x)
                     x) = eOL2
    simplifyOpE _ _ (invOL2 x1) =
      invOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Inverse A -> InverseLTerm -> A
    evalB _ In (invL x1) =
      inv In (evalB _ In x1)
    evalB _ In (eL) = e In
    evalB _ In (opL x1 x2) =
      op In (evalB _ In x1)
        (evalB _ In x2)
    evalCl :
      (A : Set) ->
      Inverse A ->
      ClInverseClTerm A -> A
    evalCl _ In (sing x1) = x1
    evalCl _ In (invCl x1) =
      inv In (evalCl _ In x1)
    evalCl _ In (eCl) = e In
    evalCl _ In (opCl x1 x2) =
      op In (evalCl _ In x1)
        (evalCl _ In x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Inverse A ->
      Vec A n ->
      OpInverseOLTerm n -> A
    evalOp _ n In vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n In vars (invOL x1) =
      inv In (evalOp _ n In vars x1)
    evalOp _ n In vars (eOL) = e In
    evalOp _ n In vars (opOL
                        x1
                        x2) =
      op In (evalOp _ n In vars x1)
        (evalOp _ n In vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Inverse A ->
      Vec A n ->
      OpInverseOL2Term2 n A -> A
    evalOpE _ n In vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n In vars (sing2 x1) =
      x1
    evalOpE _ n In vars (invOL2
                         x1) =
      inv In (evalOpE _ n In vars x1)
    evalOpE _ n In vars (eOL2) =
      e In
    evalOpE _ n In vars (opOL2
                         x1
                         x2) =
      op In (evalOpE _ n In vars x1)
        (evalOpE _ n In vars x2)
    inductionB :
      (P : InverseLTerm -> Set) ->
      ((x1 : InverseLTerm) ->
       P x1 -> P (invL x1)) ->
      P eL ->
      ((x1 : InverseLTerm)
       (x2 : InverseLTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : InverseLTerm) -> P x
    inductionB p pinvl pel popl (invL
                                 x1) =
      pinvl _
        (inductionB p pinvl pel popl x1)
    inductionB p pinvl pel popl (eL) =
      pel
    inductionB p pinvl pel popl (opL
                                 x1
                                 x2) =
      popl _ _
        (inductionB p pinvl pel popl x1)
        (inductionB p pinvl pel popl x2)
    inductionCl :
      (A : Set)
      (P : ClInverseClTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClInverseClTerm A) ->
       P x1 -> P (invCl x1)) ->
      P eCl ->
      ((x1 : ClInverseClTerm A)
       (x2 : ClInverseClTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClInverseClTerm A) -> P x
    inductionCl _ p psing pinvcl pecl popcl (sing
                                             x1) = psing x1
    inductionCl _ p psing pinvcl pecl popcl (invCl
                                             x1) =
      pinvcl _
        (inductionCl _ p psing pinvcl
           pecl
           popcl
           x1)
    inductionCl _ p psing pinvcl pecl popcl (eCl) =
      pecl
    inductionCl _ p psing pinvcl pecl popcl (opCl
                                             x1
                                             x2) =
      popcl _ _
        (inductionCl _ p psing pinvcl
           pecl
           popcl
           x1)
        (inductionCl _ p psing pinvcl
           pecl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpInverseOLTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpInverseOLTerm n) ->
       P x1 -> P (invOL x1)) ->
      P eOL ->
      ((x1 : OpInverseOLTerm n)
       (x2 : OpInverseOLTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpInverseOLTerm n) -> P x
    inductionOp _ p pv pinvol peol popol (v
                                          x1) = pv x1
    inductionOp _ p pv pinvol peol popol (invOL
                                          x1) =
      pinvol _
        (inductionOp _ p pv pinvol peol
           popol
           x1)
    inductionOp _ p pv pinvol peol popol (eOL) =
      peol
    inductionOp _ p pv pinvol peol popol (opOL
                                          x1
                                          x2) =
      popol _ _
        (inductionOp _ p pv pinvol peol
           popol
           x1)
        (inductionOp _ p pv pinvol peol
           popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpInverseOL2Term2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpInverseOL2Term2 n A) ->
       P x1 -> P (invOL2 x1)) ->
      P eOL2 ->
      ((x1 : OpInverseOL2Term2 n A)
       (x2 : OpInverseOL2Term2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpInverseOL2Term2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 pinvol2 peol2 popol2 (v2
                                                        x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pinvol2 peol2 popol2 (sing2
                                                        x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pinvol2 peol2 popol2 (invOL2
                                                        x1) =
      pinvol2 _
        (inductionOpE _ _ p pv2 psing2
           pinvol2
           peol2
           popol2
           x1)
    inductionOpE _ _ p pv2 psing2 pinvol2 peol2 popol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 pinvol2 peol2 popol2 (opOL2
                                                        x1
                                                        x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           pinvol2
           peol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           pinvol2
           peol2
           popol2
           x2)
    invL' :
      InverseLTerm -> InverseLTerm
    invL' x1 = invL x1
    eL' : InverseLTerm
    eL' = eL
    opL' :
      InverseLTerm ->
      InverseLTerm -> InverseLTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      InverseLTerm ->
      Staged InverseLTerm
    stageB (invL x1) =
      stage1 _ _ invL'
        (codeLift1 _ _ invL')
        (stageB x1)
    stageB (eL) = Now eL
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    invCl' :
      (A : Set) ->
      ClInverseClTerm A ->
      ClInverseClTerm A
    invCl' _ x1 = invCl x1
    eCl' :
      (A : Set) -> ClInverseClTerm A
    eCl' _ = eCl
    opCl' :
      (A : Set) ->
      ClInverseClTerm A ->
      ClInverseClTerm A ->
      ClInverseClTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClInverseClTerm A ->
      Staged (ClInverseClTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (invCl x1) =
      stage1 _ _ (invCl' _)
        (codeLift1 _ _ (invCl' _))
        (stageCl _ x1)
    stageCl _ (eCl) = Now eCl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    invOL' :
      (n : Nat) ->
      OpInverseOLTerm n ->
      OpInverseOLTerm n
    invOL' _ x1 = invOL x1
    eOL' :
      (n : Nat) -> OpInverseOLTerm n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      OpInverseOLTerm n ->
      OpInverseOLTerm n ->
      OpInverseOLTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpInverseOLTerm n ->
      Staged (OpInverseOLTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (invOL x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (stageOp _ x1)
    stageOp _ (eOL) = Now eOL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    invOL2' :
      (n : Nat) (A : Set) ->
      OpInverseOL2Term2 n A ->
      OpInverseOL2Term2 n A
    invOL2' _ _ x1 = invOL2 x1
    eOL2' :
      (n : Nat) (A : Set) ->
      OpInverseOL2Term2 n A
    eOL2' _ _ = eOL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpInverseOL2Term2 n A ->
      OpInverseOL2Term2 n A ->
      OpInverseOL2Term2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpInverseOL2Term2 n A ->
      Staged (OpInverseOL2Term2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (invOL2 x1) =
      stage1 _ _ (invOL2' _ _)
        (codeLift1 _ _ (invOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record InverseTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        invT : Repr A -> Repr A
        eT : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module InverseSig where
    record InverseSig
      (A : Set) : Set where
      constructor InverseSigC
      field
        inv : A -> A
        e : A
        op : A -> A -> A
    record InverseSigSig
      (AS : Set) : Set where
      constructor InverseSigSigSigC
      field
        invS : AS -> AS
        eS : AS
        opS : AS -> AS -> AS
    record InverseSigProd
      (AP : Set) : Set where
      constructor InverseSigProdC
      field
        invP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record InverseSigHom
      (A1 : Set) (A2 : Set)
      (In1 : InverseSig A1)
      (In2 : InverseSig A2) :
      Set where
      constructor InverseSigHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv In1 x1) ==
            inv In2 (hom x1)
        pres-e : hom (e In1) == e In2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
    record InverseSigRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InverseSig A1)
      (In2 : InverseSig A2) :
      Set where
      constructor InverseSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv In1 x1) (inv In2 y1)
        interp-e :
          interp (e In1) (e In2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
    data InverseSigTerm : Set where
      invL :
        InverseSigTerm -> InverseSigTerm
      eL : InverseSigTerm
      opL :
        InverseSigTerm ->
        InverseSigTerm -> InverseSigTerm
    data ClInverseSigTerm
      (A : Set) : Set where
      sing : A -> ClInverseSigTerm A
      invCl :
        ClInverseSigTerm A ->
        ClInverseSigTerm A
      eCl : ClInverseSigTerm A
      opCl :
        ClInverseSigTerm A ->
        ClInverseSigTerm A ->
        ClInverseSigTerm A
    data OpInverseSigTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpInverseSigTerm n
      invOL :
        OpInverseSigTerm n ->
        OpInverseSigTerm n
      eOL : OpInverseSigTerm n
      opOL :
        OpInverseSigTerm n ->
        OpInverseSigTerm n ->
        OpInverseSigTerm n
    data OpInverseSigTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpInverseSigTerm2 n A
      sing2 :
        A -> OpInverseSigTerm2 n A
      invOL2 :
        OpInverseSigTerm2 n A ->
        OpInverseSigTerm2 n A
      eOL2 : OpInverseSigTerm2 n A
      opOL2 :
        OpInverseSigTerm2 n A ->
        OpInverseSigTerm2 n A ->
        OpInverseSigTerm2 n A
    simplifyB :
      InverseSigTerm -> InverseSigTerm
    simplifyB (invL x1) =
      invL (simplifyB x1)
    simplifyB (eL) = eL
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClInverseSigTerm A ->
      ClInverseSigTerm A
    simplifyCl _ (invCl x1) =
      invCl (simplifyCl _ x1)
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpInverseSigTerm n ->
      OpInverseSigTerm n
    simplifyOp _ (invOL x1) =
      invOL (simplifyOp _ x1)
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpInverseSigTerm2 n A ->
      OpInverseSigTerm2 n A
    simplifyOpE _ _ (invOL2 x1) =
      invOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      InverseSig A ->
      InverseSigTerm -> A
    evalB _ In (invL x1) =
      inv In (evalB _ In x1)
    evalB _ In (eL) = e In
    evalB _ In (opL x1 x2) =
      op In (evalB _ In x1)
        (evalB _ In x2)
    evalCl :
      (A : Set) ->
      InverseSig A ->
      ClInverseSigTerm A -> A
    evalCl _ In (sing x1) = x1
    evalCl _ In (invCl x1) =
      inv In (evalCl _ In x1)
    evalCl _ In (eCl) = e In
    evalCl _ In (opCl x1 x2) =
      op In (evalCl _ In x1)
        (evalCl _ In x2)
    evalOp :
      (A : Set) (n : Nat) ->
      InverseSig A ->
      Vec A n ->
      OpInverseSigTerm n -> A
    evalOp _ n In vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n In vars (invOL x1) =
      inv In (evalOp _ n In vars x1)
    evalOp _ n In vars (eOL) = e In
    evalOp _ n In vars (opOL
                        x1
                        x2) =
      op In (evalOp _ n In vars x1)
        (evalOp _ n In vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      InverseSig A ->
      Vec A n ->
      OpInverseSigTerm2 n A -> A
    evalOpE _ n In vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n In vars (sing2 x1) =
      x1
    evalOpE _ n In vars (invOL2
                         x1) =
      inv In (evalOpE _ n In vars x1)
    evalOpE _ n In vars (eOL2) =
      e In
    evalOpE _ n In vars (opOL2
                         x1
                         x2) =
      op In (evalOpE _ n In vars x1)
        (evalOpE _ n In vars x2)
    inductionB :
      (P : InverseSigTerm -> Set) ->
      ((x1 : InverseSigTerm) ->
       P x1 -> P (invL x1)) ->
      P eL ->
      ((x1 : InverseSigTerm)
       (x2 : InverseSigTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : InverseSigTerm) -> P x
    inductionB p pinvl pel popl (invL
                                 x1) =
      pinvl _
        (inductionB p pinvl pel popl x1)
    inductionB p pinvl pel popl (eL) =
      pel
    inductionB p pinvl pel popl (opL
                                 x1
                                 x2) =
      popl _ _
        (inductionB p pinvl pel popl x1)
        (inductionB p pinvl pel popl x2)
    inductionCl :
      (A : Set)
      (P : ClInverseSigTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClInverseSigTerm A) ->
       P x1 -> P (invCl x1)) ->
      P eCl ->
      ((x1 : ClInverseSigTerm A)
       (x2 : ClInverseSigTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClInverseSigTerm A) -> P x
    inductionCl _ p psing pinvcl pecl popcl (sing
                                             x1) = psing x1
    inductionCl _ p psing pinvcl pecl popcl (invCl
                                             x1) =
      pinvcl _
        (inductionCl _ p psing pinvcl
           pecl
           popcl
           x1)
    inductionCl _ p psing pinvcl pecl popcl (eCl) =
      pecl
    inductionCl _ p psing pinvcl pecl popcl (opCl
                                             x1
                                             x2) =
      popcl _ _
        (inductionCl _ p psing pinvcl
           pecl
           popcl
           x1)
        (inductionCl _ p psing pinvcl
           pecl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpInverseSigTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpInverseSigTerm n) ->
       P x1 -> P (invOL x1)) ->
      P eOL ->
      ((x1 : OpInverseSigTerm n)
       (x2 : OpInverseSigTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpInverseSigTerm n) -> P x
    inductionOp _ p pv pinvol peol popol (v
                                          x1) = pv x1
    inductionOp _ p pv pinvol peol popol (invOL
                                          x1) =
      pinvol _
        (inductionOp _ p pv pinvol peol
           popol
           x1)
    inductionOp _ p pv pinvol peol popol (eOL) =
      peol
    inductionOp _ p pv pinvol peol popol (opOL
                                          x1
                                          x2) =
      popol _ _
        (inductionOp _ p pv pinvol peol
           popol
           x1)
        (inductionOp _ p pv pinvol peol
           popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpInverseSigTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpInverseSigTerm2 n A) ->
       P x1 -> P (invOL2 x1)) ->
      P eOL2 ->
      ((x1 : OpInverseSigTerm2 n A)
       (x2 : OpInverseSigTerm2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpInverseSigTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 pinvol2 peol2 popol2 (v2
                                                        x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pinvol2 peol2 popol2 (sing2
                                                        x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pinvol2 peol2 popol2 (invOL2
                                                        x1) =
      pinvol2 _
        (inductionOpE _ _ p pv2 psing2
           pinvol2
           peol2
           popol2
           x1)
    inductionOpE _ _ p pv2 psing2 pinvol2 peol2 popol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 pinvol2 peol2 popol2 (opOL2
                                                        x1
                                                        x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           pinvol2
           peol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           pinvol2
           peol2
           popol2
           x2)
    invL' :
      InverseSigTerm -> InverseSigTerm
    invL' x1 = invL x1
    eL' : InverseSigTerm
    eL' = eL
    opL' :
      InverseSigTerm ->
      InverseSigTerm -> InverseSigTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      InverseSigTerm ->
      Staged InverseSigTerm
    stageB (invL x1) =
      stage1 _ _ invL'
        (codeLift1 _ _ invL')
        (stageB x1)
    stageB (eL) = Now eL
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    invCl' :
      (A : Set) ->
      ClInverseSigTerm A ->
      ClInverseSigTerm A
    invCl' _ x1 = invCl x1
    eCl' :
      (A : Set) -> ClInverseSigTerm A
    eCl' _ = eCl
    opCl' :
      (A : Set) ->
      ClInverseSigTerm A ->
      ClInverseSigTerm A ->
      ClInverseSigTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClInverseSigTerm A ->
      Staged (ClInverseSigTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (invCl x1) =
      stage1 _ _ (invCl' _)
        (codeLift1 _ _ (invCl' _))
        (stageCl _ x1)
    stageCl _ (eCl) = Now eCl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    invOL' :
      (n : Nat) ->
      OpInverseSigTerm n ->
      OpInverseSigTerm n
    invOL' _ x1 = invOL x1
    eOL' :
      (n : Nat) -> OpInverseSigTerm n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      OpInverseSigTerm n ->
      OpInverseSigTerm n ->
      OpInverseSigTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpInverseSigTerm n ->
      Staged (OpInverseSigTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (invOL x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (stageOp _ x1)
    stageOp _ (eOL) = Now eOL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    invOL2' :
      (n : Nat) (A : Set) ->
      OpInverseSigTerm2 n A ->
      OpInverseSigTerm2 n A
    invOL2' _ _ x1 = invOL2 x1
    eOL2' :
      (n : Nat) (A : Set) ->
      OpInverseSigTerm2 n A
    eOL2' _ _ = eOL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpInverseSigTerm2 n A ->
      OpInverseSigTerm2 n A ->
      OpInverseSigTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpInverseSigTerm2 n A ->
      Staged (OpInverseSigTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (invOL2 x1) =
      stage1 _ _ (invOL2' _ _)
        (codeLift1 _ _ (invOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record InverseSigTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        invT : Repr A -> Repr A
        eT : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module InverseUnaryOperation where
    record InverseUnaryOperation
      (A : Set) : Set where
      constructor InverseUnaryOperationC
      field
        inv : A -> A
    record InverseUnaryOperationSig
      (AS : Set) : Set where
      constructor InverseUnaryOperationSigSigC
      field
        invS : AS -> AS
    record InverseUnaryOperationProd
      (AP : Set) : Set where
      constructor InverseUnaryOperationProdC
      field
        invP : Prod AP AP -> Prod AP AP
    record InverseUnaryOperationHom
      (A1 : Set) (A2 : Set)
      (In1 : InverseUnaryOperation A1)
      (In2 : InverseUnaryOperation
         A2) : Set where
      constructor InverseUnaryOperationHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv In1 x1) ==
            inv In2 (hom x1)
    record InverseUnaryOperationRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InverseUnaryOperation A1)
      (In2 : InverseUnaryOperation
         A2) : Set where
      constructor InverseUnaryOperationRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv In1 x1) (inv In2 y1)
    data InverseUnaryOperationTerm
      : Set where
      invL :
        InverseUnaryOperationTerm ->
        InverseUnaryOperationTerm
    data ClInverseUnaryOperationTerm
      (A : Set) : Set where
      sing :
        A ->
        ClInverseUnaryOperationTerm A
      invCl :
        ClInverseUnaryOperationTerm A ->
        ClInverseUnaryOperationTerm A
    data OpInverseUnaryOperationTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpInverseUnaryOperationTerm n
      invOL :
        OpInverseUnaryOperationTerm n ->
        OpInverseUnaryOperationTerm n
    data OpInverseUnaryOperationTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpInverseUnaryOperationTerm2 n A
      sing2 :
        A ->
        OpInverseUnaryOperationTerm2 n A
      invOL2 :
        OpInverseUnaryOperationTerm2 n
          A ->
        OpInverseUnaryOperationTerm2 n A
    simplifyB :
      InverseUnaryOperationTerm ->
      InverseUnaryOperationTerm
    simplifyB (invL x1) =
      invL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClInverseUnaryOperationTerm A ->
      ClInverseUnaryOperationTerm A
    simplifyCl _ (invCl x1) =
      invCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpInverseUnaryOperationTerm n ->
      OpInverseUnaryOperationTerm n
    simplifyOp _ (invOL x1) =
      invOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpInverseUnaryOperationTerm2 n
        A ->
      OpInverseUnaryOperationTerm2 n A
    simplifyOpE _ _ (invOL2 x1) =
      invOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      InverseUnaryOperation A ->
      InverseUnaryOperationTerm -> A
    evalB _ In (invL x1) =
      inv In (evalB _ In x1)
    evalCl :
      (A : Set) ->
      InverseUnaryOperation A ->
      ClInverseUnaryOperationTerm A ->
      A
    evalCl _ In (sing x1) = x1
    evalCl _ In (invCl x1) =
      inv In (evalCl _ In x1)
    evalOp :
      (A : Set) (n : Nat) ->
      InverseUnaryOperation A ->
      Vec A n ->
      OpInverseUnaryOperationTerm n ->
      A
    evalOp _ n In vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n In vars (invOL x1) =
      inv In (evalOp _ n In vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      InverseUnaryOperation A ->
      Vec A n ->
      OpInverseUnaryOperationTerm2 n
        A -> A
    evalOpE _ n In vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n In vars (sing2 x1) =
      x1
    evalOpE _ n In vars (invOL2
                         x1) =
      inv In (evalOpE _ n In vars x1)
    inductionB :
      (P : InverseUnaryOperationTerm ->
           Set) ->
      ((x1 : InverseUnaryOperationTerm) ->
       P x1 -> P (invL x1)) ->
      (x : InverseUnaryOperationTerm) ->
      P x
    inductionB p pinvl (invL x1) =
      pinvl _ (inductionB p pinvl x1)
    inductionCl :
      (A : Set)
      (P : ClInverseUnaryOperationTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClInverseUnaryOperationTerm
          A) -> P x1 -> P (invCl x1)) ->
      (x : ClInverseUnaryOperationTerm
         A) -> P x
    inductionCl _ p psing pinvcl (sing
                                  x1) = psing x1
    inductionCl _ p psing pinvcl (invCl
                                  x1) =
      pinvcl _
        (inductionCl _ p psing pinvcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpInverseUnaryOperationTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpInverseUnaryOperationTerm
          n) -> P x1 -> P (invOL x1)) ->
      (x : OpInverseUnaryOperationTerm
         n) -> P x
    inductionOp _ p pv pinvol (v
                               x1) = pv x1
    inductionOp _ p pv pinvol (invOL
                               x1) =
      pinvol _
        (inductionOp _ p pv pinvol x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpInverseUnaryOperationTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpInverseUnaryOperationTerm2
          n
          A) -> P x1 -> P (invOL2 x1)) ->
      (x : OpInverseUnaryOperationTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 pinvol2 (v2
                                           x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pinvol2 (sing2
                                           x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pinvol2 (invOL2
                                           x1) =
      pinvol2 _
        (inductionOpE _ _ p pv2 psing2
           pinvol2
           x1)
    invL' :
      InverseUnaryOperationTerm ->
      InverseUnaryOperationTerm
    invL' x1 = invL x1
    stageB :
      InverseUnaryOperationTerm ->
      Staged InverseUnaryOperationTerm
    stageB (invL x1) =
      stage1 _ _ invL'
        (codeLift1 _ _ invL')
        (stageB x1)
    invCl' :
      (A : Set) ->
      ClInverseUnaryOperationTerm A ->
      ClInverseUnaryOperationTerm A
    invCl' _ x1 = invCl x1
    stageCl :
      (A : Set) ->
      ClInverseUnaryOperationTerm A ->
      Staged
        (ClInverseUnaryOperationTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (invCl x1) =
      stage1 _ _ (invCl' _)
        (codeLift1 _ _ (invCl' _))
        (stageCl _ x1)
    invOL' :
      (n : Nat) ->
      OpInverseUnaryOperationTerm n ->
      OpInverseUnaryOperationTerm n
    invOL' _ x1 = invOL x1
    stageOp :
      (n : Nat) ->
      OpInverseUnaryOperationTerm n ->
      Staged
        (OpInverseUnaryOperationTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (invOL x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (stageOp _ x1)
    invOL2' :
      (n : Nat) (A : Set) ->
      OpInverseUnaryOperationTerm2 n
        A ->
      OpInverseUnaryOperationTerm2 n A
    invOL2' _ _ x1 = invOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpInverseUnaryOperationTerm2 n
        A ->
      Staged
        (OpInverseUnaryOperationTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (invOL2 x1) =
      stage1 _ _ (invOL2' _ _)
        (codeLift1 _ _ (invOL2' _ _))
        (stageOpE _ _ x1)
    record InverseUnaryOperationTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        invT : Repr A -> Repr A
  
  module Involution where
    record Involution
      (A : Set) : Set where
      constructor InvolutionC
      field
        prim : A -> A
        involutive_prim :
          (x : A) -> prim (prim x) == x
    record InvolutionSig
      (AS : Set) : Set where
      constructor InvolutionSigSigC
      field
        primS : AS -> AS
    record InvolutionProd
      (AP : Set) : Set where
      constructor InvolutionProdC
      field
        primP : Prod AP AP -> Prod AP AP
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
    record InvolutionHom
      (A1 : Set) (A2 : Set)
      (In1 : Involution A1)
      (In2 : Involution A2) :
      Set where
      constructor InvolutionHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutionRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : Involution A1)
      (In2 : Involution A2) :
      Set where
      constructor InvolutionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutionTerm : Set where
      primL :
        InvolutionTerm -> InvolutionTerm
    data ClInvolutionTerm
      (A : Set) : Set where
      sing : A -> ClInvolutionTerm A
      primCl :
        ClInvolutionTerm A ->
        ClInvolutionTerm A
    data OpInvolutionTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpInvolutionTerm n
      primOL :
        OpInvolutionTerm n ->
        OpInvolutionTerm n
    data OpInvolutionTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpInvolutionTerm2 n A
      sing2 :
        A -> OpInvolutionTerm2 n A
      primOL2 :
        OpInvolutionTerm2 n A ->
        OpInvolutionTerm2 n A
    simplifyB :
      InvolutionTerm -> InvolutionTerm
    simplifyB (primL (primL x)) = x
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClInvolutionTerm A ->
      ClInvolutionTerm A
    simplifyCl _ (primCl
                  (primCl x)) = x
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpInvolutionTerm n ->
      OpInvolutionTerm n
    simplifyOp _ (primOL
                  (primOL x)) = x
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpInvolutionTerm2 n A ->
      OpInvolutionTerm2 n A
    simplifyOpE _ _ (primOL2
                     (primOL2 x)) = x
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Involution A ->
      InvolutionTerm -> A
    evalB _ In (primL x1) =
      prim In (evalB _ In x1)
    evalCl :
      (A : Set) ->
      Involution A ->
      ClInvolutionTerm A -> A
    evalCl _ In (sing x1) = x1
    evalCl _ In (primCl x1) =
      prim In (evalCl _ In x1)
    evalOp :
      (A : Set) (n : Nat) ->
      Involution A ->
      Vec A n ->
      OpInvolutionTerm n -> A
    evalOp _ n In vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n In vars (primOL x1) =
      prim In (evalOp _ n In vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      Involution A ->
      Vec A n ->
      OpInvolutionTerm2 n A -> A
    evalOpE _ n In vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n In vars (sing2 x1) =
      x1
    evalOpE _ n In vars (primOL2
                         x1) =
      prim In (evalOpE _ n In vars x1)
    inductionB :
      (P : InvolutionTerm -> Set) ->
      ((x1 : InvolutionTerm) ->
       P x1 -> P (primL x1)) ->
      (x : InvolutionTerm) -> P x
    inductionB p ppriml (primL x1) =
      ppriml _
        (inductionB p ppriml x1)
    inductionCl :
      (A : Set)
      (P : ClInvolutionTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClInvolutionTerm A) ->
       P x1 -> P (primCl x1)) ->
      (x : ClInvolutionTerm A) -> P x
    inductionCl _ p psing pprimcl (sing
                                   x1) = psing x1
    inductionCl _ p psing pprimcl (primCl
                                   x1) =
      pprimcl _
        (inductionCl _ p psing pprimcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpInvolutionTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpInvolutionTerm n) ->
       P x1 -> P (primOL x1)) ->
      (x : OpInvolutionTerm n) -> P x
    inductionOp _ p pv pprimol (v
                                x1) = pv x1
    inductionOp _ p pv pprimol (primOL
                                x1) =
      pprimol _
        (inductionOp _ p pv pprimol x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpInvolutionTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpInvolutionTerm2 n A) ->
       P x1 -> P (primOL2 x1)) ->
      (x : OpInvolutionTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 pprimol2 (v2
                                            x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 (sing2
                                            x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 (primOL2
                                            x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           x1)
    primL' :
      InvolutionTerm -> InvolutionTerm
    primL' x1 = primL x1
    stageB :
      InvolutionTerm ->
      Staged InvolutionTerm
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    primCl' :
      (A : Set) ->
      ClInvolutionTerm A ->
      ClInvolutionTerm A
    primCl' _ x1 = primCl x1
    stageCl :
      (A : Set) ->
      ClInvolutionTerm A ->
      Staged (ClInvolutionTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    primOL' :
      (n : Nat) ->
      OpInvolutionTerm n ->
      OpInvolutionTerm n
    primOL' _ x1 = primOL x1
    stageOp :
      (n : Nat) ->
      OpInvolutionTerm n ->
      Staged (OpInvolutionTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    primOL2' :
      (n : Nat) (A : Set) ->
      OpInvolutionTerm2 n A ->
      OpInvolutionTerm2 n A
    primOL2' _ _ x1 = primOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpInvolutionTerm2 n A ->
      Staged (OpInvolutionTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    record InvolutionTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        primT : Repr A -> Repr A
  
  module InvolutiveAddMagmaSig where
    record InvolutiveAddMagmaSig
      (A : Set) : Set where
      constructor InvolutiveAddMagmaSigC
      field
        + : A -> A -> A
        prim : A -> A
    record InvolutiveAddMagmaSigSig
      (AS : Set) : Set where
      constructor InvolutiveAddMagmaSigSigSigC
      field
        +S : AS -> AS -> AS
        primS : AS -> AS
    record InvolutiveAddMagmaSigProd
      (AP : Set) : Set where
      constructor InvolutiveAddMagmaSigProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
    record InvolutiveAddMagmaSigHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveAddMagmaSig A1)
      (In2 : InvolutiveAddMagmaSig
         A2) : Set where
      constructor InvolutiveAddMagmaSigHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ In1 x1 x2) ==
            + In2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutiveAddMagmaSigRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveAddMagmaSig A1)
      (In2 : InvolutiveAddMagmaSig
         A2) : Set where
      constructor InvolutiveAddMagmaSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ In1 x1 x2)
            (+ In2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutiveAddMagmaSigTerm
      : Set where
      +L :
        InvolutiveAddMagmaSigTerm ->
        InvolutiveAddMagmaSigTerm ->
        InvolutiveAddMagmaSigTerm
      primL :
        InvolutiveAddMagmaSigTerm ->
        InvolutiveAddMagmaSigTerm
    data ClInvolutiveAddMagmaSigTerm
      (A : Set) : Set where
      sing :
        A ->
        ClInvolutiveAddMagmaSigTerm A
      +Cl :
        ClInvolutiveAddMagmaSigTerm A ->
        ClInvolutiveAddMagmaSigTerm A ->
        ClInvolutiveAddMagmaSigTerm A
      primCl :
        ClInvolutiveAddMagmaSigTerm A ->
        ClInvolutiveAddMagmaSigTerm A
    data OpInvolutiveAddMagmaSigTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpInvolutiveAddMagmaSigTerm n
      +OL :
        OpInvolutiveAddMagmaSigTerm n ->
        OpInvolutiveAddMagmaSigTerm n ->
        OpInvolutiveAddMagmaSigTerm n
      primOL :
        OpInvolutiveAddMagmaSigTerm n ->
        OpInvolutiveAddMagmaSigTerm n
    data OpInvolutiveAddMagmaSigTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpInvolutiveAddMagmaSigTerm2 n A
      sing2 :
        A ->
        OpInvolutiveAddMagmaSigTerm2 n A
      +OL2 :
        OpInvolutiveAddMagmaSigTerm2 n
          A ->
        OpInvolutiveAddMagmaSigTerm2 n
          A ->
        OpInvolutiveAddMagmaSigTerm2 n A
      primOL2 :
        OpInvolutiveAddMagmaSigTerm2 n
          A ->
        OpInvolutiveAddMagmaSigTerm2 n A
    simplifyB :
      InvolutiveAddMagmaSigTerm ->
      InvolutiveAddMagmaSigTerm
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClInvolutiveAddMagmaSigTerm A ->
      ClInvolutiveAddMagmaSigTerm A
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpInvolutiveAddMagmaSigTerm n ->
      OpInvolutiveAddMagmaSigTerm n
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpInvolutiveAddMagmaSigTerm2 n
        A ->
      OpInvolutiveAddMagmaSigTerm2 n A
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      InvolutiveAddMagmaSig A ->
      InvolutiveAddMagmaSigTerm -> A
    evalB _ In (+L x1 x2) =
      + In (evalB _ In x1)
        (evalB _ In x2)
    evalB _ In (primL x1) =
      prim In (evalB _ In x1)
    evalCl :
      (A : Set) ->
      InvolutiveAddMagmaSig A ->
      ClInvolutiveAddMagmaSigTerm A ->
      A
    evalCl _ In (sing x1) = x1
    evalCl _ In (+Cl x1 x2) =
      + In (evalCl _ In x1)
        (evalCl _ In x2)
    evalCl _ In (primCl x1) =
      prim In (evalCl _ In x1)
    evalOp :
      (A : Set) (n : Nat) ->
      InvolutiveAddMagmaSig A ->
      Vec A n ->
      OpInvolutiveAddMagmaSigTerm n ->
      A
    evalOp _ n In vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n In vars (+OL x1 x2) =
      + In (evalOp _ n In vars x1)
        (evalOp _ n In vars x2)
    evalOp _ n In vars (primOL x1) =
      prim In (evalOp _ n In vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      InvolutiveAddMagmaSig A ->
      Vec A n ->
      OpInvolutiveAddMagmaSigTerm2 n
        A -> A
    evalOpE _ n In vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n In vars (sing2 x1) =
      x1
    evalOpE _ n In vars (+OL2
                         x1
                         x2) =
      + In (evalOpE _ n In vars x1)
        (evalOpE _ n In vars x2)
    evalOpE _ n In vars (primOL2
                         x1) =
      prim In (evalOpE _ n In vars x1)
    inductionB :
      (P : InvolutiveAddMagmaSigTerm ->
           Set) ->
      ((x1 : InvolutiveAddMagmaSigTerm)
       (x2 : InvolutiveAddMagmaSigTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      ((x1 : InvolutiveAddMagmaSigTerm) ->
       P x1 -> P (primL x1)) ->
      (x : InvolutiveAddMagmaSigTerm) ->
      P x
    inductionB p p+l ppriml (+L
                             x1
                             x2) =
      p+l _ _
        (inductionB p p+l ppriml x1)
        (inductionB p p+l ppriml x2)
    inductionB p p+l ppriml (primL
                             x1) =
      ppriml _
        (inductionB p p+l ppriml x1)
    inductionCl :
      (A : Set)
      (P : ClInvolutiveAddMagmaSigTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClInvolutiveAddMagmaSigTerm
          A)
       (x2 : ClInvolutiveAddMagmaSigTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      ((x1 : ClInvolutiveAddMagmaSigTerm
          A) -> P x1 -> P (primCl x1)) ->
      (x : ClInvolutiveAddMagmaSigTerm
         A) -> P x
    inductionCl _ p psing p+cl pprimcl (sing
                                        x1) = psing x1
    inductionCl _ p psing p+cl pprimcl (+Cl
                                        x1
                                        x2) =
      p+cl _ _
        (inductionCl _ p psing p+cl
           pprimcl
           x1)
        (inductionCl _ p psing p+cl
           pprimcl
           x2)
    inductionCl _ p psing p+cl pprimcl (primCl
                                        x1) =
      pprimcl _
        (inductionCl _ p psing p+cl
           pprimcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpInvolutiveAddMagmaSigTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpInvolutiveAddMagmaSigTerm
          n)
       (x2 : OpInvolutiveAddMagmaSigTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      ((x1 : OpInvolutiveAddMagmaSigTerm
          n) -> P x1 -> P (primOL x1)) ->
      (x : OpInvolutiveAddMagmaSigTerm
         n) -> P x
    inductionOp _ p pv p+ol pprimol (v
                                     x1) = pv x1
    inductionOp _ p pv p+ol pprimol (+OL
                                     x1
                                     x2) =
      p+ol _ _
        (inductionOp _ p pv p+ol pprimol
           x1)
        (inductionOp _ p pv p+ol pprimol
           x2)
    inductionOp _ p pv p+ol pprimol (primOL
                                     x1) =
      pprimol _
        (inductionOp _ p pv p+ol pprimol
           x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpInvolutiveAddMagmaSigTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpInvolutiveAddMagmaSigTerm2
          n
          A)
       (x2 : OpInvolutiveAddMagmaSigTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      ((x1 : OpInvolutiveAddMagmaSigTerm2
          n
          A) -> P x1 -> P (primOL2 x1)) ->
      (x : OpInvolutiveAddMagmaSigTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p+ol2 pprimol2 (v2
                                                  x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 pprimol2 (sing2
                                                  x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 pprimol2 (+OL2
                                                  x1
                                                  x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           pprimol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           pprimol2
           x2)
    inductionOpE _ _ p pv2 psing2 p+ol2 pprimol2 (primOL2
                                                  x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           pprimol2
           x1)
    +L' :
      InvolutiveAddMagmaSigTerm ->
      InvolutiveAddMagmaSigTerm ->
      InvolutiveAddMagmaSigTerm
    +L' x1 x2 = +L x1 x2
    primL' :
      InvolutiveAddMagmaSigTerm ->
      InvolutiveAddMagmaSigTerm
    primL' x1 = primL x1
    stageB :
      InvolutiveAddMagmaSigTerm ->
      Staged InvolutiveAddMagmaSigTerm
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    +Cl' :
      (A : Set) ->
      ClInvolutiveAddMagmaSigTerm A ->
      ClInvolutiveAddMagmaSigTerm A ->
      ClInvolutiveAddMagmaSigTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    primCl' :
      (A : Set) ->
      ClInvolutiveAddMagmaSigTerm A ->
      ClInvolutiveAddMagmaSigTerm A
    primCl' _ x1 = primCl x1
    stageCl :
      (A : Set) ->
      ClInvolutiveAddMagmaSigTerm A ->
      Staged
        (ClInvolutiveAddMagmaSigTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    +OL' :
      (n : Nat) ->
      OpInvolutiveAddMagmaSigTerm n ->
      OpInvolutiveAddMagmaSigTerm n ->
      OpInvolutiveAddMagmaSigTerm n
    +OL' _ x1 x2 = +OL x1 x2
    primOL' :
      (n : Nat) ->
      OpInvolutiveAddMagmaSigTerm n ->
      OpInvolutiveAddMagmaSigTerm n
    primOL' _ x1 = primOL x1
    stageOp :
      (n : Nat) ->
      OpInvolutiveAddMagmaSigTerm n ->
      Staged
        (OpInvolutiveAddMagmaSigTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    +OL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveAddMagmaSigTerm2 n
        A ->
      OpInvolutiveAddMagmaSigTerm2 n
        A ->
      OpInvolutiveAddMagmaSigTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    primOL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveAddMagmaSigTerm2 n
        A ->
      OpInvolutiveAddMagmaSigTerm2 n A
    primOL2' _ _ x1 = primOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpInvolutiveAddMagmaSigTerm2 n
        A ->
      Staged
        (OpInvolutiveAddMagmaSigTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    record InvolutiveAddMagmaSigTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        +T : Repr A -> Repr A -> Repr A
        primT : Repr A -> Repr A
  
  module InvolutiveFixedPoint where
    record InvolutiveFixedPoint
      (A : Set) : Set where
      constructor InvolutiveFixedPointC
      field
        prim : A -> A
        1 : A
        fixes_prim_1 : prim 1 == 1
        involutive_prim :
          (x : A) -> prim (prim x) == x
    record InvolutiveFixedPointSig
      (AS : Set) : Set where
      constructor InvolutiveFixedPointSigSigC
      field
        primS : AS -> AS
        1S : AS
    record InvolutiveFixedPointProd
      (AP : Set) : Set where
      constructor InvolutiveFixedPointProdC
      field
        primP : Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        fixes_prim_1P : primP 1P == 1P
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
    record InvolutiveFixedPointHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveFixedPoint A1)
      (In2 : InvolutiveFixedPoint
         A2) : Set where
      constructor InvolutiveFixedPointHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-1 : hom (1 In1) == 1 In2
    record InvolutiveFixedPointRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveFixedPoint A1)
      (In2 : InvolutiveFixedPoint
         A2) : Set where
      constructor InvolutiveFixedPointRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-1 :
          interp (1 In1) (1 In2)
    data InvolutiveFixedPointTerm
      : Set where
      primL :
        InvolutiveFixedPointTerm ->
        InvolutiveFixedPointTerm
      1L : InvolutiveFixedPointTerm
    data ClInvolutiveFixedPointTerm
      (A : Set) : Set where
      sing :
        A ->
        ClInvolutiveFixedPointTerm A
      primCl :
        ClInvolutiveFixedPointTerm A ->
        ClInvolutiveFixedPointTerm A
      1Cl :
        ClInvolutiveFixedPointTerm A
    data OpInvolutiveFixedPointTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpInvolutiveFixedPointTerm n
      primOL :
        OpInvolutiveFixedPointTerm n ->
        OpInvolutiveFixedPointTerm n
      1OL :
        OpInvolutiveFixedPointTerm n
    data OpInvolutiveFixedPointTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpInvolutiveFixedPointTerm2 n A
      sing2 :
        A ->
        OpInvolutiveFixedPointTerm2 n A
      primOL2 :
        OpInvolutiveFixedPointTerm2 n
          A ->
        OpInvolutiveFixedPointTerm2 n A
      1OL2 :
        OpInvolutiveFixedPointTerm2 n A
    simplifyB :
      InvolutiveFixedPointTerm ->
      InvolutiveFixedPointTerm
    simplifyB (primL (1L)) = 1L
    simplifyB (primL (primL x)) = x
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyB (1L) = 1L
    simplifyCl :
      (A : Set) ->
      ClInvolutiveFixedPointTerm A ->
      ClInvolutiveFixedPointTerm A
    simplifyCl _ (primCl (1Cl)) =
      1Cl
    simplifyCl _ (primCl
                  (primCl x)) = x
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpInvolutiveFixedPointTerm n ->
      OpInvolutiveFixedPointTerm n
    simplifyOp _ (primOL (1OL)) =
      1OL
    simplifyOp _ (primOL
                  (primOL x)) = x
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpInvolutiveFixedPointTerm2 n
        A ->
      OpInvolutiveFixedPointTerm2 n A
    simplifyOpE _ _ (primOL2
                     (1OL2)) = 1OL2
    simplifyOpE _ _ (primOL2
                     (primOL2 x)) = x
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      InvolutiveFixedPoint A ->
      InvolutiveFixedPointTerm -> A
    evalB _ In (primL x1) =
      prim In (evalB _ In x1)
    evalB _ In (1L) = 1 In
    evalCl :
      (A : Set) ->
      InvolutiveFixedPoint A ->
      ClInvolutiveFixedPointTerm A ->
      A
    evalCl _ In (sing x1) = x1
    evalCl _ In (primCl x1) =
      prim In (evalCl _ In x1)
    evalCl _ In (1Cl) = 1 In
    evalOp :
      (A : Set) (n : Nat) ->
      InvolutiveFixedPoint A ->
      Vec A n ->
      OpInvolutiveFixedPointTerm n ->
      A
    evalOp _ n In vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n In vars (primOL x1) =
      prim In (evalOp _ n In vars x1)
    evalOp _ n In vars (1OL) = 1 In
    evalOpE :
      (A : Set) (n : Nat) ->
      InvolutiveFixedPoint A ->
      Vec A n ->
      OpInvolutiveFixedPointTerm2 n
        A -> A
    evalOpE _ n In vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n In vars (sing2 x1) =
      x1
    evalOpE _ n In vars (primOL2
                         x1) =
      prim In (evalOpE _ n In vars x1)
    evalOpE _ n In vars (1OL2) =
      1 In
    inductionB :
      (P : InvolutiveFixedPointTerm ->
           Set) ->
      ((x1 : InvolutiveFixedPointTerm) ->
       P x1 -> P (primL x1)) ->
      P 1L ->
      (x : InvolutiveFixedPointTerm) ->
      P x
    inductionB p ppriml p1l (primL
                             x1) =
      ppriml _
        (inductionB p ppriml p1l x1)
    inductionB p ppriml p1l (1L) =
      p1l
    inductionCl :
      (A : Set)
      (P : ClInvolutiveFixedPointTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClInvolutiveFixedPointTerm
          A) -> P x1 -> P (primCl x1)) ->
      P 1Cl ->
      (x : ClInvolutiveFixedPointTerm
         A) -> P x
    inductionCl _ p psing pprimcl p1cl (sing
                                        x1) = psing x1
    inductionCl _ p psing pprimcl p1cl (primCl
                                        x1) =
      pprimcl _
        (inductionCl _ p psing pprimcl
           p1cl
           x1)
    inductionCl _ p psing pprimcl p1cl (1Cl) =
      p1cl
    inductionOp :
      (n : Nat)
      (P : OpInvolutiveFixedPointTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpInvolutiveFixedPointTerm
          n) -> P x1 -> P (primOL x1)) ->
      P 1OL ->
      (x : OpInvolutiveFixedPointTerm
         n) -> P x
    inductionOp _ p pv pprimol p1ol (v
                                     x1) = pv x1
    inductionOp _ p pv pprimol p1ol (primOL
                                     x1) =
      pprimol _
        (inductionOp _ p pv pprimol p1ol
           x1)
    inductionOp _ p pv pprimol p1ol (1OL) =
      p1ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpInvolutiveFixedPointTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpInvolutiveFixedPointTerm2
          n
          A) -> P x1 -> P (primOL2 x1)) ->
      P 1OL2 ->
      (x : OpInvolutiveFixedPointTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 pprimol2 p1ol2 (v2
                                                  x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 p1ol2 (sing2
                                                  x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 p1ol2 (primOL2
                                                  x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           p1ol2
           x1)
    inductionOpE _ _ p pv2 psing2 pprimol2 p1ol2 (1OL2) =
      p1ol2
    primL' :
      InvolutiveFixedPointTerm ->
      InvolutiveFixedPointTerm
    primL' x1 = primL x1
    1L' : InvolutiveFixedPointTerm
    1L' = 1L
    stageB :
      InvolutiveFixedPointTerm ->
      Staged InvolutiveFixedPointTerm
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    stageB (1L) = Now 1L
    primCl' :
      (A : Set) ->
      ClInvolutiveFixedPointTerm A ->
      ClInvolutiveFixedPointTerm A
    primCl' _ x1 = primCl x1
    1Cl' :
      (A : Set) ->
      ClInvolutiveFixedPointTerm A
    1Cl' _ = 1Cl
    stageCl :
      (A : Set) ->
      ClInvolutiveFixedPointTerm A ->
      Staged
        (ClInvolutiveFixedPointTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    stageCl _ (1Cl) = Now 1Cl
    primOL' :
      (n : Nat) ->
      OpInvolutiveFixedPointTerm n ->
      OpInvolutiveFixedPointTerm n
    primOL' _ x1 = primOL x1
    1OL' :
      (n : Nat) ->
      OpInvolutiveFixedPointTerm n
    1OL' _ = 1OL
    stageOp :
      (n : Nat) ->
      OpInvolutiveFixedPointTerm n ->
      Staged
        (OpInvolutiveFixedPointTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    stageOp _ (1OL) = Now 1OL
    primOL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveFixedPointTerm2 n
        A ->
      OpInvolutiveFixedPointTerm2 n A
    primOL2' _ _ x1 = primOL2 x1
    1OL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveFixedPointTerm2 n A
    1OL2' _ _ = 1OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpInvolutiveFixedPointTerm2 n
        A ->
      Staged
        (OpInvolutiveFixedPointTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (1OL2) = Now 1OL2
    record InvolutiveFixedPointTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        primT : Repr A -> Repr A
        1T : Repr A
  
  module InvolutiveFixes where
    record InvolutiveFixes
      (A : Set) : Set where
      constructor InvolutiveFixesC
      field
        1 : A
        prim : A -> A
        fixes_prim_1 : prim 1 == 1
    record InvolutiveFixesSig
      (AS : Set) : Set where
      constructor InvolutiveFixesSigSigC
      field
        1S : AS
        primS : AS -> AS
    record InvolutiveFixesProd
      (AP : Set) : Set where
      constructor InvolutiveFixesProdC
      field
        1P : Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        fixes_prim_1P : primP 1P == 1P
    record InvolutiveFixesHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveFixes A1)
      (In2 : InvolutiveFixes A2) :
      Set where
      constructor InvolutiveFixesHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 In1) == 1 In2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutiveFixesRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveFixes A1)
      (In2 : InvolutiveFixes A2) :
      Set where
      constructor InvolutiveFixesRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 In1) (1 In2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutiveFixesTerm
      : Set where
      1L : InvolutiveFixesTerm
      primL :
        InvolutiveFixesTerm ->
        InvolutiveFixesTerm
    data ClInvolutiveFixesTerm
      (A : Set) : Set where
      sing :
        A -> ClInvolutiveFixesTerm A
      1Cl : ClInvolutiveFixesTerm A
      primCl :
        ClInvolutiveFixesTerm A ->
        ClInvolutiveFixesTerm A
    data OpInvolutiveFixesTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpInvolutiveFixesTerm n
      1OL : OpInvolutiveFixesTerm n
      primOL :
        OpInvolutiveFixesTerm n ->
        OpInvolutiveFixesTerm n
    data OpInvolutiveFixesTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpInvolutiveFixesTerm2 n A
      sing2 :
        A -> OpInvolutiveFixesTerm2 n A
      1OL2 :
        OpInvolutiveFixesTerm2 n A
      primOL2 :
        OpInvolutiveFixesTerm2 n A ->
        OpInvolutiveFixesTerm2 n A
    simplifyB :
      InvolutiveFixesTerm ->
      InvolutiveFixesTerm
    simplifyB (primL (1L)) = 1L
    simplifyB (1L) = 1L
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClInvolutiveFixesTerm A ->
      ClInvolutiveFixesTerm A
    simplifyCl _ (primCl (1Cl)) =
      1Cl
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpInvolutiveFixesTerm n ->
      OpInvolutiveFixesTerm n
    simplifyOp _ (primOL (1OL)) =
      1OL
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpInvolutiveFixesTerm2 n A ->
      OpInvolutiveFixesTerm2 n A
    simplifyOpE _ _ (primOL2
                     (1OL2)) = 1OL2
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      InvolutiveFixes A ->
      InvolutiveFixesTerm -> A
    evalB _ In (1L) = 1 In
    evalB _ In (primL x1) =
      prim In (evalB _ In x1)
    evalCl :
      (A : Set) ->
      InvolutiveFixes A ->
      ClInvolutiveFixesTerm A -> A
    evalCl _ In (sing x1) = x1
    evalCl _ In (1Cl) = 1 In
    evalCl _ In (primCl x1) =
      prim In (evalCl _ In x1)
    evalOp :
      (A : Set) (n : Nat) ->
      InvolutiveFixes A ->
      Vec A n ->
      OpInvolutiveFixesTerm n -> A
    evalOp _ n In vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n In vars (1OL) = 1 In
    evalOp _ n In vars (primOL x1) =
      prim In (evalOp _ n In vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      InvolutiveFixes A ->
      Vec A n ->
      OpInvolutiveFixesTerm2 n A -> A
    evalOpE _ n In vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n In vars (sing2 x1) =
      x1
    evalOpE _ n In vars (1OL2) =
      1 In
    evalOpE _ n In vars (primOL2
                         x1) =
      prim In (evalOpE _ n In vars x1)
    inductionB :
      (P : InvolutiveFixesTerm ->
           Set) ->
      P 1L ->
      ((x1 : InvolutiveFixesTerm) ->
       P x1 -> P (primL x1)) ->
      (x : InvolutiveFixesTerm) -> P x
    inductionB p p1l ppriml (1L) =
      p1l
    inductionB p p1l ppriml (primL
                             x1) =
      ppriml _
        (inductionB p p1l ppriml x1)
    inductionCl :
      (A : Set)
      (P : ClInvolutiveFixesTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 1Cl ->
      ((x1 : ClInvolutiveFixesTerm
          A) -> P x1 -> P (primCl x1)) ->
      (x : ClInvolutiveFixesTerm A) ->
      P x
    inductionCl _ p psing p1cl pprimcl (sing
                                        x1) = psing x1
    inductionCl _ p psing p1cl pprimcl (1Cl) =
      p1cl
    inductionCl _ p psing p1cl pprimcl (primCl
                                        x1) =
      pprimcl _
        (inductionCl _ p psing p1cl
           pprimcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpInvolutiveFixesTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 1OL ->
      ((x1 : OpInvolutiveFixesTerm
          n) -> P x1 -> P (primOL x1)) ->
      (x : OpInvolutiveFixesTerm n) ->
      P x
    inductionOp _ p pv p1ol pprimol (v
                                     x1) = pv x1
    inductionOp _ p pv p1ol pprimol (1OL) =
      p1ol
    inductionOp _ p pv p1ol pprimol (primOL
                                     x1) =
      pprimol _
        (inductionOp _ p pv p1ol pprimol
           x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpInvolutiveFixesTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 1OL2 ->
      ((x1 : OpInvolutiveFixesTerm2 n
          A) -> P x1 -> P (primOL2 x1)) ->
      (x : OpInvolutiveFixesTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p1ol2 pprimol2 (v2
                                                  x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p1ol2 pprimol2 (sing2
                                                  x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p1ol2 pprimol2 (1OL2) =
      p1ol2
    inductionOpE _ _ p pv2 psing2 p1ol2 pprimol2 (primOL2
                                                  x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           p1ol2
           pprimol2
           x1)
    1L' : InvolutiveFixesTerm
    1L' = 1L
    primL' :
      InvolutiveFixesTerm ->
      InvolutiveFixesTerm
    primL' x1 = primL x1
    stageB :
      InvolutiveFixesTerm ->
      Staged InvolutiveFixesTerm
    stageB (1L) = Now 1L
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    1Cl' :
      (A : Set) ->
      ClInvolutiveFixesTerm A
    1Cl' _ = 1Cl
    primCl' :
      (A : Set) ->
      ClInvolutiveFixesTerm A ->
      ClInvolutiveFixesTerm A
    primCl' _ x1 = primCl x1
    stageCl :
      (A : Set) ->
      ClInvolutiveFixesTerm A ->
      Staged (ClInvolutiveFixesTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (1Cl) = Now 1Cl
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    1OL' :
      (n : Nat) ->
      OpInvolutiveFixesTerm n
    1OL' _ = 1OL
    primOL' :
      (n : Nat) ->
      OpInvolutiveFixesTerm n ->
      OpInvolutiveFixesTerm n
    primOL' _ x1 = primOL x1
    stageOp :
      (n : Nat) ->
      OpInvolutiveFixesTerm n ->
      Staged (OpInvolutiveFixesTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (1OL) = Now 1OL
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    1OL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveFixesTerm2 n A
    1OL2' _ _ = 1OL2
    primOL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveFixesTerm2 n A ->
      OpInvolutiveFixesTerm2 n A
    primOL2' _ _ x1 = primOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpInvolutiveFixesTerm2 n A ->
      Staged
        (OpInvolutiveFixesTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (1OL2) = Now 1OL2
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    record InvolutiveFixesTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        1T : Repr A
        primT : Repr A -> Repr A
  
  module InvolutiveMagma where
    record InvolutiveMagma
      (A : Set) : Set where
      constructor InvolutiveMagmaC
      field
        prim : A -> A
        involutive_prim :
          (x : A) -> prim (prim x) == x
        op : A -> A -> A
        antidis_prim_op :
          (x : A) (y : A) ->
          prim (op x y) ==
            op (prim y) (prim x)
    record InvolutiveMagmaSig
      (AS : Set) : Set where
      constructor InvolutiveMagmaSigSigC
      field
        primS : AS -> AS
        opS : AS -> AS -> AS
    record InvolutiveMagmaProd
      (AP : Set) : Set where
      constructor InvolutiveMagmaProdC
      field
        primP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
        antidis_prim_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (opP xP yP) ==
            opP (primP yP) (primP xP)
    record InvolutiveMagmaHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveMagma A1)
      (In2 : InvolutiveMagma A2) :
      Set where
      constructor InvolutiveMagmaHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
    record InvolutiveMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveMagma A1)
      (In2 : InvolutiveMagma A2) :
      Set where
      constructor InvolutiveMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
    data InvolutiveMagmaTerm
      : Set where
      primL :
        InvolutiveMagmaTerm ->
        InvolutiveMagmaTerm
      opL :
        InvolutiveMagmaTerm ->
        InvolutiveMagmaTerm ->
        InvolutiveMagmaTerm
    data ClInvolutiveMagmaTerm
      (A : Set) : Set where
      sing :
        A -> ClInvolutiveMagmaTerm A
      primCl :
        ClInvolutiveMagmaTerm A ->
        ClInvolutiveMagmaTerm A
      opCl :
        ClInvolutiveMagmaTerm A ->
        ClInvolutiveMagmaTerm A ->
        ClInvolutiveMagmaTerm A
    data OpInvolutiveMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpInvolutiveMagmaTerm n
      primOL :
        OpInvolutiveMagmaTerm n ->
        OpInvolutiveMagmaTerm n
      opOL :
        OpInvolutiveMagmaTerm n ->
        OpInvolutiveMagmaTerm n ->
        OpInvolutiveMagmaTerm n
    data OpInvolutiveMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpInvolutiveMagmaTerm2 n A
      sing2 :
        A -> OpInvolutiveMagmaTerm2 n A
      primOL2 :
        OpInvolutiveMagmaTerm2 n A ->
        OpInvolutiveMagmaTerm2 n A
      opOL2 :
        OpInvolutiveMagmaTerm2 n A ->
        OpInvolutiveMagmaTerm2 n A ->
        OpInvolutiveMagmaTerm2 n A
    simplifyB :
      InvolutiveMagmaTerm ->
      InvolutiveMagmaTerm
    simplifyB (primL (primL x)) = x
    simplifyB (opL
               (primL y)
               (primL x)) = primL (opL x y)
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClInvolutiveMagmaTerm A ->
      ClInvolutiveMagmaTerm A
    simplifyCl _ (primCl
                  (primCl x)) = x
    simplifyCl _ (opCl
                  (primCl y)
                  (primCl x)) = primCl (opCl x y)
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpInvolutiveMagmaTerm n ->
      OpInvolutiveMagmaTerm n
    simplifyOp _ (primOL
                  (primOL x)) = x
    simplifyOp _ (opOL
                  (primOL y)
                  (primOL x)) = primOL (opOL x y)
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpInvolutiveMagmaTerm2 n A ->
      OpInvolutiveMagmaTerm2 n A
    simplifyOpE _ _ (primOL2
                     (primOL2 x)) = x
    simplifyOpE _ _ (opOL2
                     (primOL2 y)
                     (primOL2 x)) =
      primOL2 (opOL2 x y)
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      InvolutiveMagma A ->
      InvolutiveMagmaTerm -> A
    evalB _ In (primL x1) =
      prim In (evalB _ In x1)
    evalB _ In (opL x1 x2) =
      op In (evalB _ In x1)
        (evalB _ In x2)
    evalCl :
      (A : Set) ->
      InvolutiveMagma A ->
      ClInvolutiveMagmaTerm A -> A
    evalCl _ In (sing x1) = x1
    evalCl _ In (primCl x1) =
      prim In (evalCl _ In x1)
    evalCl _ In (opCl x1 x2) =
      op In (evalCl _ In x1)
        (evalCl _ In x2)
    evalOp :
      (A : Set) (n : Nat) ->
      InvolutiveMagma A ->
      Vec A n ->
      OpInvolutiveMagmaTerm n -> A
    evalOp _ n In vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n In vars (primOL x1) =
      prim In (evalOp _ n In vars x1)
    evalOp _ n In vars (opOL
                        x1
                        x2) =
      op In (evalOp _ n In vars x1)
        (evalOp _ n In vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      InvolutiveMagma A ->
      Vec A n ->
      OpInvolutiveMagmaTerm2 n A -> A
    evalOpE _ n In vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n In vars (sing2 x1) =
      x1
    evalOpE _ n In vars (primOL2
                         x1) =
      prim In (evalOpE _ n In vars x1)
    evalOpE _ n In vars (opOL2
                         x1
                         x2) =
      op In (evalOpE _ n In vars x1)
        (evalOpE _ n In vars x2)
    inductionB :
      (P : InvolutiveMagmaTerm ->
           Set) ->
      ((x1 : InvolutiveMagmaTerm) ->
       P x1 -> P (primL x1)) ->
      ((x1 : InvolutiveMagmaTerm)
       (x2 : InvolutiveMagmaTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : InvolutiveMagmaTerm) -> P x
    inductionB p ppriml popl (primL
                              x1) =
      ppriml _
        (inductionB p ppriml popl x1)
    inductionB p ppriml popl (opL
                              x1
                              x2) =
      popl _ _
        (inductionB p ppriml popl x1)
        (inductionB p ppriml popl x2)
    inductionCl :
      (A : Set)
      (P : ClInvolutiveMagmaTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClInvolutiveMagmaTerm
          A) -> P x1 -> P (primCl x1)) ->
      ((x1 : ClInvolutiveMagmaTerm A)
       (x2 : ClInvolutiveMagmaTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClInvolutiveMagmaTerm A) ->
      P x
    inductionCl _ p psing pprimcl popcl (sing
                                         x1) = psing x1
    inductionCl _ p psing pprimcl popcl (primCl
                                         x1) =
      pprimcl _
        (inductionCl _ p psing pprimcl
           popcl
           x1)
    inductionCl _ p psing pprimcl popcl (opCl
                                         x1
                                         x2) =
      popcl _ _
        (inductionCl _ p psing pprimcl
           popcl
           x1)
        (inductionCl _ p psing pprimcl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpInvolutiveMagmaTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpInvolutiveMagmaTerm
          n) -> P x1 -> P (primOL x1)) ->
      ((x1 : OpInvolutiveMagmaTerm n)
       (x2 : OpInvolutiveMagmaTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpInvolutiveMagmaTerm n) ->
      P x
    inductionOp _ p pv pprimol popol (v
                                      x1) = pv x1
    inductionOp _ p pv pprimol popol (primOL
                                      x1) =
      pprimol _
        (inductionOp _ p pv pprimol
           popol
           x1)
    inductionOp _ p pv pprimol popol (opOL
                                      x1
                                      x2) =
      popol _ _
        (inductionOp _ p pv pprimol
           popol
           x1)
        (inductionOp _ p pv pprimol
           popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpInvolutiveMagmaTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpInvolutiveMagmaTerm2 n
          A) -> P x1 -> P (primOL2 x1)) ->
      ((x1 : OpInvolutiveMagmaTerm2 n
          A)
       (x2 : OpInvolutiveMagmaTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpInvolutiveMagmaTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 pprimol2 popol2 (v2
                                                   x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 popol2 (sing2
                                                   x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 popol2 (primOL2
                                                   x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           popol2
           x1)
    inductionOpE _ _ p pv2 psing2 pprimol2 popol2 (opOL2
                                                   x1
                                                   x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           popol2
           x2)
    primL' :
      InvolutiveMagmaTerm ->
      InvolutiveMagmaTerm
    primL' x1 = primL x1
    opL' :
      InvolutiveMagmaTerm ->
      InvolutiveMagmaTerm ->
      InvolutiveMagmaTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      InvolutiveMagmaTerm ->
      Staged InvolutiveMagmaTerm
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    primCl' :
      (A : Set) ->
      ClInvolutiveMagmaTerm A ->
      ClInvolutiveMagmaTerm A
    primCl' _ x1 = primCl x1
    opCl' :
      (A : Set) ->
      ClInvolutiveMagmaTerm A ->
      ClInvolutiveMagmaTerm A ->
      ClInvolutiveMagmaTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClInvolutiveMagmaTerm A ->
      Staged (ClInvolutiveMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    primOL' :
      (n : Nat) ->
      OpInvolutiveMagmaTerm n ->
      OpInvolutiveMagmaTerm n
    primOL' _ x1 = primOL x1
    opOL' :
      (n : Nat) ->
      OpInvolutiveMagmaTerm n ->
      OpInvolutiveMagmaTerm n ->
      OpInvolutiveMagmaTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpInvolutiveMagmaTerm n ->
      Staged (OpInvolutiveMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    primOL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveMagmaTerm2 n A ->
      OpInvolutiveMagmaTerm2 n A
    primOL2' _ _ x1 = primOL2 x1
    opOL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveMagmaTerm2 n A ->
      OpInvolutiveMagmaTerm2 n A ->
      OpInvolutiveMagmaTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpInvolutiveMagmaTerm2 n A ->
      Staged
        (OpInvolutiveMagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record InvolutiveMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        primT : Repr A -> Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module InvolutiveMagmaSig where
    record InvolutiveMagmaSig
      (A : Set) : Set where
      constructor InvolutiveMagmaSigC
      field
        prim : A -> A
        op : A -> A -> A
    record InvolutiveMagmaSigSig
      (AS : Set) : Set where
      constructor InvolutiveMagmaSigSigSigC
      field
        primS : AS -> AS
        opS : AS -> AS -> AS
    record InvolutiveMagmaSigProd
      (AP : Set) : Set where
      constructor InvolutiveMagmaSigProdC
      field
        primP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record InvolutiveMagmaSigHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveMagmaSig A1)
      (In2 : InvolutiveMagmaSig A2) :
      Set where
      constructor InvolutiveMagmaSigHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
    record InvolutiveMagmaSigRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveMagmaSig A1)
      (In2 : InvolutiveMagmaSig A2) :
      Set where
      constructor InvolutiveMagmaSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
    data InvolutiveMagmaSigTerm
      : Set where
      primL :
        InvolutiveMagmaSigTerm ->
        InvolutiveMagmaSigTerm
      opL :
        InvolutiveMagmaSigTerm ->
        InvolutiveMagmaSigTerm ->
        InvolutiveMagmaSigTerm
    data ClInvolutiveMagmaSigTerm
      (A : Set) : Set where
      sing :
        A -> ClInvolutiveMagmaSigTerm A
      primCl :
        ClInvolutiveMagmaSigTerm A ->
        ClInvolutiveMagmaSigTerm A
      opCl :
        ClInvolutiveMagmaSigTerm A ->
        ClInvolutiveMagmaSigTerm A ->
        ClInvolutiveMagmaSigTerm A
    data OpInvolutiveMagmaSigTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpInvolutiveMagmaSigTerm n
      primOL :
        OpInvolutiveMagmaSigTerm n ->
        OpInvolutiveMagmaSigTerm n
      opOL :
        OpInvolutiveMagmaSigTerm n ->
        OpInvolutiveMagmaSigTerm n ->
        OpInvolutiveMagmaSigTerm n
    data OpInvolutiveMagmaSigTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpInvolutiveMagmaSigTerm2 n A
      sing2 :
        A ->
        OpInvolutiveMagmaSigTerm2 n A
      primOL2 :
        OpInvolutiveMagmaSigTerm2 n A ->
        OpInvolutiveMagmaSigTerm2 n A
      opOL2 :
        OpInvolutiveMagmaSigTerm2 n A ->
        OpInvolutiveMagmaSigTerm2 n A ->
        OpInvolutiveMagmaSigTerm2 n A
    simplifyB :
      InvolutiveMagmaSigTerm ->
      InvolutiveMagmaSigTerm
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClInvolutiveMagmaSigTerm A ->
      ClInvolutiveMagmaSigTerm A
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpInvolutiveMagmaSigTerm n ->
      OpInvolutiveMagmaSigTerm n
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpInvolutiveMagmaSigTerm2 n A ->
      OpInvolutiveMagmaSigTerm2 n A
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      InvolutiveMagmaSig A ->
      InvolutiveMagmaSigTerm -> A
    evalB _ In (primL x1) =
      prim In (evalB _ In x1)
    evalB _ In (opL x1 x2) =
      op In (evalB _ In x1)
        (evalB _ In x2)
    evalCl :
      (A : Set) ->
      InvolutiveMagmaSig A ->
      ClInvolutiveMagmaSigTerm A -> A
    evalCl _ In (sing x1) = x1
    evalCl _ In (primCl x1) =
      prim In (evalCl _ In x1)
    evalCl _ In (opCl x1 x2) =
      op In (evalCl _ In x1)
        (evalCl _ In x2)
    evalOp :
      (A : Set) (n : Nat) ->
      InvolutiveMagmaSig A ->
      Vec A n ->
      OpInvolutiveMagmaSigTerm n -> A
    evalOp _ n In vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n In vars (primOL x1) =
      prim In (evalOp _ n In vars x1)
    evalOp _ n In vars (opOL
                        x1
                        x2) =
      op In (evalOp _ n In vars x1)
        (evalOp _ n In vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      InvolutiveMagmaSig A ->
      Vec A n ->
      OpInvolutiveMagmaSigTerm2 n A ->
      A
    evalOpE _ n In vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n In vars (sing2 x1) =
      x1
    evalOpE _ n In vars (primOL2
                         x1) =
      prim In (evalOpE _ n In vars x1)
    evalOpE _ n In vars (opOL2
                         x1
                         x2) =
      op In (evalOpE _ n In vars x1)
        (evalOpE _ n In vars x2)
    inductionB :
      (P : InvolutiveMagmaSigTerm ->
           Set) ->
      ((x1 : InvolutiveMagmaSigTerm) ->
       P x1 -> P (primL x1)) ->
      ((x1 : InvolutiveMagmaSigTerm)
       (x2 : InvolutiveMagmaSigTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : InvolutiveMagmaSigTerm) ->
      P x
    inductionB p ppriml popl (primL
                              x1) =
      ppriml _
        (inductionB p ppriml popl x1)
    inductionB p ppriml popl (opL
                              x1
                              x2) =
      popl _ _
        (inductionB p ppriml popl x1)
        (inductionB p ppriml popl x2)
    inductionCl :
      (A : Set)
      (P : ClInvolutiveMagmaSigTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClInvolutiveMagmaSigTerm
          A) -> P x1 -> P (primCl x1)) ->
      ((x1 : ClInvolutiveMagmaSigTerm
          A)
       (x2 : ClInvolutiveMagmaSigTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClInvolutiveMagmaSigTerm
         A) -> P x
    inductionCl _ p psing pprimcl popcl (sing
                                         x1) = psing x1
    inductionCl _ p psing pprimcl popcl (primCl
                                         x1) =
      pprimcl _
        (inductionCl _ p psing pprimcl
           popcl
           x1)
    inductionCl _ p psing pprimcl popcl (opCl
                                         x1
                                         x2) =
      popcl _ _
        (inductionCl _ p psing pprimcl
           popcl
           x1)
        (inductionCl _ p psing pprimcl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpInvolutiveMagmaSigTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpInvolutiveMagmaSigTerm
          n) -> P x1 -> P (primOL x1)) ->
      ((x1 : OpInvolutiveMagmaSigTerm
          n)
       (x2 : OpInvolutiveMagmaSigTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpInvolutiveMagmaSigTerm
         n) -> P x
    inductionOp _ p pv pprimol popol (v
                                      x1) = pv x1
    inductionOp _ p pv pprimol popol (primOL
                                      x1) =
      pprimol _
        (inductionOp _ p pv pprimol
           popol
           x1)
    inductionOp _ p pv pprimol popol (opOL
                                      x1
                                      x2) =
      popol _ _
        (inductionOp _ p pv pprimol
           popol
           x1)
        (inductionOp _ p pv pprimol
           popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpInvolutiveMagmaSigTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpInvolutiveMagmaSigTerm2
          n
          A) -> P x1 -> P (primOL2 x1)) ->
      ((x1 : OpInvolutiveMagmaSigTerm2
          n
          A)
       (x2 : OpInvolutiveMagmaSigTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpInvolutiveMagmaSigTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 pprimol2 popol2 (v2
                                                   x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 popol2 (sing2
                                                   x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 popol2 (primOL2
                                                   x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           popol2
           x1)
    inductionOpE _ _ p pv2 psing2 pprimol2 popol2 (opOL2
                                                   x1
                                                   x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           popol2
           x2)
    primL' :
      InvolutiveMagmaSigTerm ->
      InvolutiveMagmaSigTerm
    primL' x1 = primL x1
    opL' :
      InvolutiveMagmaSigTerm ->
      InvolutiveMagmaSigTerm ->
      InvolutiveMagmaSigTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      InvolutiveMagmaSigTerm ->
      Staged InvolutiveMagmaSigTerm
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    primCl' :
      (A : Set) ->
      ClInvolutiveMagmaSigTerm A ->
      ClInvolutiveMagmaSigTerm A
    primCl' _ x1 = primCl x1
    opCl' :
      (A : Set) ->
      ClInvolutiveMagmaSigTerm A ->
      ClInvolutiveMagmaSigTerm A ->
      ClInvolutiveMagmaSigTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClInvolutiveMagmaSigTerm A ->
      Staged
        (ClInvolutiveMagmaSigTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    primOL' :
      (n : Nat) ->
      OpInvolutiveMagmaSigTerm n ->
      OpInvolutiveMagmaSigTerm n
    primOL' _ x1 = primOL x1
    opOL' :
      (n : Nat) ->
      OpInvolutiveMagmaSigTerm n ->
      OpInvolutiveMagmaSigTerm n ->
      OpInvolutiveMagmaSigTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpInvolutiveMagmaSigTerm n ->
      Staged
        (OpInvolutiveMagmaSigTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    primOL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveMagmaSigTerm2 n A ->
      OpInvolutiveMagmaSigTerm2 n A
    primOL2' _ _ x1 = primOL2 x1
    opOL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveMagmaSigTerm2 n A ->
      OpInvolutiveMagmaSigTerm2 n A ->
      OpInvolutiveMagmaSigTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpInvolutiveMagmaSigTerm2 n A ->
      Staged
        (OpInvolutiveMagmaSigTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record InvolutiveMagmaSigTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        primT : Repr A -> Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module InvolutiveMultMagmaSig where
    record InvolutiveMultMagmaSig
      (A : Set) : Set where
      constructor InvolutiveMultMagmaSigC
      field
        * : A -> A -> A
        prim : A -> A
    record InvolutiveMultMagmaSigSig
      (AS : Set) : Set where
      constructor InvolutiveMultMagmaSigSigSigC
      field
        *S : AS -> AS -> AS
        primS : AS -> AS
    record InvolutiveMultMagmaSigProd
      (AP : Set) : Set where
      constructor InvolutiveMultMagmaSigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
    record InvolutiveMultMagmaSigHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveMultMagmaSig
         A1)
      (In2 : InvolutiveMultMagmaSig
         A2) : Set where
      constructor InvolutiveMultMagmaSigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* In1 x1 x2) ==
            * In2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutiveMultMagmaSigRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveMultMagmaSig
         A1)
      (In2 : InvolutiveMultMagmaSig
         A2) : Set where
      constructor InvolutiveMultMagmaSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* In1 x1 x2)
            (* In2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutiveMultMagmaSigTerm
      : Set where
      *L :
        InvolutiveMultMagmaSigTerm ->
        InvolutiveMultMagmaSigTerm ->
        InvolutiveMultMagmaSigTerm
      primL :
        InvolutiveMultMagmaSigTerm ->
        InvolutiveMultMagmaSigTerm
    data ClInvolutiveMultMagmaSigTerm
      (A : Set) : Set where
      sing :
        A ->
        ClInvolutiveMultMagmaSigTerm A
      *Cl :
        ClInvolutiveMultMagmaSigTerm
          A ->
        ClInvolutiveMultMagmaSigTerm
          A ->
        ClInvolutiveMultMagmaSigTerm A
      primCl :
        ClInvolutiveMultMagmaSigTerm
          A ->
        ClInvolutiveMultMagmaSigTerm A
    data OpInvolutiveMultMagmaSigTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpInvolutiveMultMagmaSigTerm n
      *OL :
        OpInvolutiveMultMagmaSigTerm
          n ->
        OpInvolutiveMultMagmaSigTerm
          n ->
        OpInvolutiveMultMagmaSigTerm n
      primOL :
        OpInvolutiveMultMagmaSigTerm
          n ->
        OpInvolutiveMultMagmaSigTerm n
    data OpInvolutiveMultMagmaSigTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpInvolutiveMultMagmaSigTerm2 n
          A
      sing2 :
        A ->
        OpInvolutiveMultMagmaSigTerm2 n
          A
      *OL2 :
        OpInvolutiveMultMagmaSigTerm2 n
          A ->
        OpInvolutiveMultMagmaSigTerm2 n
          A ->
        OpInvolutiveMultMagmaSigTerm2 n
          A
      primOL2 :
        OpInvolutiveMultMagmaSigTerm2 n
          A ->
        OpInvolutiveMultMagmaSigTerm2 n
          A
    simplifyB :
      InvolutiveMultMagmaSigTerm ->
      InvolutiveMultMagmaSigTerm
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClInvolutiveMultMagmaSigTerm
        A ->
      ClInvolutiveMultMagmaSigTerm A
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpInvolutiveMultMagmaSigTerm
        n ->
      OpInvolutiveMultMagmaSigTerm n
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpInvolutiveMultMagmaSigTerm2 n
        A ->
      OpInvolutiveMultMagmaSigTerm2 n
        A
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      InvolutiveMultMagmaSig A ->
      InvolutiveMultMagmaSigTerm -> A
    evalB _ In (*L x1 x2) =
      * In (evalB _ In x1)
        (evalB _ In x2)
    evalB _ In (primL x1) =
      prim In (evalB _ In x1)
    evalCl :
      (A : Set) ->
      InvolutiveMultMagmaSig A ->
      ClInvolutiveMultMagmaSigTerm
        A -> A
    evalCl _ In (sing x1) = x1
    evalCl _ In (*Cl x1 x2) =
      * In (evalCl _ In x1)
        (evalCl _ In x2)
    evalCl _ In (primCl x1) =
      prim In (evalCl _ In x1)
    evalOp :
      (A : Set) (n : Nat) ->
      InvolutiveMultMagmaSig A ->
      Vec A n ->
      OpInvolutiveMultMagmaSigTerm
        n -> A
    evalOp _ n In vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n In vars (*OL x1 x2) =
      * In (evalOp _ n In vars x1)
        (evalOp _ n In vars x2)
    evalOp _ n In vars (primOL x1) =
      prim In (evalOp _ n In vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      InvolutiveMultMagmaSig A ->
      Vec A n ->
      OpInvolutiveMultMagmaSigTerm2 n
        A -> A
    evalOpE _ n In vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n In vars (sing2 x1) =
      x1
    evalOpE _ n In vars (*OL2
                         x1
                         x2) =
      * In (evalOpE _ n In vars x1)
        (evalOpE _ n In vars x2)
    evalOpE _ n In vars (primOL2
                         x1) =
      prim In (evalOpE _ n In vars x1)
    inductionB :
      (P : InvolutiveMultMagmaSigTerm ->
           Set) ->
      ((x1 : InvolutiveMultMagmaSigTerm)
       (x2 : InvolutiveMultMagmaSigTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : InvolutiveMultMagmaSigTerm) ->
       P x1 -> P (primL x1)) ->
      (x : InvolutiveMultMagmaSigTerm) ->
      P x
    inductionB p p*l ppriml (*L
                             x1
                             x2) =
      p*l _ _
        (inductionB p p*l ppriml x1)
        (inductionB p p*l ppriml x2)
    inductionB p p*l ppriml (primL
                             x1) =
      ppriml _
        (inductionB p p*l ppriml x1)
    inductionCl :
      (A : Set)
      (P : ClInvolutiveMultMagmaSigTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClInvolutiveMultMagmaSigTerm
          A)
       (x2 : ClInvolutiveMultMagmaSigTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClInvolutiveMultMagmaSigTerm
          A) -> P x1 -> P (primCl x1)) ->
      (x : ClInvolutiveMultMagmaSigTerm
         A) -> P x
    inductionCl _ p psing p*cl pprimcl (sing
                                        x1) = psing x1
    inductionCl _ p psing p*cl pprimcl (*Cl
                                        x1
                                        x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl
           pprimcl
           x1)
        (inductionCl _ p psing p*cl
           pprimcl
           x2)
    inductionCl _ p psing p*cl pprimcl (primCl
                                        x1) =
      pprimcl _
        (inductionCl _ p psing p*cl
           pprimcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpInvolutiveMultMagmaSigTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpInvolutiveMultMagmaSigTerm
          n)
       (x2 : OpInvolutiveMultMagmaSigTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpInvolutiveMultMagmaSigTerm
          n) -> P x1 -> P (primOL x1)) ->
      (x : OpInvolutiveMultMagmaSigTerm
         n) -> P x
    inductionOp _ p pv p*ol pprimol (v
                                     x1) = pv x1
    inductionOp _ p pv p*ol pprimol (*OL
                                     x1
                                     x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol pprimol
           x1)
        (inductionOp _ p pv p*ol pprimol
           x2)
    inductionOp _ p pv p*ol pprimol (primOL
                                     x1) =
      pprimol _
        (inductionOp _ p pv p*ol pprimol
           x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpInvolutiveMultMagmaSigTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpInvolutiveMultMagmaSigTerm2
          n
          A)
       (x2 : OpInvolutiveMultMagmaSigTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpInvolutiveMultMagmaSigTerm2
          n
          A) -> P x1 -> P (primOL2 x1)) ->
      (x : OpInvolutiveMultMagmaSigTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 pprimol2 (v2
                                                  x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 pprimol2 (sing2
                                                  x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 pprimol2 (*OL2
                                                  x1
                                                  x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           pprimol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           pprimol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 pprimol2 (primOL2
                                                  x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           pprimol2
           x1)
    *L' :
      InvolutiveMultMagmaSigTerm ->
      InvolutiveMultMagmaSigTerm ->
      InvolutiveMultMagmaSigTerm
    *L' x1 x2 = *L x1 x2
    primL' :
      InvolutiveMultMagmaSigTerm ->
      InvolutiveMultMagmaSigTerm
    primL' x1 = primL x1
    stageB :
      InvolutiveMultMagmaSigTerm ->
      Staged
        InvolutiveMultMagmaSigTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    *Cl' :
      (A : Set) ->
      ClInvolutiveMultMagmaSigTerm
        A ->
      ClInvolutiveMultMagmaSigTerm
        A ->
      ClInvolutiveMultMagmaSigTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    primCl' :
      (A : Set) ->
      ClInvolutiveMultMagmaSigTerm
        A ->
      ClInvolutiveMultMagmaSigTerm A
    primCl' _ x1 = primCl x1
    stageCl :
      (A : Set) ->
      ClInvolutiveMultMagmaSigTerm
        A ->
      Staged
        (ClInvolutiveMultMagmaSigTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    *OL' :
      (n : Nat) ->
      OpInvolutiveMultMagmaSigTerm
        n ->
      OpInvolutiveMultMagmaSigTerm
        n ->
      OpInvolutiveMultMagmaSigTerm n
    *OL' _ x1 x2 = *OL x1 x2
    primOL' :
      (n : Nat) ->
      OpInvolutiveMultMagmaSigTerm
        n ->
      OpInvolutiveMultMagmaSigTerm n
    primOL' _ x1 = primOL x1
    stageOp :
      (n : Nat) ->
      OpInvolutiveMultMagmaSigTerm
        n ->
      Staged
        (OpInvolutiveMultMagmaSigTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveMultMagmaSigTerm2 n
        A ->
      OpInvolutiveMultMagmaSigTerm2 n
        A ->
      OpInvolutiveMultMagmaSigTerm2 n
        A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    primOL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveMultMagmaSigTerm2 n
        A ->
      OpInvolutiveMultMagmaSigTerm2 n
        A
    primOL2' _ _ x1 = primOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpInvolutiveMultMagmaSigTerm2 n
        A ->
      Staged
        (OpInvolutiveMultMagmaSigTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    record InvolutiveMultMagmaSigTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        primT : Repr A -> Repr A
  
  module InvolutivePointedMagmaSig where
    record InvolutivePointedMagmaSig
      (A : Set) : Set where
      constructor InvolutivePointedMagmaSigC
      field
        prim : A -> A
        e : A
        op : A -> A -> A
    record InvolutivePointedMagmaSigSig
      (AS : Set) : Set where
      constructor InvolutivePointedMagmaSigSigSigC
      field
        primS : AS -> AS
        eS : AS
        opS : AS -> AS -> AS
    record InvolutivePointedMagmaSigProd
      (AP : Set) : Set where
      constructor InvolutivePointedMagmaSigProdC
      field
        primP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record InvolutivePointedMagmaSigHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutivePointedMagmaSig
         A1)
      (In2 : InvolutivePointedMagmaSig
         A2) : Set where
      constructor InvolutivePointedMagmaSigHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-e : hom (e In1) == e In2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
    record InvolutivePointedMagmaSigRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutivePointedMagmaSig
         A1)
      (In2 : InvolutivePointedMagmaSig
         A2) : Set where
      constructor InvolutivePointedMagmaSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-e :
          interp (e In1) (e In2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
    data InvolutivePointedMagmaSigTerm
      : Set where
      primL :
        InvolutivePointedMagmaSigTerm ->
        InvolutivePointedMagmaSigTerm
      eL :
        InvolutivePointedMagmaSigTerm
      opL :
        InvolutivePointedMagmaSigTerm ->
        InvolutivePointedMagmaSigTerm ->
        InvolutivePointedMagmaSigTerm
    data ClInvolutivePointedMagmaSigTerm
      (A : Set) : Set where
      sing :
        A ->
        ClInvolutivePointedMagmaSigTerm
          A
      primCl :
        ClInvolutivePointedMagmaSigTerm
          A ->
        ClInvolutivePointedMagmaSigTerm
          A
      eCl :
        ClInvolutivePointedMagmaSigTerm
          A
      opCl :
        ClInvolutivePointedMagmaSigTerm
          A ->
        ClInvolutivePointedMagmaSigTerm
          A ->
        ClInvolutivePointedMagmaSigTerm
          A
    data OpInvolutivePointedMagmaSigTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpInvolutivePointedMagmaSigTerm
          n
      primOL :
        OpInvolutivePointedMagmaSigTerm
          n ->
        OpInvolutivePointedMagmaSigTerm
          n
      eOL :
        OpInvolutivePointedMagmaSigTerm
          n
      opOL :
        OpInvolutivePointedMagmaSigTerm
          n ->
        OpInvolutivePointedMagmaSigTerm
          n ->
        OpInvolutivePointedMagmaSigTerm
          n
    data OpInvolutivePointedMagmaSigTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpInvolutivePointedMagmaSigTerm2
          n
          A
      sing2 :
        A ->
        OpInvolutivePointedMagmaSigTerm2
          n
          A
      primOL2 :
        OpInvolutivePointedMagmaSigTerm2
          n
          A ->
        OpInvolutivePointedMagmaSigTerm2
          n
          A
      eOL2 :
        OpInvolutivePointedMagmaSigTerm2
          n
          A
      opOL2 :
        OpInvolutivePointedMagmaSigTerm2
          n
          A ->
        OpInvolutivePointedMagmaSigTerm2
          n
          A ->
        OpInvolutivePointedMagmaSigTerm2
          n
          A
    simplifyB :
      InvolutivePointedMagmaSigTerm ->
      InvolutivePointedMagmaSigTerm
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyB (eL) = eL
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClInvolutivePointedMagmaSigTerm
        A ->
      ClInvolutivePointedMagmaSigTerm
        A
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpInvolutivePointedMagmaSigTerm
        n ->
      OpInvolutivePointedMagmaSigTerm
        n
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpInvolutivePointedMagmaSigTerm2
        n
        A ->
      OpInvolutivePointedMagmaSigTerm2
        n
        A
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      InvolutivePointedMagmaSig A ->
      InvolutivePointedMagmaSigTerm ->
      A
    evalB _ In (primL x1) =
      prim In (evalB _ In x1)
    evalB _ In (eL) = e In
    evalB _ In (opL x1 x2) =
      op In (evalB _ In x1)
        (evalB _ In x2)
    evalCl :
      (A : Set) ->
      InvolutivePointedMagmaSig A ->
      ClInvolutivePointedMagmaSigTerm
        A -> A
    evalCl _ In (sing x1) = x1
    evalCl _ In (primCl x1) =
      prim In (evalCl _ In x1)
    evalCl _ In (eCl) = e In
    evalCl _ In (opCl x1 x2) =
      op In (evalCl _ In x1)
        (evalCl _ In x2)
    evalOp :
      (A : Set) (n : Nat) ->
      InvolutivePointedMagmaSig A ->
      Vec A n ->
      OpInvolutivePointedMagmaSigTerm
        n -> A
    evalOp _ n In vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n In vars (primOL x1) =
      prim In (evalOp _ n In vars x1)
    evalOp _ n In vars (eOL) = e In
    evalOp _ n In vars (opOL
                        x1
                        x2) =
      op In (evalOp _ n In vars x1)
        (evalOp _ n In vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      InvolutivePointedMagmaSig A ->
      Vec A n ->
      OpInvolutivePointedMagmaSigTerm2
        n
        A -> A
    evalOpE _ n In vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n In vars (sing2 x1) =
      x1
    evalOpE _ n In vars (primOL2
                         x1) =
      prim In (evalOpE _ n In vars x1)
    evalOpE _ n In vars (eOL2) =
      e In
    evalOpE _ n In vars (opOL2
                         x1
                         x2) =
      op In (evalOpE _ n In vars x1)
        (evalOpE _ n In vars x2)
    inductionB :
      (P : InvolutivePointedMagmaSigTerm ->
           Set) ->
      ((x1 : InvolutivePointedMagmaSigTerm) ->
       P x1 -> P (primL x1)) ->
      P eL ->
      ((x1 : InvolutivePointedMagmaSigTerm)
       (x2 : InvolutivePointedMagmaSigTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : InvolutivePointedMagmaSigTerm) ->
      P x
    inductionB p ppriml pel popl (primL
                                  x1) =
      ppriml _
        (inductionB p ppriml pel popl
           x1)
    inductionB p ppriml pel popl (eL) =
      pel
    inductionB p ppriml pel popl (opL
                                  x1
                                  x2) =
      popl _ _
        (inductionB p ppriml pel popl
           x1)
        (inductionB p ppriml pel popl
           x2)
    inductionCl :
      (A : Set)
      (P : ClInvolutivePointedMagmaSigTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClInvolutivePointedMagmaSigTerm
          A) -> P x1 -> P (primCl x1)) ->
      P eCl ->
      ((x1 : ClInvolutivePointedMagmaSigTerm
          A)
       (x2 : ClInvolutivePointedMagmaSigTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClInvolutivePointedMagmaSigTerm
         A) -> P x
    inductionCl _ p psing pprimcl pecl popcl (sing
                                              x1) = psing x1
    inductionCl _ p psing pprimcl pecl popcl (primCl
                                              x1) =
      pprimcl _
        (inductionCl _ p psing pprimcl
           pecl
           popcl
           x1)
    inductionCl _ p psing pprimcl pecl popcl (eCl) =
      pecl
    inductionCl _ p psing pprimcl pecl popcl (opCl
                                              x1
                                              x2) =
      popcl _ _
        (inductionCl _ p psing pprimcl
           pecl
           popcl
           x1)
        (inductionCl _ p psing pprimcl
           pecl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpInvolutivePointedMagmaSigTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpInvolutivePointedMagmaSigTerm
          n) -> P x1 -> P (primOL x1)) ->
      P eOL ->
      ((x1 : OpInvolutivePointedMagmaSigTerm
          n)
       (x2 : OpInvolutivePointedMagmaSigTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpInvolutivePointedMagmaSigTerm
         n) -> P x
    inductionOp _ p pv pprimol peol popol (v
                                           x1) = pv x1
    inductionOp _ p pv pprimol peol popol (primOL
                                           x1) =
      pprimol _
        (inductionOp _ p pv pprimol peol
           popol
           x1)
    inductionOp _ p pv pprimol peol popol (eOL) =
      peol
    inductionOp _ p pv pprimol peol popol (opOL
                                           x1
                                           x2) =
      popol _ _
        (inductionOp _ p pv pprimol peol
           popol
           x1)
        (inductionOp _ p pv pprimol peol
           popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpInvolutivePointedMagmaSigTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpInvolutivePointedMagmaSigTerm2
          n
          A) -> P x1 -> P (primOL2 x1)) ->
      P eOL2 ->
      ((x1 : OpInvolutivePointedMagmaSigTerm2
          n
          A)
       (x2 : OpInvolutivePointedMagmaSigTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpInvolutivePointedMagmaSigTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 pprimol2 peol2 popol2 (v2
                                                         x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 peol2 popol2 (sing2
                                                         x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 peol2 popol2 (primOL2
                                                         x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           peol2
           popol2
           x1)
    inductionOpE _ _ p pv2 psing2 pprimol2 peol2 popol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 pprimol2 peol2 popol2 (opOL2
                                                         x1
                                                         x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           peol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           peol2
           popol2
           x2)
    primL' :
      InvolutivePointedMagmaSigTerm ->
      InvolutivePointedMagmaSigTerm
    primL' x1 = primL x1
    eL' :
      InvolutivePointedMagmaSigTerm
    eL' = eL
    opL' :
      InvolutivePointedMagmaSigTerm ->
      InvolutivePointedMagmaSigTerm ->
      InvolutivePointedMagmaSigTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      InvolutivePointedMagmaSigTerm ->
      Staged
        InvolutivePointedMagmaSigTerm
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    stageB (eL) = Now eL
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    primCl' :
      (A : Set) ->
      ClInvolutivePointedMagmaSigTerm
        A ->
      ClInvolutivePointedMagmaSigTerm
        A
    primCl' _ x1 = primCl x1
    eCl' :
      (A : Set) ->
      ClInvolutivePointedMagmaSigTerm
        A
    eCl' _ = eCl
    opCl' :
      (A : Set) ->
      ClInvolutivePointedMagmaSigTerm
        A ->
      ClInvolutivePointedMagmaSigTerm
        A ->
      ClInvolutivePointedMagmaSigTerm
        A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClInvolutivePointedMagmaSigTerm
        A ->
      Staged
        (ClInvolutivePointedMagmaSigTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    stageCl _ (eCl) = Now eCl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    primOL' :
      (n : Nat) ->
      OpInvolutivePointedMagmaSigTerm
        n ->
      OpInvolutivePointedMagmaSigTerm
        n
    primOL' _ x1 = primOL x1
    eOL' :
      (n : Nat) ->
      OpInvolutivePointedMagmaSigTerm
        n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      OpInvolutivePointedMagmaSigTerm
        n ->
      OpInvolutivePointedMagmaSigTerm
        n ->
      OpInvolutivePointedMagmaSigTerm
        n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpInvolutivePointedMagmaSigTerm
        n ->
      Staged
        (OpInvolutivePointedMagmaSigTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    stageOp _ (eOL) = Now eOL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    primOL2' :
      (n : Nat) (A : Set) ->
      OpInvolutivePointedMagmaSigTerm2
        n
        A ->
      OpInvolutivePointedMagmaSigTerm2
        n
        A
    primOL2' _ _ x1 = primOL2 x1
    eOL2' :
      (n : Nat) (A : Set) ->
      OpInvolutivePointedMagmaSigTerm2
        n
        A
    eOL2' _ _ = eOL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpInvolutivePointedMagmaSigTerm2
        n
        A ->
      OpInvolutivePointedMagmaSigTerm2
        n
        A ->
      OpInvolutivePointedMagmaSigTerm2
        n
        A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpInvolutivePointedMagmaSigTerm2
        n
        A ->
      Staged
        (OpInvolutivePointedMagmaSigTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record InvolutivePointedMagmaSigTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        primT : Repr A -> Repr A
        eT : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module InvolutivePointedSemigroup where
    record InvolutivePointedSemigroup
      (A : Set) : Set where
      constructor InvolutivePointedSemigroupC
      field
        op : A -> A -> A
        e : A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        prim : A -> A
        involutive_prim :
          (x : A) -> prim (prim x) == x
        antidis_prim_op :
          (x : A) (y : A) ->
          prim (op x y) ==
            op (prim y) (prim x)
    record InvolutivePointedSemigroupSig
      (AS : Set) : Set where
      constructor InvolutivePointedSemigroupSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
        primS : AS -> AS
    record InvolutivePointedSemigroupProd
      (AP : Set) : Set where
      constructor InvolutivePointedSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
        antidis_prim_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (opP xP yP) ==
            opP (primP yP) (primP xP)
    record InvolutivePointedSemigroupHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutivePointedSemigroup
         A1)
      (In2 : InvolutivePointedSemigroup
         A2) : Set where
      constructor InvolutivePointedSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
        pres-e : hom (e In1) == e In2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutivePointedSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutivePointedSemigroup
         A1)
      (In2 : InvolutivePointedSemigroup
         A2) : Set where
      constructor InvolutivePointedSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
        interp-e :
          interp (e In1) (e In2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutivePointedSemigroupTerm
      : Set where
      opL :
        InvolutivePointedSemigroupTerm ->
        InvolutivePointedSemigroupTerm ->
        InvolutivePointedSemigroupTerm
      eL :
        InvolutivePointedSemigroupTerm
      primL :
        InvolutivePointedSemigroupTerm ->
        InvolutivePointedSemigroupTerm
    data ClInvolutivePointedSemigroupTerm
      (A : Set) : Set where
      sing :
        A ->
        ClInvolutivePointedSemigroupTerm
          A
      opCl :
        ClInvolutivePointedSemigroupTerm
          A ->
        ClInvolutivePointedSemigroupTerm
          A ->
        ClInvolutivePointedSemigroupTerm
          A
      eCl :
        ClInvolutivePointedSemigroupTerm
          A
      primCl :
        ClInvolutivePointedSemigroupTerm
          A ->
        ClInvolutivePointedSemigroupTerm
          A
    data OpInvolutivePointedSemigroupTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpInvolutivePointedSemigroupTerm
          n
      opOL :
        OpInvolutivePointedSemigroupTerm
          n ->
        OpInvolutivePointedSemigroupTerm
          n ->
        OpInvolutivePointedSemigroupTerm
          n
      eOL :
        OpInvolutivePointedSemigroupTerm
          n
      primOL :
        OpInvolutivePointedSemigroupTerm
          n ->
        OpInvolutivePointedSemigroupTerm
          n
    data OpInvolutivePointedSemigroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpInvolutivePointedSemigroupTerm2
          n
          A
      sing2 :
        A ->
        OpInvolutivePointedSemigroupTerm2
          n
          A
      opOL2 :
        OpInvolutivePointedSemigroupTerm2
          n
          A ->
        OpInvolutivePointedSemigroupTerm2
          n
          A ->
        OpInvolutivePointedSemigroupTerm2
          n
          A
      eOL2 :
        OpInvolutivePointedSemigroupTerm2
          n
          A
      primOL2 :
        OpInvolutivePointedSemigroupTerm2
          n
          A ->
        OpInvolutivePointedSemigroupTerm2
          n
          A
    simplifyB :
      InvolutivePointedSemigroupTerm ->
      InvolutivePointedSemigroupTerm
    simplifyB (primL (primL x)) = x
    simplifyB (opL
               (primL y)
               (primL x)) = primL (opL x y)
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (eL) = eL
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClInvolutivePointedSemigroupTerm
        A ->
      ClInvolutivePointedSemigroupTerm
        A
    simplifyCl _ (primCl
                  (primCl x)) = x
    simplifyCl _ (opCl
                  (primCl y)
                  (primCl x)) = primCl (opCl x y)
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpInvolutivePointedSemigroupTerm
        n ->
      OpInvolutivePointedSemigroupTerm
        n
    simplifyOp _ (primOL
                  (primOL x)) = x
    simplifyOp _ (opOL
                  (primOL y)
                  (primOL x)) = primOL (opOL x y)
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpInvolutivePointedSemigroupTerm2
        n
        A ->
      OpInvolutivePointedSemigroupTerm2
        n
        A
    simplifyOpE _ _ (primOL2
                     (primOL2 x)) = x
    simplifyOpE _ _ (opOL2
                     (primOL2 y)
                     (primOL2 x)) =
      primOL2 (opOL2 x y)
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      InvolutivePointedSemigroup A ->
      InvolutivePointedSemigroupTerm ->
      A
    evalB _ In (opL x1 x2) =
      op In (evalB _ In x1)
        (evalB _ In x2)
    evalB _ In (eL) = e In
    evalB _ In (primL x1) =
      prim In (evalB _ In x1)
    evalCl :
      (A : Set) ->
      InvolutivePointedSemigroup A ->
      ClInvolutivePointedSemigroupTerm
        A -> A
    evalCl _ In (sing x1) = x1
    evalCl _ In (opCl x1 x2) =
      op In (evalCl _ In x1)
        (evalCl _ In x2)
    evalCl _ In (eCl) = e In
    evalCl _ In (primCl x1) =
      prim In (evalCl _ In x1)
    evalOp :
      (A : Set) (n : Nat) ->
      InvolutivePointedSemigroup A ->
      Vec A n ->
      OpInvolutivePointedSemigroupTerm
        n -> A
    evalOp _ n In vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n In vars (opOL
                        x1
                        x2) =
      op In (evalOp _ n In vars x1)
        (evalOp _ n In vars x2)
    evalOp _ n In vars (eOL) = e In
    evalOp _ n In vars (primOL x1) =
      prim In (evalOp _ n In vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      InvolutivePointedSemigroup A ->
      Vec A n ->
      OpInvolutivePointedSemigroupTerm2
        n
        A -> A
    evalOpE _ n In vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n In vars (sing2 x1) =
      x1
    evalOpE _ n In vars (opOL2
                         x1
                         x2) =
      op In (evalOpE _ n In vars x1)
        (evalOpE _ n In vars x2)
    evalOpE _ n In vars (eOL2) =
      e In
    evalOpE _ n In vars (primOL2
                         x1) =
      prim In (evalOpE _ n In vars x1)
    inductionB :
      (P : InvolutivePointedSemigroupTerm ->
           Set) ->
      ((x1 : InvolutivePointedSemigroupTerm)
       (x2 : InvolutivePointedSemigroupTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      P eL ->
      ((x1 : InvolutivePointedSemigroupTerm) ->
       P x1 -> P (primL x1)) ->
      (x : InvolutivePointedSemigroupTerm) ->
      P x
    inductionB p popl pel ppriml (opL
                                  x1
                                  x2) =
      popl _ _
        (inductionB p popl pel ppriml
           x1)
        (inductionB p popl pel ppriml
           x2)
    inductionB p popl pel ppriml (eL) =
      pel
    inductionB p popl pel ppriml (primL
                                  x1) =
      ppriml _
        (inductionB p popl pel ppriml
           x1)
    inductionCl :
      (A : Set)
      (P : ClInvolutivePointedSemigroupTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClInvolutivePointedSemigroupTerm
          A)
       (x2 : ClInvolutivePointedSemigroupTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      P eCl ->
      ((x1 : ClInvolutivePointedSemigroupTerm
          A) -> P x1 -> P (primCl x1)) ->
      (x : ClInvolutivePointedSemigroupTerm
         A) -> P x
    inductionCl _ p psing popcl pecl pprimcl (sing
                                              x1) = psing x1
    inductionCl _ p psing popcl pecl pprimcl (opCl
                                              x1
                                              x2) =
      popcl _ _
        (inductionCl _ p psing popcl
           pecl
           pprimcl
           x1)
        (inductionCl _ p psing popcl
           pecl
           pprimcl
           x2)
    inductionCl _ p psing popcl pecl pprimcl (eCl) =
      pecl
    inductionCl _ p psing popcl pecl pprimcl (primCl
                                              x1) =
      pprimcl _
        (inductionCl _ p psing popcl
           pecl
           pprimcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpInvolutivePointedSemigroupTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpInvolutivePointedSemigroupTerm
          n)
       (x2 : OpInvolutivePointedSemigroupTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      P eOL ->
      ((x1 : OpInvolutivePointedSemigroupTerm
          n) -> P x1 -> P (primOL x1)) ->
      (x : OpInvolutivePointedSemigroupTerm
         n) -> P x
    inductionOp _ p pv popol peol pprimol (v
                                           x1) = pv x1
    inductionOp _ p pv popol peol pprimol (opOL
                                           x1
                                           x2) =
      popol _ _
        (inductionOp _ p pv popol peol
           pprimol
           x1)
        (inductionOp _ p pv popol peol
           pprimol
           x2)
    inductionOp _ p pv popol peol pprimol (eOL) =
      peol
    inductionOp _ p pv popol peol pprimol (primOL
                                           x1) =
      pprimol _
        (inductionOp _ p pv popol peol
           pprimol
           x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpInvolutivePointedSemigroupTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpInvolutivePointedSemigroupTerm2
          n
          A)
       (x2 : OpInvolutivePointedSemigroupTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      P eOL2 ->
      ((x1 : OpInvolutivePointedSemigroupTerm2
          n
          A) -> P x1 -> P (primOL2 x1)) ->
      (x : OpInvolutivePointedSemigroupTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 peol2 pprimol2 (v2
                                                         x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 peol2 pprimol2 (sing2
                                                         x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 peol2 pprimol2 (opOL2
                                                         x1
                                                         x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           pprimol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           pprimol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 peol2 pprimol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 popol2 peol2 pprimol2 (primOL2
                                                         x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           pprimol2
           x1)
    opL' :
      InvolutivePointedSemigroupTerm ->
      InvolutivePointedSemigroupTerm ->
      InvolutivePointedSemigroupTerm
    opL' x1 x2 = opL x1 x2
    eL' :
      InvolutivePointedSemigroupTerm
    eL' = eL
    primL' :
      InvolutivePointedSemigroupTerm ->
      InvolutivePointedSemigroupTerm
    primL' x1 = primL x1
    stageB :
      InvolutivePointedSemigroupTerm ->
      Staged
        InvolutivePointedSemigroupTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (eL) = Now eL
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    opCl' :
      (A : Set) ->
      ClInvolutivePointedSemigroupTerm
        A ->
      ClInvolutivePointedSemigroupTerm
        A ->
      ClInvolutivePointedSemigroupTerm
        A
    opCl' _ x1 x2 = opCl x1 x2
    eCl' :
      (A : Set) ->
      ClInvolutivePointedSemigroupTerm
        A
    eCl' _ = eCl
    primCl' :
      (A : Set) ->
      ClInvolutivePointedSemigroupTerm
        A ->
      ClInvolutivePointedSemigroupTerm
        A
    primCl' _ x1 = primCl x1
    stageCl :
      (A : Set) ->
      ClInvolutivePointedSemigroupTerm
        A ->
      Staged
        (ClInvolutivePointedSemigroupTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (eCl) = Now eCl
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    opOL' :
      (n : Nat) ->
      OpInvolutivePointedSemigroupTerm
        n ->
      OpInvolutivePointedSemigroupTerm
        n ->
      OpInvolutivePointedSemigroupTerm
        n
    opOL' _ x1 x2 = opOL x1 x2
    eOL' :
      (n : Nat) ->
      OpInvolutivePointedSemigroupTerm
        n
    eOL' _ = eOL
    primOL' :
      (n : Nat) ->
      OpInvolutivePointedSemigroupTerm
        n ->
      OpInvolutivePointedSemigroupTerm
        n
    primOL' _ x1 = primOL x1
    stageOp :
      (n : Nat) ->
      OpInvolutivePointedSemigroupTerm
        n ->
      Staged
        (OpInvolutivePointedSemigroupTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (eOL) = Now eOL
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpInvolutivePointedSemigroupTerm2
        n
        A ->
      OpInvolutivePointedSemigroupTerm2
        n
        A ->
      OpInvolutivePointedSemigroupTerm2
        n
        A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    eOL2' :
      (n : Nat) (A : Set) ->
      OpInvolutivePointedSemigroupTerm2
        n
        A
    eOL2' _ _ = eOL2
    primOL2' :
      (n : Nat) (A : Set) ->
      OpInvolutivePointedSemigroupTerm2
        n
        A ->
      OpInvolutivePointedSemigroupTerm2
        n
        A
    primOL2' _ _ x1 = primOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpInvolutivePointedSemigroupTerm2
        n
        A ->
      Staged
        (OpInvolutivePointedSemigroupTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    record InvolutivePointedSemigroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
        eT : Repr A
        primT : Repr A -> Repr A
  
  module InvolutiveRing where
    record InvolutiveRing
      (A : Set) : Set where
      constructor InvolutiveRingC
      field
        * : A -> A -> A
        + : A -> A -> A
        1 : A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        prim : A -> A
        fixes_prim_1 : prim 1 == 1
        involutive_prim :
          (x : A) -> prim (prim x) == x
        antidis_prim_+ :
          (x : A) (y : A) ->
          prim (+ x y) ==
            + (prim y) (prim x)
        antidis_prim_* :
          (x : A) (y : A) ->
          prim (* x y) ==
            * (prim y) (prim x)
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
    record InvolutiveRingSig
      (AS : Set) : Set where
      constructor InvolutiveRingSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        1S : AS
        primS : AS -> AS
        0S : AS
        negS : AS -> AS
    record InvolutiveRingProd
      (AP : Set) : Set where
      constructor InvolutiveRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        fixes_prim_1P : primP 1P == 1P
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
        antidis_prim_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (+P xP yP) ==
            +P (primP yP) (primP xP)
        antidis_prim_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (*P xP yP) ==
            *P (primP yP) (primP xP)
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
    record InvolutiveRingHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRing A1)
      (In2 : InvolutiveRing A2) :
      Set where
      constructor InvolutiveRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* In1 x1 x2) ==
            * In2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ In1 x1 x2) ==
            + In2 (hom x1) (hom x2)
        pres-1 : hom (1 In1) == 1 In2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-0 : hom (0 In1) == 0 In2
        pres-neg :
          (x1 : A1) ->
          hom (neg In1 x1) ==
            neg In2 (hom x1)
    record InvolutiveRingRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRing A1)
      (In2 : InvolutiveRing A2) :
      Set where
      constructor InvolutiveRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* In1 x1 x2)
            (* In2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ In1 x1 x2)
            (+ In2 y1 y2)
        interp-1 :
          interp (1 In1) (1 In2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-0 :
          interp (0 In1) (0 In2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg In1 x1) (neg In2 y1)
    data InvolutiveRingTerm
      : Set where
      *L :
        InvolutiveRingTerm ->
        InvolutiveRingTerm ->
        InvolutiveRingTerm
      +L :
        InvolutiveRingTerm ->
        InvolutiveRingTerm ->
        InvolutiveRingTerm
      1L : InvolutiveRingTerm
      primL :
        InvolutiveRingTerm ->
        InvolutiveRingTerm
      0L : InvolutiveRingTerm
      negL :
        InvolutiveRingTerm ->
        InvolutiveRingTerm
    data ClInvolutiveRingTerm
      (A : Set) : Set where
      sing :
        A -> ClInvolutiveRingTerm A
      *Cl :
        ClInvolutiveRingTerm A ->
        ClInvolutiveRingTerm A ->
        ClInvolutiveRingTerm A
      +Cl :
        ClInvolutiveRingTerm A ->
        ClInvolutiveRingTerm A ->
        ClInvolutiveRingTerm A
      1Cl : ClInvolutiveRingTerm A
      primCl :
        ClInvolutiveRingTerm A ->
        ClInvolutiveRingTerm A
      0Cl : ClInvolutiveRingTerm A
      negCl :
        ClInvolutiveRingTerm A ->
        ClInvolutiveRingTerm A
    data OpInvolutiveRingTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpInvolutiveRingTerm n
      *OL :
        OpInvolutiveRingTerm n ->
        OpInvolutiveRingTerm n ->
        OpInvolutiveRingTerm n
      +OL :
        OpInvolutiveRingTerm n ->
        OpInvolutiveRingTerm n ->
        OpInvolutiveRingTerm n
      1OL : OpInvolutiveRingTerm n
      primOL :
        OpInvolutiveRingTerm n ->
        OpInvolutiveRingTerm n
      0OL : OpInvolutiveRingTerm n
      negOL :
        OpInvolutiveRingTerm n ->
        OpInvolutiveRingTerm n
    data OpInvolutiveRingTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpInvolutiveRingTerm2 n A
      sing2 :
        A -> OpInvolutiveRingTerm2 n A
      *OL2 :
        OpInvolutiveRingTerm2 n A ->
        OpInvolutiveRingTerm2 n A ->
        OpInvolutiveRingTerm2 n A
      +OL2 :
        OpInvolutiveRingTerm2 n A ->
        OpInvolutiveRingTerm2 n A ->
        OpInvolutiveRingTerm2 n A
      1OL2 : OpInvolutiveRingTerm2 n A
      primOL2 :
        OpInvolutiveRingTerm2 n A ->
        OpInvolutiveRingTerm2 n A
      0OL2 : OpInvolutiveRingTerm2 n A
      negOL2 :
        OpInvolutiveRingTerm2 n A ->
        OpInvolutiveRingTerm2 n A
    simplifyB :
      InvolutiveRingTerm ->
      InvolutiveRingTerm
    simplifyB (+L
               (*L x y)
               (*L x z)) = *L x (+L y z)
    simplifyB (+L
               (*L y x)
               (*L z x)) = *L (+L y z) x
    simplifyB (primL (1L)) = 1L
    simplifyB (primL (primL x)) = x
    simplifyB (+L
               (primL y)
               (primL x)) = primL (+L x y)
    simplifyB (*L
               (primL y)
               (primL x)) = primL (*L x y)
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (+L x (negL x)) = 0L
    simplifyB (+L (negL x) x) = 0L
    simplifyB (*L (1L) x) = x
    simplifyB (*L x (1L)) = x
    simplifyB (*L (0L) x) = 0L
    simplifyB (*L x (0L)) = 0L
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (1L) = 1L
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyB (0L) = 0L
    simplifyB (negL x1) =
      negL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClInvolutiveRingTerm A ->
      ClInvolutiveRingTerm A
    simplifyCl _ (+Cl
                  (*Cl x y)
                  (*Cl x z)) = *Cl x (+Cl y z)
    simplifyCl _ (+Cl
                  (*Cl y x)
                  (*Cl z x)) = *Cl (+Cl y z) x
    simplifyCl _ (primCl (1Cl)) =
      1Cl
    simplifyCl _ (primCl
                  (primCl x)) = x
    simplifyCl _ (+Cl
                  (primCl y)
                  (primCl x)) = primCl (+Cl x y)
    simplifyCl _ (*Cl
                  (primCl y)
                  (primCl x)) = primCl (*Cl x y)
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (+Cl x (negCl x)) =
      0Cl
    simplifyCl _ (+Cl (negCl x) x) =
      0Cl
    simplifyCl _ (*Cl (1Cl) x) = x
    simplifyCl _ (*Cl x (1Cl)) = x
    simplifyCl _ (*Cl (0Cl) x) = 0Cl
    simplifyCl _ (*Cl x (0Cl)) = 0Cl
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (negCl x1) =
      negCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpInvolutiveRingTerm n ->
      OpInvolutiveRingTerm n
    simplifyOp _ (+OL
                  (*OL x y)
                  (*OL x z)) = *OL x (+OL y z)
    simplifyOp _ (+OL
                  (*OL y x)
                  (*OL z x)) = *OL (+OL y z) x
    simplifyOp _ (primOL (1OL)) =
      1OL
    simplifyOp _ (primOL
                  (primOL x)) = x
    simplifyOp _ (+OL
                  (primOL y)
                  (primOL x)) = primOL (+OL x y)
    simplifyOp _ (*OL
                  (primOL y)
                  (primOL x)) = primOL (*OL x y)
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (+OL x (negOL x)) =
      0OL
    simplifyOp _ (+OL (negOL x) x) =
      0OL
    simplifyOp _ (*OL (1OL) x) = x
    simplifyOp _ (*OL x (1OL)) = x
    simplifyOp _ (*OL (0OL) x) = 0OL
    simplifyOp _ (*OL x (0OL)) = 0OL
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (negOL x1) =
      negOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpInvolutiveRingTerm2 n A ->
      OpInvolutiveRingTerm2 n A
    simplifyOpE _ _ (+OL2
                     (*OL2 x y)
                     (*OL2 x z)) = *OL2 x (+OL2 y z)
    simplifyOpE _ _ (+OL2
                     (*OL2 y x)
                     (*OL2 z x)) = *OL2 (+OL2 y z) x
    simplifyOpE _ _ (primOL2
                     (1OL2)) = 1OL2
    simplifyOpE _ _ (primOL2
                     (primOL2 x)) = x
    simplifyOpE _ _ (+OL2
                     (primOL2 y)
                     (primOL2 x)) =
      primOL2 (+OL2 x y)
    simplifyOpE _ _ (*OL2
                     (primOL2 y)
                     (primOL2 x)) =
      primOL2 (*OL2 x y)
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (+OL2
                     x
                     (negOL2 x)) = 0OL2
    simplifyOpE _ _ (+OL2
                     (negOL2 x)
                     x) = 0OL2
    simplifyOpE _ _ (*OL2
                     (1OL2)
                     x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (1OL2)) = x
    simplifyOpE _ _ (*OL2
                     (0OL2)
                     x) = 0OL2
    simplifyOpE _ _ (*OL2
                     x
                     (0OL2)) = 0OL2
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (negOL2 x1) =
      negOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      InvolutiveRing A ->
      InvolutiveRingTerm -> A
    evalB _ In (*L x1 x2) =
      * In (evalB _ In x1)
        (evalB _ In x2)
    evalB _ In (+L x1 x2) =
      + In (evalB _ In x1)
        (evalB _ In x2)
    evalB _ In (1L) = 1 In
    evalB _ In (primL x1) =
      prim In (evalB _ In x1)
    evalB _ In (0L) = 0 In
    evalB _ In (negL x1) =
      neg In (evalB _ In x1)
    evalCl :
      (A : Set) ->
      InvolutiveRing A ->
      ClInvolutiveRingTerm A -> A
    evalCl _ In (sing x1) = x1
    evalCl _ In (*Cl x1 x2) =
      * In (evalCl _ In x1)
        (evalCl _ In x2)
    evalCl _ In (+Cl x1 x2) =
      + In (evalCl _ In x1)
        (evalCl _ In x2)
    evalCl _ In (1Cl) = 1 In
    evalCl _ In (primCl x1) =
      prim In (evalCl _ In x1)
    evalCl _ In (0Cl) = 0 In
    evalCl _ In (negCl x1) =
      neg In (evalCl _ In x1)
    evalOp :
      (A : Set) (n : Nat) ->
      InvolutiveRing A ->
      Vec A n ->
      OpInvolutiveRingTerm n -> A
    evalOp _ n In vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n In vars (*OL x1 x2) =
      * In (evalOp _ n In vars x1)
        (evalOp _ n In vars x2)
    evalOp _ n In vars (+OL x1 x2) =
      + In (evalOp _ n In vars x1)
        (evalOp _ n In vars x2)
    evalOp _ n In vars (1OL) = 1 In
    evalOp _ n In vars (primOL x1) =
      prim In (evalOp _ n In vars x1)
    evalOp _ n In vars (0OL) = 0 In
    evalOp _ n In vars (negOL x1) =
      neg In (evalOp _ n In vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      InvolutiveRing A ->
      Vec A n ->
      OpInvolutiveRingTerm2 n A -> A
    evalOpE _ n In vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n In vars (sing2 x1) =
      x1
    evalOpE _ n In vars (*OL2
                         x1
                         x2) =
      * In (evalOpE _ n In vars x1)
        (evalOpE _ n In vars x2)
    evalOpE _ n In vars (+OL2
                         x1
                         x2) =
      + In (evalOpE _ n In vars x1)
        (evalOpE _ n In vars x2)
    evalOpE _ n In vars (1OL2) =
      1 In
    evalOpE _ n In vars (primOL2
                         x1) =
      prim In (evalOpE _ n In vars x1)
    evalOpE _ n In vars (0OL2) =
      0 In
    evalOpE _ n In vars (negOL2
                         x1) =
      neg In (evalOpE _ n In vars x1)
    inductionB :
      (P : InvolutiveRingTerm ->
           Set) ->
      ((x1 : InvolutiveRingTerm)
       (x2 : InvolutiveRingTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : InvolutiveRingTerm)
       (x2 : InvolutiveRingTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      P 1L ->
      ((x1 : InvolutiveRingTerm) ->
       P x1 -> P (primL x1)) ->
      P 0L ->
      ((x1 : InvolutiveRingTerm) ->
       P x1 -> P (negL x1)) ->
      (x : InvolutiveRingTerm) -> P x
    inductionB p p*l p+l p1l ppriml p0l pnegl (*L
                                               x1
                                               x2) =
      p*l _ _
        (inductionB p p*l p+l p1l ppriml
           p0l
           pnegl
           x1)
        (inductionB p p*l p+l p1l ppriml
           p0l
           pnegl
           x2)
    inductionB p p*l p+l p1l ppriml p0l pnegl (+L
                                               x1
                                               x2) =
      p+l _ _
        (inductionB p p*l p+l p1l ppriml
           p0l
           pnegl
           x1)
        (inductionB p p*l p+l p1l ppriml
           p0l
           pnegl
           x2)
    inductionB p p*l p+l p1l ppriml p0l pnegl (1L) =
      p1l
    inductionB p p*l p+l p1l ppriml p0l pnegl (primL
                                               x1) =
      ppriml _
        (inductionB p p*l p+l p1l ppriml
           p0l
           pnegl
           x1)
    inductionB p p*l p+l p1l ppriml p0l pnegl (0L) =
      p0l
    inductionB p p*l p+l p1l ppriml p0l pnegl (negL
                                               x1) =
      pnegl _
        (inductionB p p*l p+l p1l ppriml
           p0l
           pnegl
           x1)
    inductionCl :
      (A : Set)
      (P : ClInvolutiveRingTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClInvolutiveRingTerm A)
       (x2 : ClInvolutiveRingTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClInvolutiveRingTerm A)
       (x2 : ClInvolutiveRingTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      P 1Cl ->
      ((x1 : ClInvolutiveRingTerm
          A) -> P x1 -> P (primCl x1)) ->
      P 0Cl ->
      ((x1 : ClInvolutiveRingTerm
          A) -> P x1 -> P (negCl x1)) ->
      (x : ClInvolutiveRingTerm A) ->
      P x
    inductionCl _ p psing p*cl p+cl p1cl pprimcl p0cl pnegcl (sing
                                                              x1) = psing x1
    inductionCl _ p psing p*cl p+cl p1cl pprimcl p0cl pnegcl (*Cl
                                                              x1
                                                              x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           p1cl
           pprimcl
           p0cl
           pnegcl
           x1)
        (inductionCl _ p psing p*cl p+cl
           p1cl
           pprimcl
           p0cl
           pnegcl
           x2)
    inductionCl _ p psing p*cl p+cl p1cl pprimcl p0cl pnegcl (+Cl
                                                              x1
                                                              x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           p1cl
           pprimcl
           p0cl
           pnegcl
           x1)
        (inductionCl _ p psing p*cl p+cl
           p1cl
           pprimcl
           p0cl
           pnegcl
           x2)
    inductionCl _ p psing p*cl p+cl p1cl pprimcl p0cl pnegcl (1Cl) =
      p1cl
    inductionCl _ p psing p*cl p+cl p1cl pprimcl p0cl pnegcl (primCl
                                                              x1) =
      pprimcl _
        (inductionCl _ p psing p*cl p+cl
           p1cl
           pprimcl
           p0cl
           pnegcl
           x1)
    inductionCl _ p psing p*cl p+cl p1cl pprimcl p0cl pnegcl (0Cl) =
      p0cl
    inductionCl _ p psing p*cl p+cl p1cl pprimcl p0cl pnegcl (negCl
                                                              x1) =
      pnegcl _
        (inductionCl _ p psing p*cl p+cl
           p1cl
           pprimcl
           p0cl
           pnegcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpInvolutiveRingTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpInvolutiveRingTerm n)
       (x2 : OpInvolutiveRingTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpInvolutiveRingTerm n)
       (x2 : OpInvolutiveRingTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      P 1OL ->
      ((x1 : OpInvolutiveRingTerm
          n) -> P x1 -> P (primOL x1)) ->
      P 0OL ->
      ((x1 : OpInvolutiveRingTerm
          n) -> P x1 -> P (negOL x1)) ->
      (x : OpInvolutiveRingTerm n) ->
      P x
    inductionOp _ p pv p*ol p+ol p1ol pprimol p0ol pnegol (v
                                                           x1) = pv x1
    inductionOp _ p pv p*ol p+ol p1ol pprimol p0ol pnegol (*OL
                                                           x1
                                                           x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           p1ol
           pprimol
           p0ol
           pnegol
           x1)
        (inductionOp _ p pv p*ol p+ol
           p1ol
           pprimol
           p0ol
           pnegol
           x2)
    inductionOp _ p pv p*ol p+ol p1ol pprimol p0ol pnegol (+OL
                                                           x1
                                                           x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           p1ol
           pprimol
           p0ol
           pnegol
           x1)
        (inductionOp _ p pv p*ol p+ol
           p1ol
           pprimol
           p0ol
           pnegol
           x2)
    inductionOp _ p pv p*ol p+ol p1ol pprimol p0ol pnegol (1OL) =
      p1ol
    inductionOp _ p pv p*ol p+ol p1ol pprimol p0ol pnegol (primOL
                                                           x1) =
      pprimol _
        (inductionOp _ p pv p*ol p+ol
           p1ol
           pprimol
           p0ol
           pnegol
           x1)
    inductionOp _ p pv p*ol p+ol p1ol pprimol p0ol pnegol (0OL) =
      p0ol
    inductionOp _ p pv p*ol p+ol p1ol pprimol p0ol pnegol (negOL
                                                           x1) =
      pnegol _
        (inductionOp _ p pv p*ol p+ol
           p1ol
           pprimol
           p0ol
           pnegol
           x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpInvolutiveRingTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpInvolutiveRingTerm2 n
          A)
       (x2 : OpInvolutiveRingTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpInvolutiveRingTerm2 n
          A)
       (x2 : OpInvolutiveRingTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      P 1OL2 ->
      ((x1 : OpInvolutiveRingTerm2 n
          A) -> P x1 -> P (primOL2 x1)) ->
      P 0OL2 ->
      ((x1 : OpInvolutiveRingTerm2 n
          A) -> P x1 -> P (negOL2 x1)) ->
      (x : OpInvolutiveRingTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p1ol2 pprimol2 p0ol2 pnegol2 (v2
                                                                            x1) =
      pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p1ol2 pprimol2 p0ol2 pnegol2 (sing2
                                                                            x1) =
      psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p1ol2 pprimol2 p0ol2 pnegol2 (*OL2
                                                                            x1
                                                                            x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p1ol2
           pprimol2
           p0ol2
           pnegol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p1ol2
           pprimol2
           p0ol2
           pnegol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p1ol2 pprimol2 p0ol2 pnegol2 (+OL2
                                                                            x1
                                                                            x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p1ol2
           pprimol2
           p0ol2
           pnegol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p1ol2
           pprimol2
           p0ol2
           pnegol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p1ol2 pprimol2 p0ol2 pnegol2 (1OL2) =
      p1ol2
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p1ol2 pprimol2 p0ol2 pnegol2 (primOL2
                                                                            x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p1ol2
           pprimol2
           p0ol2
           pnegol2
           x1)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p1ol2 pprimol2 p0ol2 pnegol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p1ol2 pprimol2 p0ol2 pnegol2 (negOL2
                                                                            x1) =
      pnegol2 _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p1ol2
           pprimol2
           p0ol2
           pnegol2
           x1)
    *L' :
      InvolutiveRingTerm ->
      InvolutiveRingTerm ->
      InvolutiveRingTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      InvolutiveRingTerm ->
      InvolutiveRingTerm ->
      InvolutiveRingTerm
    +L' x1 x2 = +L x1 x2
    1L' : InvolutiveRingTerm
    1L' = 1L
    primL' :
      InvolutiveRingTerm ->
      InvolutiveRingTerm
    primL' x1 = primL x1
    0L' : InvolutiveRingTerm
    0L' = 0L
    negL' :
      InvolutiveRingTerm ->
      InvolutiveRingTerm
    negL' x1 = negL x1
    stageB :
      InvolutiveRingTerm ->
      Staged InvolutiveRingTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (1L) = Now 1L
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    stageB (0L) = Now 0L
    stageB (negL x1) =
      stage1 _ _ negL'
        (codeLift1 _ _ negL')
        (stageB x1)
    *Cl' :
      (A : Set) ->
      ClInvolutiveRingTerm A ->
      ClInvolutiveRingTerm A ->
      ClInvolutiveRingTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClInvolutiveRingTerm A ->
      ClInvolutiveRingTerm A ->
      ClInvolutiveRingTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    1Cl' :
      (A : Set) ->
      ClInvolutiveRingTerm A
    1Cl' _ = 1Cl
    primCl' :
      (A : Set) ->
      ClInvolutiveRingTerm A ->
      ClInvolutiveRingTerm A
    primCl' _ x1 = primCl x1
    0Cl' :
      (A : Set) ->
      ClInvolutiveRingTerm A
    0Cl' _ = 0Cl
    negCl' :
      (A : Set) ->
      ClInvolutiveRingTerm A ->
      ClInvolutiveRingTerm A
    negCl' _ x1 = negCl x1
    stageCl :
      (A : Set) ->
      ClInvolutiveRingTerm A ->
      Staged (ClInvolutiveRingTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (1Cl) = Now 1Cl
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (negCl x1) =
      stage1 _ _ (negCl' _)
        (codeLift1 _ _ (negCl' _))
        (stageCl _ x1)
    *OL' :
      (n : Nat) ->
      OpInvolutiveRingTerm n ->
      OpInvolutiveRingTerm n ->
      OpInvolutiveRingTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpInvolutiveRingTerm n ->
      OpInvolutiveRingTerm n ->
      OpInvolutiveRingTerm n
    +OL' _ x1 x2 = +OL x1 x2
    1OL' :
      (n : Nat) ->
      OpInvolutiveRingTerm n
    1OL' _ = 1OL
    primOL' :
      (n : Nat) ->
      OpInvolutiveRingTerm n ->
      OpInvolutiveRingTerm n
    primOL' _ x1 = primOL x1
    0OL' :
      (n : Nat) ->
      OpInvolutiveRingTerm n
    0OL' _ = 0OL
    negOL' :
      (n : Nat) ->
      OpInvolutiveRingTerm n ->
      OpInvolutiveRingTerm n
    negOL' _ x1 = negOL x1
    stageOp :
      (n : Nat) ->
      OpInvolutiveRingTerm n ->
      Staged (OpInvolutiveRingTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (1OL) = Now 1OL
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    stageOp _ (0OL) = Now 0OL
    stageOp _ (negOL x1) =
      stage1 _ _ (negOL' _)
        (codeLift1 _ _ (negOL' _))
        (stageOp _ x1)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveRingTerm2 n A ->
      OpInvolutiveRingTerm2 n A ->
      OpInvolutiveRingTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveRingTerm2 n A ->
      OpInvolutiveRingTerm2 n A ->
      OpInvolutiveRingTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    1OL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveRingTerm2 n A
    1OL2' _ _ = 1OL2
    primOL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveRingTerm2 n A ->
      OpInvolutiveRingTerm2 n A
    primOL2' _ _ x1 = primOL2 x1
    0OL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveRingTerm2 n A
    0OL2' _ _ = 0OL2
    negOL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveRingTerm2 n A ->
      OpInvolutiveRingTerm2 n A
    negOL2' _ _ x1 = negOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpInvolutiveRingTerm2 n A ->
      Staged
        (OpInvolutiveRingTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (1OL2) = Now 1OL2
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (negOL2 x1) =
      stage1 _ _ (negOL2' _ _)
        (codeLift1 _ _ (negOL2' _ _))
        (stageOpE _ _ x1)
    record InvolutiveRingTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
        1T : Repr A
        primT : Repr A -> Repr A
        0T : Repr A
        negT : Repr A -> Repr A
  
  module InvolutiveRingoid where
    record InvolutiveRingoid
      (A : Set) : Set where
      constructor InvolutiveRingoidC
      field
        prim : A -> A
        1 : A
        fixes_prim_1 : prim 1 == 1
        involutive_prim :
          (x : A) -> prim (prim x) == x
        * : A -> A -> A
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        antidis_prim_+ :
          (x : A) (y : A) ->
          prim (+ x y) ==
            + (prim y) (prim x)
        antidis_prim_* :
          (x : A) (y : A) ->
          prim (* x y) ==
            * (prim y) (prim x)
    record InvolutiveRingoidSig
      (AS : Set) : Set where
      constructor InvolutiveRingoidSigSigC
      field
        primS : AS -> AS
        1S : AS
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record InvolutiveRingoidProd
      (AP : Set) : Set where
      constructor InvolutiveRingoidProdC
      field
        primP : Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        fixes_prim_1P : primP 1P == 1P
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        antidis_prim_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (+P xP yP) ==
            +P (primP yP) (primP xP)
        antidis_prim_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (*P xP yP) ==
            *P (primP yP) (primP xP)
    record InvolutiveRingoidHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRingoid A1)
      (In2 : InvolutiveRingoid A2) :
      Set where
      constructor InvolutiveRingoidHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-1 : hom (1 In1) == 1 In2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* In1 x1 x2) ==
            * In2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ In1 x1 x2) ==
            + In2 (hom x1) (hom x2)
    record InvolutiveRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRingoid A1)
      (In2 : InvolutiveRingoid A2) :
      Set where
      constructor InvolutiveRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-1 :
          interp (1 In1) (1 In2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* In1 x1 x2)
            (* In2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ In1 x1 x2)
            (+ In2 y1 y2)
    data InvolutiveRingoidTerm
      : Set where
      primL :
        InvolutiveRingoidTerm ->
        InvolutiveRingoidTerm
      1L : InvolutiveRingoidTerm
      *L :
        InvolutiveRingoidTerm ->
        InvolutiveRingoidTerm ->
        InvolutiveRingoidTerm
      +L :
        InvolutiveRingoidTerm ->
        InvolutiveRingoidTerm ->
        InvolutiveRingoidTerm
    data ClInvolutiveRingoidTerm
      (A : Set) : Set where
      sing :
        A -> ClInvolutiveRingoidTerm A
      primCl :
        ClInvolutiveRingoidTerm A ->
        ClInvolutiveRingoidTerm A
      1Cl : ClInvolutiveRingoidTerm A
      *Cl :
        ClInvolutiveRingoidTerm A ->
        ClInvolutiveRingoidTerm A ->
        ClInvolutiveRingoidTerm A
      +Cl :
        ClInvolutiveRingoidTerm A ->
        ClInvolutiveRingoidTerm A ->
        ClInvolutiveRingoidTerm A
    data OpInvolutiveRingoidTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpInvolutiveRingoidTerm n
      primOL :
        OpInvolutiveRingoidTerm n ->
        OpInvolutiveRingoidTerm n
      1OL : OpInvolutiveRingoidTerm n
      *OL :
        OpInvolutiveRingoidTerm n ->
        OpInvolutiveRingoidTerm n ->
        OpInvolutiveRingoidTerm n
      +OL :
        OpInvolutiveRingoidTerm n ->
        OpInvolutiveRingoidTerm n ->
        OpInvolutiveRingoidTerm n
    data OpInvolutiveRingoidTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpInvolutiveRingoidTerm2 n A
      sing2 :
        A ->
        OpInvolutiveRingoidTerm2 n A
      primOL2 :
        OpInvolutiveRingoidTerm2 n A ->
        OpInvolutiveRingoidTerm2 n A
      1OL2 :
        OpInvolutiveRingoidTerm2 n A
      *OL2 :
        OpInvolutiveRingoidTerm2 n A ->
        OpInvolutiveRingoidTerm2 n A ->
        OpInvolutiveRingoidTerm2 n A
      +OL2 :
        OpInvolutiveRingoidTerm2 n A ->
        OpInvolutiveRingoidTerm2 n A ->
        OpInvolutiveRingoidTerm2 n A
    simplifyB :
      InvolutiveRingoidTerm ->
      InvolutiveRingoidTerm
    simplifyB (primL (1L)) = 1L
    simplifyB (primL (primL x)) = x
    simplifyB (+L
               (*L x y)
               (*L x z)) = *L x (+L y z)
    simplifyB (+L
               (*L y x)
               (*L z x)) = *L (+L y z) x
    simplifyB (+L
               (primL y)
               (primL x)) = primL (+L x y)
    simplifyB (*L
               (primL y)
               (primL x)) = primL (*L x y)
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyB (1L) = 1L
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClInvolutiveRingoidTerm A ->
      ClInvolutiveRingoidTerm A
    simplifyCl _ (primCl (1Cl)) =
      1Cl
    simplifyCl _ (primCl
                  (primCl x)) = x
    simplifyCl _ (+Cl
                  (*Cl x y)
                  (*Cl x z)) = *Cl x (+Cl y z)
    simplifyCl _ (+Cl
                  (*Cl y x)
                  (*Cl z x)) = *Cl (+Cl y z) x
    simplifyCl _ (+Cl
                  (primCl y)
                  (primCl x)) = primCl (+Cl x y)
    simplifyCl _ (*Cl
                  (primCl y)
                  (primCl x)) = primCl (*Cl x y)
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpInvolutiveRingoidTerm n ->
      OpInvolutiveRingoidTerm n
    simplifyOp _ (primOL (1OL)) =
      1OL
    simplifyOp _ (primOL
                  (primOL x)) = x
    simplifyOp _ (+OL
                  (*OL x y)
                  (*OL x z)) = *OL x (+OL y z)
    simplifyOp _ (+OL
                  (*OL y x)
                  (*OL z x)) = *OL (+OL y z) x
    simplifyOp _ (+OL
                  (primOL y)
                  (primOL x)) = primOL (+OL x y)
    simplifyOp _ (*OL
                  (primOL y)
                  (primOL x)) = primOL (*OL x y)
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpInvolutiveRingoidTerm2 n A ->
      OpInvolutiveRingoidTerm2 n A
    simplifyOpE _ _ (primOL2
                     (1OL2)) = 1OL2
    simplifyOpE _ _ (primOL2
                     (primOL2 x)) = x
    simplifyOpE _ _ (+OL2
                     (*OL2 x y)
                     (*OL2 x z)) = *OL2 x (+OL2 y z)
    simplifyOpE _ _ (+OL2
                     (*OL2 y x)
                     (*OL2 z x)) = *OL2 (+OL2 y z) x
    simplifyOpE _ _ (+OL2
                     (primOL2 y)
                     (primOL2 x)) =
      primOL2 (+OL2 x y)
    simplifyOpE _ _ (*OL2
                     (primOL2 y)
                     (primOL2 x)) =
      primOL2 (*OL2 x y)
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      InvolutiveRingoid A ->
      InvolutiveRingoidTerm -> A
    evalB _ In (primL x1) =
      prim In (evalB _ In x1)
    evalB _ In (1L) = 1 In
    evalB _ In (*L x1 x2) =
      * In (evalB _ In x1)
        (evalB _ In x2)
    evalB _ In (+L x1 x2) =
      + In (evalB _ In x1)
        (evalB _ In x2)
    evalCl :
      (A : Set) ->
      InvolutiveRingoid A ->
      ClInvolutiveRingoidTerm A -> A
    evalCl _ In (sing x1) = x1
    evalCl _ In (primCl x1) =
      prim In (evalCl _ In x1)
    evalCl _ In (1Cl) = 1 In
    evalCl _ In (*Cl x1 x2) =
      * In (evalCl _ In x1)
        (evalCl _ In x2)
    evalCl _ In (+Cl x1 x2) =
      + In (evalCl _ In x1)
        (evalCl _ In x2)
    evalOp :
      (A : Set) (n : Nat) ->
      InvolutiveRingoid A ->
      Vec A n ->
      OpInvolutiveRingoidTerm n -> A
    evalOp _ n In vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n In vars (primOL x1) =
      prim In (evalOp _ n In vars x1)
    evalOp _ n In vars (1OL) = 1 In
    evalOp _ n In vars (*OL x1 x2) =
      * In (evalOp _ n In vars x1)
        (evalOp _ n In vars x2)
    evalOp _ n In vars (+OL x1 x2) =
      + In (evalOp _ n In vars x1)
        (evalOp _ n In vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      InvolutiveRingoid A ->
      Vec A n ->
      OpInvolutiveRingoidTerm2 n A ->
      A
    evalOpE _ n In vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n In vars (sing2 x1) =
      x1
    evalOpE _ n In vars (primOL2
                         x1) =
      prim In (evalOpE _ n In vars x1)
    evalOpE _ n In vars (1OL2) =
      1 In
    evalOpE _ n In vars (*OL2
                         x1
                         x2) =
      * In (evalOpE _ n In vars x1)
        (evalOpE _ n In vars x2)
    evalOpE _ n In vars (+OL2
                         x1
                         x2) =
      + In (evalOpE _ n In vars x1)
        (evalOpE _ n In vars x2)
    inductionB :
      (P : InvolutiveRingoidTerm ->
           Set) ->
      ((x1 : InvolutiveRingoidTerm) ->
       P x1 -> P (primL x1)) ->
      P 1L ->
      ((x1 : InvolutiveRingoidTerm)
       (x2 : InvolutiveRingoidTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : InvolutiveRingoidTerm)
       (x2 : InvolutiveRingoidTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : InvolutiveRingoidTerm) ->
      P x
    inductionB p ppriml p1l p*l p+l (primL
                                     x1) =
      ppriml _
        (inductionB p ppriml p1l p*l p+l
           x1)
    inductionB p ppriml p1l p*l p+l (1L) =
      p1l
    inductionB p ppriml p1l p*l p+l (*L
                                     x1
                                     x2) =
      p*l _ _
        (inductionB p ppriml p1l p*l p+l
           x1)
        (inductionB p ppriml p1l p*l p+l
           x2)
    inductionB p ppriml p1l p*l p+l (+L
                                     x1
                                     x2) =
      p+l _ _
        (inductionB p ppriml p1l p*l p+l
           x1)
        (inductionB p ppriml p1l p*l p+l
           x2)
    inductionCl :
      (A : Set)
      (P : ClInvolutiveRingoidTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClInvolutiveRingoidTerm
          A) -> P x1 -> P (primCl x1)) ->
      P 1Cl ->
      ((x1 : ClInvolutiveRingoidTerm
          A)
       (x2 : ClInvolutiveRingoidTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClInvolutiveRingoidTerm
          A)
       (x2 : ClInvolutiveRingoidTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClInvolutiveRingoidTerm
         A) -> P x
    inductionCl _ p psing pprimcl p1cl p*cl p+cl (sing
                                                  x1) = psing x1
    inductionCl _ p psing pprimcl p1cl p*cl p+cl (primCl
                                                  x1) =
      pprimcl _
        (inductionCl _ p psing pprimcl
           p1cl
           p*cl
           p+cl
           x1)
    inductionCl _ p psing pprimcl p1cl p*cl p+cl (1Cl) =
      p1cl
    inductionCl _ p psing pprimcl p1cl p*cl p+cl (*Cl
                                                  x1
                                                  x2) =
      p*cl _ _
        (inductionCl _ p psing pprimcl
           p1cl
           p*cl
           p+cl
           x1)
        (inductionCl _ p psing pprimcl
           p1cl
           p*cl
           p+cl
           x2)
    inductionCl _ p psing pprimcl p1cl p*cl p+cl (+Cl
                                                  x1
                                                  x2) =
      p+cl _ _
        (inductionCl _ p psing pprimcl
           p1cl
           p*cl
           p+cl
           x1)
        (inductionCl _ p psing pprimcl
           p1cl
           p*cl
           p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpInvolutiveRingoidTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpInvolutiveRingoidTerm
          n) -> P x1 -> P (primOL x1)) ->
      P 1OL ->
      ((x1 : OpInvolutiveRingoidTerm
          n)
       (x2 : OpInvolutiveRingoidTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpInvolutiveRingoidTerm
          n)
       (x2 : OpInvolutiveRingoidTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpInvolutiveRingoidTerm
         n) -> P x
    inductionOp _ p pv pprimol p1ol p*ol p+ol (v
                                               x1) = pv x1
    inductionOp _ p pv pprimol p1ol p*ol p+ol (primOL
                                               x1) =
      pprimol _
        (inductionOp _ p pv pprimol p1ol
           p*ol
           p+ol
           x1)
    inductionOp _ p pv pprimol p1ol p*ol p+ol (1OL) =
      p1ol
    inductionOp _ p pv pprimol p1ol p*ol p+ol (*OL
                                               x1
                                               x2) =
      p*ol _ _
        (inductionOp _ p pv pprimol p1ol
           p*ol
           p+ol
           x1)
        (inductionOp _ p pv pprimol p1ol
           p*ol
           p+ol
           x2)
    inductionOp _ p pv pprimol p1ol p*ol p+ol (+OL
                                               x1
                                               x2) =
      p+ol _ _
        (inductionOp _ p pv pprimol p1ol
           p*ol
           p+ol
           x1)
        (inductionOp _ p pv pprimol p1ol
           p*ol
           p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpInvolutiveRingoidTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpInvolutiveRingoidTerm2
          n
          A) -> P x1 -> P (primOL2 x1)) ->
      P 1OL2 ->
      ((x1 : OpInvolutiveRingoidTerm2
          n
          A)
       (x2 : OpInvolutiveRingoidTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpInvolutiveRingoidTerm2
          n
          A)
       (x2 : OpInvolutiveRingoidTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpInvolutiveRingoidTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 pprimol2 p1ol2 p*ol2 p+ol2 (v2
                                                              x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 p1ol2 p*ol2 p+ol2 (sing2
                                                              x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 p1ol2 p*ol2 p+ol2 (primOL2
                                                              x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           p1ol2
           p*ol2
           p+ol2
           x1)
    inductionOpE _ _ p pv2 psing2 pprimol2 p1ol2 p*ol2 p+ol2 (1OL2) =
      p1ol2
    inductionOpE _ _ p pv2 psing2 pprimol2 p1ol2 p*ol2 p+ol2 (*OL2
                                                              x1
                                                              x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           p1ol2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           p1ol2
           p*ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 pprimol2 p1ol2 p*ol2 p+ol2 (+OL2
                                                              x1
                                                              x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           p1ol2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           p1ol2
           p*ol2
           p+ol2
           x2)
    primL' :
      InvolutiveRingoidTerm ->
      InvolutiveRingoidTerm
    primL' x1 = primL x1
    1L' : InvolutiveRingoidTerm
    1L' = 1L
    *L' :
      InvolutiveRingoidTerm ->
      InvolutiveRingoidTerm ->
      InvolutiveRingoidTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      InvolutiveRingoidTerm ->
      InvolutiveRingoidTerm ->
      InvolutiveRingoidTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      InvolutiveRingoidTerm ->
      Staged InvolutiveRingoidTerm
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    stageB (1L) = Now 1L
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    primCl' :
      (A : Set) ->
      ClInvolutiveRingoidTerm A ->
      ClInvolutiveRingoidTerm A
    primCl' _ x1 = primCl x1
    1Cl' :
      (A : Set) ->
      ClInvolutiveRingoidTerm A
    1Cl' _ = 1Cl
    *Cl' :
      (A : Set) ->
      ClInvolutiveRingoidTerm A ->
      ClInvolutiveRingoidTerm A ->
      ClInvolutiveRingoidTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClInvolutiveRingoidTerm A ->
      ClInvolutiveRingoidTerm A ->
      ClInvolutiveRingoidTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClInvolutiveRingoidTerm A ->
      Staged
        (ClInvolutiveRingoidTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    stageCl _ (1Cl) = Now 1Cl
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    primOL' :
      (n : Nat) ->
      OpInvolutiveRingoidTerm n ->
      OpInvolutiveRingoidTerm n
    primOL' _ x1 = primOL x1
    1OL' :
      (n : Nat) ->
      OpInvolutiveRingoidTerm n
    1OL' _ = 1OL
    *OL' :
      (n : Nat) ->
      OpInvolutiveRingoidTerm n ->
      OpInvolutiveRingoidTerm n ->
      OpInvolutiveRingoidTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpInvolutiveRingoidTerm n ->
      OpInvolutiveRingoidTerm n ->
      OpInvolutiveRingoidTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpInvolutiveRingoidTerm n ->
      Staged
        (OpInvolutiveRingoidTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    stageOp _ (1OL) = Now 1OL
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    primOL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveRingoidTerm2 n A ->
      OpInvolutiveRingoidTerm2 n A
    primOL2' _ _ x1 = primOL2 x1
    1OL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveRingoidTerm2 n A
    1OL2' _ _ = 1OL2
    *OL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveRingoidTerm2 n A ->
      OpInvolutiveRingoidTerm2 n A ->
      OpInvolutiveRingoidTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveRingoidTerm2 n A ->
      OpInvolutiveRingoidTerm2 n A ->
      OpInvolutiveRingoidTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpInvolutiveRingoidTerm2 n A ->
      Staged
        (OpInvolutiveRingoidTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (1OL2) = Now 1OL2
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record InvolutiveRingoidTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        primT : Repr A -> Repr A
        1T : Repr A
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module InvolutiveRingoidSig where
    record InvolutiveRingoidSig
      (A : Set) : Set where
      constructor InvolutiveRingoidSigC
      field
        prim : A -> A
        * : A -> A -> A
        + : A -> A -> A
    record InvolutiveRingoidSigSig
      (AS : Set) : Set where
      constructor InvolutiveRingoidSigSigSigC
      field
        primS : AS -> AS
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record InvolutiveRingoidSigProd
      (AP : Set) : Set where
      constructor InvolutiveRingoidSigProdC
      field
        primP : Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record InvolutiveRingoidSigHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRingoidSig A1)
      (In2 : InvolutiveRingoidSig
         A2) : Set where
      constructor InvolutiveRingoidSigHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* In1 x1 x2) ==
            * In2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ In1 x1 x2) ==
            + In2 (hom x1) (hom x2)
    record InvolutiveRingoidSigRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRingoidSig A1)
      (In2 : InvolutiveRingoidSig
         A2) : Set where
      constructor InvolutiveRingoidSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* In1 x1 x2)
            (* In2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ In1 x1 x2)
            (+ In2 y1 y2)
    data InvolutiveRingoidSigTerm
      : Set where
      primL :
        InvolutiveRingoidSigTerm ->
        InvolutiveRingoidSigTerm
      *L :
        InvolutiveRingoidSigTerm ->
        InvolutiveRingoidSigTerm ->
        InvolutiveRingoidSigTerm
      +L :
        InvolutiveRingoidSigTerm ->
        InvolutiveRingoidSigTerm ->
        InvolutiveRingoidSigTerm
    data ClInvolutiveRingoidSigTerm
      (A : Set) : Set where
      sing :
        A ->
        ClInvolutiveRingoidSigTerm A
      primCl :
        ClInvolutiveRingoidSigTerm A ->
        ClInvolutiveRingoidSigTerm A
      *Cl :
        ClInvolutiveRingoidSigTerm A ->
        ClInvolutiveRingoidSigTerm A ->
        ClInvolutiveRingoidSigTerm A
      +Cl :
        ClInvolutiveRingoidSigTerm A ->
        ClInvolutiveRingoidSigTerm A ->
        ClInvolutiveRingoidSigTerm A
    data OpInvolutiveRingoidSigTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpInvolutiveRingoidSigTerm n
      primOL :
        OpInvolutiveRingoidSigTerm n ->
        OpInvolutiveRingoidSigTerm n
      *OL :
        OpInvolutiveRingoidSigTerm n ->
        OpInvolutiveRingoidSigTerm n ->
        OpInvolutiveRingoidSigTerm n
      +OL :
        OpInvolutiveRingoidSigTerm n ->
        OpInvolutiveRingoidSigTerm n ->
        OpInvolutiveRingoidSigTerm n
    data OpInvolutiveRingoidSigTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpInvolutiveRingoidSigTerm2 n A
      sing2 :
        A ->
        OpInvolutiveRingoidSigTerm2 n A
      primOL2 :
        OpInvolutiveRingoidSigTerm2 n
          A ->
        OpInvolutiveRingoidSigTerm2 n A
      *OL2 :
        OpInvolutiveRingoidSigTerm2 n
          A ->
        OpInvolutiveRingoidSigTerm2 n
          A ->
        OpInvolutiveRingoidSigTerm2 n A
      +OL2 :
        OpInvolutiveRingoidSigTerm2 n
          A ->
        OpInvolutiveRingoidSigTerm2 n
          A ->
        OpInvolutiveRingoidSigTerm2 n A
    simplifyB :
      InvolutiveRingoidSigTerm ->
      InvolutiveRingoidSigTerm
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClInvolutiveRingoidSigTerm A ->
      ClInvolutiveRingoidSigTerm A
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpInvolutiveRingoidSigTerm n ->
      OpInvolutiveRingoidSigTerm n
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpInvolutiveRingoidSigTerm2 n
        A ->
      OpInvolutiveRingoidSigTerm2 n A
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      InvolutiveRingoidSig A ->
      InvolutiveRingoidSigTerm -> A
    evalB _ In (primL x1) =
      prim In (evalB _ In x1)
    evalB _ In (*L x1 x2) =
      * In (evalB _ In x1)
        (evalB _ In x2)
    evalB _ In (+L x1 x2) =
      + In (evalB _ In x1)
        (evalB _ In x2)
    evalCl :
      (A : Set) ->
      InvolutiveRingoidSig A ->
      ClInvolutiveRingoidSigTerm A ->
      A
    evalCl _ In (sing x1) = x1
    evalCl _ In (primCl x1) =
      prim In (evalCl _ In x1)
    evalCl _ In (*Cl x1 x2) =
      * In (evalCl _ In x1)
        (evalCl _ In x2)
    evalCl _ In (+Cl x1 x2) =
      + In (evalCl _ In x1)
        (evalCl _ In x2)
    evalOp :
      (A : Set) (n : Nat) ->
      InvolutiveRingoidSig A ->
      Vec A n ->
      OpInvolutiveRingoidSigTerm n ->
      A
    evalOp _ n In vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n In vars (primOL x1) =
      prim In (evalOp _ n In vars x1)
    evalOp _ n In vars (*OL x1 x2) =
      * In (evalOp _ n In vars x1)
        (evalOp _ n In vars x2)
    evalOp _ n In vars (+OL x1 x2) =
      + In (evalOp _ n In vars x1)
        (evalOp _ n In vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      InvolutiveRingoidSig A ->
      Vec A n ->
      OpInvolutiveRingoidSigTerm2 n
        A -> A
    evalOpE _ n In vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n In vars (sing2 x1) =
      x1
    evalOpE _ n In vars (primOL2
                         x1) =
      prim In (evalOpE _ n In vars x1)
    evalOpE _ n In vars (*OL2
                         x1
                         x2) =
      * In (evalOpE _ n In vars x1)
        (evalOpE _ n In vars x2)
    evalOpE _ n In vars (+OL2
                         x1
                         x2) =
      + In (evalOpE _ n In vars x1)
        (evalOpE _ n In vars x2)
    inductionB :
      (P : InvolutiveRingoidSigTerm ->
           Set) ->
      ((x1 : InvolutiveRingoidSigTerm) ->
       P x1 -> P (primL x1)) ->
      ((x1 : InvolutiveRingoidSigTerm)
       (x2 : InvolutiveRingoidSigTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : InvolutiveRingoidSigTerm)
       (x2 : InvolutiveRingoidSigTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : InvolutiveRingoidSigTerm) ->
      P x
    inductionB p ppriml p*l p+l (primL
                                 x1) =
      ppriml _
        (inductionB p ppriml p*l p+l x1)
    inductionB p ppriml p*l p+l (*L
                                 x1
                                 x2) =
      p*l _ _
        (inductionB p ppriml p*l p+l x1)
        (inductionB p ppriml p*l p+l x2)
    inductionB p ppriml p*l p+l (+L
                                 x1
                                 x2) =
      p+l _ _
        (inductionB p ppriml p*l p+l x1)
        (inductionB p ppriml p*l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClInvolutiveRingoidSigTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClInvolutiveRingoidSigTerm
          A) -> P x1 -> P (primCl x1)) ->
      ((x1 : ClInvolutiveRingoidSigTerm
          A)
       (x2 : ClInvolutiveRingoidSigTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClInvolutiveRingoidSigTerm
          A)
       (x2 : ClInvolutiveRingoidSigTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClInvolutiveRingoidSigTerm
         A) -> P x
    inductionCl _ p psing pprimcl p*cl p+cl (sing
                                             x1) = psing x1
    inductionCl _ p psing pprimcl p*cl p+cl (primCl
                                             x1) =
      pprimcl _
        (inductionCl _ p psing pprimcl
           p*cl
           p+cl
           x1)
    inductionCl _ p psing pprimcl p*cl p+cl (*Cl
                                             x1
                                             x2) =
      p*cl _ _
        (inductionCl _ p psing pprimcl
           p*cl
           p+cl
           x1)
        (inductionCl _ p psing pprimcl
           p*cl
           p+cl
           x2)
    inductionCl _ p psing pprimcl p*cl p+cl (+Cl
                                             x1
                                             x2) =
      p+cl _ _
        (inductionCl _ p psing pprimcl
           p*cl
           p+cl
           x1)
        (inductionCl _ p psing pprimcl
           p*cl
           p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpInvolutiveRingoidSigTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpInvolutiveRingoidSigTerm
          n) -> P x1 -> P (primOL x1)) ->
      ((x1 : OpInvolutiveRingoidSigTerm
          n)
       (x2 : OpInvolutiveRingoidSigTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpInvolutiveRingoidSigTerm
          n)
       (x2 : OpInvolutiveRingoidSigTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpInvolutiveRingoidSigTerm
         n) -> P x
    inductionOp _ p pv pprimol p*ol p+ol (v
                                          x1) = pv x1
    inductionOp _ p pv pprimol p*ol p+ol (primOL
                                          x1) =
      pprimol _
        (inductionOp _ p pv pprimol p*ol
           p+ol
           x1)
    inductionOp _ p pv pprimol p*ol p+ol (*OL
                                          x1
                                          x2) =
      p*ol _ _
        (inductionOp _ p pv pprimol p*ol
           p+ol
           x1)
        (inductionOp _ p pv pprimol p*ol
           p+ol
           x2)
    inductionOp _ p pv pprimol p*ol p+ol (+OL
                                          x1
                                          x2) =
      p+ol _ _
        (inductionOp _ p pv pprimol p*ol
           p+ol
           x1)
        (inductionOp _ p pv pprimol p*ol
           p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpInvolutiveRingoidSigTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpInvolutiveRingoidSigTerm2
          n
          A) -> P x1 -> P (primOL2 x1)) ->
      ((x1 : OpInvolutiveRingoidSigTerm2
          n
          A)
       (x2 : OpInvolutiveRingoidSigTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpInvolutiveRingoidSigTerm2
          n
          A)
       (x2 : OpInvolutiveRingoidSigTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpInvolutiveRingoidSigTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 pprimol2 p*ol2 p+ol2 (v2
                                                        x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 p*ol2 p+ol2 (sing2
                                                        x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 p*ol2 p+ol2 (primOL2
                                                        x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           p*ol2
           p+ol2
           x1)
    inductionOpE _ _ p pv2 psing2 pprimol2 p*ol2 p+ol2 (*OL2
                                                        x1
                                                        x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           p*ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 pprimol2 p*ol2 p+ol2 (+OL2
                                                        x1
                                                        x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           p*ol2
           p+ol2
           x2)
    primL' :
      InvolutiveRingoidSigTerm ->
      InvolutiveRingoidSigTerm
    primL' x1 = primL x1
    *L' :
      InvolutiveRingoidSigTerm ->
      InvolutiveRingoidSigTerm ->
      InvolutiveRingoidSigTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      InvolutiveRingoidSigTerm ->
      InvolutiveRingoidSigTerm ->
      InvolutiveRingoidSigTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      InvolutiveRingoidSigTerm ->
      Staged InvolutiveRingoidSigTerm
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    primCl' :
      (A : Set) ->
      ClInvolutiveRingoidSigTerm A ->
      ClInvolutiveRingoidSigTerm A
    primCl' _ x1 = primCl x1
    *Cl' :
      (A : Set) ->
      ClInvolutiveRingoidSigTerm A ->
      ClInvolutiveRingoidSigTerm A ->
      ClInvolutiveRingoidSigTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClInvolutiveRingoidSigTerm A ->
      ClInvolutiveRingoidSigTerm A ->
      ClInvolutiveRingoidSigTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClInvolutiveRingoidSigTerm A ->
      Staged
        (ClInvolutiveRingoidSigTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    primOL' :
      (n : Nat) ->
      OpInvolutiveRingoidSigTerm n ->
      OpInvolutiveRingoidSigTerm n
    primOL' _ x1 = primOL x1
    *OL' :
      (n : Nat) ->
      OpInvolutiveRingoidSigTerm n ->
      OpInvolutiveRingoidSigTerm n ->
      OpInvolutiveRingoidSigTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpInvolutiveRingoidSigTerm n ->
      OpInvolutiveRingoidSigTerm n ->
      OpInvolutiveRingoidSigTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpInvolutiveRingoidSigTerm n ->
      Staged
        (OpInvolutiveRingoidSigTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    primOL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveRingoidSigTerm2 n
        A ->
      OpInvolutiveRingoidSigTerm2 n A
    primOL2' _ _ x1 = primOL2 x1
    *OL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveRingoidSigTerm2 n
        A ->
      OpInvolutiveRingoidSigTerm2 n
        A ->
      OpInvolutiveRingoidSigTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveRingoidSigTerm2 n
        A ->
      OpInvolutiveRingoidSigTerm2 n
        A ->
      OpInvolutiveRingoidSigTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpInvolutiveRingoidSigTerm2 n
        A ->
      Staged
        (OpInvolutiveRingoidSigTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record InvolutiveRingoidSigTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        primT : Repr A -> Repr A
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module InvolutiveRingoidWithAntiDistrib where
    record InvolutiveRingoidWithAntiDistrib
      (A : Set) : Set where
      constructor InvolutiveRingoidWithAntiDistribC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        prim : A -> A
        antidis_prim_+ :
          (x : A) (y : A) ->
          prim (+ x y) ==
            + (prim y) (prim x)
        antidis_prim_* :
          (x : A) (y : A) ->
          prim (* x y) ==
            * (prim y) (prim x)
    record InvolutiveRingoidWithAntiDistribSig
      (AS : Set) : Set where
      constructor InvolutiveRingoidWithAntiDistribSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        primS : AS -> AS
    record InvolutiveRingoidWithAntiDistribProd
      (AP : Set) : Set where
      constructor InvolutiveRingoidWithAntiDistribProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        antidis_prim_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (+P xP yP) ==
            +P (primP yP) (primP xP)
        antidis_prim_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (*P xP yP) ==
            *P (primP yP) (primP xP)
    record InvolutiveRingoidWithAntiDistribHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRingoidWithAntiDistrib
         A1)
      (In2 : InvolutiveRingoidWithAntiDistrib
         A2) : Set where
      constructor InvolutiveRingoidWithAntiDistribHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* In1 x1 x2) ==
            * In2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ In1 x1 x2) ==
            + In2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutiveRingoidWithAntiDistribRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveRingoidWithAntiDistrib
         A1)
      (In2 : InvolutiveRingoidWithAntiDistrib
         A2) : Set where
      constructor InvolutiveRingoidWithAntiDistribRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* In1 x1 x2)
            (* In2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ In1 x1 x2)
            (+ In2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutiveRingoidWithAntiDistribTerm
      : Set where
      *L :
        InvolutiveRingoidWithAntiDistribTerm ->
        InvolutiveRingoidWithAntiDistribTerm ->
        InvolutiveRingoidWithAntiDistribTerm
      +L :
        InvolutiveRingoidWithAntiDistribTerm ->
        InvolutiveRingoidWithAntiDistribTerm ->
        InvolutiveRingoidWithAntiDistribTerm
      primL :
        InvolutiveRingoidWithAntiDistribTerm ->
        InvolutiveRingoidWithAntiDistribTerm
    data ClInvolutiveRingoidWithAntiDistribTerm
      (A : Set) : Set where
      sing :
        A ->
        ClInvolutiveRingoidWithAntiDistribTerm
          A
      *Cl :
        ClInvolutiveRingoidWithAntiDistribTerm
          A ->
        ClInvolutiveRingoidWithAntiDistribTerm
          A ->
        ClInvolutiveRingoidWithAntiDistribTerm
          A
      +Cl :
        ClInvolutiveRingoidWithAntiDistribTerm
          A ->
        ClInvolutiveRingoidWithAntiDistribTerm
          A ->
        ClInvolutiveRingoidWithAntiDistribTerm
          A
      primCl :
        ClInvolutiveRingoidWithAntiDistribTerm
          A ->
        ClInvolutiveRingoidWithAntiDistribTerm
          A
    data OpInvolutiveRingoidWithAntiDistribTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpInvolutiveRingoidWithAntiDistribTerm
          n
      *OL :
        OpInvolutiveRingoidWithAntiDistribTerm
          n ->
        OpInvolutiveRingoidWithAntiDistribTerm
          n ->
        OpInvolutiveRingoidWithAntiDistribTerm
          n
      +OL :
        OpInvolutiveRingoidWithAntiDistribTerm
          n ->
        OpInvolutiveRingoidWithAntiDistribTerm
          n ->
        OpInvolutiveRingoidWithAntiDistribTerm
          n
      primOL :
        OpInvolutiveRingoidWithAntiDistribTerm
          n ->
        OpInvolutiveRingoidWithAntiDistribTerm
          n
    data OpInvolutiveRingoidWithAntiDistribTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpInvolutiveRingoidWithAntiDistribTerm2
          n
          A
      sing2 :
        A ->
        OpInvolutiveRingoidWithAntiDistribTerm2
          n
          A
      *OL2 :
        OpInvolutiveRingoidWithAntiDistribTerm2
          n
          A ->
        OpInvolutiveRingoidWithAntiDistribTerm2
          n
          A ->
        OpInvolutiveRingoidWithAntiDistribTerm2
          n
          A
      +OL2 :
        OpInvolutiveRingoidWithAntiDistribTerm2
          n
          A ->
        OpInvolutiveRingoidWithAntiDistribTerm2
          n
          A ->
        OpInvolutiveRingoidWithAntiDistribTerm2
          n
          A
      primOL2 :
        OpInvolutiveRingoidWithAntiDistribTerm2
          n
          A ->
        OpInvolutiveRingoidWithAntiDistribTerm2
          n
          A
    simplifyB :
      InvolutiveRingoidWithAntiDistribTerm ->
      InvolutiveRingoidWithAntiDistribTerm
    simplifyB (+L
               (*L x y)
               (*L x z)) = *L x (+L y z)
    simplifyB (+L
               (*L y x)
               (*L z x)) = *L (+L y z) x
    simplifyB (+L
               (primL y)
               (primL x)) = primL (+L x y)
    simplifyB (*L
               (primL y)
               (primL x)) = primL (*L x y)
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClInvolutiveRingoidWithAntiDistribTerm
        A ->
      ClInvolutiveRingoidWithAntiDistribTerm
        A
    simplifyCl _ (+Cl
                  (*Cl x y)
                  (*Cl x z)) = *Cl x (+Cl y z)
    simplifyCl _ (+Cl
                  (*Cl y x)
                  (*Cl z x)) = *Cl (+Cl y z) x
    simplifyCl _ (+Cl
                  (primCl y)
                  (primCl x)) = primCl (+Cl x y)
    simplifyCl _ (*Cl
                  (primCl y)
                  (primCl x)) = primCl (*Cl x y)
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpInvolutiveRingoidWithAntiDistribTerm
        n ->
      OpInvolutiveRingoidWithAntiDistribTerm
        n
    simplifyOp _ (+OL
                  (*OL x y)
                  (*OL x z)) = *OL x (+OL y z)
    simplifyOp _ (+OL
                  (*OL y x)
                  (*OL z x)) = *OL (+OL y z) x
    simplifyOp _ (+OL
                  (primOL y)
                  (primOL x)) = primOL (+OL x y)
    simplifyOp _ (*OL
                  (primOL y)
                  (primOL x)) = primOL (*OL x y)
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpInvolutiveRingoidWithAntiDistribTerm2
        n
        A ->
      OpInvolutiveRingoidWithAntiDistribTerm2
        n
        A
    simplifyOpE _ _ (+OL2
                     (*OL2 x y)
                     (*OL2 x z)) = *OL2 x (+OL2 y z)
    simplifyOpE _ _ (+OL2
                     (*OL2 y x)
                     (*OL2 z x)) = *OL2 (+OL2 y z) x
    simplifyOpE _ _ (+OL2
                     (primOL2 y)
                     (primOL2 x)) =
      primOL2 (+OL2 x y)
    simplifyOpE _ _ (*OL2
                     (primOL2 y)
                     (primOL2 x)) =
      primOL2 (*OL2 x y)
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      InvolutiveRingoidWithAntiDistrib
        A ->
      InvolutiveRingoidWithAntiDistribTerm ->
      A
    evalB _ In (*L x1 x2) =
      * In (evalB _ In x1)
        (evalB _ In x2)
    evalB _ In (+L x1 x2) =
      + In (evalB _ In x1)
        (evalB _ In x2)
    evalB _ In (primL x1) =
      prim In (evalB _ In x1)
    evalCl :
      (A : Set) ->
      InvolutiveRingoidWithAntiDistrib
        A ->
      ClInvolutiveRingoidWithAntiDistribTerm
        A -> A
    evalCl _ In (sing x1) = x1
    evalCl _ In (*Cl x1 x2) =
      * In (evalCl _ In x1)
        (evalCl _ In x2)
    evalCl _ In (+Cl x1 x2) =
      + In (evalCl _ In x1)
        (evalCl _ In x2)
    evalCl _ In (primCl x1) =
      prim In (evalCl _ In x1)
    evalOp :
      (A : Set) (n : Nat) ->
      InvolutiveRingoidWithAntiDistrib
        A ->
      Vec A n ->
      OpInvolutiveRingoidWithAntiDistribTerm
        n -> A
    evalOp _ n In vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n In vars (*OL x1 x2) =
      * In (evalOp _ n In vars x1)
        (evalOp _ n In vars x2)
    evalOp _ n In vars (+OL x1 x2) =
      + In (evalOp _ n In vars x1)
        (evalOp _ n In vars x2)
    evalOp _ n In vars (primOL x1) =
      prim In (evalOp _ n In vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      InvolutiveRingoidWithAntiDistrib
        A ->
      Vec A n ->
      OpInvolutiveRingoidWithAntiDistribTerm2
        n
        A -> A
    evalOpE _ n In vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n In vars (sing2 x1) =
      x1
    evalOpE _ n In vars (*OL2
                         x1
                         x2) =
      * In (evalOpE _ n In vars x1)
        (evalOpE _ n In vars x2)
    evalOpE _ n In vars (+OL2
                         x1
                         x2) =
      + In (evalOpE _ n In vars x1)
        (evalOpE _ n In vars x2)
    evalOpE _ n In vars (primOL2
                         x1) =
      prim In (evalOpE _ n In vars x1)
    inductionB :
      (P : InvolutiveRingoidWithAntiDistribTerm ->
           Set) ->
      ((x1 : InvolutiveRingoidWithAntiDistribTerm)
       (x2 : InvolutiveRingoidWithAntiDistribTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : InvolutiveRingoidWithAntiDistribTerm)
       (x2 : InvolutiveRingoidWithAntiDistribTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      ((x1 : InvolutiveRingoidWithAntiDistribTerm) ->
       P x1 -> P (primL x1)) ->
      (x : InvolutiveRingoidWithAntiDistribTerm) ->
      P x
    inductionB p p*l p+l ppriml (*L
                                 x1
                                 x2) =
      p*l _ _
        (inductionB p p*l p+l ppriml x1)
        (inductionB p p*l p+l ppriml x2)
    inductionB p p*l p+l ppriml (+L
                                 x1
                                 x2) =
      p+l _ _
        (inductionB p p*l p+l ppriml x1)
        (inductionB p p*l p+l ppriml x2)
    inductionB p p*l p+l ppriml (primL
                                 x1) =
      ppriml _
        (inductionB p p*l p+l ppriml x1)
    inductionCl :
      (A : Set)
      (P : ClInvolutiveRingoidWithAntiDistribTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClInvolutiveRingoidWithAntiDistribTerm
          A)
       (x2 : ClInvolutiveRingoidWithAntiDistribTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClInvolutiveRingoidWithAntiDistribTerm
          A)
       (x2 : ClInvolutiveRingoidWithAntiDistribTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      ((x1 : ClInvolutiveRingoidWithAntiDistribTerm
          A) -> P x1 -> P (primCl x1)) ->
      (x : ClInvolutiveRingoidWithAntiDistribTerm
         A) -> P x
    inductionCl _ p psing p*cl p+cl pprimcl (sing
                                             x1) = psing x1
    inductionCl _ p psing p*cl p+cl pprimcl (*Cl
                                             x1
                                             x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x1)
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x2)
    inductionCl _ p psing p*cl p+cl pprimcl (+Cl
                                             x1
                                             x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x1)
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x2)
    inductionCl _ p psing p*cl p+cl pprimcl (primCl
                                             x1) =
      pprimcl _
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpInvolutiveRingoidWithAntiDistribTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpInvolutiveRingoidWithAntiDistribTerm
          n)
       (x2 : OpInvolutiveRingoidWithAntiDistribTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpInvolutiveRingoidWithAntiDistribTerm
          n)
       (x2 : OpInvolutiveRingoidWithAntiDistribTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      ((x1 : OpInvolutiveRingoidWithAntiDistribTerm
          n) -> P x1 -> P (primOL x1)) ->
      (x : OpInvolutiveRingoidWithAntiDistribTerm
         n) -> P x
    inductionOp _ p pv p*ol p+ol pprimol (v
                                          x1) = pv x1
    inductionOp _ p pv p*ol p+ol pprimol (*OL
                                          x1
                                          x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x1)
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x2)
    inductionOp _ p pv p*ol p+ol pprimol (+OL
                                          x1
                                          x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x1)
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x2)
    inductionOp _ p pv p*ol p+ol pprimol (primOL
                                          x1) =
      pprimol _
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpInvolutiveRingoidWithAntiDistribTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpInvolutiveRingoidWithAntiDistribTerm2
          n
          A)
       (x2 : OpInvolutiveRingoidWithAntiDistribTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpInvolutiveRingoidWithAntiDistribTerm2
          n
          A)
       (x2 : OpInvolutiveRingoidWithAntiDistribTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      ((x1 : OpInvolutiveRingoidWithAntiDistribTerm2
          n
          A) -> P x1 -> P (primOL2 x1)) ->
      (x : OpInvolutiveRingoidWithAntiDistribTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (v2
                                                        x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (sing2
                                                        x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (*OL2
                                                        x1
                                                        x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (+OL2
                                                        x1
                                                        x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (primOL2
                                                        x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x1)
    *L' :
      InvolutiveRingoidWithAntiDistribTerm ->
      InvolutiveRingoidWithAntiDistribTerm ->
      InvolutiveRingoidWithAntiDistribTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      InvolutiveRingoidWithAntiDistribTerm ->
      InvolutiveRingoidWithAntiDistribTerm ->
      InvolutiveRingoidWithAntiDistribTerm
    +L' x1 x2 = +L x1 x2
    primL' :
      InvolutiveRingoidWithAntiDistribTerm ->
      InvolutiveRingoidWithAntiDistribTerm
    primL' x1 = primL x1
    stageB :
      InvolutiveRingoidWithAntiDistribTerm ->
      Staged
        InvolutiveRingoidWithAntiDistribTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    *Cl' :
      (A : Set) ->
      ClInvolutiveRingoidWithAntiDistribTerm
        A ->
      ClInvolutiveRingoidWithAntiDistribTerm
        A ->
      ClInvolutiveRingoidWithAntiDistribTerm
        A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClInvolutiveRingoidWithAntiDistribTerm
        A ->
      ClInvolutiveRingoidWithAntiDistribTerm
        A ->
      ClInvolutiveRingoidWithAntiDistribTerm
        A
    +Cl' _ x1 x2 = +Cl x1 x2
    primCl' :
      (A : Set) ->
      ClInvolutiveRingoidWithAntiDistribTerm
        A ->
      ClInvolutiveRingoidWithAntiDistribTerm
        A
    primCl' _ x1 = primCl x1
    stageCl :
      (A : Set) ->
      ClInvolutiveRingoidWithAntiDistribTerm
        A ->
      Staged
        (ClInvolutiveRingoidWithAntiDistribTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    *OL' :
      (n : Nat) ->
      OpInvolutiveRingoidWithAntiDistribTerm
        n ->
      OpInvolutiveRingoidWithAntiDistribTerm
        n ->
      OpInvolutiveRingoidWithAntiDistribTerm
        n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpInvolutiveRingoidWithAntiDistribTerm
        n ->
      OpInvolutiveRingoidWithAntiDistribTerm
        n ->
      OpInvolutiveRingoidWithAntiDistribTerm
        n
    +OL' _ x1 x2 = +OL x1 x2
    primOL' :
      (n : Nat) ->
      OpInvolutiveRingoidWithAntiDistribTerm
        n ->
      OpInvolutiveRingoidWithAntiDistribTerm
        n
    primOL' _ x1 = primOL x1
    stageOp :
      (n : Nat) ->
      OpInvolutiveRingoidWithAntiDistribTerm
        n ->
      Staged
        (OpInvolutiveRingoidWithAntiDistribTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveRingoidWithAntiDistribTerm2
        n
        A ->
      OpInvolutiveRingoidWithAntiDistribTerm2
        n
        A ->
      OpInvolutiveRingoidWithAntiDistribTerm2
        n
        A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveRingoidWithAntiDistribTerm2
        n
        A ->
      OpInvolutiveRingoidWithAntiDistribTerm2
        n
        A ->
      OpInvolutiveRingoidWithAntiDistribTerm2
        n
        A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    primOL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveRingoidWithAntiDistribTerm2
        n
        A ->
      OpInvolutiveRingoidWithAntiDistribTerm2
        n
        A
    primOL2' _ _ x1 = primOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpInvolutiveRingoidWithAntiDistribTerm2
        n
        A ->
      Staged
        (OpInvolutiveRingoidWithAntiDistribTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    record InvolutiveRingoidWithAntiDistribTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
        primT : Repr A -> Repr A
  
  module InvolutiveSemigroup where
    record InvolutiveSemigroup
      (A : Set) : Set where
      constructor InvolutiveSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        prim : A -> A
        involutive_prim :
          (x : A) -> prim (prim x) == x
        antidis_prim_op :
          (x : A) (y : A) ->
          prim (op x y) ==
            op (prim y) (prim x)
    record InvolutiveSemigroupSig
      (AS : Set) : Set where
      constructor InvolutiveSemigroupSigSigC
      field
        opS : AS -> AS -> AS
        primS : AS -> AS
    record InvolutiveSemigroupProd
      (AP : Set) : Set where
      constructor InvolutiveSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        involutive_primP :
          (xP : Prod AP AP) ->
          primP (primP xP) == xP
        antidis_prim_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (opP xP yP) ==
            opP (primP yP) (primP xP)
    record InvolutiveSemigroupHom
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveSemigroup A1)
      (In2 : InvolutiveSemigroup A2) :
      Set where
      constructor InvolutiveSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op In1 x1 x2) ==
            op In2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim In1 x1) ==
            prim In2 (hom x1)
    record InvolutiveSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (In1 : InvolutiveSemigroup A1)
      (In2 : InvolutiveSemigroup A2) :
      Set where
      constructor InvolutiveSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op In1 x1 x2)
            (op In2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim In1 x1)
            (prim In2 y1)
    data InvolutiveSemigroupTerm
      : Set where
      opL :
        InvolutiveSemigroupTerm ->
        InvolutiveSemigroupTerm ->
        InvolutiveSemigroupTerm
      primL :
        InvolutiveSemigroupTerm ->
        InvolutiveSemigroupTerm
    data ClInvolutiveSemigroupTerm
      (A : Set) : Set where
      sing :
        A -> ClInvolutiveSemigroupTerm A
      opCl :
        ClInvolutiveSemigroupTerm A ->
        ClInvolutiveSemigroupTerm A ->
        ClInvolutiveSemigroupTerm A
      primCl :
        ClInvolutiveSemigroupTerm A ->
        ClInvolutiveSemigroupTerm A
    data OpInvolutiveSemigroupTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpInvolutiveSemigroupTerm n
      opOL :
        OpInvolutiveSemigroupTerm n ->
        OpInvolutiveSemigroupTerm n ->
        OpInvolutiveSemigroupTerm n
      primOL :
        OpInvolutiveSemigroupTerm n ->
        OpInvolutiveSemigroupTerm n
    data OpInvolutiveSemigroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpInvolutiveSemigroupTerm2 n A
      sing2 :
        A ->
        OpInvolutiveSemigroupTerm2 n A
      opOL2 :
        OpInvolutiveSemigroupTerm2 n
          A ->
        OpInvolutiveSemigroupTerm2 n
          A ->
        OpInvolutiveSemigroupTerm2 n A
      primOL2 :
        OpInvolutiveSemigroupTerm2 n
          A ->
        OpInvolutiveSemigroupTerm2 n A
    simplifyB :
      InvolutiveSemigroupTerm ->
      InvolutiveSemigroupTerm
    simplifyB (primL (primL x)) = x
    simplifyB (opL
               (primL y)
               (primL x)) = primL (opL x y)
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClInvolutiveSemigroupTerm A ->
      ClInvolutiveSemigroupTerm A
    simplifyCl _ (primCl
                  (primCl x)) = x
    simplifyCl _ (opCl
                  (primCl y)
                  (primCl x)) = primCl (opCl x y)
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpInvolutiveSemigroupTerm n ->
      OpInvolutiveSemigroupTerm n
    simplifyOp _ (primOL
                  (primOL x)) = x
    simplifyOp _ (opOL
                  (primOL y)
                  (primOL x)) = primOL (opOL x y)
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpInvolutiveSemigroupTerm2 n
        A ->
      OpInvolutiveSemigroupTerm2 n A
    simplifyOpE _ _ (primOL2
                     (primOL2 x)) = x
    simplifyOpE _ _ (opOL2
                     (primOL2 y)
                     (primOL2 x)) =
      primOL2 (opOL2 x y)
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      InvolutiveSemigroup A ->
      InvolutiveSemigroupTerm -> A
    evalB _ In (opL x1 x2) =
      op In (evalB _ In x1)
        (evalB _ In x2)
    evalB _ In (primL x1) =
      prim In (evalB _ In x1)
    evalCl :
      (A : Set) ->
      InvolutiveSemigroup A ->
      ClInvolutiveSemigroupTerm A -> A
    evalCl _ In (sing x1) = x1
    evalCl _ In (opCl x1 x2) =
      op In (evalCl _ In x1)
        (evalCl _ In x2)
    evalCl _ In (primCl x1) =
      prim In (evalCl _ In x1)
    evalOp :
      (A : Set) (n : Nat) ->
      InvolutiveSemigroup A ->
      Vec A n ->
      OpInvolutiveSemigroupTerm n -> A
    evalOp _ n In vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n In vars (opOL
                        x1
                        x2) =
      op In (evalOp _ n In vars x1)
        (evalOp _ n In vars x2)
    evalOp _ n In vars (primOL x1) =
      prim In (evalOp _ n In vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      InvolutiveSemigroup A ->
      Vec A n ->
      OpInvolutiveSemigroupTerm2 n
        A -> A
    evalOpE _ n In vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n In vars (sing2 x1) =
      x1
    evalOpE _ n In vars (opOL2
                         x1
                         x2) =
      op In (evalOpE _ n In vars x1)
        (evalOpE _ n In vars x2)
    evalOpE _ n In vars (primOL2
                         x1) =
      prim In (evalOpE _ n In vars x1)
    inductionB :
      (P : InvolutiveSemigroupTerm ->
           Set) ->
      ((x1 : InvolutiveSemigroupTerm)
       (x2 : InvolutiveSemigroupTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      ((x1 : InvolutiveSemigroupTerm) ->
       P x1 -> P (primL x1)) ->
      (x : InvolutiveSemigroupTerm) ->
      P x
    inductionB p popl ppriml (opL
                              x1
                              x2) =
      popl _ _
        (inductionB p popl ppriml x1)
        (inductionB p popl ppriml x2)
    inductionB p popl ppriml (primL
                              x1) =
      ppriml _
        (inductionB p popl ppriml x1)
    inductionCl :
      (A : Set)
      (P : ClInvolutiveSemigroupTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClInvolutiveSemigroupTerm
          A)
       (x2 : ClInvolutiveSemigroupTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      ((x1 : ClInvolutiveSemigroupTerm
          A) -> P x1 -> P (primCl x1)) ->
      (x : ClInvolutiveSemigroupTerm
         A) -> P x
    inductionCl _ p psing popcl pprimcl (sing
                                         x1) = psing x1
    inductionCl _ p psing popcl pprimcl (opCl
                                         x1
                                         x2) =
      popcl _ _
        (inductionCl _ p psing popcl
           pprimcl
           x1)
        (inductionCl _ p psing popcl
           pprimcl
           x2)
    inductionCl _ p psing popcl pprimcl (primCl
                                         x1) =
      pprimcl _
        (inductionCl _ p psing popcl
           pprimcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpInvolutiveSemigroupTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpInvolutiveSemigroupTerm
          n)
       (x2 : OpInvolutiveSemigroupTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      ((x1 : OpInvolutiveSemigroupTerm
          n) -> P x1 -> P (primOL x1)) ->
      (x : OpInvolutiveSemigroupTerm
         n) -> P x
    inductionOp _ p pv popol pprimol (v
                                      x1) = pv x1
    inductionOp _ p pv popol pprimol (opOL
                                      x1
                                      x2) =
      popol _ _
        (inductionOp _ p pv popol
           pprimol
           x1)
        (inductionOp _ p pv popol
           pprimol
           x2)
    inductionOp _ p pv popol pprimol (primOL
                                      x1) =
      pprimol _
        (inductionOp _ p pv popol
           pprimol
           x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpInvolutiveSemigroupTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpInvolutiveSemigroupTerm2
          n
          A)
       (x2 : OpInvolutiveSemigroupTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      ((x1 : OpInvolutiveSemigroupTerm2
          n
          A) -> P x1 -> P (primOL2 x1)) ->
      (x : OpInvolutiveSemigroupTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 pprimol2 (v2
                                                   x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 pprimol2 (sing2
                                                   x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 pprimol2 (opOL2
                                                   x1
                                                   x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           pprimol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           pprimol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 pprimol2 (primOL2
                                                   x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           popol2
           pprimol2
           x1)
    opL' :
      InvolutiveSemigroupTerm ->
      InvolutiveSemigroupTerm ->
      InvolutiveSemigroupTerm
    opL' x1 x2 = opL x1 x2
    primL' :
      InvolutiveSemigroupTerm ->
      InvolutiveSemigroupTerm
    primL' x1 = primL x1
    stageB :
      InvolutiveSemigroupTerm ->
      Staged InvolutiveSemigroupTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    opCl' :
      (A : Set) ->
      ClInvolutiveSemigroupTerm A ->
      ClInvolutiveSemigroupTerm A ->
      ClInvolutiveSemigroupTerm A
    opCl' _ x1 x2 = opCl x1 x2
    primCl' :
      (A : Set) ->
      ClInvolutiveSemigroupTerm A ->
      ClInvolutiveSemigroupTerm A
    primCl' _ x1 = primCl x1
    stageCl :
      (A : Set) ->
      ClInvolutiveSemigroupTerm A ->
      Staged
        (ClInvolutiveSemigroupTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    opOL' :
      (n : Nat) ->
      OpInvolutiveSemigroupTerm n ->
      OpInvolutiveSemigroupTerm n ->
      OpInvolutiveSemigroupTerm n
    opOL' _ x1 x2 = opOL x1 x2
    primOL' :
      (n : Nat) ->
      OpInvolutiveSemigroupTerm n ->
      OpInvolutiveSemigroupTerm n
    primOL' _ x1 = primOL x1
    stageOp :
      (n : Nat) ->
      OpInvolutiveSemigroupTerm n ->
      Staged
        (OpInvolutiveSemigroupTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveSemigroupTerm2 n
        A ->
      OpInvolutiveSemigroupTerm2 n
        A ->
      OpInvolutiveSemigroupTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    primOL2' :
      (n : Nat) (A : Set) ->
      OpInvolutiveSemigroupTerm2 n
        A ->
      OpInvolutiveSemigroupTerm2 n A
    primOL2' _ _ x1 = primOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpInvolutiveSemigroupTerm2 n
        A ->
      Staged
        (OpInvolutiveSemigroupTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    record InvolutiveSemigroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
        primT : Repr A -> Repr A
  
  module JacobianIdentity where
    record JacobianIdentity
      (A : Set) : Set where
      constructor JacobianIdentityC
      field
        0 : A
        + : A -> A -> A
        * : A -> A -> A
        jacobian_*_+ :
          (x : A) (y : A) (z : A) ->
          +
            (+ (* x (* y z)) (* y (* z x)))
            (* z (* x y)) == 0
    record JacobianIdentitySig
      (AS : Set) : Set where
      constructor JacobianIdentitySigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
    record JacobianIdentityProd
      (AP : Set) : Set where
      constructor JacobianIdentityProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        jacobian_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P
            (+P (*P xP (*P yP zP))
               (*P yP (*P zP xP)))
            (*P zP (*P xP yP)) == 0P
    record JacobianIdentityHom
      (A1 : Set) (A2 : Set)
      (Ja1 : JacobianIdentity A1)
      (Ja2 : JacobianIdentity A2) :
      Set where
      constructor JacobianIdentityHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ja1) == 0 Ja2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ja1 x1 x2) ==
            + Ja2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ja1 x1 x2) ==
            * Ja2 (hom x1) (hom x2)
    record JacobianIdentityRelInterp
      (A1 : Set) (A2 : Set)
      (Ja1 : JacobianIdentity A1)
      (Ja2 : JacobianIdentity A2) :
      Set where
      constructor JacobianIdentityRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ja1) (0 Ja2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ja1 x1 x2)
            (+ Ja2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ja1 x1 x2)
            (* Ja2 y1 y2)
    data JacobianIdentityTerm
      : Set where
      0L : JacobianIdentityTerm
      +L :
        JacobianIdentityTerm ->
        JacobianIdentityTerm ->
        JacobianIdentityTerm
      *L :
        JacobianIdentityTerm ->
        JacobianIdentityTerm ->
        JacobianIdentityTerm
    data ClJacobianIdentityTerm
      (A : Set) : Set where
      sing :
        A -> ClJacobianIdentityTerm A
      0Cl : ClJacobianIdentityTerm A
      +Cl :
        ClJacobianIdentityTerm A ->
        ClJacobianIdentityTerm A ->
        ClJacobianIdentityTerm A
      *Cl :
        ClJacobianIdentityTerm A ->
        ClJacobianIdentityTerm A ->
        ClJacobianIdentityTerm A
    data OpJacobianIdentityTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpJacobianIdentityTerm n
      0OL : OpJacobianIdentityTerm n
      +OL :
        OpJacobianIdentityTerm n ->
        OpJacobianIdentityTerm n ->
        OpJacobianIdentityTerm n
      *OL :
        OpJacobianIdentityTerm n ->
        OpJacobianIdentityTerm n ->
        OpJacobianIdentityTerm n
    data OpJacobianIdentityTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpJacobianIdentityTerm2 n A
      sing2 :
        A -> OpJacobianIdentityTerm2 n A
      0OL2 :
        OpJacobianIdentityTerm2 n A
      +OL2 :
        OpJacobianIdentityTerm2 n A ->
        OpJacobianIdentityTerm2 n A ->
        OpJacobianIdentityTerm2 n A
      *OL2 :
        OpJacobianIdentityTerm2 n A ->
        OpJacobianIdentityTerm2 n A ->
        OpJacobianIdentityTerm2 n A
    simplifyB :
      JacobianIdentityTerm ->
      JacobianIdentityTerm
    simplifyB (+L
               (+L
                (*L x (*L y z))
                (*L y (*L z x)))
               (*L z (*L x y))) = 0L
    simplifyB (0L) = 0L
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClJacobianIdentityTerm A ->
      ClJacobianIdentityTerm A
    simplifyCl _ (+Cl
                  (+Cl
                   (*Cl x (*Cl y z))
                   (*Cl y (*Cl z x)))
                  (*Cl z (*Cl x y))) = 0Cl
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpJacobianIdentityTerm n ->
      OpJacobianIdentityTerm n
    simplifyOp _ (+OL
                  (+OL
                   (*OL x (*OL y z))
                   (*OL y (*OL z x)))
                  (*OL z (*OL x y))) = 0OL
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpJacobianIdentityTerm2 n A ->
      OpJacobianIdentityTerm2 n A
    simplifyOpE _ _ (+OL2
                     (+OL2
                      (*OL2 x (*OL2 y z))
                      (*OL2 y (*OL2 z x)))
                     (*OL2 z (*OL2 x y))) = 0OL2
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      JacobianIdentity A ->
      JacobianIdentityTerm -> A
    evalB _ Ja (0L) = 0 Ja
    evalB _ Ja (+L x1 x2) =
      + Ja (evalB _ Ja x1)
        (evalB _ Ja x2)
    evalB _ Ja (*L x1 x2) =
      * Ja (evalB _ Ja x1)
        (evalB _ Ja x2)
    evalCl :
      (A : Set) ->
      JacobianIdentity A ->
      ClJacobianIdentityTerm A -> A
    evalCl _ Ja (sing x1) = x1
    evalCl _ Ja (0Cl) = 0 Ja
    evalCl _ Ja (+Cl x1 x2) =
      + Ja (evalCl _ Ja x1)
        (evalCl _ Ja x2)
    evalCl _ Ja (*Cl x1 x2) =
      * Ja (evalCl _ Ja x1)
        (evalCl _ Ja x2)
    evalOp :
      (A : Set) (n : Nat) ->
      JacobianIdentity A ->
      Vec A n ->
      OpJacobianIdentityTerm n -> A
    evalOp _ n Ja vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ja vars (0OL) = 0 Ja
    evalOp _ n Ja vars (+OL x1 x2) =
      + Ja (evalOp _ n Ja vars x1)
        (evalOp _ n Ja vars x2)
    evalOp _ n Ja vars (*OL x1 x2) =
      * Ja (evalOp _ n Ja vars x1)
        (evalOp _ n Ja vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      JacobianIdentity A ->
      Vec A n ->
      OpJacobianIdentityTerm2 n A -> A
    evalOpE _ n Ja vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ja vars (sing2 x1) =
      x1
    evalOpE _ n Ja vars (0OL2) =
      0 Ja
    evalOpE _ n Ja vars (+OL2
                         x1
                         x2) =
      + Ja (evalOpE _ n Ja vars x1)
        (evalOpE _ n Ja vars x2)
    evalOpE _ n Ja vars (*OL2
                         x1
                         x2) =
      * Ja (evalOpE _ n Ja vars x1)
        (evalOpE _ n Ja vars x2)
    inductionB :
      (P : JacobianIdentityTerm ->
           Set) ->
      P 0L ->
      ((x1 : JacobianIdentityTerm)
       (x2 : JacobianIdentityTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      ((x1 : JacobianIdentityTerm)
       (x2 : JacobianIdentityTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      (x : JacobianIdentityTerm) ->
      P x
    inductionB p p0l p+l p*l (0L) =
      p0l
    inductionB p p0l p+l p*l (+L
                              x1
                              x2) =
      p+l _ _
        (inductionB p p0l p+l p*l x1)
        (inductionB p p0l p+l p*l x2)
    inductionB p p0l p+l p*l (*L
                              x1
                              x2) =
      p*l _ _
        (inductionB p p0l p+l p*l x1)
        (inductionB p p0l p+l p*l x2)
    inductionCl :
      (A : Set)
      (P : ClJacobianIdentityTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 0Cl ->
      ((x1 : ClJacobianIdentityTerm A)
       (x2 : ClJacobianIdentityTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      ((x1 : ClJacobianIdentityTerm A)
       (x2 : ClJacobianIdentityTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      (x : ClJacobianIdentityTerm
         A) -> P x
    inductionCl _ p psing p0cl p+cl p*cl (sing
                                          x1) = psing x1
    inductionCl _ p psing p0cl p+cl p*cl (0Cl) =
      p0cl
    inductionCl _ p psing p0cl p+cl p*cl (+Cl
                                          x1
                                          x2) =
      p+cl _ _
        (inductionCl _ p psing p0cl p+cl
           p*cl
           x1)
        (inductionCl _ p psing p0cl p+cl
           p*cl
           x2)
    inductionCl _ p psing p0cl p+cl p*cl (*Cl
                                          x1
                                          x2) =
      p*cl _ _
        (inductionCl _ p psing p0cl p+cl
           p*cl
           x1)
        (inductionCl _ p psing p0cl p+cl
           p*cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpJacobianIdentityTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 0OL ->
      ((x1 : OpJacobianIdentityTerm n)
       (x2 : OpJacobianIdentityTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      ((x1 : OpJacobianIdentityTerm n)
       (x2 : OpJacobianIdentityTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      (x : OpJacobianIdentityTerm
         n) -> P x
    inductionOp _ p pv p0ol p+ol p*ol (v
                                       x1) = pv x1
    inductionOp _ p pv p0ol p+ol p*ol (0OL) =
      p0ol
    inductionOp _ p pv p0ol p+ol p*ol (+OL
                                       x1
                                       x2) =
      p+ol _ _
        (inductionOp _ p pv p0ol p+ol
           p*ol
           x1)
        (inductionOp _ p pv p0ol p+ol
           p*ol
           x2)
    inductionOp _ p pv p0ol p+ol p*ol (*OL
                                       x1
                                       x2) =
      p*ol _ _
        (inductionOp _ p pv p0ol p+ol
           p*ol
           x1)
        (inductionOp _ p pv p0ol p+ol
           p*ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpJacobianIdentityTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 0OL2 ->
      ((x1 : OpJacobianIdentityTerm2 n
          A)
       (x2 : OpJacobianIdentityTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      ((x1 : OpJacobianIdentityTerm2 n
          A)
       (x2 : OpJacobianIdentityTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      (x : OpJacobianIdentityTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 (v2
                                                     x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 (sing2
                                                     x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 (+OL2
                                                     x1
                                                     x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           p*ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 (*OL2
                                                     x1
                                                     x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           p*ol2
           x2)
    0L' : JacobianIdentityTerm
    0L' = 0L
    +L' :
      JacobianIdentityTerm ->
      JacobianIdentityTerm ->
      JacobianIdentityTerm
    +L' x1 x2 = +L x1 x2
    *L' :
      JacobianIdentityTerm ->
      JacobianIdentityTerm ->
      JacobianIdentityTerm
    *L' x1 x2 = *L x1 x2
    stageB :
      JacobianIdentityTerm ->
      Staged JacobianIdentityTerm
    stageB (0L) = Now 0L
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    0Cl' :
      (A : Set) ->
      ClJacobianIdentityTerm A
    0Cl' _ = 0Cl
    +Cl' :
      (A : Set) ->
      ClJacobianIdentityTerm A ->
      ClJacobianIdentityTerm A ->
      ClJacobianIdentityTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    *Cl' :
      (A : Set) ->
      ClJacobianIdentityTerm A ->
      ClJacobianIdentityTerm A ->
      ClJacobianIdentityTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    stageCl :
      (A : Set) ->
      ClJacobianIdentityTerm A ->
      Staged
        (ClJacobianIdentityTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    0OL' :
      (n : Nat) ->
      OpJacobianIdentityTerm n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      OpJacobianIdentityTerm n ->
      OpJacobianIdentityTerm n ->
      OpJacobianIdentityTerm n
    +OL' _ x1 x2 = +OL x1 x2
    *OL' :
      (n : Nat) ->
      OpJacobianIdentityTerm n ->
      OpJacobianIdentityTerm n ->
      OpJacobianIdentityTerm n
    *OL' _ x1 x2 = *OL x1 x2
    stageOp :
      (n : Nat) ->
      OpJacobianIdentityTerm n ->
      Staged
        (OpJacobianIdentityTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (0OL) = Now 0OL
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    0OL2' :
      (n : Nat) (A : Set) ->
      OpJacobianIdentityTerm2 n A
    0OL2' _ _ = 0OL2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpJacobianIdentityTerm2 n A ->
      OpJacobianIdentityTerm2 n A ->
      OpJacobianIdentityTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    *OL2' :
      (n : Nat) (A : Set) ->
      OpJacobianIdentityTerm2 n A ->
      OpJacobianIdentityTerm2 n A ->
      OpJacobianIdentityTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpJacobianIdentityTerm2 n A ->
      Staged
        (OpJacobianIdentityTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record JacobianIdentityTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        0T : Repr A
        +T : Repr A -> Repr A -> Repr A
        *T : Repr A -> Repr A -> Repr A
  
  module JoinSemilattice where
    record JoinSemilattice
      (A : Set) : Set where
      constructor JoinSemilatticeC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
    record JoinSemilatticeSig
      (AS : Set) : Set where
      constructor JoinSemilatticeSigSigC
      field
        +S : AS -> AS -> AS
    record JoinSemilatticeProd
      (AP : Set) : Set where
      constructor JoinSemilatticeProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record JoinSemilatticeHom
      (A1 : Set) (A2 : Set)
      (Jo1 : JoinSemilattice A1)
      (Jo2 : JoinSemilattice A2) :
      Set where
      constructor JoinSemilatticeHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Jo1 x1 x2) ==
            + Jo2 (hom x1) (hom x2)
    record JoinSemilatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Jo1 : JoinSemilattice A1)
      (Jo2 : JoinSemilattice A2) :
      Set where
      constructor JoinSemilatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Jo1 x1 x2)
            (+ Jo2 y1 y2)
    data JoinSemilatticeTerm
      : Set where
      +L :
        JoinSemilatticeTerm ->
        JoinSemilatticeTerm ->
        JoinSemilatticeTerm
    data ClJoinSemilatticeTerm
      (A : Set) : Set where
      sing :
        A -> ClJoinSemilatticeTerm A
      +Cl :
        ClJoinSemilatticeTerm A ->
        ClJoinSemilatticeTerm A ->
        ClJoinSemilatticeTerm A
    data OpJoinSemilatticeTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpJoinSemilatticeTerm n
      +OL :
        OpJoinSemilatticeTerm n ->
        OpJoinSemilatticeTerm n ->
        OpJoinSemilatticeTerm n
    data OpJoinSemilatticeTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpJoinSemilatticeTerm2 n A
      sing2 :
        A -> OpJoinSemilatticeTerm2 n A
      +OL2 :
        OpJoinSemilatticeTerm2 n A ->
        OpJoinSemilatticeTerm2 n A ->
        OpJoinSemilatticeTerm2 n A
    simplifyB :
      JoinSemilatticeTerm ->
      JoinSemilatticeTerm
    simplifyB (+L x x) = x
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClJoinSemilatticeTerm A ->
      ClJoinSemilatticeTerm A
    simplifyCl _ (+Cl x x) = x
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpJoinSemilatticeTerm n ->
      OpJoinSemilatticeTerm n
    simplifyOp _ (+OL x x) = x
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpJoinSemilatticeTerm2 n A ->
      OpJoinSemilatticeTerm2 n A
    simplifyOpE _ _ (+OL2 x x) = x
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      JoinSemilattice A ->
      JoinSemilatticeTerm -> A
    evalB _ Jo (+L x1 x2) =
      + Jo (evalB _ Jo x1)
        (evalB _ Jo x2)
    evalCl :
      (A : Set) ->
      JoinSemilattice A ->
      ClJoinSemilatticeTerm A -> A
    evalCl _ Jo (sing x1) = x1
    evalCl _ Jo (+Cl x1 x2) =
      + Jo (evalCl _ Jo x1)
        (evalCl _ Jo x2)
    evalOp :
      (A : Set) (n : Nat) ->
      JoinSemilattice A ->
      Vec A n ->
      OpJoinSemilatticeTerm n -> A
    evalOp _ n Jo vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Jo vars (+OL x1 x2) =
      + Jo (evalOp _ n Jo vars x1)
        (evalOp _ n Jo vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      JoinSemilattice A ->
      Vec A n ->
      OpJoinSemilatticeTerm2 n A -> A
    evalOpE _ n Jo vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Jo vars (sing2 x1) =
      x1
    evalOpE _ n Jo vars (+OL2
                         x1
                         x2) =
      + Jo (evalOpE _ n Jo vars x1)
        (evalOpE _ n Jo vars x2)
    inductionB :
      (P : JoinSemilatticeTerm ->
           Set) ->
      ((x1 : JoinSemilatticeTerm)
       (x2 : JoinSemilatticeTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : JoinSemilatticeTerm) -> P x
    inductionB p p+l (+L x1 x2) =
      p+l _ _ (inductionB p p+l x1)
        (inductionB p p+l x2)
    inductionCl :
      (A : Set)
      (P : ClJoinSemilatticeTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClJoinSemilatticeTerm A)
       (x2 : ClJoinSemilatticeTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClJoinSemilatticeTerm A) ->
      P x
    inductionCl _ p psing p+cl (sing
                                x1) = psing x1
    inductionCl _ p psing p+cl (+Cl
                                x1
                                x2) =
      p+cl _ _
        (inductionCl _ p psing p+cl x1)
        (inductionCl _ p psing p+cl x2)
    inductionOp :
      (n : Nat)
      (P : OpJoinSemilatticeTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpJoinSemilatticeTerm n)
       (x2 : OpJoinSemilatticeTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpJoinSemilatticeTerm n) ->
      P x
    inductionOp _ p pv p+ol (v x1) =
      pv x1
    inductionOp _ p pv p+ol (+OL
                             x1
                             x2) =
      p+ol _ _
        (inductionOp _ p pv p+ol x1)
        (inductionOp _ p pv p+ol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpJoinSemilatticeTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpJoinSemilatticeTerm2 n
          A)
       (x2 : OpJoinSemilatticeTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpJoinSemilatticeTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p+ol2 (v2
                                         x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 (sing2
                                         x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 (+OL2
                                         x1
                                         x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           x2)
    +L' :
      JoinSemilatticeTerm ->
      JoinSemilatticeTerm ->
      JoinSemilatticeTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      JoinSemilatticeTerm ->
      Staged JoinSemilatticeTerm
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    +Cl' :
      (A : Set) ->
      ClJoinSemilatticeTerm A ->
      ClJoinSemilatticeTerm A ->
      ClJoinSemilatticeTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClJoinSemilatticeTerm A ->
      Staged (ClJoinSemilatticeTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    +OL' :
      (n : Nat) ->
      OpJoinSemilatticeTerm n ->
      OpJoinSemilatticeTerm n ->
      OpJoinSemilatticeTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpJoinSemilatticeTerm n ->
      Staged (OpJoinSemilatticeTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    +OL2' :
      (n : Nat) (A : Set) ->
      OpJoinSemilatticeTerm2 n A ->
      OpJoinSemilatticeTerm2 n A ->
      OpJoinSemilatticeTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpJoinSemilatticeTerm2 n A ->
      Staged
        (OpJoinSemilatticeTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record JoinSemilatticeTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        +T : Repr A -> Repr A -> Repr A
  
  module JoinSemilattice_RingoidSig where
    record JoinSemilattice_RingoidSig
      (A : Set) : Set where
      constructor JoinSemilattice_RingoidSigC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        * : A -> A -> A
    record JoinSemilattice_RingoidSigSig
      (AS : Set) : Set where
      constructor JoinSemilattice_RingoidSigSigSigC
      field
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
    record JoinSemilattice_RingoidSigProd
      (AP : Set) : Set where
      constructor JoinSemilattice_RingoidSigProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
    record JoinSemilattice_RingoidSigHom
      (A1 : Set) (A2 : Set)
      (Jo1 : JoinSemilattice_RingoidSig
         A1)
      (Jo2 : JoinSemilattice_RingoidSig
         A2) : Set where
      constructor JoinSemilattice_RingoidSigHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Jo1 x1 x2) ==
            + Jo2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Jo1 x1 x2) ==
            * Jo2 (hom x1) (hom x2)
    record JoinSemilattice_RingoidSigRelInterp
      (A1 : Set) (A2 : Set)
      (Jo1 : JoinSemilattice_RingoidSig
         A1)
      (Jo2 : JoinSemilattice_RingoidSig
         A2) : Set where
      constructor JoinSemilattice_RingoidSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Jo1 x1 x2)
            (+ Jo2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Jo1 x1 x2)
            (* Jo2 y1 y2)
    data JoinSemilattice_RingoidSigTerm
      : Set where
      +L :
        JoinSemilattice_RingoidSigTerm ->
        JoinSemilattice_RingoidSigTerm ->
        JoinSemilattice_RingoidSigTerm
      *L :
        JoinSemilattice_RingoidSigTerm ->
        JoinSemilattice_RingoidSigTerm ->
        JoinSemilattice_RingoidSigTerm
    data ClJoinSemilattice_RingoidSigTerm
      (A : Set) : Set where
      sing :
        A ->
        ClJoinSemilattice_RingoidSigTerm
          A
      +Cl :
        ClJoinSemilattice_RingoidSigTerm
          A ->
        ClJoinSemilattice_RingoidSigTerm
          A ->
        ClJoinSemilattice_RingoidSigTerm
          A
      *Cl :
        ClJoinSemilattice_RingoidSigTerm
          A ->
        ClJoinSemilattice_RingoidSigTerm
          A ->
        ClJoinSemilattice_RingoidSigTerm
          A
    data OpJoinSemilattice_RingoidSigTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpJoinSemilattice_RingoidSigTerm
          n
      +OL :
        OpJoinSemilattice_RingoidSigTerm
          n ->
        OpJoinSemilattice_RingoidSigTerm
          n ->
        OpJoinSemilattice_RingoidSigTerm
          n
      *OL :
        OpJoinSemilattice_RingoidSigTerm
          n ->
        OpJoinSemilattice_RingoidSigTerm
          n ->
        OpJoinSemilattice_RingoidSigTerm
          n
    data OpJoinSemilattice_RingoidSigTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpJoinSemilattice_RingoidSigTerm2
          n
          A
      sing2 :
        A ->
        OpJoinSemilattice_RingoidSigTerm2
          n
          A
      +OL2 :
        OpJoinSemilattice_RingoidSigTerm2
          n
          A ->
        OpJoinSemilattice_RingoidSigTerm2
          n
          A ->
        OpJoinSemilattice_RingoidSigTerm2
          n
          A
      *OL2 :
        OpJoinSemilattice_RingoidSigTerm2
          n
          A ->
        OpJoinSemilattice_RingoidSigTerm2
          n
          A ->
        OpJoinSemilattice_RingoidSigTerm2
          n
          A
    simplifyB :
      JoinSemilattice_RingoidSigTerm ->
      JoinSemilattice_RingoidSigTerm
    simplifyB (+L x x) = x
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClJoinSemilattice_RingoidSigTerm
        A ->
      ClJoinSemilattice_RingoidSigTerm
        A
    simplifyCl _ (+Cl x x) = x
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpJoinSemilattice_RingoidSigTerm
        n ->
      OpJoinSemilattice_RingoidSigTerm
        n
    simplifyOp _ (+OL x x) = x
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpJoinSemilattice_RingoidSigTerm2
        n
        A ->
      OpJoinSemilattice_RingoidSigTerm2
        n
        A
    simplifyOpE _ _ (+OL2 x x) = x
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      JoinSemilattice_RingoidSig A ->
      JoinSemilattice_RingoidSigTerm ->
      A
    evalB _ Jo (+L x1 x2) =
      + Jo (evalB _ Jo x1)
        (evalB _ Jo x2)
    evalB _ Jo (*L x1 x2) =
      * Jo (evalB _ Jo x1)
        (evalB _ Jo x2)
    evalCl :
      (A : Set) ->
      JoinSemilattice_RingoidSig A ->
      ClJoinSemilattice_RingoidSigTerm
        A -> A
    evalCl _ Jo (sing x1) = x1
    evalCl _ Jo (+Cl x1 x2) =
      + Jo (evalCl _ Jo x1)
        (evalCl _ Jo x2)
    evalCl _ Jo (*Cl x1 x2) =
      * Jo (evalCl _ Jo x1)
        (evalCl _ Jo x2)
    evalOp :
      (A : Set) (n : Nat) ->
      JoinSemilattice_RingoidSig A ->
      Vec A n ->
      OpJoinSemilattice_RingoidSigTerm
        n -> A
    evalOp _ n Jo vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Jo vars (+OL x1 x2) =
      + Jo (evalOp _ n Jo vars x1)
        (evalOp _ n Jo vars x2)
    evalOp _ n Jo vars (*OL x1 x2) =
      * Jo (evalOp _ n Jo vars x1)
        (evalOp _ n Jo vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      JoinSemilattice_RingoidSig A ->
      Vec A n ->
      OpJoinSemilattice_RingoidSigTerm2
        n
        A -> A
    evalOpE _ n Jo vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Jo vars (sing2 x1) =
      x1
    evalOpE _ n Jo vars (+OL2
                         x1
                         x2) =
      + Jo (evalOpE _ n Jo vars x1)
        (evalOpE _ n Jo vars x2)
    evalOpE _ n Jo vars (*OL2
                         x1
                         x2) =
      * Jo (evalOpE _ n Jo vars x1)
        (evalOpE _ n Jo vars x2)
    inductionB :
      (P : JoinSemilattice_RingoidSigTerm ->
           Set) ->
      ((x1 : JoinSemilattice_RingoidSigTerm)
       (x2 : JoinSemilattice_RingoidSigTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      ((x1 : JoinSemilattice_RingoidSigTerm)
       (x2 : JoinSemilattice_RingoidSigTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      (x : JoinSemilattice_RingoidSigTerm) ->
      P x
    inductionB p p+l p*l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p+l p*l x1)
        (inductionB p p+l p*l x2)
    inductionB p p+l p*l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p+l p*l x1)
        (inductionB p p+l p*l x2)
    inductionCl :
      (A : Set)
      (P : ClJoinSemilattice_RingoidSigTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClJoinSemilattice_RingoidSigTerm
          A)
       (x2 : ClJoinSemilattice_RingoidSigTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      ((x1 : ClJoinSemilattice_RingoidSigTerm
          A)
       (x2 : ClJoinSemilattice_RingoidSigTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      (x : ClJoinSemilattice_RingoidSigTerm
         A) -> P x
    inductionCl _ p psing p+cl p*cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p+cl p*cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p+cl p*cl
           x1)
        (inductionCl _ p psing p+cl p*cl
           x2)
    inductionCl _ p psing p+cl p*cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p+cl p*cl
           x1)
        (inductionCl _ p psing p+cl p*cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpJoinSemilattice_RingoidSigTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpJoinSemilattice_RingoidSigTerm
          n)
       (x2 : OpJoinSemilattice_RingoidSigTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      ((x1 : OpJoinSemilattice_RingoidSigTerm
          n)
       (x2 : OpJoinSemilattice_RingoidSigTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      (x : OpJoinSemilattice_RingoidSigTerm
         n) -> P x
    inductionOp _ p pv p+ol p*ol (v
                                  x1) = pv x1
    inductionOp _ p pv p+ol p*ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p+ol p*ol
           x1)
        (inductionOp _ p pv p+ol p*ol
           x2)
    inductionOp _ p pv p+ol p*ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p+ol p*ol
           x1)
        (inductionOp _ p pv p+ol p*ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpJoinSemilattice_RingoidSigTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpJoinSemilattice_RingoidSigTerm2
          n
          A)
       (x2 : OpJoinSemilattice_RingoidSigTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      ((x1 : OpJoinSemilattice_RingoidSigTerm2
          n
          A)
       (x2 : OpJoinSemilattice_RingoidSigTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      (x : OpJoinSemilattice_RingoidSigTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p+ol2 p*ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 p*ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 p*ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p*ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p+ol2 p*ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p*ol2
           x2)
    +L' :
      JoinSemilattice_RingoidSigTerm ->
      JoinSemilattice_RingoidSigTerm ->
      JoinSemilattice_RingoidSigTerm
    +L' x1 x2 = +L x1 x2
    *L' :
      JoinSemilattice_RingoidSigTerm ->
      JoinSemilattice_RingoidSigTerm ->
      JoinSemilattice_RingoidSigTerm
    *L' x1 x2 = *L x1 x2
    stageB :
      JoinSemilattice_RingoidSigTerm ->
      Staged
        JoinSemilattice_RingoidSigTerm
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    +Cl' :
      (A : Set) ->
      ClJoinSemilattice_RingoidSigTerm
        A ->
      ClJoinSemilattice_RingoidSigTerm
        A ->
      ClJoinSemilattice_RingoidSigTerm
        A
    +Cl' _ x1 x2 = +Cl x1 x2
    *Cl' :
      (A : Set) ->
      ClJoinSemilattice_RingoidSigTerm
        A ->
      ClJoinSemilattice_RingoidSigTerm
        A ->
      ClJoinSemilattice_RingoidSigTerm
        A
    *Cl' _ x1 x2 = *Cl x1 x2
    stageCl :
      (A : Set) ->
      ClJoinSemilattice_RingoidSigTerm
        A ->
      Staged
        (ClJoinSemilattice_RingoidSigTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    +OL' :
      (n : Nat) ->
      OpJoinSemilattice_RingoidSigTerm
        n ->
      OpJoinSemilattice_RingoidSigTerm
        n ->
      OpJoinSemilattice_RingoidSigTerm
        n
    +OL' _ x1 x2 = +OL x1 x2
    *OL' :
      (n : Nat) ->
      OpJoinSemilattice_RingoidSigTerm
        n ->
      OpJoinSemilattice_RingoidSigTerm
        n ->
      OpJoinSemilattice_RingoidSigTerm
        n
    *OL' _ x1 x2 = *OL x1 x2
    stageOp :
      (n : Nat) ->
      OpJoinSemilattice_RingoidSigTerm
        n ->
      Staged
        (OpJoinSemilattice_RingoidSigTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    +OL2' :
      (n : Nat) (A : Set) ->
      OpJoinSemilattice_RingoidSigTerm2
        n
        A ->
      OpJoinSemilattice_RingoidSigTerm2
        n
        A ->
      OpJoinSemilattice_RingoidSigTerm2
        n
        A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    *OL2' :
      (n : Nat) (A : Set) ->
      OpJoinSemilattice_RingoidSigTerm2
        n
        A ->
      OpJoinSemilattice_RingoidSigTerm2
        n
        A ->
      OpJoinSemilattice_RingoidSigTerm2
        n
        A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpJoinSemilattice_RingoidSigTerm2
        n
        A ->
      Staged
        (OpJoinSemilattice_RingoidSigTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record JoinSemilattice_RingoidSigTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        +T : Repr A -> Repr A -> Repr A
        *T : Repr A -> Repr A -> Repr A
  
  module Kei where
    record Kei (A : Set) : Set where
      constructor KeiC
      field
        |> : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        idempotent_|> :
          (x : A) -> |> x x == x
        rightSelfInverse_|> :
          (x : A) (y : A) ->
          |> (|> x y) y == x
    record KeiSig
      (AS : Set) : Set where
      constructor KeiSigSigC
      field
        |>S : AS -> AS -> AS
    record KeiProd
      (AP : Set) : Set where
      constructor KeiProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
        rightSelfInverse_|>P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          |>P (|>P xP yP) yP == xP
    record KeiHom
      (A1 : Set) (A2 : Set)
      (Ke1 : Kei A1)
      (Ke2 : Kei A2) : Set where
      constructor KeiHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ke1 x1 x2) ==
            |> Ke2 (hom x1) (hom x2)
    record KeiRelInterp
      (A1 : Set) (A2 : Set)
      (Ke1 : Kei A1)
      (Ke2 : Kei A2) : Set where
      constructor KeiRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ke1 x1 x2)
            (|> Ke2 y1 y2)
    data KeiTerm : Set where
      |>L :
        KeiTerm -> KeiTerm -> KeiTerm
    data ClKeiTerm
      (A : Set) : Set where
      sing : A -> ClKeiTerm A
      |>Cl :
        ClKeiTerm A ->
        ClKeiTerm A -> ClKeiTerm A
    data OpKeiTerm
      (n : Nat) : Set where
      v : Fin n -> OpKeiTerm n
      |>OL :
        OpKeiTerm n ->
        OpKeiTerm n -> OpKeiTerm n
    data OpKeiTerm2
      (n : Nat) (A : Set) : Set where
      v2 : Fin n -> OpKeiTerm2 n A
      sing2 : A -> OpKeiTerm2 n A
      |>OL2 :
        OpKeiTerm2 n A ->
        OpKeiTerm2 n A -> OpKeiTerm2 n A
    simplifyB : KeiTerm -> KeiTerm
    simplifyB (|>L
               (|>L x y)
               (|>L x z)) = |>L x (|>L y z)
    simplifyB (|>L x x) = x
    simplifyB (|>L (|>L x y) y) = x
    simplifyB (|>L x1 x2) =
      |>L (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClKeiTerm A -> ClKeiTerm A
    simplifyCl _ (|>Cl
                  (|>Cl x y)
                  (|>Cl x z)) = |>Cl x (|>Cl y z)
    simplifyCl _ (|>Cl x x) = x
    simplifyCl _ (|>Cl
                  (|>Cl x y)
                  y) = x
    simplifyCl _ (|>Cl x1 x2) =
      |>Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpKeiTerm n -> OpKeiTerm n
    simplifyOp _ (|>OL
                  (|>OL x y)
                  (|>OL x z)) = |>OL x (|>OL y z)
    simplifyOp _ (|>OL x x) = x
    simplifyOp _ (|>OL
                  (|>OL x y)
                  y) = x
    simplifyOp _ (|>OL x1 x2) =
      |>OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpKeiTerm2 n A -> OpKeiTerm2 n A
    simplifyOpE _ _ (|>OL2
                     (|>OL2 x y)
                     (|>OL2 x z)) =
      |>OL2 x (|>OL2 y z)
    simplifyOpE _ _ (|>OL2 x x) = x
    simplifyOpE _ _ (|>OL2
                     (|>OL2 x y)
                     y) = x
    simplifyOpE _ _ (|>OL2 x1 x2) =
      |>OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Kei A -> KeiTerm -> A
    evalB _ Ke (|>L x1 x2) =
      |> Ke (evalB _ Ke x1)
        (evalB _ Ke x2)
    evalCl :
      (A : Set) ->
      Kei A -> ClKeiTerm A -> A
    evalCl _ Ke (sing x1) = x1
    evalCl _ Ke (|>Cl x1 x2) =
      |> Ke (evalCl _ Ke x1)
        (evalCl _ Ke x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Kei A ->
      Vec A n -> OpKeiTerm n -> A
    evalOp _ n Ke vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ke vars (|>OL
                        x1
                        x2) =
      |> Ke (evalOp _ n Ke vars x1)
        (evalOp _ n Ke vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Kei A ->
      Vec A n -> OpKeiTerm2 n A -> A
    evalOpE _ n Ke vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ke vars (sing2 x1) =
      x1
    evalOpE _ n Ke vars (|>OL2
                         x1
                         x2) =
      |> Ke (evalOpE _ n Ke vars x1)
        (evalOpE _ n Ke vars x2)
    inductionB :
      (P : KeiTerm -> Set) ->
      ((x1 : KeiTerm)
       (x2 : KeiTerm) ->
       P x1 ->
       P x2 -> P (|>L x1 x2)) ->
      (x : KeiTerm) -> P x
    inductionB p p|>l (|>L x1 x2) =
      p|>l _ _ (inductionB p p|>l x1)
        (inductionB p p|>l x2)
    inductionCl :
      (A : Set)
      (P : ClKeiTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClKeiTerm A)
       (x2 : ClKeiTerm A) ->
       P x1 ->
       P x2 -> P (|>Cl x1 x2)) ->
      (x : ClKeiTerm A) -> P x
    inductionCl _ p psing p|>cl (sing
                                 x1) = psing x1
    inductionCl _ p psing p|>cl (|>Cl
                                 x1
                                 x2) =
      p|>cl _ _
        (inductionCl _ p psing p|>cl x1)
        (inductionCl _ p psing p|>cl x2)
    inductionOp :
      (n : Nat)
      (P : OpKeiTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpKeiTerm n)
       (x2 : OpKeiTerm n) ->
       P x1 ->
       P x2 -> P (|>OL x1 x2)) ->
      (x : OpKeiTerm n) -> P x
    inductionOp _ p pv p|>ol (v
                              x1) = pv x1
    inductionOp _ p pv p|>ol (|>OL
                              x1
                              x2) =
      p|>ol _ _
        (inductionOp _ p pv p|>ol x1)
        (inductionOp _ p pv p|>ol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpKeiTerm2 n A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpKeiTerm2 n A)
       (x2 : OpKeiTerm2 n A) ->
       P x1 ->
       P x2 -> P (|>OL2 x1 x2)) ->
      (x : OpKeiTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 p|>ol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 (|>OL2
                                          x1
                                          x2) =
      p|>ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           x2)
    |>L' :
      KeiTerm -> KeiTerm -> KeiTerm
    |>L' x1 x2 = |>L x1 x2
    stageB :
      KeiTerm -> Staged KeiTerm
    stageB (|>L x1 x2) =
      stage2 _ _ _ |>L'
        (codeLift2 _ _ _ |>L')
        (stageB x1)
        (stageB x2)
    |>Cl' :
      (A : Set) ->
      ClKeiTerm A ->
      ClKeiTerm A -> ClKeiTerm A
    |>Cl' _ x1 x2 = |>Cl x1 x2
    stageCl :
      (A : Set) ->
      ClKeiTerm A ->
      Staged (ClKeiTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (|>Cl x1 x2) =
      stage2 _ _ _ (|>Cl' _)
        (codeLift2 _ _ _ (|>Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    |>OL' :
      (n : Nat) ->
      OpKeiTerm n ->
      OpKeiTerm n -> OpKeiTerm n
    |>OL' _ x1 x2 = |>OL x1 x2
    stageOp :
      (n : Nat) ->
      OpKeiTerm n ->
      Staged (OpKeiTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (|>OL x1 x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    |>OL2' :
      (n : Nat) (A : Set) ->
      OpKeiTerm2 n A ->
      OpKeiTerm2 n A -> OpKeiTerm2 n A
    |>OL2' _ _ x1 x2 = |>OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpKeiTerm2 n A ->
      Staged (OpKeiTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (|>OL2 x1 x2) =
      stage2 _ _ _ (|>OL2' _ _)
        (codeLift2 _ _ _ (|>OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record KeiTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        |>T : Repr A -> Repr A -> Repr A
  
  module Lattice where
    record Lattice
      (A : Set) : Set where
      constructor LatticeC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
    record LatticeSig
      (AS : Set) : Set where
      constructor LatticeSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record LatticeProd
      (AP : Set) : Set where
      constructor LatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
    record LatticeHom
      (A1 : Set) (A2 : Set)
      (La1 : Lattice A1)
      (La2 : Lattice A2) : Set where
      constructor LatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* La1 x1 x2) ==
            * La2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ La1 x1 x2) ==
            + La2 (hom x1) (hom x2)
    record LatticeRelInterp
      (A1 : Set) (A2 : Set)
      (La1 : Lattice A1)
      (La2 : Lattice A2) : Set where
      constructor LatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* La1 x1 x2)
            (* La2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ La1 x1 x2)
            (+ La2 y1 y2)
    data LatticeTerm : Set where
      *L :
        LatticeTerm ->
        LatticeTerm -> LatticeTerm
      +L :
        LatticeTerm ->
        LatticeTerm -> LatticeTerm
    data ClLatticeTerm
      (A : Set) : Set where
      sing : A -> ClLatticeTerm A
      *Cl :
        ClLatticeTerm A ->
        ClLatticeTerm A ->
        ClLatticeTerm A
      +Cl :
        ClLatticeTerm A ->
        ClLatticeTerm A ->
        ClLatticeTerm A
    data OpLatticeTerm
      (n : Nat) : Set where
      v : Fin n -> OpLatticeTerm n
      *OL :
        OpLatticeTerm n ->
        OpLatticeTerm n ->
        OpLatticeTerm n
      +OL :
        OpLatticeTerm n ->
        OpLatticeTerm n ->
        OpLatticeTerm n
    data OpLatticeTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpLatticeTerm2 n A
      sing2 : A -> OpLatticeTerm2 n A
      *OL2 :
        OpLatticeTerm2 n A ->
        OpLatticeTerm2 n A ->
        OpLatticeTerm2 n A
      +OL2 :
        OpLatticeTerm2 n A ->
        OpLatticeTerm2 n A ->
        OpLatticeTerm2 n A
    simplifyB :
      LatticeTerm -> LatticeTerm
    simplifyB (*L x x) = x
    simplifyB (+L x x) = x
    simplifyB (*L x (+L x y)) = x
    simplifyB (+L x (*L x y)) = x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLatticeTerm A ->
      ClLatticeTerm A
    simplifyCl _ (*Cl x x) = x
    simplifyCl _ (+Cl x x) = x
    simplifyCl _ (*Cl x (+Cl x y)) =
      x
    simplifyCl _ (+Cl x (*Cl x y)) =
      x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLatticeTerm n ->
      OpLatticeTerm n
    simplifyOp _ (*OL x x) = x
    simplifyOp _ (+OL x x) = x
    simplifyOp _ (*OL x (+OL x y)) =
      x
    simplifyOp _ (+OL x (*OL x y)) =
      x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLatticeTerm2 n A ->
      OpLatticeTerm2 n A
    simplifyOpE _ _ (*OL2 x x) = x
    simplifyOpE _ _ (+OL2 x x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (+OL2 x y)) = x
    simplifyOpE _ _ (+OL2
                     x
                     (*OL2 x y)) = x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Lattice A -> LatticeTerm -> A
    evalB _ La (*L x1 x2) =
      * La (evalB _ La x1)
        (evalB _ La x2)
    evalB _ La (+L x1 x2) =
      + La (evalB _ La x1)
        (evalB _ La x2)
    evalCl :
      (A : Set) ->
      Lattice A ->
      ClLatticeTerm A -> A
    evalCl _ La (sing x1) = x1
    evalCl _ La (*Cl x1 x2) =
      * La (evalCl _ La x1)
        (evalCl _ La x2)
    evalCl _ La (+Cl x1 x2) =
      + La (evalCl _ La x1)
        (evalCl _ La x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Lattice A ->
      Vec A n -> OpLatticeTerm n -> A
    evalOp _ n La vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n La vars (*OL x1 x2) =
      * La (evalOp _ n La vars x1)
        (evalOp _ n La vars x2)
    evalOp _ n La vars (+OL x1 x2) =
      + La (evalOp _ n La vars x1)
        (evalOp _ n La vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Lattice A ->
      Vec A n ->
      OpLatticeTerm2 n A -> A
    evalOpE _ n La vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n La vars (sing2 x1) =
      x1
    evalOpE _ n La vars (*OL2
                         x1
                         x2) =
      * La (evalOpE _ n La vars x1)
        (evalOpE _ n La vars x2)
    evalOpE _ n La vars (+OL2
                         x1
                         x2) =
      + La (evalOpE _ n La vars x1)
        (evalOpE _ n La vars x2)
    inductionB :
      (P : LatticeTerm -> Set) ->
      ((x1 : LatticeTerm)
       (x2 : LatticeTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : LatticeTerm)
       (x2 : LatticeTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : LatticeTerm) -> P x
    inductionB p p*l p+l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionB p p*l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClLatticeTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClLatticeTerm A)
       (x2 : ClLatticeTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClLatticeTerm A)
       (x2 : ClLatticeTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClLatticeTerm A) -> P x
    inductionCl _ p psing p*cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p*cl p+cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionCl _ p psing p*cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpLatticeTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpLatticeTerm n)
       (x2 : OpLatticeTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpLatticeTerm n)
       (x2 : OpLatticeTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpLatticeTerm n) -> P x
    inductionOp _ p pv p*ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p*ol p+ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOp _ p pv p*ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLatticeTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpLatticeTerm2 n A)
       (x2 : OpLatticeTerm2 n A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpLatticeTerm2 n A)
       (x2 : OpLatticeTerm2 n A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpLatticeTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    *L' :
      LatticeTerm ->
      LatticeTerm -> LatticeTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      LatticeTerm ->
      LatticeTerm -> LatticeTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      LatticeTerm ->
      Staged LatticeTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClLatticeTerm A ->
      ClLatticeTerm A ->
      ClLatticeTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClLatticeTerm A ->
      ClLatticeTerm A ->
      ClLatticeTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClLatticeTerm A ->
      Staged (ClLatticeTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpLatticeTerm n ->
      OpLatticeTerm n ->
      OpLatticeTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpLatticeTerm n ->
      OpLatticeTerm n ->
      OpLatticeTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpLatticeTerm n ->
      Staged (OpLatticeTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpLatticeTerm2 n A ->
      OpLatticeTerm2 n A ->
      OpLatticeTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpLatticeTerm2 n A ->
      OpLatticeTerm2 n A ->
      OpLatticeTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLatticeTerm2 n A ->
      Staged (OpLatticeTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LatticeTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module Left0 where
    record Left0
      (A : Set) : Set where
      constructor Left0C
      field
        0 : A
        op : A -> A -> A
        leftZero_op_0 :
          (x : A) -> op 0 x == 0
    record Left0Sig
      (AS : Set) : Set where
      constructor Left0SigSigC
      field
        0S : AS
        opS : AS -> AS -> AS
    record Left0Prod
      (AP : Set) : Set where
      constructor Left0ProdC
      field
        0P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          opP 0P xP == 0P
    record Left0Hom
      (A1 : Set) (A2 : Set)
      (Le1 : Left0 A1)
      (Le2 : Left0 A2) : Set where
      constructor Left0HomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Le1) == 0 Le2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record Left0RelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : Left0 A1)
      (Le2 : Left0 A2) : Set where
      constructor Left0RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Le1) (0 Le2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data Left0LTerm : Set where
      0L : Left0LTerm
      opL :
        Left0LTerm ->
        Left0LTerm -> Left0LTerm
    data ClLeft0ClTerm
      (A : Set) : Set where
      sing : A -> ClLeft0ClTerm A
      0Cl : ClLeft0ClTerm A
      opCl :
        ClLeft0ClTerm A ->
        ClLeft0ClTerm A ->
        ClLeft0ClTerm A
    data OpLeft0OLTerm
      (n : Nat) : Set where
      v : Fin n -> OpLeft0OLTerm n
      0OL : OpLeft0OLTerm n
      opOL :
        OpLeft0OLTerm n ->
        OpLeft0OLTerm n ->
        OpLeft0OLTerm n
    data OpLeft0OL2Term2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpLeft0OL2Term2 n A
      sing2 : A -> OpLeft0OL2Term2 n A
      0OL2 : OpLeft0OL2Term2 n A
      opOL2 :
        OpLeft0OL2Term2 n A ->
        OpLeft0OL2Term2 n A ->
        OpLeft0OL2Term2 n A
    simplifyB :
      Left0LTerm -> Left0LTerm
    simplifyB (opL (0L) x) = 0L
    simplifyB (0L) = 0L
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLeft0ClTerm A ->
      ClLeft0ClTerm A
    simplifyCl _ (opCl (0Cl) x) =
      0Cl
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeft0OLTerm n ->
      OpLeft0OLTerm n
    simplifyOp _ (opOL (0OL) x) =
      0OL
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeft0OL2Term2 n A ->
      OpLeft0OL2Term2 n A
    simplifyOpE _ _ (opOL2
                     (0OL2)
                     x) = 0OL2
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Left0 A -> Left0LTerm -> A
    evalB _ Le (0L) = 0 Le
    evalB _ Le (opL x1 x2) =
      op Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalCl :
      (A : Set) ->
      Left0 A -> ClLeft0ClTerm A -> A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (0Cl) = 0 Le
    evalCl _ Le (opCl x1 x2) =
      op Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Left0 A ->
      Vec A n -> OpLeft0OLTerm n -> A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (0OL) = 0 Le
    evalOp _ n Le vars (opOL
                        x1
                        x2) =
      op Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Left0 A ->
      Vec A n ->
      OpLeft0OL2Term2 n A -> A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (0OL2) =
      0 Le
    evalOpE _ n Le vars (opOL2
                         x1
                         x2) =
      op Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    inductionB :
      (P : Left0LTerm -> Set) ->
      P 0L ->
      ((x1 : Left0LTerm)
       (x2 : Left0LTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : Left0LTerm) -> P x
    inductionB p p0l popl (0L) = p0l
    inductionB p p0l popl (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p p0l popl x1)
        (inductionB p p0l popl x2)
    inductionCl :
      (A : Set)
      (P : ClLeft0ClTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 0Cl ->
      ((x1 : ClLeft0ClTerm A)
       (x2 : ClLeft0ClTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClLeft0ClTerm A) -> P x
    inductionCl _ p psing p0cl popcl (sing
                                      x1) = psing x1
    inductionCl _ p psing p0cl popcl (0Cl) =
      p0cl
    inductionCl _ p psing p0cl popcl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing p0cl
           popcl
           x1)
        (inductionCl _ p psing p0cl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpLeft0OLTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 0OL ->
      ((x1 : OpLeft0OLTerm n)
       (x2 : OpLeft0OLTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpLeft0OLTerm n) -> P x
    inductionOp _ p pv p0ol popol (v
                                   x1) = pv x1
    inductionOp _ p pv p0ol popol (0OL) =
      p0ol
    inductionOp _ p pv p0ol popol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv p0ol popol
           x1)
        (inductionOp _ p pv p0ol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeft0OL2Term2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 0OL2 ->
      ((x1 : OpLeft0OL2Term2 n A)
       (x2 : OpLeft0OL2Term2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpLeft0OL2Term2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 p0ol2 popol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 popol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 popol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p0ol2 popol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           popol2
           x2)
    0L' : Left0LTerm
    0L' = 0L
    opL' :
      Left0LTerm ->
      Left0LTerm -> Left0LTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      Left0LTerm -> Staged Left0LTerm
    stageB (0L) = Now 0L
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    0Cl' :
      (A : Set) -> ClLeft0ClTerm A
    0Cl' _ = 0Cl
    opCl' :
      (A : Set) ->
      ClLeft0ClTerm A ->
      ClLeft0ClTerm A ->
      ClLeft0ClTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClLeft0ClTerm A ->
      Staged (ClLeft0ClTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    0OL' :
      (n : Nat) -> OpLeft0OLTerm n
    0OL' _ = 0OL
    opOL' :
      (n : Nat) ->
      OpLeft0OLTerm n ->
      OpLeft0OLTerm n ->
      OpLeft0OLTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpLeft0OLTerm n ->
      Staged (OpLeft0OLTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (0OL) = Now 0OL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    0OL2' :
      (n : Nat) (A : Set) ->
      OpLeft0OL2Term2 n A
    0OL2' _ _ = 0OL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpLeft0OL2Term2 n A ->
      OpLeft0OL2Term2 n A ->
      OpLeft0OL2Term2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeft0OL2Term2 n A ->
      Staged (OpLeft0OL2Term2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record Left0Tagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        0T : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module LeftAbsorption where
    record LeftAbsorption
      (A : Set) : Set where
      constructor LeftAbsorptionC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
    record LeftAbsorptionSig
      (AS : Set) : Set where
      constructor LeftAbsorptionSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record LeftAbsorptionProd
      (AP : Set) : Set where
      constructor LeftAbsorptionProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
    record LeftAbsorptionHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftAbsorption A1)
      (Le2 : LeftAbsorption A2) :
      Set where
      constructor LeftAbsorptionHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Le1 x1 x2) ==
            * Le2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Le1 x1 x2) ==
            + Le2 (hom x1) (hom x2)
    record LeftAbsorptionRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftAbsorption A1)
      (Le2 : LeftAbsorption A2) :
      Set where
      constructor LeftAbsorptionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Le1 x1 x2)
            (* Le2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Le1 x1 x2)
            (+ Le2 y1 y2)
    data LeftAbsorptionTerm
      : Set where
      *L :
        LeftAbsorptionTerm ->
        LeftAbsorptionTerm ->
        LeftAbsorptionTerm
      +L :
        LeftAbsorptionTerm ->
        LeftAbsorptionTerm ->
        LeftAbsorptionTerm
    data ClLeftAbsorptionTerm
      (A : Set) : Set where
      sing :
        A -> ClLeftAbsorptionTerm A
      *Cl :
        ClLeftAbsorptionTerm A ->
        ClLeftAbsorptionTerm A ->
        ClLeftAbsorptionTerm A
      +Cl :
        ClLeftAbsorptionTerm A ->
        ClLeftAbsorptionTerm A ->
        ClLeftAbsorptionTerm A
    data OpLeftAbsorptionTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpLeftAbsorptionTerm n
      *OL :
        OpLeftAbsorptionTerm n ->
        OpLeftAbsorptionTerm n ->
        OpLeftAbsorptionTerm n
      +OL :
        OpLeftAbsorptionTerm n ->
        OpLeftAbsorptionTerm n ->
        OpLeftAbsorptionTerm n
    data OpLeftAbsorptionTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpLeftAbsorptionTerm2 n A
      sing2 :
        A -> OpLeftAbsorptionTerm2 n A
      *OL2 :
        OpLeftAbsorptionTerm2 n A ->
        OpLeftAbsorptionTerm2 n A ->
        OpLeftAbsorptionTerm2 n A
      +OL2 :
        OpLeftAbsorptionTerm2 n A ->
        OpLeftAbsorptionTerm2 n A ->
        OpLeftAbsorptionTerm2 n A
    simplifyB :
      LeftAbsorptionTerm ->
      LeftAbsorptionTerm
    simplifyB (*L x (+L x y)) = x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLeftAbsorptionTerm A ->
      ClLeftAbsorptionTerm A
    simplifyCl _ (*Cl x (+Cl x y)) =
      x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeftAbsorptionTerm n ->
      OpLeftAbsorptionTerm n
    simplifyOp _ (*OL x (+OL x y)) =
      x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeftAbsorptionTerm2 n A ->
      OpLeftAbsorptionTerm2 n A
    simplifyOpE _ _ (*OL2
                     x
                     (+OL2 x y)) = x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LeftAbsorption A ->
      LeftAbsorptionTerm -> A
    evalB _ Le (*L x1 x2) =
      * Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalB _ Le (+L x1 x2) =
      + Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalCl :
      (A : Set) ->
      LeftAbsorption A ->
      ClLeftAbsorptionTerm A -> A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (*Cl x1 x2) =
      * Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalCl _ Le (+Cl x1 x2) =
      + Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalOp :
      (A : Set) (n : Nat) ->
      LeftAbsorption A ->
      Vec A n ->
      OpLeftAbsorptionTerm n -> A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (*OL x1 x2) =
      * Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOp _ n Le vars (+OL x1 x2) =
      + Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      LeftAbsorption A ->
      Vec A n ->
      OpLeftAbsorptionTerm2 n A -> A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (*OL2
                         x1
                         x2) =
      * Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    evalOpE _ n Le vars (+OL2
                         x1
                         x2) =
      + Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    inductionB :
      (P : LeftAbsorptionTerm ->
           Set) ->
      ((x1 : LeftAbsorptionTerm)
       (x2 : LeftAbsorptionTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : LeftAbsorptionTerm)
       (x2 : LeftAbsorptionTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : LeftAbsorptionTerm) -> P x
    inductionB p p*l p+l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionB p p*l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClLeftAbsorptionTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClLeftAbsorptionTerm A)
       (x2 : ClLeftAbsorptionTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClLeftAbsorptionTerm A)
       (x2 : ClLeftAbsorptionTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClLeftAbsorptionTerm A) ->
      P x
    inductionCl _ p psing p*cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p*cl p+cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionCl _ p psing p*cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpLeftAbsorptionTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpLeftAbsorptionTerm n)
       (x2 : OpLeftAbsorptionTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpLeftAbsorptionTerm n)
       (x2 : OpLeftAbsorptionTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpLeftAbsorptionTerm n) ->
      P x
    inductionOp _ p pv p*ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p*ol p+ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOp _ p pv p*ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeftAbsorptionTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpLeftAbsorptionTerm2 n
          A)
       (x2 : OpLeftAbsorptionTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpLeftAbsorptionTerm2 n
          A)
       (x2 : OpLeftAbsorptionTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpLeftAbsorptionTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    *L' :
      LeftAbsorptionTerm ->
      LeftAbsorptionTerm ->
      LeftAbsorptionTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      LeftAbsorptionTerm ->
      LeftAbsorptionTerm ->
      LeftAbsorptionTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      LeftAbsorptionTerm ->
      Staged LeftAbsorptionTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClLeftAbsorptionTerm A ->
      ClLeftAbsorptionTerm A ->
      ClLeftAbsorptionTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClLeftAbsorptionTerm A ->
      ClLeftAbsorptionTerm A ->
      ClLeftAbsorptionTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClLeftAbsorptionTerm A ->
      Staged (ClLeftAbsorptionTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpLeftAbsorptionTerm n ->
      OpLeftAbsorptionTerm n ->
      OpLeftAbsorptionTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpLeftAbsorptionTerm n ->
      OpLeftAbsorptionTerm n ->
      OpLeftAbsorptionTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpLeftAbsorptionTerm n ->
      Staged (OpLeftAbsorptionTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpLeftAbsorptionTerm2 n A ->
      OpLeftAbsorptionTerm2 n A ->
      OpLeftAbsorptionTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpLeftAbsorptionTerm2 n A ->
      OpLeftAbsorptionTerm2 n A ->
      OpLeftAbsorptionTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeftAbsorptionTerm2 n A ->
      Staged
        (OpLeftAbsorptionTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LeftAbsorptionTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module LeftAbsorptionOp where
    record LeftAbsorptionOp
      (A : Set) : Set where
      constructor LeftAbsorptionOpC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
    record LeftAbsorptionOpSig
      (AS : Set) : Set where
      constructor LeftAbsorptionOpSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record LeftAbsorptionOpProd
      (AP : Set) : Set where
      constructor LeftAbsorptionOpProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
    record LeftAbsorptionOpHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftAbsorptionOp A1)
      (Le2 : LeftAbsorptionOp A2) :
      Set where
      constructor LeftAbsorptionOpHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Le1 x1 x2) ==
            * Le2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Le1 x1 x2) ==
            + Le2 (hom x1) (hom x2)
    record LeftAbsorptionOpRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftAbsorptionOp A1)
      (Le2 : LeftAbsorptionOp A2) :
      Set where
      constructor LeftAbsorptionOpRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Le1 x1 x2)
            (* Le2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Le1 x1 x2)
            (+ Le2 y1 y2)
    data LeftAbsorptionOpTerm
      : Set where
      *L :
        LeftAbsorptionOpTerm ->
        LeftAbsorptionOpTerm ->
        LeftAbsorptionOpTerm
      +L :
        LeftAbsorptionOpTerm ->
        LeftAbsorptionOpTerm ->
        LeftAbsorptionOpTerm
    data ClLeftAbsorptionOpTerm
      (A : Set) : Set where
      sing :
        A -> ClLeftAbsorptionOpTerm A
      *Cl :
        ClLeftAbsorptionOpTerm A ->
        ClLeftAbsorptionOpTerm A ->
        ClLeftAbsorptionOpTerm A
      +Cl :
        ClLeftAbsorptionOpTerm A ->
        ClLeftAbsorptionOpTerm A ->
        ClLeftAbsorptionOpTerm A
    data OpLeftAbsorptionOpTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpLeftAbsorptionOpTerm n
      *OL :
        OpLeftAbsorptionOpTerm n ->
        OpLeftAbsorptionOpTerm n ->
        OpLeftAbsorptionOpTerm n
      +OL :
        OpLeftAbsorptionOpTerm n ->
        OpLeftAbsorptionOpTerm n ->
        OpLeftAbsorptionOpTerm n
    data OpLeftAbsorptionOpTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpLeftAbsorptionOpTerm2 n A
      sing2 :
        A -> OpLeftAbsorptionOpTerm2 n A
      *OL2 :
        OpLeftAbsorptionOpTerm2 n A ->
        OpLeftAbsorptionOpTerm2 n A ->
        OpLeftAbsorptionOpTerm2 n A
      +OL2 :
        OpLeftAbsorptionOpTerm2 n A ->
        OpLeftAbsorptionOpTerm2 n A ->
        OpLeftAbsorptionOpTerm2 n A
    simplifyB :
      LeftAbsorptionOpTerm ->
      LeftAbsorptionOpTerm
    simplifyB (+L x (*L x y)) = x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLeftAbsorptionOpTerm A ->
      ClLeftAbsorptionOpTerm A
    simplifyCl _ (+Cl x (*Cl x y)) =
      x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeftAbsorptionOpTerm n ->
      OpLeftAbsorptionOpTerm n
    simplifyOp _ (+OL x (*OL x y)) =
      x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeftAbsorptionOpTerm2 n A ->
      OpLeftAbsorptionOpTerm2 n A
    simplifyOpE _ _ (+OL2
                     x
                     (*OL2 x y)) = x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LeftAbsorptionOp A ->
      LeftAbsorptionOpTerm -> A
    evalB _ Le (*L x1 x2) =
      * Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalB _ Le (+L x1 x2) =
      + Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalCl :
      (A : Set) ->
      LeftAbsorptionOp A ->
      ClLeftAbsorptionOpTerm A -> A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (*Cl x1 x2) =
      * Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalCl _ Le (+Cl x1 x2) =
      + Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalOp :
      (A : Set) (n : Nat) ->
      LeftAbsorptionOp A ->
      Vec A n ->
      OpLeftAbsorptionOpTerm n -> A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (*OL x1 x2) =
      * Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOp _ n Le vars (+OL x1 x2) =
      + Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      LeftAbsorptionOp A ->
      Vec A n ->
      OpLeftAbsorptionOpTerm2 n A -> A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (*OL2
                         x1
                         x2) =
      * Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    evalOpE _ n Le vars (+OL2
                         x1
                         x2) =
      + Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    inductionB :
      (P : LeftAbsorptionOpTerm ->
           Set) ->
      ((x1 : LeftAbsorptionOpTerm)
       (x2 : LeftAbsorptionOpTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : LeftAbsorptionOpTerm)
       (x2 : LeftAbsorptionOpTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : LeftAbsorptionOpTerm) ->
      P x
    inductionB p p*l p+l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionB p p*l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClLeftAbsorptionOpTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClLeftAbsorptionOpTerm A)
       (x2 : ClLeftAbsorptionOpTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClLeftAbsorptionOpTerm A)
       (x2 : ClLeftAbsorptionOpTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClLeftAbsorptionOpTerm
         A) -> P x
    inductionCl _ p psing p*cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p*cl p+cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionCl _ p psing p*cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpLeftAbsorptionOpTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpLeftAbsorptionOpTerm n)
       (x2 : OpLeftAbsorptionOpTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpLeftAbsorptionOpTerm n)
       (x2 : OpLeftAbsorptionOpTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpLeftAbsorptionOpTerm
         n) -> P x
    inductionOp _ p pv p*ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p*ol p+ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOp _ p pv p*ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeftAbsorptionOpTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpLeftAbsorptionOpTerm2 n
          A)
       (x2 : OpLeftAbsorptionOpTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpLeftAbsorptionOpTerm2 n
          A)
       (x2 : OpLeftAbsorptionOpTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpLeftAbsorptionOpTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    *L' :
      LeftAbsorptionOpTerm ->
      LeftAbsorptionOpTerm ->
      LeftAbsorptionOpTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      LeftAbsorptionOpTerm ->
      LeftAbsorptionOpTerm ->
      LeftAbsorptionOpTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      LeftAbsorptionOpTerm ->
      Staged LeftAbsorptionOpTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClLeftAbsorptionOpTerm A ->
      ClLeftAbsorptionOpTerm A ->
      ClLeftAbsorptionOpTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClLeftAbsorptionOpTerm A ->
      ClLeftAbsorptionOpTerm A ->
      ClLeftAbsorptionOpTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClLeftAbsorptionOpTerm A ->
      Staged
        (ClLeftAbsorptionOpTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpLeftAbsorptionOpTerm n ->
      OpLeftAbsorptionOpTerm n ->
      OpLeftAbsorptionOpTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpLeftAbsorptionOpTerm n ->
      OpLeftAbsorptionOpTerm n ->
      OpLeftAbsorptionOpTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpLeftAbsorptionOpTerm n ->
      Staged
        (OpLeftAbsorptionOpTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpLeftAbsorptionOpTerm2 n A ->
      OpLeftAbsorptionOpTerm2 n A ->
      OpLeftAbsorptionOpTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpLeftAbsorptionOpTerm2 n A ->
      OpLeftAbsorptionOpTerm2 n A ->
      OpLeftAbsorptionOpTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeftAbsorptionOpTerm2 n A ->
      Staged
        (OpLeftAbsorptionOpTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LeftAbsorptionOpTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module LeftBiMagma where
    record LeftBiMagma
      (A : Set) : Set where
      constructor LeftBiMagmaC
      field
        op : A -> A -> A
        linv : A -> A -> A
    record LeftBiMagmaSig
      (AS : Set) : Set where
      constructor LeftBiMagmaSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
    record LeftBiMagmaProd
      (AP : Set) : Set where
      constructor LeftBiMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record LeftBiMagmaHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftBiMagma A1)
      (Le2 : LeftBiMagma A2) :
      Set where
      constructor LeftBiMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Le1 x1 x2) ==
            linv Le2 (hom x1) (hom x2)
    record LeftBiMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftBiMagma A1)
      (Le2 : LeftBiMagma A2) :
      Set where
      constructor LeftBiMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Le1 x1 x2)
            (linv Le2 y1 y2)
    data LeftBiMagmaTerm : Set where
      opL :
        LeftBiMagmaTerm ->
        LeftBiMagmaTerm ->
        LeftBiMagmaTerm
      linvL :
        LeftBiMagmaTerm ->
        LeftBiMagmaTerm ->
        LeftBiMagmaTerm
    data ClLeftBiMagmaTerm
      (A : Set) : Set where
      sing :
        A -> ClLeftBiMagmaTerm A
      opCl :
        ClLeftBiMagmaTerm A ->
        ClLeftBiMagmaTerm A ->
        ClLeftBiMagmaTerm A
      linvCl :
        ClLeftBiMagmaTerm A ->
        ClLeftBiMagmaTerm A ->
        ClLeftBiMagmaTerm A
    data OpLeftBiMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpLeftBiMagmaTerm n
      opOL :
        OpLeftBiMagmaTerm n ->
        OpLeftBiMagmaTerm n ->
        OpLeftBiMagmaTerm n
      linvOL :
        OpLeftBiMagmaTerm n ->
        OpLeftBiMagmaTerm n ->
        OpLeftBiMagmaTerm n
    data OpLeftBiMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpLeftBiMagmaTerm2 n A
      sing2 :
        A -> OpLeftBiMagmaTerm2 n A
      opOL2 :
        OpLeftBiMagmaTerm2 n A ->
        OpLeftBiMagmaTerm2 n A ->
        OpLeftBiMagmaTerm2 n A
      linvOL2 :
        OpLeftBiMagmaTerm2 n A ->
        OpLeftBiMagmaTerm2 n A ->
        OpLeftBiMagmaTerm2 n A
    simplifyB :
      LeftBiMagmaTerm ->
      LeftBiMagmaTerm
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (linvL x1 x2) =
      linvL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLeftBiMagmaTerm A ->
      ClLeftBiMagmaTerm A
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (linvCl x1 x2) =
      linvCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeftBiMagmaTerm n ->
      OpLeftBiMagmaTerm n
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (linvOL x1 x2) =
      linvOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeftBiMagmaTerm2 n A ->
      OpLeftBiMagmaTerm2 n A
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (linvOL2
                     x1
                     x2) =
      linvOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LeftBiMagma A ->
      LeftBiMagmaTerm -> A
    evalB _ Le (opL x1 x2) =
      op Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalB _ Le (linvL x1 x2) =
      linv Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalCl :
      (A : Set) ->
      LeftBiMagma A ->
      ClLeftBiMagmaTerm A -> A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (opCl x1 x2) =
      op Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalCl _ Le (linvCl x1 x2) =
      linv Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalOp :
      (A : Set) (n : Nat) ->
      LeftBiMagma A ->
      Vec A n ->
      OpLeftBiMagmaTerm n -> A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (opOL
                        x1
                        x2) =
      op Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOp _ n Le vars (linvOL
                        x1
                        x2) =
      linv Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      LeftBiMagma A ->
      Vec A n ->
      OpLeftBiMagmaTerm2 n A -> A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (opOL2
                         x1
                         x2) =
      op Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    evalOpE _ n Le vars (linvOL2
                         x1
                         x2) =
      linv Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    inductionB :
      (P : LeftBiMagmaTerm -> Set) ->
      ((x1 : LeftBiMagmaTerm)
       (x2 : LeftBiMagmaTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      ((x1 : LeftBiMagmaTerm)
       (x2 : LeftBiMagmaTerm) ->
       P x1 ->
       P x2 -> P (linvL x1 x2)) ->
      (x : LeftBiMagmaTerm) -> P x
    inductionB p popl plinvl (opL
                              x1
                              x2) =
      popl _ _
        (inductionB p popl plinvl x1)
        (inductionB p popl plinvl x2)
    inductionB p popl plinvl (linvL
                              x1
                              x2) =
      plinvl _ _
        (inductionB p popl plinvl x1)
        (inductionB p popl plinvl x2)
    inductionCl :
      (A : Set)
      (P : ClLeftBiMagmaTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClLeftBiMagmaTerm A)
       (x2 : ClLeftBiMagmaTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      ((x1 : ClLeftBiMagmaTerm A)
       (x2 : ClLeftBiMagmaTerm A) ->
       P x1 ->
       P x2 -> P (linvCl x1 x2)) ->
      (x : ClLeftBiMagmaTerm A) -> P x
    inductionCl _ p psing popcl plinvcl (sing
                                         x1) = psing x1
    inductionCl _ p psing popcl plinvcl (opCl
                                         x1
                                         x2) =
      popcl _ _
        (inductionCl _ p psing popcl
           plinvcl
           x1)
        (inductionCl _ p psing popcl
           plinvcl
           x2)
    inductionCl _ p psing popcl plinvcl (linvCl
                                         x1
                                         x2) =
      plinvcl _ _
        (inductionCl _ p psing popcl
           plinvcl
           x1)
        (inductionCl _ p psing popcl
           plinvcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpLeftBiMagmaTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpLeftBiMagmaTerm n)
       (x2 : OpLeftBiMagmaTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      ((x1 : OpLeftBiMagmaTerm n)
       (x2 : OpLeftBiMagmaTerm n) ->
       P x1 ->
       P x2 -> P (linvOL x1 x2)) ->
      (x : OpLeftBiMagmaTerm n) -> P x
    inductionOp _ p pv popol plinvol (v
                                      x1) = pv x1
    inductionOp _ p pv popol plinvol (opOL
                                      x1
                                      x2) =
      popol _ _
        (inductionOp _ p pv popol
           plinvol
           x1)
        (inductionOp _ p pv popol
           plinvol
           x2)
    inductionOp _ p pv popol plinvol (linvOL
                                      x1
                                      x2) =
      plinvol _ _
        (inductionOp _ p pv popol
           plinvol
           x1)
        (inductionOp _ p pv popol
           plinvol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeftBiMagmaTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpLeftBiMagmaTerm2 n A)
       (x2 : OpLeftBiMagmaTerm2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      ((x1 : OpLeftBiMagmaTerm2 n A)
       (x2 : OpLeftBiMagmaTerm2 n A) ->
       P x1 ->
       P x2 -> P (linvOL2 x1 x2)) ->
      (x : OpLeftBiMagmaTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 (v2
                                                   x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 (sing2
                                                   x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 (opOL2
                                                   x1
                                                   x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 (linvOL2
                                                   x1
                                                   x2) =
      plinvol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           x2)
    opL' :
      LeftBiMagmaTerm ->
      LeftBiMagmaTerm ->
      LeftBiMagmaTerm
    opL' x1 x2 = opL x1 x2
    linvL' :
      LeftBiMagmaTerm ->
      LeftBiMagmaTerm ->
      LeftBiMagmaTerm
    linvL' x1 x2 = linvL x1 x2
    stageB :
      LeftBiMagmaTerm ->
      Staged LeftBiMagmaTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (linvL x1 x2) =
      stage2 _ _ _ linvL'
        (codeLift2 _ _ _ linvL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClLeftBiMagmaTerm A ->
      ClLeftBiMagmaTerm A ->
      ClLeftBiMagmaTerm A
    opCl' _ x1 x2 = opCl x1 x2
    linvCl' :
      (A : Set) ->
      ClLeftBiMagmaTerm A ->
      ClLeftBiMagmaTerm A ->
      ClLeftBiMagmaTerm A
    linvCl' _ x1 x2 = linvCl x1 x2
    stageCl :
      (A : Set) ->
      ClLeftBiMagmaTerm A ->
      Staged (ClLeftBiMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (linvCl x1 x2) =
      stage2 _ _ _ (linvCl' _)
        (codeLift2 _ _ _ (linvCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpLeftBiMagmaTerm n ->
      OpLeftBiMagmaTerm n ->
      OpLeftBiMagmaTerm n
    opOL' _ x1 x2 = opOL x1 x2
    linvOL' :
      (n : Nat) ->
      OpLeftBiMagmaTerm n ->
      OpLeftBiMagmaTerm n ->
      OpLeftBiMagmaTerm n
    linvOL' _ x1 x2 = linvOL x1 x2
    stageOp :
      (n : Nat) ->
      OpLeftBiMagmaTerm n ->
      Staged (OpLeftBiMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (linvOL x1 x2) =
      stage2 _ _ _ (linvOL' _)
        (codeLift2 _ _ _ (linvOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpLeftBiMagmaTerm2 n A ->
      OpLeftBiMagmaTerm2 n A ->
      OpLeftBiMagmaTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    linvOL2' :
      (n : Nat) (A : Set) ->
      OpLeftBiMagmaTerm2 n A ->
      OpLeftBiMagmaTerm2 n A ->
      OpLeftBiMagmaTerm2 n A
    linvOL2' _ _ x1 x2 =
      linvOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeftBiMagmaTerm2 n A ->
      Staged (OpLeftBiMagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (linvOL2 x1 x2) =
      stage2 _ _ _ (linvOL2' _ _)
        (codeLift2 _ _ _ (linvOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LeftBiMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
        linvT :
          Repr A -> Repr A -> Repr A
  
  module LeftBinaryInverse where
    record LeftBinaryInverse
      (A : Set) : Set where
      constructor LeftBinaryInverseC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftInverse :
          (x : A) (y : A) ->
          <| (|> x y) x == y
    record LeftBinaryInverseSig
      (AS : Set) : Set where
      constructor LeftBinaryInverseSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record LeftBinaryInverseProd
      (AP : Set) : Set where
      constructor LeftBinaryInverseProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          <|P (|>P xP yP) xP == yP
    record LeftBinaryInverseHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftBinaryInverse A1)
      (Le2 : LeftBinaryInverse A2) :
      Set where
      constructor LeftBinaryInverseHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Le1 x1 x2) ==
            <| Le2 (hom x1) (hom x2)
    record LeftBinaryInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftBinaryInverse A1)
      (Le2 : LeftBinaryInverse A2) :
      Set where
      constructor LeftBinaryInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Le1 x1 x2)
            (<| Le2 y1 y2)
    data LeftBinaryInverseTerm
      : Set where
      |>L :
        LeftBinaryInverseTerm ->
        LeftBinaryInverseTerm ->
        LeftBinaryInverseTerm
      <|L :
        LeftBinaryInverseTerm ->
        LeftBinaryInverseTerm ->
        LeftBinaryInverseTerm
    data ClLeftBinaryInverseTerm
      (A : Set) : Set where
      sing :
        A -> ClLeftBinaryInverseTerm A
      |>Cl :
        ClLeftBinaryInverseTerm A ->
        ClLeftBinaryInverseTerm A ->
        ClLeftBinaryInverseTerm A
      <|Cl :
        ClLeftBinaryInverseTerm A ->
        ClLeftBinaryInverseTerm A ->
        ClLeftBinaryInverseTerm A
    data OpLeftBinaryInverseTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpLeftBinaryInverseTerm n
      |>OL :
        OpLeftBinaryInverseTerm n ->
        OpLeftBinaryInverseTerm n ->
        OpLeftBinaryInverseTerm n
      <|OL :
        OpLeftBinaryInverseTerm n ->
        OpLeftBinaryInverseTerm n ->
        OpLeftBinaryInverseTerm n
    data OpLeftBinaryInverseTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpLeftBinaryInverseTerm2 n A
      sing2 :
        A ->
        OpLeftBinaryInverseTerm2 n A
      |>OL2 :
        OpLeftBinaryInverseTerm2 n A ->
        OpLeftBinaryInverseTerm2 n A ->
        OpLeftBinaryInverseTerm2 n A
      <|OL2 :
        OpLeftBinaryInverseTerm2 n A ->
        OpLeftBinaryInverseTerm2 n A ->
        OpLeftBinaryInverseTerm2 n A
    simplifyB :
      LeftBinaryInverseTerm ->
      LeftBinaryInverseTerm
    simplifyB (<|L (|>L x y) x) = y
    simplifyB (|>L x1 x2) =
      |>L (simplifyB x1)
        (simplifyB x2)
    simplifyB (<|L x1 x2) =
      <|L (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLeftBinaryInverseTerm A ->
      ClLeftBinaryInverseTerm A
    simplifyCl _ (<|Cl
                  (|>Cl x y)
                  x) = y
    simplifyCl _ (|>Cl x1 x2) =
      |>Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (<|Cl x1 x2) =
      <|Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeftBinaryInverseTerm n ->
      OpLeftBinaryInverseTerm n
    simplifyOp _ (<|OL
                  (|>OL x y)
                  x) = y
    simplifyOp _ (|>OL x1 x2) =
      |>OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (<|OL x1 x2) =
      <|OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeftBinaryInverseTerm2 n A ->
      OpLeftBinaryInverseTerm2 n A
    simplifyOpE _ _ (<|OL2
                     (|>OL2 x y)
                     x) = y
    simplifyOpE _ _ (|>OL2 x1 x2) =
      |>OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (<|OL2 x1 x2) =
      <|OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LeftBinaryInverse A ->
      LeftBinaryInverseTerm -> A
    evalB _ Le (|>L x1 x2) =
      |> Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalB _ Le (<|L x1 x2) =
      <| Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalCl :
      (A : Set) ->
      LeftBinaryInverse A ->
      ClLeftBinaryInverseTerm A -> A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (|>Cl x1 x2) =
      |> Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalCl _ Le (<|Cl x1 x2) =
      <| Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalOp :
      (A : Set) (n : Nat) ->
      LeftBinaryInverse A ->
      Vec A n ->
      OpLeftBinaryInverseTerm n -> A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (|>OL
                        x1
                        x2) =
      |> Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOp _ n Le vars (<|OL
                        x1
                        x2) =
      <| Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      LeftBinaryInverse A ->
      Vec A n ->
      OpLeftBinaryInverseTerm2 n A ->
      A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (|>OL2
                         x1
                         x2) =
      |> Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    evalOpE _ n Le vars (<|OL2
                         x1
                         x2) =
      <| Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    inductionB :
      (P : LeftBinaryInverseTerm ->
           Set) ->
      ((x1 : LeftBinaryInverseTerm)
       (x2 : LeftBinaryInverseTerm) ->
       P x1 ->
       P x2 -> P (|>L x1 x2)) ->
      ((x1 : LeftBinaryInverseTerm)
       (x2 : LeftBinaryInverseTerm) ->
       P x1 ->
       P x2 -> P (<|L x1 x2)) ->
      (x : LeftBinaryInverseTerm) ->
      P x
    inductionB p p|>l p<|l (|>L
                            x1
                            x2) =
      p|>l _ _
        (inductionB p p|>l p<|l x1)
        (inductionB p p|>l p<|l x2)
    inductionB p p|>l p<|l (<|L
                            x1
                            x2) =
      p<|l _ _
        (inductionB p p|>l p<|l x1)
        (inductionB p p|>l p<|l x2)
    inductionCl :
      (A : Set)
      (P : ClLeftBinaryInverseTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClLeftBinaryInverseTerm
          A)
       (x2 : ClLeftBinaryInverseTerm
          A) ->
       P x1 ->
       P x2 -> P (|>Cl x1 x2)) ->
      ((x1 : ClLeftBinaryInverseTerm
          A)
       (x2 : ClLeftBinaryInverseTerm
          A) ->
       P x1 ->
       P x2 -> P (<|Cl x1 x2)) ->
      (x : ClLeftBinaryInverseTerm
         A) -> P x
    inductionCl _ p psing p|>cl p<|cl (sing
                                       x1) = psing x1
    inductionCl _ p psing p|>cl p<|cl (|>Cl
                                       x1
                                       x2) =
      p|>cl _ _
        (inductionCl _ p psing p|>cl
           p<|cl
           x1)
        (inductionCl _ p psing p|>cl
           p<|cl
           x2)
    inductionCl _ p psing p|>cl p<|cl (<|Cl
                                       x1
                                       x2) =
      p<|cl _ _
        (inductionCl _ p psing p|>cl
           p<|cl
           x1)
        (inductionCl _ p psing p|>cl
           p<|cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpLeftBinaryInverseTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpLeftBinaryInverseTerm
          n)
       (x2 : OpLeftBinaryInverseTerm
          n) ->
       P x1 ->
       P x2 -> P (|>OL x1 x2)) ->
      ((x1 : OpLeftBinaryInverseTerm
          n)
       (x2 : OpLeftBinaryInverseTerm
          n) ->
       P x1 ->
       P x2 -> P (<|OL x1 x2)) ->
      (x : OpLeftBinaryInverseTerm
         n) -> P x
    inductionOp _ p pv p|>ol p<|ol (v
                                    x1) = pv x1
    inductionOp _ p pv p|>ol p<|ol (|>OL
                                    x1
                                    x2) =
      p|>ol _ _
        (inductionOp _ p pv p|>ol p<|ol
           x1)
        (inductionOp _ p pv p|>ol p<|ol
           x2)
    inductionOp _ p pv p|>ol p<|ol (<|OL
                                    x1
                                    x2) =
      p<|ol _ _
        (inductionOp _ p pv p|>ol p<|ol
           x1)
        (inductionOp _ p pv p|>ol p<|ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeftBinaryInverseTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpLeftBinaryInverseTerm2
          n
          A)
       (x2 : OpLeftBinaryInverseTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (|>OL2 x1 x2)) ->
      ((x1 : OpLeftBinaryInverseTerm2
          n
          A)
       (x2 : OpLeftBinaryInverseTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (<|OL2 x1 x2)) ->
      (x : OpLeftBinaryInverseTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (v2
                                                 x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (sing2
                                                 x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (|>OL2
                                                 x1
                                                 x2) =
      p|>ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (<|OL2
                                                 x1
                                                 x2) =
      p<|ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x2)
    |>L' :
      LeftBinaryInverseTerm ->
      LeftBinaryInverseTerm ->
      LeftBinaryInverseTerm
    |>L' x1 x2 = |>L x1 x2
    <|L' :
      LeftBinaryInverseTerm ->
      LeftBinaryInverseTerm ->
      LeftBinaryInverseTerm
    <|L' x1 x2 = <|L x1 x2
    stageB :
      LeftBinaryInverseTerm ->
      Staged LeftBinaryInverseTerm
    stageB (|>L x1 x2) =
      stage2 _ _ _ |>L'
        (codeLift2 _ _ _ |>L')
        (stageB x1)
        (stageB x2)
    stageB (<|L x1 x2) =
      stage2 _ _ _ <|L'
        (codeLift2 _ _ _ <|L')
        (stageB x1)
        (stageB x2)
    |>Cl' :
      (A : Set) ->
      ClLeftBinaryInverseTerm A ->
      ClLeftBinaryInverseTerm A ->
      ClLeftBinaryInverseTerm A
    |>Cl' _ x1 x2 = |>Cl x1 x2
    <|Cl' :
      (A : Set) ->
      ClLeftBinaryInverseTerm A ->
      ClLeftBinaryInverseTerm A ->
      ClLeftBinaryInverseTerm A
    <|Cl' _ x1 x2 = <|Cl x1 x2
    stageCl :
      (A : Set) ->
      ClLeftBinaryInverseTerm A ->
      Staged
        (ClLeftBinaryInverseTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (|>Cl x1 x2) =
      stage2 _ _ _ (|>Cl' _)
        (codeLift2 _ _ _ (|>Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (<|Cl x1 x2) =
      stage2 _ _ _ (<|Cl' _)
        (codeLift2 _ _ _ (<|Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    |>OL' :
      (n : Nat) ->
      OpLeftBinaryInverseTerm n ->
      OpLeftBinaryInverseTerm n ->
      OpLeftBinaryInverseTerm n
    |>OL' _ x1 x2 = |>OL x1 x2
    <|OL' :
      (n : Nat) ->
      OpLeftBinaryInverseTerm n ->
      OpLeftBinaryInverseTerm n ->
      OpLeftBinaryInverseTerm n
    <|OL' _ x1 x2 = <|OL x1 x2
    stageOp :
      (n : Nat) ->
      OpLeftBinaryInverseTerm n ->
      Staged
        (OpLeftBinaryInverseTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (|>OL x1 x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (<|OL x1 x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    |>OL2' :
      (n : Nat) (A : Set) ->
      OpLeftBinaryInverseTerm2 n A ->
      OpLeftBinaryInverseTerm2 n A ->
      OpLeftBinaryInverseTerm2 n A
    |>OL2' _ _ x1 x2 = |>OL2 x1 x2
    <|OL2' :
      (n : Nat) (A : Set) ->
      OpLeftBinaryInverseTerm2 n A ->
      OpLeftBinaryInverseTerm2 n A ->
      OpLeftBinaryInverseTerm2 n A
    <|OL2' _ _ x1 x2 = <|OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeftBinaryInverseTerm2 n A ->
      Staged
        (OpLeftBinaryInverseTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (|>OL2 x1 x2) =
      stage2 _ _ _ (|>OL2' _ _)
        (codeLift2 _ _ _ (|>OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (<|OL2 x1 x2) =
      stage2 _ _ _ (<|OL2' _ _)
        (codeLift2 _ _ _ (<|OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LeftBinaryInverseTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        |>T : Repr A -> Repr A -> Repr A
        <|T : Repr A -> Repr A -> Repr A
  
  module LeftCancellative where
    record LeftCancellative
      (A : Set) : Set where
      constructor LeftCancellativeC
      field
        op : A -> A -> A
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
    record LeftCancellativeSig
      (AS : Set) : Set where
      constructor LeftCancellativeSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
    record LeftCancellativeProd
      (AP : Set) : Set where
      constructor LeftCancellativeProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
    record LeftCancellativeHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellative A1)
      (Le2 : LeftCancellative A2) :
      Set where
      constructor LeftCancellativeHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Le1 x1 x2) ==
            linv Le2 (hom x1) (hom x2)
    record LeftCancellativeRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellative A1)
      (Le2 : LeftCancellative A2) :
      Set where
      constructor LeftCancellativeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Le1 x1 x2)
            (linv Le2 y1 y2)
    data LeftCancellativeTerm
      : Set where
      opL :
        LeftCancellativeTerm ->
        LeftCancellativeTerm ->
        LeftCancellativeTerm
      linvL :
        LeftCancellativeTerm ->
        LeftCancellativeTerm ->
        LeftCancellativeTerm
    data ClLeftCancellativeTerm
      (A : Set) : Set where
      sing :
        A -> ClLeftCancellativeTerm A
      opCl :
        ClLeftCancellativeTerm A ->
        ClLeftCancellativeTerm A ->
        ClLeftCancellativeTerm A
      linvCl :
        ClLeftCancellativeTerm A ->
        ClLeftCancellativeTerm A ->
        ClLeftCancellativeTerm A
    data OpLeftCancellativeTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpLeftCancellativeTerm n
      opOL :
        OpLeftCancellativeTerm n ->
        OpLeftCancellativeTerm n ->
        OpLeftCancellativeTerm n
      linvOL :
        OpLeftCancellativeTerm n ->
        OpLeftCancellativeTerm n ->
        OpLeftCancellativeTerm n
    data OpLeftCancellativeTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpLeftCancellativeTerm2 n A
      sing2 :
        A -> OpLeftCancellativeTerm2 n A
      opOL2 :
        OpLeftCancellativeTerm2 n A ->
        OpLeftCancellativeTerm2 n A ->
        OpLeftCancellativeTerm2 n A
      linvOL2 :
        OpLeftCancellativeTerm2 n A ->
        OpLeftCancellativeTerm2 n A ->
        OpLeftCancellativeTerm2 n A
    simplifyB :
      LeftCancellativeTerm ->
      LeftCancellativeTerm
    simplifyB (opL x (linvL x y)) =
      y
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (linvL x1 x2) =
      linvL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLeftCancellativeTerm A ->
      ClLeftCancellativeTerm A
    simplifyCl _ (opCl
                  x
                  (linvCl x y)) = y
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (linvCl x1 x2) =
      linvCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeftCancellativeTerm n ->
      OpLeftCancellativeTerm n
    simplifyOp _ (opOL
                  x
                  (linvOL x y)) = y
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (linvOL x1 x2) =
      linvOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeftCancellativeTerm2 n A ->
      OpLeftCancellativeTerm2 n A
    simplifyOpE _ _ (opOL2
                     x
                     (linvOL2 x y)) = y
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (linvOL2
                     x1
                     x2) =
      linvOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LeftCancellative A ->
      LeftCancellativeTerm -> A
    evalB _ Le (opL x1 x2) =
      op Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalB _ Le (linvL x1 x2) =
      linv Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalCl :
      (A : Set) ->
      LeftCancellative A ->
      ClLeftCancellativeTerm A -> A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (opCl x1 x2) =
      op Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalCl _ Le (linvCl x1 x2) =
      linv Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalOp :
      (A : Set) (n : Nat) ->
      LeftCancellative A ->
      Vec A n ->
      OpLeftCancellativeTerm n -> A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (opOL
                        x1
                        x2) =
      op Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOp _ n Le vars (linvOL
                        x1
                        x2) =
      linv Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      LeftCancellative A ->
      Vec A n ->
      OpLeftCancellativeTerm2 n A -> A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (opOL2
                         x1
                         x2) =
      op Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    evalOpE _ n Le vars (linvOL2
                         x1
                         x2) =
      linv Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    inductionB :
      (P : LeftCancellativeTerm ->
           Set) ->
      ((x1 : LeftCancellativeTerm)
       (x2 : LeftCancellativeTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      ((x1 : LeftCancellativeTerm)
       (x2 : LeftCancellativeTerm) ->
       P x1 ->
       P x2 -> P (linvL x1 x2)) ->
      (x : LeftCancellativeTerm) ->
      P x
    inductionB p popl plinvl (opL
                              x1
                              x2) =
      popl _ _
        (inductionB p popl plinvl x1)
        (inductionB p popl plinvl x2)
    inductionB p popl plinvl (linvL
                              x1
                              x2) =
      plinvl _ _
        (inductionB p popl plinvl x1)
        (inductionB p popl plinvl x2)
    inductionCl :
      (A : Set)
      (P : ClLeftCancellativeTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClLeftCancellativeTerm A)
       (x2 : ClLeftCancellativeTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      ((x1 : ClLeftCancellativeTerm A)
       (x2 : ClLeftCancellativeTerm
          A) ->
       P x1 ->
       P x2 -> P (linvCl x1 x2)) ->
      (x : ClLeftCancellativeTerm
         A) -> P x
    inductionCl _ p psing popcl plinvcl (sing
                                         x1) = psing x1
    inductionCl _ p psing popcl plinvcl (opCl
                                         x1
                                         x2) =
      popcl _ _
        (inductionCl _ p psing popcl
           plinvcl
           x1)
        (inductionCl _ p psing popcl
           plinvcl
           x2)
    inductionCl _ p psing popcl plinvcl (linvCl
                                         x1
                                         x2) =
      plinvcl _ _
        (inductionCl _ p psing popcl
           plinvcl
           x1)
        (inductionCl _ p psing popcl
           plinvcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpLeftCancellativeTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpLeftCancellativeTerm n)
       (x2 : OpLeftCancellativeTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      ((x1 : OpLeftCancellativeTerm n)
       (x2 : OpLeftCancellativeTerm
          n) ->
       P x1 ->
       P x2 -> P (linvOL x1 x2)) ->
      (x : OpLeftCancellativeTerm
         n) -> P x
    inductionOp _ p pv popol plinvol (v
                                      x1) = pv x1
    inductionOp _ p pv popol plinvol (opOL
                                      x1
                                      x2) =
      popol _ _
        (inductionOp _ p pv popol
           plinvol
           x1)
        (inductionOp _ p pv popol
           plinvol
           x2)
    inductionOp _ p pv popol plinvol (linvOL
                                      x1
                                      x2) =
      plinvol _ _
        (inductionOp _ p pv popol
           plinvol
           x1)
        (inductionOp _ p pv popol
           plinvol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeftCancellativeTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpLeftCancellativeTerm2 n
          A)
       (x2 : OpLeftCancellativeTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      ((x1 : OpLeftCancellativeTerm2 n
          A)
       (x2 : OpLeftCancellativeTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (linvOL2 x1 x2)) ->
      (x : OpLeftCancellativeTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 (v2
                                                   x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 (sing2
                                                   x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 (opOL2
                                                   x1
                                                   x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 (linvOL2
                                                   x1
                                                   x2) =
      plinvol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           x2)
    opL' :
      LeftCancellativeTerm ->
      LeftCancellativeTerm ->
      LeftCancellativeTerm
    opL' x1 x2 = opL x1 x2
    linvL' :
      LeftCancellativeTerm ->
      LeftCancellativeTerm ->
      LeftCancellativeTerm
    linvL' x1 x2 = linvL x1 x2
    stageB :
      LeftCancellativeTerm ->
      Staged LeftCancellativeTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (linvL x1 x2) =
      stage2 _ _ _ linvL'
        (codeLift2 _ _ _ linvL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClLeftCancellativeTerm A ->
      ClLeftCancellativeTerm A ->
      ClLeftCancellativeTerm A
    opCl' _ x1 x2 = opCl x1 x2
    linvCl' :
      (A : Set) ->
      ClLeftCancellativeTerm A ->
      ClLeftCancellativeTerm A ->
      ClLeftCancellativeTerm A
    linvCl' _ x1 x2 = linvCl x1 x2
    stageCl :
      (A : Set) ->
      ClLeftCancellativeTerm A ->
      Staged
        (ClLeftCancellativeTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (linvCl x1 x2) =
      stage2 _ _ _ (linvCl' _)
        (codeLift2 _ _ _ (linvCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpLeftCancellativeTerm n ->
      OpLeftCancellativeTerm n ->
      OpLeftCancellativeTerm n
    opOL' _ x1 x2 = opOL x1 x2
    linvOL' :
      (n : Nat) ->
      OpLeftCancellativeTerm n ->
      OpLeftCancellativeTerm n ->
      OpLeftCancellativeTerm n
    linvOL' _ x1 x2 = linvOL x1 x2
    stageOp :
      (n : Nat) ->
      OpLeftCancellativeTerm n ->
      Staged
        (OpLeftCancellativeTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (linvOL x1 x2) =
      stage2 _ _ _ (linvOL' _)
        (codeLift2 _ _ _ (linvOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpLeftCancellativeTerm2 n A ->
      OpLeftCancellativeTerm2 n A ->
      OpLeftCancellativeTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    linvOL2' :
      (n : Nat) (A : Set) ->
      OpLeftCancellativeTerm2 n A ->
      OpLeftCancellativeTerm2 n A ->
      OpLeftCancellativeTerm2 n A
    linvOL2' _ _ x1 x2 =
      linvOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeftCancellativeTerm2 n A ->
      Staged
        (OpLeftCancellativeTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (linvOL2 x1 x2) =
      stage2 _ _ _ (linvOL2' _ _)
        (codeLift2 _ _ _ (linvOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LeftCancellativeTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
        linvT :
          Repr A -> Repr A -> Repr A
  
  module LeftCancellativeMagma where
    record LeftCancellativeMagma
      (A : Set) : Set where
      constructor LeftCancellativeMagmaC
      field
        op : A -> A -> A
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
    record LeftCancellativeMagmaSig
      (AS : Set) : Set where
      constructor LeftCancellativeMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record LeftCancellativeMagmaProd
      (AP : Set) : Set where
      constructor LeftCancellativeMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
    record LeftCancellativeMagmaHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellativeMagma A1)
      (Le2 : LeftCancellativeMagma
         A2) : Set where
      constructor LeftCancellativeMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record LeftCancellativeMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellativeMagma A1)
      (Le2 : LeftCancellativeMagma
         A2) : Set where
      constructor LeftCancellativeMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data LeftCancellativeMagmaTerm
      : Set where
      opL :
        LeftCancellativeMagmaTerm ->
        LeftCancellativeMagmaTerm ->
        LeftCancellativeMagmaTerm
    data ClLeftCancellativeMagmaTerm
      (A : Set) : Set where
      sing :
        A ->
        ClLeftCancellativeMagmaTerm A
      opCl :
        ClLeftCancellativeMagmaTerm A ->
        ClLeftCancellativeMagmaTerm A ->
        ClLeftCancellativeMagmaTerm A
    data OpLeftCancellativeMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpLeftCancellativeMagmaTerm n
      opOL :
        OpLeftCancellativeMagmaTerm n ->
        OpLeftCancellativeMagmaTerm n ->
        OpLeftCancellativeMagmaTerm n
    data OpLeftCancellativeMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpLeftCancellativeMagmaTerm2 n A
      sing2 :
        A ->
        OpLeftCancellativeMagmaTerm2 n A
      opOL2 :
        OpLeftCancellativeMagmaTerm2 n
          A ->
        OpLeftCancellativeMagmaTerm2 n
          A ->
        OpLeftCancellativeMagmaTerm2 n A
    simplifyB :
      LeftCancellativeMagmaTerm ->
      LeftCancellativeMagmaTerm
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLeftCancellativeMagmaTerm A ->
      ClLeftCancellativeMagmaTerm A
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeftCancellativeMagmaTerm n ->
      OpLeftCancellativeMagmaTerm n
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeftCancellativeMagmaTerm2 n
        A ->
      OpLeftCancellativeMagmaTerm2 n A
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LeftCancellativeMagma A ->
      LeftCancellativeMagmaTerm -> A
    evalB _ Le (opL x1 x2) =
      op Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalCl :
      (A : Set) ->
      LeftCancellativeMagma A ->
      ClLeftCancellativeMagmaTerm A ->
      A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (opCl x1 x2) =
      op Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalOp :
      (A : Set) (n : Nat) ->
      LeftCancellativeMagma A ->
      Vec A n ->
      OpLeftCancellativeMagmaTerm n ->
      A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (opOL
                        x1
                        x2) =
      op Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      LeftCancellativeMagma A ->
      Vec A n ->
      OpLeftCancellativeMagmaTerm2 n
        A -> A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (opOL2
                         x1
                         x2) =
      op Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    inductionB :
      (P : LeftCancellativeMagmaTerm ->
           Set) ->
      ((x1 : LeftCancellativeMagmaTerm)
       (x2 : LeftCancellativeMagmaTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : LeftCancellativeMagmaTerm) ->
      P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClLeftCancellativeMagmaTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClLeftCancellativeMagmaTerm
          A)
       (x2 : ClLeftCancellativeMagmaTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClLeftCancellativeMagmaTerm
         A) -> P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpLeftCancellativeMagmaTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpLeftCancellativeMagmaTerm
          n)
       (x2 : OpLeftCancellativeMagmaTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpLeftCancellativeMagmaTerm
         n) -> P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeftCancellativeMagmaTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpLeftCancellativeMagmaTerm2
          n
          A)
       (x2 : OpLeftCancellativeMagmaTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpLeftCancellativeMagmaTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      LeftCancellativeMagmaTerm ->
      LeftCancellativeMagmaTerm ->
      LeftCancellativeMagmaTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      LeftCancellativeMagmaTerm ->
      Staged LeftCancellativeMagmaTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClLeftCancellativeMagmaTerm A ->
      ClLeftCancellativeMagmaTerm A ->
      ClLeftCancellativeMagmaTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClLeftCancellativeMagmaTerm A ->
      Staged
        (ClLeftCancellativeMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpLeftCancellativeMagmaTerm n ->
      OpLeftCancellativeMagmaTerm n ->
      OpLeftCancellativeMagmaTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpLeftCancellativeMagmaTerm n ->
      Staged
        (OpLeftCancellativeMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpLeftCancellativeMagmaTerm2 n
        A ->
      OpLeftCancellativeMagmaTerm2 n
        A ->
      OpLeftCancellativeMagmaTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeftCancellativeMagmaTerm2 n
        A ->
      Staged
        (OpLeftCancellativeMagmaTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LeftCancellativeMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module LeftCancellativeOp where
    record LeftCancellativeOp
      (A : Set) : Set where
      constructor LeftCancellativeOpC
      field
        op : A -> A -> A
        linv : A -> A -> A
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
    record LeftCancellativeOpSig
      (AS : Set) : Set where
      constructor LeftCancellativeOpSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
    record LeftCancellativeOpProd
      (AP : Set) : Set where
      constructor LeftCancellativeOpProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
    record LeftCancellativeOpHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellativeOp A1)
      (Le2 : LeftCancellativeOp A2) :
      Set where
      constructor LeftCancellativeOpHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Le1 x1 x2) ==
            linv Le2 (hom x1) (hom x2)
    record LeftCancellativeOpRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellativeOp A1)
      (Le2 : LeftCancellativeOp A2) :
      Set where
      constructor LeftCancellativeOpRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Le1 x1 x2)
            (linv Le2 y1 y2)
    data LeftCancellativeOpTerm
      : Set where
      opL :
        LeftCancellativeOpTerm ->
        LeftCancellativeOpTerm ->
        LeftCancellativeOpTerm
      linvL :
        LeftCancellativeOpTerm ->
        LeftCancellativeOpTerm ->
        LeftCancellativeOpTerm
    data ClLeftCancellativeOpTerm
      (A : Set) : Set where
      sing :
        A -> ClLeftCancellativeOpTerm A
      opCl :
        ClLeftCancellativeOpTerm A ->
        ClLeftCancellativeOpTerm A ->
        ClLeftCancellativeOpTerm A
      linvCl :
        ClLeftCancellativeOpTerm A ->
        ClLeftCancellativeOpTerm A ->
        ClLeftCancellativeOpTerm A
    data OpLeftCancellativeOpTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpLeftCancellativeOpTerm n
      opOL :
        OpLeftCancellativeOpTerm n ->
        OpLeftCancellativeOpTerm n ->
        OpLeftCancellativeOpTerm n
      linvOL :
        OpLeftCancellativeOpTerm n ->
        OpLeftCancellativeOpTerm n ->
        OpLeftCancellativeOpTerm n
    data OpLeftCancellativeOpTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpLeftCancellativeOpTerm2 n A
      sing2 :
        A ->
        OpLeftCancellativeOpTerm2 n A
      opOL2 :
        OpLeftCancellativeOpTerm2 n A ->
        OpLeftCancellativeOpTerm2 n A ->
        OpLeftCancellativeOpTerm2 n A
      linvOL2 :
        OpLeftCancellativeOpTerm2 n A ->
        OpLeftCancellativeOpTerm2 n A ->
        OpLeftCancellativeOpTerm2 n A
    simplifyB :
      LeftCancellativeOpTerm ->
      LeftCancellativeOpTerm
    simplifyB (linvL x (opL x y)) =
      y
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (linvL x1 x2) =
      linvL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLeftCancellativeOpTerm A ->
      ClLeftCancellativeOpTerm A
    simplifyCl _ (linvCl
                  x
                  (opCl x y)) = y
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (linvCl x1 x2) =
      linvCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeftCancellativeOpTerm n ->
      OpLeftCancellativeOpTerm n
    simplifyOp _ (linvOL
                  x
                  (opOL x y)) = y
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (linvOL x1 x2) =
      linvOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeftCancellativeOpTerm2 n A ->
      OpLeftCancellativeOpTerm2 n A
    simplifyOpE _ _ (linvOL2
                     x
                     (opOL2 x y)) = y
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (linvOL2
                     x1
                     x2) =
      linvOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LeftCancellativeOp A ->
      LeftCancellativeOpTerm -> A
    evalB _ Le (opL x1 x2) =
      op Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalB _ Le (linvL x1 x2) =
      linv Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalCl :
      (A : Set) ->
      LeftCancellativeOp A ->
      ClLeftCancellativeOpTerm A -> A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (opCl x1 x2) =
      op Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalCl _ Le (linvCl x1 x2) =
      linv Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalOp :
      (A : Set) (n : Nat) ->
      LeftCancellativeOp A ->
      Vec A n ->
      OpLeftCancellativeOpTerm n -> A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (opOL
                        x1
                        x2) =
      op Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOp _ n Le vars (linvOL
                        x1
                        x2) =
      linv Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      LeftCancellativeOp A ->
      Vec A n ->
      OpLeftCancellativeOpTerm2 n A ->
      A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (opOL2
                         x1
                         x2) =
      op Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    evalOpE _ n Le vars (linvOL2
                         x1
                         x2) =
      linv Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    inductionB :
      (P : LeftCancellativeOpTerm ->
           Set) ->
      ((x1 : LeftCancellativeOpTerm)
       (x2 : LeftCancellativeOpTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      ((x1 : LeftCancellativeOpTerm)
       (x2 : LeftCancellativeOpTerm) ->
       P x1 ->
       P x2 -> P (linvL x1 x2)) ->
      (x : LeftCancellativeOpTerm) ->
      P x
    inductionB p popl plinvl (opL
                              x1
                              x2) =
      popl _ _
        (inductionB p popl plinvl x1)
        (inductionB p popl plinvl x2)
    inductionB p popl plinvl (linvL
                              x1
                              x2) =
      plinvl _ _
        (inductionB p popl plinvl x1)
        (inductionB p popl plinvl x2)
    inductionCl :
      (A : Set)
      (P : ClLeftCancellativeOpTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClLeftCancellativeOpTerm
          A)
       (x2 : ClLeftCancellativeOpTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      ((x1 : ClLeftCancellativeOpTerm
          A)
       (x2 : ClLeftCancellativeOpTerm
          A) ->
       P x1 ->
       P x2 -> P (linvCl x1 x2)) ->
      (x : ClLeftCancellativeOpTerm
         A) -> P x
    inductionCl _ p psing popcl plinvcl (sing
                                         x1) = psing x1
    inductionCl _ p psing popcl plinvcl (opCl
                                         x1
                                         x2) =
      popcl _ _
        (inductionCl _ p psing popcl
           plinvcl
           x1)
        (inductionCl _ p psing popcl
           plinvcl
           x2)
    inductionCl _ p psing popcl plinvcl (linvCl
                                         x1
                                         x2) =
      plinvcl _ _
        (inductionCl _ p psing popcl
           plinvcl
           x1)
        (inductionCl _ p psing popcl
           plinvcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpLeftCancellativeOpTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpLeftCancellativeOpTerm
          n)
       (x2 : OpLeftCancellativeOpTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      ((x1 : OpLeftCancellativeOpTerm
          n)
       (x2 : OpLeftCancellativeOpTerm
          n) ->
       P x1 ->
       P x2 -> P (linvOL x1 x2)) ->
      (x : OpLeftCancellativeOpTerm
         n) -> P x
    inductionOp _ p pv popol plinvol (v
                                      x1) = pv x1
    inductionOp _ p pv popol plinvol (opOL
                                      x1
                                      x2) =
      popol _ _
        (inductionOp _ p pv popol
           plinvol
           x1)
        (inductionOp _ p pv popol
           plinvol
           x2)
    inductionOp _ p pv popol plinvol (linvOL
                                      x1
                                      x2) =
      plinvol _ _
        (inductionOp _ p pv popol
           plinvol
           x1)
        (inductionOp _ p pv popol
           plinvol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeftCancellativeOpTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpLeftCancellativeOpTerm2
          n
          A)
       (x2 : OpLeftCancellativeOpTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      ((x1 : OpLeftCancellativeOpTerm2
          n
          A)
       (x2 : OpLeftCancellativeOpTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (linvOL2 x1 x2)) ->
      (x : OpLeftCancellativeOpTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 (v2
                                                   x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 (sing2
                                                   x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 (opOL2
                                                   x1
                                                   x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 (linvOL2
                                                   x1
                                                   x2) =
      plinvol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           x2)
    opL' :
      LeftCancellativeOpTerm ->
      LeftCancellativeOpTerm ->
      LeftCancellativeOpTerm
    opL' x1 x2 = opL x1 x2
    linvL' :
      LeftCancellativeOpTerm ->
      LeftCancellativeOpTerm ->
      LeftCancellativeOpTerm
    linvL' x1 x2 = linvL x1 x2
    stageB :
      LeftCancellativeOpTerm ->
      Staged LeftCancellativeOpTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (linvL x1 x2) =
      stage2 _ _ _ linvL'
        (codeLift2 _ _ _ linvL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClLeftCancellativeOpTerm A ->
      ClLeftCancellativeOpTerm A ->
      ClLeftCancellativeOpTerm A
    opCl' _ x1 x2 = opCl x1 x2
    linvCl' :
      (A : Set) ->
      ClLeftCancellativeOpTerm A ->
      ClLeftCancellativeOpTerm A ->
      ClLeftCancellativeOpTerm A
    linvCl' _ x1 x2 = linvCl x1 x2
    stageCl :
      (A : Set) ->
      ClLeftCancellativeOpTerm A ->
      Staged
        (ClLeftCancellativeOpTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (linvCl x1 x2) =
      stage2 _ _ _ (linvCl' _)
        (codeLift2 _ _ _ (linvCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpLeftCancellativeOpTerm n ->
      OpLeftCancellativeOpTerm n ->
      OpLeftCancellativeOpTerm n
    opOL' _ x1 x2 = opOL x1 x2
    linvOL' :
      (n : Nat) ->
      OpLeftCancellativeOpTerm n ->
      OpLeftCancellativeOpTerm n ->
      OpLeftCancellativeOpTerm n
    linvOL' _ x1 x2 = linvOL x1 x2
    stageOp :
      (n : Nat) ->
      OpLeftCancellativeOpTerm n ->
      Staged
        (OpLeftCancellativeOpTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (linvOL x1 x2) =
      stage2 _ _ _ (linvOL' _)
        (codeLift2 _ _ _ (linvOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpLeftCancellativeOpTerm2 n A ->
      OpLeftCancellativeOpTerm2 n A ->
      OpLeftCancellativeOpTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    linvOL2' :
      (n : Nat) (A : Set) ->
      OpLeftCancellativeOpTerm2 n A ->
      OpLeftCancellativeOpTerm2 n A ->
      OpLeftCancellativeOpTerm2 n A
    linvOL2' _ _ x1 x2 =
      linvOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeftCancellativeOpTerm2 n A ->
      Staged
        (OpLeftCancellativeOpTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (linvOL2 x1 x2) =
      stage2 _ _ _ (linvOL2' _ _)
        (codeLift2 _ _ _ (linvOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LeftCancellativeOpTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
        linvT :
          Repr A -> Repr A -> Repr A
  
  module LeftCancellativeSemigroup where
    record LeftCancellativeSemigroup
      (A : Set) : Set where
      constructor LeftCancellativeSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        leftCancellative :
          (x : A) (y : A) (z : A) ->
          op z x == op z y -> x == y
    record LeftCancellativeSemigroupSig
      (AS : Set) : Set where
      constructor LeftCancellativeSemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record LeftCancellativeSemigroupProd
      (AP : Set) : Set where
      constructor LeftCancellativeSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        leftCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP zP xP == opP zP yP ->
          xP == yP
    record LeftCancellativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellativeSemigroup
         A1)
      (Le2 : LeftCancellativeSemigroup
         A2) : Set where
      constructor LeftCancellativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record LeftCancellativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftCancellativeSemigroup
         A1)
      (Le2 : LeftCancellativeSemigroup
         A2) : Set where
      constructor LeftCancellativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data LeftCancellativeSemigroupTerm
      : Set where
      opL :
        LeftCancellativeSemigroupTerm ->
        LeftCancellativeSemigroupTerm ->
        LeftCancellativeSemigroupTerm
    data ClLeftCancellativeSemigroupTerm
      (A : Set) : Set where
      sing :
        A ->
        ClLeftCancellativeSemigroupTerm
          A
      opCl :
        ClLeftCancellativeSemigroupTerm
          A ->
        ClLeftCancellativeSemigroupTerm
          A ->
        ClLeftCancellativeSemigroupTerm
          A
    data OpLeftCancellativeSemigroupTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpLeftCancellativeSemigroupTerm
          n
      opOL :
        OpLeftCancellativeSemigroupTerm
          n ->
        OpLeftCancellativeSemigroupTerm
          n ->
        OpLeftCancellativeSemigroupTerm
          n
    data OpLeftCancellativeSemigroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpLeftCancellativeSemigroupTerm2
          n
          A
      sing2 :
        A ->
        OpLeftCancellativeSemigroupTerm2
          n
          A
      opOL2 :
        OpLeftCancellativeSemigroupTerm2
          n
          A ->
        OpLeftCancellativeSemigroupTerm2
          n
          A ->
        OpLeftCancellativeSemigroupTerm2
          n
          A
    simplifyB :
      LeftCancellativeSemigroupTerm ->
      LeftCancellativeSemigroupTerm
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLeftCancellativeSemigroupTerm
        A ->
      ClLeftCancellativeSemigroupTerm
        A
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeftCancellativeSemigroupTerm
        n ->
      OpLeftCancellativeSemigroupTerm
        n
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeftCancellativeSemigroupTerm2
        n
        A ->
      OpLeftCancellativeSemigroupTerm2
        n
        A
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LeftCancellativeSemigroup A ->
      LeftCancellativeSemigroupTerm ->
      A
    evalB _ Le (opL x1 x2) =
      op Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalCl :
      (A : Set) ->
      LeftCancellativeSemigroup A ->
      ClLeftCancellativeSemigroupTerm
        A -> A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (opCl x1 x2) =
      op Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalOp :
      (A : Set) (n : Nat) ->
      LeftCancellativeSemigroup A ->
      Vec A n ->
      OpLeftCancellativeSemigroupTerm
        n -> A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (opOL
                        x1
                        x2) =
      op Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      LeftCancellativeSemigroup A ->
      Vec A n ->
      OpLeftCancellativeSemigroupTerm2
        n
        A -> A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (opOL2
                         x1
                         x2) =
      op Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    inductionB :
      (P : LeftCancellativeSemigroupTerm ->
           Set) ->
      ((x1 : LeftCancellativeSemigroupTerm)
       (x2 : LeftCancellativeSemigroupTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : LeftCancellativeSemigroupTerm) ->
      P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClLeftCancellativeSemigroupTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClLeftCancellativeSemigroupTerm
          A)
       (x2 : ClLeftCancellativeSemigroupTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClLeftCancellativeSemigroupTerm
         A) -> P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpLeftCancellativeSemigroupTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpLeftCancellativeSemigroupTerm
          n)
       (x2 : OpLeftCancellativeSemigroupTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpLeftCancellativeSemigroupTerm
         n) -> P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeftCancellativeSemigroupTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpLeftCancellativeSemigroupTerm2
          n
          A)
       (x2 : OpLeftCancellativeSemigroupTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpLeftCancellativeSemigroupTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      LeftCancellativeSemigroupTerm ->
      LeftCancellativeSemigroupTerm ->
      LeftCancellativeSemigroupTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      LeftCancellativeSemigroupTerm ->
      Staged
        LeftCancellativeSemigroupTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClLeftCancellativeSemigroupTerm
        A ->
      ClLeftCancellativeSemigroupTerm
        A ->
      ClLeftCancellativeSemigroupTerm
        A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClLeftCancellativeSemigroupTerm
        A ->
      Staged
        (ClLeftCancellativeSemigroupTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpLeftCancellativeSemigroupTerm
        n ->
      OpLeftCancellativeSemigroupTerm
        n ->
      OpLeftCancellativeSemigroupTerm
        n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpLeftCancellativeSemigroupTerm
        n ->
      Staged
        (OpLeftCancellativeSemigroupTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpLeftCancellativeSemigroupTerm2
        n
        A ->
      OpLeftCancellativeSemigroupTerm2
        n
        A ->
      OpLeftCancellativeSemigroupTerm2
        n
        A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeftCancellativeSemigroupTerm2
        n
        A ->
      Staged
        (OpLeftCancellativeSemigroupTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LeftCancellativeSemigroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module LeftDistributiveMagma where
    record LeftDistributiveMagma
      (A : Set) : Set where
      constructor LeftDistributiveMagmaC
      field
        op : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          op x (op y z) ==
            op (op x y) (op x z)
    record LeftDistributiveMagmaSig
      (AS : Set) : Set where
      constructor LeftDistributiveMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record LeftDistributiveMagmaProd
      (AP : Set) : Set where
      constructor LeftDistributiveMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP (opP yP zP) ==
            opP (opP xP yP) (opP xP zP)
    record LeftDistributiveMagmaHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftDistributiveMagma A1)
      (Le2 : LeftDistributiveMagma
         A2) : Set where
      constructor LeftDistributiveMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record LeftDistributiveMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftDistributiveMagma A1)
      (Le2 : LeftDistributiveMagma
         A2) : Set where
      constructor LeftDistributiveMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data LeftDistributiveMagmaTerm
      : Set where
      opL :
        LeftDistributiveMagmaTerm ->
        LeftDistributiveMagmaTerm ->
        LeftDistributiveMagmaTerm
    data ClLeftDistributiveMagmaTerm
      (A : Set) : Set where
      sing :
        A ->
        ClLeftDistributiveMagmaTerm A
      opCl :
        ClLeftDistributiveMagmaTerm A ->
        ClLeftDistributiveMagmaTerm A ->
        ClLeftDistributiveMagmaTerm A
    data OpLeftDistributiveMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpLeftDistributiveMagmaTerm n
      opOL :
        OpLeftDistributiveMagmaTerm n ->
        OpLeftDistributiveMagmaTerm n ->
        OpLeftDistributiveMagmaTerm n
    data OpLeftDistributiveMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpLeftDistributiveMagmaTerm2 n A
      sing2 :
        A ->
        OpLeftDistributiveMagmaTerm2 n A
      opOL2 :
        OpLeftDistributiveMagmaTerm2 n
          A ->
        OpLeftDistributiveMagmaTerm2 n
          A ->
        OpLeftDistributiveMagmaTerm2 n A
    simplifyB :
      LeftDistributiveMagmaTerm ->
      LeftDistributiveMagmaTerm
    simplifyB (opL
               (opL x y)
               (opL x z)) = opL x (opL y z)
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLeftDistributiveMagmaTerm A ->
      ClLeftDistributiveMagmaTerm A
    simplifyCl _ (opCl
                  (opCl x y)
                  (opCl x z)) = opCl x (opCl y z)
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeftDistributiveMagmaTerm n ->
      OpLeftDistributiveMagmaTerm n
    simplifyOp _ (opOL
                  (opOL x y)
                  (opOL x z)) = opOL x (opOL y z)
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeftDistributiveMagmaTerm2 n
        A ->
      OpLeftDistributiveMagmaTerm2 n A
    simplifyOpE _ _ (opOL2
                     (opOL2 x y)
                     (opOL2 x z)) =
      opOL2 x (opOL2 y z)
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LeftDistributiveMagma A ->
      LeftDistributiveMagmaTerm -> A
    evalB _ Le (opL x1 x2) =
      op Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalCl :
      (A : Set) ->
      LeftDistributiveMagma A ->
      ClLeftDistributiveMagmaTerm A ->
      A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (opCl x1 x2) =
      op Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalOp :
      (A : Set) (n : Nat) ->
      LeftDistributiveMagma A ->
      Vec A n ->
      OpLeftDistributiveMagmaTerm n ->
      A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (opOL
                        x1
                        x2) =
      op Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      LeftDistributiveMagma A ->
      Vec A n ->
      OpLeftDistributiveMagmaTerm2 n
        A -> A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (opOL2
                         x1
                         x2) =
      op Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    inductionB :
      (P : LeftDistributiveMagmaTerm ->
           Set) ->
      ((x1 : LeftDistributiveMagmaTerm)
       (x2 : LeftDistributiveMagmaTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : LeftDistributiveMagmaTerm) ->
      P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClLeftDistributiveMagmaTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClLeftDistributiveMagmaTerm
          A)
       (x2 : ClLeftDistributiveMagmaTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClLeftDistributiveMagmaTerm
         A) -> P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpLeftDistributiveMagmaTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpLeftDistributiveMagmaTerm
          n)
       (x2 : OpLeftDistributiveMagmaTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpLeftDistributiveMagmaTerm
         n) -> P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeftDistributiveMagmaTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpLeftDistributiveMagmaTerm2
          n
          A)
       (x2 : OpLeftDistributiveMagmaTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpLeftDistributiveMagmaTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      LeftDistributiveMagmaTerm ->
      LeftDistributiveMagmaTerm ->
      LeftDistributiveMagmaTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      LeftDistributiveMagmaTerm ->
      Staged LeftDistributiveMagmaTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClLeftDistributiveMagmaTerm A ->
      ClLeftDistributiveMagmaTerm A ->
      ClLeftDistributiveMagmaTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClLeftDistributiveMagmaTerm A ->
      Staged
        (ClLeftDistributiveMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpLeftDistributiveMagmaTerm n ->
      OpLeftDistributiveMagmaTerm n ->
      OpLeftDistributiveMagmaTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpLeftDistributiveMagmaTerm n ->
      Staged
        (OpLeftDistributiveMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpLeftDistributiveMagmaTerm2 n
        A ->
      OpLeftDistributiveMagmaTerm2 n
        A ->
      OpLeftDistributiveMagmaTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeftDistributiveMagmaTerm2 n
        A ->
      Staged
        (OpLeftDistributiveMagmaTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LeftDistributiveMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module LeftIdempotence where
    record LeftIdempotence
      (A : Set) : Set where
      constructor LeftIdempotenceC
      field
        |> : A -> A -> A
        idempotent_|> :
          (x : A) -> |> x x == x
    record LeftIdempotenceSig
      (AS : Set) : Set where
      constructor LeftIdempotenceSigSigC
      field
        |>S : AS -> AS -> AS
    record LeftIdempotenceProd
      (AP : Set) : Set where
      constructor LeftIdempotenceProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
    record LeftIdempotenceHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftIdempotence A1)
      (Le2 : LeftIdempotence A2) :
      Set where
      constructor LeftIdempotenceHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
    record LeftIdempotenceRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftIdempotence A1)
      (Le2 : LeftIdempotence A2) :
      Set where
      constructor LeftIdempotenceRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
    data LeftIdempotenceTerm
      : Set where
      |>L :
        LeftIdempotenceTerm ->
        LeftIdempotenceTerm ->
        LeftIdempotenceTerm
    data ClLeftIdempotenceTerm
      (A : Set) : Set where
      sing :
        A -> ClLeftIdempotenceTerm A
      |>Cl :
        ClLeftIdempotenceTerm A ->
        ClLeftIdempotenceTerm A ->
        ClLeftIdempotenceTerm A
    data OpLeftIdempotenceTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpLeftIdempotenceTerm n
      |>OL :
        OpLeftIdempotenceTerm n ->
        OpLeftIdempotenceTerm n ->
        OpLeftIdempotenceTerm n
    data OpLeftIdempotenceTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpLeftIdempotenceTerm2 n A
      sing2 :
        A -> OpLeftIdempotenceTerm2 n A
      |>OL2 :
        OpLeftIdempotenceTerm2 n A ->
        OpLeftIdempotenceTerm2 n A ->
        OpLeftIdempotenceTerm2 n A
    simplifyB :
      LeftIdempotenceTerm ->
      LeftIdempotenceTerm
    simplifyB (|>L x x) = x
    simplifyB (|>L x1 x2) =
      |>L (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLeftIdempotenceTerm A ->
      ClLeftIdempotenceTerm A
    simplifyCl _ (|>Cl x x) = x
    simplifyCl _ (|>Cl x1 x2) =
      |>Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeftIdempotenceTerm n ->
      OpLeftIdempotenceTerm n
    simplifyOp _ (|>OL x x) = x
    simplifyOp _ (|>OL x1 x2) =
      |>OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeftIdempotenceTerm2 n A ->
      OpLeftIdempotenceTerm2 n A
    simplifyOpE _ _ (|>OL2 x x) = x
    simplifyOpE _ _ (|>OL2 x1 x2) =
      |>OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LeftIdempotence A ->
      LeftIdempotenceTerm -> A
    evalB _ Le (|>L x1 x2) =
      |> Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalCl :
      (A : Set) ->
      LeftIdempotence A ->
      ClLeftIdempotenceTerm A -> A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (|>Cl x1 x2) =
      |> Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalOp :
      (A : Set) (n : Nat) ->
      LeftIdempotence A ->
      Vec A n ->
      OpLeftIdempotenceTerm n -> A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (|>OL
                        x1
                        x2) =
      |> Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      LeftIdempotence A ->
      Vec A n ->
      OpLeftIdempotenceTerm2 n A -> A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (|>OL2
                         x1
                         x2) =
      |> Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    inductionB :
      (P : LeftIdempotenceTerm ->
           Set) ->
      ((x1 : LeftIdempotenceTerm)
       (x2 : LeftIdempotenceTerm) ->
       P x1 ->
       P x2 -> P (|>L x1 x2)) ->
      (x : LeftIdempotenceTerm) -> P x
    inductionB p p|>l (|>L x1 x2) =
      p|>l _ _ (inductionB p p|>l x1)
        (inductionB p p|>l x2)
    inductionCl :
      (A : Set)
      (P : ClLeftIdempotenceTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClLeftIdempotenceTerm A)
       (x2 : ClLeftIdempotenceTerm
          A) ->
       P x1 ->
       P x2 -> P (|>Cl x1 x2)) ->
      (x : ClLeftIdempotenceTerm A) ->
      P x
    inductionCl _ p psing p|>cl (sing
                                 x1) = psing x1
    inductionCl _ p psing p|>cl (|>Cl
                                 x1
                                 x2) =
      p|>cl _ _
        (inductionCl _ p psing p|>cl x1)
        (inductionCl _ p psing p|>cl x2)
    inductionOp :
      (n : Nat)
      (P : OpLeftIdempotenceTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpLeftIdempotenceTerm n)
       (x2 : OpLeftIdempotenceTerm
          n) ->
       P x1 ->
       P x2 -> P (|>OL x1 x2)) ->
      (x : OpLeftIdempotenceTerm n) ->
      P x
    inductionOp _ p pv p|>ol (v
                              x1) = pv x1
    inductionOp _ p pv p|>ol (|>OL
                              x1
                              x2) =
      p|>ol _ _
        (inductionOp _ p pv p|>ol x1)
        (inductionOp _ p pv p|>ol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeftIdempotenceTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpLeftIdempotenceTerm2 n
          A)
       (x2 : OpLeftIdempotenceTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (|>OL2 x1 x2)) ->
      (x : OpLeftIdempotenceTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p|>ol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 (|>OL2
                                          x1
                                          x2) =
      p|>ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           x2)
    |>L' :
      LeftIdempotenceTerm ->
      LeftIdempotenceTerm ->
      LeftIdempotenceTerm
    |>L' x1 x2 = |>L x1 x2
    stageB :
      LeftIdempotenceTerm ->
      Staged LeftIdempotenceTerm
    stageB (|>L x1 x2) =
      stage2 _ _ _ |>L'
        (codeLift2 _ _ _ |>L')
        (stageB x1)
        (stageB x2)
    |>Cl' :
      (A : Set) ->
      ClLeftIdempotenceTerm A ->
      ClLeftIdempotenceTerm A ->
      ClLeftIdempotenceTerm A
    |>Cl' _ x1 x2 = |>Cl x1 x2
    stageCl :
      (A : Set) ->
      ClLeftIdempotenceTerm A ->
      Staged (ClLeftIdempotenceTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (|>Cl x1 x2) =
      stage2 _ _ _ (|>Cl' _)
        (codeLift2 _ _ _ (|>Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    |>OL' :
      (n : Nat) ->
      OpLeftIdempotenceTerm n ->
      OpLeftIdempotenceTerm n ->
      OpLeftIdempotenceTerm n
    |>OL' _ x1 x2 = |>OL x1 x2
    stageOp :
      (n : Nat) ->
      OpLeftIdempotenceTerm n ->
      Staged (OpLeftIdempotenceTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (|>OL x1 x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    |>OL2' :
      (n : Nat) (A : Set) ->
      OpLeftIdempotenceTerm2 n A ->
      OpLeftIdempotenceTerm2 n A ->
      OpLeftIdempotenceTerm2 n A
    |>OL2' _ _ x1 x2 = |>OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeftIdempotenceTerm2 n A ->
      Staged
        (OpLeftIdempotenceTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (|>OL2 x1 x2) =
      stage2 _ _ _ (|>OL2' _ _)
        (codeLift2 _ _ _ (|>OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LeftIdempotenceTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        |>T : Repr A -> Repr A -> Repr A
  
  module LeftInverse where
    record LeftInverse
      (A : Set) : Set where
      constructor LeftInverseC
      field
        inv : A -> A
        e : A
        op : A -> A -> A
        leftInverse_inv_op_e :
          (x : A) -> op x (inv x) == e
    record LeftInverseSig
      (AS : Set) : Set where
      constructor LeftInverseSigSigC
      field
        invS : AS -> AS
        eS : AS
        opS : AS -> AS -> AS
    record LeftInverseProd
      (AP : Set) : Set where
      constructor LeftInverseProdC
      field
        invP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP xP (invP xP) == eP
    record LeftInverseHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftInverse A1)
      (Le2 : LeftInverse A2) :
      Set where
      constructor LeftInverseHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv Le1 x1) ==
            inv Le2 (hom x1)
        pres-e : hom (e Le1) == e Le2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record LeftInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftInverse A1)
      (Le2 : LeftInverse A2) :
      Set where
      constructor LeftInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Le1 x1) (inv Le2 y1)
        interp-e :
          interp (e Le1) (e Le2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data LeftInverseLTerm
      : Set where
      invL :
        LeftInverseLTerm ->
        LeftInverseLTerm
      eL : LeftInverseLTerm
      opL :
        LeftInverseLTerm ->
        LeftInverseLTerm ->
        LeftInverseLTerm
    data ClLeftInverseClTerm
      (A : Set) : Set where
      sing :
        A -> ClLeftInverseClTerm A
      invCl :
        ClLeftInverseClTerm A ->
        ClLeftInverseClTerm A
      eCl : ClLeftInverseClTerm A
      opCl :
        ClLeftInverseClTerm A ->
        ClLeftInverseClTerm A ->
        ClLeftInverseClTerm A
    data OpLeftInverseOLTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpLeftInverseOLTerm n
      invOL :
        OpLeftInverseOLTerm n ->
        OpLeftInverseOLTerm n
      eOL : OpLeftInverseOLTerm n
      opOL :
        OpLeftInverseOLTerm n ->
        OpLeftInverseOLTerm n ->
        OpLeftInverseOLTerm n
    data OpLeftInverseOL2Term2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpLeftInverseOL2Term2 n A
      sing2 :
        A -> OpLeftInverseOL2Term2 n A
      invOL2 :
        OpLeftInverseOL2Term2 n A ->
        OpLeftInverseOL2Term2 n A
      eOL2 : OpLeftInverseOL2Term2 n A
      opOL2 :
        OpLeftInverseOL2Term2 n A ->
        OpLeftInverseOL2Term2 n A ->
        OpLeftInverseOL2Term2 n A
    simplifyB :
      LeftInverseLTerm ->
      LeftInverseLTerm
    simplifyB (opL x (invL x)) = eL
    simplifyB (invL x1) =
      invL (simplifyB x1)
    simplifyB (eL) = eL
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLeftInverseClTerm A ->
      ClLeftInverseClTerm A
    simplifyCl _ (opCl
                  x
                  (invCl x)) = eCl
    simplifyCl _ (invCl x1) =
      invCl (simplifyCl _ x1)
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeftInverseOLTerm n ->
      OpLeftInverseOLTerm n
    simplifyOp _ (opOL
                  x
                  (invOL x)) = eOL
    simplifyOp _ (invOL x1) =
      invOL (simplifyOp _ x1)
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeftInverseOL2Term2 n A ->
      OpLeftInverseOL2Term2 n A
    simplifyOpE _ _ (opOL2
                     x
                     (invOL2 x)) = eOL2
    simplifyOpE _ _ (invOL2 x1) =
      invOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LeftInverse A ->
      LeftInverseLTerm -> A
    evalB _ Le (invL x1) =
      inv Le (evalB _ Le x1)
    evalB _ Le (eL) = e Le
    evalB _ Le (opL x1 x2) =
      op Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalCl :
      (A : Set) ->
      LeftInverse A ->
      ClLeftInverseClTerm A -> A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (invCl x1) =
      inv Le (evalCl _ Le x1)
    evalCl _ Le (eCl) = e Le
    evalCl _ Le (opCl x1 x2) =
      op Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalOp :
      (A : Set) (n : Nat) ->
      LeftInverse A ->
      Vec A n ->
      OpLeftInverseOLTerm n -> A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (invOL x1) =
      inv Le (evalOp _ n Le vars x1)
    evalOp _ n Le vars (eOL) = e Le
    evalOp _ n Le vars (opOL
                        x1
                        x2) =
      op Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      LeftInverse A ->
      Vec A n ->
      OpLeftInverseOL2Term2 n A -> A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (invOL2
                         x1) =
      inv Le (evalOpE _ n Le vars x1)
    evalOpE _ n Le vars (eOL2) =
      e Le
    evalOpE _ n Le vars (opOL2
                         x1
                         x2) =
      op Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    inductionB :
      (P : LeftInverseLTerm -> Set) ->
      ((x1 : LeftInverseLTerm) ->
       P x1 -> P (invL x1)) ->
      P eL ->
      ((x1 : LeftInverseLTerm)
       (x2 : LeftInverseLTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : LeftInverseLTerm) -> P x
    inductionB p pinvl pel popl (invL
                                 x1) =
      pinvl _
        (inductionB p pinvl pel popl x1)
    inductionB p pinvl pel popl (eL) =
      pel
    inductionB p pinvl pel popl (opL
                                 x1
                                 x2) =
      popl _ _
        (inductionB p pinvl pel popl x1)
        (inductionB p pinvl pel popl x2)
    inductionCl :
      (A : Set)
      (P : ClLeftInverseClTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClLeftInverseClTerm A) ->
       P x1 -> P (invCl x1)) ->
      P eCl ->
      ((x1 : ClLeftInverseClTerm A)
       (x2 : ClLeftInverseClTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClLeftInverseClTerm A) ->
      P x
    inductionCl _ p psing pinvcl pecl popcl (sing
                                             x1) = psing x1
    inductionCl _ p psing pinvcl pecl popcl (invCl
                                             x1) =
      pinvcl _
        (inductionCl _ p psing pinvcl
           pecl
           popcl
           x1)
    inductionCl _ p psing pinvcl pecl popcl (eCl) =
      pecl
    inductionCl _ p psing pinvcl pecl popcl (opCl
                                             x1
                                             x2) =
      popcl _ _
        (inductionCl _ p psing pinvcl
           pecl
           popcl
           x1)
        (inductionCl _ p psing pinvcl
           pecl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpLeftInverseOLTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpLeftInverseOLTerm n) ->
       P x1 -> P (invOL x1)) ->
      P eOL ->
      ((x1 : OpLeftInverseOLTerm n)
       (x2 : OpLeftInverseOLTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpLeftInverseOLTerm n) ->
      P x
    inductionOp _ p pv pinvol peol popol (v
                                          x1) = pv x1
    inductionOp _ p pv pinvol peol popol (invOL
                                          x1) =
      pinvol _
        (inductionOp _ p pv pinvol peol
           popol
           x1)
    inductionOp _ p pv pinvol peol popol (eOL) =
      peol
    inductionOp _ p pv pinvol peol popol (opOL
                                          x1
                                          x2) =
      popol _ _
        (inductionOp _ p pv pinvol peol
           popol
           x1)
        (inductionOp _ p pv pinvol peol
           popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeftInverseOL2Term2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpLeftInverseOL2Term2 n
          A) -> P x1 -> P (invOL2 x1)) ->
      P eOL2 ->
      ((x1 : OpLeftInverseOL2Term2 n
          A)
       (x2 : OpLeftInverseOL2Term2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpLeftInverseOL2Term2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 pinvol2 peol2 popol2 (v2
                                                        x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pinvol2 peol2 popol2 (sing2
                                                        x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pinvol2 peol2 popol2 (invOL2
                                                        x1) =
      pinvol2 _
        (inductionOpE _ _ p pv2 psing2
           pinvol2
           peol2
           popol2
           x1)
    inductionOpE _ _ p pv2 psing2 pinvol2 peol2 popol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 pinvol2 peol2 popol2 (opOL2
                                                        x1
                                                        x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           pinvol2
           peol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           pinvol2
           peol2
           popol2
           x2)
    invL' :
      LeftInverseLTerm ->
      LeftInverseLTerm
    invL' x1 = invL x1
    eL' : LeftInverseLTerm
    eL' = eL
    opL' :
      LeftInverseLTerm ->
      LeftInverseLTerm ->
      LeftInverseLTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      LeftInverseLTerm ->
      Staged LeftInverseLTerm
    stageB (invL x1) =
      stage1 _ _ invL'
        (codeLift1 _ _ invL')
        (stageB x1)
    stageB (eL) = Now eL
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    invCl' :
      (A : Set) ->
      ClLeftInverseClTerm A ->
      ClLeftInverseClTerm A
    invCl' _ x1 = invCl x1
    eCl' :
      (A : Set) ->
      ClLeftInverseClTerm A
    eCl' _ = eCl
    opCl' :
      (A : Set) ->
      ClLeftInverseClTerm A ->
      ClLeftInverseClTerm A ->
      ClLeftInverseClTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClLeftInverseClTerm A ->
      Staged (ClLeftInverseClTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (invCl x1) =
      stage1 _ _ (invCl' _)
        (codeLift1 _ _ (invCl' _))
        (stageCl _ x1)
    stageCl _ (eCl) = Now eCl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    invOL' :
      (n : Nat) ->
      OpLeftInverseOLTerm n ->
      OpLeftInverseOLTerm n
    invOL' _ x1 = invOL x1
    eOL' :
      (n : Nat) ->
      OpLeftInverseOLTerm n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      OpLeftInverseOLTerm n ->
      OpLeftInverseOLTerm n ->
      OpLeftInverseOLTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpLeftInverseOLTerm n ->
      Staged (OpLeftInverseOLTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (invOL x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (stageOp _ x1)
    stageOp _ (eOL) = Now eOL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    invOL2' :
      (n : Nat) (A : Set) ->
      OpLeftInverseOL2Term2 n A ->
      OpLeftInverseOL2Term2 n A
    invOL2' _ _ x1 = invOL2 x1
    eOL2' :
      (n : Nat) (A : Set) ->
      OpLeftInverseOL2Term2 n A
    eOL2' _ _ = eOL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpLeftInverseOL2Term2 n A ->
      OpLeftInverseOL2Term2 n A ->
      OpLeftInverseOL2Term2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeftInverseOL2Term2 n A ->
      Staged
        (OpLeftInverseOL2Term2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (invOL2 x1) =
      stage1 _ _ (invOL2' _ _)
        (codeLift1 _ _ (invOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LeftInverseTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        invT : Repr A -> Repr A
        eT : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module LeftInverseMagma where
    record LeftInverseMagma
      (A : Set) : Set where
      constructor LeftInverseMagmaC
      field
        linv : A -> A -> A
    record LeftInverseMagmaSig
      (AS : Set) : Set where
      constructor LeftInverseMagmaSigSigC
      field
        linvS : AS -> AS -> AS
    record LeftInverseMagmaProd
      (AP : Set) : Set where
      constructor LeftInverseMagmaProdC
      field
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record LeftInverseMagmaHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftInverseMagma A1)
      (Le2 : LeftInverseMagma A2) :
      Set where
      constructor LeftInverseMagmaHomC
      field
        hom : A1 -> A2
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Le1 x1 x2) ==
            linv Le2 (hom x1) (hom x2)
    record LeftInverseMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftInverseMagma A1)
      (Le2 : LeftInverseMagma A2) :
      Set where
      constructor LeftInverseMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Le1 x1 x2)
            (linv Le2 y1 y2)
    data LeftInverseMagmaTerm
      : Set where
      linvL :
        LeftInverseMagmaTerm ->
        LeftInverseMagmaTerm ->
        LeftInverseMagmaTerm
    data ClLeftInverseMagmaTerm
      (A : Set) : Set where
      sing :
        A -> ClLeftInverseMagmaTerm A
      linvCl :
        ClLeftInverseMagmaTerm A ->
        ClLeftInverseMagmaTerm A ->
        ClLeftInverseMagmaTerm A
    data OpLeftInverseMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpLeftInverseMagmaTerm n
      linvOL :
        OpLeftInverseMagmaTerm n ->
        OpLeftInverseMagmaTerm n ->
        OpLeftInverseMagmaTerm n
    data OpLeftInverseMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpLeftInverseMagmaTerm2 n A
      sing2 :
        A -> OpLeftInverseMagmaTerm2 n A
      linvOL2 :
        OpLeftInverseMagmaTerm2 n A ->
        OpLeftInverseMagmaTerm2 n A ->
        OpLeftInverseMagmaTerm2 n A
    simplifyB :
      LeftInverseMagmaTerm ->
      LeftInverseMagmaTerm
    simplifyB (linvL x1 x2) =
      linvL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLeftInverseMagmaTerm A ->
      ClLeftInverseMagmaTerm A
    simplifyCl _ (linvCl x1 x2) =
      linvCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeftInverseMagmaTerm n ->
      OpLeftInverseMagmaTerm n
    simplifyOp _ (linvOL x1 x2) =
      linvOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeftInverseMagmaTerm2 n A ->
      OpLeftInverseMagmaTerm2 n A
    simplifyOpE _ _ (linvOL2
                     x1
                     x2) =
      linvOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LeftInverseMagma A ->
      LeftInverseMagmaTerm -> A
    evalB _ Le (linvL x1 x2) =
      linv Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalCl :
      (A : Set) ->
      LeftInverseMagma A ->
      ClLeftInverseMagmaTerm A -> A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (linvCl x1 x2) =
      linv Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalOp :
      (A : Set) (n : Nat) ->
      LeftInverseMagma A ->
      Vec A n ->
      OpLeftInverseMagmaTerm n -> A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (linvOL
                        x1
                        x2) =
      linv Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      LeftInverseMagma A ->
      Vec A n ->
      OpLeftInverseMagmaTerm2 n A -> A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (linvOL2
                         x1
                         x2) =
      linv Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    inductionB :
      (P : LeftInverseMagmaTerm ->
           Set) ->
      ((x1 : LeftInverseMagmaTerm)
       (x2 : LeftInverseMagmaTerm) ->
       P x1 ->
       P x2 -> P (linvL x1 x2)) ->
      (x : LeftInverseMagmaTerm) ->
      P x
    inductionB p plinvl (linvL
                         x1
                         x2) =
      plinvl _ _
        (inductionB p plinvl x1)
        (inductionB p plinvl x2)
    inductionCl :
      (A : Set)
      (P : ClLeftInverseMagmaTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClLeftInverseMagmaTerm A)
       (x2 : ClLeftInverseMagmaTerm
          A) ->
       P x1 ->
       P x2 -> P (linvCl x1 x2)) ->
      (x : ClLeftInverseMagmaTerm
         A) -> P x
    inductionCl _ p psing plinvcl (sing
                                   x1) = psing x1
    inductionCl _ p psing plinvcl (linvCl
                                   x1
                                   x2) =
      plinvcl _ _
        (inductionCl _ p psing plinvcl
           x1)
        (inductionCl _ p psing plinvcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpLeftInverseMagmaTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpLeftInverseMagmaTerm n)
       (x2 : OpLeftInverseMagmaTerm
          n) ->
       P x1 ->
       P x2 -> P (linvOL x1 x2)) ->
      (x : OpLeftInverseMagmaTerm
         n) -> P x
    inductionOp _ p pv plinvol (v
                                x1) = pv x1
    inductionOp _ p pv plinvol (linvOL
                                x1
                                x2) =
      plinvol _ _
        (inductionOp _ p pv plinvol x1)
        (inductionOp _ p pv plinvol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeftInverseMagmaTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpLeftInverseMagmaTerm2 n
          A)
       (x2 : OpLeftInverseMagmaTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (linvOL2 x1 x2)) ->
      (x : OpLeftInverseMagmaTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 plinvol2 (v2
                                            x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 plinvol2 (sing2
                                            x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 plinvol2 (linvOL2
                                            x1
                                            x2) =
      plinvol2 _ _
        (inductionOpE _ _ p pv2 psing2
           plinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           plinvol2
           x2)
    linvL' :
      LeftInverseMagmaTerm ->
      LeftInverseMagmaTerm ->
      LeftInverseMagmaTerm
    linvL' x1 x2 = linvL x1 x2
    stageB :
      LeftInverseMagmaTerm ->
      Staged LeftInverseMagmaTerm
    stageB (linvL x1 x2) =
      stage2 _ _ _ linvL'
        (codeLift2 _ _ _ linvL')
        (stageB x1)
        (stageB x2)
    linvCl' :
      (A : Set) ->
      ClLeftInverseMagmaTerm A ->
      ClLeftInverseMagmaTerm A ->
      ClLeftInverseMagmaTerm A
    linvCl' _ x1 x2 = linvCl x1 x2
    stageCl :
      (A : Set) ->
      ClLeftInverseMagmaTerm A ->
      Staged
        (ClLeftInverseMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (linvCl x1 x2) =
      stage2 _ _ _ (linvCl' _)
        (codeLift2 _ _ _ (linvCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    linvOL' :
      (n : Nat) ->
      OpLeftInverseMagmaTerm n ->
      OpLeftInverseMagmaTerm n ->
      OpLeftInverseMagmaTerm n
    linvOL' _ x1 x2 = linvOL x1 x2
    stageOp :
      (n : Nat) ->
      OpLeftInverseMagmaTerm n ->
      Staged
        (OpLeftInverseMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (linvOL x1 x2) =
      stage2 _ _ _ (linvOL' _)
        (codeLift2 _ _ _ (linvOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    linvOL2' :
      (n : Nat) (A : Set) ->
      OpLeftInverseMagmaTerm2 n A ->
      OpLeftInverseMagmaTerm2 n A ->
      OpLeftInverseMagmaTerm2 n A
    linvOL2' _ _ x1 x2 =
      linvOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeftInverseMagmaTerm2 n A ->
      Staged
        (OpLeftInverseMagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (linvOL2 x1 x2) =
      stage2 _ _ _ (linvOL2' _ _)
        (codeLift2 _ _ _ (linvOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LeftInverseMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        linvT :
          Repr A -> Repr A -> Repr A
  
  module LeftLoop where
    record LeftLoop
      (A : Set) : Set where
      constructor LeftLoopC
      field
        op : A -> A -> A
        e : A
        runit_e : (x : A) -> op x e == x
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
    record LeftLoopSig
      (AS : Set) : Set where
      constructor LeftLoopSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
        linvS : AS -> AS -> AS
    record LeftLoopProd
      (AP : Set) : Set where
      constructor LeftLoopProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
    record LeftLoopHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftLoop A1)
      (Le2 : LeftLoop A2) : Set where
      constructor LeftLoopHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
        pres-e : hom (e Le1) == e Le2
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Le1 x1 x2) ==
            linv Le2 (hom x1) (hom x2)
    record LeftLoopRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftLoop A1)
      (Le2 : LeftLoop A2) : Set where
      constructor LeftLoopRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
        interp-e :
          interp (e Le1) (e Le2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Le1 x1 x2)
            (linv Le2 y1 y2)
    data LeftLoopLTerm : Set where
      opL :
        LeftLoopLTerm ->
        LeftLoopLTerm -> LeftLoopLTerm
      eL : LeftLoopLTerm
      linvL :
        LeftLoopLTerm ->
        LeftLoopLTerm -> LeftLoopLTerm
    data ClLeftLoopClTerm
      (A : Set) : Set where
      sing : A -> ClLeftLoopClTerm A
      opCl :
        ClLeftLoopClTerm A ->
        ClLeftLoopClTerm A ->
        ClLeftLoopClTerm A
      eCl : ClLeftLoopClTerm A
      linvCl :
        ClLeftLoopClTerm A ->
        ClLeftLoopClTerm A ->
        ClLeftLoopClTerm A
    data OpLeftLoopOLTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpLeftLoopOLTerm n
      opOL :
        OpLeftLoopOLTerm n ->
        OpLeftLoopOLTerm n ->
        OpLeftLoopOLTerm n
      eOL : OpLeftLoopOLTerm n
      linvOL :
        OpLeftLoopOLTerm n ->
        OpLeftLoopOLTerm n ->
        OpLeftLoopOLTerm n
    data OpLeftLoopOL2Term2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpLeftLoopOL2Term2 n A
      sing2 :
        A -> OpLeftLoopOL2Term2 n A
      opOL2 :
        OpLeftLoopOL2Term2 n A ->
        OpLeftLoopOL2Term2 n A ->
        OpLeftLoopOL2Term2 n A
      eOL2 : OpLeftLoopOL2Term2 n A
      linvOL2 :
        OpLeftLoopOL2Term2 n A ->
        OpLeftLoopOL2Term2 n A ->
        OpLeftLoopOL2Term2 n A
    simplifyB :
      LeftLoopLTerm -> LeftLoopLTerm
    simplifyB (opL x (eL)) = x
    simplifyB (opL x (linvL x y)) =
      y
    simplifyB (linvL x (opL x y)) =
      y
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (eL) = eL
    simplifyB (linvL x1 x2) =
      linvL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLeftLoopClTerm A ->
      ClLeftLoopClTerm A
    simplifyCl _ (opCl x (eCl)) = x
    simplifyCl _ (opCl
                  x
                  (linvCl x y)) = y
    simplifyCl _ (linvCl
                  x
                  (opCl x y)) = y
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (linvCl x1 x2) =
      linvCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeftLoopOLTerm n ->
      OpLeftLoopOLTerm n
    simplifyOp _ (opOL x (eOL)) = x
    simplifyOp _ (opOL
                  x
                  (linvOL x y)) = y
    simplifyOp _ (linvOL
                  x
                  (opOL x y)) = y
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (linvOL x1 x2) =
      linvOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeftLoopOL2Term2 n A ->
      OpLeftLoopOL2Term2 n A
    simplifyOpE _ _ (opOL2
                     x
                     (eOL2)) = x
    simplifyOpE _ _ (opOL2
                     x
                     (linvOL2 x y)) = y
    simplifyOpE _ _ (linvOL2
                     x
                     (opOL2 x y)) = y
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (linvOL2
                     x1
                     x2) =
      linvOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LeftLoop A -> LeftLoopLTerm -> A
    evalB _ Le (opL x1 x2) =
      op Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalB _ Le (eL) = e Le
    evalB _ Le (linvL x1 x2) =
      linv Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalCl :
      (A : Set) ->
      LeftLoop A ->
      ClLeftLoopClTerm A -> A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (opCl x1 x2) =
      op Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalCl _ Le (eCl) = e Le
    evalCl _ Le (linvCl x1 x2) =
      linv Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalOp :
      (A : Set) (n : Nat) ->
      LeftLoop A ->
      Vec A n ->
      OpLeftLoopOLTerm n -> A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (opOL
                        x1
                        x2) =
      op Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOp _ n Le vars (eOL) = e Le
    evalOp _ n Le vars (linvOL
                        x1
                        x2) =
      linv Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      LeftLoop A ->
      Vec A n ->
      OpLeftLoopOL2Term2 n A -> A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (opOL2
                         x1
                         x2) =
      op Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    evalOpE _ n Le vars (eOL2) =
      e Le
    evalOpE _ n Le vars (linvOL2
                         x1
                         x2) =
      linv Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    inductionB :
      (P : LeftLoopLTerm -> Set) ->
      ((x1 : LeftLoopLTerm)
       (x2 : LeftLoopLTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      P eL ->
      ((x1 : LeftLoopLTerm)
       (x2 : LeftLoopLTerm) ->
       P x1 ->
       P x2 -> P (linvL x1 x2)) ->
      (x : LeftLoopLTerm) -> P x
    inductionB p popl pel plinvl (opL
                                  x1
                                  x2) =
      popl _ _
        (inductionB p popl pel plinvl
           x1)
        (inductionB p popl pel plinvl
           x2)
    inductionB p popl pel plinvl (eL) =
      pel
    inductionB p popl pel plinvl (linvL
                                  x1
                                  x2) =
      plinvl _ _
        (inductionB p popl pel plinvl
           x1)
        (inductionB p popl pel plinvl
           x2)
    inductionCl :
      (A : Set)
      (P : ClLeftLoopClTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClLeftLoopClTerm A)
       (x2 : ClLeftLoopClTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      P eCl ->
      ((x1 : ClLeftLoopClTerm A)
       (x2 : ClLeftLoopClTerm A) ->
       P x1 ->
       P x2 -> P (linvCl x1 x2)) ->
      (x : ClLeftLoopClTerm A) -> P x
    inductionCl _ p psing popcl pecl plinvcl (sing
                                              x1) = psing x1
    inductionCl _ p psing popcl pecl plinvcl (opCl
                                              x1
                                              x2) =
      popcl _ _
        (inductionCl _ p psing popcl
           pecl
           plinvcl
           x1)
        (inductionCl _ p psing popcl
           pecl
           plinvcl
           x2)
    inductionCl _ p psing popcl pecl plinvcl (eCl) =
      pecl
    inductionCl _ p psing popcl pecl plinvcl (linvCl
                                              x1
                                              x2) =
      plinvcl _ _
        (inductionCl _ p psing popcl
           pecl
           plinvcl
           x1)
        (inductionCl _ p psing popcl
           pecl
           plinvcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpLeftLoopOLTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpLeftLoopOLTerm n)
       (x2 : OpLeftLoopOLTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      P eOL ->
      ((x1 : OpLeftLoopOLTerm n)
       (x2 : OpLeftLoopOLTerm n) ->
       P x1 ->
       P x2 -> P (linvOL x1 x2)) ->
      (x : OpLeftLoopOLTerm n) -> P x
    inductionOp _ p pv popol peol plinvol (v
                                           x1) = pv x1
    inductionOp _ p pv popol peol plinvol (opOL
                                           x1
                                           x2) =
      popol _ _
        (inductionOp _ p pv popol peol
           plinvol
           x1)
        (inductionOp _ p pv popol peol
           plinvol
           x2)
    inductionOp _ p pv popol peol plinvol (eOL) =
      peol
    inductionOp _ p pv popol peol plinvol (linvOL
                                           x1
                                           x2) =
      plinvol _ _
        (inductionOp _ p pv popol peol
           plinvol
           x1)
        (inductionOp _ p pv popol peol
           plinvol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeftLoopOL2Term2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpLeftLoopOL2Term2 n A)
       (x2 : OpLeftLoopOL2Term2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      P eOL2 ->
      ((x1 : OpLeftLoopOL2Term2 n A)
       (x2 : OpLeftLoopOL2Term2 n A) ->
       P x1 ->
       P x2 -> P (linvOL2 x1 x2)) ->
      (x : OpLeftLoopOL2Term2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 popol2 peol2 plinvol2 (v2
                                                         x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 peol2 plinvol2 (sing2
                                                         x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 peol2 plinvol2 (opOL2
                                                         x1
                                                         x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           plinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           plinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 peol2 plinvol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 popol2 peol2 plinvol2 (linvOL2
                                                         x1
                                                         x2) =
      plinvol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           plinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           plinvol2
           x2)
    opL' :
      LeftLoopLTerm ->
      LeftLoopLTerm -> LeftLoopLTerm
    opL' x1 x2 = opL x1 x2
    eL' : LeftLoopLTerm
    eL' = eL
    linvL' :
      LeftLoopLTerm ->
      LeftLoopLTerm -> LeftLoopLTerm
    linvL' x1 x2 = linvL x1 x2
    stageB :
      LeftLoopLTerm ->
      Staged LeftLoopLTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (eL) = Now eL
    stageB (linvL x1 x2) =
      stage2 _ _ _ linvL'
        (codeLift2 _ _ _ linvL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClLeftLoopClTerm A ->
      ClLeftLoopClTerm A ->
      ClLeftLoopClTerm A
    opCl' _ x1 x2 = opCl x1 x2
    eCl' :
      (A : Set) -> ClLeftLoopClTerm A
    eCl' _ = eCl
    linvCl' :
      (A : Set) ->
      ClLeftLoopClTerm A ->
      ClLeftLoopClTerm A ->
      ClLeftLoopClTerm A
    linvCl' _ x1 x2 = linvCl x1 x2
    stageCl :
      (A : Set) ->
      ClLeftLoopClTerm A ->
      Staged (ClLeftLoopClTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (eCl) = Now eCl
    stageCl _ (linvCl x1 x2) =
      stage2 _ _ _ (linvCl' _)
        (codeLift2 _ _ _ (linvCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpLeftLoopOLTerm n ->
      OpLeftLoopOLTerm n ->
      OpLeftLoopOLTerm n
    opOL' _ x1 x2 = opOL x1 x2
    eOL' :
      (n : Nat) -> OpLeftLoopOLTerm n
    eOL' _ = eOL
    linvOL' :
      (n : Nat) ->
      OpLeftLoopOLTerm n ->
      OpLeftLoopOLTerm n ->
      OpLeftLoopOLTerm n
    linvOL' _ x1 x2 = linvOL x1 x2
    stageOp :
      (n : Nat) ->
      OpLeftLoopOLTerm n ->
      Staged (OpLeftLoopOLTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (eOL) = Now eOL
    stageOp _ (linvOL x1 x2) =
      stage2 _ _ _ (linvOL' _)
        (codeLift2 _ _ _ (linvOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpLeftLoopOL2Term2 n A ->
      OpLeftLoopOL2Term2 n A ->
      OpLeftLoopOL2Term2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    eOL2' :
      (n : Nat) (A : Set) ->
      OpLeftLoopOL2Term2 n A
    eOL2' _ _ = eOL2
    linvOL2' :
      (n : Nat) (A : Set) ->
      OpLeftLoopOL2Term2 n A ->
      OpLeftLoopOL2Term2 n A ->
      OpLeftLoopOL2Term2 n A
    linvOL2' _ _ x1 x2 =
      linvOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeftLoopOL2Term2 n A ->
      Staged (OpLeftLoopOL2Term2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (linvOL2 x1 x2) =
      stage2 _ _ _ (linvOL2' _ _)
        (codeLift2 _ _ _ (linvOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LeftLoopTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
        eT : Repr A
        linvT :
          Repr A -> Repr A -> Repr A
  
  module LeftMonoid where
    record LeftMonoid
      (A : Set) : Set where
      constructor LeftMonoidC
      field
        op : A -> A -> A
        e : A
        lunit_e : (x : A) -> op e x == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record LeftMonoidSig
      (AS : Set) : Set where
      constructor LeftMonoidSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record LeftMonoidProd
      (AP : Set) : Set where
      constructor LeftMonoidProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record LeftMonoidHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftMonoid A1)
      (Le2 : LeftMonoid A2) :
      Set where
      constructor LeftMonoidHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
        pres-e : hom (e Le1) == e Le2
    record LeftMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftMonoid A1)
      (Le2 : LeftMonoid A2) :
      Set where
      constructor LeftMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
        interp-e :
          interp (e Le1) (e Le2)
    data LeftMonoidTerm : Set where
      opL :
        LeftMonoidTerm ->
        LeftMonoidTerm -> LeftMonoidTerm
      eL : LeftMonoidTerm
    data ClLeftMonoidTerm
      (A : Set) : Set where
      sing : A -> ClLeftMonoidTerm A
      opCl :
        ClLeftMonoidTerm A ->
        ClLeftMonoidTerm A ->
        ClLeftMonoidTerm A
      eCl : ClLeftMonoidTerm A
    data OpLeftMonoidTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpLeftMonoidTerm n
      opOL :
        OpLeftMonoidTerm n ->
        OpLeftMonoidTerm n ->
        OpLeftMonoidTerm n
      eOL : OpLeftMonoidTerm n
    data OpLeftMonoidTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpLeftMonoidTerm2 n A
      sing2 :
        A -> OpLeftMonoidTerm2 n A
      opOL2 :
        OpLeftMonoidTerm2 n A ->
        OpLeftMonoidTerm2 n A ->
        OpLeftMonoidTerm2 n A
      eOL2 : OpLeftMonoidTerm2 n A
    simplifyB :
      LeftMonoidTerm -> LeftMonoidTerm
    simplifyB (opL (eL) x) = x
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (eL) = eL
    simplifyCl :
      (A : Set) ->
      ClLeftMonoidTerm A ->
      ClLeftMonoidTerm A
    simplifyCl _ (opCl (eCl) x) = x
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeftMonoidTerm n ->
      OpLeftMonoidTerm n
    simplifyOp _ (opOL (eOL) x) = x
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeftMonoidTerm2 n A ->
      OpLeftMonoidTerm2 n A
    simplifyOpE _ _ (opOL2
                     (eOL2)
                     x) = x
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LeftMonoid A ->
      LeftMonoidTerm -> A
    evalB _ Le (opL x1 x2) =
      op Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalB _ Le (eL) = e Le
    evalCl :
      (A : Set) ->
      LeftMonoid A ->
      ClLeftMonoidTerm A -> A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (opCl x1 x2) =
      op Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalCl _ Le (eCl) = e Le
    evalOp :
      (A : Set) (n : Nat) ->
      LeftMonoid A ->
      Vec A n ->
      OpLeftMonoidTerm n -> A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (opOL
                        x1
                        x2) =
      op Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOp _ n Le vars (eOL) = e Le
    evalOpE :
      (A : Set) (n : Nat) ->
      LeftMonoid A ->
      Vec A n ->
      OpLeftMonoidTerm2 n A -> A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (opOL2
                         x1
                         x2) =
      op Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    evalOpE _ n Le vars (eOL2) =
      e Le
    inductionB :
      (P : LeftMonoidTerm -> Set) ->
      ((x1 : LeftMonoidTerm)
       (x2 : LeftMonoidTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      P eL ->
      (x : LeftMonoidTerm) -> P x
    inductionB p popl pel (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p popl pel x1)
        (inductionB p popl pel x2)
    inductionB p popl pel (eL) = pel
    inductionCl :
      (A : Set)
      (P : ClLeftMonoidTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClLeftMonoidTerm A)
       (x2 : ClLeftMonoidTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      P eCl ->
      (x : ClLeftMonoidTerm A) -> P x
    inductionCl _ p psing popcl pecl (sing
                                      x1) = psing x1
    inductionCl _ p psing popcl pecl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing popcl
           pecl
           x1)
        (inductionCl _ p psing popcl
           pecl
           x2)
    inductionCl _ p psing popcl pecl (eCl) =
      pecl
    inductionOp :
      (n : Nat)
      (P : OpLeftMonoidTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpLeftMonoidTerm n)
       (x2 : OpLeftMonoidTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      P eOL ->
      (x : OpLeftMonoidTerm n) -> P x
    inductionOp _ p pv popol peol (v
                                   x1) = pv x1
    inductionOp _ p pv popol peol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv popol peol
           x1)
        (inductionOp _ p pv popol peol
           x2)
    inductionOp _ p pv popol peol (eOL) =
      peol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeftMonoidTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpLeftMonoidTerm2 n A)
       (x2 : OpLeftMonoidTerm2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      P eOL2 ->
      (x : OpLeftMonoidTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (eOL2) =
      peol2
    opL' :
      LeftMonoidTerm ->
      LeftMonoidTerm -> LeftMonoidTerm
    opL' x1 x2 = opL x1 x2
    eL' : LeftMonoidTerm
    eL' = eL
    stageB :
      LeftMonoidTerm ->
      Staged LeftMonoidTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (eL) = Now eL
    opCl' :
      (A : Set) ->
      ClLeftMonoidTerm A ->
      ClLeftMonoidTerm A ->
      ClLeftMonoidTerm A
    opCl' _ x1 x2 = opCl x1 x2
    eCl' :
      (A : Set) -> ClLeftMonoidTerm A
    eCl' _ = eCl
    stageCl :
      (A : Set) ->
      ClLeftMonoidTerm A ->
      Staged (ClLeftMonoidTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (eCl) = Now eCl
    opOL' :
      (n : Nat) ->
      OpLeftMonoidTerm n ->
      OpLeftMonoidTerm n ->
      OpLeftMonoidTerm n
    opOL' _ x1 x2 = opOL x1 x2
    eOL' :
      (n : Nat) -> OpLeftMonoidTerm n
    eOL' _ = eOL
    stageOp :
      (n : Nat) ->
      OpLeftMonoidTerm n ->
      Staged (OpLeftMonoidTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (eOL) = Now eOL
    opOL2' :
      (n : Nat) (A : Set) ->
      OpLeftMonoidTerm2 n A ->
      OpLeftMonoidTerm2 n A ->
      OpLeftMonoidTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    eOL2' :
      (n : Nat) (A : Set) ->
      OpLeftMonoidTerm2 n A
    eOL2' _ _ = eOL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeftMonoidTerm2 n A ->
      Staged (OpLeftMonoidTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (eOL2) = Now eOL2
    record LeftMonoidTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
        eT : Repr A
  
  module LeftPreSemiring where
    record LeftPreSemiring
      (A : Set) : Set where
      constructor LeftPreSemiringC
      field
        * : A -> A -> A
        + : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record LeftPreSemiringSig
      (AS : Set) : Set where
      constructor LeftPreSemiringSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record LeftPreSemiringProd
      (AP : Set) : Set where
      constructor LeftPreSemiringProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record LeftPreSemiringHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftPreSemiring A1)
      (Le2 : LeftPreSemiring A2) :
      Set where
      constructor LeftPreSemiringHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Le1 x1 x2) ==
            * Le2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Le1 x1 x2) ==
            + Le2 (hom x1) (hom x2)
    record LeftPreSemiringRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftPreSemiring A1)
      (Le2 : LeftPreSemiring A2) :
      Set where
      constructor LeftPreSemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Le1 x1 x2)
            (* Le2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Le1 x1 x2)
            (+ Le2 y1 y2)
    data LeftPreSemiringTerm
      : Set where
      *L :
        LeftPreSemiringTerm ->
        LeftPreSemiringTerm ->
        LeftPreSemiringTerm
      +L :
        LeftPreSemiringTerm ->
        LeftPreSemiringTerm ->
        LeftPreSemiringTerm
    data ClLeftPreSemiringTerm
      (A : Set) : Set where
      sing :
        A -> ClLeftPreSemiringTerm A
      *Cl :
        ClLeftPreSemiringTerm A ->
        ClLeftPreSemiringTerm A ->
        ClLeftPreSemiringTerm A
      +Cl :
        ClLeftPreSemiringTerm A ->
        ClLeftPreSemiringTerm A ->
        ClLeftPreSemiringTerm A
    data OpLeftPreSemiringTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpLeftPreSemiringTerm n
      *OL :
        OpLeftPreSemiringTerm n ->
        OpLeftPreSemiringTerm n ->
        OpLeftPreSemiringTerm n
      +OL :
        OpLeftPreSemiringTerm n ->
        OpLeftPreSemiringTerm n ->
        OpLeftPreSemiringTerm n
    data OpLeftPreSemiringTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpLeftPreSemiringTerm2 n A
      sing2 :
        A -> OpLeftPreSemiringTerm2 n A
      *OL2 :
        OpLeftPreSemiringTerm2 n A ->
        OpLeftPreSemiringTerm2 n A ->
        OpLeftPreSemiringTerm2 n A
      +OL2 :
        OpLeftPreSemiringTerm2 n A ->
        OpLeftPreSemiringTerm2 n A ->
        OpLeftPreSemiringTerm2 n A
    simplifyB :
      LeftPreSemiringTerm ->
      LeftPreSemiringTerm
    simplifyB (+L
               (*L x y)
               (*L x z)) = *L x (+L y z)
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLeftPreSemiringTerm A ->
      ClLeftPreSemiringTerm A
    simplifyCl _ (+Cl
                  (*Cl x y)
                  (*Cl x z)) = *Cl x (+Cl y z)
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeftPreSemiringTerm n ->
      OpLeftPreSemiringTerm n
    simplifyOp _ (+OL
                  (*OL x y)
                  (*OL x z)) = *OL x (+OL y z)
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeftPreSemiringTerm2 n A ->
      OpLeftPreSemiringTerm2 n A
    simplifyOpE _ _ (+OL2
                     (*OL2 x y)
                     (*OL2 x z)) = *OL2 x (+OL2 y z)
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LeftPreSemiring A ->
      LeftPreSemiringTerm -> A
    evalB _ Le (*L x1 x2) =
      * Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalB _ Le (+L x1 x2) =
      + Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalCl :
      (A : Set) ->
      LeftPreSemiring A ->
      ClLeftPreSemiringTerm A -> A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (*Cl x1 x2) =
      * Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalCl _ Le (+Cl x1 x2) =
      + Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalOp :
      (A : Set) (n : Nat) ->
      LeftPreSemiring A ->
      Vec A n ->
      OpLeftPreSemiringTerm n -> A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (*OL x1 x2) =
      * Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOp _ n Le vars (+OL x1 x2) =
      + Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      LeftPreSemiring A ->
      Vec A n ->
      OpLeftPreSemiringTerm2 n A -> A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (*OL2
                         x1
                         x2) =
      * Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    evalOpE _ n Le vars (+OL2
                         x1
                         x2) =
      + Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    inductionB :
      (P : LeftPreSemiringTerm ->
           Set) ->
      ((x1 : LeftPreSemiringTerm)
       (x2 : LeftPreSemiringTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : LeftPreSemiringTerm)
       (x2 : LeftPreSemiringTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : LeftPreSemiringTerm) -> P x
    inductionB p p*l p+l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionB p p*l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClLeftPreSemiringTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClLeftPreSemiringTerm A)
       (x2 : ClLeftPreSemiringTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClLeftPreSemiringTerm A)
       (x2 : ClLeftPreSemiringTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClLeftPreSemiringTerm A) ->
      P x
    inductionCl _ p psing p*cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p*cl p+cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionCl _ p psing p*cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpLeftPreSemiringTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpLeftPreSemiringTerm n)
       (x2 : OpLeftPreSemiringTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpLeftPreSemiringTerm n)
       (x2 : OpLeftPreSemiringTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpLeftPreSemiringTerm n) ->
      P x
    inductionOp _ p pv p*ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p*ol p+ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOp _ p pv p*ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeftPreSemiringTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpLeftPreSemiringTerm2 n
          A)
       (x2 : OpLeftPreSemiringTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpLeftPreSemiringTerm2 n
          A)
       (x2 : OpLeftPreSemiringTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpLeftPreSemiringTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    *L' :
      LeftPreSemiringTerm ->
      LeftPreSemiringTerm ->
      LeftPreSemiringTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      LeftPreSemiringTerm ->
      LeftPreSemiringTerm ->
      LeftPreSemiringTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      LeftPreSemiringTerm ->
      Staged LeftPreSemiringTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClLeftPreSemiringTerm A ->
      ClLeftPreSemiringTerm A ->
      ClLeftPreSemiringTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClLeftPreSemiringTerm A ->
      ClLeftPreSemiringTerm A ->
      ClLeftPreSemiringTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClLeftPreSemiringTerm A ->
      Staged (ClLeftPreSemiringTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpLeftPreSemiringTerm n ->
      OpLeftPreSemiringTerm n ->
      OpLeftPreSemiringTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpLeftPreSemiringTerm n ->
      OpLeftPreSemiringTerm n ->
      OpLeftPreSemiringTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpLeftPreSemiringTerm n ->
      Staged (OpLeftPreSemiringTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpLeftPreSemiringTerm2 n A ->
      OpLeftPreSemiringTerm2 n A ->
      OpLeftPreSemiringTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpLeftPreSemiringTerm2 n A ->
      OpLeftPreSemiringTerm2 n A ->
      OpLeftPreSemiringTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeftPreSemiringTerm2 n A ->
      Staged
        (OpLeftPreSemiringTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LeftPreSemiringTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module LeftQuasiGroup where
    record LeftQuasiGroup
      (A : Set) : Set where
      constructor LeftQuasiGroupC
      field
        op : A -> A -> A
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
    record LeftQuasiGroupSig
      (AS : Set) : Set where
      constructor LeftQuasiGroupSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
    record LeftQuasiGroupProd
      (AP : Set) : Set where
      constructor LeftQuasiGroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
    record LeftQuasiGroupHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftQuasiGroup A1)
      (Le2 : LeftQuasiGroup A2) :
      Set where
      constructor LeftQuasiGroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Le1 x1 x2) ==
            linv Le2 (hom x1) (hom x2)
    record LeftQuasiGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftQuasiGroup A1)
      (Le2 : LeftQuasiGroup A2) :
      Set where
      constructor LeftQuasiGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Le1 x1 x2)
            (linv Le2 y1 y2)
    data LeftQuasiGroupTerm
      : Set where
      opL :
        LeftQuasiGroupTerm ->
        LeftQuasiGroupTerm ->
        LeftQuasiGroupTerm
      linvL :
        LeftQuasiGroupTerm ->
        LeftQuasiGroupTerm ->
        LeftQuasiGroupTerm
    data ClLeftQuasiGroupTerm
      (A : Set) : Set where
      sing :
        A -> ClLeftQuasiGroupTerm A
      opCl :
        ClLeftQuasiGroupTerm A ->
        ClLeftQuasiGroupTerm A ->
        ClLeftQuasiGroupTerm A
      linvCl :
        ClLeftQuasiGroupTerm A ->
        ClLeftQuasiGroupTerm A ->
        ClLeftQuasiGroupTerm A
    data OpLeftQuasiGroupTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpLeftQuasiGroupTerm n
      opOL :
        OpLeftQuasiGroupTerm n ->
        OpLeftQuasiGroupTerm n ->
        OpLeftQuasiGroupTerm n
      linvOL :
        OpLeftQuasiGroupTerm n ->
        OpLeftQuasiGroupTerm n ->
        OpLeftQuasiGroupTerm n
    data OpLeftQuasiGroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpLeftQuasiGroupTerm2 n A
      sing2 :
        A -> OpLeftQuasiGroupTerm2 n A
      opOL2 :
        OpLeftQuasiGroupTerm2 n A ->
        OpLeftQuasiGroupTerm2 n A ->
        OpLeftQuasiGroupTerm2 n A
      linvOL2 :
        OpLeftQuasiGroupTerm2 n A ->
        OpLeftQuasiGroupTerm2 n A ->
        OpLeftQuasiGroupTerm2 n A
    simplifyB :
      LeftQuasiGroupTerm ->
      LeftQuasiGroupTerm
    simplifyB (opL x (linvL x y)) =
      y
    simplifyB (linvL x (opL x y)) =
      y
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (linvL x1 x2) =
      linvL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLeftQuasiGroupTerm A ->
      ClLeftQuasiGroupTerm A
    simplifyCl _ (opCl
                  x
                  (linvCl x y)) = y
    simplifyCl _ (linvCl
                  x
                  (opCl x y)) = y
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (linvCl x1 x2) =
      linvCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeftQuasiGroupTerm n ->
      OpLeftQuasiGroupTerm n
    simplifyOp _ (opOL
                  x
                  (linvOL x y)) = y
    simplifyOp _ (linvOL
                  x
                  (opOL x y)) = y
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (linvOL x1 x2) =
      linvOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeftQuasiGroupTerm2 n A ->
      OpLeftQuasiGroupTerm2 n A
    simplifyOpE _ _ (opOL2
                     x
                     (linvOL2 x y)) = y
    simplifyOpE _ _ (linvOL2
                     x
                     (opOL2 x y)) = y
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (linvOL2
                     x1
                     x2) =
      linvOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LeftQuasiGroup A ->
      LeftQuasiGroupTerm -> A
    evalB _ Le (opL x1 x2) =
      op Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalB _ Le (linvL x1 x2) =
      linv Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalCl :
      (A : Set) ->
      LeftQuasiGroup A ->
      ClLeftQuasiGroupTerm A -> A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (opCl x1 x2) =
      op Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalCl _ Le (linvCl x1 x2) =
      linv Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalOp :
      (A : Set) (n : Nat) ->
      LeftQuasiGroup A ->
      Vec A n ->
      OpLeftQuasiGroupTerm n -> A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (opOL
                        x1
                        x2) =
      op Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOp _ n Le vars (linvOL
                        x1
                        x2) =
      linv Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      LeftQuasiGroup A ->
      Vec A n ->
      OpLeftQuasiGroupTerm2 n A -> A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (opOL2
                         x1
                         x2) =
      op Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    evalOpE _ n Le vars (linvOL2
                         x1
                         x2) =
      linv Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    inductionB :
      (P : LeftQuasiGroupTerm ->
           Set) ->
      ((x1 : LeftQuasiGroupTerm)
       (x2 : LeftQuasiGroupTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      ((x1 : LeftQuasiGroupTerm)
       (x2 : LeftQuasiGroupTerm) ->
       P x1 ->
       P x2 -> P (linvL x1 x2)) ->
      (x : LeftQuasiGroupTerm) -> P x
    inductionB p popl plinvl (opL
                              x1
                              x2) =
      popl _ _
        (inductionB p popl plinvl x1)
        (inductionB p popl plinvl x2)
    inductionB p popl plinvl (linvL
                              x1
                              x2) =
      plinvl _ _
        (inductionB p popl plinvl x1)
        (inductionB p popl plinvl x2)
    inductionCl :
      (A : Set)
      (P : ClLeftQuasiGroupTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClLeftQuasiGroupTerm A)
       (x2 : ClLeftQuasiGroupTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      ((x1 : ClLeftQuasiGroupTerm A)
       (x2 : ClLeftQuasiGroupTerm A) ->
       P x1 ->
       P x2 -> P (linvCl x1 x2)) ->
      (x : ClLeftQuasiGroupTerm A) ->
      P x
    inductionCl _ p psing popcl plinvcl (sing
                                         x1) = psing x1
    inductionCl _ p psing popcl plinvcl (opCl
                                         x1
                                         x2) =
      popcl _ _
        (inductionCl _ p psing popcl
           plinvcl
           x1)
        (inductionCl _ p psing popcl
           plinvcl
           x2)
    inductionCl _ p psing popcl plinvcl (linvCl
                                         x1
                                         x2) =
      plinvcl _ _
        (inductionCl _ p psing popcl
           plinvcl
           x1)
        (inductionCl _ p psing popcl
           plinvcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpLeftQuasiGroupTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpLeftQuasiGroupTerm n)
       (x2 : OpLeftQuasiGroupTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      ((x1 : OpLeftQuasiGroupTerm n)
       (x2 : OpLeftQuasiGroupTerm n) ->
       P x1 ->
       P x2 -> P (linvOL x1 x2)) ->
      (x : OpLeftQuasiGroupTerm n) ->
      P x
    inductionOp _ p pv popol plinvol (v
                                      x1) = pv x1
    inductionOp _ p pv popol plinvol (opOL
                                      x1
                                      x2) =
      popol _ _
        (inductionOp _ p pv popol
           plinvol
           x1)
        (inductionOp _ p pv popol
           plinvol
           x2)
    inductionOp _ p pv popol plinvol (linvOL
                                      x1
                                      x2) =
      plinvol _ _
        (inductionOp _ p pv popol
           plinvol
           x1)
        (inductionOp _ p pv popol
           plinvol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeftQuasiGroupTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpLeftQuasiGroupTerm2 n
          A)
       (x2 : OpLeftQuasiGroupTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      ((x1 : OpLeftQuasiGroupTerm2 n
          A)
       (x2 : OpLeftQuasiGroupTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (linvOL2 x1 x2)) ->
      (x : OpLeftQuasiGroupTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 (v2
                                                   x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 (sing2
                                                   x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 (opOL2
                                                   x1
                                                   x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 (linvOL2
                                                   x1
                                                   x2) =
      plinvol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           x2)
    opL' :
      LeftQuasiGroupTerm ->
      LeftQuasiGroupTerm ->
      LeftQuasiGroupTerm
    opL' x1 x2 = opL x1 x2
    linvL' :
      LeftQuasiGroupTerm ->
      LeftQuasiGroupTerm ->
      LeftQuasiGroupTerm
    linvL' x1 x2 = linvL x1 x2
    stageB :
      LeftQuasiGroupTerm ->
      Staged LeftQuasiGroupTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (linvL x1 x2) =
      stage2 _ _ _ linvL'
        (codeLift2 _ _ _ linvL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClLeftQuasiGroupTerm A ->
      ClLeftQuasiGroupTerm A ->
      ClLeftQuasiGroupTerm A
    opCl' _ x1 x2 = opCl x1 x2
    linvCl' :
      (A : Set) ->
      ClLeftQuasiGroupTerm A ->
      ClLeftQuasiGroupTerm A ->
      ClLeftQuasiGroupTerm A
    linvCl' _ x1 x2 = linvCl x1 x2
    stageCl :
      (A : Set) ->
      ClLeftQuasiGroupTerm A ->
      Staged (ClLeftQuasiGroupTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (linvCl x1 x2) =
      stage2 _ _ _ (linvCl' _)
        (codeLift2 _ _ _ (linvCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpLeftQuasiGroupTerm n ->
      OpLeftQuasiGroupTerm n ->
      OpLeftQuasiGroupTerm n
    opOL' _ x1 x2 = opOL x1 x2
    linvOL' :
      (n : Nat) ->
      OpLeftQuasiGroupTerm n ->
      OpLeftQuasiGroupTerm n ->
      OpLeftQuasiGroupTerm n
    linvOL' _ x1 x2 = linvOL x1 x2
    stageOp :
      (n : Nat) ->
      OpLeftQuasiGroupTerm n ->
      Staged (OpLeftQuasiGroupTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (linvOL x1 x2) =
      stage2 _ _ _ (linvOL' _)
        (codeLift2 _ _ _ (linvOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpLeftQuasiGroupTerm2 n A ->
      OpLeftQuasiGroupTerm2 n A ->
      OpLeftQuasiGroupTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    linvOL2' :
      (n : Nat) (A : Set) ->
      OpLeftQuasiGroupTerm2 n A ->
      OpLeftQuasiGroupTerm2 n A ->
      OpLeftQuasiGroupTerm2 n A
    linvOL2' _ _ x1 x2 =
      linvOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeftQuasiGroupTerm2 n A ->
      Staged
        (OpLeftQuasiGroupTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (linvOL2 x1 x2) =
      stage2 _ _ _ (linvOL2' _ _)
        (codeLift2 _ _ _ (linvOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LeftQuasiGroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
        linvT :
          Repr A -> Repr A -> Repr A
  
  module LeftRack where
    record LeftRack
      (A : Set) : Set where
      constructor LeftRackC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
    record LeftRackSig
      (AS : Set) : Set where
      constructor LeftRackSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record LeftRackProd
      (AP : Set) : Set where
      constructor LeftRackProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
    record LeftRackHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftRack A1)
      (Le2 : LeftRack A2) : Set where
      constructor LeftRackHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Le1 x1 x2) ==
            <| Le2 (hom x1) (hom x2)
    record LeftRackRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftRack A1)
      (Le2 : LeftRack A2) : Set where
      constructor LeftRackRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Le1 x1 x2)
            (<| Le2 y1 y2)
    data LeftRackTerm : Set where
      |>L :
        LeftRackTerm ->
        LeftRackTerm -> LeftRackTerm
      <|L :
        LeftRackTerm ->
        LeftRackTerm -> LeftRackTerm
    data ClLeftRackTerm
      (A : Set) : Set where
      sing : A -> ClLeftRackTerm A
      |>Cl :
        ClLeftRackTerm A ->
        ClLeftRackTerm A ->
        ClLeftRackTerm A
      <|Cl :
        ClLeftRackTerm A ->
        ClLeftRackTerm A ->
        ClLeftRackTerm A
    data OpLeftRackTerm
      (n : Nat) : Set where
      v : Fin n -> OpLeftRackTerm n
      |>OL :
        OpLeftRackTerm n ->
        OpLeftRackTerm n ->
        OpLeftRackTerm n
      <|OL :
        OpLeftRackTerm n ->
        OpLeftRackTerm n ->
        OpLeftRackTerm n
    data OpLeftRackTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpLeftRackTerm2 n A
      sing2 : A -> OpLeftRackTerm2 n A
      |>OL2 :
        OpLeftRackTerm2 n A ->
        OpLeftRackTerm2 n A ->
        OpLeftRackTerm2 n A
      <|OL2 :
        OpLeftRackTerm2 n A ->
        OpLeftRackTerm2 n A ->
        OpLeftRackTerm2 n A
    simplifyB :
      LeftRackTerm -> LeftRackTerm
    simplifyB (|>L
               (|>L x y)
               (|>L x z)) = |>L x (|>L y z)
    simplifyB (|>L x1 x2) =
      |>L (simplifyB x1)
        (simplifyB x2)
    simplifyB (<|L x1 x2) =
      <|L (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLeftRackTerm A ->
      ClLeftRackTerm A
    simplifyCl _ (|>Cl
                  (|>Cl x y)
                  (|>Cl x z)) = |>Cl x (|>Cl y z)
    simplifyCl _ (|>Cl x1 x2) =
      |>Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (<|Cl x1 x2) =
      <|Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeftRackTerm n ->
      OpLeftRackTerm n
    simplifyOp _ (|>OL
                  (|>OL x y)
                  (|>OL x z)) = |>OL x (|>OL y z)
    simplifyOp _ (|>OL x1 x2) =
      |>OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (<|OL x1 x2) =
      <|OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeftRackTerm2 n A ->
      OpLeftRackTerm2 n A
    simplifyOpE _ _ (|>OL2
                     (|>OL2 x y)
                     (|>OL2 x z)) =
      |>OL2 x (|>OL2 y z)
    simplifyOpE _ _ (|>OL2 x1 x2) =
      |>OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (<|OL2 x1 x2) =
      <|OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LeftRack A -> LeftRackTerm -> A
    evalB _ Le (|>L x1 x2) =
      |> Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalB _ Le (<|L x1 x2) =
      <| Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalCl :
      (A : Set) ->
      LeftRack A ->
      ClLeftRackTerm A -> A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (|>Cl x1 x2) =
      |> Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalCl _ Le (<|Cl x1 x2) =
      <| Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalOp :
      (A : Set) (n : Nat) ->
      LeftRack A ->
      Vec A n -> OpLeftRackTerm n -> A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (|>OL
                        x1
                        x2) =
      |> Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOp _ n Le vars (<|OL
                        x1
                        x2) =
      <| Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      LeftRack A ->
      Vec A n ->
      OpLeftRackTerm2 n A -> A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (|>OL2
                         x1
                         x2) =
      |> Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    evalOpE _ n Le vars (<|OL2
                         x1
                         x2) =
      <| Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    inductionB :
      (P : LeftRackTerm -> Set) ->
      ((x1 : LeftRackTerm)
       (x2 : LeftRackTerm) ->
       P x1 ->
       P x2 -> P (|>L x1 x2)) ->
      ((x1 : LeftRackTerm)
       (x2 : LeftRackTerm) ->
       P x1 ->
       P x2 -> P (<|L x1 x2)) ->
      (x : LeftRackTerm) -> P x
    inductionB p p|>l p<|l (|>L
                            x1
                            x2) =
      p|>l _ _
        (inductionB p p|>l p<|l x1)
        (inductionB p p|>l p<|l x2)
    inductionB p p|>l p<|l (<|L
                            x1
                            x2) =
      p<|l _ _
        (inductionB p p|>l p<|l x1)
        (inductionB p p|>l p<|l x2)
    inductionCl :
      (A : Set)
      (P : ClLeftRackTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClLeftRackTerm A)
       (x2 : ClLeftRackTerm A) ->
       P x1 ->
       P x2 -> P (|>Cl x1 x2)) ->
      ((x1 : ClLeftRackTerm A)
       (x2 : ClLeftRackTerm A) ->
       P x1 ->
       P x2 -> P (<|Cl x1 x2)) ->
      (x : ClLeftRackTerm A) -> P x
    inductionCl _ p psing p|>cl p<|cl (sing
                                       x1) = psing x1
    inductionCl _ p psing p|>cl p<|cl (|>Cl
                                       x1
                                       x2) =
      p|>cl _ _
        (inductionCl _ p psing p|>cl
           p<|cl
           x1)
        (inductionCl _ p psing p|>cl
           p<|cl
           x2)
    inductionCl _ p psing p|>cl p<|cl (<|Cl
                                       x1
                                       x2) =
      p<|cl _ _
        (inductionCl _ p psing p|>cl
           p<|cl
           x1)
        (inductionCl _ p psing p|>cl
           p<|cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpLeftRackTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpLeftRackTerm n)
       (x2 : OpLeftRackTerm n) ->
       P x1 ->
       P x2 -> P (|>OL x1 x2)) ->
      ((x1 : OpLeftRackTerm n)
       (x2 : OpLeftRackTerm n) ->
       P x1 ->
       P x2 -> P (<|OL x1 x2)) ->
      (x : OpLeftRackTerm n) -> P x
    inductionOp _ p pv p|>ol p<|ol (v
                                    x1) = pv x1
    inductionOp _ p pv p|>ol p<|ol (|>OL
                                    x1
                                    x2) =
      p|>ol _ _
        (inductionOp _ p pv p|>ol p<|ol
           x1)
        (inductionOp _ p pv p|>ol p<|ol
           x2)
    inductionOp _ p pv p|>ol p<|ol (<|OL
                                    x1
                                    x2) =
      p<|ol _ _
        (inductionOp _ p pv p|>ol p<|ol
           x1)
        (inductionOp _ p pv p|>ol p<|ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeftRackTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpLeftRackTerm2 n A)
       (x2 : OpLeftRackTerm2 n A) ->
       P x1 ->
       P x2 -> P (|>OL2 x1 x2)) ->
      ((x1 : OpLeftRackTerm2 n A)
       (x2 : OpLeftRackTerm2 n A) ->
       P x1 ->
       P x2 -> P (<|OL2 x1 x2)) ->
      (x : OpLeftRackTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (v2
                                                 x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (sing2
                                                 x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (|>OL2
                                                 x1
                                                 x2) =
      p|>ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (<|OL2
                                                 x1
                                                 x2) =
      p<|ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x2)
    |>L' :
      LeftRackTerm ->
      LeftRackTerm -> LeftRackTerm
    |>L' x1 x2 = |>L x1 x2
    <|L' :
      LeftRackTerm ->
      LeftRackTerm -> LeftRackTerm
    <|L' x1 x2 = <|L x1 x2
    stageB :
      LeftRackTerm ->
      Staged LeftRackTerm
    stageB (|>L x1 x2) =
      stage2 _ _ _ |>L'
        (codeLift2 _ _ _ |>L')
        (stageB x1)
        (stageB x2)
    stageB (<|L x1 x2) =
      stage2 _ _ _ <|L'
        (codeLift2 _ _ _ <|L')
        (stageB x1)
        (stageB x2)
    |>Cl' :
      (A : Set) ->
      ClLeftRackTerm A ->
      ClLeftRackTerm A ->
      ClLeftRackTerm A
    |>Cl' _ x1 x2 = |>Cl x1 x2
    <|Cl' :
      (A : Set) ->
      ClLeftRackTerm A ->
      ClLeftRackTerm A ->
      ClLeftRackTerm A
    <|Cl' _ x1 x2 = <|Cl x1 x2
    stageCl :
      (A : Set) ->
      ClLeftRackTerm A ->
      Staged (ClLeftRackTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (|>Cl x1 x2) =
      stage2 _ _ _ (|>Cl' _)
        (codeLift2 _ _ _ (|>Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (<|Cl x1 x2) =
      stage2 _ _ _ (<|Cl' _)
        (codeLift2 _ _ _ (<|Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    |>OL' :
      (n : Nat) ->
      OpLeftRackTerm n ->
      OpLeftRackTerm n ->
      OpLeftRackTerm n
    |>OL' _ x1 x2 = |>OL x1 x2
    <|OL' :
      (n : Nat) ->
      OpLeftRackTerm n ->
      OpLeftRackTerm n ->
      OpLeftRackTerm n
    <|OL' _ x1 x2 = <|OL x1 x2
    stageOp :
      (n : Nat) ->
      OpLeftRackTerm n ->
      Staged (OpLeftRackTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (|>OL x1 x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (<|OL x1 x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    |>OL2' :
      (n : Nat) (A : Set) ->
      OpLeftRackTerm2 n A ->
      OpLeftRackTerm2 n A ->
      OpLeftRackTerm2 n A
    |>OL2' _ _ x1 x2 = |>OL2 x1 x2
    <|OL2' :
      (n : Nat) (A : Set) ->
      OpLeftRackTerm2 n A ->
      OpLeftRackTerm2 n A ->
      OpLeftRackTerm2 n A
    <|OL2' _ _ x1 x2 = <|OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeftRackTerm2 n A ->
      Staged (OpLeftRackTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (|>OL2 x1 x2) =
      stage2 _ _ _ (|>OL2' _ _)
        (codeLift2 _ _ _ (|>OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (<|OL2 x1 x2) =
      stage2 _ _ _ (<|OL2' _ _)
        (codeLift2 _ _ _ (<|OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LeftRackTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        |>T : Repr A -> Repr A -> Repr A
        <|T : Repr A -> Repr A -> Repr A
  
  module LeftRingoid where
    record LeftRingoid
      (A : Set) : Set where
      constructor LeftRingoidC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
    record LeftRingoidSig
      (AS : Set) : Set where
      constructor LeftRingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record LeftRingoidProd
      (AP : Set) : Set where
      constructor LeftRingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
    record LeftRingoidHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftRingoid A1)
      (Le2 : LeftRingoid A2) :
      Set where
      constructor LeftRingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Le1 x1 x2) ==
            * Le2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Le1 x1 x2) ==
            + Le2 (hom x1) (hom x2)
    record LeftRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftRingoid A1)
      (Le2 : LeftRingoid A2) :
      Set where
      constructor LeftRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Le1 x1 x2)
            (* Le2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Le1 x1 x2)
            (+ Le2 y1 y2)
    data LeftRingoidTerm : Set where
      *L :
        LeftRingoidTerm ->
        LeftRingoidTerm ->
        LeftRingoidTerm
      +L :
        LeftRingoidTerm ->
        LeftRingoidTerm ->
        LeftRingoidTerm
    data ClLeftRingoidTerm
      (A : Set) : Set where
      sing :
        A -> ClLeftRingoidTerm A
      *Cl :
        ClLeftRingoidTerm A ->
        ClLeftRingoidTerm A ->
        ClLeftRingoidTerm A
      +Cl :
        ClLeftRingoidTerm A ->
        ClLeftRingoidTerm A ->
        ClLeftRingoidTerm A
    data OpLeftRingoidTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpLeftRingoidTerm n
      *OL :
        OpLeftRingoidTerm n ->
        OpLeftRingoidTerm n ->
        OpLeftRingoidTerm n
      +OL :
        OpLeftRingoidTerm n ->
        OpLeftRingoidTerm n ->
        OpLeftRingoidTerm n
    data OpLeftRingoidTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpLeftRingoidTerm2 n A
      sing2 :
        A -> OpLeftRingoidTerm2 n A
      *OL2 :
        OpLeftRingoidTerm2 n A ->
        OpLeftRingoidTerm2 n A ->
        OpLeftRingoidTerm2 n A
      +OL2 :
        OpLeftRingoidTerm2 n A ->
        OpLeftRingoidTerm2 n A ->
        OpLeftRingoidTerm2 n A
    simplifyB :
      LeftRingoidTerm ->
      LeftRingoidTerm
    simplifyB (+L
               (*L x y)
               (*L x z)) = *L x (+L y z)
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLeftRingoidTerm A ->
      ClLeftRingoidTerm A
    simplifyCl _ (+Cl
                  (*Cl x y)
                  (*Cl x z)) = *Cl x (+Cl y z)
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeftRingoidTerm n ->
      OpLeftRingoidTerm n
    simplifyOp _ (+OL
                  (*OL x y)
                  (*OL x z)) = *OL x (+OL y z)
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeftRingoidTerm2 n A ->
      OpLeftRingoidTerm2 n A
    simplifyOpE _ _ (+OL2
                     (*OL2 x y)
                     (*OL2 x z)) = *OL2 x (+OL2 y z)
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LeftRingoid A ->
      LeftRingoidTerm -> A
    evalB _ Le (*L x1 x2) =
      * Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalB _ Le (+L x1 x2) =
      + Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalCl :
      (A : Set) ->
      LeftRingoid A ->
      ClLeftRingoidTerm A -> A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (*Cl x1 x2) =
      * Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalCl _ Le (+Cl x1 x2) =
      + Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalOp :
      (A : Set) (n : Nat) ->
      LeftRingoid A ->
      Vec A n ->
      OpLeftRingoidTerm n -> A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (*OL x1 x2) =
      * Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOp _ n Le vars (+OL x1 x2) =
      + Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      LeftRingoid A ->
      Vec A n ->
      OpLeftRingoidTerm2 n A -> A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (*OL2
                         x1
                         x2) =
      * Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    evalOpE _ n Le vars (+OL2
                         x1
                         x2) =
      + Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    inductionB :
      (P : LeftRingoidTerm -> Set) ->
      ((x1 : LeftRingoidTerm)
       (x2 : LeftRingoidTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : LeftRingoidTerm)
       (x2 : LeftRingoidTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : LeftRingoidTerm) -> P x
    inductionB p p*l p+l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionB p p*l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClLeftRingoidTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClLeftRingoidTerm A)
       (x2 : ClLeftRingoidTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClLeftRingoidTerm A)
       (x2 : ClLeftRingoidTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClLeftRingoidTerm A) -> P x
    inductionCl _ p psing p*cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p*cl p+cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionCl _ p psing p*cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpLeftRingoidTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpLeftRingoidTerm n)
       (x2 : OpLeftRingoidTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpLeftRingoidTerm n)
       (x2 : OpLeftRingoidTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpLeftRingoidTerm n) -> P x
    inductionOp _ p pv p*ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p*ol p+ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOp _ p pv p*ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeftRingoidTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpLeftRingoidTerm2 n A)
       (x2 : OpLeftRingoidTerm2 n A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpLeftRingoidTerm2 n A)
       (x2 : OpLeftRingoidTerm2 n A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpLeftRingoidTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    *L' :
      LeftRingoidTerm ->
      LeftRingoidTerm ->
      LeftRingoidTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      LeftRingoidTerm ->
      LeftRingoidTerm ->
      LeftRingoidTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      LeftRingoidTerm ->
      Staged LeftRingoidTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClLeftRingoidTerm A ->
      ClLeftRingoidTerm A ->
      ClLeftRingoidTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClLeftRingoidTerm A ->
      ClLeftRingoidTerm A ->
      ClLeftRingoidTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClLeftRingoidTerm A ->
      Staged (ClLeftRingoidTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpLeftRingoidTerm n ->
      OpLeftRingoidTerm n ->
      OpLeftRingoidTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpLeftRingoidTerm n ->
      OpLeftRingoidTerm n ->
      OpLeftRingoidTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpLeftRingoidTerm n ->
      Staged (OpLeftRingoidTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpLeftRingoidTerm2 n A ->
      OpLeftRingoidTerm2 n A ->
      OpLeftRingoidTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpLeftRingoidTerm2 n A ->
      OpLeftRingoidTerm2 n A ->
      OpLeftRingoidTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeftRingoidTerm2 n A ->
      Staged (OpLeftRingoidTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LeftRingoidTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module LeftShelf where
    record LeftShelf
      (A : Set) : Set where
      constructor LeftShelfC
      field
        |> : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
    record LeftShelfSig
      (AS : Set) : Set where
      constructor LeftShelfSigSigC
      field
        |>S : AS -> AS -> AS
    record LeftShelfProd
      (AP : Set) : Set where
      constructor LeftShelfProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
    record LeftShelfHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftShelf A1)
      (Le2 : LeftShelf A2) : Set where
      constructor LeftShelfHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
    record LeftShelfRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftShelf A1)
      (Le2 : LeftShelf A2) : Set where
      constructor LeftShelfRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
    data LeftShelfTerm : Set where
      |>L :
        LeftShelfTerm ->
        LeftShelfTerm -> LeftShelfTerm
    data ClLeftShelfTerm
      (A : Set) : Set where
      sing : A -> ClLeftShelfTerm A
      |>Cl :
        ClLeftShelfTerm A ->
        ClLeftShelfTerm A ->
        ClLeftShelfTerm A
    data OpLeftShelfTerm
      (n : Nat) : Set where
      v : Fin n -> OpLeftShelfTerm n
      |>OL :
        OpLeftShelfTerm n ->
        OpLeftShelfTerm n ->
        OpLeftShelfTerm n
    data OpLeftShelfTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpLeftShelfTerm2 n A
      sing2 :
        A -> OpLeftShelfTerm2 n A
      |>OL2 :
        OpLeftShelfTerm2 n A ->
        OpLeftShelfTerm2 n A ->
        OpLeftShelfTerm2 n A
    simplifyB :
      LeftShelfTerm -> LeftShelfTerm
    simplifyB (|>L
               (|>L x y)
               (|>L x z)) = |>L x (|>L y z)
    simplifyB (|>L x1 x2) =
      |>L (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLeftShelfTerm A ->
      ClLeftShelfTerm A
    simplifyCl _ (|>Cl
                  (|>Cl x y)
                  (|>Cl x z)) = |>Cl x (|>Cl y z)
    simplifyCl _ (|>Cl x1 x2) =
      |>Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeftShelfTerm n ->
      OpLeftShelfTerm n
    simplifyOp _ (|>OL
                  (|>OL x y)
                  (|>OL x z)) = |>OL x (|>OL y z)
    simplifyOp _ (|>OL x1 x2) =
      |>OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeftShelfTerm2 n A ->
      OpLeftShelfTerm2 n A
    simplifyOpE _ _ (|>OL2
                     (|>OL2 x y)
                     (|>OL2 x z)) =
      |>OL2 x (|>OL2 y z)
    simplifyOpE _ _ (|>OL2 x1 x2) =
      |>OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LeftShelf A ->
      LeftShelfTerm -> A
    evalB _ Le (|>L x1 x2) =
      |> Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalCl :
      (A : Set) ->
      LeftShelf A ->
      ClLeftShelfTerm A -> A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (|>Cl x1 x2) =
      |> Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalOp :
      (A : Set) (n : Nat) ->
      LeftShelf A ->
      Vec A n ->
      OpLeftShelfTerm n -> A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (|>OL
                        x1
                        x2) =
      |> Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      LeftShelf A ->
      Vec A n ->
      OpLeftShelfTerm2 n A -> A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (|>OL2
                         x1
                         x2) =
      |> Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    inductionB :
      (P : LeftShelfTerm -> Set) ->
      ((x1 : LeftShelfTerm)
       (x2 : LeftShelfTerm) ->
       P x1 ->
       P x2 -> P (|>L x1 x2)) ->
      (x : LeftShelfTerm) -> P x
    inductionB p p|>l (|>L x1 x2) =
      p|>l _ _ (inductionB p p|>l x1)
        (inductionB p p|>l x2)
    inductionCl :
      (A : Set)
      (P : ClLeftShelfTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClLeftShelfTerm A)
       (x2 : ClLeftShelfTerm A) ->
       P x1 ->
       P x2 -> P (|>Cl x1 x2)) ->
      (x : ClLeftShelfTerm A) -> P x
    inductionCl _ p psing p|>cl (sing
                                 x1) = psing x1
    inductionCl _ p psing p|>cl (|>Cl
                                 x1
                                 x2) =
      p|>cl _ _
        (inductionCl _ p psing p|>cl x1)
        (inductionCl _ p psing p|>cl x2)
    inductionOp :
      (n : Nat)
      (P : OpLeftShelfTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpLeftShelfTerm n)
       (x2 : OpLeftShelfTerm n) ->
       P x1 ->
       P x2 -> P (|>OL x1 x2)) ->
      (x : OpLeftShelfTerm n) -> P x
    inductionOp _ p pv p|>ol (v
                              x1) = pv x1
    inductionOp _ p pv p|>ol (|>OL
                              x1
                              x2) =
      p|>ol _ _
        (inductionOp _ p pv p|>ol x1)
        (inductionOp _ p pv p|>ol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeftShelfTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpLeftShelfTerm2 n A)
       (x2 : OpLeftShelfTerm2 n A) ->
       P x1 ->
       P x2 -> P (|>OL2 x1 x2)) ->
      (x : OpLeftShelfTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p|>ol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 (|>OL2
                                          x1
                                          x2) =
      p|>ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           x2)
    |>L' :
      LeftShelfTerm ->
      LeftShelfTerm -> LeftShelfTerm
    |>L' x1 x2 = |>L x1 x2
    stageB :
      LeftShelfTerm ->
      Staged LeftShelfTerm
    stageB (|>L x1 x2) =
      stage2 _ _ _ |>L'
        (codeLift2 _ _ _ |>L')
        (stageB x1)
        (stageB x2)
    |>Cl' :
      (A : Set) ->
      ClLeftShelfTerm A ->
      ClLeftShelfTerm A ->
      ClLeftShelfTerm A
    |>Cl' _ x1 x2 = |>Cl x1 x2
    stageCl :
      (A : Set) ->
      ClLeftShelfTerm A ->
      Staged (ClLeftShelfTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (|>Cl x1 x2) =
      stage2 _ _ _ (|>Cl' _)
        (codeLift2 _ _ _ (|>Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    |>OL' :
      (n : Nat) ->
      OpLeftShelfTerm n ->
      OpLeftShelfTerm n ->
      OpLeftShelfTerm n
    |>OL' _ x1 x2 = |>OL x1 x2
    stageOp :
      (n : Nat) ->
      OpLeftShelfTerm n ->
      Staged (OpLeftShelfTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (|>OL x1 x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    |>OL2' :
      (n : Nat) (A : Set) ->
      OpLeftShelfTerm2 n A ->
      OpLeftShelfTerm2 n A ->
      OpLeftShelfTerm2 n A
    |>OL2' _ _ x1 x2 = |>OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeftShelfTerm2 n A ->
      Staged (OpLeftShelfTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (|>OL2 x1 x2) =
      stage2 _ _ _ (|>OL2' _ _)
        (codeLift2 _ _ _ (|>OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LeftShelfTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        |>T : Repr A -> Repr A -> Repr A
  
  module LeftShelfSig where
    record LeftShelfSig
      (A : Set) : Set where
      constructor LeftShelfSigC
      field
        |> : A -> A -> A
    record LeftShelfSigSig
      (AS : Set) : Set where
      constructor LeftShelfSigSigSigC
      field
        |>S : AS -> AS -> AS
    record LeftShelfSigProd
      (AP : Set) : Set where
      constructor LeftShelfSigProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record LeftShelfSigHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftShelfSig A1)
      (Le2 : LeftShelfSig A2) :
      Set where
      constructor LeftShelfSigHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
    record LeftShelfSigRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftShelfSig A1)
      (Le2 : LeftShelfSig A2) :
      Set where
      constructor LeftShelfSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
    data LeftShelfSigTerm
      : Set where
      |>L :
        LeftShelfSigTerm ->
        LeftShelfSigTerm ->
        LeftShelfSigTerm
    data ClLeftShelfSigTerm
      (A : Set) : Set where
      sing :
        A -> ClLeftShelfSigTerm A
      |>Cl :
        ClLeftShelfSigTerm A ->
        ClLeftShelfSigTerm A ->
        ClLeftShelfSigTerm A
    data OpLeftShelfSigTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpLeftShelfSigTerm n
      |>OL :
        OpLeftShelfSigTerm n ->
        OpLeftShelfSigTerm n ->
        OpLeftShelfSigTerm n
    data OpLeftShelfSigTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpLeftShelfSigTerm2 n A
      sing2 :
        A -> OpLeftShelfSigTerm2 n A
      |>OL2 :
        OpLeftShelfSigTerm2 n A ->
        OpLeftShelfSigTerm2 n A ->
        OpLeftShelfSigTerm2 n A
    simplifyB :
      LeftShelfSigTerm ->
      LeftShelfSigTerm
    simplifyB (|>L x1 x2) =
      |>L (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLeftShelfSigTerm A ->
      ClLeftShelfSigTerm A
    simplifyCl _ (|>Cl x1 x2) =
      |>Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeftShelfSigTerm n ->
      OpLeftShelfSigTerm n
    simplifyOp _ (|>OL x1 x2) =
      |>OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeftShelfSigTerm2 n A ->
      OpLeftShelfSigTerm2 n A
    simplifyOpE _ _ (|>OL2 x1 x2) =
      |>OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LeftShelfSig A ->
      LeftShelfSigTerm -> A
    evalB _ Le (|>L x1 x2) =
      |> Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalCl :
      (A : Set) ->
      LeftShelfSig A ->
      ClLeftShelfSigTerm A -> A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (|>Cl x1 x2) =
      |> Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalOp :
      (A : Set) (n : Nat) ->
      LeftShelfSig A ->
      Vec A n ->
      OpLeftShelfSigTerm n -> A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (|>OL
                        x1
                        x2) =
      |> Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      LeftShelfSig A ->
      Vec A n ->
      OpLeftShelfSigTerm2 n A -> A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (|>OL2
                         x1
                         x2) =
      |> Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    inductionB :
      (P : LeftShelfSigTerm -> Set) ->
      ((x1 : LeftShelfSigTerm)
       (x2 : LeftShelfSigTerm) ->
       P x1 ->
       P x2 -> P (|>L x1 x2)) ->
      (x : LeftShelfSigTerm) -> P x
    inductionB p p|>l (|>L x1 x2) =
      p|>l _ _ (inductionB p p|>l x1)
        (inductionB p p|>l x2)
    inductionCl :
      (A : Set)
      (P : ClLeftShelfSigTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClLeftShelfSigTerm A)
       (x2 : ClLeftShelfSigTerm A) ->
       P x1 ->
       P x2 -> P (|>Cl x1 x2)) ->
      (x : ClLeftShelfSigTerm A) ->
      P x
    inductionCl _ p psing p|>cl (sing
                                 x1) = psing x1
    inductionCl _ p psing p|>cl (|>Cl
                                 x1
                                 x2) =
      p|>cl _ _
        (inductionCl _ p psing p|>cl x1)
        (inductionCl _ p psing p|>cl x2)
    inductionOp :
      (n : Nat)
      (P : OpLeftShelfSigTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpLeftShelfSigTerm n)
       (x2 : OpLeftShelfSigTerm n) ->
       P x1 ->
       P x2 -> P (|>OL x1 x2)) ->
      (x : OpLeftShelfSigTerm n) ->
      P x
    inductionOp _ p pv p|>ol (v
                              x1) = pv x1
    inductionOp _ p pv p|>ol (|>OL
                              x1
                              x2) =
      p|>ol _ _
        (inductionOp _ p pv p|>ol x1)
        (inductionOp _ p pv p|>ol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeftShelfSigTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpLeftShelfSigTerm2 n A)
       (x2 : OpLeftShelfSigTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (|>OL2 x1 x2)) ->
      (x : OpLeftShelfSigTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p|>ol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 (|>OL2
                                          x1
                                          x2) =
      p|>ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           x2)
    |>L' :
      LeftShelfSigTerm ->
      LeftShelfSigTerm ->
      LeftShelfSigTerm
    |>L' x1 x2 = |>L x1 x2
    stageB :
      LeftShelfSigTerm ->
      Staged LeftShelfSigTerm
    stageB (|>L x1 x2) =
      stage2 _ _ _ |>L'
        (codeLift2 _ _ _ |>L')
        (stageB x1)
        (stageB x2)
    |>Cl' :
      (A : Set) ->
      ClLeftShelfSigTerm A ->
      ClLeftShelfSigTerm A ->
      ClLeftShelfSigTerm A
    |>Cl' _ x1 x2 = |>Cl x1 x2
    stageCl :
      (A : Set) ->
      ClLeftShelfSigTerm A ->
      Staged (ClLeftShelfSigTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (|>Cl x1 x2) =
      stage2 _ _ _ (|>Cl' _)
        (codeLift2 _ _ _ (|>Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    |>OL' :
      (n : Nat) ->
      OpLeftShelfSigTerm n ->
      OpLeftShelfSigTerm n ->
      OpLeftShelfSigTerm n
    |>OL' _ x1 x2 = |>OL x1 x2
    stageOp :
      (n : Nat) ->
      OpLeftShelfSigTerm n ->
      Staged (OpLeftShelfSigTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (|>OL x1 x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    |>OL2' :
      (n : Nat) (A : Set) ->
      OpLeftShelfSigTerm2 n A ->
      OpLeftShelfSigTerm2 n A ->
      OpLeftShelfSigTerm2 n A
    |>OL2' _ _ x1 x2 = |>OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeftShelfSigTerm2 n A ->
      Staged (OpLeftShelfSigTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (|>OL2 x1 x2) =
      stage2 _ _ _ (|>OL2' _ _)
        (codeLift2 _ _ _ (|>OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LeftShelfSigTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        |>T : Repr A -> Repr A -> Repr A
  
  module LeftSpindle where
    record LeftSpindle
      (A : Set) : Set where
      constructor LeftSpindleC
      field
        |> : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        idempotent_|> :
          (x : A) -> |> x x == x
    record LeftSpindleSig
      (AS : Set) : Set where
      constructor LeftSpindleSigSigC
      field
        |>S : AS -> AS -> AS
    record LeftSpindleProd
      (AP : Set) : Set where
      constructor LeftSpindleProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
    record LeftSpindleHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftSpindle A1)
      (Le2 : LeftSpindle A2) :
      Set where
      constructor LeftSpindleHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
    record LeftSpindleRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftSpindle A1)
      (Le2 : LeftSpindle A2) :
      Set where
      constructor LeftSpindleRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
    data LeftSpindleTerm : Set where
      |>L :
        LeftSpindleTerm ->
        LeftSpindleTerm ->
        LeftSpindleTerm
    data ClLeftSpindleTerm
      (A : Set) : Set where
      sing :
        A -> ClLeftSpindleTerm A
      |>Cl :
        ClLeftSpindleTerm A ->
        ClLeftSpindleTerm A ->
        ClLeftSpindleTerm A
    data OpLeftSpindleTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpLeftSpindleTerm n
      |>OL :
        OpLeftSpindleTerm n ->
        OpLeftSpindleTerm n ->
        OpLeftSpindleTerm n
    data OpLeftSpindleTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpLeftSpindleTerm2 n A
      sing2 :
        A -> OpLeftSpindleTerm2 n A
      |>OL2 :
        OpLeftSpindleTerm2 n A ->
        OpLeftSpindleTerm2 n A ->
        OpLeftSpindleTerm2 n A
    simplifyB :
      LeftSpindleTerm ->
      LeftSpindleTerm
    simplifyB (|>L
               (|>L x y)
               (|>L x z)) = |>L x (|>L y z)
    simplifyB (|>L x x) = x
    simplifyB (|>L x1 x2) =
      |>L (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLeftSpindleTerm A ->
      ClLeftSpindleTerm A
    simplifyCl _ (|>Cl
                  (|>Cl x y)
                  (|>Cl x z)) = |>Cl x (|>Cl y z)
    simplifyCl _ (|>Cl x x) = x
    simplifyCl _ (|>Cl x1 x2) =
      |>Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeftSpindleTerm n ->
      OpLeftSpindleTerm n
    simplifyOp _ (|>OL
                  (|>OL x y)
                  (|>OL x z)) = |>OL x (|>OL y z)
    simplifyOp _ (|>OL x x) = x
    simplifyOp _ (|>OL x1 x2) =
      |>OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeftSpindleTerm2 n A ->
      OpLeftSpindleTerm2 n A
    simplifyOpE _ _ (|>OL2
                     (|>OL2 x y)
                     (|>OL2 x z)) =
      |>OL2 x (|>OL2 y z)
    simplifyOpE _ _ (|>OL2 x x) = x
    simplifyOpE _ _ (|>OL2 x1 x2) =
      |>OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LeftSpindle A ->
      LeftSpindleTerm -> A
    evalB _ Le (|>L x1 x2) =
      |> Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalCl :
      (A : Set) ->
      LeftSpindle A ->
      ClLeftSpindleTerm A -> A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (|>Cl x1 x2) =
      |> Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalOp :
      (A : Set) (n : Nat) ->
      LeftSpindle A ->
      Vec A n ->
      OpLeftSpindleTerm n -> A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (|>OL
                        x1
                        x2) =
      |> Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      LeftSpindle A ->
      Vec A n ->
      OpLeftSpindleTerm2 n A -> A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (|>OL2
                         x1
                         x2) =
      |> Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    inductionB :
      (P : LeftSpindleTerm -> Set) ->
      ((x1 : LeftSpindleTerm)
       (x2 : LeftSpindleTerm) ->
       P x1 ->
       P x2 -> P (|>L x1 x2)) ->
      (x : LeftSpindleTerm) -> P x
    inductionB p p|>l (|>L x1 x2) =
      p|>l _ _ (inductionB p p|>l x1)
        (inductionB p p|>l x2)
    inductionCl :
      (A : Set)
      (P : ClLeftSpindleTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClLeftSpindleTerm A)
       (x2 : ClLeftSpindleTerm A) ->
       P x1 ->
       P x2 -> P (|>Cl x1 x2)) ->
      (x : ClLeftSpindleTerm A) -> P x
    inductionCl _ p psing p|>cl (sing
                                 x1) = psing x1
    inductionCl _ p psing p|>cl (|>Cl
                                 x1
                                 x2) =
      p|>cl _ _
        (inductionCl _ p psing p|>cl x1)
        (inductionCl _ p psing p|>cl x2)
    inductionOp :
      (n : Nat)
      (P : OpLeftSpindleTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpLeftSpindleTerm n)
       (x2 : OpLeftSpindleTerm n) ->
       P x1 ->
       P x2 -> P (|>OL x1 x2)) ->
      (x : OpLeftSpindleTerm n) -> P x
    inductionOp _ p pv p|>ol (v
                              x1) = pv x1
    inductionOp _ p pv p|>ol (|>OL
                              x1
                              x2) =
      p|>ol _ _
        (inductionOp _ p pv p|>ol x1)
        (inductionOp _ p pv p|>ol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeftSpindleTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpLeftSpindleTerm2 n A)
       (x2 : OpLeftSpindleTerm2 n A) ->
       P x1 ->
       P x2 -> P (|>OL2 x1 x2)) ->
      (x : OpLeftSpindleTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p|>ol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 (|>OL2
                                          x1
                                          x2) =
      p|>ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           x2)
    |>L' :
      LeftSpindleTerm ->
      LeftSpindleTerm ->
      LeftSpindleTerm
    |>L' x1 x2 = |>L x1 x2
    stageB :
      LeftSpindleTerm ->
      Staged LeftSpindleTerm
    stageB (|>L x1 x2) =
      stage2 _ _ _ |>L'
        (codeLift2 _ _ _ |>L')
        (stageB x1)
        (stageB x2)
    |>Cl' :
      (A : Set) ->
      ClLeftSpindleTerm A ->
      ClLeftSpindleTerm A ->
      ClLeftSpindleTerm A
    |>Cl' _ x1 x2 = |>Cl x1 x2
    stageCl :
      (A : Set) ->
      ClLeftSpindleTerm A ->
      Staged (ClLeftSpindleTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (|>Cl x1 x2) =
      stage2 _ _ _ (|>Cl' _)
        (codeLift2 _ _ _ (|>Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    |>OL' :
      (n : Nat) ->
      OpLeftSpindleTerm n ->
      OpLeftSpindleTerm n ->
      OpLeftSpindleTerm n
    |>OL' _ x1 x2 = |>OL x1 x2
    stageOp :
      (n : Nat) ->
      OpLeftSpindleTerm n ->
      Staged (OpLeftSpindleTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (|>OL x1 x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    |>OL2' :
      (n : Nat) (A : Set) ->
      OpLeftSpindleTerm2 n A ->
      OpLeftSpindleTerm2 n A ->
      OpLeftSpindleTerm2 n A
    |>OL2' _ _ x1 x2 = |>OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeftSpindleTerm2 n A ->
      Staged (OpLeftSpindleTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (|>OL2 x1 x2) =
      stage2 _ _ _ (|>OL2' _ _)
        (codeLift2 _ _ _ (|>OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LeftSpindleTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        |>T : Repr A -> Repr A -> Repr A
  
  module LeftSpindle_Shelf where
    record LeftSpindle_Shelf
      (A : Set) : Set where
      constructor LeftSpindle_ShelfC
      field
        |> : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        idempotent_|> :
          (x : A) -> |> x x == x
        <| : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
    record LeftSpindle_ShelfSig
      (AS : Set) : Set where
      constructor LeftSpindle_ShelfSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record LeftSpindle_ShelfProd
      (AP : Set) : Set where
      constructor LeftSpindle_ShelfProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
    record LeftSpindle_ShelfHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftSpindle_Shelf A1)
      (Le2 : LeftSpindle_Shelf A2) :
      Set where
      constructor LeftSpindle_ShelfHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Le1 x1 x2) ==
            <| Le2 (hom x1) (hom x2)
    record LeftSpindle_ShelfRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftSpindle_Shelf A1)
      (Le2 : LeftSpindle_Shelf A2) :
      Set where
      constructor LeftSpindle_ShelfRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Le1 x1 x2)
            (<| Le2 y1 y2)
    data LeftSpindle_ShelfTerm
      : Set where
      |>L :
        LeftSpindle_ShelfTerm ->
        LeftSpindle_ShelfTerm ->
        LeftSpindle_ShelfTerm
      <|L :
        LeftSpindle_ShelfTerm ->
        LeftSpindle_ShelfTerm ->
        LeftSpindle_ShelfTerm
    data ClLeftSpindle_ShelfTerm
      (A : Set) : Set where
      sing :
        A -> ClLeftSpindle_ShelfTerm A
      |>Cl :
        ClLeftSpindle_ShelfTerm A ->
        ClLeftSpindle_ShelfTerm A ->
        ClLeftSpindle_ShelfTerm A
      <|Cl :
        ClLeftSpindle_ShelfTerm A ->
        ClLeftSpindle_ShelfTerm A ->
        ClLeftSpindle_ShelfTerm A
    data OpLeftSpindle_ShelfTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpLeftSpindle_ShelfTerm n
      |>OL :
        OpLeftSpindle_ShelfTerm n ->
        OpLeftSpindle_ShelfTerm n ->
        OpLeftSpindle_ShelfTerm n
      <|OL :
        OpLeftSpindle_ShelfTerm n ->
        OpLeftSpindle_ShelfTerm n ->
        OpLeftSpindle_ShelfTerm n
    data OpLeftSpindle_ShelfTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpLeftSpindle_ShelfTerm2 n A
      sing2 :
        A ->
        OpLeftSpindle_ShelfTerm2 n A
      |>OL2 :
        OpLeftSpindle_ShelfTerm2 n A ->
        OpLeftSpindle_ShelfTerm2 n A ->
        OpLeftSpindle_ShelfTerm2 n A
      <|OL2 :
        OpLeftSpindle_ShelfTerm2 n A ->
        OpLeftSpindle_ShelfTerm2 n A ->
        OpLeftSpindle_ShelfTerm2 n A
    simplifyB :
      LeftSpindle_ShelfTerm ->
      LeftSpindle_ShelfTerm
    simplifyB (|>L
               (|>L x y)
               (|>L x z)) = |>L x (|>L y z)
    simplifyB (|>L x x) = x
    simplifyB (<|L
               (<|L y x)
               (<|L z x)) = <|L (<|L y z) x
    simplifyB (|>L x1 x2) =
      |>L (simplifyB x1)
        (simplifyB x2)
    simplifyB (<|L x1 x2) =
      <|L (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLeftSpindle_ShelfTerm A ->
      ClLeftSpindle_ShelfTerm A
    simplifyCl _ (|>Cl
                  (|>Cl x y)
                  (|>Cl x z)) = |>Cl x (|>Cl y z)
    simplifyCl _ (|>Cl x x) = x
    simplifyCl _ (<|Cl
                  (<|Cl y x)
                  (<|Cl z x)) = <|Cl (<|Cl y z) x
    simplifyCl _ (|>Cl x1 x2) =
      |>Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (<|Cl x1 x2) =
      <|Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeftSpindle_ShelfTerm n ->
      OpLeftSpindle_ShelfTerm n
    simplifyOp _ (|>OL
                  (|>OL x y)
                  (|>OL x z)) = |>OL x (|>OL y z)
    simplifyOp _ (|>OL x x) = x
    simplifyOp _ (<|OL
                  (<|OL y x)
                  (<|OL z x)) = <|OL (<|OL y z) x
    simplifyOp _ (|>OL x1 x2) =
      |>OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (<|OL x1 x2) =
      <|OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeftSpindle_ShelfTerm2 n A ->
      OpLeftSpindle_ShelfTerm2 n A
    simplifyOpE _ _ (|>OL2
                     (|>OL2 x y)
                     (|>OL2 x z)) =
      |>OL2 x (|>OL2 y z)
    simplifyOpE _ _ (|>OL2 x x) = x
    simplifyOpE _ _ (<|OL2
                     (<|OL2 y x)
                     (<|OL2 z x)) =
      <|OL2 (<|OL2 y z) x
    simplifyOpE _ _ (|>OL2 x1 x2) =
      |>OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (<|OL2 x1 x2) =
      <|OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LeftSpindle_Shelf A ->
      LeftSpindle_ShelfTerm -> A
    evalB _ Le (|>L x1 x2) =
      |> Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalB _ Le (<|L x1 x2) =
      <| Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalCl :
      (A : Set) ->
      LeftSpindle_Shelf A ->
      ClLeftSpindle_ShelfTerm A -> A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (|>Cl x1 x2) =
      |> Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalCl _ Le (<|Cl x1 x2) =
      <| Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalOp :
      (A : Set) (n : Nat) ->
      LeftSpindle_Shelf A ->
      Vec A n ->
      OpLeftSpindle_ShelfTerm n -> A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (|>OL
                        x1
                        x2) =
      |> Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOp _ n Le vars (<|OL
                        x1
                        x2) =
      <| Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      LeftSpindle_Shelf A ->
      Vec A n ->
      OpLeftSpindle_ShelfTerm2 n A ->
      A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (|>OL2
                         x1
                         x2) =
      |> Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    evalOpE _ n Le vars (<|OL2
                         x1
                         x2) =
      <| Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    inductionB :
      (P : LeftSpindle_ShelfTerm ->
           Set) ->
      ((x1 : LeftSpindle_ShelfTerm)
       (x2 : LeftSpindle_ShelfTerm) ->
       P x1 ->
       P x2 -> P (|>L x1 x2)) ->
      ((x1 : LeftSpindle_ShelfTerm)
       (x2 : LeftSpindle_ShelfTerm) ->
       P x1 ->
       P x2 -> P (<|L x1 x2)) ->
      (x : LeftSpindle_ShelfTerm) ->
      P x
    inductionB p p|>l p<|l (|>L
                            x1
                            x2) =
      p|>l _ _
        (inductionB p p|>l p<|l x1)
        (inductionB p p|>l p<|l x2)
    inductionB p p|>l p<|l (<|L
                            x1
                            x2) =
      p<|l _ _
        (inductionB p p|>l p<|l x1)
        (inductionB p p|>l p<|l x2)
    inductionCl :
      (A : Set)
      (P : ClLeftSpindle_ShelfTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClLeftSpindle_ShelfTerm
          A)
       (x2 : ClLeftSpindle_ShelfTerm
          A) ->
       P x1 ->
       P x2 -> P (|>Cl x1 x2)) ->
      ((x1 : ClLeftSpindle_ShelfTerm
          A)
       (x2 : ClLeftSpindle_ShelfTerm
          A) ->
       P x1 ->
       P x2 -> P (<|Cl x1 x2)) ->
      (x : ClLeftSpindle_ShelfTerm
         A) -> P x
    inductionCl _ p psing p|>cl p<|cl (sing
                                       x1) = psing x1
    inductionCl _ p psing p|>cl p<|cl (|>Cl
                                       x1
                                       x2) =
      p|>cl _ _
        (inductionCl _ p psing p|>cl
           p<|cl
           x1)
        (inductionCl _ p psing p|>cl
           p<|cl
           x2)
    inductionCl _ p psing p|>cl p<|cl (<|Cl
                                       x1
                                       x2) =
      p<|cl _ _
        (inductionCl _ p psing p|>cl
           p<|cl
           x1)
        (inductionCl _ p psing p|>cl
           p<|cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpLeftSpindle_ShelfTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpLeftSpindle_ShelfTerm
          n)
       (x2 : OpLeftSpindle_ShelfTerm
          n) ->
       P x1 ->
       P x2 -> P (|>OL x1 x2)) ->
      ((x1 : OpLeftSpindle_ShelfTerm
          n)
       (x2 : OpLeftSpindle_ShelfTerm
          n) ->
       P x1 ->
       P x2 -> P (<|OL x1 x2)) ->
      (x : OpLeftSpindle_ShelfTerm
         n) -> P x
    inductionOp _ p pv p|>ol p<|ol (v
                                    x1) = pv x1
    inductionOp _ p pv p|>ol p<|ol (|>OL
                                    x1
                                    x2) =
      p|>ol _ _
        (inductionOp _ p pv p|>ol p<|ol
           x1)
        (inductionOp _ p pv p|>ol p<|ol
           x2)
    inductionOp _ p pv p|>ol p<|ol (<|OL
                                    x1
                                    x2) =
      p<|ol _ _
        (inductionOp _ p pv p|>ol p<|ol
           x1)
        (inductionOp _ p pv p|>ol p<|ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeftSpindle_ShelfTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpLeftSpindle_ShelfTerm2
          n
          A)
       (x2 : OpLeftSpindle_ShelfTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (|>OL2 x1 x2)) ->
      ((x1 : OpLeftSpindle_ShelfTerm2
          n
          A)
       (x2 : OpLeftSpindle_ShelfTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (<|OL2 x1 x2)) ->
      (x : OpLeftSpindle_ShelfTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (v2
                                                 x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (sing2
                                                 x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (|>OL2
                                                 x1
                                                 x2) =
      p|>ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (<|OL2
                                                 x1
                                                 x2) =
      p<|ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x2)
    |>L' :
      LeftSpindle_ShelfTerm ->
      LeftSpindle_ShelfTerm ->
      LeftSpindle_ShelfTerm
    |>L' x1 x2 = |>L x1 x2
    <|L' :
      LeftSpindle_ShelfTerm ->
      LeftSpindle_ShelfTerm ->
      LeftSpindle_ShelfTerm
    <|L' x1 x2 = <|L x1 x2
    stageB :
      LeftSpindle_ShelfTerm ->
      Staged LeftSpindle_ShelfTerm
    stageB (|>L x1 x2) =
      stage2 _ _ _ |>L'
        (codeLift2 _ _ _ |>L')
        (stageB x1)
        (stageB x2)
    stageB (<|L x1 x2) =
      stage2 _ _ _ <|L'
        (codeLift2 _ _ _ <|L')
        (stageB x1)
        (stageB x2)
    |>Cl' :
      (A : Set) ->
      ClLeftSpindle_ShelfTerm A ->
      ClLeftSpindle_ShelfTerm A ->
      ClLeftSpindle_ShelfTerm A
    |>Cl' _ x1 x2 = |>Cl x1 x2
    <|Cl' :
      (A : Set) ->
      ClLeftSpindle_ShelfTerm A ->
      ClLeftSpindle_ShelfTerm A ->
      ClLeftSpindle_ShelfTerm A
    <|Cl' _ x1 x2 = <|Cl x1 x2
    stageCl :
      (A : Set) ->
      ClLeftSpindle_ShelfTerm A ->
      Staged
        (ClLeftSpindle_ShelfTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (|>Cl x1 x2) =
      stage2 _ _ _ (|>Cl' _)
        (codeLift2 _ _ _ (|>Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (<|Cl x1 x2) =
      stage2 _ _ _ (<|Cl' _)
        (codeLift2 _ _ _ (<|Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    |>OL' :
      (n : Nat) ->
      OpLeftSpindle_ShelfTerm n ->
      OpLeftSpindle_ShelfTerm n ->
      OpLeftSpindle_ShelfTerm n
    |>OL' _ x1 x2 = |>OL x1 x2
    <|OL' :
      (n : Nat) ->
      OpLeftSpindle_ShelfTerm n ->
      OpLeftSpindle_ShelfTerm n ->
      OpLeftSpindle_ShelfTerm n
    <|OL' _ x1 x2 = <|OL x1 x2
    stageOp :
      (n : Nat) ->
      OpLeftSpindle_ShelfTerm n ->
      Staged
        (OpLeftSpindle_ShelfTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (|>OL x1 x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (<|OL x1 x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    |>OL2' :
      (n : Nat) (A : Set) ->
      OpLeftSpindle_ShelfTerm2 n A ->
      OpLeftSpindle_ShelfTerm2 n A ->
      OpLeftSpindle_ShelfTerm2 n A
    |>OL2' _ _ x1 x2 = |>OL2 x1 x2
    <|OL2' :
      (n : Nat) (A : Set) ->
      OpLeftSpindle_ShelfTerm2 n A ->
      OpLeftSpindle_ShelfTerm2 n A ->
      OpLeftSpindle_ShelfTerm2 n A
    <|OL2' _ _ x1 x2 = <|OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeftSpindle_ShelfTerm2 n A ->
      Staged
        (OpLeftSpindle_ShelfTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (|>OL2 x1 x2) =
      stage2 _ _ _ (|>OL2' _ _)
        (codeLift2 _ _ _ (|>OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (<|OL2 x1 x2) =
      stage2 _ _ _ (<|OL2' _ _)
        (codeLift2 _ _ _ (<|OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LeftSpindle_ShelfTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        |>T : Repr A -> Repr A -> Repr A
        <|T : Repr A -> Repr A -> Repr A
  
  module LeftSpindle_ShelfSig where
    record LeftSpindle_ShelfSig
      (A : Set) : Set where
      constructor LeftSpindle_ShelfSigC
      field
        |> : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        idempotent_|> :
          (x : A) -> |> x x == x
        <| : A -> A -> A
    record LeftSpindle_ShelfSigSig
      (AS : Set) : Set where
      constructor LeftSpindle_ShelfSigSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record LeftSpindle_ShelfSigProd
      (AP : Set) : Set where
      constructor LeftSpindle_ShelfSigProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
    record LeftSpindle_ShelfSigHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftSpindle_ShelfSig A1)
      (Le2 : LeftSpindle_ShelfSig
         A2) : Set where
      constructor LeftSpindle_ShelfSigHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Le1 x1 x2) ==
            |> Le2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Le1 x1 x2) ==
            <| Le2 (hom x1) (hom x2)
    record LeftSpindle_ShelfSigRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftSpindle_ShelfSig A1)
      (Le2 : LeftSpindle_ShelfSig
         A2) : Set where
      constructor LeftSpindle_ShelfSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Le1 x1 x2)
            (|> Le2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Le1 x1 x2)
            (<| Le2 y1 y2)
    data LeftSpindle_ShelfSigTerm
      : Set where
      |>L :
        LeftSpindle_ShelfSigTerm ->
        LeftSpindle_ShelfSigTerm ->
        LeftSpindle_ShelfSigTerm
      <|L :
        LeftSpindle_ShelfSigTerm ->
        LeftSpindle_ShelfSigTerm ->
        LeftSpindle_ShelfSigTerm
    data ClLeftSpindle_ShelfSigTerm
      (A : Set) : Set where
      sing :
        A ->
        ClLeftSpindle_ShelfSigTerm A
      |>Cl :
        ClLeftSpindle_ShelfSigTerm A ->
        ClLeftSpindle_ShelfSigTerm A ->
        ClLeftSpindle_ShelfSigTerm A
      <|Cl :
        ClLeftSpindle_ShelfSigTerm A ->
        ClLeftSpindle_ShelfSigTerm A ->
        ClLeftSpindle_ShelfSigTerm A
    data OpLeftSpindle_ShelfSigTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpLeftSpindle_ShelfSigTerm n
      |>OL :
        OpLeftSpindle_ShelfSigTerm n ->
        OpLeftSpindle_ShelfSigTerm n ->
        OpLeftSpindle_ShelfSigTerm n
      <|OL :
        OpLeftSpindle_ShelfSigTerm n ->
        OpLeftSpindle_ShelfSigTerm n ->
        OpLeftSpindle_ShelfSigTerm n
    data OpLeftSpindle_ShelfSigTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpLeftSpindle_ShelfSigTerm2 n A
      sing2 :
        A ->
        OpLeftSpindle_ShelfSigTerm2 n A
      |>OL2 :
        OpLeftSpindle_ShelfSigTerm2 n
          A ->
        OpLeftSpindle_ShelfSigTerm2 n
          A ->
        OpLeftSpindle_ShelfSigTerm2 n A
      <|OL2 :
        OpLeftSpindle_ShelfSigTerm2 n
          A ->
        OpLeftSpindle_ShelfSigTerm2 n
          A ->
        OpLeftSpindle_ShelfSigTerm2 n A
    simplifyB :
      LeftSpindle_ShelfSigTerm ->
      LeftSpindle_ShelfSigTerm
    simplifyB (|>L
               (|>L x y)
               (|>L x z)) = |>L x (|>L y z)
    simplifyB (|>L x x) = x
    simplifyB (|>L x1 x2) =
      |>L (simplifyB x1)
        (simplifyB x2)
    simplifyB (<|L x1 x2) =
      <|L (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLeftSpindle_ShelfSigTerm A ->
      ClLeftSpindle_ShelfSigTerm A
    simplifyCl _ (|>Cl
                  (|>Cl x y)
                  (|>Cl x z)) = |>Cl x (|>Cl y z)
    simplifyCl _ (|>Cl x x) = x
    simplifyCl _ (|>Cl x1 x2) =
      |>Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (<|Cl x1 x2) =
      <|Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeftSpindle_ShelfSigTerm n ->
      OpLeftSpindle_ShelfSigTerm n
    simplifyOp _ (|>OL
                  (|>OL x y)
                  (|>OL x z)) = |>OL x (|>OL y z)
    simplifyOp _ (|>OL x x) = x
    simplifyOp _ (|>OL x1 x2) =
      |>OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (<|OL x1 x2) =
      <|OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeftSpindle_ShelfSigTerm2 n
        A ->
      OpLeftSpindle_ShelfSigTerm2 n A
    simplifyOpE _ _ (|>OL2
                     (|>OL2 x y)
                     (|>OL2 x z)) =
      |>OL2 x (|>OL2 y z)
    simplifyOpE _ _ (|>OL2 x x) = x
    simplifyOpE _ _ (|>OL2 x1 x2) =
      |>OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (<|OL2 x1 x2) =
      <|OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LeftSpindle_ShelfSig A ->
      LeftSpindle_ShelfSigTerm -> A
    evalB _ Le (|>L x1 x2) =
      |> Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalB _ Le (<|L x1 x2) =
      <| Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalCl :
      (A : Set) ->
      LeftSpindle_ShelfSig A ->
      ClLeftSpindle_ShelfSigTerm A ->
      A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (|>Cl x1 x2) =
      |> Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalCl _ Le (<|Cl x1 x2) =
      <| Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalOp :
      (A : Set) (n : Nat) ->
      LeftSpindle_ShelfSig A ->
      Vec A n ->
      OpLeftSpindle_ShelfSigTerm n ->
      A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (|>OL
                        x1
                        x2) =
      |> Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOp _ n Le vars (<|OL
                        x1
                        x2) =
      <| Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      LeftSpindle_ShelfSig A ->
      Vec A n ->
      OpLeftSpindle_ShelfSigTerm2 n
        A -> A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (|>OL2
                         x1
                         x2) =
      |> Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    evalOpE _ n Le vars (<|OL2
                         x1
                         x2) =
      <| Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    inductionB :
      (P : LeftSpindle_ShelfSigTerm ->
           Set) ->
      ((x1 : LeftSpindle_ShelfSigTerm)
       (x2 : LeftSpindle_ShelfSigTerm) ->
       P x1 ->
       P x2 -> P (|>L x1 x2)) ->
      ((x1 : LeftSpindle_ShelfSigTerm)
       (x2 : LeftSpindle_ShelfSigTerm) ->
       P x1 ->
       P x2 -> P (<|L x1 x2)) ->
      (x : LeftSpindle_ShelfSigTerm) ->
      P x
    inductionB p p|>l p<|l (|>L
                            x1
                            x2) =
      p|>l _ _
        (inductionB p p|>l p<|l x1)
        (inductionB p p|>l p<|l x2)
    inductionB p p|>l p<|l (<|L
                            x1
                            x2) =
      p<|l _ _
        (inductionB p p|>l p<|l x1)
        (inductionB p p|>l p<|l x2)
    inductionCl :
      (A : Set)
      (P : ClLeftSpindle_ShelfSigTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClLeftSpindle_ShelfSigTerm
          A)
       (x2 : ClLeftSpindle_ShelfSigTerm
          A) ->
       P x1 ->
       P x2 -> P (|>Cl x1 x2)) ->
      ((x1 : ClLeftSpindle_ShelfSigTerm
          A)
       (x2 : ClLeftSpindle_ShelfSigTerm
          A) ->
       P x1 ->
       P x2 -> P (<|Cl x1 x2)) ->
      (x : ClLeftSpindle_ShelfSigTerm
         A) -> P x
    inductionCl _ p psing p|>cl p<|cl (sing
                                       x1) = psing x1
    inductionCl _ p psing p|>cl p<|cl (|>Cl
                                       x1
                                       x2) =
      p|>cl _ _
        (inductionCl _ p psing p|>cl
           p<|cl
           x1)
        (inductionCl _ p psing p|>cl
           p<|cl
           x2)
    inductionCl _ p psing p|>cl p<|cl (<|Cl
                                       x1
                                       x2) =
      p<|cl _ _
        (inductionCl _ p psing p|>cl
           p<|cl
           x1)
        (inductionCl _ p psing p|>cl
           p<|cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpLeftSpindle_ShelfSigTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpLeftSpindle_ShelfSigTerm
          n)
       (x2 : OpLeftSpindle_ShelfSigTerm
          n) ->
       P x1 ->
       P x2 -> P (|>OL x1 x2)) ->
      ((x1 : OpLeftSpindle_ShelfSigTerm
          n)
       (x2 : OpLeftSpindle_ShelfSigTerm
          n) ->
       P x1 ->
       P x2 -> P (<|OL x1 x2)) ->
      (x : OpLeftSpindle_ShelfSigTerm
         n) -> P x
    inductionOp _ p pv p|>ol p<|ol (v
                                    x1) = pv x1
    inductionOp _ p pv p|>ol p<|ol (|>OL
                                    x1
                                    x2) =
      p|>ol _ _
        (inductionOp _ p pv p|>ol p<|ol
           x1)
        (inductionOp _ p pv p|>ol p<|ol
           x2)
    inductionOp _ p pv p|>ol p<|ol (<|OL
                                    x1
                                    x2) =
      p<|ol _ _
        (inductionOp _ p pv p|>ol p<|ol
           x1)
        (inductionOp _ p pv p|>ol p<|ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeftSpindle_ShelfSigTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpLeftSpindle_ShelfSigTerm2
          n
          A)
       (x2 : OpLeftSpindle_ShelfSigTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (|>OL2 x1 x2)) ->
      ((x1 : OpLeftSpindle_ShelfSigTerm2
          n
          A)
       (x2 : OpLeftSpindle_ShelfSigTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (<|OL2 x1 x2)) ->
      (x : OpLeftSpindle_ShelfSigTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (v2
                                                 x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (sing2
                                                 x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (|>OL2
                                                 x1
                                                 x2) =
      p|>ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (<|OL2
                                                 x1
                                                 x2) =
      p<|ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x2)
    |>L' :
      LeftSpindle_ShelfSigTerm ->
      LeftSpindle_ShelfSigTerm ->
      LeftSpindle_ShelfSigTerm
    |>L' x1 x2 = |>L x1 x2
    <|L' :
      LeftSpindle_ShelfSigTerm ->
      LeftSpindle_ShelfSigTerm ->
      LeftSpindle_ShelfSigTerm
    <|L' x1 x2 = <|L x1 x2
    stageB :
      LeftSpindle_ShelfSigTerm ->
      Staged LeftSpindle_ShelfSigTerm
    stageB (|>L x1 x2) =
      stage2 _ _ _ |>L'
        (codeLift2 _ _ _ |>L')
        (stageB x1)
        (stageB x2)
    stageB (<|L x1 x2) =
      stage2 _ _ _ <|L'
        (codeLift2 _ _ _ <|L')
        (stageB x1)
        (stageB x2)
    |>Cl' :
      (A : Set) ->
      ClLeftSpindle_ShelfSigTerm A ->
      ClLeftSpindle_ShelfSigTerm A ->
      ClLeftSpindle_ShelfSigTerm A
    |>Cl' _ x1 x2 = |>Cl x1 x2
    <|Cl' :
      (A : Set) ->
      ClLeftSpindle_ShelfSigTerm A ->
      ClLeftSpindle_ShelfSigTerm A ->
      ClLeftSpindle_ShelfSigTerm A
    <|Cl' _ x1 x2 = <|Cl x1 x2
    stageCl :
      (A : Set) ->
      ClLeftSpindle_ShelfSigTerm A ->
      Staged
        (ClLeftSpindle_ShelfSigTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (|>Cl x1 x2) =
      stage2 _ _ _ (|>Cl' _)
        (codeLift2 _ _ _ (|>Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (<|Cl x1 x2) =
      stage2 _ _ _ (<|Cl' _)
        (codeLift2 _ _ _ (<|Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    |>OL' :
      (n : Nat) ->
      OpLeftSpindle_ShelfSigTerm n ->
      OpLeftSpindle_ShelfSigTerm n ->
      OpLeftSpindle_ShelfSigTerm n
    |>OL' _ x1 x2 = |>OL x1 x2
    <|OL' :
      (n : Nat) ->
      OpLeftSpindle_ShelfSigTerm n ->
      OpLeftSpindle_ShelfSigTerm n ->
      OpLeftSpindle_ShelfSigTerm n
    <|OL' _ x1 x2 = <|OL x1 x2
    stageOp :
      (n : Nat) ->
      OpLeftSpindle_ShelfSigTerm n ->
      Staged
        (OpLeftSpindle_ShelfSigTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (|>OL x1 x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (<|OL x1 x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    |>OL2' :
      (n : Nat) (A : Set) ->
      OpLeftSpindle_ShelfSigTerm2 n
        A ->
      OpLeftSpindle_ShelfSigTerm2 n
        A ->
      OpLeftSpindle_ShelfSigTerm2 n A
    |>OL2' _ _ x1 x2 = |>OL2 x1 x2
    <|OL2' :
      (n : Nat) (A : Set) ->
      OpLeftSpindle_ShelfSigTerm2 n
        A ->
      OpLeftSpindle_ShelfSigTerm2 n
        A ->
      OpLeftSpindle_ShelfSigTerm2 n A
    <|OL2' _ _ x1 x2 = <|OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeftSpindle_ShelfSigTerm2 n
        A ->
      Staged
        (OpLeftSpindle_ShelfSigTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (|>OL2 x1 x2) =
      stage2 _ _ _ (|>OL2' _ _)
        (codeLift2 _ _ _ (|>OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (<|OL2 x1 x2) =
      stage2 _ _ _ (<|OL2' _ _)
        (codeLift2 _ _ _ (<|OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LeftSpindle_ShelfSigTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        |>T : Repr A -> Repr A -> Repr A
        <|T : Repr A -> Repr A -> Repr A
  
  module LeftUnital where
    record LeftUnital
      (A : Set) : Set where
      constructor LeftUnitalC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
    record LeftUnitalSig
      (AS : Set) : Set where
      constructor LeftUnitalSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record LeftUnitalProd
      (AP : Set) : Set where
      constructor LeftUnitalProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
    record LeftUnitalHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftUnital A1)
      (Le2 : LeftUnital A2) :
      Set where
      constructor LeftUnitalHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Le1) == e Le2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record LeftUnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftUnital A1)
      (Le2 : LeftUnital A2) :
      Set where
      constructor LeftUnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Le1) (e Le2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data LeftUnitalTerm : Set where
      eL : LeftUnitalTerm
      opL :
        LeftUnitalTerm ->
        LeftUnitalTerm -> LeftUnitalTerm
    data ClLeftUnitalTerm
      (A : Set) : Set where
      sing : A -> ClLeftUnitalTerm A
      eCl : ClLeftUnitalTerm A
      opCl :
        ClLeftUnitalTerm A ->
        ClLeftUnitalTerm A ->
        ClLeftUnitalTerm A
    data OpLeftUnitalTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpLeftUnitalTerm n
      eOL : OpLeftUnitalTerm n
      opOL :
        OpLeftUnitalTerm n ->
        OpLeftUnitalTerm n ->
        OpLeftUnitalTerm n
    data OpLeftUnitalTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpLeftUnitalTerm2 n A
      sing2 :
        A -> OpLeftUnitalTerm2 n A
      eOL2 : OpLeftUnitalTerm2 n A
      opOL2 :
        OpLeftUnitalTerm2 n A ->
        OpLeftUnitalTerm2 n A ->
        OpLeftUnitalTerm2 n A
    simplifyB :
      LeftUnitalTerm -> LeftUnitalTerm
    simplifyB (opL (eL) x) = x
    simplifyB (eL) = eL
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLeftUnitalTerm A ->
      ClLeftUnitalTerm A
    simplifyCl _ (opCl (eCl) x) = x
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeftUnitalTerm n ->
      OpLeftUnitalTerm n
    simplifyOp _ (opOL (eOL) x) = x
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeftUnitalTerm2 n A ->
      OpLeftUnitalTerm2 n A
    simplifyOpE _ _ (opOL2
                     (eOL2)
                     x) = x
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LeftUnital A ->
      LeftUnitalTerm -> A
    evalB _ Le (eL) = e Le
    evalB _ Le (opL x1 x2) =
      op Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalCl :
      (A : Set) ->
      LeftUnital A ->
      ClLeftUnitalTerm A -> A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (eCl) = e Le
    evalCl _ Le (opCl x1 x2) =
      op Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalOp :
      (A : Set) (n : Nat) ->
      LeftUnital A ->
      Vec A n ->
      OpLeftUnitalTerm n -> A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (eOL) = e Le
    evalOp _ n Le vars (opOL
                        x1
                        x2) =
      op Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      LeftUnital A ->
      Vec A n ->
      OpLeftUnitalTerm2 n A -> A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (eOL2) =
      e Le
    evalOpE _ n Le vars (opOL2
                         x1
                         x2) =
      op Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    inductionB :
      (P : LeftUnitalTerm -> Set) ->
      P eL ->
      ((x1 : LeftUnitalTerm)
       (x2 : LeftUnitalTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : LeftUnitalTerm) -> P x
    inductionB p pel popl (eL) = pel
    inductionB p pel popl (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p pel popl x1)
        (inductionB p pel popl x2)
    inductionCl :
      (A : Set)
      (P : ClLeftUnitalTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P eCl ->
      ((x1 : ClLeftUnitalTerm A)
       (x2 : ClLeftUnitalTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClLeftUnitalTerm A) -> P x
    inductionCl _ p psing pecl popcl (sing
                                      x1) = psing x1
    inductionCl _ p psing pecl popcl (eCl) =
      pecl
    inductionCl _ p psing pecl popcl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing pecl
           popcl
           x1)
        (inductionCl _ p psing pecl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpLeftUnitalTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P eOL ->
      ((x1 : OpLeftUnitalTerm n)
       (x2 : OpLeftUnitalTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpLeftUnitalTerm n) -> P x
    inductionOp _ p pv peol popol (v
                                   x1) = pv x1
    inductionOp _ p pv peol popol (eOL) =
      peol
    inductionOp _ p pv peol popol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv peol popol
           x1)
        (inductionOp _ p pv peol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeftUnitalTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P eOL2 ->
      ((x1 : OpLeftUnitalTerm2 n A)
       (x2 : OpLeftUnitalTerm2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpLeftUnitalTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x2)
    eL' : LeftUnitalTerm
    eL' = eL
    opL' :
      LeftUnitalTerm ->
      LeftUnitalTerm -> LeftUnitalTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      LeftUnitalTerm ->
      Staged LeftUnitalTerm
    stageB (eL) = Now eL
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    eCl' :
      (A : Set) -> ClLeftUnitalTerm A
    eCl' _ = eCl
    opCl' :
      (A : Set) ->
      ClLeftUnitalTerm A ->
      ClLeftUnitalTerm A ->
      ClLeftUnitalTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClLeftUnitalTerm A ->
      Staged (ClLeftUnitalTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (eCl) = Now eCl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    eOL' :
      (n : Nat) -> OpLeftUnitalTerm n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      OpLeftUnitalTerm n ->
      OpLeftUnitalTerm n ->
      OpLeftUnitalTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpLeftUnitalTerm n ->
      Staged (OpLeftUnitalTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (eOL) = Now eOL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    eOL2' :
      (n : Nat) (A : Set) ->
      OpLeftUnitalTerm2 n A
    eOL2' _ _ = eOL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpLeftUnitalTerm2 n A ->
      OpLeftUnitalTerm2 n A ->
      OpLeftUnitalTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeftUnitalTerm2 n A ->
      Staged (OpLeftUnitalTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LeftUnitalTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        eT : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module LeftZero where
    record LeftZero
      (A : Set) : Set where
      constructor LeftZeroC
      field
        e : A
        op : A -> A -> A
        leftZero_op_e :
          (x : A) -> op e x == e
    record LeftZeroSig
      (AS : Set) : Set where
      constructor LeftZeroSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record LeftZeroProd
      (AP : Set) : Set where
      constructor LeftZeroProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftZero_op_eP :
          (xP : Prod AP AP) ->
          opP eP xP == eP
    record LeftZeroHom
      (A1 : Set) (A2 : Set)
      (Le1 : LeftZero A1)
      (Le2 : LeftZero A2) : Set where
      constructor LeftZeroHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Le1) == e Le2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Le1 x1 x2) ==
            op Le2 (hom x1) (hom x2)
    record LeftZeroRelInterp
      (A1 : Set) (A2 : Set)
      (Le1 : LeftZero A1)
      (Le2 : LeftZero A2) : Set where
      constructor LeftZeroRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Le1) (e Le2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Le1 x1 x2)
            (op Le2 y1 y2)
    data LeftZeroTerm : Set where
      eL : LeftZeroTerm
      opL :
        LeftZeroTerm ->
        LeftZeroTerm -> LeftZeroTerm
    data ClLeftZeroTerm
      (A : Set) : Set where
      sing : A -> ClLeftZeroTerm A
      eCl : ClLeftZeroTerm A
      opCl :
        ClLeftZeroTerm A ->
        ClLeftZeroTerm A ->
        ClLeftZeroTerm A
    data OpLeftZeroTerm
      (n : Nat) : Set where
      v : Fin n -> OpLeftZeroTerm n
      eOL : OpLeftZeroTerm n
      opOL :
        OpLeftZeroTerm n ->
        OpLeftZeroTerm n ->
        OpLeftZeroTerm n
    data OpLeftZeroTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpLeftZeroTerm2 n A
      sing2 : A -> OpLeftZeroTerm2 n A
      eOL2 : OpLeftZeroTerm2 n A
      opOL2 :
        OpLeftZeroTerm2 n A ->
        OpLeftZeroTerm2 n A ->
        OpLeftZeroTerm2 n A
    simplifyB :
      LeftZeroTerm -> LeftZeroTerm
    simplifyB (opL (eL) x) = eL
    simplifyB (eL) = eL
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLeftZeroTerm A ->
      ClLeftZeroTerm A
    simplifyCl _ (opCl (eCl) x) =
      eCl
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLeftZeroTerm n ->
      OpLeftZeroTerm n
    simplifyOp _ (opOL (eOL) x) =
      eOL
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLeftZeroTerm2 n A ->
      OpLeftZeroTerm2 n A
    simplifyOpE _ _ (opOL2
                     (eOL2)
                     x) = eOL2
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LeftZero A -> LeftZeroTerm -> A
    evalB _ Le (eL) = e Le
    evalB _ Le (opL x1 x2) =
      op Le (evalB _ Le x1)
        (evalB _ Le x2)
    evalCl :
      (A : Set) ->
      LeftZero A ->
      ClLeftZeroTerm A -> A
    evalCl _ Le (sing x1) = x1
    evalCl _ Le (eCl) = e Le
    evalCl _ Le (opCl x1 x2) =
      op Le (evalCl _ Le x1)
        (evalCl _ Le x2)
    evalOp :
      (A : Set) (n : Nat) ->
      LeftZero A ->
      Vec A n -> OpLeftZeroTerm n -> A
    evalOp _ n Le vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Le vars (eOL) = e Le
    evalOp _ n Le vars (opOL
                        x1
                        x2) =
      op Le (evalOp _ n Le vars x1)
        (evalOp _ n Le vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      LeftZero A ->
      Vec A n ->
      OpLeftZeroTerm2 n A -> A
    evalOpE _ n Le vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Le vars (sing2 x1) =
      x1
    evalOpE _ n Le vars (eOL2) =
      e Le
    evalOpE _ n Le vars (opOL2
                         x1
                         x2) =
      op Le (evalOpE _ n Le vars x1)
        (evalOpE _ n Le vars x2)
    inductionB :
      (P : LeftZeroTerm -> Set) ->
      P eL ->
      ((x1 : LeftZeroTerm)
       (x2 : LeftZeroTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : LeftZeroTerm) -> P x
    inductionB p pel popl (eL) = pel
    inductionB p pel popl (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p pel popl x1)
        (inductionB p pel popl x2)
    inductionCl :
      (A : Set)
      (P : ClLeftZeroTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P eCl ->
      ((x1 : ClLeftZeroTerm A)
       (x2 : ClLeftZeroTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClLeftZeroTerm A) -> P x
    inductionCl _ p psing pecl popcl (sing
                                      x1) = psing x1
    inductionCl _ p psing pecl popcl (eCl) =
      pecl
    inductionCl _ p psing pecl popcl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing pecl
           popcl
           x1)
        (inductionCl _ p psing pecl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpLeftZeroTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P eOL ->
      ((x1 : OpLeftZeroTerm n)
       (x2 : OpLeftZeroTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpLeftZeroTerm n) -> P x
    inductionOp _ p pv peol popol (v
                                   x1) = pv x1
    inductionOp _ p pv peol popol (eOL) =
      peol
    inductionOp _ p pv peol popol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv peol popol
           x1)
        (inductionOp _ p pv peol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLeftZeroTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P eOL2 ->
      ((x1 : OpLeftZeroTerm2 n A)
       (x2 : OpLeftZeroTerm2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpLeftZeroTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x2)
    eL' : LeftZeroTerm
    eL' = eL
    opL' :
      LeftZeroTerm ->
      LeftZeroTerm -> LeftZeroTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      LeftZeroTerm ->
      Staged LeftZeroTerm
    stageB (eL) = Now eL
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    eCl' :
      (A : Set) -> ClLeftZeroTerm A
    eCl' _ = eCl
    opCl' :
      (A : Set) ->
      ClLeftZeroTerm A ->
      ClLeftZeroTerm A ->
      ClLeftZeroTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClLeftZeroTerm A ->
      Staged (ClLeftZeroTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (eCl) = Now eCl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    eOL' :
      (n : Nat) -> OpLeftZeroTerm n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      OpLeftZeroTerm n ->
      OpLeftZeroTerm n ->
      OpLeftZeroTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpLeftZeroTerm n ->
      Staged (OpLeftZeroTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (eOL) = Now eOL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    eOL2' :
      (n : Nat) (A : Set) ->
      OpLeftZeroTerm2 n A
    eOL2' _ _ = eOL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpLeftZeroTerm2 n A ->
      OpLeftZeroTerm2 n A ->
      OpLeftZeroTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLeftZeroTerm2 n A ->
      Staged (OpLeftZeroTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LeftZeroTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        eT : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module LieRing where
    record LieRing
      (A : Set) : Set where
      constructor LieRingC
      field
        0 : A
        + : A -> A -> A
        * : A -> A -> A
        jacobian_*_+ :
          (x : A) (y : A) (z : A) ->
          +
            (+ (* x (* y z)) (* y (* z x)))
            (* z (* x y)) == 0
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
        antiCommutative :
          (x : A) (y : A) ->
          * x y == neg (* y x)
    record LieRingSig
      (AS : Set) : Set where
      constructor LieRingSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
        negS : AS -> AS
        1S : AS
    record LieRingProd
      (AP : Set) : Set where
      constructor LieRingProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        jacobian_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P
            (+P (*P xP (*P yP zP))
               (*P yP (*P zP xP)))
            (*P zP (*P xP yP)) == 0P
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
        antiCommutativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == negP (*P yP xP)
    record LieRingHom
      (A1 : Set) (A2 : Set)
      (Li1 : LieRing A1)
      (Li2 : LieRing A2) : Set where
      constructor LieRingHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Li1) == 0 Li2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Li1 x1 x2) ==
            + Li2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Li1 x1 x2) ==
            * Li2 (hom x1) (hom x2)
        pres-neg :
          (x1 : A1) ->
          hom (neg Li1 x1) ==
            neg Li2 (hom x1)
        pres-1 : hom (1 Li1) == 1 Li2
    record LieRingRelInterp
      (A1 : Set) (A2 : Set)
      (Li1 : LieRing A1)
      (Li2 : LieRing A2) : Set where
      constructor LieRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Li1) (0 Li2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Li1 x1 x2)
            (+ Li2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Li1 x1 x2)
            (* Li2 y1 y2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Li1 x1) (neg Li2 y1)
        interp-1 :
          interp (1 Li1) (1 Li2)
    data LieRingTerm : Set where
      0L : LieRingTerm
      +L :
        LieRingTerm ->
        LieRingTerm -> LieRingTerm
      *L :
        LieRingTerm ->
        LieRingTerm -> LieRingTerm
      negL :
        LieRingTerm -> LieRingTerm
      1L : LieRingTerm
    data ClLieRingTerm
      (A : Set) : Set where
      sing : A -> ClLieRingTerm A
      0Cl : ClLieRingTerm A
      +Cl :
        ClLieRingTerm A ->
        ClLieRingTerm A ->
        ClLieRingTerm A
      *Cl :
        ClLieRingTerm A ->
        ClLieRingTerm A ->
        ClLieRingTerm A
      negCl :
        ClLieRingTerm A ->
        ClLieRingTerm A
      1Cl : ClLieRingTerm A
    data OpLieRingTerm
      (n : Nat) : Set where
      v : Fin n -> OpLieRingTerm n
      0OL : OpLieRingTerm n
      +OL :
        OpLieRingTerm n ->
        OpLieRingTerm n ->
        OpLieRingTerm n
      *OL :
        OpLieRingTerm n ->
        OpLieRingTerm n ->
        OpLieRingTerm n
      negOL :
        OpLieRingTerm n ->
        OpLieRingTerm n
      1OL : OpLieRingTerm n
    data OpLieRingTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpLieRingTerm2 n A
      sing2 : A -> OpLieRingTerm2 n A
      0OL2 : OpLieRingTerm2 n A
      +OL2 :
        OpLieRingTerm2 n A ->
        OpLieRingTerm2 n A ->
        OpLieRingTerm2 n A
      *OL2 :
        OpLieRingTerm2 n A ->
        OpLieRingTerm2 n A ->
        OpLieRingTerm2 n A
      negOL2 :
        OpLieRingTerm2 n A ->
        OpLieRingTerm2 n A
      1OL2 : OpLieRingTerm2 n A
    simplifyB :
      LieRingTerm -> LieRingTerm
    simplifyB (+L
               (+L
                (*L x (*L y z))
                (*L y (*L z x)))
               (*L z (*L x y))) = 0L
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (+L
               (*L x y)
               (*L x z)) = *L x (+L y z)
    simplifyB (+L
               (*L y x)
               (*L z x)) = *L (+L y z) x
    simplifyB (+L x (negL x)) = 0L
    simplifyB (+L (negL x) x) = 0L
    simplifyB (*L (1L) x) = x
    simplifyB (*L x (1L)) = x
    simplifyB (*L (0L) x) = 0L
    simplifyB (*L x (0L)) = 0L
    simplifyB (negL (*L y x)) =
      *L x y
    simplifyB (0L) = 0L
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (negL x1) =
      negL (simplifyB x1)
    simplifyB (1L) = 1L
    simplifyCl :
      (A : Set) ->
      ClLieRingTerm A ->
      ClLieRingTerm A
    simplifyCl _ (+Cl
                  (+Cl
                   (*Cl x (*Cl y z))
                   (*Cl y (*Cl z x)))
                  (*Cl z (*Cl x y))) = 0Cl
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (+Cl
                  (*Cl x y)
                  (*Cl x z)) = *Cl x (+Cl y z)
    simplifyCl _ (+Cl
                  (*Cl y x)
                  (*Cl z x)) = *Cl (+Cl y z) x
    simplifyCl _ (+Cl x (negCl x)) =
      0Cl
    simplifyCl _ (+Cl (negCl x) x) =
      0Cl
    simplifyCl _ (*Cl (1Cl) x) = x
    simplifyCl _ (*Cl x (1Cl)) = x
    simplifyCl _ (*Cl (0Cl) x) = 0Cl
    simplifyCl _ (*Cl x (0Cl)) = 0Cl
    simplifyCl _ (negCl (*Cl y x)) =
      *Cl x y
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (negCl x1) =
      negCl (simplifyCl _ x1)
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLieRingTerm n ->
      OpLieRingTerm n
    simplifyOp _ (+OL
                  (+OL
                   (*OL x (*OL y z))
                   (*OL y (*OL z x)))
                  (*OL z (*OL x y))) = 0OL
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (+OL
                  (*OL x y)
                  (*OL x z)) = *OL x (+OL y z)
    simplifyOp _ (+OL
                  (*OL y x)
                  (*OL z x)) = *OL (+OL y z) x
    simplifyOp _ (+OL x (negOL x)) =
      0OL
    simplifyOp _ (+OL (negOL x) x) =
      0OL
    simplifyOp _ (*OL (1OL) x) = x
    simplifyOp _ (*OL x (1OL)) = x
    simplifyOp _ (*OL (0OL) x) = 0OL
    simplifyOp _ (*OL x (0OL)) = 0OL
    simplifyOp _ (negOL (*OL y x)) =
      *OL x y
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (negOL x1) =
      negOL (simplifyOp _ x1)
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLieRingTerm2 n A ->
      OpLieRingTerm2 n A
    simplifyOpE _ _ (+OL2
                     (+OL2
                      (*OL2 x (*OL2 y z))
                      (*OL2 y (*OL2 z x)))
                     (*OL2 z (*OL2 x y))) = 0OL2
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (+OL2
                     (*OL2 x y)
                     (*OL2 x z)) = *OL2 x (+OL2 y z)
    simplifyOpE _ _ (+OL2
                     (*OL2 y x)
                     (*OL2 z x)) = *OL2 (+OL2 y z) x
    simplifyOpE _ _ (+OL2
                     x
                     (negOL2 x)) = 0OL2
    simplifyOpE _ _ (+OL2
                     (negOL2 x)
                     x) = 0OL2
    simplifyOpE _ _ (*OL2
                     (1OL2)
                     x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (1OL2)) = x
    simplifyOpE _ _ (*OL2
                     (0OL2)
                     x) = 0OL2
    simplifyOpE _ _ (*OL2
                     x
                     (0OL2)) = 0OL2
    simplifyOpE _ _ (negOL2
                     (*OL2 y x)) = *OL2 x y
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (negOL2 x1) =
      negOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      LieRing A -> LieRingTerm -> A
    evalB _ Li (0L) = 0 Li
    evalB _ Li (+L x1 x2) =
      + Li (evalB _ Li x1)
        (evalB _ Li x2)
    evalB _ Li (*L x1 x2) =
      * Li (evalB _ Li x1)
        (evalB _ Li x2)
    evalB _ Li (negL x1) =
      neg Li (evalB _ Li x1)
    evalB _ Li (1L) = 1 Li
    evalCl :
      (A : Set) ->
      LieRing A ->
      ClLieRingTerm A -> A
    evalCl _ Li (sing x1) = x1
    evalCl _ Li (0Cl) = 0 Li
    evalCl _ Li (+Cl x1 x2) =
      + Li (evalCl _ Li x1)
        (evalCl _ Li x2)
    evalCl _ Li (*Cl x1 x2) =
      * Li (evalCl _ Li x1)
        (evalCl _ Li x2)
    evalCl _ Li (negCl x1) =
      neg Li (evalCl _ Li x1)
    evalCl _ Li (1Cl) = 1 Li
    evalOp :
      (A : Set) (n : Nat) ->
      LieRing A ->
      Vec A n -> OpLieRingTerm n -> A
    evalOp _ n Li vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Li vars (0OL) = 0 Li
    evalOp _ n Li vars (+OL x1 x2) =
      + Li (evalOp _ n Li vars x1)
        (evalOp _ n Li vars x2)
    evalOp _ n Li vars (*OL x1 x2) =
      * Li (evalOp _ n Li vars x1)
        (evalOp _ n Li vars x2)
    evalOp _ n Li vars (negOL x1) =
      neg Li (evalOp _ n Li vars x1)
    evalOp _ n Li vars (1OL) = 1 Li
    evalOpE :
      (A : Set) (n : Nat) ->
      LieRing A ->
      Vec A n ->
      OpLieRingTerm2 n A -> A
    evalOpE _ n Li vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Li vars (sing2 x1) =
      x1
    evalOpE _ n Li vars (0OL2) =
      0 Li
    evalOpE _ n Li vars (+OL2
                         x1
                         x2) =
      + Li (evalOpE _ n Li vars x1)
        (evalOpE _ n Li vars x2)
    evalOpE _ n Li vars (*OL2
                         x1
                         x2) =
      * Li (evalOpE _ n Li vars x1)
        (evalOpE _ n Li vars x2)
    evalOpE _ n Li vars (negOL2
                         x1) =
      neg Li (evalOpE _ n Li vars x1)
    evalOpE _ n Li vars (1OL2) =
      1 Li
    inductionB :
      (P : LieRingTerm -> Set) ->
      P 0L ->
      ((x1 : LieRingTerm)
       (x2 : LieRingTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      ((x1 : LieRingTerm)
       (x2 : LieRingTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : LieRingTerm) ->
       P x1 -> P (negL x1)) ->
      P 1L -> (x : LieRingTerm) -> P x
    inductionB p p0l p+l p*l pnegl p1l (0L) =
      p0l
    inductionB p p0l p+l p*l pnegl p1l (+L
                                        x1
                                        x2) =
      p+l _ _
        (inductionB p p0l p+l p*l pnegl
           p1l
           x1)
        (inductionB p p0l p+l p*l pnegl
           p1l
           x2)
    inductionB p p0l p+l p*l pnegl p1l (*L
                                        x1
                                        x2) =
      p*l _ _
        (inductionB p p0l p+l p*l pnegl
           p1l
           x1)
        (inductionB p p0l p+l p*l pnegl
           p1l
           x2)
    inductionB p p0l p+l p*l pnegl p1l (negL
                                        x1) =
      pnegl _
        (inductionB p p0l p+l p*l pnegl
           p1l
           x1)
    inductionB p p0l p+l p*l pnegl p1l (1L) =
      p1l
    inductionCl :
      (A : Set)
      (P : ClLieRingTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 0Cl ->
      ((x1 : ClLieRingTerm A)
       (x2 : ClLieRingTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      ((x1 : ClLieRingTerm A)
       (x2 : ClLieRingTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClLieRingTerm A) ->
       P x1 -> P (negCl x1)) ->
      P 1Cl ->
      (x : ClLieRingTerm A) -> P x
    inductionCl _ p psing p0cl p+cl p*cl pnegcl p1cl (sing
                                                      x1) = psing x1
    inductionCl _ p psing p0cl p+cl p*cl pnegcl p1cl (0Cl) =
      p0cl
    inductionCl _ p psing p0cl p+cl p*cl pnegcl p1cl (+Cl
                                                      x1
                                                      x2) =
      p+cl _ _
        (inductionCl _ p psing p0cl p+cl
           p*cl
           pnegcl
           p1cl
           x1)
        (inductionCl _ p psing p0cl p+cl
           p*cl
           pnegcl
           p1cl
           x2)
    inductionCl _ p psing p0cl p+cl p*cl pnegcl p1cl (*Cl
                                                      x1
                                                      x2) =
      p*cl _ _
        (inductionCl _ p psing p0cl p+cl
           p*cl
           pnegcl
           p1cl
           x1)
        (inductionCl _ p psing p0cl p+cl
           p*cl
           pnegcl
           p1cl
           x2)
    inductionCl _ p psing p0cl p+cl p*cl pnegcl p1cl (negCl
                                                      x1) =
      pnegcl _
        (inductionCl _ p psing p0cl p+cl
           p*cl
           pnegcl
           p1cl
           x1)
    inductionCl _ p psing p0cl p+cl p*cl pnegcl p1cl (1Cl) =
      p1cl
    inductionOp :
      (n : Nat)
      (P : OpLieRingTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 0OL ->
      ((x1 : OpLieRingTerm n)
       (x2 : OpLieRingTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      ((x1 : OpLieRingTerm n)
       (x2 : OpLieRingTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpLieRingTerm n) ->
       P x1 -> P (negOL x1)) ->
      P 1OL ->
      (x : OpLieRingTerm n) -> P x
    inductionOp _ p pv p0ol p+ol p*ol pnegol p1ol (v
                                                   x1) = pv x1
    inductionOp _ p pv p0ol p+ol p*ol pnegol p1ol (0OL) =
      p0ol
    inductionOp _ p pv p0ol p+ol p*ol pnegol p1ol (+OL
                                                   x1
                                                   x2) =
      p+ol _ _
        (inductionOp _ p pv p0ol p+ol
           p*ol
           pnegol
           p1ol
           x1)
        (inductionOp _ p pv p0ol p+ol
           p*ol
           pnegol
           p1ol
           x2)
    inductionOp _ p pv p0ol p+ol p*ol pnegol p1ol (*OL
                                                   x1
                                                   x2) =
      p*ol _ _
        (inductionOp _ p pv p0ol p+ol
           p*ol
           pnegol
           p1ol
           x1)
        (inductionOp _ p pv p0ol p+ol
           p*ol
           pnegol
           p1ol
           x2)
    inductionOp _ p pv p0ol p+ol p*ol pnegol p1ol (negOL
                                                   x1) =
      pnegol _
        (inductionOp _ p pv p0ol p+ol
           p*ol
           pnegol
           p1ol
           x1)
    inductionOp _ p pv p0ol p+ol p*ol pnegol p1ol (1OL) =
      p1ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLieRingTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 0OL2 ->
      ((x1 : OpLieRingTerm2 n A)
       (x2 : OpLieRingTerm2 n A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      ((x1 : OpLieRingTerm2 n A)
       (x2 : OpLieRingTerm2 n A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpLieRingTerm2 n A) ->
       P x1 -> P (negOL2 x1)) ->
      P 1OL2 ->
      (x : OpLieRingTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 pnegol2 p1ol2 (v2
                                                                   x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 pnegol2 p1ol2 (sing2
                                                                   x1) =
      psing2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 pnegol2 p1ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 pnegol2 p1ol2 (+OL2
                                                                   x1
                                                                   x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           p*ol2
           pnegol2
           p1ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           p*ol2
           pnegol2
           p1ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 pnegol2 p1ol2 (*OL2
                                                                   x1
                                                                   x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           p*ol2
           pnegol2
           p1ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           p*ol2
           pnegol2
           p1ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 pnegol2 p1ol2 (negOL2
                                                                   x1) =
      pnegol2 _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           p*ol2
           pnegol2
           p1ol2
           x1)
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 pnegol2 p1ol2 (1OL2) =
      p1ol2
    0L' : LieRingTerm
    0L' = 0L
    +L' :
      LieRingTerm ->
      LieRingTerm -> LieRingTerm
    +L' x1 x2 = +L x1 x2
    *L' :
      LieRingTerm ->
      LieRingTerm -> LieRingTerm
    *L' x1 x2 = *L x1 x2
    negL' :
      LieRingTerm -> LieRingTerm
    negL' x1 = negL x1
    1L' : LieRingTerm
    1L' = 1L
    stageB :
      LieRingTerm ->
      Staged LieRingTerm
    stageB (0L) = Now 0L
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (negL x1) =
      stage1 _ _ negL'
        (codeLift1 _ _ negL')
        (stageB x1)
    stageB (1L) = Now 1L
    0Cl' :
      (A : Set) -> ClLieRingTerm A
    0Cl' _ = 0Cl
    +Cl' :
      (A : Set) ->
      ClLieRingTerm A ->
      ClLieRingTerm A ->
      ClLieRingTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    *Cl' :
      (A : Set) ->
      ClLieRingTerm A ->
      ClLieRingTerm A ->
      ClLieRingTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    negCl' :
      (A : Set) ->
      ClLieRingTerm A ->
      ClLieRingTerm A
    negCl' _ x1 = negCl x1
    1Cl' :
      (A : Set) -> ClLieRingTerm A
    1Cl' _ = 1Cl
    stageCl :
      (A : Set) ->
      ClLieRingTerm A ->
      Staged (ClLieRingTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (negCl x1) =
      stage1 _ _ (negCl' _)
        (codeLift1 _ _ (negCl' _))
        (stageCl _ x1)
    stageCl _ (1Cl) = Now 1Cl
    0OL' :
      (n : Nat) -> OpLieRingTerm n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      OpLieRingTerm n ->
      OpLieRingTerm n ->
      OpLieRingTerm n
    +OL' _ x1 x2 = +OL x1 x2
    *OL' :
      (n : Nat) ->
      OpLieRingTerm n ->
      OpLieRingTerm n ->
      OpLieRingTerm n
    *OL' _ x1 x2 = *OL x1 x2
    negOL' :
      (n : Nat) ->
      OpLieRingTerm n ->
      OpLieRingTerm n
    negOL' _ x1 = negOL x1
    1OL' :
      (n : Nat) -> OpLieRingTerm n
    1OL' _ = 1OL
    stageOp :
      (n : Nat) ->
      OpLieRingTerm n ->
      Staged (OpLieRingTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (0OL) = Now 0OL
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (negOL x1) =
      stage1 _ _ (negOL' _)
        (codeLift1 _ _ (negOL' _))
        (stageOp _ x1)
    stageOp _ (1OL) = Now 1OL
    0OL2' :
      (n : Nat) (A : Set) ->
      OpLieRingTerm2 n A
    0OL2' _ _ = 0OL2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpLieRingTerm2 n A ->
      OpLieRingTerm2 n A ->
      OpLieRingTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    *OL2' :
      (n : Nat) (A : Set) ->
      OpLieRingTerm2 n A ->
      OpLieRingTerm2 n A ->
      OpLieRingTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    negOL2' :
      (n : Nat) (A : Set) ->
      OpLieRingTerm2 n A ->
      OpLieRingTerm2 n A
    negOL2' _ _ x1 = negOL2 x1
    1OL2' :
      (n : Nat) (A : Set) ->
      OpLieRingTerm2 n A
    1OL2' _ _ = 1OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLieRingTerm2 n A ->
      Staged (OpLieRingTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (negOL2 x1) =
      stage1 _ _ (negOL2' _ _)
        (codeLift1 _ _ (negOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (1OL2) = Now 1OL2
    record LieRingTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        0T : Repr A
        +T : Repr A -> Repr A -> Repr A
        *T : Repr A -> Repr A -> Repr A
        negT : Repr A -> Repr A
        1T : Repr A
  
  module Loop where
    record Loop
      (A : Set) : Set where
      constructor LoopC
      field
        op : A -> A -> A
        e : A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
    record LoopSig
      (AS : Set) : Set where
      constructor LoopSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
        linvS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record LoopProd
      (AP : Set) : Set where
      constructor LoopProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
    record LoopHom
      (A1 : Set) (A2 : Set)
      (Lo1 : Loop A1)
      (Lo2 : Loop A2) : Set where
      constructor LoopHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Lo1 x1 x2) ==
            op Lo2 (hom x1) (hom x2)
        pres-e : hom (e Lo1) == e Lo2
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Lo1 x1 x2) ==
            linv Lo2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Lo1 x1 x2) ==
            rinv Lo2 (hom x1) (hom x2)
    record LoopRelInterp
      (A1 : Set) (A2 : Set)
      (Lo1 : Loop A1)
      (Lo2 : Loop A2) : Set where
      constructor LoopRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Lo1 x1 x2)
            (op Lo2 y1 y2)
        interp-e :
          interp (e Lo1) (e Lo2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Lo1 x1 x2)
            (linv Lo2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Lo1 x1 x2)
            (rinv Lo2 y1 y2)
    data LoopLTerm : Set where
      opL :
        LoopLTerm ->
        LoopLTerm -> LoopLTerm
      eL : LoopLTerm
      linvL :
        LoopLTerm ->
        LoopLTerm -> LoopLTerm
      rinvL :
        LoopLTerm ->
        LoopLTerm -> LoopLTerm
    data ClLoopClTerm
      (A : Set) : Set where
      sing : A -> ClLoopClTerm A
      opCl :
        ClLoopClTerm A ->
        ClLoopClTerm A -> ClLoopClTerm A
      eCl : ClLoopClTerm A
      linvCl :
        ClLoopClTerm A ->
        ClLoopClTerm A -> ClLoopClTerm A
      rinvCl :
        ClLoopClTerm A ->
        ClLoopClTerm A -> ClLoopClTerm A
    data OpLoopOLTerm
      (n : Nat) : Set where
      v : Fin n -> OpLoopOLTerm n
      opOL :
        OpLoopOLTerm n ->
        OpLoopOLTerm n -> OpLoopOLTerm n
      eOL : OpLoopOLTerm n
      linvOL :
        OpLoopOLTerm n ->
        OpLoopOLTerm n -> OpLoopOLTerm n
      rinvOL :
        OpLoopOLTerm n ->
        OpLoopOLTerm n -> OpLoopOLTerm n
    data OpLoopOL2Term2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpLoopOL2Term2 n A
      sing2 : A -> OpLoopOL2Term2 n A
      opOL2 :
        OpLoopOL2Term2 n A ->
        OpLoopOL2Term2 n A ->
        OpLoopOL2Term2 n A
      eOL2 : OpLoopOL2Term2 n A
      linvOL2 :
        OpLoopOL2Term2 n A ->
        OpLoopOL2Term2 n A ->
        OpLoopOL2Term2 n A
      rinvOL2 :
        OpLoopOL2Term2 n A ->
        OpLoopOL2Term2 n A ->
        OpLoopOL2Term2 n A
    simplifyB :
      LoopLTerm -> LoopLTerm
    simplifyB (opL (eL) x) = x
    simplifyB (opL x (eL)) = x
    simplifyB (opL x (linvL x y)) =
      y
    simplifyB (linvL x (opL x y)) =
      y
    simplifyB (opL (rinvL y x) x) =
      y
    simplifyB (rinvL (opL y x) x) =
      y
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (eL) = eL
    simplifyB (linvL x1 x2) =
      linvL (simplifyB x1)
        (simplifyB x2)
    simplifyB (rinvL x1 x2) =
      rinvL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClLoopClTerm A -> ClLoopClTerm A
    simplifyCl _ (opCl (eCl) x) = x
    simplifyCl _ (opCl x (eCl)) = x
    simplifyCl _ (opCl
                  x
                  (linvCl x y)) = y
    simplifyCl _ (linvCl
                  x
                  (opCl x y)) = y
    simplifyCl _ (opCl
                  (rinvCl y x)
                  x) = y
    simplifyCl _ (rinvCl
                  (opCl y x)
                  x) = y
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (linvCl x1 x2) =
      linvCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (rinvCl x1 x2) =
      rinvCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpLoopOLTerm n -> OpLoopOLTerm n
    simplifyOp _ (opOL (eOL) x) = x
    simplifyOp _ (opOL x (eOL)) = x
    simplifyOp _ (opOL
                  x
                  (linvOL x y)) = y
    simplifyOp _ (linvOL
                  x
                  (opOL x y)) = y
    simplifyOp _ (opOL
                  (rinvOL y x)
                  x) = y
    simplifyOp _ (rinvOL
                  (opOL y x)
                  x) = y
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (linvOL x1 x2) =
      linvOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (rinvOL x1 x2) =
      rinvOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpLoopOL2Term2 n A ->
      OpLoopOL2Term2 n A
    simplifyOpE _ _ (opOL2
                     (eOL2)
                     x) = x
    simplifyOpE _ _ (opOL2
                     x
                     (eOL2)) = x
    simplifyOpE _ _ (opOL2
                     x
                     (linvOL2 x y)) = y
    simplifyOpE _ _ (linvOL2
                     x
                     (opOL2 x y)) = y
    simplifyOpE _ _ (opOL2
                     (rinvOL2 y x)
                     x) = y
    simplifyOpE _ _ (rinvOL2
                     (opOL2 y x)
                     x) = y
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (linvOL2
                     x1
                     x2) =
      linvOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (rinvOL2
                     x1
                     x2) =
      rinvOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Loop A -> LoopLTerm -> A
    evalB _ Lo (opL x1 x2) =
      op Lo (evalB _ Lo x1)
        (evalB _ Lo x2)
    evalB _ Lo (eL) = e Lo
    evalB _ Lo (linvL x1 x2) =
      linv Lo (evalB _ Lo x1)
        (evalB _ Lo x2)
    evalB _ Lo (rinvL x1 x2) =
      rinv Lo (evalB _ Lo x1)
        (evalB _ Lo x2)
    evalCl :
      (A : Set) ->
      Loop A -> ClLoopClTerm A -> A
    evalCl _ Lo (sing x1) = x1
    evalCl _ Lo (opCl x1 x2) =
      op Lo (evalCl _ Lo x1)
        (evalCl _ Lo x2)
    evalCl _ Lo (eCl) = e Lo
    evalCl _ Lo (linvCl x1 x2) =
      linv Lo (evalCl _ Lo x1)
        (evalCl _ Lo x2)
    evalCl _ Lo (rinvCl x1 x2) =
      rinv Lo (evalCl _ Lo x1)
        (evalCl _ Lo x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Loop A ->
      Vec A n -> OpLoopOLTerm n -> A
    evalOp _ n Lo vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Lo vars (opOL
                        x1
                        x2) =
      op Lo (evalOp _ n Lo vars x1)
        (evalOp _ n Lo vars x2)
    evalOp _ n Lo vars (eOL) = e Lo
    evalOp _ n Lo vars (linvOL
                        x1
                        x2) =
      linv Lo (evalOp _ n Lo vars x1)
        (evalOp _ n Lo vars x2)
    evalOp _ n Lo vars (rinvOL
                        x1
                        x2) =
      rinv Lo (evalOp _ n Lo vars x1)
        (evalOp _ n Lo vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Loop A ->
      Vec A n ->
      OpLoopOL2Term2 n A -> A
    evalOpE _ n Lo vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Lo vars (sing2 x1) =
      x1
    evalOpE _ n Lo vars (opOL2
                         x1
                         x2) =
      op Lo (evalOpE _ n Lo vars x1)
        (evalOpE _ n Lo vars x2)
    evalOpE _ n Lo vars (eOL2) =
      e Lo
    evalOpE _ n Lo vars (linvOL2
                         x1
                         x2) =
      linv Lo (evalOpE _ n Lo vars x1)
        (evalOpE _ n Lo vars x2)
    evalOpE _ n Lo vars (rinvOL2
                         x1
                         x2) =
      rinv Lo (evalOpE _ n Lo vars x1)
        (evalOpE _ n Lo vars x2)
    inductionB :
      (P : LoopLTerm -> Set) ->
      ((x1 : LoopLTerm)
       (x2 : LoopLTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      P eL ->
      ((x1 : LoopLTerm)
       (x2 : LoopLTerm) ->
       P x1 ->
       P x2 -> P (linvL x1 x2)) ->
      ((x1 : LoopLTerm)
       (x2 : LoopLTerm) ->
       P x1 ->
       P x2 -> P (rinvL x1 x2)) ->
      (x : LoopLTerm) -> P x
    inductionB p popl pel plinvl prinvl (opL
                                         x1
                                         x2) =
      popl _ _
        (inductionB p popl pel plinvl
           prinvl
           x1)
        (inductionB p popl pel plinvl
           prinvl
           x2)
    inductionB p popl pel plinvl prinvl (eL) =
      pel
    inductionB p popl pel plinvl prinvl (linvL
                                         x1
                                         x2) =
      plinvl _ _
        (inductionB p popl pel plinvl
           prinvl
           x1)
        (inductionB p popl pel plinvl
           prinvl
           x2)
    inductionB p popl pel plinvl prinvl (rinvL
                                         x1
                                         x2) =
      prinvl _ _
        (inductionB p popl pel plinvl
           prinvl
           x1)
        (inductionB p popl pel plinvl
           prinvl
           x2)
    inductionCl :
      (A : Set)
      (P : ClLoopClTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClLoopClTerm A)
       (x2 : ClLoopClTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      P eCl ->
      ((x1 : ClLoopClTerm A)
       (x2 : ClLoopClTerm A) ->
       P x1 ->
       P x2 -> P (linvCl x1 x2)) ->
      ((x1 : ClLoopClTerm A)
       (x2 : ClLoopClTerm A) ->
       P x1 ->
       P x2 -> P (rinvCl x1 x2)) ->
      (x : ClLoopClTerm A) -> P x
    inductionCl _ p psing popcl pecl plinvcl prinvcl (sing
                                                      x1) = psing x1
    inductionCl _ p psing popcl pecl plinvcl prinvcl (opCl
                                                      x1
                                                      x2) =
      popcl _ _
        (inductionCl _ p psing popcl
           pecl
           plinvcl
           prinvcl
           x1)
        (inductionCl _ p psing popcl
           pecl
           plinvcl
           prinvcl
           x2)
    inductionCl _ p psing popcl pecl plinvcl prinvcl (eCl) =
      pecl
    inductionCl _ p psing popcl pecl plinvcl prinvcl (linvCl
                                                      x1
                                                      x2) =
      plinvcl _ _
        (inductionCl _ p psing popcl
           pecl
           plinvcl
           prinvcl
           x1)
        (inductionCl _ p psing popcl
           pecl
           plinvcl
           prinvcl
           x2)
    inductionCl _ p psing popcl pecl plinvcl prinvcl (rinvCl
                                                      x1
                                                      x2) =
      prinvcl _ _
        (inductionCl _ p psing popcl
           pecl
           plinvcl
           prinvcl
           x1)
        (inductionCl _ p psing popcl
           pecl
           plinvcl
           prinvcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpLoopOLTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpLoopOLTerm n)
       (x2 : OpLoopOLTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      P eOL ->
      ((x1 : OpLoopOLTerm n)
       (x2 : OpLoopOLTerm n) ->
       P x1 ->
       P x2 -> P (linvOL x1 x2)) ->
      ((x1 : OpLoopOLTerm n)
       (x2 : OpLoopOLTerm n) ->
       P x1 ->
       P x2 -> P (rinvOL x1 x2)) ->
      (x : OpLoopOLTerm n) -> P x
    inductionOp _ p pv popol peol plinvol prinvol (v
                                                   x1) = pv x1
    inductionOp _ p pv popol peol plinvol prinvol (opOL
                                                   x1
                                                   x2) =
      popol _ _
        (inductionOp _ p pv popol peol
           plinvol
           prinvol
           x1)
        (inductionOp _ p pv popol peol
           plinvol
           prinvol
           x2)
    inductionOp _ p pv popol peol plinvol prinvol (eOL) =
      peol
    inductionOp _ p pv popol peol plinvol prinvol (linvOL
                                                   x1
                                                   x2) =
      plinvol _ _
        (inductionOp _ p pv popol peol
           plinvol
           prinvol
           x1)
        (inductionOp _ p pv popol peol
           plinvol
           prinvol
           x2)
    inductionOp _ p pv popol peol plinvol prinvol (rinvOL
                                                   x1
                                                   x2) =
      prinvol _ _
        (inductionOp _ p pv popol peol
           plinvol
           prinvol
           x1)
        (inductionOp _ p pv popol peol
           plinvol
           prinvol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpLoopOL2Term2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpLoopOL2Term2 n A)
       (x2 : OpLoopOL2Term2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      P eOL2 ->
      ((x1 : OpLoopOL2Term2 n A)
       (x2 : OpLoopOL2Term2 n A) ->
       P x1 ->
       P x2 -> P (linvOL2 x1 x2)) ->
      ((x1 : OpLoopOL2Term2 n A)
       (x2 : OpLoopOL2Term2 n A) ->
       P x1 ->
       P x2 -> P (rinvOL2 x1 x2)) ->
      (x : OpLoopOL2Term2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 peol2 plinvol2 prinvol2 (v2
                                                                  x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 peol2 plinvol2 prinvol2 (sing2
                                                                  x1) =
      psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 peol2 plinvol2 prinvol2 (opOL2
                                                                  x1
                                                                  x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           plinvol2
           prinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           plinvol2
           prinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 peol2 plinvol2 prinvol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 popol2 peol2 plinvol2 prinvol2 (linvOL2
                                                                  x1
                                                                  x2) =
      plinvol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           plinvol2
           prinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           plinvol2
           prinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 peol2 plinvol2 prinvol2 (rinvOL2
                                                                  x1
                                                                  x2) =
      prinvol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           plinvol2
           prinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           plinvol2
           prinvol2
           x2)
    opL' :
      LoopLTerm ->
      LoopLTerm -> LoopLTerm
    opL' x1 x2 = opL x1 x2
    eL' : LoopLTerm
    eL' = eL
    linvL' :
      LoopLTerm ->
      LoopLTerm -> LoopLTerm
    linvL' x1 x2 = linvL x1 x2
    rinvL' :
      LoopLTerm ->
      LoopLTerm -> LoopLTerm
    rinvL' x1 x2 = rinvL x1 x2
    stageB :
      LoopLTerm -> Staged LoopLTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (eL) = Now eL
    stageB (linvL x1 x2) =
      stage2 _ _ _ linvL'
        (codeLift2 _ _ _ linvL')
        (stageB x1)
        (stageB x2)
    stageB (rinvL x1 x2) =
      stage2 _ _ _ rinvL'
        (codeLift2 _ _ _ rinvL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClLoopClTerm A ->
      ClLoopClTerm A -> ClLoopClTerm A
    opCl' _ x1 x2 = opCl x1 x2
    eCl' :
      (A : Set) -> ClLoopClTerm A
    eCl' _ = eCl
    linvCl' :
      (A : Set) ->
      ClLoopClTerm A ->
      ClLoopClTerm A -> ClLoopClTerm A
    linvCl' _ x1 x2 = linvCl x1 x2
    rinvCl' :
      (A : Set) ->
      ClLoopClTerm A ->
      ClLoopClTerm A -> ClLoopClTerm A
    rinvCl' _ x1 x2 = rinvCl x1 x2
    stageCl :
      (A : Set) ->
      ClLoopClTerm A ->
      Staged (ClLoopClTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (eCl) = Now eCl
    stageCl _ (linvCl x1 x2) =
      stage2 _ _ _ (linvCl' _)
        (codeLift2 _ _ _ (linvCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (rinvCl x1 x2) =
      stage2 _ _ _ (rinvCl' _)
        (codeLift2 _ _ _ (rinvCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpLoopOLTerm n ->
      OpLoopOLTerm n -> OpLoopOLTerm n
    opOL' _ x1 x2 = opOL x1 x2
    eOL' :
      (n : Nat) -> OpLoopOLTerm n
    eOL' _ = eOL
    linvOL' :
      (n : Nat) ->
      OpLoopOLTerm n ->
      OpLoopOLTerm n -> OpLoopOLTerm n
    linvOL' _ x1 x2 = linvOL x1 x2
    rinvOL' :
      (n : Nat) ->
      OpLoopOLTerm n ->
      OpLoopOLTerm n -> OpLoopOLTerm n
    rinvOL' _ x1 x2 = rinvOL x1 x2
    stageOp :
      (n : Nat) ->
      OpLoopOLTerm n ->
      Staged (OpLoopOLTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (eOL) = Now eOL
    stageOp _ (linvOL x1 x2) =
      stage2 _ _ _ (linvOL' _)
        (codeLift2 _ _ _ (linvOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (rinvOL x1 x2) =
      stage2 _ _ _ (rinvOL' _)
        (codeLift2 _ _ _ (rinvOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpLoopOL2Term2 n A ->
      OpLoopOL2Term2 n A ->
      OpLoopOL2Term2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    eOL2' :
      (n : Nat) (A : Set) ->
      OpLoopOL2Term2 n A
    eOL2' _ _ = eOL2
    linvOL2' :
      (n : Nat) (A : Set) ->
      OpLoopOL2Term2 n A ->
      OpLoopOL2Term2 n A ->
      OpLoopOL2Term2 n A
    linvOL2' _ _ x1 x2 =
      linvOL2 x1 x2
    rinvOL2' :
      (n : Nat) (A : Set) ->
      OpLoopOL2Term2 n A ->
      OpLoopOL2Term2 n A ->
      OpLoopOL2Term2 n A
    rinvOL2' _ _ x1 x2 =
      rinvOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpLoopOL2Term2 n A ->
      Staged (OpLoopOL2Term2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (linvOL2 x1 x2) =
      stage2 _ _ _ (linvOL2' _ _)
        (codeLift2 _ _ _ (linvOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (rinvOL2 x1 x2) =
      stage2 _ _ _ (rinvOL2' _ _)
        (codeLift2 _ _ _ (rinvOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record LoopTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
        eT : Repr A
        linvT :
          Repr A -> Repr A -> Repr A
        rinvT :
          Repr A -> Repr A -> Repr A
  
  module Magma where
    record Magma
      (A : Set) : Set where
      constructor MagmaC
      field
        op : A -> A -> A
    record MagmaSig
      (AS : Set) : Set where
      constructor MagmaSigSigC
      field
        opS : AS -> AS -> AS
    record MagmaProd
      (AP : Set) : Set where
      constructor MagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record MagmaHom
      (A1 : Set) (A2 : Set)
      (Ma1 : Magma A1)
      (Ma2 : Magma A2) : Set where
      constructor MagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ma1 x1 x2) ==
            op Ma2 (hom x1) (hom x2)
    record MagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ma1 : Magma A1)
      (Ma2 : Magma A2) : Set where
      constructor MagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ma1 x1 x2)
            (op Ma2 y1 y2)
    data MagmaTerm : Set where
      opL :
        MagmaTerm ->
        MagmaTerm -> MagmaTerm
    data ClMagmaTerm
      (A : Set) : Set where
      sing : A -> ClMagmaTerm A
      opCl :
        ClMagmaTerm A ->
        ClMagmaTerm A -> ClMagmaTerm A
    data OpMagmaTerm
      (n : Nat) : Set where
      v : Fin n -> OpMagmaTerm n
      opOL :
        OpMagmaTerm n ->
        OpMagmaTerm n -> OpMagmaTerm n
    data OpMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 : Fin n -> OpMagmaTerm2 n A
      sing2 : A -> OpMagmaTerm2 n A
      opOL2 :
        OpMagmaTerm2 n A ->
        OpMagmaTerm2 n A ->
        OpMagmaTerm2 n A
    simplifyB :
      MagmaTerm -> MagmaTerm
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClMagmaTerm A -> ClMagmaTerm A
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpMagmaTerm n -> OpMagmaTerm n
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpMagmaTerm2 n A ->
      OpMagmaTerm2 n A
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Magma A -> MagmaTerm -> A
    evalB _ Ma (opL x1 x2) =
      op Ma (evalB _ Ma x1)
        (evalB _ Ma x2)
    evalCl :
      (A : Set) ->
      Magma A -> ClMagmaTerm A -> A
    evalCl _ Ma (sing x1) = x1
    evalCl _ Ma (opCl x1 x2) =
      op Ma (evalCl _ Ma x1)
        (evalCl _ Ma x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Magma A ->
      Vec A n -> OpMagmaTerm n -> A
    evalOp _ n Ma vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ma vars (opOL
                        x1
                        x2) =
      op Ma (evalOp _ n Ma vars x1)
        (evalOp _ n Ma vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Magma A ->
      Vec A n -> OpMagmaTerm2 n A -> A
    evalOpE _ n Ma vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ma vars (sing2 x1) =
      x1
    evalOpE _ n Ma vars (opOL2
                         x1
                         x2) =
      op Ma (evalOpE _ n Ma vars x1)
        (evalOpE _ n Ma vars x2)
    inductionB :
      (P : MagmaTerm -> Set) ->
      ((x1 : MagmaTerm)
       (x2 : MagmaTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : MagmaTerm) -> P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClMagmaTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClMagmaTerm A)
       (x2 : ClMagmaTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClMagmaTerm A) -> P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpMagmaTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpMagmaTerm n)
       (x2 : OpMagmaTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpMagmaTerm n) -> P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpMagmaTerm2 n A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpMagmaTerm2 n A)
       (x2 : OpMagmaTerm2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpMagmaTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      MagmaTerm ->
      MagmaTerm -> MagmaTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      MagmaTerm -> Staged MagmaTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClMagmaTerm A ->
      ClMagmaTerm A -> ClMagmaTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClMagmaTerm A ->
      Staged (ClMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpMagmaTerm n ->
      OpMagmaTerm n -> OpMagmaTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpMagmaTerm n ->
      Staged (OpMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpMagmaTerm2 n A ->
      OpMagmaTerm2 n A ->
      OpMagmaTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpMagmaTerm2 n A ->
      Staged (OpMagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record MagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module MedialMagma where
    record MedialMagma
      (A : Set) : Set where
      constructor MedialMagmaC
      field
        op : A -> A -> A
        mediates :
          (w : A) (x : A) (y : A)
          (z : A) ->
          op (op x y) (op z w) ==
            op (op x z) (op y w)
    record MedialMagmaSig
      (AS : Set) : Set where
      constructor MedialMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record MedialMagmaProd
      (AP : Set) : Set where
      constructor MedialMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        mediatesP :
          (wP : Prod AP AP)
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) (opP zP wP) ==
            opP (opP xP zP) (opP yP wP)
    record MedialMagmaHom
      (A1 : Set) (A2 : Set)
      (Me1 : MedialMagma A1)
      (Me2 : MedialMagma A2) :
      Set where
      constructor MedialMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Me1 x1 x2) ==
            op Me2 (hom x1) (hom x2)
    record MedialMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Me1 : MedialMagma A1)
      (Me2 : MedialMagma A2) :
      Set where
      constructor MedialMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Me1 x1 x2)
            (op Me2 y1 y2)
    data MedialMagmaTerm : Set where
      opL :
        MedialMagmaTerm ->
        MedialMagmaTerm ->
        MedialMagmaTerm
    data ClMedialMagmaTerm
      (A : Set) : Set where
      sing :
        A -> ClMedialMagmaTerm A
      opCl :
        ClMedialMagmaTerm A ->
        ClMedialMagmaTerm A ->
        ClMedialMagmaTerm A
    data OpMedialMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpMedialMagmaTerm n
      opOL :
        OpMedialMagmaTerm n ->
        OpMedialMagmaTerm n ->
        OpMedialMagmaTerm n
    data OpMedialMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpMedialMagmaTerm2 n A
      sing2 :
        A -> OpMedialMagmaTerm2 n A
      opOL2 :
        OpMedialMagmaTerm2 n A ->
        OpMedialMagmaTerm2 n A ->
        OpMedialMagmaTerm2 n A
    simplifyB :
      MedialMagmaTerm ->
      MedialMagmaTerm
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClMedialMagmaTerm A ->
      ClMedialMagmaTerm A
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpMedialMagmaTerm n ->
      OpMedialMagmaTerm n
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpMedialMagmaTerm2 n A ->
      OpMedialMagmaTerm2 n A
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      MedialMagma A ->
      MedialMagmaTerm -> A
    evalB _ Me (opL x1 x2) =
      op Me (evalB _ Me x1)
        (evalB _ Me x2)
    evalCl :
      (A : Set) ->
      MedialMagma A ->
      ClMedialMagmaTerm A -> A
    evalCl _ Me (sing x1) = x1
    evalCl _ Me (opCl x1 x2) =
      op Me (evalCl _ Me x1)
        (evalCl _ Me x2)
    evalOp :
      (A : Set) (n : Nat) ->
      MedialMagma A ->
      Vec A n ->
      OpMedialMagmaTerm n -> A
    evalOp _ n Me vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Me vars (opOL
                        x1
                        x2) =
      op Me (evalOp _ n Me vars x1)
        (evalOp _ n Me vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      MedialMagma A ->
      Vec A n ->
      OpMedialMagmaTerm2 n A -> A
    evalOpE _ n Me vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Me vars (sing2 x1) =
      x1
    evalOpE _ n Me vars (opOL2
                         x1
                         x2) =
      op Me (evalOpE _ n Me vars x1)
        (evalOpE _ n Me vars x2)
    inductionB :
      (P : MedialMagmaTerm -> Set) ->
      ((x1 : MedialMagmaTerm)
       (x2 : MedialMagmaTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : MedialMagmaTerm) -> P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClMedialMagmaTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClMedialMagmaTerm A)
       (x2 : ClMedialMagmaTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClMedialMagmaTerm A) -> P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpMedialMagmaTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpMedialMagmaTerm n)
       (x2 : OpMedialMagmaTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpMedialMagmaTerm n) -> P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpMedialMagmaTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpMedialMagmaTerm2 n A)
       (x2 : OpMedialMagmaTerm2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpMedialMagmaTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      MedialMagmaTerm ->
      MedialMagmaTerm ->
      MedialMagmaTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      MedialMagmaTerm ->
      Staged MedialMagmaTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClMedialMagmaTerm A ->
      ClMedialMagmaTerm A ->
      ClMedialMagmaTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClMedialMagmaTerm A ->
      Staged (ClMedialMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpMedialMagmaTerm n ->
      OpMedialMagmaTerm n ->
      OpMedialMagmaTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpMedialMagmaTerm n ->
      Staged (OpMedialMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpMedialMagmaTerm2 n A ->
      OpMedialMagmaTerm2 n A ->
      OpMedialMagmaTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpMedialMagmaTerm2 n A ->
      Staged (OpMedialMagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record MedialMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module MedialQuasiGroup where
    record MedialQuasiGroup
      (A : Set) : Set where
      constructor MedialQuasiGroupC
      field
        op : A -> A -> A
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
        mediates :
          (w : A) (x : A) (y : A)
          (z : A) ->
          op (op x y) (op z w) ==
            op (op x z) (op y w)
    record MedialQuasiGroupSig
      (AS : Set) : Set where
      constructor MedialQuasiGroupSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record MedialQuasiGroupProd
      (AP : Set) : Set where
      constructor MedialQuasiGroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
        mediatesP :
          (wP : Prod AP AP)
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) (opP zP wP) ==
            opP (opP xP zP) (opP yP wP)
    record MedialQuasiGroupHom
      (A1 : Set) (A2 : Set)
      (Me1 : MedialQuasiGroup A1)
      (Me2 : MedialQuasiGroup A2) :
      Set where
      constructor MedialQuasiGroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Me1 x1 x2) ==
            op Me2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Me1 x1 x2) ==
            linv Me2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Me1 x1 x2) ==
            rinv Me2 (hom x1) (hom x2)
    record MedialQuasiGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Me1 : MedialQuasiGroup A1)
      (Me2 : MedialQuasiGroup A2) :
      Set where
      constructor MedialQuasiGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Me1 x1 x2)
            (op Me2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Me1 x1 x2)
            (linv Me2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Me1 x1 x2)
            (rinv Me2 y1 y2)
    data MedialQuasiGroupTerm
      : Set where
      opL :
        MedialQuasiGroupTerm ->
        MedialQuasiGroupTerm ->
        MedialQuasiGroupTerm
      linvL :
        MedialQuasiGroupTerm ->
        MedialQuasiGroupTerm ->
        MedialQuasiGroupTerm
      rinvL :
        MedialQuasiGroupTerm ->
        MedialQuasiGroupTerm ->
        MedialQuasiGroupTerm
    data ClMedialQuasiGroupTerm
      (A : Set) : Set where
      sing :
        A -> ClMedialQuasiGroupTerm A
      opCl :
        ClMedialQuasiGroupTerm A ->
        ClMedialQuasiGroupTerm A ->
        ClMedialQuasiGroupTerm A
      linvCl :
        ClMedialQuasiGroupTerm A ->
        ClMedialQuasiGroupTerm A ->
        ClMedialQuasiGroupTerm A
      rinvCl :
        ClMedialQuasiGroupTerm A ->
        ClMedialQuasiGroupTerm A ->
        ClMedialQuasiGroupTerm A
    data OpMedialQuasiGroupTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpMedialQuasiGroupTerm n
      opOL :
        OpMedialQuasiGroupTerm n ->
        OpMedialQuasiGroupTerm n ->
        OpMedialQuasiGroupTerm n
      linvOL :
        OpMedialQuasiGroupTerm n ->
        OpMedialQuasiGroupTerm n ->
        OpMedialQuasiGroupTerm n
      rinvOL :
        OpMedialQuasiGroupTerm n ->
        OpMedialQuasiGroupTerm n ->
        OpMedialQuasiGroupTerm n
    data OpMedialQuasiGroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpMedialQuasiGroupTerm2 n A
      sing2 :
        A -> OpMedialQuasiGroupTerm2 n A
      opOL2 :
        OpMedialQuasiGroupTerm2 n A ->
        OpMedialQuasiGroupTerm2 n A ->
        OpMedialQuasiGroupTerm2 n A
      linvOL2 :
        OpMedialQuasiGroupTerm2 n A ->
        OpMedialQuasiGroupTerm2 n A ->
        OpMedialQuasiGroupTerm2 n A
      rinvOL2 :
        OpMedialQuasiGroupTerm2 n A ->
        OpMedialQuasiGroupTerm2 n A ->
        OpMedialQuasiGroupTerm2 n A
    simplifyB :
      MedialQuasiGroupTerm ->
      MedialQuasiGroupTerm
    simplifyB (opL x (linvL x y)) =
      y
    simplifyB (linvL x (opL x y)) =
      y
    simplifyB (opL (rinvL y x) x) =
      y
    simplifyB (rinvL (opL y x) x) =
      y
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (linvL x1 x2) =
      linvL (simplifyB x1)
        (simplifyB x2)
    simplifyB (rinvL x1 x2) =
      rinvL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClMedialQuasiGroupTerm A ->
      ClMedialQuasiGroupTerm A
    simplifyCl _ (opCl
                  x
                  (linvCl x y)) = y
    simplifyCl _ (linvCl
                  x
                  (opCl x y)) = y
    simplifyCl _ (opCl
                  (rinvCl y x)
                  x) = y
    simplifyCl _ (rinvCl
                  (opCl y x)
                  x) = y
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (linvCl x1 x2) =
      linvCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (rinvCl x1 x2) =
      rinvCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpMedialQuasiGroupTerm n ->
      OpMedialQuasiGroupTerm n
    simplifyOp _ (opOL
                  x
                  (linvOL x y)) = y
    simplifyOp _ (linvOL
                  x
                  (opOL x y)) = y
    simplifyOp _ (opOL
                  (rinvOL y x)
                  x) = y
    simplifyOp _ (rinvOL
                  (opOL y x)
                  x) = y
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (linvOL x1 x2) =
      linvOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (rinvOL x1 x2) =
      rinvOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpMedialQuasiGroupTerm2 n A ->
      OpMedialQuasiGroupTerm2 n A
    simplifyOpE _ _ (opOL2
                     x
                     (linvOL2 x y)) = y
    simplifyOpE _ _ (linvOL2
                     x
                     (opOL2 x y)) = y
    simplifyOpE _ _ (opOL2
                     (rinvOL2 y x)
                     x) = y
    simplifyOpE _ _ (rinvOL2
                     (opOL2 y x)
                     x) = y
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (linvOL2
                     x1
                     x2) =
      linvOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (rinvOL2
                     x1
                     x2) =
      rinvOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      MedialQuasiGroup A ->
      MedialQuasiGroupTerm -> A
    evalB _ Me (opL x1 x2) =
      op Me (evalB _ Me x1)
        (evalB _ Me x2)
    evalB _ Me (linvL x1 x2) =
      linv Me (evalB _ Me x1)
        (evalB _ Me x2)
    evalB _ Me (rinvL x1 x2) =
      rinv Me (evalB _ Me x1)
        (evalB _ Me x2)
    evalCl :
      (A : Set) ->
      MedialQuasiGroup A ->
      ClMedialQuasiGroupTerm A -> A
    evalCl _ Me (sing x1) = x1
    evalCl _ Me (opCl x1 x2) =
      op Me (evalCl _ Me x1)
        (evalCl _ Me x2)
    evalCl _ Me (linvCl x1 x2) =
      linv Me (evalCl _ Me x1)
        (evalCl _ Me x2)
    evalCl _ Me (rinvCl x1 x2) =
      rinv Me (evalCl _ Me x1)
        (evalCl _ Me x2)
    evalOp :
      (A : Set) (n : Nat) ->
      MedialQuasiGroup A ->
      Vec A n ->
      OpMedialQuasiGroupTerm n -> A
    evalOp _ n Me vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Me vars (opOL
                        x1
                        x2) =
      op Me (evalOp _ n Me vars x1)
        (evalOp _ n Me vars x2)
    evalOp _ n Me vars (linvOL
                        x1
                        x2) =
      linv Me (evalOp _ n Me vars x1)
        (evalOp _ n Me vars x2)
    evalOp _ n Me vars (rinvOL
                        x1
                        x2) =
      rinv Me (evalOp _ n Me vars x1)
        (evalOp _ n Me vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      MedialQuasiGroup A ->
      Vec A n ->
      OpMedialQuasiGroupTerm2 n A -> A
    evalOpE _ n Me vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Me vars (sing2 x1) =
      x1
    evalOpE _ n Me vars (opOL2
                         x1
                         x2) =
      op Me (evalOpE _ n Me vars x1)
        (evalOpE _ n Me vars x2)
    evalOpE _ n Me vars (linvOL2
                         x1
                         x2) =
      linv Me (evalOpE _ n Me vars x1)
        (evalOpE _ n Me vars x2)
    evalOpE _ n Me vars (rinvOL2
                         x1
                         x2) =
      rinv Me (evalOpE _ n Me vars x1)
        (evalOpE _ n Me vars x2)
    inductionB :
      (P : MedialQuasiGroupTerm ->
           Set) ->
      ((x1 : MedialQuasiGroupTerm)
       (x2 : MedialQuasiGroupTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      ((x1 : MedialQuasiGroupTerm)
       (x2 : MedialQuasiGroupTerm) ->
       P x1 ->
       P x2 -> P (linvL x1 x2)) ->
      ((x1 : MedialQuasiGroupTerm)
       (x2 : MedialQuasiGroupTerm) ->
       P x1 ->
       P x2 -> P (rinvL x1 x2)) ->
      (x : MedialQuasiGroupTerm) ->
      P x
    inductionB p popl plinvl prinvl (opL
                                     x1
                                     x2) =
      popl _ _
        (inductionB p popl plinvl prinvl
           x1)
        (inductionB p popl plinvl prinvl
           x2)
    inductionB p popl plinvl prinvl (linvL
                                     x1
                                     x2) =
      plinvl _ _
        (inductionB p popl plinvl prinvl
           x1)
        (inductionB p popl plinvl prinvl
           x2)
    inductionB p popl plinvl prinvl (rinvL
                                     x1
                                     x2) =
      prinvl _ _
        (inductionB p popl plinvl prinvl
           x1)
        (inductionB p popl plinvl prinvl
           x2)
    inductionCl :
      (A : Set)
      (P : ClMedialQuasiGroupTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClMedialQuasiGroupTerm A)
       (x2 : ClMedialQuasiGroupTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      ((x1 : ClMedialQuasiGroupTerm A)
       (x2 : ClMedialQuasiGroupTerm
          A) ->
       P x1 ->
       P x2 -> P (linvCl x1 x2)) ->
      ((x1 : ClMedialQuasiGroupTerm A)
       (x2 : ClMedialQuasiGroupTerm
          A) ->
       P x1 ->
       P x2 -> P (rinvCl x1 x2)) ->
      (x : ClMedialQuasiGroupTerm
         A) -> P x
    inductionCl _ p psing popcl plinvcl prinvcl (sing
                                                 x1) = psing x1
    inductionCl _ p psing popcl plinvcl prinvcl (opCl
                                                 x1
                                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl
           plinvcl
           prinvcl
           x1)
        (inductionCl _ p psing popcl
           plinvcl
           prinvcl
           x2)
    inductionCl _ p psing popcl plinvcl prinvcl (linvCl
                                                 x1
                                                 x2) =
      plinvcl _ _
        (inductionCl _ p psing popcl
           plinvcl
           prinvcl
           x1)
        (inductionCl _ p psing popcl
           plinvcl
           prinvcl
           x2)
    inductionCl _ p psing popcl plinvcl prinvcl (rinvCl
                                                 x1
                                                 x2) =
      prinvcl _ _
        (inductionCl _ p psing popcl
           plinvcl
           prinvcl
           x1)
        (inductionCl _ p psing popcl
           plinvcl
           prinvcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpMedialQuasiGroupTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpMedialQuasiGroupTerm n)
       (x2 : OpMedialQuasiGroupTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      ((x1 : OpMedialQuasiGroupTerm n)
       (x2 : OpMedialQuasiGroupTerm
          n) ->
       P x1 ->
       P x2 -> P (linvOL x1 x2)) ->
      ((x1 : OpMedialQuasiGroupTerm n)
       (x2 : OpMedialQuasiGroupTerm
          n) ->
       P x1 ->
       P x2 -> P (rinvOL x1 x2)) ->
      (x : OpMedialQuasiGroupTerm
         n) -> P x
    inductionOp _ p pv popol plinvol prinvol (v
                                              x1) = pv x1
    inductionOp _ p pv popol plinvol prinvol (opOL
                                              x1
                                              x2) =
      popol _ _
        (inductionOp _ p pv popol
           plinvol
           prinvol
           x1)
        (inductionOp _ p pv popol
           plinvol
           prinvol
           x2)
    inductionOp _ p pv popol plinvol prinvol (linvOL
                                              x1
                                              x2) =
      plinvol _ _
        (inductionOp _ p pv popol
           plinvol
           prinvol
           x1)
        (inductionOp _ p pv popol
           plinvol
           prinvol
           x2)
    inductionOp _ p pv popol plinvol prinvol (rinvOL
                                              x1
                                              x2) =
      prinvol _ _
        (inductionOp _ p pv popol
           plinvol
           prinvol
           x1)
        (inductionOp _ p pv popol
           plinvol
           prinvol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpMedialQuasiGroupTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpMedialQuasiGroupTerm2 n
          A)
       (x2 : OpMedialQuasiGroupTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      ((x1 : OpMedialQuasiGroupTerm2 n
          A)
       (x2 : OpMedialQuasiGroupTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (linvOL2 x1 x2)) ->
      ((x1 : OpMedialQuasiGroupTerm2 n
          A)
       (x2 : OpMedialQuasiGroupTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (rinvOL2 x1 x2)) ->
      (x : OpMedialQuasiGroupTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 prinvol2 (v2
                                                            x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 prinvol2 (sing2
                                                            x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 prinvol2 (opOL2
                                                            x1
                                                            x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           prinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           prinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 prinvol2 (linvOL2
                                                            x1
                                                            x2) =
      plinvol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           prinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           prinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 prinvol2 (rinvOL2
                                                            x1
                                                            x2) =
      prinvol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           prinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           prinvol2
           x2)
    opL' :
      MedialQuasiGroupTerm ->
      MedialQuasiGroupTerm ->
      MedialQuasiGroupTerm
    opL' x1 x2 = opL x1 x2
    linvL' :
      MedialQuasiGroupTerm ->
      MedialQuasiGroupTerm ->
      MedialQuasiGroupTerm
    linvL' x1 x2 = linvL x1 x2
    rinvL' :
      MedialQuasiGroupTerm ->
      MedialQuasiGroupTerm ->
      MedialQuasiGroupTerm
    rinvL' x1 x2 = rinvL x1 x2
    stageB :
      MedialQuasiGroupTerm ->
      Staged MedialQuasiGroupTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (linvL x1 x2) =
      stage2 _ _ _ linvL'
        (codeLift2 _ _ _ linvL')
        (stageB x1)
        (stageB x2)
    stageB (rinvL x1 x2) =
      stage2 _ _ _ rinvL'
        (codeLift2 _ _ _ rinvL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClMedialQuasiGroupTerm A ->
      ClMedialQuasiGroupTerm A ->
      ClMedialQuasiGroupTerm A
    opCl' _ x1 x2 = opCl x1 x2
    linvCl' :
      (A : Set) ->
      ClMedialQuasiGroupTerm A ->
      ClMedialQuasiGroupTerm A ->
      ClMedialQuasiGroupTerm A
    linvCl' _ x1 x2 = linvCl x1 x2
    rinvCl' :
      (A : Set) ->
      ClMedialQuasiGroupTerm A ->
      ClMedialQuasiGroupTerm A ->
      ClMedialQuasiGroupTerm A
    rinvCl' _ x1 x2 = rinvCl x1 x2
    stageCl :
      (A : Set) ->
      ClMedialQuasiGroupTerm A ->
      Staged
        (ClMedialQuasiGroupTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (linvCl x1 x2) =
      stage2 _ _ _ (linvCl' _)
        (codeLift2 _ _ _ (linvCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (rinvCl x1 x2) =
      stage2 _ _ _ (rinvCl' _)
        (codeLift2 _ _ _ (rinvCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpMedialQuasiGroupTerm n ->
      OpMedialQuasiGroupTerm n ->
      OpMedialQuasiGroupTerm n
    opOL' _ x1 x2 = opOL x1 x2
    linvOL' :
      (n : Nat) ->
      OpMedialQuasiGroupTerm n ->
      OpMedialQuasiGroupTerm n ->
      OpMedialQuasiGroupTerm n
    linvOL' _ x1 x2 = linvOL x1 x2
    rinvOL' :
      (n : Nat) ->
      OpMedialQuasiGroupTerm n ->
      OpMedialQuasiGroupTerm n ->
      OpMedialQuasiGroupTerm n
    rinvOL' _ x1 x2 = rinvOL x1 x2
    stageOp :
      (n : Nat) ->
      OpMedialQuasiGroupTerm n ->
      Staged
        (OpMedialQuasiGroupTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (linvOL x1 x2) =
      stage2 _ _ _ (linvOL' _)
        (codeLift2 _ _ _ (linvOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (rinvOL x1 x2) =
      stage2 _ _ _ (rinvOL' _)
        (codeLift2 _ _ _ (rinvOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpMedialQuasiGroupTerm2 n A ->
      OpMedialQuasiGroupTerm2 n A ->
      OpMedialQuasiGroupTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    linvOL2' :
      (n : Nat) (A : Set) ->
      OpMedialQuasiGroupTerm2 n A ->
      OpMedialQuasiGroupTerm2 n A ->
      OpMedialQuasiGroupTerm2 n A
    linvOL2' _ _ x1 x2 =
      linvOL2 x1 x2
    rinvOL2' :
      (n : Nat) (A : Set) ->
      OpMedialQuasiGroupTerm2 n A ->
      OpMedialQuasiGroupTerm2 n A ->
      OpMedialQuasiGroupTerm2 n A
    rinvOL2' _ _ x1 x2 =
      rinvOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpMedialQuasiGroupTerm2 n A ->
      Staged
        (OpMedialQuasiGroupTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (linvOL2 x1 x2) =
      stage2 _ _ _ (linvOL2' _ _)
        (codeLift2 _ _ _ (linvOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (rinvOL2 x1 x2) =
      stage2 _ _ _ (rinvOL2' _ _)
        (codeLift2 _ _ _ (rinvOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record MedialQuasiGroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
        linvT :
          Repr A -> Repr A -> Repr A
        rinvT :
          Repr A -> Repr A -> Repr A
  
  module MeetSemilattice where
    record MeetSemilattice
      (A : Set) : Set where
      constructor MeetSemilatticeC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        idempotent_op :
          (x : A) -> op x x == x
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
    record MeetSemilatticeSig
      (AS : Set) : Set where
      constructor MeetSemilatticeSigSigC
      field
        opS : AS -> AS -> AS
    record MeetSemilatticeProd
      (AP : Set) : Set where
      constructor MeetSemilatticeProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        idempotent_opP :
          (xP : Prod AP AP) ->
          opP xP xP == xP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
    record MeetSemilatticeHom
      (A1 : Set) (A2 : Set)
      (Me1 : MeetSemilattice A1)
      (Me2 : MeetSemilattice A2) :
      Set where
      constructor MeetSemilatticeHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Me1 x1 x2) ==
            op Me2 (hom x1) (hom x2)
    record MeetSemilatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Me1 : MeetSemilattice A1)
      (Me2 : MeetSemilattice A2) :
      Set where
      constructor MeetSemilatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Me1 x1 x2)
            (op Me2 y1 y2)
    data MeetSemilatticeTerm
      : Set where
      opL :
        MeetSemilatticeTerm ->
        MeetSemilatticeTerm ->
        MeetSemilatticeTerm
    data ClMeetSemilatticeTerm
      (A : Set) : Set where
      sing :
        A -> ClMeetSemilatticeTerm A
      opCl :
        ClMeetSemilatticeTerm A ->
        ClMeetSemilatticeTerm A ->
        ClMeetSemilatticeTerm A
    data OpMeetSemilatticeTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpMeetSemilatticeTerm n
      opOL :
        OpMeetSemilatticeTerm n ->
        OpMeetSemilatticeTerm n ->
        OpMeetSemilatticeTerm n
    data OpMeetSemilatticeTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpMeetSemilatticeTerm2 n A
      sing2 :
        A -> OpMeetSemilatticeTerm2 n A
      opOL2 :
        OpMeetSemilatticeTerm2 n A ->
        OpMeetSemilatticeTerm2 n A ->
        OpMeetSemilatticeTerm2 n A
    simplifyB :
      MeetSemilatticeTerm ->
      MeetSemilatticeTerm
    simplifyB (opL x x) = x
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClMeetSemilatticeTerm A ->
      ClMeetSemilatticeTerm A
    simplifyCl _ (opCl x x) = x
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpMeetSemilatticeTerm n ->
      OpMeetSemilatticeTerm n
    simplifyOp _ (opOL x x) = x
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpMeetSemilatticeTerm2 n A ->
      OpMeetSemilatticeTerm2 n A
    simplifyOpE _ _ (opOL2 x x) = x
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      MeetSemilattice A ->
      MeetSemilatticeTerm -> A
    evalB _ Me (opL x1 x2) =
      op Me (evalB _ Me x1)
        (evalB _ Me x2)
    evalCl :
      (A : Set) ->
      MeetSemilattice A ->
      ClMeetSemilatticeTerm A -> A
    evalCl _ Me (sing x1) = x1
    evalCl _ Me (opCl x1 x2) =
      op Me (evalCl _ Me x1)
        (evalCl _ Me x2)
    evalOp :
      (A : Set) (n : Nat) ->
      MeetSemilattice A ->
      Vec A n ->
      OpMeetSemilatticeTerm n -> A
    evalOp _ n Me vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Me vars (opOL
                        x1
                        x2) =
      op Me (evalOp _ n Me vars x1)
        (evalOp _ n Me vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      MeetSemilattice A ->
      Vec A n ->
      OpMeetSemilatticeTerm2 n A -> A
    evalOpE _ n Me vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Me vars (sing2 x1) =
      x1
    evalOpE _ n Me vars (opOL2
                         x1
                         x2) =
      op Me (evalOpE _ n Me vars x1)
        (evalOpE _ n Me vars x2)
    inductionB :
      (P : MeetSemilatticeTerm ->
           Set) ->
      ((x1 : MeetSemilatticeTerm)
       (x2 : MeetSemilatticeTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : MeetSemilatticeTerm) -> P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClMeetSemilatticeTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClMeetSemilatticeTerm A)
       (x2 : ClMeetSemilatticeTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClMeetSemilatticeTerm A) ->
      P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpMeetSemilatticeTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpMeetSemilatticeTerm n)
       (x2 : OpMeetSemilatticeTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpMeetSemilatticeTerm n) ->
      P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpMeetSemilatticeTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpMeetSemilatticeTerm2 n
          A)
       (x2 : OpMeetSemilatticeTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpMeetSemilatticeTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      MeetSemilatticeTerm ->
      MeetSemilatticeTerm ->
      MeetSemilatticeTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      MeetSemilatticeTerm ->
      Staged MeetSemilatticeTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClMeetSemilatticeTerm A ->
      ClMeetSemilatticeTerm A ->
      ClMeetSemilatticeTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClMeetSemilatticeTerm A ->
      Staged (ClMeetSemilatticeTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpMeetSemilatticeTerm n ->
      OpMeetSemilatticeTerm n ->
      OpMeetSemilatticeTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpMeetSemilatticeTerm n ->
      Staged (OpMeetSemilatticeTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpMeetSemilatticeTerm2 n A ->
      OpMeetSemilatticeTerm2 n A ->
      OpMeetSemilatticeTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpMeetSemilatticeTerm2 n A ->
      Staged
        (OpMeetSemilatticeTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record MeetSemilatticeTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module MiddleAbsorption where
    record MiddleAbsorption
      (A : Set) : Set where
      constructor MiddleAbsorptionC
      field
        op : A -> A -> A
        middleAbsorb_* :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x z
    record MiddleAbsorptionSig
      (AS : Set) : Set where
      constructor MiddleAbsorptionSigSigC
      field
        opS : AS -> AS -> AS
    record MiddleAbsorptionProd
      (AP : Set) : Set where
      constructor MiddleAbsorptionProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        middleAbsorb_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP == opP xP zP
    record MiddleAbsorptionHom
      (A1 : Set) (A2 : Set)
      (Mi1 : MiddleAbsorption A1)
      (Mi2 : MiddleAbsorption A2) :
      Set where
      constructor MiddleAbsorptionHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mi1 x1 x2) ==
            op Mi2 (hom x1) (hom x2)
    record MiddleAbsorptionRelInterp
      (A1 : Set) (A2 : Set)
      (Mi1 : MiddleAbsorption A1)
      (Mi2 : MiddleAbsorption A2) :
      Set where
      constructor MiddleAbsorptionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mi1 x1 x2)
            (op Mi2 y1 y2)
    data MiddleAbsorptionTerm
      : Set where
      opL :
        MiddleAbsorptionTerm ->
        MiddleAbsorptionTerm ->
        MiddleAbsorptionTerm
    data ClMiddleAbsorptionTerm
      (A : Set) : Set where
      sing :
        A -> ClMiddleAbsorptionTerm A
      opCl :
        ClMiddleAbsorptionTerm A ->
        ClMiddleAbsorptionTerm A ->
        ClMiddleAbsorptionTerm A
    data OpMiddleAbsorptionTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpMiddleAbsorptionTerm n
      opOL :
        OpMiddleAbsorptionTerm n ->
        OpMiddleAbsorptionTerm n ->
        OpMiddleAbsorptionTerm n
    data OpMiddleAbsorptionTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpMiddleAbsorptionTerm2 n A
      sing2 :
        A -> OpMiddleAbsorptionTerm2 n A
      opOL2 :
        OpMiddleAbsorptionTerm2 n A ->
        OpMiddleAbsorptionTerm2 n A ->
        OpMiddleAbsorptionTerm2 n A
    simplifyB :
      MiddleAbsorptionTerm ->
      MiddleAbsorptionTerm
    simplifyB (opL (opL x y) z) =
      opL x z
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClMiddleAbsorptionTerm A ->
      ClMiddleAbsorptionTerm A
    simplifyCl _ (opCl
                  (opCl x y)
                  z) = opCl x z
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpMiddleAbsorptionTerm n ->
      OpMiddleAbsorptionTerm n
    simplifyOp _ (opOL
                  (opOL x y)
                  z) = opOL x z
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpMiddleAbsorptionTerm2 n A ->
      OpMiddleAbsorptionTerm2 n A
    simplifyOpE _ _ (opOL2
                     (opOL2 x y)
                     z) = opOL2 x z
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      MiddleAbsorption A ->
      MiddleAbsorptionTerm -> A
    evalB _ Mi (opL x1 x2) =
      op Mi (evalB _ Mi x1)
        (evalB _ Mi x2)
    evalCl :
      (A : Set) ->
      MiddleAbsorption A ->
      ClMiddleAbsorptionTerm A -> A
    evalCl _ Mi (sing x1) = x1
    evalCl _ Mi (opCl x1 x2) =
      op Mi (evalCl _ Mi x1)
        (evalCl _ Mi x2)
    evalOp :
      (A : Set) (n : Nat) ->
      MiddleAbsorption A ->
      Vec A n ->
      OpMiddleAbsorptionTerm n -> A
    evalOp _ n Mi vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Mi vars (opOL
                        x1
                        x2) =
      op Mi (evalOp _ n Mi vars x1)
        (evalOp _ n Mi vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      MiddleAbsorption A ->
      Vec A n ->
      OpMiddleAbsorptionTerm2 n A -> A
    evalOpE _ n Mi vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Mi vars (sing2 x1) =
      x1
    evalOpE _ n Mi vars (opOL2
                         x1
                         x2) =
      op Mi (evalOpE _ n Mi vars x1)
        (evalOpE _ n Mi vars x2)
    inductionB :
      (P : MiddleAbsorptionTerm ->
           Set) ->
      ((x1 : MiddleAbsorptionTerm)
       (x2 : MiddleAbsorptionTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : MiddleAbsorptionTerm) ->
      P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClMiddleAbsorptionTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClMiddleAbsorptionTerm A)
       (x2 : ClMiddleAbsorptionTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClMiddleAbsorptionTerm
         A) -> P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpMiddleAbsorptionTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpMiddleAbsorptionTerm n)
       (x2 : OpMiddleAbsorptionTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpMiddleAbsorptionTerm
         n) -> P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpMiddleAbsorptionTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpMiddleAbsorptionTerm2 n
          A)
       (x2 : OpMiddleAbsorptionTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpMiddleAbsorptionTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      MiddleAbsorptionTerm ->
      MiddleAbsorptionTerm ->
      MiddleAbsorptionTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      MiddleAbsorptionTerm ->
      Staged MiddleAbsorptionTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClMiddleAbsorptionTerm A ->
      ClMiddleAbsorptionTerm A ->
      ClMiddleAbsorptionTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClMiddleAbsorptionTerm A ->
      Staged
        (ClMiddleAbsorptionTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpMiddleAbsorptionTerm n ->
      OpMiddleAbsorptionTerm n ->
      OpMiddleAbsorptionTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpMiddleAbsorptionTerm n ->
      Staged
        (OpMiddleAbsorptionTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpMiddleAbsorptionTerm2 n A ->
      OpMiddleAbsorptionTerm2 n A ->
      OpMiddleAbsorptionTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpMiddleAbsorptionTerm2 n A ->
      Staged
        (OpMiddleAbsorptionTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record MiddleAbsorptionTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module MiddleCommute where
    record MiddleCommute
      (A : Set) : Set where
      constructor MiddleCommuteC
      field
        op : A -> A -> A
        middleCommute_* :
          (x : A) (y : A) (z : A) ->
          op (op (op x y) z) x ==
            op (op (op x z) y) x
    record MiddleCommuteSig
      (AS : Set) : Set where
      constructor MiddleCommuteSigSigC
      field
        opS : AS -> AS -> AS
    record MiddleCommuteProd
      (AP : Set) : Set where
      constructor MiddleCommuteProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        middleCommute_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP (opP xP yP) zP) xP ==
            opP (opP (opP xP zP) yP) xP
    record MiddleCommuteHom
      (A1 : Set) (A2 : Set)
      (Mi1 : MiddleCommute A1)
      (Mi2 : MiddleCommute A2) :
      Set where
      constructor MiddleCommuteHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mi1 x1 x2) ==
            op Mi2 (hom x1) (hom x2)
    record MiddleCommuteRelInterp
      (A1 : Set) (A2 : Set)
      (Mi1 : MiddleCommute A1)
      (Mi2 : MiddleCommute A2) :
      Set where
      constructor MiddleCommuteRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mi1 x1 x2)
            (op Mi2 y1 y2)
    data MiddleCommuteTerm
      : Set where
      opL :
        MiddleCommuteTerm ->
        MiddleCommuteTerm ->
        MiddleCommuteTerm
    data ClMiddleCommuteTerm
      (A : Set) : Set where
      sing :
        A -> ClMiddleCommuteTerm A
      opCl :
        ClMiddleCommuteTerm A ->
        ClMiddleCommuteTerm A ->
        ClMiddleCommuteTerm A
    data OpMiddleCommuteTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpMiddleCommuteTerm n
      opOL :
        OpMiddleCommuteTerm n ->
        OpMiddleCommuteTerm n ->
        OpMiddleCommuteTerm n
    data OpMiddleCommuteTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpMiddleCommuteTerm2 n A
      sing2 :
        A -> OpMiddleCommuteTerm2 n A
      opOL2 :
        OpMiddleCommuteTerm2 n A ->
        OpMiddleCommuteTerm2 n A ->
        OpMiddleCommuteTerm2 n A
    simplifyB :
      MiddleCommuteTerm ->
      MiddleCommuteTerm
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClMiddleCommuteTerm A ->
      ClMiddleCommuteTerm A
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpMiddleCommuteTerm n ->
      OpMiddleCommuteTerm n
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpMiddleCommuteTerm2 n A ->
      OpMiddleCommuteTerm2 n A
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      MiddleCommute A ->
      MiddleCommuteTerm -> A
    evalB _ Mi (opL x1 x2) =
      op Mi (evalB _ Mi x1)
        (evalB _ Mi x2)
    evalCl :
      (A : Set) ->
      MiddleCommute A ->
      ClMiddleCommuteTerm A -> A
    evalCl _ Mi (sing x1) = x1
    evalCl _ Mi (opCl x1 x2) =
      op Mi (evalCl _ Mi x1)
        (evalCl _ Mi x2)
    evalOp :
      (A : Set) (n : Nat) ->
      MiddleCommute A ->
      Vec A n ->
      OpMiddleCommuteTerm n -> A
    evalOp _ n Mi vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Mi vars (opOL
                        x1
                        x2) =
      op Mi (evalOp _ n Mi vars x1)
        (evalOp _ n Mi vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      MiddleCommute A ->
      Vec A n ->
      OpMiddleCommuteTerm2 n A -> A
    evalOpE _ n Mi vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Mi vars (sing2 x1) =
      x1
    evalOpE _ n Mi vars (opOL2
                         x1
                         x2) =
      op Mi (evalOpE _ n Mi vars x1)
        (evalOpE _ n Mi vars x2)
    inductionB :
      (P : MiddleCommuteTerm ->
           Set) ->
      ((x1 : MiddleCommuteTerm)
       (x2 : MiddleCommuteTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : MiddleCommuteTerm) -> P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClMiddleCommuteTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClMiddleCommuteTerm A)
       (x2 : ClMiddleCommuteTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClMiddleCommuteTerm A) ->
      P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpMiddleCommuteTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpMiddleCommuteTerm n)
       (x2 : OpMiddleCommuteTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpMiddleCommuteTerm n) ->
      P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpMiddleCommuteTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpMiddleCommuteTerm2 n A)
       (x2 : OpMiddleCommuteTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpMiddleCommuteTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      MiddleCommuteTerm ->
      MiddleCommuteTerm ->
      MiddleCommuteTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      MiddleCommuteTerm ->
      Staged MiddleCommuteTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClMiddleCommuteTerm A ->
      ClMiddleCommuteTerm A ->
      ClMiddleCommuteTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClMiddleCommuteTerm A ->
      Staged (ClMiddleCommuteTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpMiddleCommuteTerm n ->
      OpMiddleCommuteTerm n ->
      OpMiddleCommuteTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpMiddleCommuteTerm n ->
      Staged (OpMiddleCommuteTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpMiddleCommuteTerm2 n A ->
      OpMiddleCommuteTerm2 n A ->
      OpMiddleCommuteTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpMiddleCommuteTerm2 n A ->
      Staged
        (OpMiddleCommuteTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record MiddleCommuteTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module ModularLattice where
    record ModularLattice
      (A : Set) : Set where
      constructor ModularLatticeC
      field
        * : A -> A -> A
        + : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        idempotent_+ :
          (x : A) -> + x x == x
        leftAbsorp_*_+ :
          (x : A) (y : A) ->
          * x (+ x y) == x
        leftAbsorp_+_* :
          (x : A) (y : A) ->
          + x (* x y) == x
        leftModular_*_+ :
          (x : A) (y : A) (z : A) ->
          + (* x y) (* x z) ==
            * x (+ y (* x z))
    record ModularLatticeSig
      (AS : Set) : Set where
      constructor ModularLatticeSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record ModularLatticeProd
      (AP : Set) : Set where
      constructor ModularLatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        idempotent_+P :
          (xP : Prod AP AP) ->
          +P xP xP == xP
        leftAbsorp_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP (+P xP yP) == xP
        leftAbsorp_+_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP (*P xP yP) == xP
        leftModular_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (*P xP yP) (*P xP zP) ==
            *P xP (+P yP (*P xP zP))
    record ModularLatticeHom
      (A1 : Set) (A2 : Set)
      (Mo1 : ModularLattice A1)
      (Mo2 : ModularLattice A2) :
      Set where
      constructor ModularLatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mo1 x1 x2) ==
            * Mo2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Mo1 x1 x2) ==
            + Mo2 (hom x1) (hom x2)
    record ModularLatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : ModularLattice A1)
      (Mo2 : ModularLattice A2) :
      Set where
      constructor ModularLatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mo1 x1 x2)
            (* Mo2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Mo1 x1 x2)
            (+ Mo2 y1 y2)
    data ModularLatticeTerm
      : Set where
      *L :
        ModularLatticeTerm ->
        ModularLatticeTerm ->
        ModularLatticeTerm
      +L :
        ModularLatticeTerm ->
        ModularLatticeTerm ->
        ModularLatticeTerm
    data ClModularLatticeTerm
      (A : Set) : Set where
      sing :
        A -> ClModularLatticeTerm A
      *Cl :
        ClModularLatticeTerm A ->
        ClModularLatticeTerm A ->
        ClModularLatticeTerm A
      +Cl :
        ClModularLatticeTerm A ->
        ClModularLatticeTerm A ->
        ClModularLatticeTerm A
    data OpModularLatticeTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpModularLatticeTerm n
      *OL :
        OpModularLatticeTerm n ->
        OpModularLatticeTerm n ->
        OpModularLatticeTerm n
      +OL :
        OpModularLatticeTerm n ->
        OpModularLatticeTerm n ->
        OpModularLatticeTerm n
    data OpModularLatticeTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpModularLatticeTerm2 n A
      sing2 :
        A -> OpModularLatticeTerm2 n A
      *OL2 :
        OpModularLatticeTerm2 n A ->
        OpModularLatticeTerm2 n A ->
        OpModularLatticeTerm2 n A
      +OL2 :
        OpModularLatticeTerm2 n A ->
        OpModularLatticeTerm2 n A ->
        OpModularLatticeTerm2 n A
    simplifyB :
      ModularLatticeTerm ->
      ModularLatticeTerm
    simplifyB (*L x x) = x
    simplifyB (+L x x) = x
    simplifyB (*L x (+L x y)) = x
    simplifyB (+L x (*L x y)) = x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClModularLatticeTerm A ->
      ClModularLatticeTerm A
    simplifyCl _ (*Cl x x) = x
    simplifyCl _ (+Cl x x) = x
    simplifyCl _ (*Cl x (+Cl x y)) =
      x
    simplifyCl _ (+Cl x (*Cl x y)) =
      x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpModularLatticeTerm n ->
      OpModularLatticeTerm n
    simplifyOp _ (*OL x x) = x
    simplifyOp _ (+OL x x) = x
    simplifyOp _ (*OL x (+OL x y)) =
      x
    simplifyOp _ (+OL x (*OL x y)) =
      x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpModularLatticeTerm2 n A ->
      OpModularLatticeTerm2 n A
    simplifyOpE _ _ (*OL2 x x) = x
    simplifyOpE _ _ (+OL2 x x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (+OL2 x y)) = x
    simplifyOpE _ _ (+OL2
                     x
                     (*OL2 x y)) = x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      ModularLattice A ->
      ModularLatticeTerm -> A
    evalB _ Mo (*L x1 x2) =
      * Mo (evalB _ Mo x1)
        (evalB _ Mo x2)
    evalB _ Mo (+L x1 x2) =
      + Mo (evalB _ Mo x1)
        (evalB _ Mo x2)
    evalCl :
      (A : Set) ->
      ModularLattice A ->
      ClModularLatticeTerm A -> A
    evalCl _ Mo (sing x1) = x1
    evalCl _ Mo (*Cl x1 x2) =
      * Mo (evalCl _ Mo x1)
        (evalCl _ Mo x2)
    evalCl _ Mo (+Cl x1 x2) =
      + Mo (evalCl _ Mo x1)
        (evalCl _ Mo x2)
    evalOp :
      (A : Set) (n : Nat) ->
      ModularLattice A ->
      Vec A n ->
      OpModularLatticeTerm n -> A
    evalOp _ n Mo vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Mo vars (*OL x1 x2) =
      * Mo (evalOp _ n Mo vars x1)
        (evalOp _ n Mo vars x2)
    evalOp _ n Mo vars (+OL x1 x2) =
      + Mo (evalOp _ n Mo vars x1)
        (evalOp _ n Mo vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      ModularLattice A ->
      Vec A n ->
      OpModularLatticeTerm2 n A -> A
    evalOpE _ n Mo vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Mo vars (sing2 x1) =
      x1
    evalOpE _ n Mo vars (*OL2
                         x1
                         x2) =
      * Mo (evalOpE _ n Mo vars x1)
        (evalOpE _ n Mo vars x2)
    evalOpE _ n Mo vars (+OL2
                         x1
                         x2) =
      + Mo (evalOpE _ n Mo vars x1)
        (evalOpE _ n Mo vars x2)
    inductionB :
      (P : ModularLatticeTerm ->
           Set) ->
      ((x1 : ModularLatticeTerm)
       (x2 : ModularLatticeTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : ModularLatticeTerm)
       (x2 : ModularLatticeTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : ModularLatticeTerm) -> P x
    inductionB p p*l p+l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionB p p*l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClModularLatticeTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClModularLatticeTerm A)
       (x2 : ClModularLatticeTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClModularLatticeTerm A)
       (x2 : ClModularLatticeTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClModularLatticeTerm A) ->
      P x
    inductionCl _ p psing p*cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p*cl p+cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionCl _ p psing p*cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpModularLatticeTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpModularLatticeTerm n)
       (x2 : OpModularLatticeTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpModularLatticeTerm n)
       (x2 : OpModularLatticeTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpModularLatticeTerm n) ->
      P x
    inductionOp _ p pv p*ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p*ol p+ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOp _ p pv p*ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpModularLatticeTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpModularLatticeTerm2 n
          A)
       (x2 : OpModularLatticeTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpModularLatticeTerm2 n
          A)
       (x2 : OpModularLatticeTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpModularLatticeTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    *L' :
      ModularLatticeTerm ->
      ModularLatticeTerm ->
      ModularLatticeTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      ModularLatticeTerm ->
      ModularLatticeTerm ->
      ModularLatticeTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      ModularLatticeTerm ->
      Staged ModularLatticeTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClModularLatticeTerm A ->
      ClModularLatticeTerm A ->
      ClModularLatticeTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClModularLatticeTerm A ->
      ClModularLatticeTerm A ->
      ClModularLatticeTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClModularLatticeTerm A ->
      Staged (ClModularLatticeTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpModularLatticeTerm n ->
      OpModularLatticeTerm n ->
      OpModularLatticeTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpModularLatticeTerm n ->
      OpModularLatticeTerm n ->
      OpModularLatticeTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpModularLatticeTerm n ->
      Staged (OpModularLatticeTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpModularLatticeTerm2 n A ->
      OpModularLatticeTerm2 n A ->
      OpModularLatticeTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpModularLatticeTerm2 n A ->
      OpModularLatticeTerm2 n A ->
      OpModularLatticeTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpModularLatticeTerm2 n A ->
      Staged
        (OpModularLatticeTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record ModularLatticeTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module Modularity where
    record Modularity
      (A : Set) : Set where
      constructor ModularityC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftModular_*_+ :
          (x : A) (y : A) (z : A) ->
          + (* x y) (* x z) ==
            * x (+ y (* x z))
    record ModularitySig
      (AS : Set) : Set where
      constructor ModularitySigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record ModularityProd
      (AP : Set) : Set where
      constructor ModularityProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftModular_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (*P xP yP) (*P xP zP) ==
            *P xP (+P yP (*P xP zP))
    record ModularityHom
      (A1 : Set) (A2 : Set)
      (Mo1 : Modularity A1)
      (Mo2 : Modularity A2) :
      Set where
      constructor ModularityHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mo1 x1 x2) ==
            * Mo2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Mo1 x1 x2) ==
            + Mo2 (hom x1) (hom x2)
    record ModularityRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : Modularity A1)
      (Mo2 : Modularity A2) :
      Set where
      constructor ModularityRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mo1 x1 x2)
            (* Mo2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Mo1 x1 x2)
            (+ Mo2 y1 y2)
    data ModularityTerm : Set where
      *L :
        ModularityTerm ->
        ModularityTerm -> ModularityTerm
      +L :
        ModularityTerm ->
        ModularityTerm -> ModularityTerm
    data ClModularityTerm
      (A : Set) : Set where
      sing : A -> ClModularityTerm A
      *Cl :
        ClModularityTerm A ->
        ClModularityTerm A ->
        ClModularityTerm A
      +Cl :
        ClModularityTerm A ->
        ClModularityTerm A ->
        ClModularityTerm A
    data OpModularityTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpModularityTerm n
      *OL :
        OpModularityTerm n ->
        OpModularityTerm n ->
        OpModularityTerm n
      +OL :
        OpModularityTerm n ->
        OpModularityTerm n ->
        OpModularityTerm n
    data OpModularityTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpModularityTerm2 n A
      sing2 :
        A -> OpModularityTerm2 n A
      *OL2 :
        OpModularityTerm2 n A ->
        OpModularityTerm2 n A ->
        OpModularityTerm2 n A
      +OL2 :
        OpModularityTerm2 n A ->
        OpModularityTerm2 n A ->
        OpModularityTerm2 n A
    simplifyB :
      ModularityTerm -> ModularityTerm
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClModularityTerm A ->
      ClModularityTerm A
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpModularityTerm n ->
      OpModularityTerm n
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpModularityTerm2 n A ->
      OpModularityTerm2 n A
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Modularity A ->
      ModularityTerm -> A
    evalB _ Mo (*L x1 x2) =
      * Mo (evalB _ Mo x1)
        (evalB _ Mo x2)
    evalB _ Mo (+L x1 x2) =
      + Mo (evalB _ Mo x1)
        (evalB _ Mo x2)
    evalCl :
      (A : Set) ->
      Modularity A ->
      ClModularityTerm A -> A
    evalCl _ Mo (sing x1) = x1
    evalCl _ Mo (*Cl x1 x2) =
      * Mo (evalCl _ Mo x1)
        (evalCl _ Mo x2)
    evalCl _ Mo (+Cl x1 x2) =
      + Mo (evalCl _ Mo x1)
        (evalCl _ Mo x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Modularity A ->
      Vec A n ->
      OpModularityTerm n -> A
    evalOp _ n Mo vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Mo vars (*OL x1 x2) =
      * Mo (evalOp _ n Mo vars x1)
        (evalOp _ n Mo vars x2)
    evalOp _ n Mo vars (+OL x1 x2) =
      + Mo (evalOp _ n Mo vars x1)
        (evalOp _ n Mo vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Modularity A ->
      Vec A n ->
      OpModularityTerm2 n A -> A
    evalOpE _ n Mo vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Mo vars (sing2 x1) =
      x1
    evalOpE _ n Mo vars (*OL2
                         x1
                         x2) =
      * Mo (evalOpE _ n Mo vars x1)
        (evalOpE _ n Mo vars x2)
    evalOpE _ n Mo vars (+OL2
                         x1
                         x2) =
      + Mo (evalOpE _ n Mo vars x1)
        (evalOpE _ n Mo vars x2)
    inductionB :
      (P : ModularityTerm -> Set) ->
      ((x1 : ModularityTerm)
       (x2 : ModularityTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : ModularityTerm)
       (x2 : ModularityTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : ModularityTerm) -> P x
    inductionB p p*l p+l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionB p p*l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClModularityTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClModularityTerm A)
       (x2 : ClModularityTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClModularityTerm A)
       (x2 : ClModularityTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClModularityTerm A) -> P x
    inductionCl _ p psing p*cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p*cl p+cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionCl _ p psing p*cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpModularityTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpModularityTerm n)
       (x2 : OpModularityTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpModularityTerm n)
       (x2 : OpModularityTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpModularityTerm n) -> P x
    inductionOp _ p pv p*ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p*ol p+ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOp _ p pv p*ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpModularityTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpModularityTerm2 n A)
       (x2 : OpModularityTerm2 n A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpModularityTerm2 n A)
       (x2 : OpModularityTerm2 n A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpModularityTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    *L' :
      ModularityTerm ->
      ModularityTerm -> ModularityTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      ModularityTerm ->
      ModularityTerm -> ModularityTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      ModularityTerm ->
      Staged ModularityTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClModularityTerm A ->
      ClModularityTerm A ->
      ClModularityTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClModularityTerm A ->
      ClModularityTerm A ->
      ClModularityTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClModularityTerm A ->
      Staged (ClModularityTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpModularityTerm n ->
      OpModularityTerm n ->
      OpModularityTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpModularityTerm n ->
      OpModularityTerm n ->
      OpModularityTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpModularityTerm n ->
      Staged (OpModularityTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpModularityTerm2 n A ->
      OpModularityTerm2 n A ->
      OpModularityTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpModularityTerm2 n A ->
      OpModularityTerm2 n A ->
      OpModularityTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpModularityTerm2 n A ->
      Staged (OpModularityTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record ModularityTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module Monoid where
    record Monoid
      (A : Set) : Set where
      constructor MonoidC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record MonoidSig
      (AS : Set) : Set where
      constructor MonoidSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record MonoidProd
      (AP : Set) : Set where
      constructor MonoidProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record MonoidHom
      (A1 : Set) (A2 : Set)
      (Mo1 : Monoid A1)
      (Mo2 : Monoid A2) : Set where
      constructor MonoidHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Mo1) == e Mo2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mo1 x1 x2) ==
            op Mo2 (hom x1) (hom x2)
    record MonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : Monoid A1)
      (Mo2 : Monoid A2) : Set where
      constructor MonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Mo1) (e Mo2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mo1 x1 x2)
            (op Mo2 y1 y2)
    data MonoidTerm : Set where
      eL : MonoidTerm
      opL :
        MonoidTerm ->
        MonoidTerm -> MonoidTerm
    data ClMonoidTerm
      (A : Set) : Set where
      sing : A -> ClMonoidTerm A
      eCl : ClMonoidTerm A
      opCl :
        ClMonoidTerm A ->
        ClMonoidTerm A -> ClMonoidTerm A
    data OpMonoidTerm
      (n : Nat) : Set where
      v : Fin n -> OpMonoidTerm n
      eOL : OpMonoidTerm n
      opOL :
        OpMonoidTerm n ->
        OpMonoidTerm n -> OpMonoidTerm n
    data OpMonoidTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpMonoidTerm2 n A
      sing2 : A -> OpMonoidTerm2 n A
      eOL2 : OpMonoidTerm2 n A
      opOL2 :
        OpMonoidTerm2 n A ->
        OpMonoidTerm2 n A ->
        OpMonoidTerm2 n A
    simplifyB :
      MonoidTerm -> MonoidTerm
    simplifyB (opL (eL) x) = x
    simplifyB (opL x (eL)) = x
    simplifyB (eL) = eL
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClMonoidTerm A -> ClMonoidTerm A
    simplifyCl _ (opCl (eCl) x) = x
    simplifyCl _ (opCl x (eCl)) = x
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpMonoidTerm n -> OpMonoidTerm n
    simplifyOp _ (opOL (eOL) x) = x
    simplifyOp _ (opOL x (eOL)) = x
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpMonoidTerm2 n A ->
      OpMonoidTerm2 n A
    simplifyOpE _ _ (opOL2
                     (eOL2)
                     x) = x
    simplifyOpE _ _ (opOL2
                     x
                     (eOL2)) = x
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Monoid A -> MonoidTerm -> A
    evalB _ Mo (eL) = e Mo
    evalB _ Mo (opL x1 x2) =
      op Mo (evalB _ Mo x1)
        (evalB _ Mo x2)
    evalCl :
      (A : Set) ->
      Monoid A -> ClMonoidTerm A -> A
    evalCl _ Mo (sing x1) = x1
    evalCl _ Mo (eCl) = e Mo
    evalCl _ Mo (opCl x1 x2) =
      op Mo (evalCl _ Mo x1)
        (evalCl _ Mo x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Monoid A ->
      Vec A n -> OpMonoidTerm n -> A
    evalOp _ n Mo vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Mo vars (eOL) = e Mo
    evalOp _ n Mo vars (opOL
                        x1
                        x2) =
      op Mo (evalOp _ n Mo vars x1)
        (evalOp _ n Mo vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Monoid A ->
      Vec A n ->
      OpMonoidTerm2 n A -> A
    evalOpE _ n Mo vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Mo vars (sing2 x1) =
      x1
    evalOpE _ n Mo vars (eOL2) =
      e Mo
    evalOpE _ n Mo vars (opOL2
                         x1
                         x2) =
      op Mo (evalOpE _ n Mo vars x1)
        (evalOpE _ n Mo vars x2)
    inductionB :
      (P : MonoidTerm -> Set) ->
      P eL ->
      ((x1 : MonoidTerm)
       (x2 : MonoidTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : MonoidTerm) -> P x
    inductionB p pel popl (eL) = pel
    inductionB p pel popl (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p pel popl x1)
        (inductionB p pel popl x2)
    inductionCl :
      (A : Set)
      (P : ClMonoidTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P eCl ->
      ((x1 : ClMonoidTerm A)
       (x2 : ClMonoidTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClMonoidTerm A) -> P x
    inductionCl _ p psing pecl popcl (sing
                                      x1) = psing x1
    inductionCl _ p psing pecl popcl (eCl) =
      pecl
    inductionCl _ p psing pecl popcl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing pecl
           popcl
           x1)
        (inductionCl _ p psing pecl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpMonoidTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P eOL ->
      ((x1 : OpMonoidTerm n)
       (x2 : OpMonoidTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpMonoidTerm n) -> P x
    inductionOp _ p pv peol popol (v
                                   x1) = pv x1
    inductionOp _ p pv peol popol (eOL) =
      peol
    inductionOp _ p pv peol popol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv peol popol
           x1)
        (inductionOp _ p pv peol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpMonoidTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P eOL2 ->
      ((x1 : OpMonoidTerm2 n A)
       (x2 : OpMonoidTerm2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpMonoidTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x2)
    eL' : MonoidTerm
    eL' = eL
    opL' :
      MonoidTerm ->
      MonoidTerm -> MonoidTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      MonoidTerm -> Staged MonoidTerm
    stageB (eL) = Now eL
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    eCl' :
      (A : Set) -> ClMonoidTerm A
    eCl' _ = eCl
    opCl' :
      (A : Set) ->
      ClMonoidTerm A ->
      ClMonoidTerm A -> ClMonoidTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClMonoidTerm A ->
      Staged (ClMonoidTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (eCl) = Now eCl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    eOL' :
      (n : Nat) -> OpMonoidTerm n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      OpMonoidTerm n ->
      OpMonoidTerm n -> OpMonoidTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpMonoidTerm n ->
      Staged (OpMonoidTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (eOL) = Now eOL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    eOL2' :
      (n : Nat) (A : Set) ->
      OpMonoidTerm2 n A
    eOL2' _ _ = eOL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpMonoidTerm2 n A ->
      OpMonoidTerm2 n A ->
      OpMonoidTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpMonoidTerm2 n A ->
      Staged (OpMonoidTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record MonoidTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        eT : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module Monoid1 where
    record Monoid1
      (A : Set) : Set where
      constructor Monoid1C
      field
        1 : A
        op : A -> A -> A
        lunit_1 : (x : A) -> op 1 x == x
        runit_1 : (x : A) -> op x 1 == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record Monoid1Sig
      (AS : Set) : Set where
      constructor Monoid1SigSigC
      field
        1S : AS
        opS : AS -> AS -> AS
    record Monoid1Prod
      (AP : Set) : Set where
      constructor Monoid1ProdC
      field
        1P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          opP 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          opP xP 1P == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record Monoid1Hom
      (A1 : Set) (A2 : Set)
      (Mo1 : Monoid1 A1)
      (Mo2 : Monoid1 A2) : Set where
      constructor Monoid1HomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Mo1) == 1 Mo2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mo1 x1 x2) ==
            op Mo2 (hom x1) (hom x2)
    record Monoid1RelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : Monoid1 A1)
      (Mo2 : Monoid1 A2) : Set where
      constructor Monoid1RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Mo1) (1 Mo2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mo1 x1 x2)
            (op Mo2 y1 y2)
    data Monoid1LTerm : Set where
      1L : Monoid1LTerm
      opL :
        Monoid1LTerm ->
        Monoid1LTerm -> Monoid1LTerm
    data ClMonoid1ClTerm
      (A : Set) : Set where
      sing : A -> ClMonoid1ClTerm A
      1Cl : ClMonoid1ClTerm A
      opCl :
        ClMonoid1ClTerm A ->
        ClMonoid1ClTerm A ->
        ClMonoid1ClTerm A
    data OpMonoid1OLTerm
      (n : Nat) : Set where
      v : Fin n -> OpMonoid1OLTerm n
      1OL : OpMonoid1OLTerm n
      opOL :
        OpMonoid1OLTerm n ->
        OpMonoid1OLTerm n ->
        OpMonoid1OLTerm n
    data OpMonoid1OL2Term2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpMonoid1OL2Term2 n A
      sing2 :
        A -> OpMonoid1OL2Term2 n A
      1OL2 : OpMonoid1OL2Term2 n A
      opOL2 :
        OpMonoid1OL2Term2 n A ->
        OpMonoid1OL2Term2 n A ->
        OpMonoid1OL2Term2 n A
    simplifyB :
      Monoid1LTerm -> Monoid1LTerm
    simplifyB (opL (1L) x) = x
    simplifyB (opL x (1L)) = x
    simplifyB (1L) = 1L
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClMonoid1ClTerm A ->
      ClMonoid1ClTerm A
    simplifyCl _ (opCl (1Cl) x) = x
    simplifyCl _ (opCl x (1Cl)) = x
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpMonoid1OLTerm n ->
      OpMonoid1OLTerm n
    simplifyOp _ (opOL (1OL) x) = x
    simplifyOp _ (opOL x (1OL)) = x
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpMonoid1OL2Term2 n A ->
      OpMonoid1OL2Term2 n A
    simplifyOpE _ _ (opOL2
                     (1OL2)
                     x) = x
    simplifyOpE _ _ (opOL2
                     x
                     (1OL2)) = x
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Monoid1 A -> Monoid1LTerm -> A
    evalB _ Mo (1L) = 1 Mo
    evalB _ Mo (opL x1 x2) =
      op Mo (evalB _ Mo x1)
        (evalB _ Mo x2)
    evalCl :
      (A : Set) ->
      Monoid1 A ->
      ClMonoid1ClTerm A -> A
    evalCl _ Mo (sing x1) = x1
    evalCl _ Mo (1Cl) = 1 Mo
    evalCl _ Mo (opCl x1 x2) =
      op Mo (evalCl _ Mo x1)
        (evalCl _ Mo x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Monoid1 A ->
      Vec A n ->
      OpMonoid1OLTerm n -> A
    evalOp _ n Mo vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Mo vars (1OL) = 1 Mo
    evalOp _ n Mo vars (opOL
                        x1
                        x2) =
      op Mo (evalOp _ n Mo vars x1)
        (evalOp _ n Mo vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Monoid1 A ->
      Vec A n ->
      OpMonoid1OL2Term2 n A -> A
    evalOpE _ n Mo vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Mo vars (sing2 x1) =
      x1
    evalOpE _ n Mo vars (1OL2) =
      1 Mo
    evalOpE _ n Mo vars (opOL2
                         x1
                         x2) =
      op Mo (evalOpE _ n Mo vars x1)
        (evalOpE _ n Mo vars x2)
    inductionB :
      (P : Monoid1LTerm -> Set) ->
      P 1L ->
      ((x1 : Monoid1LTerm)
       (x2 : Monoid1LTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : Monoid1LTerm) -> P x
    inductionB p p1l popl (1L) = p1l
    inductionB p p1l popl (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p p1l popl x1)
        (inductionB p p1l popl x2)
    inductionCl :
      (A : Set)
      (P : ClMonoid1ClTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 1Cl ->
      ((x1 : ClMonoid1ClTerm A)
       (x2 : ClMonoid1ClTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClMonoid1ClTerm A) -> P x
    inductionCl _ p psing p1cl popcl (sing
                                      x1) = psing x1
    inductionCl _ p psing p1cl popcl (1Cl) =
      p1cl
    inductionCl _ p psing p1cl popcl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing p1cl
           popcl
           x1)
        (inductionCl _ p psing p1cl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpMonoid1OLTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 1OL ->
      ((x1 : OpMonoid1OLTerm n)
       (x2 : OpMonoid1OLTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpMonoid1OLTerm n) -> P x
    inductionOp _ p pv p1ol popol (v
                                   x1) = pv x1
    inductionOp _ p pv p1ol popol (1OL) =
      p1ol
    inductionOp _ p pv p1ol popol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv p1ol popol
           x1)
        (inductionOp _ p pv p1ol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpMonoid1OL2Term2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 1OL2 ->
      ((x1 : OpMonoid1OL2Term2 n A)
       (x2 : OpMonoid1OL2Term2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpMonoid1OL2Term2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p1ol2 popol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p1ol2 popol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p1ol2 popol2 (1OL2) =
      p1ol2
    inductionOpE _ _ p pv2 psing2 p1ol2 popol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p1ol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p1ol2
           popol2
           x2)
    1L' : Monoid1LTerm
    1L' = 1L
    opL' :
      Monoid1LTerm ->
      Monoid1LTerm -> Monoid1LTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      Monoid1LTerm ->
      Staged Monoid1LTerm
    stageB (1L) = Now 1L
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    1Cl' :
      (A : Set) -> ClMonoid1ClTerm A
    1Cl' _ = 1Cl
    opCl' :
      (A : Set) ->
      ClMonoid1ClTerm A ->
      ClMonoid1ClTerm A ->
      ClMonoid1ClTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClMonoid1ClTerm A ->
      Staged (ClMonoid1ClTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (1Cl) = Now 1Cl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    1OL' :
      (n : Nat) -> OpMonoid1OLTerm n
    1OL' _ = 1OL
    opOL' :
      (n : Nat) ->
      OpMonoid1OLTerm n ->
      OpMonoid1OLTerm n ->
      OpMonoid1OLTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpMonoid1OLTerm n ->
      Staged (OpMonoid1OLTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (1OL) = Now 1OL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    1OL2' :
      (n : Nat) (A : Set) ->
      OpMonoid1OL2Term2 n A
    1OL2' _ _ = 1OL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpMonoid1OL2Term2 n A ->
      OpMonoid1OL2Term2 n A ->
      OpMonoid1OL2Term2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpMonoid1OL2Term2 n A ->
      Staged (OpMonoid1OL2Term2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (1OL2) = Now 1OL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record Monoid1Tagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        1T : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module MoufangIdentity where
    record MoufangIdentity
      (A : Set) : Set where
      constructor MoufangIdentityC
      field
        op : A -> A -> A
        moufangId :
          (x : A) (y : A) (z : A) ->
          op (op z x) (op y z) ==
            op (op z (op x y)) z
    record MoufangIdentitySig
      (AS : Set) : Set where
      constructor MoufangIdentitySigSigC
      field
        opS : AS -> AS -> AS
    record MoufangIdentityProd
      (AP : Set) : Set where
      constructor MoufangIdentityProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        moufangIdP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP zP xP) (opP yP zP) ==
            opP (opP zP (opP xP yP)) zP
    record MoufangIdentityHom
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangIdentity A1)
      (Mo2 : MoufangIdentity A2) :
      Set where
      constructor MoufangIdentityHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mo1 x1 x2) ==
            op Mo2 (hom x1) (hom x2)
    record MoufangIdentityRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangIdentity A1)
      (Mo2 : MoufangIdentity A2) :
      Set where
      constructor MoufangIdentityRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mo1 x1 x2)
            (op Mo2 y1 y2)
    data MoufangIdentityTerm
      : Set where
      opL :
        MoufangIdentityTerm ->
        MoufangIdentityTerm ->
        MoufangIdentityTerm
    data ClMoufangIdentityTerm
      (A : Set) : Set where
      sing :
        A -> ClMoufangIdentityTerm A
      opCl :
        ClMoufangIdentityTerm A ->
        ClMoufangIdentityTerm A ->
        ClMoufangIdentityTerm A
    data OpMoufangIdentityTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpMoufangIdentityTerm n
      opOL :
        OpMoufangIdentityTerm n ->
        OpMoufangIdentityTerm n ->
        OpMoufangIdentityTerm n
    data OpMoufangIdentityTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpMoufangIdentityTerm2 n A
      sing2 :
        A -> OpMoufangIdentityTerm2 n A
      opOL2 :
        OpMoufangIdentityTerm2 n A ->
        OpMoufangIdentityTerm2 n A ->
        OpMoufangIdentityTerm2 n A
    simplifyB :
      MoufangIdentityTerm ->
      MoufangIdentityTerm
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClMoufangIdentityTerm A ->
      ClMoufangIdentityTerm A
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpMoufangIdentityTerm n ->
      OpMoufangIdentityTerm n
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpMoufangIdentityTerm2 n A ->
      OpMoufangIdentityTerm2 n A
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      MoufangIdentity A ->
      MoufangIdentityTerm -> A
    evalB _ Mo (opL x1 x2) =
      op Mo (evalB _ Mo x1)
        (evalB _ Mo x2)
    evalCl :
      (A : Set) ->
      MoufangIdentity A ->
      ClMoufangIdentityTerm A -> A
    evalCl _ Mo (sing x1) = x1
    evalCl _ Mo (opCl x1 x2) =
      op Mo (evalCl _ Mo x1)
        (evalCl _ Mo x2)
    evalOp :
      (A : Set) (n : Nat) ->
      MoufangIdentity A ->
      Vec A n ->
      OpMoufangIdentityTerm n -> A
    evalOp _ n Mo vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Mo vars (opOL
                        x1
                        x2) =
      op Mo (evalOp _ n Mo vars x1)
        (evalOp _ n Mo vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      MoufangIdentity A ->
      Vec A n ->
      OpMoufangIdentityTerm2 n A -> A
    evalOpE _ n Mo vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Mo vars (sing2 x1) =
      x1
    evalOpE _ n Mo vars (opOL2
                         x1
                         x2) =
      op Mo (evalOpE _ n Mo vars x1)
        (evalOpE _ n Mo vars x2)
    inductionB :
      (P : MoufangIdentityTerm ->
           Set) ->
      ((x1 : MoufangIdentityTerm)
       (x2 : MoufangIdentityTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : MoufangIdentityTerm) -> P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClMoufangIdentityTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClMoufangIdentityTerm A)
       (x2 : ClMoufangIdentityTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClMoufangIdentityTerm A) ->
      P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpMoufangIdentityTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpMoufangIdentityTerm n)
       (x2 : OpMoufangIdentityTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpMoufangIdentityTerm n) ->
      P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpMoufangIdentityTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpMoufangIdentityTerm2 n
          A)
       (x2 : OpMoufangIdentityTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpMoufangIdentityTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      MoufangIdentityTerm ->
      MoufangIdentityTerm ->
      MoufangIdentityTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      MoufangIdentityTerm ->
      Staged MoufangIdentityTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClMoufangIdentityTerm A ->
      ClMoufangIdentityTerm A ->
      ClMoufangIdentityTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClMoufangIdentityTerm A ->
      Staged (ClMoufangIdentityTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpMoufangIdentityTerm n ->
      OpMoufangIdentityTerm n ->
      OpMoufangIdentityTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpMoufangIdentityTerm n ->
      Staged (OpMoufangIdentityTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpMoufangIdentityTerm2 n A ->
      OpMoufangIdentityTerm2 n A ->
      OpMoufangIdentityTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpMoufangIdentityTerm2 n A ->
      Staged
        (OpMoufangIdentityTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record MoufangIdentityTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module MoufangLaw where
    record MoufangLaw
      (A : Set) : Set where
      constructor MoufangLawC
      field
        op : A -> A -> A
        moufangLaw :
          (e : A) (x : A) (y : A)
          (z : A) ->
          op y e == y ->
          op (op (op x y) z) x ==
            op x (op y (op (op e z) x))
    record MoufangLawSig
      (AS : Set) : Set where
      constructor MoufangLawSigSigC
      field
        opS : AS -> AS -> AS
    record MoufangLawProd
      (AP : Set) : Set where
      constructor MoufangLawProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        moufangLawP :
          (eP : Prod AP AP)
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP yP eP == yP ->
          opP (opP (opP xP yP) zP) xP ==
            opP xP
              (opP yP (opP (opP eP zP) xP))
    record MoufangLawHom
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangLaw A1)
      (Mo2 : MoufangLaw A2) :
      Set where
      constructor MoufangLawHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mo1 x1 x2) ==
            op Mo2 (hom x1) (hom x2)
    record MoufangLawRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangLaw A1)
      (Mo2 : MoufangLaw A2) :
      Set where
      constructor MoufangLawRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mo1 x1 x2)
            (op Mo2 y1 y2)
    data MoufangLawTerm : Set where
      opL :
        MoufangLawTerm ->
        MoufangLawTerm -> MoufangLawTerm
    data ClMoufangLawTerm
      (A : Set) : Set where
      sing : A -> ClMoufangLawTerm A
      opCl :
        ClMoufangLawTerm A ->
        ClMoufangLawTerm A ->
        ClMoufangLawTerm A
    data OpMoufangLawTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpMoufangLawTerm n
      opOL :
        OpMoufangLawTerm n ->
        OpMoufangLawTerm n ->
        OpMoufangLawTerm n
    data OpMoufangLawTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpMoufangLawTerm2 n A
      sing2 :
        A -> OpMoufangLawTerm2 n A
      opOL2 :
        OpMoufangLawTerm2 n A ->
        OpMoufangLawTerm2 n A ->
        OpMoufangLawTerm2 n A
    simplifyB :
      MoufangLawTerm -> MoufangLawTerm
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClMoufangLawTerm A ->
      ClMoufangLawTerm A
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpMoufangLawTerm n ->
      OpMoufangLawTerm n
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpMoufangLawTerm2 n A ->
      OpMoufangLawTerm2 n A
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      MoufangLaw A ->
      MoufangLawTerm -> A
    evalB _ Mo (opL x1 x2) =
      op Mo (evalB _ Mo x1)
        (evalB _ Mo x2)
    evalCl :
      (A : Set) ->
      MoufangLaw A ->
      ClMoufangLawTerm A -> A
    evalCl _ Mo (sing x1) = x1
    evalCl _ Mo (opCl x1 x2) =
      op Mo (evalCl _ Mo x1)
        (evalCl _ Mo x2)
    evalOp :
      (A : Set) (n : Nat) ->
      MoufangLaw A ->
      Vec A n ->
      OpMoufangLawTerm n -> A
    evalOp _ n Mo vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Mo vars (opOL
                        x1
                        x2) =
      op Mo (evalOp _ n Mo vars x1)
        (evalOp _ n Mo vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      MoufangLaw A ->
      Vec A n ->
      OpMoufangLawTerm2 n A -> A
    evalOpE _ n Mo vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Mo vars (sing2 x1) =
      x1
    evalOpE _ n Mo vars (opOL2
                         x1
                         x2) =
      op Mo (evalOpE _ n Mo vars x1)
        (evalOpE _ n Mo vars x2)
    inductionB :
      (P : MoufangLawTerm -> Set) ->
      ((x1 : MoufangLawTerm)
       (x2 : MoufangLawTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : MoufangLawTerm) -> P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClMoufangLawTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClMoufangLawTerm A)
       (x2 : ClMoufangLawTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClMoufangLawTerm A) -> P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpMoufangLawTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpMoufangLawTerm n)
       (x2 : OpMoufangLawTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpMoufangLawTerm n) -> P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpMoufangLawTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpMoufangLawTerm2 n A)
       (x2 : OpMoufangLawTerm2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpMoufangLawTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      MoufangLawTerm ->
      MoufangLawTerm -> MoufangLawTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      MoufangLawTerm ->
      Staged MoufangLawTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClMoufangLawTerm A ->
      ClMoufangLawTerm A ->
      ClMoufangLawTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClMoufangLawTerm A ->
      Staged (ClMoufangLawTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpMoufangLawTerm n ->
      OpMoufangLawTerm n ->
      OpMoufangLawTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpMoufangLawTerm n ->
      Staged (OpMoufangLawTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpMoufangLawTerm2 n A ->
      OpMoufangLawTerm2 n A ->
      OpMoufangLawTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpMoufangLawTerm2 n A ->
      Staged (OpMoufangLawTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record MoufangLawTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module MoufangLoop where
    record MoufangLoop
      (A : Set) : Set where
      constructor MoufangLoopC
      field
        op : A -> A -> A
        e : A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
        moufangId :
          (x : A) (y : A) (z : A) ->
          op (op z x) (op y z) ==
            op (op z (op x y)) z
    record MoufangLoopSig
      (AS : Set) : Set where
      constructor MoufangLoopSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
        linvS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record MoufangLoopProd
      (AP : Set) : Set where
      constructor MoufangLoopProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
        moufangIdP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP zP xP) (opP yP zP) ==
            opP (opP zP (opP xP yP)) zP
    record MoufangLoopHom
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangLoop A1)
      (Mo2 : MoufangLoop A2) :
      Set where
      constructor MoufangLoopHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mo1 x1 x2) ==
            op Mo2 (hom x1) (hom x2)
        pres-e : hom (e Mo1) == e Mo2
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Mo1 x1 x2) ==
            linv Mo2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Mo1 x1 x2) ==
            rinv Mo2 (hom x1) (hom x2)
    record MoufangLoopRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangLoop A1)
      (Mo2 : MoufangLoop A2) :
      Set where
      constructor MoufangLoopRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mo1 x1 x2)
            (op Mo2 y1 y2)
        interp-e :
          interp (e Mo1) (e Mo2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Mo1 x1 x2)
            (linv Mo2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Mo1 x1 x2)
            (rinv Mo2 y1 y2)
    data MoufangLoopLTerm
      : Set where
      opL :
        MoufangLoopLTerm ->
        MoufangLoopLTerm ->
        MoufangLoopLTerm
      eL : MoufangLoopLTerm
      linvL :
        MoufangLoopLTerm ->
        MoufangLoopLTerm ->
        MoufangLoopLTerm
      rinvL :
        MoufangLoopLTerm ->
        MoufangLoopLTerm ->
        MoufangLoopLTerm
    data ClMoufangLoopClTerm
      (A : Set) : Set where
      sing :
        A -> ClMoufangLoopClTerm A
      opCl :
        ClMoufangLoopClTerm A ->
        ClMoufangLoopClTerm A ->
        ClMoufangLoopClTerm A
      eCl : ClMoufangLoopClTerm A
      linvCl :
        ClMoufangLoopClTerm A ->
        ClMoufangLoopClTerm A ->
        ClMoufangLoopClTerm A
      rinvCl :
        ClMoufangLoopClTerm A ->
        ClMoufangLoopClTerm A ->
        ClMoufangLoopClTerm A
    data OpMoufangLoopOLTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpMoufangLoopOLTerm n
      opOL :
        OpMoufangLoopOLTerm n ->
        OpMoufangLoopOLTerm n ->
        OpMoufangLoopOLTerm n
      eOL : OpMoufangLoopOLTerm n
      linvOL :
        OpMoufangLoopOLTerm n ->
        OpMoufangLoopOLTerm n ->
        OpMoufangLoopOLTerm n
      rinvOL :
        OpMoufangLoopOLTerm n ->
        OpMoufangLoopOLTerm n ->
        OpMoufangLoopOLTerm n
    data OpMoufangLoopOL2Term2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpMoufangLoopOL2Term2 n A
      sing2 :
        A -> OpMoufangLoopOL2Term2 n A
      opOL2 :
        OpMoufangLoopOL2Term2 n A ->
        OpMoufangLoopOL2Term2 n A ->
        OpMoufangLoopOL2Term2 n A
      eOL2 : OpMoufangLoopOL2Term2 n A
      linvOL2 :
        OpMoufangLoopOL2Term2 n A ->
        OpMoufangLoopOL2Term2 n A ->
        OpMoufangLoopOL2Term2 n A
      rinvOL2 :
        OpMoufangLoopOL2Term2 n A ->
        OpMoufangLoopOL2Term2 n A ->
        OpMoufangLoopOL2Term2 n A
    simplifyB :
      MoufangLoopLTerm ->
      MoufangLoopLTerm
    simplifyB (opL (eL) x) = x
    simplifyB (opL x (eL)) = x
    simplifyB (opL x (linvL x y)) =
      y
    simplifyB (linvL x (opL x y)) =
      y
    simplifyB (opL (rinvL y x) x) =
      y
    simplifyB (rinvL (opL y x) x) =
      y
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (eL) = eL
    simplifyB (linvL x1 x2) =
      linvL (simplifyB x1)
        (simplifyB x2)
    simplifyB (rinvL x1 x2) =
      rinvL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClMoufangLoopClTerm A ->
      ClMoufangLoopClTerm A
    simplifyCl _ (opCl (eCl) x) = x
    simplifyCl _ (opCl x (eCl)) = x
    simplifyCl _ (opCl
                  x
                  (linvCl x y)) = y
    simplifyCl _ (linvCl
                  x
                  (opCl x y)) = y
    simplifyCl _ (opCl
                  (rinvCl y x)
                  x) = y
    simplifyCl _ (rinvCl
                  (opCl y x)
                  x) = y
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (linvCl x1 x2) =
      linvCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (rinvCl x1 x2) =
      rinvCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpMoufangLoopOLTerm n ->
      OpMoufangLoopOLTerm n
    simplifyOp _ (opOL (eOL) x) = x
    simplifyOp _ (opOL x (eOL)) = x
    simplifyOp _ (opOL
                  x
                  (linvOL x y)) = y
    simplifyOp _ (linvOL
                  x
                  (opOL x y)) = y
    simplifyOp _ (opOL
                  (rinvOL y x)
                  x) = y
    simplifyOp _ (rinvOL
                  (opOL y x)
                  x) = y
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (linvOL x1 x2) =
      linvOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (rinvOL x1 x2) =
      rinvOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpMoufangLoopOL2Term2 n A ->
      OpMoufangLoopOL2Term2 n A
    simplifyOpE _ _ (opOL2
                     (eOL2)
                     x) = x
    simplifyOpE _ _ (opOL2
                     x
                     (eOL2)) = x
    simplifyOpE _ _ (opOL2
                     x
                     (linvOL2 x y)) = y
    simplifyOpE _ _ (linvOL2
                     x
                     (opOL2 x y)) = y
    simplifyOpE _ _ (opOL2
                     (rinvOL2 y x)
                     x) = y
    simplifyOpE _ _ (rinvOL2
                     (opOL2 y x)
                     x) = y
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (linvOL2
                     x1
                     x2) =
      linvOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (rinvOL2
                     x1
                     x2) =
      rinvOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      MoufangLoop A ->
      MoufangLoopLTerm -> A
    evalB _ Mo (opL x1 x2) =
      op Mo (evalB _ Mo x1)
        (evalB _ Mo x2)
    evalB _ Mo (eL) = e Mo
    evalB _ Mo (linvL x1 x2) =
      linv Mo (evalB _ Mo x1)
        (evalB _ Mo x2)
    evalB _ Mo (rinvL x1 x2) =
      rinv Mo (evalB _ Mo x1)
        (evalB _ Mo x2)
    evalCl :
      (A : Set) ->
      MoufangLoop A ->
      ClMoufangLoopClTerm A -> A
    evalCl _ Mo (sing x1) = x1
    evalCl _ Mo (opCl x1 x2) =
      op Mo (evalCl _ Mo x1)
        (evalCl _ Mo x2)
    evalCl _ Mo (eCl) = e Mo
    evalCl _ Mo (linvCl x1 x2) =
      linv Mo (evalCl _ Mo x1)
        (evalCl _ Mo x2)
    evalCl _ Mo (rinvCl x1 x2) =
      rinv Mo (evalCl _ Mo x1)
        (evalCl _ Mo x2)
    evalOp :
      (A : Set) (n : Nat) ->
      MoufangLoop A ->
      Vec A n ->
      OpMoufangLoopOLTerm n -> A
    evalOp _ n Mo vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Mo vars (opOL
                        x1
                        x2) =
      op Mo (evalOp _ n Mo vars x1)
        (evalOp _ n Mo vars x2)
    evalOp _ n Mo vars (eOL) = e Mo
    evalOp _ n Mo vars (linvOL
                        x1
                        x2) =
      linv Mo (evalOp _ n Mo vars x1)
        (evalOp _ n Mo vars x2)
    evalOp _ n Mo vars (rinvOL
                        x1
                        x2) =
      rinv Mo (evalOp _ n Mo vars x1)
        (evalOp _ n Mo vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      MoufangLoop A ->
      Vec A n ->
      OpMoufangLoopOL2Term2 n A -> A
    evalOpE _ n Mo vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Mo vars (sing2 x1) =
      x1
    evalOpE _ n Mo vars (opOL2
                         x1
                         x2) =
      op Mo (evalOpE _ n Mo vars x1)
        (evalOpE _ n Mo vars x2)
    evalOpE _ n Mo vars (eOL2) =
      e Mo
    evalOpE _ n Mo vars (linvOL2
                         x1
                         x2) =
      linv Mo (evalOpE _ n Mo vars x1)
        (evalOpE _ n Mo vars x2)
    evalOpE _ n Mo vars (rinvOL2
                         x1
                         x2) =
      rinv Mo (evalOpE _ n Mo vars x1)
        (evalOpE _ n Mo vars x2)
    inductionB :
      (P : MoufangLoopLTerm -> Set) ->
      ((x1 : MoufangLoopLTerm)
       (x2 : MoufangLoopLTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      P eL ->
      ((x1 : MoufangLoopLTerm)
       (x2 : MoufangLoopLTerm) ->
       P x1 ->
       P x2 -> P (linvL x1 x2)) ->
      ((x1 : MoufangLoopLTerm)
       (x2 : MoufangLoopLTerm) ->
       P x1 ->
       P x2 -> P (rinvL x1 x2)) ->
      (x : MoufangLoopLTerm) -> P x
    inductionB p popl pel plinvl prinvl (opL
                                         x1
                                         x2) =
      popl _ _
        (inductionB p popl pel plinvl
           prinvl
           x1)
        (inductionB p popl pel plinvl
           prinvl
           x2)
    inductionB p popl pel plinvl prinvl (eL) =
      pel
    inductionB p popl pel plinvl prinvl (linvL
                                         x1
                                         x2) =
      plinvl _ _
        (inductionB p popl pel plinvl
           prinvl
           x1)
        (inductionB p popl pel plinvl
           prinvl
           x2)
    inductionB p popl pel plinvl prinvl (rinvL
                                         x1
                                         x2) =
      prinvl _ _
        (inductionB p popl pel plinvl
           prinvl
           x1)
        (inductionB p popl pel plinvl
           prinvl
           x2)
    inductionCl :
      (A : Set)
      (P : ClMoufangLoopClTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClMoufangLoopClTerm A)
       (x2 : ClMoufangLoopClTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      P eCl ->
      ((x1 : ClMoufangLoopClTerm A)
       (x2 : ClMoufangLoopClTerm A) ->
       P x1 ->
       P x2 -> P (linvCl x1 x2)) ->
      ((x1 : ClMoufangLoopClTerm A)
       (x2 : ClMoufangLoopClTerm A) ->
       P x1 ->
       P x2 -> P (rinvCl x1 x2)) ->
      (x : ClMoufangLoopClTerm A) ->
      P x
    inductionCl _ p psing popcl pecl plinvcl prinvcl (sing
                                                      x1) = psing x1
    inductionCl _ p psing popcl pecl plinvcl prinvcl (opCl
                                                      x1
                                                      x2) =
      popcl _ _
        (inductionCl _ p psing popcl
           pecl
           plinvcl
           prinvcl
           x1)
        (inductionCl _ p psing popcl
           pecl
           plinvcl
           prinvcl
           x2)
    inductionCl _ p psing popcl pecl plinvcl prinvcl (eCl) =
      pecl
    inductionCl _ p psing popcl pecl plinvcl prinvcl (linvCl
                                                      x1
                                                      x2) =
      plinvcl _ _
        (inductionCl _ p psing popcl
           pecl
           plinvcl
           prinvcl
           x1)
        (inductionCl _ p psing popcl
           pecl
           plinvcl
           prinvcl
           x2)
    inductionCl _ p psing popcl pecl plinvcl prinvcl (rinvCl
                                                      x1
                                                      x2) =
      prinvcl _ _
        (inductionCl _ p psing popcl
           pecl
           plinvcl
           prinvcl
           x1)
        (inductionCl _ p psing popcl
           pecl
           plinvcl
           prinvcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpMoufangLoopOLTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpMoufangLoopOLTerm n)
       (x2 : OpMoufangLoopOLTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      P eOL ->
      ((x1 : OpMoufangLoopOLTerm n)
       (x2 : OpMoufangLoopOLTerm n) ->
       P x1 ->
       P x2 -> P (linvOL x1 x2)) ->
      ((x1 : OpMoufangLoopOLTerm n)
       (x2 : OpMoufangLoopOLTerm n) ->
       P x1 ->
       P x2 -> P (rinvOL x1 x2)) ->
      (x : OpMoufangLoopOLTerm n) ->
      P x
    inductionOp _ p pv popol peol plinvol prinvol (v
                                                   x1) = pv x1
    inductionOp _ p pv popol peol plinvol prinvol (opOL
                                                   x1
                                                   x2) =
      popol _ _
        (inductionOp _ p pv popol peol
           plinvol
           prinvol
           x1)
        (inductionOp _ p pv popol peol
           plinvol
           prinvol
           x2)
    inductionOp _ p pv popol peol plinvol prinvol (eOL) =
      peol
    inductionOp _ p pv popol peol plinvol prinvol (linvOL
                                                   x1
                                                   x2) =
      plinvol _ _
        (inductionOp _ p pv popol peol
           plinvol
           prinvol
           x1)
        (inductionOp _ p pv popol peol
           plinvol
           prinvol
           x2)
    inductionOp _ p pv popol peol plinvol prinvol (rinvOL
                                                   x1
                                                   x2) =
      prinvol _ _
        (inductionOp _ p pv popol peol
           plinvol
           prinvol
           x1)
        (inductionOp _ p pv popol peol
           plinvol
           prinvol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpMoufangLoopOL2Term2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpMoufangLoopOL2Term2 n
          A)
       (x2 : OpMoufangLoopOL2Term2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      P eOL2 ->
      ((x1 : OpMoufangLoopOL2Term2 n
          A)
       (x2 : OpMoufangLoopOL2Term2 n
          A) ->
       P x1 ->
       P x2 -> P (linvOL2 x1 x2)) ->
      ((x1 : OpMoufangLoopOL2Term2 n
          A)
       (x2 : OpMoufangLoopOL2Term2 n
          A) ->
       P x1 ->
       P x2 -> P (rinvOL2 x1 x2)) ->
      (x : OpMoufangLoopOL2Term2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 peol2 plinvol2 prinvol2 (v2
                                                                  x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 peol2 plinvol2 prinvol2 (sing2
                                                                  x1) =
      psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 peol2 plinvol2 prinvol2 (opOL2
                                                                  x1
                                                                  x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           plinvol2
           prinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           plinvol2
           prinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 peol2 plinvol2 prinvol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 popol2 peol2 plinvol2 prinvol2 (linvOL2
                                                                  x1
                                                                  x2) =
      plinvol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           plinvol2
           prinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           plinvol2
           prinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 peol2 plinvol2 prinvol2 (rinvOL2
                                                                  x1
                                                                  x2) =
      prinvol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           plinvol2
           prinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           plinvol2
           prinvol2
           x2)
    opL' :
      MoufangLoopLTerm ->
      MoufangLoopLTerm ->
      MoufangLoopLTerm
    opL' x1 x2 = opL x1 x2
    eL' : MoufangLoopLTerm
    eL' = eL
    linvL' :
      MoufangLoopLTerm ->
      MoufangLoopLTerm ->
      MoufangLoopLTerm
    linvL' x1 x2 = linvL x1 x2
    rinvL' :
      MoufangLoopLTerm ->
      MoufangLoopLTerm ->
      MoufangLoopLTerm
    rinvL' x1 x2 = rinvL x1 x2
    stageB :
      MoufangLoopLTerm ->
      Staged MoufangLoopLTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (eL) = Now eL
    stageB (linvL x1 x2) =
      stage2 _ _ _ linvL'
        (codeLift2 _ _ _ linvL')
        (stageB x1)
        (stageB x2)
    stageB (rinvL x1 x2) =
      stage2 _ _ _ rinvL'
        (codeLift2 _ _ _ rinvL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClMoufangLoopClTerm A ->
      ClMoufangLoopClTerm A ->
      ClMoufangLoopClTerm A
    opCl' _ x1 x2 = opCl x1 x2
    eCl' :
      (A : Set) ->
      ClMoufangLoopClTerm A
    eCl' _ = eCl
    linvCl' :
      (A : Set) ->
      ClMoufangLoopClTerm A ->
      ClMoufangLoopClTerm A ->
      ClMoufangLoopClTerm A
    linvCl' _ x1 x2 = linvCl x1 x2
    rinvCl' :
      (A : Set) ->
      ClMoufangLoopClTerm A ->
      ClMoufangLoopClTerm A ->
      ClMoufangLoopClTerm A
    rinvCl' _ x1 x2 = rinvCl x1 x2
    stageCl :
      (A : Set) ->
      ClMoufangLoopClTerm A ->
      Staged (ClMoufangLoopClTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (eCl) = Now eCl
    stageCl _ (linvCl x1 x2) =
      stage2 _ _ _ (linvCl' _)
        (codeLift2 _ _ _ (linvCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (rinvCl x1 x2) =
      stage2 _ _ _ (rinvCl' _)
        (codeLift2 _ _ _ (rinvCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpMoufangLoopOLTerm n ->
      OpMoufangLoopOLTerm n ->
      OpMoufangLoopOLTerm n
    opOL' _ x1 x2 = opOL x1 x2
    eOL' :
      (n : Nat) ->
      OpMoufangLoopOLTerm n
    eOL' _ = eOL
    linvOL' :
      (n : Nat) ->
      OpMoufangLoopOLTerm n ->
      OpMoufangLoopOLTerm n ->
      OpMoufangLoopOLTerm n
    linvOL' _ x1 x2 = linvOL x1 x2
    rinvOL' :
      (n : Nat) ->
      OpMoufangLoopOLTerm n ->
      OpMoufangLoopOLTerm n ->
      OpMoufangLoopOLTerm n
    rinvOL' _ x1 x2 = rinvOL x1 x2
    stageOp :
      (n : Nat) ->
      OpMoufangLoopOLTerm n ->
      Staged (OpMoufangLoopOLTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (eOL) = Now eOL
    stageOp _ (linvOL x1 x2) =
      stage2 _ _ _ (linvOL' _)
        (codeLift2 _ _ _ (linvOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (rinvOL x1 x2) =
      stage2 _ _ _ (rinvOL' _)
        (codeLift2 _ _ _ (rinvOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpMoufangLoopOL2Term2 n A ->
      OpMoufangLoopOL2Term2 n A ->
      OpMoufangLoopOL2Term2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    eOL2' :
      (n : Nat) (A : Set) ->
      OpMoufangLoopOL2Term2 n A
    eOL2' _ _ = eOL2
    linvOL2' :
      (n : Nat) (A : Set) ->
      OpMoufangLoopOL2Term2 n A ->
      OpMoufangLoopOL2Term2 n A ->
      OpMoufangLoopOL2Term2 n A
    linvOL2' _ _ x1 x2 =
      linvOL2 x1 x2
    rinvOL2' :
      (n : Nat) (A : Set) ->
      OpMoufangLoopOL2Term2 n A ->
      OpMoufangLoopOL2Term2 n A ->
      OpMoufangLoopOL2Term2 n A
    rinvOL2' _ _ x1 x2 =
      rinvOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpMoufangLoopOL2Term2 n A ->
      Staged
        (OpMoufangLoopOL2Term2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (linvOL2 x1 x2) =
      stage2 _ _ _ (linvOL2' _ _)
        (codeLift2 _ _ _ (linvOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (rinvOL2 x1 x2) =
      stage2 _ _ _ (rinvOL2' _ _)
        (codeLift2 _ _ _ (rinvOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record MoufangLoopTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
        eT : Repr A
        linvT :
          Repr A -> Repr A -> Repr A
        rinvT :
          Repr A -> Repr A -> Repr A
  
  module MoufangQuasiGroup where
    record MoufangQuasiGroup
      (A : Set) : Set where
      constructor MoufangQuasiGroupC
      field
        op : A -> A -> A
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
        moufangLaw :
          (e : A) (x : A) (y : A)
          (z : A) ->
          op y e == y ->
          op (op (op x y) z) x ==
            op x (op y (op (op e z) x))
    record MoufangQuasiGroupSig
      (AS : Set) : Set where
      constructor MoufangQuasiGroupSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record MoufangQuasiGroupProd
      (AP : Set) : Set where
      constructor MoufangQuasiGroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
        moufangLawP :
          (eP : Prod AP AP)
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP yP eP == yP ->
          opP (opP (opP xP yP) zP) xP ==
            opP xP
              (opP yP (opP (opP eP zP) xP))
    record MoufangQuasiGroupHom
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangQuasiGroup A1)
      (Mo2 : MoufangQuasiGroup A2) :
      Set where
      constructor MoufangQuasiGroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Mo1 x1 x2) ==
            op Mo2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Mo1 x1 x2) ==
            linv Mo2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Mo1 x1 x2) ==
            rinv Mo2 (hom x1) (hom x2)
    record MoufangQuasiGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Mo1 : MoufangQuasiGroup A1)
      (Mo2 : MoufangQuasiGroup A2) :
      Set where
      constructor MoufangQuasiGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Mo1 x1 x2)
            (op Mo2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Mo1 x1 x2)
            (linv Mo2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Mo1 x1 x2)
            (rinv Mo2 y1 y2)
    data MoufangQuasiGroupTerm
      : Set where
      opL :
        MoufangQuasiGroupTerm ->
        MoufangQuasiGroupTerm ->
        MoufangQuasiGroupTerm
      linvL :
        MoufangQuasiGroupTerm ->
        MoufangQuasiGroupTerm ->
        MoufangQuasiGroupTerm
      rinvL :
        MoufangQuasiGroupTerm ->
        MoufangQuasiGroupTerm ->
        MoufangQuasiGroupTerm
    data ClMoufangQuasiGroupTerm
      (A : Set) : Set where
      sing :
        A -> ClMoufangQuasiGroupTerm A
      opCl :
        ClMoufangQuasiGroupTerm A ->
        ClMoufangQuasiGroupTerm A ->
        ClMoufangQuasiGroupTerm A
      linvCl :
        ClMoufangQuasiGroupTerm A ->
        ClMoufangQuasiGroupTerm A ->
        ClMoufangQuasiGroupTerm A
      rinvCl :
        ClMoufangQuasiGroupTerm A ->
        ClMoufangQuasiGroupTerm A ->
        ClMoufangQuasiGroupTerm A
    data OpMoufangQuasiGroupTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpMoufangQuasiGroupTerm n
      opOL :
        OpMoufangQuasiGroupTerm n ->
        OpMoufangQuasiGroupTerm n ->
        OpMoufangQuasiGroupTerm n
      linvOL :
        OpMoufangQuasiGroupTerm n ->
        OpMoufangQuasiGroupTerm n ->
        OpMoufangQuasiGroupTerm n
      rinvOL :
        OpMoufangQuasiGroupTerm n ->
        OpMoufangQuasiGroupTerm n ->
        OpMoufangQuasiGroupTerm n
    data OpMoufangQuasiGroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpMoufangQuasiGroupTerm2 n A
      sing2 :
        A ->
        OpMoufangQuasiGroupTerm2 n A
      opOL2 :
        OpMoufangQuasiGroupTerm2 n A ->
        OpMoufangQuasiGroupTerm2 n A ->
        OpMoufangQuasiGroupTerm2 n A
      linvOL2 :
        OpMoufangQuasiGroupTerm2 n A ->
        OpMoufangQuasiGroupTerm2 n A ->
        OpMoufangQuasiGroupTerm2 n A
      rinvOL2 :
        OpMoufangQuasiGroupTerm2 n A ->
        OpMoufangQuasiGroupTerm2 n A ->
        OpMoufangQuasiGroupTerm2 n A
    simplifyB :
      MoufangQuasiGroupTerm ->
      MoufangQuasiGroupTerm
    simplifyB (opL x (linvL x y)) =
      y
    simplifyB (linvL x (opL x y)) =
      y
    simplifyB (opL (rinvL y x) x) =
      y
    simplifyB (rinvL (opL y x) x) =
      y
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (linvL x1 x2) =
      linvL (simplifyB x1)
        (simplifyB x2)
    simplifyB (rinvL x1 x2) =
      rinvL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClMoufangQuasiGroupTerm A ->
      ClMoufangQuasiGroupTerm A
    simplifyCl _ (opCl
                  x
                  (linvCl x y)) = y
    simplifyCl _ (linvCl
                  x
                  (opCl x y)) = y
    simplifyCl _ (opCl
                  (rinvCl y x)
                  x) = y
    simplifyCl _ (rinvCl
                  (opCl y x)
                  x) = y
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (linvCl x1 x2) =
      linvCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (rinvCl x1 x2) =
      rinvCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpMoufangQuasiGroupTerm n ->
      OpMoufangQuasiGroupTerm n
    simplifyOp _ (opOL
                  x
                  (linvOL x y)) = y
    simplifyOp _ (linvOL
                  x
                  (opOL x y)) = y
    simplifyOp _ (opOL
                  (rinvOL y x)
                  x) = y
    simplifyOp _ (rinvOL
                  (opOL y x)
                  x) = y
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (linvOL x1 x2) =
      linvOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (rinvOL x1 x2) =
      rinvOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpMoufangQuasiGroupTerm2 n A ->
      OpMoufangQuasiGroupTerm2 n A
    simplifyOpE _ _ (opOL2
                     x
                     (linvOL2 x y)) = y
    simplifyOpE _ _ (linvOL2
                     x
                     (opOL2 x y)) = y
    simplifyOpE _ _ (opOL2
                     (rinvOL2 y x)
                     x) = y
    simplifyOpE _ _ (rinvOL2
                     (opOL2 y x)
                     x) = y
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (linvOL2
                     x1
                     x2) =
      linvOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (rinvOL2
                     x1
                     x2) =
      rinvOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      MoufangQuasiGroup A ->
      MoufangQuasiGroupTerm -> A
    evalB _ Mo (opL x1 x2) =
      op Mo (evalB _ Mo x1)
        (evalB _ Mo x2)
    evalB _ Mo (linvL x1 x2) =
      linv Mo (evalB _ Mo x1)
        (evalB _ Mo x2)
    evalB _ Mo (rinvL x1 x2) =
      rinv Mo (evalB _ Mo x1)
        (evalB _ Mo x2)
    evalCl :
      (A : Set) ->
      MoufangQuasiGroup A ->
      ClMoufangQuasiGroupTerm A -> A
    evalCl _ Mo (sing x1) = x1
    evalCl _ Mo (opCl x1 x2) =
      op Mo (evalCl _ Mo x1)
        (evalCl _ Mo x2)
    evalCl _ Mo (linvCl x1 x2) =
      linv Mo (evalCl _ Mo x1)
        (evalCl _ Mo x2)
    evalCl _ Mo (rinvCl x1 x2) =
      rinv Mo (evalCl _ Mo x1)
        (evalCl _ Mo x2)
    evalOp :
      (A : Set) (n : Nat) ->
      MoufangQuasiGroup A ->
      Vec A n ->
      OpMoufangQuasiGroupTerm n -> A
    evalOp _ n Mo vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Mo vars (opOL
                        x1
                        x2) =
      op Mo (evalOp _ n Mo vars x1)
        (evalOp _ n Mo vars x2)
    evalOp _ n Mo vars (linvOL
                        x1
                        x2) =
      linv Mo (evalOp _ n Mo vars x1)
        (evalOp _ n Mo vars x2)
    evalOp _ n Mo vars (rinvOL
                        x1
                        x2) =
      rinv Mo (evalOp _ n Mo vars x1)
        (evalOp _ n Mo vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      MoufangQuasiGroup A ->
      Vec A n ->
      OpMoufangQuasiGroupTerm2 n A ->
      A
    evalOpE _ n Mo vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Mo vars (sing2 x1) =
      x1
    evalOpE _ n Mo vars (opOL2
                         x1
                         x2) =
      op Mo (evalOpE _ n Mo vars x1)
        (evalOpE _ n Mo vars x2)
    evalOpE _ n Mo vars (linvOL2
                         x1
                         x2) =
      linv Mo (evalOpE _ n Mo vars x1)
        (evalOpE _ n Mo vars x2)
    evalOpE _ n Mo vars (rinvOL2
                         x1
                         x2) =
      rinv Mo (evalOpE _ n Mo vars x1)
        (evalOpE _ n Mo vars x2)
    inductionB :
      (P : MoufangQuasiGroupTerm ->
           Set) ->
      ((x1 : MoufangQuasiGroupTerm)
       (x2 : MoufangQuasiGroupTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      ((x1 : MoufangQuasiGroupTerm)
       (x2 : MoufangQuasiGroupTerm) ->
       P x1 ->
       P x2 -> P (linvL x1 x2)) ->
      ((x1 : MoufangQuasiGroupTerm)
       (x2 : MoufangQuasiGroupTerm) ->
       P x1 ->
       P x2 -> P (rinvL x1 x2)) ->
      (x : MoufangQuasiGroupTerm) ->
      P x
    inductionB p popl plinvl prinvl (opL
                                     x1
                                     x2) =
      popl _ _
        (inductionB p popl plinvl prinvl
           x1)
        (inductionB p popl plinvl prinvl
           x2)
    inductionB p popl plinvl prinvl (linvL
                                     x1
                                     x2) =
      plinvl _ _
        (inductionB p popl plinvl prinvl
           x1)
        (inductionB p popl plinvl prinvl
           x2)
    inductionB p popl plinvl prinvl (rinvL
                                     x1
                                     x2) =
      prinvl _ _
        (inductionB p popl plinvl prinvl
           x1)
        (inductionB p popl plinvl prinvl
           x2)
    inductionCl :
      (A : Set)
      (P : ClMoufangQuasiGroupTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClMoufangQuasiGroupTerm
          A)
       (x2 : ClMoufangQuasiGroupTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      ((x1 : ClMoufangQuasiGroupTerm
          A)
       (x2 : ClMoufangQuasiGroupTerm
          A) ->
       P x1 ->
       P x2 -> P (linvCl x1 x2)) ->
      ((x1 : ClMoufangQuasiGroupTerm
          A)
       (x2 : ClMoufangQuasiGroupTerm
          A) ->
       P x1 ->
       P x2 -> P (rinvCl x1 x2)) ->
      (x : ClMoufangQuasiGroupTerm
         A) -> P x
    inductionCl _ p psing popcl plinvcl prinvcl (sing
                                                 x1) = psing x1
    inductionCl _ p psing popcl plinvcl prinvcl (opCl
                                                 x1
                                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl
           plinvcl
           prinvcl
           x1)
        (inductionCl _ p psing popcl
           plinvcl
           prinvcl
           x2)
    inductionCl _ p psing popcl plinvcl prinvcl (linvCl
                                                 x1
                                                 x2) =
      plinvcl _ _
        (inductionCl _ p psing popcl
           plinvcl
           prinvcl
           x1)
        (inductionCl _ p psing popcl
           plinvcl
           prinvcl
           x2)
    inductionCl _ p psing popcl plinvcl prinvcl (rinvCl
                                                 x1
                                                 x2) =
      prinvcl _ _
        (inductionCl _ p psing popcl
           plinvcl
           prinvcl
           x1)
        (inductionCl _ p psing popcl
           plinvcl
           prinvcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpMoufangQuasiGroupTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpMoufangQuasiGroupTerm
          n)
       (x2 : OpMoufangQuasiGroupTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      ((x1 : OpMoufangQuasiGroupTerm
          n)
       (x2 : OpMoufangQuasiGroupTerm
          n) ->
       P x1 ->
       P x2 -> P (linvOL x1 x2)) ->
      ((x1 : OpMoufangQuasiGroupTerm
          n)
       (x2 : OpMoufangQuasiGroupTerm
          n) ->
       P x1 ->
       P x2 -> P (rinvOL x1 x2)) ->
      (x : OpMoufangQuasiGroupTerm
         n) -> P x
    inductionOp _ p pv popol plinvol prinvol (v
                                              x1) = pv x1
    inductionOp _ p pv popol plinvol prinvol (opOL
                                              x1
                                              x2) =
      popol _ _
        (inductionOp _ p pv popol
           plinvol
           prinvol
           x1)
        (inductionOp _ p pv popol
           plinvol
           prinvol
           x2)
    inductionOp _ p pv popol plinvol prinvol (linvOL
                                              x1
                                              x2) =
      plinvol _ _
        (inductionOp _ p pv popol
           plinvol
           prinvol
           x1)
        (inductionOp _ p pv popol
           plinvol
           prinvol
           x2)
    inductionOp _ p pv popol plinvol prinvol (rinvOL
                                              x1
                                              x2) =
      prinvol _ _
        (inductionOp _ p pv popol
           plinvol
           prinvol
           x1)
        (inductionOp _ p pv popol
           plinvol
           prinvol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpMoufangQuasiGroupTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpMoufangQuasiGroupTerm2
          n
          A)
       (x2 : OpMoufangQuasiGroupTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      ((x1 : OpMoufangQuasiGroupTerm2
          n
          A)
       (x2 : OpMoufangQuasiGroupTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (linvOL2 x1 x2)) ->
      ((x1 : OpMoufangQuasiGroupTerm2
          n
          A)
       (x2 : OpMoufangQuasiGroupTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (rinvOL2 x1 x2)) ->
      (x : OpMoufangQuasiGroupTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 prinvol2 (v2
                                                            x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 prinvol2 (sing2
                                                            x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 prinvol2 (opOL2
                                                            x1
                                                            x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           prinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           prinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 prinvol2 (linvOL2
                                                            x1
                                                            x2) =
      plinvol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           prinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           prinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 prinvol2 (rinvOL2
                                                            x1
                                                            x2) =
      prinvol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           prinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           prinvol2
           x2)
    opL' :
      MoufangQuasiGroupTerm ->
      MoufangQuasiGroupTerm ->
      MoufangQuasiGroupTerm
    opL' x1 x2 = opL x1 x2
    linvL' :
      MoufangQuasiGroupTerm ->
      MoufangQuasiGroupTerm ->
      MoufangQuasiGroupTerm
    linvL' x1 x2 = linvL x1 x2
    rinvL' :
      MoufangQuasiGroupTerm ->
      MoufangQuasiGroupTerm ->
      MoufangQuasiGroupTerm
    rinvL' x1 x2 = rinvL x1 x2
    stageB :
      MoufangQuasiGroupTerm ->
      Staged MoufangQuasiGroupTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (linvL x1 x2) =
      stage2 _ _ _ linvL'
        (codeLift2 _ _ _ linvL')
        (stageB x1)
        (stageB x2)
    stageB (rinvL x1 x2) =
      stage2 _ _ _ rinvL'
        (codeLift2 _ _ _ rinvL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClMoufangQuasiGroupTerm A ->
      ClMoufangQuasiGroupTerm A ->
      ClMoufangQuasiGroupTerm A
    opCl' _ x1 x2 = opCl x1 x2
    linvCl' :
      (A : Set) ->
      ClMoufangQuasiGroupTerm A ->
      ClMoufangQuasiGroupTerm A ->
      ClMoufangQuasiGroupTerm A
    linvCl' _ x1 x2 = linvCl x1 x2
    rinvCl' :
      (A : Set) ->
      ClMoufangQuasiGroupTerm A ->
      ClMoufangQuasiGroupTerm A ->
      ClMoufangQuasiGroupTerm A
    rinvCl' _ x1 x2 = rinvCl x1 x2
    stageCl :
      (A : Set) ->
      ClMoufangQuasiGroupTerm A ->
      Staged
        (ClMoufangQuasiGroupTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (linvCl x1 x2) =
      stage2 _ _ _ (linvCl' _)
        (codeLift2 _ _ _ (linvCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (rinvCl x1 x2) =
      stage2 _ _ _ (rinvCl' _)
        (codeLift2 _ _ _ (rinvCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpMoufangQuasiGroupTerm n ->
      OpMoufangQuasiGroupTerm n ->
      OpMoufangQuasiGroupTerm n
    opOL' _ x1 x2 = opOL x1 x2
    linvOL' :
      (n : Nat) ->
      OpMoufangQuasiGroupTerm n ->
      OpMoufangQuasiGroupTerm n ->
      OpMoufangQuasiGroupTerm n
    linvOL' _ x1 x2 = linvOL x1 x2
    rinvOL' :
      (n : Nat) ->
      OpMoufangQuasiGroupTerm n ->
      OpMoufangQuasiGroupTerm n ->
      OpMoufangQuasiGroupTerm n
    rinvOL' _ x1 x2 = rinvOL x1 x2
    stageOp :
      (n : Nat) ->
      OpMoufangQuasiGroupTerm n ->
      Staged
        (OpMoufangQuasiGroupTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (linvOL x1 x2) =
      stage2 _ _ _ (linvOL' _)
        (codeLift2 _ _ _ (linvOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (rinvOL x1 x2) =
      stage2 _ _ _ (rinvOL' _)
        (codeLift2 _ _ _ (rinvOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpMoufangQuasiGroupTerm2 n A ->
      OpMoufangQuasiGroupTerm2 n A ->
      OpMoufangQuasiGroupTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    linvOL2' :
      (n : Nat) (A : Set) ->
      OpMoufangQuasiGroupTerm2 n A ->
      OpMoufangQuasiGroupTerm2 n A ->
      OpMoufangQuasiGroupTerm2 n A
    linvOL2' _ _ x1 x2 =
      linvOL2 x1 x2
    rinvOL2' :
      (n : Nat) (A : Set) ->
      OpMoufangQuasiGroupTerm2 n A ->
      OpMoufangQuasiGroupTerm2 n A ->
      OpMoufangQuasiGroupTerm2 n A
    rinvOL2' _ _ x1 x2 =
      rinvOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpMoufangQuasiGroupTerm2 n A ->
      Staged
        (OpMoufangQuasiGroupTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (linvOL2 x1 x2) =
      stage2 _ _ _ (linvOL2' _ _)
        (codeLift2 _ _ _ (linvOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (rinvOL2 x1 x2) =
      stage2 _ _ _ (rinvOL2' _ _)
        (codeLift2 _ _ _ (rinvOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record MoufangQuasiGroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
        linvT :
          Repr A -> Repr A -> Repr A
        rinvT :
          Repr A -> Repr A -> Repr A
  
  module MultCommutativeMonoid where
    record MultCommutativeMonoid
      (A : Set) : Set where
      constructor MultCommutativeMonoidC
      field
        1 : A
        * : A -> A -> A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
    record MultCommutativeMonoidSig
      (AS : Set) : Set where
      constructor MultCommutativeMonoidSigSigC
      field
        1S : AS
        *S : AS -> AS -> AS
    record MultCommutativeMonoidProd
      (AP : Set) : Set where
      constructor MultCommutativeMonoidProdC
      field
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
    record MultCommutativeMonoidHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultCommutativeMonoid A1)
      (Mu2 : MultCommutativeMonoid
         A2) : Set where
      constructor MultCommutativeMonoidHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Mu1) == 1 Mu2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultCommutativeMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultCommutativeMonoid A1)
      (Mu2 : MultCommutativeMonoid
         A2) : Set where
      constructor MultCommutativeMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Mu1) (1 Mu2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultCommutativeMonoidTerm
      : Set where
      1L : MultCommutativeMonoidTerm
      *L :
        MultCommutativeMonoidTerm ->
        MultCommutativeMonoidTerm ->
        MultCommutativeMonoidTerm
    data ClMultCommutativeMonoidTerm
      (A : Set) : Set where
      sing :
        A ->
        ClMultCommutativeMonoidTerm A
      1Cl :
        ClMultCommutativeMonoidTerm A
      *Cl :
        ClMultCommutativeMonoidTerm A ->
        ClMultCommutativeMonoidTerm A ->
        ClMultCommutativeMonoidTerm A
    data OpMultCommutativeMonoidTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpMultCommutativeMonoidTerm n
      1OL :
        OpMultCommutativeMonoidTerm n
      *OL :
        OpMultCommutativeMonoidTerm n ->
        OpMultCommutativeMonoidTerm n ->
        OpMultCommutativeMonoidTerm n
    data OpMultCommutativeMonoidTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpMultCommutativeMonoidTerm2 n A
      sing2 :
        A ->
        OpMultCommutativeMonoidTerm2 n A
      1OL2 :
        OpMultCommutativeMonoidTerm2 n A
      *OL2 :
        OpMultCommutativeMonoidTerm2 n
          A ->
        OpMultCommutativeMonoidTerm2 n
          A ->
        OpMultCommutativeMonoidTerm2 n A
    simplifyB :
      MultCommutativeMonoidTerm ->
      MultCommutativeMonoidTerm
    simplifyB (*L (1L) x) = x
    simplifyB (*L x (1L)) = x
    simplifyB (1L) = 1L
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClMultCommutativeMonoidTerm A ->
      ClMultCommutativeMonoidTerm A
    simplifyCl _ (*Cl (1Cl) x) = x
    simplifyCl _ (*Cl x (1Cl)) = x
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpMultCommutativeMonoidTerm n ->
      OpMultCommutativeMonoidTerm n
    simplifyOp _ (*OL (1OL) x) = x
    simplifyOp _ (*OL x (1OL)) = x
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpMultCommutativeMonoidTerm2 n
        A ->
      OpMultCommutativeMonoidTerm2 n A
    simplifyOpE _ _ (*OL2
                     (1OL2)
                     x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (1OL2)) = x
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      MultCommutativeMonoid A ->
      MultCommutativeMonoidTerm -> A
    evalB _ Mu (1L) = 1 Mu
    evalB _ Mu (*L x1 x2) =
      * Mu (evalB _ Mu x1)
        (evalB _ Mu x2)
    evalCl :
      (A : Set) ->
      MultCommutativeMonoid A ->
      ClMultCommutativeMonoidTerm A ->
      A
    evalCl _ Mu (sing x1) = x1
    evalCl _ Mu (1Cl) = 1 Mu
    evalCl _ Mu (*Cl x1 x2) =
      * Mu (evalCl _ Mu x1)
        (evalCl _ Mu x2)
    evalOp :
      (A : Set) (n : Nat) ->
      MultCommutativeMonoid A ->
      Vec A n ->
      OpMultCommutativeMonoidTerm n ->
      A
    evalOp _ n Mu vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Mu vars (1OL) = 1 Mu
    evalOp _ n Mu vars (*OL x1 x2) =
      * Mu (evalOp _ n Mu vars x1)
        (evalOp _ n Mu vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      MultCommutativeMonoid A ->
      Vec A n ->
      OpMultCommutativeMonoidTerm2 n
        A -> A
    evalOpE _ n Mu vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Mu vars (sing2 x1) =
      x1
    evalOpE _ n Mu vars (1OL2) =
      1 Mu
    evalOpE _ n Mu vars (*OL2
                         x1
                         x2) =
      * Mu (evalOpE _ n Mu vars x1)
        (evalOpE _ n Mu vars x2)
    inductionB :
      (P : MultCommutativeMonoidTerm ->
           Set) ->
      P 1L ->
      ((x1 : MultCommutativeMonoidTerm)
       (x2 : MultCommutativeMonoidTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      (x : MultCommutativeMonoidTerm) ->
      P x
    inductionB p p1l p*l (1L) = p1l
    inductionB p p1l p*l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p1l p*l x1)
        (inductionB p p1l p*l x2)
    inductionCl :
      (A : Set)
      (P : ClMultCommutativeMonoidTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 1Cl ->
      ((x1 : ClMultCommutativeMonoidTerm
          A)
       (x2 : ClMultCommutativeMonoidTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      (x : ClMultCommutativeMonoidTerm
         A) -> P x
    inductionCl _ p psing p1cl p*cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p1cl p*cl (1Cl) =
      p1cl
    inductionCl _ p psing p1cl p*cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p1cl p*cl
           x1)
        (inductionCl _ p psing p1cl p*cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpMultCommutativeMonoidTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 1OL ->
      ((x1 : OpMultCommutativeMonoidTerm
          n)
       (x2 : OpMultCommutativeMonoidTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      (x : OpMultCommutativeMonoidTerm
         n) -> P x
    inductionOp _ p pv p1ol p*ol (v
                                  x1) = pv x1
    inductionOp _ p pv p1ol p*ol (1OL) =
      p1ol
    inductionOp _ p pv p1ol p*ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p1ol p*ol
           x1)
        (inductionOp _ p pv p1ol p*ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpMultCommutativeMonoidTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 1OL2 ->
      ((x1 : OpMultCommutativeMonoidTerm2
          n
          A)
       (x2 : OpMultCommutativeMonoidTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      (x : OpMultCommutativeMonoidTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p1ol2 p*ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p1ol2 p*ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p1ol2 p*ol2 (1OL2) =
      p1ol2
    inductionOpE _ _ p pv2 psing2 p1ol2 p*ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p1ol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p1ol2
           p*ol2
           x2)
    1L' : MultCommutativeMonoidTerm
    1L' = 1L
    *L' :
      MultCommutativeMonoidTerm ->
      MultCommutativeMonoidTerm ->
      MultCommutativeMonoidTerm
    *L' x1 x2 = *L x1 x2
    stageB :
      MultCommutativeMonoidTerm ->
      Staged MultCommutativeMonoidTerm
    stageB (1L) = Now 1L
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    1Cl' :
      (A : Set) ->
      ClMultCommutativeMonoidTerm A
    1Cl' _ = 1Cl
    *Cl' :
      (A : Set) ->
      ClMultCommutativeMonoidTerm A ->
      ClMultCommutativeMonoidTerm A ->
      ClMultCommutativeMonoidTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    stageCl :
      (A : Set) ->
      ClMultCommutativeMonoidTerm A ->
      Staged
        (ClMultCommutativeMonoidTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (1Cl) = Now 1Cl
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    1OL' :
      (n : Nat) ->
      OpMultCommutativeMonoidTerm n
    1OL' _ = 1OL
    *OL' :
      (n : Nat) ->
      OpMultCommutativeMonoidTerm n ->
      OpMultCommutativeMonoidTerm n ->
      OpMultCommutativeMonoidTerm n
    *OL' _ x1 x2 = *OL x1 x2
    stageOp :
      (n : Nat) ->
      OpMultCommutativeMonoidTerm n ->
      Staged
        (OpMultCommutativeMonoidTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (1OL) = Now 1OL
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    1OL2' :
      (n : Nat) (A : Set) ->
      OpMultCommutativeMonoidTerm2 n A
    1OL2' _ _ = 1OL2
    *OL2' :
      (n : Nat) (A : Set) ->
      OpMultCommutativeMonoidTerm2 n
        A ->
      OpMultCommutativeMonoidTerm2 n
        A ->
      OpMultCommutativeMonoidTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpMultCommutativeMonoidTerm2 n
        A ->
      Staged
        (OpMultCommutativeMonoidTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (1OL2) = Now 1OL2
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record MultCommutativeMonoidTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        1T : Repr A
        *T : Repr A -> Repr A -> Repr A
  
  module MultCommutativeSemigroup where
    record MultCommutativeSemigroup
      (A : Set) : Set where
      constructor MultCommutativeSemigroupC
      field
        * : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
    record MultCommutativeSemigroupSig
      (AS : Set) : Set where
      constructor MultCommutativeSemigroupSigSigC
      field
        *S : AS -> AS -> AS
    record MultCommutativeSemigroupProd
      (AP : Set) : Set where
      constructor MultCommutativeSemigroupProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
    record MultCommutativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultCommutativeSemigroup
         A1)
      (Mu2 : MultCommutativeSemigroup
         A2) : Set where
      constructor MultCommutativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultCommutativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultCommutativeSemigroup
         A1)
      (Mu2 : MultCommutativeSemigroup
         A2) : Set where
      constructor MultCommutativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultCommutativeSemigroupTerm
      : Set where
      *L :
        MultCommutativeSemigroupTerm ->
        MultCommutativeSemigroupTerm ->
        MultCommutativeSemigroupTerm
    data ClMultCommutativeSemigroupTerm
      (A : Set) : Set where
      sing :
        A ->
        ClMultCommutativeSemigroupTerm A
      *Cl :
        ClMultCommutativeSemigroupTerm
          A ->
        ClMultCommutativeSemigroupTerm
          A ->
        ClMultCommutativeSemigroupTerm A
    data OpMultCommutativeSemigroupTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpMultCommutativeSemigroupTerm n
      *OL :
        OpMultCommutativeSemigroupTerm
          n ->
        OpMultCommutativeSemigroupTerm
          n ->
        OpMultCommutativeSemigroupTerm n
    data OpMultCommutativeSemigroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpMultCommutativeSemigroupTerm2
          n
          A
      sing2 :
        A ->
        OpMultCommutativeSemigroupTerm2
          n
          A
      *OL2 :
        OpMultCommutativeSemigroupTerm2
          n
          A ->
        OpMultCommutativeSemigroupTerm2
          n
          A ->
        OpMultCommutativeSemigroupTerm2
          n
          A
    simplifyB :
      MultCommutativeSemigroupTerm ->
      MultCommutativeSemigroupTerm
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClMultCommutativeSemigroupTerm
        A ->
      ClMultCommutativeSemigroupTerm A
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpMultCommutativeSemigroupTerm
        n ->
      OpMultCommutativeSemigroupTerm n
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpMultCommutativeSemigroupTerm2
        n
        A ->
      OpMultCommutativeSemigroupTerm2
        n
        A
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      MultCommutativeSemigroup A ->
      MultCommutativeSemigroupTerm ->
      A
    evalB _ Mu (*L x1 x2) =
      * Mu (evalB _ Mu x1)
        (evalB _ Mu x2)
    evalCl :
      (A : Set) ->
      MultCommutativeSemigroup A ->
      ClMultCommutativeSemigroupTerm
        A -> A
    evalCl _ Mu (sing x1) = x1
    evalCl _ Mu (*Cl x1 x2) =
      * Mu (evalCl _ Mu x1)
        (evalCl _ Mu x2)
    evalOp :
      (A : Set) (n : Nat) ->
      MultCommutativeSemigroup A ->
      Vec A n ->
      OpMultCommutativeSemigroupTerm
        n -> A
    evalOp _ n Mu vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Mu vars (*OL x1 x2) =
      * Mu (evalOp _ n Mu vars x1)
        (evalOp _ n Mu vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      MultCommutativeSemigroup A ->
      Vec A n ->
      OpMultCommutativeSemigroupTerm2
        n
        A -> A
    evalOpE _ n Mu vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Mu vars (sing2 x1) =
      x1
    evalOpE _ n Mu vars (*OL2
                         x1
                         x2) =
      * Mu (evalOpE _ n Mu vars x1)
        (evalOpE _ n Mu vars x2)
    inductionB :
      (P : MultCommutativeSemigroupTerm ->
           Set) ->
      ((x1 : MultCommutativeSemigroupTerm)
       (x2 : MultCommutativeSemigroupTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      (x : MultCommutativeSemigroupTerm) ->
      P x
    inductionB p p*l (*L x1 x2) =
      p*l _ _ (inductionB p p*l x1)
        (inductionB p p*l x2)
    inductionCl :
      (A : Set)
      (P : ClMultCommutativeSemigroupTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClMultCommutativeSemigroupTerm
          A)
       (x2 : ClMultCommutativeSemigroupTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      (x : ClMultCommutativeSemigroupTerm
         A) -> P x
    inductionCl _ p psing p*cl (sing
                                x1) = psing x1
    inductionCl _ p psing p*cl (*Cl
                                x1
                                x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl x1)
        (inductionCl _ p psing p*cl x2)
    inductionOp :
      (n : Nat)
      (P : OpMultCommutativeSemigroupTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpMultCommutativeSemigroupTerm
          n)
       (x2 : OpMultCommutativeSemigroupTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      (x : OpMultCommutativeSemigroupTerm
         n) -> P x
    inductionOp _ p pv p*ol (v x1) =
      pv x1
    inductionOp _ p pv p*ol (*OL
                             x1
                             x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol x1)
        (inductionOp _ p pv p*ol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpMultCommutativeSemigroupTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpMultCommutativeSemigroupTerm2
          n
          A)
       (x2 : OpMultCommutativeSemigroupTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      (x : OpMultCommutativeSemigroupTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 (v2
                                         x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 (sing2
                                         x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 (*OL2
                                         x1
                                         x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           x2)
    *L' :
      MultCommutativeSemigroupTerm ->
      MultCommutativeSemigroupTerm ->
      MultCommutativeSemigroupTerm
    *L' x1 x2 = *L x1 x2
    stageB :
      MultCommutativeSemigroupTerm ->
      Staged
        MultCommutativeSemigroupTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClMultCommutativeSemigroupTerm
        A ->
      ClMultCommutativeSemigroupTerm
        A ->
      ClMultCommutativeSemigroupTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    stageCl :
      (A : Set) ->
      ClMultCommutativeSemigroupTerm
        A ->
      Staged
        (ClMultCommutativeSemigroupTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpMultCommutativeSemigroupTerm
        n ->
      OpMultCommutativeSemigroupTerm
        n ->
      OpMultCommutativeSemigroupTerm n
    *OL' _ x1 x2 = *OL x1 x2
    stageOp :
      (n : Nat) ->
      OpMultCommutativeSemigroupTerm
        n ->
      Staged
        (OpMultCommutativeSemigroupTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpMultCommutativeSemigroupTerm2
        n
        A ->
      OpMultCommutativeSemigroupTerm2
        n
        A ->
      OpMultCommutativeSemigroupTerm2
        n
        A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpMultCommutativeSemigroupTerm2
        n
        A ->
      Staged
        (OpMultCommutativeSemigroupTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record MultCommutativeSemigroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
  
  module MultGroup where
    record MultGroup
      (A : Set) : Set where
      constructor MultGroupC
      field
        1 : A
        * : A -> A -> A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        inv : A -> A
        leftInverse_inv_op_1 :
          (x : A) -> * x (inv x) == 1
        rightInverse_inv_op_1 :
          (x : A) -> * (inv x) x == 1
    record MultGroupSig
      (AS : Set) : Set where
      constructor MultGroupSigSigC
      field
        1S : AS
        *S : AS -> AS -> AS
        invS : AS -> AS
    record MultGroupProd
      (AP : Set) : Set where
      constructor MultGroupProdC
      field
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P xP (invP xP) == 1P
        rightInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P (invP xP) xP == 1P
    record MultGroupHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultGroup A1)
      (Mu2 : MultGroup A2) : Set where
      constructor MultGroupHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Mu1) == 1 Mu2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
        pres-inv :
          (x1 : A1) ->
          hom (inv Mu1 x1) ==
            inv Mu2 (hom x1)
    record MultGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultGroup A1)
      (Mu2 : MultGroup A2) : Set where
      constructor MultGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Mu1) (1 Mu2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Mu1 x1) (inv Mu2 y1)
    data MultGroupTerm : Set where
      1L : MultGroupTerm
      *L :
        MultGroupTerm ->
        MultGroupTerm -> MultGroupTerm
      invL :
        MultGroupTerm -> MultGroupTerm
    data ClMultGroupTerm
      (A : Set) : Set where
      sing : A -> ClMultGroupTerm A
      1Cl : ClMultGroupTerm A
      *Cl :
        ClMultGroupTerm A ->
        ClMultGroupTerm A ->
        ClMultGroupTerm A
      invCl :
        ClMultGroupTerm A ->
        ClMultGroupTerm A
    data OpMultGroupTerm
      (n : Nat) : Set where
      v : Fin n -> OpMultGroupTerm n
      1OL : OpMultGroupTerm n
      *OL :
        OpMultGroupTerm n ->
        OpMultGroupTerm n ->
        OpMultGroupTerm n
      invOL :
        OpMultGroupTerm n ->
        OpMultGroupTerm n
    data OpMultGroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpMultGroupTerm2 n A
      sing2 :
        A -> OpMultGroupTerm2 n A
      1OL2 : OpMultGroupTerm2 n A
      *OL2 :
        OpMultGroupTerm2 n A ->
        OpMultGroupTerm2 n A ->
        OpMultGroupTerm2 n A
      invOL2 :
        OpMultGroupTerm2 n A ->
        OpMultGroupTerm2 n A
    simplifyB :
      MultGroupTerm -> MultGroupTerm
    simplifyB (*L (1L) x) = x
    simplifyB (*L x (1L)) = x
    simplifyB (*L x (invL x)) = 1L
    simplifyB (*L (invL x) x) = 1L
    simplifyB (1L) = 1L
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (invL x1) =
      invL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClMultGroupTerm A ->
      ClMultGroupTerm A
    simplifyCl _ (*Cl (1Cl) x) = x
    simplifyCl _ (*Cl x (1Cl)) = x
    simplifyCl _ (*Cl x (invCl x)) =
      1Cl
    simplifyCl _ (*Cl (invCl x) x) =
      1Cl
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (invCl x1) =
      invCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpMultGroupTerm n ->
      OpMultGroupTerm n
    simplifyOp _ (*OL (1OL) x) = x
    simplifyOp _ (*OL x (1OL)) = x
    simplifyOp _ (*OL x (invOL x)) =
      1OL
    simplifyOp _ (*OL (invOL x) x) =
      1OL
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (invOL x1) =
      invOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpMultGroupTerm2 n A ->
      OpMultGroupTerm2 n A
    simplifyOpE _ _ (*OL2
                     (1OL2)
                     x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (1OL2)) = x
    simplifyOpE _ _ (*OL2
                     x
                     (invOL2 x)) = 1OL2
    simplifyOpE _ _ (*OL2
                     (invOL2 x)
                     x) = 1OL2
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (invOL2 x1) =
      invOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      MultGroup A ->
      MultGroupTerm -> A
    evalB _ Mu (1L) = 1 Mu
    evalB _ Mu (*L x1 x2) =
      * Mu (evalB _ Mu x1)
        (evalB _ Mu x2)
    evalB _ Mu (invL x1) =
      inv Mu (evalB _ Mu x1)
    evalCl :
      (A : Set) ->
      MultGroup A ->
      ClMultGroupTerm A -> A
    evalCl _ Mu (sing x1) = x1
    evalCl _ Mu (1Cl) = 1 Mu
    evalCl _ Mu (*Cl x1 x2) =
      * Mu (evalCl _ Mu x1)
        (evalCl _ Mu x2)
    evalCl _ Mu (invCl x1) =
      inv Mu (evalCl _ Mu x1)
    evalOp :
      (A : Set) (n : Nat) ->
      MultGroup A ->
      Vec A n ->
      OpMultGroupTerm n -> A
    evalOp _ n Mu vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Mu vars (1OL) = 1 Mu
    evalOp _ n Mu vars (*OL x1 x2) =
      * Mu (evalOp _ n Mu vars x1)
        (evalOp _ n Mu vars x2)
    evalOp _ n Mu vars (invOL x1) =
      inv Mu (evalOp _ n Mu vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      MultGroup A ->
      Vec A n ->
      OpMultGroupTerm2 n A -> A
    evalOpE _ n Mu vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Mu vars (sing2 x1) =
      x1
    evalOpE _ n Mu vars (1OL2) =
      1 Mu
    evalOpE _ n Mu vars (*OL2
                         x1
                         x2) =
      * Mu (evalOpE _ n Mu vars x1)
        (evalOpE _ n Mu vars x2)
    evalOpE _ n Mu vars (invOL2
                         x1) =
      inv Mu (evalOpE _ n Mu vars x1)
    inductionB :
      (P : MultGroupTerm -> Set) ->
      P 1L ->
      ((x1 : MultGroupTerm)
       (x2 : MultGroupTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : MultGroupTerm) ->
       P x1 -> P (invL x1)) ->
      (x : MultGroupTerm) -> P x
    inductionB p p1l p*l pinvl (1L) =
      p1l
    inductionB p p1l p*l pinvl (*L
                                x1
                                x2) =
      p*l _ _
        (inductionB p p1l p*l pinvl x1)
        (inductionB p p1l p*l pinvl x2)
    inductionB p p1l p*l pinvl (invL
                                x1) =
      pinvl _
        (inductionB p p1l p*l pinvl x1)
    inductionCl :
      (A : Set)
      (P : ClMultGroupTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 1Cl ->
      ((x1 : ClMultGroupTerm A)
       (x2 : ClMultGroupTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClMultGroupTerm A) ->
       P x1 -> P (invCl x1)) ->
      (x : ClMultGroupTerm A) -> P x
    inductionCl _ p psing p1cl p*cl pinvcl (sing
                                            x1) = psing x1
    inductionCl _ p psing p1cl p*cl pinvcl (1Cl) =
      p1cl
    inductionCl _ p psing p1cl p*cl pinvcl (*Cl
                                            x1
                                            x2) =
      p*cl _ _
        (inductionCl _ p psing p1cl p*cl
           pinvcl
           x1)
        (inductionCl _ p psing p1cl p*cl
           pinvcl
           x2)
    inductionCl _ p psing p1cl p*cl pinvcl (invCl
                                            x1) =
      pinvcl _
        (inductionCl _ p psing p1cl p*cl
           pinvcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpMultGroupTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 1OL ->
      ((x1 : OpMultGroupTerm n)
       (x2 : OpMultGroupTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpMultGroupTerm n) ->
       P x1 -> P (invOL x1)) ->
      (x : OpMultGroupTerm n) -> P x
    inductionOp _ p pv p1ol p*ol pinvol (v
                                         x1) = pv x1
    inductionOp _ p pv p1ol p*ol pinvol (1OL) =
      p1ol
    inductionOp _ p pv p1ol p*ol pinvol (*OL
                                         x1
                                         x2) =
      p*ol _ _
        (inductionOp _ p pv p1ol p*ol
           pinvol
           x1)
        (inductionOp _ p pv p1ol p*ol
           pinvol
           x2)
    inductionOp _ p pv p1ol p*ol pinvol (invOL
                                         x1) =
      pinvol _
        (inductionOp _ p pv p1ol p*ol
           pinvol
           x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpMultGroupTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 1OL2 ->
      ((x1 : OpMultGroupTerm2 n A)
       (x2 : OpMultGroupTerm2 n A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpMultGroupTerm2 n A) ->
       P x1 -> P (invOL2 x1)) ->
      (x : OpMultGroupTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p1ol2 p*ol2 pinvol2 (v2
                                                       x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p1ol2 p*ol2 pinvol2 (sing2
                                                       x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p1ol2 p*ol2 pinvol2 (1OL2) =
      p1ol2
    inductionOpE _ _ p pv2 psing2 p1ol2 p*ol2 pinvol2 (*OL2
                                                       x1
                                                       x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p1ol2
           p*ol2
           pinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p1ol2
           p*ol2
           pinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 p1ol2 p*ol2 pinvol2 (invOL2
                                                       x1) =
      pinvol2 _
        (inductionOpE _ _ p pv2 psing2
           p1ol2
           p*ol2
           pinvol2
           x1)
    1L' : MultGroupTerm
    1L' = 1L
    *L' :
      MultGroupTerm ->
      MultGroupTerm -> MultGroupTerm
    *L' x1 x2 = *L x1 x2
    invL' :
      MultGroupTerm -> MultGroupTerm
    invL' x1 = invL x1
    stageB :
      MultGroupTerm ->
      Staged MultGroupTerm
    stageB (1L) = Now 1L
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (invL x1) =
      stage1 _ _ invL'
        (codeLift1 _ _ invL')
        (stageB x1)
    1Cl' :
      (A : Set) -> ClMultGroupTerm A
    1Cl' _ = 1Cl
    *Cl' :
      (A : Set) ->
      ClMultGroupTerm A ->
      ClMultGroupTerm A ->
      ClMultGroupTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    invCl' :
      (A : Set) ->
      ClMultGroupTerm A ->
      ClMultGroupTerm A
    invCl' _ x1 = invCl x1
    stageCl :
      (A : Set) ->
      ClMultGroupTerm A ->
      Staged (ClMultGroupTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (1Cl) = Now 1Cl
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (invCl x1) =
      stage1 _ _ (invCl' _)
        (codeLift1 _ _ (invCl' _))
        (stageCl _ x1)
    1OL' :
      (n : Nat) -> OpMultGroupTerm n
    1OL' _ = 1OL
    *OL' :
      (n : Nat) ->
      OpMultGroupTerm n ->
      OpMultGroupTerm n ->
      OpMultGroupTerm n
    *OL' _ x1 x2 = *OL x1 x2
    invOL' :
      (n : Nat) ->
      OpMultGroupTerm n ->
      OpMultGroupTerm n
    invOL' _ x1 = invOL x1
    stageOp :
      (n : Nat) ->
      OpMultGroupTerm n ->
      Staged (OpMultGroupTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (1OL) = Now 1OL
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (invOL x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (stageOp _ x1)
    1OL2' :
      (n : Nat) (A : Set) ->
      OpMultGroupTerm2 n A
    1OL2' _ _ = 1OL2
    *OL2' :
      (n : Nat) (A : Set) ->
      OpMultGroupTerm2 n A ->
      OpMultGroupTerm2 n A ->
      OpMultGroupTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    invOL2' :
      (n : Nat) (A : Set) ->
      OpMultGroupTerm2 n A ->
      OpMultGroupTerm2 n A
    invOL2' _ _ x1 = invOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpMultGroupTerm2 n A ->
      Staged (OpMultGroupTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (1OL2) = Now 1OL2
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (invOL2 x1) =
      stage1 _ _ (invOL2' _ _)
        (codeLift1 _ _ (invOL2' _ _))
        (stageOpE _ _ x1)
    record MultGroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        1T : Repr A
        *T : Repr A -> Repr A -> Repr A
        invT : Repr A -> Repr A
  
  module MultMagma where
    record MultMagma
      (A : Set) : Set where
      constructor MultMagmaC
      field
        * : A -> A -> A
    record MultMagmaSig
      (AS : Set) : Set where
      constructor MultMagmaSigSigC
      field
        *S : AS -> AS -> AS
    record MultMagmaProd
      (AP : Set) : Set where
      constructor MultMagmaProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record MultMagmaHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultMagma A1)
      (Mu2 : MultMagma A2) : Set where
      constructor MultMagmaHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultMagma A1)
      (Mu2 : MultMagma A2) : Set where
      constructor MultMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultMagmaTerm : Set where
      *L :
        MultMagmaTerm ->
        MultMagmaTerm -> MultMagmaTerm
    data ClMultMagmaTerm
      (A : Set) : Set where
      sing : A -> ClMultMagmaTerm A
      *Cl :
        ClMultMagmaTerm A ->
        ClMultMagmaTerm A ->
        ClMultMagmaTerm A
    data OpMultMagmaTerm
      (n : Nat) : Set where
      v : Fin n -> OpMultMagmaTerm n
      *OL :
        OpMultMagmaTerm n ->
        OpMultMagmaTerm n ->
        OpMultMagmaTerm n
    data OpMultMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpMultMagmaTerm2 n A
      sing2 :
        A -> OpMultMagmaTerm2 n A
      *OL2 :
        OpMultMagmaTerm2 n A ->
        OpMultMagmaTerm2 n A ->
        OpMultMagmaTerm2 n A
    simplifyB :
      MultMagmaTerm -> MultMagmaTerm
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClMultMagmaTerm A ->
      ClMultMagmaTerm A
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpMultMagmaTerm n ->
      OpMultMagmaTerm n
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpMultMagmaTerm2 n A ->
      OpMultMagmaTerm2 n A
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      MultMagma A ->
      MultMagmaTerm -> A
    evalB _ Mu (*L x1 x2) =
      * Mu (evalB _ Mu x1)
        (evalB _ Mu x2)
    evalCl :
      (A : Set) ->
      MultMagma A ->
      ClMultMagmaTerm A -> A
    evalCl _ Mu (sing x1) = x1
    evalCl _ Mu (*Cl x1 x2) =
      * Mu (evalCl _ Mu x1)
        (evalCl _ Mu x2)
    evalOp :
      (A : Set) (n : Nat) ->
      MultMagma A ->
      Vec A n ->
      OpMultMagmaTerm n -> A
    evalOp _ n Mu vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Mu vars (*OL x1 x2) =
      * Mu (evalOp _ n Mu vars x1)
        (evalOp _ n Mu vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      MultMagma A ->
      Vec A n ->
      OpMultMagmaTerm2 n A -> A
    evalOpE _ n Mu vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Mu vars (sing2 x1) =
      x1
    evalOpE _ n Mu vars (*OL2
                         x1
                         x2) =
      * Mu (evalOpE _ n Mu vars x1)
        (evalOpE _ n Mu vars x2)
    inductionB :
      (P : MultMagmaTerm -> Set) ->
      ((x1 : MultMagmaTerm)
       (x2 : MultMagmaTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      (x : MultMagmaTerm) -> P x
    inductionB p p*l (*L x1 x2) =
      p*l _ _ (inductionB p p*l x1)
        (inductionB p p*l x2)
    inductionCl :
      (A : Set)
      (P : ClMultMagmaTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClMultMagmaTerm A)
       (x2 : ClMultMagmaTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      (x : ClMultMagmaTerm A) -> P x
    inductionCl _ p psing p*cl (sing
                                x1) = psing x1
    inductionCl _ p psing p*cl (*Cl
                                x1
                                x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl x1)
        (inductionCl _ p psing p*cl x2)
    inductionOp :
      (n : Nat)
      (P : OpMultMagmaTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpMultMagmaTerm n)
       (x2 : OpMultMagmaTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      (x : OpMultMagmaTerm n) -> P x
    inductionOp _ p pv p*ol (v x1) =
      pv x1
    inductionOp _ p pv p*ol (*OL
                             x1
                             x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol x1)
        (inductionOp _ p pv p*ol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpMultMagmaTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpMultMagmaTerm2 n A)
       (x2 : OpMultMagmaTerm2 n A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      (x : OpMultMagmaTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p*ol2 (v2
                                         x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 (sing2
                                         x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 (*OL2
                                         x1
                                         x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           x2)
    *L' :
      MultMagmaTerm ->
      MultMagmaTerm -> MultMagmaTerm
    *L' x1 x2 = *L x1 x2
    stageB :
      MultMagmaTerm ->
      Staged MultMagmaTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClMultMagmaTerm A ->
      ClMultMagmaTerm A ->
      ClMultMagmaTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    stageCl :
      (A : Set) ->
      ClMultMagmaTerm A ->
      Staged (ClMultMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpMultMagmaTerm n ->
      OpMultMagmaTerm n ->
      OpMultMagmaTerm n
    *OL' _ x1 x2 = *OL x1 x2
    stageOp :
      (n : Nat) ->
      OpMultMagmaTerm n ->
      Staged (OpMultMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpMultMagmaTerm2 n A ->
      OpMultMagmaTerm2 n A ->
      OpMultMagmaTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpMultMagmaTerm2 n A ->
      Staged (OpMultMagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record MultMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
  
  module MultMeetSemilattice where
    record MultMeetSemilattice
      (A : Set) : Set where
      constructor MultMeetSemilatticeC
      field
        * : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
    record MultMeetSemilatticeSig
      (AS : Set) : Set where
      constructor MultMeetSemilatticeSigSigC
      field
        *S : AS -> AS -> AS
    record MultMeetSemilatticeProd
      (AP : Set) : Set where
      constructor MultMeetSemilatticeProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
    record MultMeetSemilatticeHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultMeetSemilattice A1)
      (Mu2 : MultMeetSemilattice A2) :
      Set where
      constructor MultMeetSemilatticeHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultMeetSemilatticeRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultMeetSemilattice A1)
      (Mu2 : MultMeetSemilattice A2) :
      Set where
      constructor MultMeetSemilatticeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultMeetSemilatticeTerm
      : Set where
      *L :
        MultMeetSemilatticeTerm ->
        MultMeetSemilatticeTerm ->
        MultMeetSemilatticeTerm
    data ClMultMeetSemilatticeTerm
      (A : Set) : Set where
      sing :
        A -> ClMultMeetSemilatticeTerm A
      *Cl :
        ClMultMeetSemilatticeTerm A ->
        ClMultMeetSemilatticeTerm A ->
        ClMultMeetSemilatticeTerm A
    data OpMultMeetSemilatticeTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpMultMeetSemilatticeTerm n
      *OL :
        OpMultMeetSemilatticeTerm n ->
        OpMultMeetSemilatticeTerm n ->
        OpMultMeetSemilatticeTerm n
    data OpMultMeetSemilatticeTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpMultMeetSemilatticeTerm2 n A
      sing2 :
        A ->
        OpMultMeetSemilatticeTerm2 n A
      *OL2 :
        OpMultMeetSemilatticeTerm2 n
          A ->
        OpMultMeetSemilatticeTerm2 n
          A ->
        OpMultMeetSemilatticeTerm2 n A
    simplifyB :
      MultMeetSemilatticeTerm ->
      MultMeetSemilatticeTerm
    simplifyB (*L x x) = x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClMultMeetSemilatticeTerm A ->
      ClMultMeetSemilatticeTerm A
    simplifyCl _ (*Cl x x) = x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpMultMeetSemilatticeTerm n ->
      OpMultMeetSemilatticeTerm n
    simplifyOp _ (*OL x x) = x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpMultMeetSemilatticeTerm2 n
        A ->
      OpMultMeetSemilatticeTerm2 n A
    simplifyOpE _ _ (*OL2 x x) = x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      MultMeetSemilattice A ->
      MultMeetSemilatticeTerm -> A
    evalB _ Mu (*L x1 x2) =
      * Mu (evalB _ Mu x1)
        (evalB _ Mu x2)
    evalCl :
      (A : Set) ->
      MultMeetSemilattice A ->
      ClMultMeetSemilatticeTerm A -> A
    evalCl _ Mu (sing x1) = x1
    evalCl _ Mu (*Cl x1 x2) =
      * Mu (evalCl _ Mu x1)
        (evalCl _ Mu x2)
    evalOp :
      (A : Set) (n : Nat) ->
      MultMeetSemilattice A ->
      Vec A n ->
      OpMultMeetSemilatticeTerm n -> A
    evalOp _ n Mu vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Mu vars (*OL x1 x2) =
      * Mu (evalOp _ n Mu vars x1)
        (evalOp _ n Mu vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      MultMeetSemilattice A ->
      Vec A n ->
      OpMultMeetSemilatticeTerm2 n
        A -> A
    evalOpE _ n Mu vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Mu vars (sing2 x1) =
      x1
    evalOpE _ n Mu vars (*OL2
                         x1
                         x2) =
      * Mu (evalOpE _ n Mu vars x1)
        (evalOpE _ n Mu vars x2)
    inductionB :
      (P : MultMeetSemilatticeTerm ->
           Set) ->
      ((x1 : MultMeetSemilatticeTerm)
       (x2 : MultMeetSemilatticeTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      (x : MultMeetSemilatticeTerm) ->
      P x
    inductionB p p*l (*L x1 x2) =
      p*l _ _ (inductionB p p*l x1)
        (inductionB p p*l x2)
    inductionCl :
      (A : Set)
      (P : ClMultMeetSemilatticeTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClMultMeetSemilatticeTerm
          A)
       (x2 : ClMultMeetSemilatticeTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      (x : ClMultMeetSemilatticeTerm
         A) -> P x
    inductionCl _ p psing p*cl (sing
                                x1) = psing x1
    inductionCl _ p psing p*cl (*Cl
                                x1
                                x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl x1)
        (inductionCl _ p psing p*cl x2)
    inductionOp :
      (n : Nat)
      (P : OpMultMeetSemilatticeTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpMultMeetSemilatticeTerm
          n)
       (x2 : OpMultMeetSemilatticeTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      (x : OpMultMeetSemilatticeTerm
         n) -> P x
    inductionOp _ p pv p*ol (v x1) =
      pv x1
    inductionOp _ p pv p*ol (*OL
                             x1
                             x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol x1)
        (inductionOp _ p pv p*ol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpMultMeetSemilatticeTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpMultMeetSemilatticeTerm2
          n
          A)
       (x2 : OpMultMeetSemilatticeTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      (x : OpMultMeetSemilatticeTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 (v2
                                         x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 (sing2
                                         x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 (*OL2
                                         x1
                                         x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           x2)
    *L' :
      MultMeetSemilatticeTerm ->
      MultMeetSemilatticeTerm ->
      MultMeetSemilatticeTerm
    *L' x1 x2 = *L x1 x2
    stageB :
      MultMeetSemilatticeTerm ->
      Staged MultMeetSemilatticeTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClMultMeetSemilatticeTerm A ->
      ClMultMeetSemilatticeTerm A ->
      ClMultMeetSemilatticeTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    stageCl :
      (A : Set) ->
      ClMultMeetSemilatticeTerm A ->
      Staged
        (ClMultMeetSemilatticeTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpMultMeetSemilatticeTerm n ->
      OpMultMeetSemilatticeTerm n ->
      OpMultMeetSemilatticeTerm n
    *OL' _ x1 x2 = *OL x1 x2
    stageOp :
      (n : Nat) ->
      OpMultMeetSemilatticeTerm n ->
      Staged
        (OpMultMeetSemilatticeTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpMultMeetSemilatticeTerm2 n
        A ->
      OpMultMeetSemilatticeTerm2 n
        A ->
      OpMultMeetSemilatticeTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpMultMeetSemilatticeTerm2 n
        A ->
      Staged
        (OpMultMeetSemilatticeTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record MultMeetSemilatticeTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
  
  module MultMonoid where
    record MultMonoid
      (A : Set) : Set where
      constructor MultMonoidC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
    record MultMonoidSig
      (AS : Set) : Set where
      constructor MultMonoidSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
    record MultMonoidProd
      (AP : Set) : Set where
      constructor MultMonoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
    record MultMonoidHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultMonoid A1)
      (Mu2 : MultMonoid A2) :
      Set where
      constructor MultMonoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
        pres-1 : hom (1 Mu1) == 1 Mu2
    record MultMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultMonoid A1)
      (Mu2 : MultMonoid A2) :
      Set where
      constructor MultMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
        interp-1 :
          interp (1 Mu1) (1 Mu2)
    data MultMonoidTerm : Set where
      *L :
        MultMonoidTerm ->
        MultMonoidTerm -> MultMonoidTerm
      1L : MultMonoidTerm
    data ClMultMonoidTerm
      (A : Set) : Set where
      sing : A -> ClMultMonoidTerm A
      *Cl :
        ClMultMonoidTerm A ->
        ClMultMonoidTerm A ->
        ClMultMonoidTerm A
      1Cl : ClMultMonoidTerm A
    data OpMultMonoidTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpMultMonoidTerm n
      *OL :
        OpMultMonoidTerm n ->
        OpMultMonoidTerm n ->
        OpMultMonoidTerm n
      1OL : OpMultMonoidTerm n
    data OpMultMonoidTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpMultMonoidTerm2 n A
      sing2 :
        A -> OpMultMonoidTerm2 n A
      *OL2 :
        OpMultMonoidTerm2 n A ->
        OpMultMonoidTerm2 n A ->
        OpMultMonoidTerm2 n A
      1OL2 : OpMultMonoidTerm2 n A
    simplifyB :
      MultMonoidTerm -> MultMonoidTerm
    simplifyB (*L (1L) x) = x
    simplifyB (*L x (1L)) = x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (1L) = 1L
    simplifyCl :
      (A : Set) ->
      ClMultMonoidTerm A ->
      ClMultMonoidTerm A
    simplifyCl _ (*Cl (1Cl) x) = x
    simplifyCl _ (*Cl x (1Cl)) = x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpMultMonoidTerm n ->
      OpMultMonoidTerm n
    simplifyOp _ (*OL (1OL) x) = x
    simplifyOp _ (*OL x (1OL)) = x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpMultMonoidTerm2 n A ->
      OpMultMonoidTerm2 n A
    simplifyOpE _ _ (*OL2
                     (1OL2)
                     x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (1OL2)) = x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      MultMonoid A ->
      MultMonoidTerm -> A
    evalB _ Mu (*L x1 x2) =
      * Mu (evalB _ Mu x1)
        (evalB _ Mu x2)
    evalB _ Mu (1L) = 1 Mu
    evalCl :
      (A : Set) ->
      MultMonoid A ->
      ClMultMonoidTerm A -> A
    evalCl _ Mu (sing x1) = x1
    evalCl _ Mu (*Cl x1 x2) =
      * Mu (evalCl _ Mu x1)
        (evalCl _ Mu x2)
    evalCl _ Mu (1Cl) = 1 Mu
    evalOp :
      (A : Set) (n : Nat) ->
      MultMonoid A ->
      Vec A n ->
      OpMultMonoidTerm n -> A
    evalOp _ n Mu vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Mu vars (*OL x1 x2) =
      * Mu (evalOp _ n Mu vars x1)
        (evalOp _ n Mu vars x2)
    evalOp _ n Mu vars (1OL) = 1 Mu
    evalOpE :
      (A : Set) (n : Nat) ->
      MultMonoid A ->
      Vec A n ->
      OpMultMonoidTerm2 n A -> A
    evalOpE _ n Mu vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Mu vars (sing2 x1) =
      x1
    evalOpE _ n Mu vars (*OL2
                         x1
                         x2) =
      * Mu (evalOpE _ n Mu vars x1)
        (evalOpE _ n Mu vars x2)
    evalOpE _ n Mu vars (1OL2) =
      1 Mu
    inductionB :
      (P : MultMonoidTerm -> Set) ->
      ((x1 : MultMonoidTerm)
       (x2 : MultMonoidTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      P 1L ->
      (x : MultMonoidTerm) -> P x
    inductionB p p*l p1l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p*l p1l x1)
        (inductionB p p*l p1l x2)
    inductionB p p*l p1l (1L) = p1l
    inductionCl :
      (A : Set)
      (P : ClMultMonoidTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClMultMonoidTerm A)
       (x2 : ClMultMonoidTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      P 1Cl ->
      (x : ClMultMonoidTerm A) -> P x
    inductionCl _ p psing p*cl p1cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p*cl p1cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p1cl
           x1)
        (inductionCl _ p psing p*cl p1cl
           x2)
    inductionCl _ p psing p*cl p1cl (1Cl) =
      p1cl
    inductionOp :
      (n : Nat)
      (P : OpMultMonoidTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpMultMonoidTerm n)
       (x2 : OpMultMonoidTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      P 1OL ->
      (x : OpMultMonoidTerm n) -> P x
    inductionOp _ p pv p*ol p1ol (v
                                  x1) = pv x1
    inductionOp _ p pv p*ol p1ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p1ol
           x1)
        (inductionOp _ p pv p*ol p1ol
           x2)
    inductionOp _ p pv p*ol p1ol (1OL) =
      p1ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpMultMonoidTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpMultMonoidTerm2 n A)
       (x2 : OpMultMonoidTerm2 n A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      P 1OL2 ->
      (x : OpMultMonoidTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 (1OL2) =
      p1ol2
    *L' :
      MultMonoidTerm ->
      MultMonoidTerm -> MultMonoidTerm
    *L' x1 x2 = *L x1 x2
    1L' : MultMonoidTerm
    1L' = 1L
    stageB :
      MultMonoidTerm ->
      Staged MultMonoidTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (1L) = Now 1L
    *Cl' :
      (A : Set) ->
      ClMultMonoidTerm A ->
      ClMultMonoidTerm A ->
      ClMultMonoidTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    1Cl' :
      (A : Set) -> ClMultMonoidTerm A
    1Cl' _ = 1Cl
    stageCl :
      (A : Set) ->
      ClMultMonoidTerm A ->
      Staged (ClMultMonoidTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (1Cl) = Now 1Cl
    *OL' :
      (n : Nat) ->
      OpMultMonoidTerm n ->
      OpMultMonoidTerm n ->
      OpMultMonoidTerm n
    *OL' _ x1 x2 = *OL x1 x2
    1OL' :
      (n : Nat) -> OpMultMonoidTerm n
    1OL' _ = 1OL
    stageOp :
      (n : Nat) ->
      OpMultMonoidTerm n ->
      Staged (OpMultMonoidTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (1OL) = Now 1OL
    *OL2' :
      (n : Nat) (A : Set) ->
      OpMultMonoidTerm2 n A ->
      OpMultMonoidTerm2 n A ->
      OpMultMonoidTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    1OL2' :
      (n : Nat) (A : Set) ->
      OpMultMonoidTerm2 n A
    1OL2' _ _ = 1OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpMultMonoidTerm2 n A ->
      Staged (OpMultMonoidTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (1OL2) = Now 1OL2
    record MultMonoidTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        1T : Repr A
  
  module MultPointedMagma where
    record MultPointedMagma
      (A : Set) : Set where
      constructor MultPointedMagmaC
      field
        1 : A
        * : A -> A -> A
    record MultPointedMagmaSig
      (AS : Set) : Set where
      constructor MultPointedMagmaSigSigC
      field
        1S : AS
        *S : AS -> AS -> AS
    record MultPointedMagmaProd
      (AP : Set) : Set where
      constructor MultPointedMagmaProdC
      field
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record MultPointedMagmaHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultPointedMagma A1)
      (Mu2 : MultPointedMagma A2) :
      Set where
      constructor MultPointedMagmaHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Mu1) == 1 Mu2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultPointedMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultPointedMagma A1)
      (Mu2 : MultPointedMagma A2) :
      Set where
      constructor MultPointedMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Mu1) (1 Mu2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultPointedMagmaTerm
      : Set where
      1L : MultPointedMagmaTerm
      *L :
        MultPointedMagmaTerm ->
        MultPointedMagmaTerm ->
        MultPointedMagmaTerm
    data ClMultPointedMagmaTerm
      (A : Set) : Set where
      sing :
        A -> ClMultPointedMagmaTerm A
      1Cl : ClMultPointedMagmaTerm A
      *Cl :
        ClMultPointedMagmaTerm A ->
        ClMultPointedMagmaTerm A ->
        ClMultPointedMagmaTerm A
    data OpMultPointedMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpMultPointedMagmaTerm n
      1OL : OpMultPointedMagmaTerm n
      *OL :
        OpMultPointedMagmaTerm n ->
        OpMultPointedMagmaTerm n ->
        OpMultPointedMagmaTerm n
    data OpMultPointedMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpMultPointedMagmaTerm2 n A
      sing2 :
        A -> OpMultPointedMagmaTerm2 n A
      1OL2 :
        OpMultPointedMagmaTerm2 n A
      *OL2 :
        OpMultPointedMagmaTerm2 n A ->
        OpMultPointedMagmaTerm2 n A ->
        OpMultPointedMagmaTerm2 n A
    simplifyB :
      MultPointedMagmaTerm ->
      MultPointedMagmaTerm
    simplifyB (1L) = 1L
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClMultPointedMagmaTerm A ->
      ClMultPointedMagmaTerm A
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpMultPointedMagmaTerm n ->
      OpMultPointedMagmaTerm n
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpMultPointedMagmaTerm2 n A ->
      OpMultPointedMagmaTerm2 n A
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      MultPointedMagma A ->
      MultPointedMagmaTerm -> A
    evalB _ Mu (1L) = 1 Mu
    evalB _ Mu (*L x1 x2) =
      * Mu (evalB _ Mu x1)
        (evalB _ Mu x2)
    evalCl :
      (A : Set) ->
      MultPointedMagma A ->
      ClMultPointedMagmaTerm A -> A
    evalCl _ Mu (sing x1) = x1
    evalCl _ Mu (1Cl) = 1 Mu
    evalCl _ Mu (*Cl x1 x2) =
      * Mu (evalCl _ Mu x1)
        (evalCl _ Mu x2)
    evalOp :
      (A : Set) (n : Nat) ->
      MultPointedMagma A ->
      Vec A n ->
      OpMultPointedMagmaTerm n -> A
    evalOp _ n Mu vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Mu vars (1OL) = 1 Mu
    evalOp _ n Mu vars (*OL x1 x2) =
      * Mu (evalOp _ n Mu vars x1)
        (evalOp _ n Mu vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      MultPointedMagma A ->
      Vec A n ->
      OpMultPointedMagmaTerm2 n A -> A
    evalOpE _ n Mu vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Mu vars (sing2 x1) =
      x1
    evalOpE _ n Mu vars (1OL2) =
      1 Mu
    evalOpE _ n Mu vars (*OL2
                         x1
                         x2) =
      * Mu (evalOpE _ n Mu vars x1)
        (evalOpE _ n Mu vars x2)
    inductionB :
      (P : MultPointedMagmaTerm ->
           Set) ->
      P 1L ->
      ((x1 : MultPointedMagmaTerm)
       (x2 : MultPointedMagmaTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      (x : MultPointedMagmaTerm) ->
      P x
    inductionB p p1l p*l (1L) = p1l
    inductionB p p1l p*l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p1l p*l x1)
        (inductionB p p1l p*l x2)
    inductionCl :
      (A : Set)
      (P : ClMultPointedMagmaTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 1Cl ->
      ((x1 : ClMultPointedMagmaTerm A)
       (x2 : ClMultPointedMagmaTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      (x : ClMultPointedMagmaTerm
         A) -> P x
    inductionCl _ p psing p1cl p*cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p1cl p*cl (1Cl) =
      p1cl
    inductionCl _ p psing p1cl p*cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p1cl p*cl
           x1)
        (inductionCl _ p psing p1cl p*cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpMultPointedMagmaTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 1OL ->
      ((x1 : OpMultPointedMagmaTerm n)
       (x2 : OpMultPointedMagmaTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      (x : OpMultPointedMagmaTerm
         n) -> P x
    inductionOp _ p pv p1ol p*ol (v
                                  x1) = pv x1
    inductionOp _ p pv p1ol p*ol (1OL) =
      p1ol
    inductionOp _ p pv p1ol p*ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p1ol p*ol
           x1)
        (inductionOp _ p pv p1ol p*ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpMultPointedMagmaTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 1OL2 ->
      ((x1 : OpMultPointedMagmaTerm2 n
          A)
       (x2 : OpMultPointedMagmaTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      (x : OpMultPointedMagmaTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p1ol2 p*ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p1ol2 p*ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p1ol2 p*ol2 (1OL2) =
      p1ol2
    inductionOpE _ _ p pv2 psing2 p1ol2 p*ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p1ol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p1ol2
           p*ol2
           x2)
    1L' : MultPointedMagmaTerm
    1L' = 1L
    *L' :
      MultPointedMagmaTerm ->
      MultPointedMagmaTerm ->
      MultPointedMagmaTerm
    *L' x1 x2 = *L x1 x2
    stageB :
      MultPointedMagmaTerm ->
      Staged MultPointedMagmaTerm
    stageB (1L) = Now 1L
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    1Cl' :
      (A : Set) ->
      ClMultPointedMagmaTerm A
    1Cl' _ = 1Cl
    *Cl' :
      (A : Set) ->
      ClMultPointedMagmaTerm A ->
      ClMultPointedMagmaTerm A ->
      ClMultPointedMagmaTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    stageCl :
      (A : Set) ->
      ClMultPointedMagmaTerm A ->
      Staged
        (ClMultPointedMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (1Cl) = Now 1Cl
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    1OL' :
      (n : Nat) ->
      OpMultPointedMagmaTerm n
    1OL' _ = 1OL
    *OL' :
      (n : Nat) ->
      OpMultPointedMagmaTerm n ->
      OpMultPointedMagmaTerm n ->
      OpMultPointedMagmaTerm n
    *OL' _ x1 x2 = *OL x1 x2
    stageOp :
      (n : Nat) ->
      OpMultPointedMagmaTerm n ->
      Staged
        (OpMultPointedMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (1OL) = Now 1OL
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    1OL2' :
      (n : Nat) (A : Set) ->
      OpMultPointedMagmaTerm2 n A
    1OL2' _ _ = 1OL2
    *OL2' :
      (n : Nat) (A : Set) ->
      OpMultPointedMagmaTerm2 n A ->
      OpMultPointedMagmaTerm2 n A ->
      OpMultPointedMagmaTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpMultPointedMagmaTerm2 n A ->
      Staged
        (OpMultPointedMagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (1OL2) = Now 1OL2
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record MultPointedMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        1T : Repr A
        *T : Repr A -> Repr A -> Repr A
  
  module MultPointedSemigroup where
    record MultPointedSemigroup
      (A : Set) : Set where
      constructor MultPointedSemigroupC
      field
        1 : A
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
    record MultPointedSemigroupSig
      (AS : Set) : Set where
      constructor MultPointedSemigroupSigSigC
      field
        1S : AS
        *S : AS -> AS -> AS
    record MultPointedSemigroupProd
      (AP : Set) : Set where
      constructor MultPointedSemigroupProdC
      field
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
    record MultPointedSemigroupHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultPointedSemigroup A1)
      (Mu2 : MultPointedSemigroup
         A2) : Set where
      constructor MultPointedSemigroupHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Mu1) == 1 Mu2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultPointedSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultPointedSemigroup A1)
      (Mu2 : MultPointedSemigroup
         A2) : Set where
      constructor MultPointedSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Mu1) (1 Mu2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultPointedSemigroupTerm
      : Set where
      1L : MultPointedSemigroupTerm
      *L :
        MultPointedSemigroupTerm ->
        MultPointedSemigroupTerm ->
        MultPointedSemigroupTerm
    data ClMultPointedSemigroupTerm
      (A : Set) : Set where
      sing :
        A ->
        ClMultPointedSemigroupTerm A
      1Cl :
        ClMultPointedSemigroupTerm A
      *Cl :
        ClMultPointedSemigroupTerm A ->
        ClMultPointedSemigroupTerm A ->
        ClMultPointedSemigroupTerm A
    data OpMultPointedSemigroupTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpMultPointedSemigroupTerm n
      1OL :
        OpMultPointedSemigroupTerm n
      *OL :
        OpMultPointedSemigroupTerm n ->
        OpMultPointedSemigroupTerm n ->
        OpMultPointedSemigroupTerm n
    data OpMultPointedSemigroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpMultPointedSemigroupTerm2 n A
      sing2 :
        A ->
        OpMultPointedSemigroupTerm2 n A
      1OL2 :
        OpMultPointedSemigroupTerm2 n A
      *OL2 :
        OpMultPointedSemigroupTerm2 n
          A ->
        OpMultPointedSemigroupTerm2 n
          A ->
        OpMultPointedSemigroupTerm2 n A
    simplifyB :
      MultPointedSemigroupTerm ->
      MultPointedSemigroupTerm
    simplifyB (1L) = 1L
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClMultPointedSemigroupTerm A ->
      ClMultPointedSemigroupTerm A
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpMultPointedSemigroupTerm n ->
      OpMultPointedSemigroupTerm n
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpMultPointedSemigroupTerm2 n
        A ->
      OpMultPointedSemigroupTerm2 n A
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      MultPointedSemigroup A ->
      MultPointedSemigroupTerm -> A
    evalB _ Mu (1L) = 1 Mu
    evalB _ Mu (*L x1 x2) =
      * Mu (evalB _ Mu x1)
        (evalB _ Mu x2)
    evalCl :
      (A : Set) ->
      MultPointedSemigroup A ->
      ClMultPointedSemigroupTerm A ->
      A
    evalCl _ Mu (sing x1) = x1
    evalCl _ Mu (1Cl) = 1 Mu
    evalCl _ Mu (*Cl x1 x2) =
      * Mu (evalCl _ Mu x1)
        (evalCl _ Mu x2)
    evalOp :
      (A : Set) (n : Nat) ->
      MultPointedSemigroup A ->
      Vec A n ->
      OpMultPointedSemigroupTerm n ->
      A
    evalOp _ n Mu vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Mu vars (1OL) = 1 Mu
    evalOp _ n Mu vars (*OL x1 x2) =
      * Mu (evalOp _ n Mu vars x1)
        (evalOp _ n Mu vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      MultPointedSemigroup A ->
      Vec A n ->
      OpMultPointedSemigroupTerm2 n
        A -> A
    evalOpE _ n Mu vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Mu vars (sing2 x1) =
      x1
    evalOpE _ n Mu vars (1OL2) =
      1 Mu
    evalOpE _ n Mu vars (*OL2
                         x1
                         x2) =
      * Mu (evalOpE _ n Mu vars x1)
        (evalOpE _ n Mu vars x2)
    inductionB :
      (P : MultPointedSemigroupTerm ->
           Set) ->
      P 1L ->
      ((x1 : MultPointedSemigroupTerm)
       (x2 : MultPointedSemigroupTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      (x : MultPointedSemigroupTerm) ->
      P x
    inductionB p p1l p*l (1L) = p1l
    inductionB p p1l p*l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p1l p*l x1)
        (inductionB p p1l p*l x2)
    inductionCl :
      (A : Set)
      (P : ClMultPointedSemigroupTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 1Cl ->
      ((x1 : ClMultPointedSemigroupTerm
          A)
       (x2 : ClMultPointedSemigroupTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      (x : ClMultPointedSemigroupTerm
         A) -> P x
    inductionCl _ p psing p1cl p*cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p1cl p*cl (1Cl) =
      p1cl
    inductionCl _ p psing p1cl p*cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p1cl p*cl
           x1)
        (inductionCl _ p psing p1cl p*cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpMultPointedSemigroupTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 1OL ->
      ((x1 : OpMultPointedSemigroupTerm
          n)
       (x2 : OpMultPointedSemigroupTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      (x : OpMultPointedSemigroupTerm
         n) -> P x
    inductionOp _ p pv p1ol p*ol (v
                                  x1) = pv x1
    inductionOp _ p pv p1ol p*ol (1OL) =
      p1ol
    inductionOp _ p pv p1ol p*ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p1ol p*ol
           x1)
        (inductionOp _ p pv p1ol p*ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpMultPointedSemigroupTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 1OL2 ->
      ((x1 : OpMultPointedSemigroupTerm2
          n
          A)
       (x2 : OpMultPointedSemigroupTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      (x : OpMultPointedSemigroupTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p1ol2 p*ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p1ol2 p*ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p1ol2 p*ol2 (1OL2) =
      p1ol2
    inductionOpE _ _ p pv2 psing2 p1ol2 p*ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p1ol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p1ol2
           p*ol2
           x2)
    1L' : MultPointedSemigroupTerm
    1L' = 1L
    *L' :
      MultPointedSemigroupTerm ->
      MultPointedSemigroupTerm ->
      MultPointedSemigroupTerm
    *L' x1 x2 = *L x1 x2
    stageB :
      MultPointedSemigroupTerm ->
      Staged MultPointedSemigroupTerm
    stageB (1L) = Now 1L
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    1Cl' :
      (A : Set) ->
      ClMultPointedSemigroupTerm A
    1Cl' _ = 1Cl
    *Cl' :
      (A : Set) ->
      ClMultPointedSemigroupTerm A ->
      ClMultPointedSemigroupTerm A ->
      ClMultPointedSemigroupTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    stageCl :
      (A : Set) ->
      ClMultPointedSemigroupTerm A ->
      Staged
        (ClMultPointedSemigroupTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (1Cl) = Now 1Cl
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    1OL' :
      (n : Nat) ->
      OpMultPointedSemigroupTerm n
    1OL' _ = 1OL
    *OL' :
      (n : Nat) ->
      OpMultPointedSemigroupTerm n ->
      OpMultPointedSemigroupTerm n ->
      OpMultPointedSemigroupTerm n
    *OL' _ x1 x2 = *OL x1 x2
    stageOp :
      (n : Nat) ->
      OpMultPointedSemigroupTerm n ->
      Staged
        (OpMultPointedSemigroupTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (1OL) = Now 1OL
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    1OL2' :
      (n : Nat) (A : Set) ->
      OpMultPointedSemigroupTerm2 n A
    1OL2' _ _ = 1OL2
    *OL2' :
      (n : Nat) (A : Set) ->
      OpMultPointedSemigroupTerm2 n
        A ->
      OpMultPointedSemigroupTerm2 n
        A ->
      OpMultPointedSemigroupTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpMultPointedSemigroupTerm2 n
        A ->
      Staged
        (OpMultPointedSemigroupTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (1OL2) = Now 1OL2
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record MultPointedSemigroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        1T : Repr A
        *T : Repr A -> Repr A -> Repr A
  
  module MultSemigroup where
    record MultSemigroup
      (A : Set) : Set where
      constructor MultSemigroupC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
    record MultSemigroupSig
      (AS : Set) : Set where
      constructor MultSemigroupSigSigC
      field
        *S : AS -> AS -> AS
    record MultSemigroupProd
      (AP : Set) : Set where
      constructor MultSemigroupProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
    record MultSemigroupHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultSemigroup A1)
      (Mu2 : MultSemigroup A2) :
      Set where
      constructor MultSemigroupHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultSemigroup A1)
      (Mu2 : MultSemigroup A2) :
      Set where
      constructor MultSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultSemigroupTerm
      : Set where
      *L :
        MultSemigroupTerm ->
        MultSemigroupTerm ->
        MultSemigroupTerm
    data ClMultSemigroupTerm
      (A : Set) : Set where
      sing :
        A -> ClMultSemigroupTerm A
      *Cl :
        ClMultSemigroupTerm A ->
        ClMultSemigroupTerm A ->
        ClMultSemigroupTerm A
    data OpMultSemigroupTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpMultSemigroupTerm n
      *OL :
        OpMultSemigroupTerm n ->
        OpMultSemigroupTerm n ->
        OpMultSemigroupTerm n
    data OpMultSemigroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpMultSemigroupTerm2 n A
      sing2 :
        A -> OpMultSemigroupTerm2 n A
      *OL2 :
        OpMultSemigroupTerm2 n A ->
        OpMultSemigroupTerm2 n A ->
        OpMultSemigroupTerm2 n A
    simplifyB :
      MultSemigroupTerm ->
      MultSemigroupTerm
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClMultSemigroupTerm A ->
      ClMultSemigroupTerm A
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpMultSemigroupTerm n ->
      OpMultSemigroupTerm n
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpMultSemigroupTerm2 n A ->
      OpMultSemigroupTerm2 n A
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      MultSemigroup A ->
      MultSemigroupTerm -> A
    evalB _ Mu (*L x1 x2) =
      * Mu (evalB _ Mu x1)
        (evalB _ Mu x2)
    evalCl :
      (A : Set) ->
      MultSemigroup A ->
      ClMultSemigroupTerm A -> A
    evalCl _ Mu (sing x1) = x1
    evalCl _ Mu (*Cl x1 x2) =
      * Mu (evalCl _ Mu x1)
        (evalCl _ Mu x2)
    evalOp :
      (A : Set) (n : Nat) ->
      MultSemigroup A ->
      Vec A n ->
      OpMultSemigroupTerm n -> A
    evalOp _ n Mu vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Mu vars (*OL x1 x2) =
      * Mu (evalOp _ n Mu vars x1)
        (evalOp _ n Mu vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      MultSemigroup A ->
      Vec A n ->
      OpMultSemigroupTerm2 n A -> A
    evalOpE _ n Mu vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Mu vars (sing2 x1) =
      x1
    evalOpE _ n Mu vars (*OL2
                         x1
                         x2) =
      * Mu (evalOpE _ n Mu vars x1)
        (evalOpE _ n Mu vars x2)
    inductionB :
      (P : MultSemigroupTerm ->
           Set) ->
      ((x1 : MultSemigroupTerm)
       (x2 : MultSemigroupTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      (x : MultSemigroupTerm) -> P x
    inductionB p p*l (*L x1 x2) =
      p*l _ _ (inductionB p p*l x1)
        (inductionB p p*l x2)
    inductionCl :
      (A : Set)
      (P : ClMultSemigroupTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClMultSemigroupTerm A)
       (x2 : ClMultSemigroupTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      (x : ClMultSemigroupTerm A) ->
      P x
    inductionCl _ p psing p*cl (sing
                                x1) = psing x1
    inductionCl _ p psing p*cl (*Cl
                                x1
                                x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl x1)
        (inductionCl _ p psing p*cl x2)
    inductionOp :
      (n : Nat)
      (P : OpMultSemigroupTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpMultSemigroupTerm n)
       (x2 : OpMultSemigroupTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      (x : OpMultSemigroupTerm n) ->
      P x
    inductionOp _ p pv p*ol (v x1) =
      pv x1
    inductionOp _ p pv p*ol (*OL
                             x1
                             x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol x1)
        (inductionOp _ p pv p*ol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpMultSemigroupTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpMultSemigroupTerm2 n A)
       (x2 : OpMultSemigroupTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      (x : OpMultSemigroupTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 (v2
                                         x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 (sing2
                                         x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 (*OL2
                                         x1
                                         x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           x2)
    *L' :
      MultSemigroupTerm ->
      MultSemigroupTerm ->
      MultSemigroupTerm
    *L' x1 x2 = *L x1 x2
    stageB :
      MultSemigroupTerm ->
      Staged MultSemigroupTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClMultSemigroupTerm A ->
      ClMultSemigroupTerm A ->
      ClMultSemigroupTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    stageCl :
      (A : Set) ->
      ClMultSemigroupTerm A ->
      Staged (ClMultSemigroupTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpMultSemigroupTerm n ->
      OpMultSemigroupTerm n ->
      OpMultSemigroupTerm n
    *OL' _ x1 x2 = *OL x1 x2
    stageOp :
      (n : Nat) ->
      OpMultSemigroupTerm n ->
      Staged (OpMultSemigroupTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpMultSemigroupTerm2 n A ->
      OpMultSemigroupTerm2 n A ->
      OpMultSemigroupTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpMultSemigroupTerm2 n A ->
      Staged
        (OpMultSemigroupTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record MultSemigroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
  
  module MultSemilattice_RingoidSig where
    record MultSemilattice_RingoidSig
      (A : Set) : Set where
      constructor MultSemilattice_RingoidSigC
      field
        * : A -> A -> A
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        idempotent_* :
          (x : A) -> * x x == x
        + : A -> A -> A
    record MultSemilattice_RingoidSigSig
      (AS : Set) : Set where
      constructor MultSemilattice_RingoidSigSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record MultSemilattice_RingoidSigProd
      (AP : Set) : Set where
      constructor MultSemilattice_RingoidSigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        idempotent_*P :
          (xP : Prod AP AP) ->
          *P xP xP == xP
    record MultSemilattice_RingoidSigHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultSemilattice_RingoidSig
         A1)
      (Mu2 : MultSemilattice_RingoidSig
         A2) : Set where
      constructor MultSemilattice_RingoidSigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Mu1 x1 x2) ==
            + Mu2 (hom x1) (hom x2)
    record MultSemilattice_RingoidSigRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultSemilattice_RingoidSig
         A1)
      (Mu2 : MultSemilattice_RingoidSig
         A2) : Set where
      constructor MultSemilattice_RingoidSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Mu1 x1 x2)
            (+ Mu2 y1 y2)
    data MultSemilattice_RingoidSigTerm
      : Set where
      *L :
        MultSemilattice_RingoidSigTerm ->
        MultSemilattice_RingoidSigTerm ->
        MultSemilattice_RingoidSigTerm
      +L :
        MultSemilattice_RingoidSigTerm ->
        MultSemilattice_RingoidSigTerm ->
        MultSemilattice_RingoidSigTerm
    data ClMultSemilattice_RingoidSigTerm
      (A : Set) : Set where
      sing :
        A ->
        ClMultSemilattice_RingoidSigTerm
          A
      *Cl :
        ClMultSemilattice_RingoidSigTerm
          A ->
        ClMultSemilattice_RingoidSigTerm
          A ->
        ClMultSemilattice_RingoidSigTerm
          A
      +Cl :
        ClMultSemilattice_RingoidSigTerm
          A ->
        ClMultSemilattice_RingoidSigTerm
          A ->
        ClMultSemilattice_RingoidSigTerm
          A
    data OpMultSemilattice_RingoidSigTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpMultSemilattice_RingoidSigTerm
          n
      *OL :
        OpMultSemilattice_RingoidSigTerm
          n ->
        OpMultSemilattice_RingoidSigTerm
          n ->
        OpMultSemilattice_RingoidSigTerm
          n
      +OL :
        OpMultSemilattice_RingoidSigTerm
          n ->
        OpMultSemilattice_RingoidSigTerm
          n ->
        OpMultSemilattice_RingoidSigTerm
          n
    data OpMultSemilattice_RingoidSigTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpMultSemilattice_RingoidSigTerm2
          n
          A
      sing2 :
        A ->
        OpMultSemilattice_RingoidSigTerm2
          n
          A
      *OL2 :
        OpMultSemilattice_RingoidSigTerm2
          n
          A ->
        OpMultSemilattice_RingoidSigTerm2
          n
          A ->
        OpMultSemilattice_RingoidSigTerm2
          n
          A
      +OL2 :
        OpMultSemilattice_RingoidSigTerm2
          n
          A ->
        OpMultSemilattice_RingoidSigTerm2
          n
          A ->
        OpMultSemilattice_RingoidSigTerm2
          n
          A
    simplifyB :
      MultSemilattice_RingoidSigTerm ->
      MultSemilattice_RingoidSigTerm
    simplifyB (*L x x) = x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClMultSemilattice_RingoidSigTerm
        A ->
      ClMultSemilattice_RingoidSigTerm
        A
    simplifyCl _ (*Cl x x) = x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpMultSemilattice_RingoidSigTerm
        n ->
      OpMultSemilattice_RingoidSigTerm
        n
    simplifyOp _ (*OL x x) = x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpMultSemilattice_RingoidSigTerm2
        n
        A ->
      OpMultSemilattice_RingoidSigTerm2
        n
        A
    simplifyOpE _ _ (*OL2 x x) = x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      MultSemilattice_RingoidSig A ->
      MultSemilattice_RingoidSigTerm ->
      A
    evalB _ Mu (*L x1 x2) =
      * Mu (evalB _ Mu x1)
        (evalB _ Mu x2)
    evalB _ Mu (+L x1 x2) =
      + Mu (evalB _ Mu x1)
        (evalB _ Mu x2)
    evalCl :
      (A : Set) ->
      MultSemilattice_RingoidSig A ->
      ClMultSemilattice_RingoidSigTerm
        A -> A
    evalCl _ Mu (sing x1) = x1
    evalCl _ Mu (*Cl x1 x2) =
      * Mu (evalCl _ Mu x1)
        (evalCl _ Mu x2)
    evalCl _ Mu (+Cl x1 x2) =
      + Mu (evalCl _ Mu x1)
        (evalCl _ Mu x2)
    evalOp :
      (A : Set) (n : Nat) ->
      MultSemilattice_RingoidSig A ->
      Vec A n ->
      OpMultSemilattice_RingoidSigTerm
        n -> A
    evalOp _ n Mu vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Mu vars (*OL x1 x2) =
      * Mu (evalOp _ n Mu vars x1)
        (evalOp _ n Mu vars x2)
    evalOp _ n Mu vars (+OL x1 x2) =
      + Mu (evalOp _ n Mu vars x1)
        (evalOp _ n Mu vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      MultSemilattice_RingoidSig A ->
      Vec A n ->
      OpMultSemilattice_RingoidSigTerm2
        n
        A -> A
    evalOpE _ n Mu vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Mu vars (sing2 x1) =
      x1
    evalOpE _ n Mu vars (*OL2
                         x1
                         x2) =
      * Mu (evalOpE _ n Mu vars x1)
        (evalOpE _ n Mu vars x2)
    evalOpE _ n Mu vars (+OL2
                         x1
                         x2) =
      + Mu (evalOpE _ n Mu vars x1)
        (evalOpE _ n Mu vars x2)
    inductionB :
      (P : MultSemilattice_RingoidSigTerm ->
           Set) ->
      ((x1 : MultSemilattice_RingoidSigTerm)
       (x2 : MultSemilattice_RingoidSigTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : MultSemilattice_RingoidSigTerm)
       (x2 : MultSemilattice_RingoidSigTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : MultSemilattice_RingoidSigTerm) ->
      P x
    inductionB p p*l p+l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionB p p*l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClMultSemilattice_RingoidSigTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClMultSemilattice_RingoidSigTerm
          A)
       (x2 : ClMultSemilattice_RingoidSigTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClMultSemilattice_RingoidSigTerm
          A)
       (x2 : ClMultSemilattice_RingoidSigTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClMultSemilattice_RingoidSigTerm
         A) -> P x
    inductionCl _ p psing p*cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p*cl p+cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionCl _ p psing p*cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpMultSemilattice_RingoidSigTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpMultSemilattice_RingoidSigTerm
          n)
       (x2 : OpMultSemilattice_RingoidSigTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpMultSemilattice_RingoidSigTerm
          n)
       (x2 : OpMultSemilattice_RingoidSigTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpMultSemilattice_RingoidSigTerm
         n) -> P x
    inductionOp _ p pv p*ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p*ol p+ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOp _ p pv p*ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpMultSemilattice_RingoidSigTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpMultSemilattice_RingoidSigTerm2
          n
          A)
       (x2 : OpMultSemilattice_RingoidSigTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpMultSemilattice_RingoidSigTerm2
          n
          A)
       (x2 : OpMultSemilattice_RingoidSigTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpMultSemilattice_RingoidSigTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    *L' :
      MultSemilattice_RingoidSigTerm ->
      MultSemilattice_RingoidSigTerm ->
      MultSemilattice_RingoidSigTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      MultSemilattice_RingoidSigTerm ->
      MultSemilattice_RingoidSigTerm ->
      MultSemilattice_RingoidSigTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      MultSemilattice_RingoidSigTerm ->
      Staged
        MultSemilattice_RingoidSigTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClMultSemilattice_RingoidSigTerm
        A ->
      ClMultSemilattice_RingoidSigTerm
        A ->
      ClMultSemilattice_RingoidSigTerm
        A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClMultSemilattice_RingoidSigTerm
        A ->
      ClMultSemilattice_RingoidSigTerm
        A ->
      ClMultSemilattice_RingoidSigTerm
        A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClMultSemilattice_RingoidSigTerm
        A ->
      Staged
        (ClMultSemilattice_RingoidSigTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpMultSemilattice_RingoidSigTerm
        n ->
      OpMultSemilattice_RingoidSigTerm
        n ->
      OpMultSemilattice_RingoidSigTerm
        n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpMultSemilattice_RingoidSigTerm
        n ->
      OpMultSemilattice_RingoidSigTerm
        n ->
      OpMultSemilattice_RingoidSigTerm
        n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpMultSemilattice_RingoidSigTerm
        n ->
      Staged
        (OpMultSemilattice_RingoidSigTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpMultSemilattice_RingoidSigTerm2
        n
        A ->
      OpMultSemilattice_RingoidSigTerm2
        n
        A ->
      OpMultSemilattice_RingoidSigTerm2
        n
        A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpMultSemilattice_RingoidSigTerm2
        n
        A ->
      OpMultSemilattice_RingoidSigTerm2
        n
        A ->
      OpMultSemilattice_RingoidSigTerm2
        n
        A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpMultSemilattice_RingoidSigTerm2
        n
        A ->
      Staged
        (OpMultSemilattice_RingoidSigTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record MultSemilattice_RingoidSigTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module MultUnaryAntiDistribution where
    record MultUnaryAntiDistribution
      (A : Set) : Set where
      constructor MultUnaryAntiDistributionC
      field
        prim : A -> A
        * : A -> A -> A
        antidis_prim_* :
          (x : A) (y : A) ->
          prim (* x y) ==
            * (prim y) (prim x)
    record MultUnaryAntiDistributionSig
      (AS : Set) : Set where
      constructor MultUnaryAntiDistributionSigSigC
      field
        primS : AS -> AS
        *S : AS -> AS -> AS
    record MultUnaryAntiDistributionProd
      (AP : Set) : Set where
      constructor MultUnaryAntiDistributionProdC
      field
        primP : Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        antidis_prim_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (*P xP yP) ==
            *P (primP yP) (primP xP)
    record MultUnaryAntiDistributionHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultUnaryAntiDistribution
         A1)
      (Mu2 : MultUnaryAntiDistribution
         A2) : Set where
      constructor MultUnaryAntiDistributionHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Mu1 x1) ==
            prim Mu2 (hom x1)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultUnaryAntiDistributionRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultUnaryAntiDistribution
         A1)
      (Mu2 : MultUnaryAntiDistribution
         A2) : Set where
      constructor MultUnaryAntiDistributionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Mu1 x1)
            (prim Mu2 y1)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultUnaryAntiDistributionTerm
      : Set where
      primL :
        MultUnaryAntiDistributionTerm ->
        MultUnaryAntiDistributionTerm
      *L :
        MultUnaryAntiDistributionTerm ->
        MultUnaryAntiDistributionTerm ->
        MultUnaryAntiDistributionTerm
    data ClMultUnaryAntiDistributionTerm
      (A : Set) : Set where
      sing :
        A ->
        ClMultUnaryAntiDistributionTerm
          A
      primCl :
        ClMultUnaryAntiDistributionTerm
          A ->
        ClMultUnaryAntiDistributionTerm
          A
      *Cl :
        ClMultUnaryAntiDistributionTerm
          A ->
        ClMultUnaryAntiDistributionTerm
          A ->
        ClMultUnaryAntiDistributionTerm
          A
    data OpMultUnaryAntiDistributionTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpMultUnaryAntiDistributionTerm
          n
      primOL :
        OpMultUnaryAntiDistributionTerm
          n ->
        OpMultUnaryAntiDistributionTerm
          n
      *OL :
        OpMultUnaryAntiDistributionTerm
          n ->
        OpMultUnaryAntiDistributionTerm
          n ->
        OpMultUnaryAntiDistributionTerm
          n
    data OpMultUnaryAntiDistributionTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpMultUnaryAntiDistributionTerm2
          n
          A
      sing2 :
        A ->
        OpMultUnaryAntiDistributionTerm2
          n
          A
      primOL2 :
        OpMultUnaryAntiDistributionTerm2
          n
          A ->
        OpMultUnaryAntiDistributionTerm2
          n
          A
      *OL2 :
        OpMultUnaryAntiDistributionTerm2
          n
          A ->
        OpMultUnaryAntiDistributionTerm2
          n
          A ->
        OpMultUnaryAntiDistributionTerm2
          n
          A
    simplifyB :
      MultUnaryAntiDistributionTerm ->
      MultUnaryAntiDistributionTerm
    simplifyB (*L
               (primL y)
               (primL x)) = primL (*L x y)
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClMultUnaryAntiDistributionTerm
        A ->
      ClMultUnaryAntiDistributionTerm
        A
    simplifyCl _ (*Cl
                  (primCl y)
                  (primCl x)) = primCl (*Cl x y)
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpMultUnaryAntiDistributionTerm
        n ->
      OpMultUnaryAntiDistributionTerm
        n
    simplifyOp _ (*OL
                  (primOL y)
                  (primOL x)) = primOL (*OL x y)
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpMultUnaryAntiDistributionTerm2
        n
        A ->
      OpMultUnaryAntiDistributionTerm2
        n
        A
    simplifyOpE _ _ (*OL2
                     (primOL2 y)
                     (primOL2 x)) =
      primOL2 (*OL2 x y)
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      MultUnaryAntiDistribution A ->
      MultUnaryAntiDistributionTerm ->
      A
    evalB _ Mu (primL x1) =
      prim Mu (evalB _ Mu x1)
    evalB _ Mu (*L x1 x2) =
      * Mu (evalB _ Mu x1)
        (evalB _ Mu x2)
    evalCl :
      (A : Set) ->
      MultUnaryAntiDistribution A ->
      ClMultUnaryAntiDistributionTerm
        A -> A
    evalCl _ Mu (sing x1) = x1
    evalCl _ Mu (primCl x1) =
      prim Mu (evalCl _ Mu x1)
    evalCl _ Mu (*Cl x1 x2) =
      * Mu (evalCl _ Mu x1)
        (evalCl _ Mu x2)
    evalOp :
      (A : Set) (n : Nat) ->
      MultUnaryAntiDistribution A ->
      Vec A n ->
      OpMultUnaryAntiDistributionTerm
        n -> A
    evalOp _ n Mu vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Mu vars (primOL x1) =
      prim Mu (evalOp _ n Mu vars x1)
    evalOp _ n Mu vars (*OL x1 x2) =
      * Mu (evalOp _ n Mu vars x1)
        (evalOp _ n Mu vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      MultUnaryAntiDistribution A ->
      Vec A n ->
      OpMultUnaryAntiDistributionTerm2
        n
        A -> A
    evalOpE _ n Mu vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Mu vars (sing2 x1) =
      x1
    evalOpE _ n Mu vars (primOL2
                         x1) =
      prim Mu (evalOpE _ n Mu vars x1)
    evalOpE _ n Mu vars (*OL2
                         x1
                         x2) =
      * Mu (evalOpE _ n Mu vars x1)
        (evalOpE _ n Mu vars x2)
    inductionB :
      (P : MultUnaryAntiDistributionTerm ->
           Set) ->
      ((x1 : MultUnaryAntiDistributionTerm) ->
       P x1 -> P (primL x1)) ->
      ((x1 : MultUnaryAntiDistributionTerm)
       (x2 : MultUnaryAntiDistributionTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      (x : MultUnaryAntiDistributionTerm) ->
      P x
    inductionB p ppriml p*l (primL
                             x1) =
      ppriml _
        (inductionB p ppriml p*l x1)
    inductionB p ppriml p*l (*L
                             x1
                             x2) =
      p*l _ _
        (inductionB p ppriml p*l x1)
        (inductionB p ppriml p*l x2)
    inductionCl :
      (A : Set)
      (P : ClMultUnaryAntiDistributionTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClMultUnaryAntiDistributionTerm
          A) -> P x1 -> P (primCl x1)) ->
      ((x1 : ClMultUnaryAntiDistributionTerm
          A)
       (x2 : ClMultUnaryAntiDistributionTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      (x : ClMultUnaryAntiDistributionTerm
         A) -> P x
    inductionCl _ p psing pprimcl p*cl (sing
                                        x1) = psing x1
    inductionCl _ p psing pprimcl p*cl (primCl
                                        x1) =
      pprimcl _
        (inductionCl _ p psing pprimcl
           p*cl
           x1)
    inductionCl _ p psing pprimcl p*cl (*Cl
                                        x1
                                        x2) =
      p*cl _ _
        (inductionCl _ p psing pprimcl
           p*cl
           x1)
        (inductionCl _ p psing pprimcl
           p*cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpMultUnaryAntiDistributionTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpMultUnaryAntiDistributionTerm
          n) -> P x1 -> P (primOL x1)) ->
      ((x1 : OpMultUnaryAntiDistributionTerm
          n)
       (x2 : OpMultUnaryAntiDistributionTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      (x : OpMultUnaryAntiDistributionTerm
         n) -> P x
    inductionOp _ p pv pprimol p*ol (v
                                     x1) = pv x1
    inductionOp _ p pv pprimol p*ol (primOL
                                     x1) =
      pprimol _
        (inductionOp _ p pv pprimol p*ol
           x1)
    inductionOp _ p pv pprimol p*ol (*OL
                                     x1
                                     x2) =
      p*ol _ _
        (inductionOp _ p pv pprimol p*ol
           x1)
        (inductionOp _ p pv pprimol p*ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpMultUnaryAntiDistributionTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpMultUnaryAntiDistributionTerm2
          n
          A) -> P x1 -> P (primOL2 x1)) ->
      ((x1 : OpMultUnaryAntiDistributionTerm2
          n
          A)
       (x2 : OpMultUnaryAntiDistributionTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      (x : OpMultUnaryAntiDistributionTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 pprimol2 p*ol2 (v2
                                                  x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 p*ol2 (sing2
                                                  x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 p*ol2 (primOL2
                                                  x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           p*ol2
           x1)
    inductionOpE _ _ p pv2 psing2 pprimol2 p*ol2 (*OL2
                                                  x1
                                                  x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           p*ol2
           x2)
    primL' :
      MultUnaryAntiDistributionTerm ->
      MultUnaryAntiDistributionTerm
    primL' x1 = primL x1
    *L' :
      MultUnaryAntiDistributionTerm ->
      MultUnaryAntiDistributionTerm ->
      MultUnaryAntiDistributionTerm
    *L' x1 x2 = *L x1 x2
    stageB :
      MultUnaryAntiDistributionTerm ->
      Staged
        MultUnaryAntiDistributionTerm
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    primCl' :
      (A : Set) ->
      ClMultUnaryAntiDistributionTerm
        A ->
      ClMultUnaryAntiDistributionTerm
        A
    primCl' _ x1 = primCl x1
    *Cl' :
      (A : Set) ->
      ClMultUnaryAntiDistributionTerm
        A ->
      ClMultUnaryAntiDistributionTerm
        A ->
      ClMultUnaryAntiDistributionTerm
        A
    *Cl' _ x1 x2 = *Cl x1 x2
    stageCl :
      (A : Set) ->
      ClMultUnaryAntiDistributionTerm
        A ->
      Staged
        (ClMultUnaryAntiDistributionTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    primOL' :
      (n : Nat) ->
      OpMultUnaryAntiDistributionTerm
        n ->
      OpMultUnaryAntiDistributionTerm
        n
    primOL' _ x1 = primOL x1
    *OL' :
      (n : Nat) ->
      OpMultUnaryAntiDistributionTerm
        n ->
      OpMultUnaryAntiDistributionTerm
        n ->
      OpMultUnaryAntiDistributionTerm
        n
    *OL' _ x1 x2 = *OL x1 x2
    stageOp :
      (n : Nat) ->
      OpMultUnaryAntiDistributionTerm
        n ->
      Staged
        (OpMultUnaryAntiDistributionTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    primOL2' :
      (n : Nat) (A : Set) ->
      OpMultUnaryAntiDistributionTerm2
        n
        A ->
      OpMultUnaryAntiDistributionTerm2
        n
        A
    primOL2' _ _ x1 = primOL2 x1
    *OL2' :
      (n : Nat) (A : Set) ->
      OpMultUnaryAntiDistributionTerm2
        n
        A ->
      OpMultUnaryAntiDistributionTerm2
        n
        A ->
      OpMultUnaryAntiDistributionTerm2
        n
        A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpMultUnaryAntiDistributionTerm2
        n
        A ->
      Staged
        (OpMultUnaryAntiDistributionTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record MultUnaryAntiDistributionTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        primT : Repr A -> Repr A
        *T : Repr A -> Repr A -> Repr A
  
  module MultUnital where
    record MultUnital
      (A : Set) : Set where
      constructor MultUnitalC
      field
        1 : A
        * : A -> A -> A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
    record MultUnitalSig
      (AS : Set) : Set where
      constructor MultUnitalSigSigC
      field
        1S : AS
        *S : AS -> AS -> AS
    record MultUnitalProd
      (AP : Set) : Set where
      constructor MultUnitalProdC
      field
        1P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
    record MultUnitalHom
      (A1 : Set) (A2 : Set)
      (Mu1 : MultUnital A1)
      (Mu2 : MultUnital A2) :
      Set where
      constructor MultUnitalHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Mu1) == 1 Mu2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Mu1 x1 x2) ==
            * Mu2 (hom x1) (hom x2)
    record MultUnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Mu1 : MultUnital A1)
      (Mu2 : MultUnital A2) :
      Set where
      constructor MultUnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Mu1) (1 Mu2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Mu1 x1 x2)
            (* Mu2 y1 y2)
    data MultUnitalTerm : Set where
      1L : MultUnitalTerm
      *L :
        MultUnitalTerm ->
        MultUnitalTerm -> MultUnitalTerm
    data ClMultUnitalTerm
      (A : Set) : Set where
      sing : A -> ClMultUnitalTerm A
      1Cl : ClMultUnitalTerm A
      *Cl :
        ClMultUnitalTerm A ->
        ClMultUnitalTerm A ->
        ClMultUnitalTerm A
    data OpMultUnitalTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpMultUnitalTerm n
      1OL : OpMultUnitalTerm n
      *OL :
        OpMultUnitalTerm n ->
        OpMultUnitalTerm n ->
        OpMultUnitalTerm n
    data OpMultUnitalTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpMultUnitalTerm2 n A
      sing2 :
        A -> OpMultUnitalTerm2 n A
      1OL2 : OpMultUnitalTerm2 n A
      *OL2 :
        OpMultUnitalTerm2 n A ->
        OpMultUnitalTerm2 n A ->
        OpMultUnitalTerm2 n A
    simplifyB :
      MultUnitalTerm -> MultUnitalTerm
    simplifyB (*L (1L) x) = x
    simplifyB (*L x (1L)) = x
    simplifyB (1L) = 1L
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClMultUnitalTerm A ->
      ClMultUnitalTerm A
    simplifyCl _ (*Cl (1Cl) x) = x
    simplifyCl _ (*Cl x (1Cl)) = x
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpMultUnitalTerm n ->
      OpMultUnitalTerm n
    simplifyOp _ (*OL (1OL) x) = x
    simplifyOp _ (*OL x (1OL)) = x
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpMultUnitalTerm2 n A ->
      OpMultUnitalTerm2 n A
    simplifyOpE _ _ (*OL2
                     (1OL2)
                     x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (1OL2)) = x
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      MultUnital A ->
      MultUnitalTerm -> A
    evalB _ Mu (1L) = 1 Mu
    evalB _ Mu (*L x1 x2) =
      * Mu (evalB _ Mu x1)
        (evalB _ Mu x2)
    evalCl :
      (A : Set) ->
      MultUnital A ->
      ClMultUnitalTerm A -> A
    evalCl _ Mu (sing x1) = x1
    evalCl _ Mu (1Cl) = 1 Mu
    evalCl _ Mu (*Cl x1 x2) =
      * Mu (evalCl _ Mu x1)
        (evalCl _ Mu x2)
    evalOp :
      (A : Set) (n : Nat) ->
      MultUnital A ->
      Vec A n ->
      OpMultUnitalTerm n -> A
    evalOp _ n Mu vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Mu vars (1OL) = 1 Mu
    evalOp _ n Mu vars (*OL x1 x2) =
      * Mu (evalOp _ n Mu vars x1)
        (evalOp _ n Mu vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      MultUnital A ->
      Vec A n ->
      OpMultUnitalTerm2 n A -> A
    evalOpE _ n Mu vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Mu vars (sing2 x1) =
      x1
    evalOpE _ n Mu vars (1OL2) =
      1 Mu
    evalOpE _ n Mu vars (*OL2
                         x1
                         x2) =
      * Mu (evalOpE _ n Mu vars x1)
        (evalOpE _ n Mu vars x2)
    inductionB :
      (P : MultUnitalTerm -> Set) ->
      P 1L ->
      ((x1 : MultUnitalTerm)
       (x2 : MultUnitalTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      (x : MultUnitalTerm) -> P x
    inductionB p p1l p*l (1L) = p1l
    inductionB p p1l p*l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p1l p*l x1)
        (inductionB p p1l p*l x2)
    inductionCl :
      (A : Set)
      (P : ClMultUnitalTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 1Cl ->
      ((x1 : ClMultUnitalTerm A)
       (x2 : ClMultUnitalTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      (x : ClMultUnitalTerm A) -> P x
    inductionCl _ p psing p1cl p*cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p1cl p*cl (1Cl) =
      p1cl
    inductionCl _ p psing p1cl p*cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p1cl p*cl
           x1)
        (inductionCl _ p psing p1cl p*cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpMultUnitalTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 1OL ->
      ((x1 : OpMultUnitalTerm n)
       (x2 : OpMultUnitalTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      (x : OpMultUnitalTerm n) -> P x
    inductionOp _ p pv p1ol p*ol (v
                                  x1) = pv x1
    inductionOp _ p pv p1ol p*ol (1OL) =
      p1ol
    inductionOp _ p pv p1ol p*ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p1ol p*ol
           x1)
        (inductionOp _ p pv p1ol p*ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpMultUnitalTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 1OL2 ->
      ((x1 : OpMultUnitalTerm2 n A)
       (x2 : OpMultUnitalTerm2 n A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      (x : OpMultUnitalTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p1ol2 p*ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p1ol2 p*ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p1ol2 p*ol2 (1OL2) =
      p1ol2
    inductionOpE _ _ p pv2 psing2 p1ol2 p*ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p1ol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p1ol2
           p*ol2
           x2)
    1L' : MultUnitalTerm
    1L' = 1L
    *L' :
      MultUnitalTerm ->
      MultUnitalTerm -> MultUnitalTerm
    *L' x1 x2 = *L x1 x2
    stageB :
      MultUnitalTerm ->
      Staged MultUnitalTerm
    stageB (1L) = Now 1L
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    1Cl' :
      (A : Set) -> ClMultUnitalTerm A
    1Cl' _ = 1Cl
    *Cl' :
      (A : Set) ->
      ClMultUnitalTerm A ->
      ClMultUnitalTerm A ->
      ClMultUnitalTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    stageCl :
      (A : Set) ->
      ClMultUnitalTerm A ->
      Staged (ClMultUnitalTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (1Cl) = Now 1Cl
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    1OL' :
      (n : Nat) -> OpMultUnitalTerm n
    1OL' _ = 1OL
    *OL' :
      (n : Nat) ->
      OpMultUnitalTerm n ->
      OpMultUnitalTerm n ->
      OpMultUnitalTerm n
    *OL' _ x1 x2 = *OL x1 x2
    stageOp :
      (n : Nat) ->
      OpMultUnitalTerm n ->
      Staged (OpMultUnitalTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (1OL) = Now 1OL
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    1OL2' :
      (n : Nat) (A : Set) ->
      OpMultUnitalTerm2 n A
    1OL2' _ _ = 1OL2
    *OL2' :
      (n : Nat) (A : Set) ->
      OpMultUnitalTerm2 n A ->
      OpMultUnitalTerm2 n A ->
      OpMultUnitalTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpMultUnitalTerm2 n A ->
      Staged (OpMultUnitalTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (1OL2) = Now 1OL2
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record MultUnitalTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        1T : Repr A
        *T : Repr A -> Repr A -> Repr A
  
  module NearRing where
    record NearRing
      (A : Set) : Set where
      constructor NearRingC
      field
        * : A -> A -> A
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record NearRingSig
      (AS : Set) : Set where
      constructor NearRingSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
    record NearRingProd
      (AP : Set) : Set where
      constructor NearRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record NearRingHom
      (A1 : Set) (A2 : Set)
      (Ne1 : NearRing A1)
      (Ne2 : NearRing A2) : Set where
      constructor NearRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ne1 x1 x2) ==
            * Ne2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ne1 x1 x2) ==
            + Ne2 (hom x1) (hom x2)
        pres-0 : hom (0 Ne1) == 0 Ne2
        pres-neg :
          (x1 : A1) ->
          hom (neg Ne1 x1) ==
            neg Ne2 (hom x1)
    record NearRingRelInterp
      (A1 : Set) (A2 : Set)
      (Ne1 : NearRing A1)
      (Ne2 : NearRing A2) : Set where
      constructor NearRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ne1 x1 x2)
            (* Ne2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ne1 x1 x2)
            (+ Ne2 y1 y2)
        interp-0 :
          interp (0 Ne1) (0 Ne2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Ne1 x1) (neg Ne2 y1)
    data NearRingTerm : Set where
      *L :
        NearRingTerm ->
        NearRingTerm -> NearRingTerm
      +L :
        NearRingTerm ->
        NearRingTerm -> NearRingTerm
      0L : NearRingTerm
      negL :
        NearRingTerm -> NearRingTerm
    data ClNearRingTerm
      (A : Set) : Set where
      sing : A -> ClNearRingTerm A
      *Cl :
        ClNearRingTerm A ->
        ClNearRingTerm A ->
        ClNearRingTerm A
      +Cl :
        ClNearRingTerm A ->
        ClNearRingTerm A ->
        ClNearRingTerm A
      0Cl : ClNearRingTerm A
      negCl :
        ClNearRingTerm A ->
        ClNearRingTerm A
    data OpNearRingTerm
      (n : Nat) : Set where
      v : Fin n -> OpNearRingTerm n
      *OL :
        OpNearRingTerm n ->
        OpNearRingTerm n ->
        OpNearRingTerm n
      +OL :
        OpNearRingTerm n ->
        OpNearRingTerm n ->
        OpNearRingTerm n
      0OL : OpNearRingTerm n
      negOL :
        OpNearRingTerm n ->
        OpNearRingTerm n
    data OpNearRingTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpNearRingTerm2 n A
      sing2 : A -> OpNearRingTerm2 n A
      *OL2 :
        OpNearRingTerm2 n A ->
        OpNearRingTerm2 n A ->
        OpNearRingTerm2 n A
      +OL2 :
        OpNearRingTerm2 n A ->
        OpNearRingTerm2 n A ->
        OpNearRingTerm2 n A
      0OL2 : OpNearRingTerm2 n A
      negOL2 :
        OpNearRingTerm2 n A ->
        OpNearRingTerm2 n A
    simplifyB :
      NearRingTerm -> NearRingTerm
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (+L x (negL x)) = 0L
    simplifyB (+L (negL x) x) = 0L
    simplifyB (+L
               (*L y x)
               (*L z x)) = *L (+L y z) x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (0L) = 0L
    simplifyB (negL x1) =
      negL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClNearRingTerm A ->
      ClNearRingTerm A
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (+Cl x (negCl x)) =
      0Cl
    simplifyCl _ (+Cl (negCl x) x) =
      0Cl
    simplifyCl _ (+Cl
                  (*Cl y x)
                  (*Cl z x)) = *Cl (+Cl y z) x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (negCl x1) =
      negCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpNearRingTerm n ->
      OpNearRingTerm n
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (+OL x (negOL x)) =
      0OL
    simplifyOp _ (+OL (negOL x) x) =
      0OL
    simplifyOp _ (+OL
                  (*OL y x)
                  (*OL z x)) = *OL (+OL y z) x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (negOL x1) =
      negOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpNearRingTerm2 n A ->
      OpNearRingTerm2 n A
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (+OL2
                     x
                     (negOL2 x)) = 0OL2
    simplifyOpE _ _ (+OL2
                     (negOL2 x)
                     x) = 0OL2
    simplifyOpE _ _ (+OL2
                     (*OL2 y x)
                     (*OL2 z x)) = *OL2 (+OL2 y z) x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (negOL2 x1) =
      negOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      NearRing A -> NearRingTerm -> A
    evalB _ Ne (*L x1 x2) =
      * Ne (evalB _ Ne x1)
        (evalB _ Ne x2)
    evalB _ Ne (+L x1 x2) =
      + Ne (evalB _ Ne x1)
        (evalB _ Ne x2)
    evalB _ Ne (0L) = 0 Ne
    evalB _ Ne (negL x1) =
      neg Ne (evalB _ Ne x1)
    evalCl :
      (A : Set) ->
      NearRing A ->
      ClNearRingTerm A -> A
    evalCl _ Ne (sing x1) = x1
    evalCl _ Ne (*Cl x1 x2) =
      * Ne (evalCl _ Ne x1)
        (evalCl _ Ne x2)
    evalCl _ Ne (+Cl x1 x2) =
      + Ne (evalCl _ Ne x1)
        (evalCl _ Ne x2)
    evalCl _ Ne (0Cl) = 0 Ne
    evalCl _ Ne (negCl x1) =
      neg Ne (evalCl _ Ne x1)
    evalOp :
      (A : Set) (n : Nat) ->
      NearRing A ->
      Vec A n -> OpNearRingTerm n -> A
    evalOp _ n Ne vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ne vars (*OL x1 x2) =
      * Ne (evalOp _ n Ne vars x1)
        (evalOp _ n Ne vars x2)
    evalOp _ n Ne vars (+OL x1 x2) =
      + Ne (evalOp _ n Ne vars x1)
        (evalOp _ n Ne vars x2)
    evalOp _ n Ne vars (0OL) = 0 Ne
    evalOp _ n Ne vars (negOL x1) =
      neg Ne (evalOp _ n Ne vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      NearRing A ->
      Vec A n ->
      OpNearRingTerm2 n A -> A
    evalOpE _ n Ne vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ne vars (sing2 x1) =
      x1
    evalOpE _ n Ne vars (*OL2
                         x1
                         x2) =
      * Ne (evalOpE _ n Ne vars x1)
        (evalOpE _ n Ne vars x2)
    evalOpE _ n Ne vars (+OL2
                         x1
                         x2) =
      + Ne (evalOpE _ n Ne vars x1)
        (evalOpE _ n Ne vars x2)
    evalOpE _ n Ne vars (0OL2) =
      0 Ne
    evalOpE _ n Ne vars (negOL2
                         x1) =
      neg Ne (evalOpE _ n Ne vars x1)
    inductionB :
      (P : NearRingTerm -> Set) ->
      ((x1 : NearRingTerm)
       (x2 : NearRingTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : NearRingTerm)
       (x2 : NearRingTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      P 0L ->
      ((x1 : NearRingTerm) ->
       P x1 -> P (negL x1)) ->
      (x : NearRingTerm) -> P x
    inductionB p p*l p+l p0l pnegl (*L
                                    x1
                                    x2) =
      p*l _ _
        (inductionB p p*l p+l p0l pnegl
           x1)
        (inductionB p p*l p+l p0l pnegl
           x2)
    inductionB p p*l p+l p0l pnegl (+L
                                    x1
                                    x2) =
      p+l _ _
        (inductionB p p*l p+l p0l pnegl
           x1)
        (inductionB p p*l p+l p0l pnegl
           x2)
    inductionB p p*l p+l p0l pnegl (0L) =
      p0l
    inductionB p p*l p+l p0l pnegl (negL
                                    x1) =
      pnegl _
        (inductionB p p*l p+l p0l pnegl
           x1)
    inductionCl :
      (A : Set)
      (P : ClNearRingTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClNearRingTerm A)
       (x2 : ClNearRingTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClNearRingTerm A)
       (x2 : ClNearRingTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      P 0Cl ->
      ((x1 : ClNearRingTerm A) ->
       P x1 -> P (negCl x1)) ->
      (x : ClNearRingTerm A) -> P x
    inductionCl _ p psing p*cl p+cl p0cl pnegcl (sing
                                                 x1) = psing x1
    inductionCl _ p psing p*cl p+cl p0cl pnegcl (*Cl
                                                 x1
                                                 x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           p0cl
           pnegcl
           x1)
        (inductionCl _ p psing p*cl p+cl
           p0cl
           pnegcl
           x2)
    inductionCl _ p psing p*cl p+cl p0cl pnegcl (+Cl
                                                 x1
                                                 x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           p0cl
           pnegcl
           x1)
        (inductionCl _ p psing p*cl p+cl
           p0cl
           pnegcl
           x2)
    inductionCl _ p psing p*cl p+cl p0cl pnegcl (0Cl) =
      p0cl
    inductionCl _ p psing p*cl p+cl p0cl pnegcl (negCl
                                                 x1) =
      pnegcl _
        (inductionCl _ p psing p*cl p+cl
           p0cl
           pnegcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpNearRingTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpNearRingTerm n)
       (x2 : OpNearRingTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpNearRingTerm n)
       (x2 : OpNearRingTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      P 0OL ->
      ((x1 : OpNearRingTerm n) ->
       P x1 -> P (negOL x1)) ->
      (x : OpNearRingTerm n) -> P x
    inductionOp _ p pv p*ol p+ol p0ol pnegol (v
                                              x1) = pv x1
    inductionOp _ p pv p*ol p+ol p0ol pnegol (*OL
                                              x1
                                              x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           p0ol
           pnegol
           x1)
        (inductionOp _ p pv p*ol p+ol
           p0ol
           pnegol
           x2)
    inductionOp _ p pv p*ol p+ol p0ol pnegol (+OL
                                              x1
                                              x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           p0ol
           pnegol
           x1)
        (inductionOp _ p pv p*ol p+ol
           p0ol
           pnegol
           x2)
    inductionOp _ p pv p*ol p+ol p0ol pnegol (0OL) =
      p0ol
    inductionOp _ p pv p*ol p+ol p0ol pnegol (negOL
                                              x1) =
      pnegol _
        (inductionOp _ p pv p*ol p+ol
           p0ol
           pnegol
           x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpNearRingTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpNearRingTerm2 n A)
       (x2 : OpNearRingTerm2 n A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpNearRingTerm2 n A)
       (x2 : OpNearRingTerm2 n A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      P 0OL2 ->
      ((x1 : OpNearRingTerm2 n A) ->
       P x1 -> P (negOL2 x1)) ->
      (x : OpNearRingTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 (v2
                                                             x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 (sing2
                                                             x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 (*OL2
                                                             x1
                                                             x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           pnegol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           pnegol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 (+OL2
                                                             x1
                                                             x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           pnegol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           pnegol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 (negOL2
                                                             x1) =
      pnegol2 _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           pnegol2
           x1)
    *L' :
      NearRingTerm ->
      NearRingTerm -> NearRingTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      NearRingTerm ->
      NearRingTerm -> NearRingTerm
    +L' x1 x2 = +L x1 x2
    0L' : NearRingTerm
    0L' = 0L
    negL' :
      NearRingTerm -> NearRingTerm
    negL' x1 = negL x1
    stageB :
      NearRingTerm ->
      Staged NearRingTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (0L) = Now 0L
    stageB (negL x1) =
      stage1 _ _ negL'
        (codeLift1 _ _ negL')
        (stageB x1)
    *Cl' :
      (A : Set) ->
      ClNearRingTerm A ->
      ClNearRingTerm A ->
      ClNearRingTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClNearRingTerm A ->
      ClNearRingTerm A ->
      ClNearRingTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    0Cl' :
      (A : Set) -> ClNearRingTerm A
    0Cl' _ = 0Cl
    negCl' :
      (A : Set) ->
      ClNearRingTerm A ->
      ClNearRingTerm A
    negCl' _ x1 = negCl x1
    stageCl :
      (A : Set) ->
      ClNearRingTerm A ->
      Staged (ClNearRingTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (negCl x1) =
      stage1 _ _ (negCl' _)
        (codeLift1 _ _ (negCl' _))
        (stageCl _ x1)
    *OL' :
      (n : Nat) ->
      OpNearRingTerm n ->
      OpNearRingTerm n ->
      OpNearRingTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpNearRingTerm n ->
      OpNearRingTerm n ->
      OpNearRingTerm n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) -> OpNearRingTerm n
    0OL' _ = 0OL
    negOL' :
      (n : Nat) ->
      OpNearRingTerm n ->
      OpNearRingTerm n
    negOL' _ x1 = negOL x1
    stageOp :
      (n : Nat) ->
      OpNearRingTerm n ->
      Staged (OpNearRingTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (0OL) = Now 0OL
    stageOp _ (negOL x1) =
      stage1 _ _ (negOL' _)
        (codeLift1 _ _ (negOL' _))
        (stageOp _ x1)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpNearRingTerm2 n A ->
      OpNearRingTerm2 n A ->
      OpNearRingTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpNearRingTerm2 n A ->
      OpNearRingTerm2 n A ->
      OpNearRingTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    0OL2' :
      (n : Nat) (A : Set) ->
      OpNearRingTerm2 n A
    0OL2' _ _ = 0OL2
    negOL2' :
      (n : Nat) (A : Set) ->
      OpNearRingTerm2 n A ->
      OpNearRingTerm2 n A
    negOL2' _ _ x1 = negOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpNearRingTerm2 n A ->
      Staged (OpNearRingTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (negOL2 x1) =
      stage1 _ _ (negOL2' _ _)
        (codeLift1 _ _ (negOL2' _ _))
        (stageOpE _ _ x1)
    record NearRingTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
        0T : Repr A
        negT : Repr A -> Repr A
  
  module NearSemiring where
    record NearSemiring
      (A : Set) : Set where
      constructor NearSemiringC
      field
        * : A -> A -> A
        + : A -> A -> A
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record NearSemiringSig
      (AS : Set) : Set where
      constructor NearSemiringSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record NearSemiringProd
      (AP : Set) : Set where
      constructor NearSemiringProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record NearSemiringHom
      (A1 : Set) (A2 : Set)
      (Ne1 : NearSemiring A1)
      (Ne2 : NearSemiring A2) :
      Set where
      constructor NearSemiringHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ne1 x1 x2) ==
            * Ne2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ne1 x1 x2) ==
            + Ne2 (hom x1) (hom x2)
    record NearSemiringRelInterp
      (A1 : Set) (A2 : Set)
      (Ne1 : NearSemiring A1)
      (Ne2 : NearSemiring A2) :
      Set where
      constructor NearSemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ne1 x1 x2)
            (* Ne2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ne1 x1 x2)
            (+ Ne2 y1 y2)
    data NearSemiringTerm
      : Set where
      *L :
        NearSemiringTerm ->
        NearSemiringTerm ->
        NearSemiringTerm
      +L :
        NearSemiringTerm ->
        NearSemiringTerm ->
        NearSemiringTerm
    data ClNearSemiringTerm
      (A : Set) : Set where
      sing :
        A -> ClNearSemiringTerm A
      *Cl :
        ClNearSemiringTerm A ->
        ClNearSemiringTerm A ->
        ClNearSemiringTerm A
      +Cl :
        ClNearSemiringTerm A ->
        ClNearSemiringTerm A ->
        ClNearSemiringTerm A
    data OpNearSemiringTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpNearSemiringTerm n
      *OL :
        OpNearSemiringTerm n ->
        OpNearSemiringTerm n ->
        OpNearSemiringTerm n
      +OL :
        OpNearSemiringTerm n ->
        OpNearSemiringTerm n ->
        OpNearSemiringTerm n
    data OpNearSemiringTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpNearSemiringTerm2 n A
      sing2 :
        A -> OpNearSemiringTerm2 n A
      *OL2 :
        OpNearSemiringTerm2 n A ->
        OpNearSemiringTerm2 n A ->
        OpNearSemiringTerm2 n A
      +OL2 :
        OpNearSemiringTerm2 n A ->
        OpNearSemiringTerm2 n A ->
        OpNearSemiringTerm2 n A
    simplifyB :
      NearSemiringTerm ->
      NearSemiringTerm
    simplifyB (+L
               (*L y x)
               (*L z x)) = *L (+L y z) x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClNearSemiringTerm A ->
      ClNearSemiringTerm A
    simplifyCl _ (+Cl
                  (*Cl y x)
                  (*Cl z x)) = *Cl (+Cl y z) x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpNearSemiringTerm n ->
      OpNearSemiringTerm n
    simplifyOp _ (+OL
                  (*OL y x)
                  (*OL z x)) = *OL (+OL y z) x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpNearSemiringTerm2 n A ->
      OpNearSemiringTerm2 n A
    simplifyOpE _ _ (+OL2
                     (*OL2 y x)
                     (*OL2 z x)) = *OL2 (+OL2 y z) x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      NearSemiring A ->
      NearSemiringTerm -> A
    evalB _ Ne (*L x1 x2) =
      * Ne (evalB _ Ne x1)
        (evalB _ Ne x2)
    evalB _ Ne (+L x1 x2) =
      + Ne (evalB _ Ne x1)
        (evalB _ Ne x2)
    evalCl :
      (A : Set) ->
      NearSemiring A ->
      ClNearSemiringTerm A -> A
    evalCl _ Ne (sing x1) = x1
    evalCl _ Ne (*Cl x1 x2) =
      * Ne (evalCl _ Ne x1)
        (evalCl _ Ne x2)
    evalCl _ Ne (+Cl x1 x2) =
      + Ne (evalCl _ Ne x1)
        (evalCl _ Ne x2)
    evalOp :
      (A : Set) (n : Nat) ->
      NearSemiring A ->
      Vec A n ->
      OpNearSemiringTerm n -> A
    evalOp _ n Ne vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ne vars (*OL x1 x2) =
      * Ne (evalOp _ n Ne vars x1)
        (evalOp _ n Ne vars x2)
    evalOp _ n Ne vars (+OL x1 x2) =
      + Ne (evalOp _ n Ne vars x1)
        (evalOp _ n Ne vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      NearSemiring A ->
      Vec A n ->
      OpNearSemiringTerm2 n A -> A
    evalOpE _ n Ne vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ne vars (sing2 x1) =
      x1
    evalOpE _ n Ne vars (*OL2
                         x1
                         x2) =
      * Ne (evalOpE _ n Ne vars x1)
        (evalOpE _ n Ne vars x2)
    evalOpE _ n Ne vars (+OL2
                         x1
                         x2) =
      + Ne (evalOpE _ n Ne vars x1)
        (evalOpE _ n Ne vars x2)
    inductionB :
      (P : NearSemiringTerm -> Set) ->
      ((x1 : NearSemiringTerm)
       (x2 : NearSemiringTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : NearSemiringTerm)
       (x2 : NearSemiringTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : NearSemiringTerm) -> P x
    inductionB p p*l p+l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionB p p*l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClNearSemiringTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClNearSemiringTerm A)
       (x2 : ClNearSemiringTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClNearSemiringTerm A)
       (x2 : ClNearSemiringTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClNearSemiringTerm A) ->
      P x
    inductionCl _ p psing p*cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p*cl p+cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionCl _ p psing p*cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpNearSemiringTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpNearSemiringTerm n)
       (x2 : OpNearSemiringTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpNearSemiringTerm n)
       (x2 : OpNearSemiringTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpNearSemiringTerm n) ->
      P x
    inductionOp _ p pv p*ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p*ol p+ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOp _ p pv p*ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpNearSemiringTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpNearSemiringTerm2 n A)
       (x2 : OpNearSemiringTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpNearSemiringTerm2 n A)
       (x2 : OpNearSemiringTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpNearSemiringTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    *L' :
      NearSemiringTerm ->
      NearSemiringTerm ->
      NearSemiringTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      NearSemiringTerm ->
      NearSemiringTerm ->
      NearSemiringTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      NearSemiringTerm ->
      Staged NearSemiringTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClNearSemiringTerm A ->
      ClNearSemiringTerm A ->
      ClNearSemiringTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClNearSemiringTerm A ->
      ClNearSemiringTerm A ->
      ClNearSemiringTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClNearSemiringTerm A ->
      Staged (ClNearSemiringTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpNearSemiringTerm n ->
      OpNearSemiringTerm n ->
      OpNearSemiringTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpNearSemiringTerm n ->
      OpNearSemiringTerm n ->
      OpNearSemiringTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpNearSemiringTerm n ->
      Staged (OpNearSemiringTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpNearSemiringTerm2 n A ->
      OpNearSemiringTerm2 n A ->
      OpNearSemiringTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpNearSemiringTerm2 n A ->
      OpNearSemiringTerm2 n A ->
      OpNearSemiringTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpNearSemiringTerm2 n A ->
      Staged (OpNearSemiringTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record NearSemiringTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module NonDistributiveAddPreSemiring where
    record NonDistributiveAddPreSemiring
      (A : Set) : Set where
      constructor NonDistributiveAddPreSemiringC
      field
        + : A -> A -> A
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        * : A -> A -> A
    record NonDistributiveAddPreSemiringSig
      (AS : Set) : Set where
      constructor NonDistributiveAddPreSemiringSigSigC
      field
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
    record NonDistributiveAddPreSemiringProd
      (AP : Set) : Set where
      constructor NonDistributiveAddPreSemiringProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record NonDistributiveAddPreSemiringHom
      (A1 : Set) (A2 : Set)
      (No1 : NonDistributiveAddPreSemiring
         A1)
      (No2 : NonDistributiveAddPreSemiring
         A2) : Set where
      constructor NonDistributiveAddPreSemiringHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ No1 x1 x2) ==
            + No2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* No1 x1 x2) ==
            * No2 (hom x1) (hom x2)
    record NonDistributiveAddPreSemiringRelInterp
      (A1 : Set) (A2 : Set)
      (No1 : NonDistributiveAddPreSemiring
         A1)
      (No2 : NonDistributiveAddPreSemiring
         A2) : Set where
      constructor NonDistributiveAddPreSemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ No1 x1 x2)
            (+ No2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* No1 x1 x2)
            (* No2 y1 y2)
    data NonDistributiveAddPreSemiringTerm
      : Set where
      +L :
        NonDistributiveAddPreSemiringTerm ->
        NonDistributiveAddPreSemiringTerm ->
        NonDistributiveAddPreSemiringTerm
      *L :
        NonDistributiveAddPreSemiringTerm ->
        NonDistributiveAddPreSemiringTerm ->
        NonDistributiveAddPreSemiringTerm
    data ClNonDistributiveAddPreSemiringTerm
      (A : Set) : Set where
      sing :
        A ->
        ClNonDistributiveAddPreSemiringTerm
          A
      +Cl :
        ClNonDistributiveAddPreSemiringTerm
          A ->
        ClNonDistributiveAddPreSemiringTerm
          A ->
        ClNonDistributiveAddPreSemiringTerm
          A
      *Cl :
        ClNonDistributiveAddPreSemiringTerm
          A ->
        ClNonDistributiveAddPreSemiringTerm
          A ->
        ClNonDistributiveAddPreSemiringTerm
          A
    data OpNonDistributiveAddPreSemiringTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpNonDistributiveAddPreSemiringTerm
          n
      +OL :
        OpNonDistributiveAddPreSemiringTerm
          n ->
        OpNonDistributiveAddPreSemiringTerm
          n ->
        OpNonDistributiveAddPreSemiringTerm
          n
      *OL :
        OpNonDistributiveAddPreSemiringTerm
          n ->
        OpNonDistributiveAddPreSemiringTerm
          n ->
        OpNonDistributiveAddPreSemiringTerm
          n
    data OpNonDistributiveAddPreSemiringTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpNonDistributiveAddPreSemiringTerm2
          n
          A
      sing2 :
        A ->
        OpNonDistributiveAddPreSemiringTerm2
          n
          A
      +OL2 :
        OpNonDistributiveAddPreSemiringTerm2
          n
          A ->
        OpNonDistributiveAddPreSemiringTerm2
          n
          A ->
        OpNonDistributiveAddPreSemiringTerm2
          n
          A
      *OL2 :
        OpNonDistributiveAddPreSemiringTerm2
          n
          A ->
        OpNonDistributiveAddPreSemiringTerm2
          n
          A ->
        OpNonDistributiveAddPreSemiringTerm2
          n
          A
    simplifyB :
      NonDistributiveAddPreSemiringTerm ->
      NonDistributiveAddPreSemiringTerm
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClNonDistributiveAddPreSemiringTerm
        A ->
      ClNonDistributiveAddPreSemiringTerm
        A
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpNonDistributiveAddPreSemiringTerm
        n ->
      OpNonDistributiveAddPreSemiringTerm
        n
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpNonDistributiveAddPreSemiringTerm2
        n
        A ->
      OpNonDistributiveAddPreSemiringTerm2
        n
        A
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      NonDistributiveAddPreSemiring
        A ->
      NonDistributiveAddPreSemiringTerm ->
      A
    evalB _ No (+L x1 x2) =
      + No (evalB _ No x1)
        (evalB _ No x2)
    evalB _ No (*L x1 x2) =
      * No (evalB _ No x1)
        (evalB _ No x2)
    evalCl :
      (A : Set) ->
      NonDistributiveAddPreSemiring
        A ->
      ClNonDistributiveAddPreSemiringTerm
        A -> A
    evalCl _ No (sing x1) = x1
    evalCl _ No (+Cl x1 x2) =
      + No (evalCl _ No x1)
        (evalCl _ No x2)
    evalCl _ No (*Cl x1 x2) =
      * No (evalCl _ No x1)
        (evalCl _ No x2)
    evalOp :
      (A : Set) (n : Nat) ->
      NonDistributiveAddPreSemiring
        A ->
      Vec A n ->
      OpNonDistributiveAddPreSemiringTerm
        n -> A
    evalOp _ n No vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n No vars (+OL x1 x2) =
      + No (evalOp _ n No vars x1)
        (evalOp _ n No vars x2)
    evalOp _ n No vars (*OL x1 x2) =
      * No (evalOp _ n No vars x1)
        (evalOp _ n No vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      NonDistributiveAddPreSemiring
        A ->
      Vec A n ->
      OpNonDistributiveAddPreSemiringTerm2
        n
        A -> A
    evalOpE _ n No vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n No vars (sing2 x1) =
      x1
    evalOpE _ n No vars (+OL2
                         x1
                         x2) =
      + No (evalOpE _ n No vars x1)
        (evalOpE _ n No vars x2)
    evalOpE _ n No vars (*OL2
                         x1
                         x2) =
      * No (evalOpE _ n No vars x1)
        (evalOpE _ n No vars x2)
    inductionB :
      (P : NonDistributiveAddPreSemiringTerm ->
           Set) ->
      ((x1 : NonDistributiveAddPreSemiringTerm)
       (x2 : NonDistributiveAddPreSemiringTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      ((x1 : NonDistributiveAddPreSemiringTerm)
       (x2 : NonDistributiveAddPreSemiringTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      (x : NonDistributiveAddPreSemiringTerm) ->
      P x
    inductionB p p+l p*l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p+l p*l x1)
        (inductionB p p+l p*l x2)
    inductionB p p+l p*l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p+l p*l x1)
        (inductionB p p+l p*l x2)
    inductionCl :
      (A : Set)
      (P : ClNonDistributiveAddPreSemiringTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClNonDistributiveAddPreSemiringTerm
          A)
       (x2 : ClNonDistributiveAddPreSemiringTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      ((x1 : ClNonDistributiveAddPreSemiringTerm
          A)
       (x2 : ClNonDistributiveAddPreSemiringTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      (x : ClNonDistributiveAddPreSemiringTerm
         A) -> P x
    inductionCl _ p psing p+cl p*cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p+cl p*cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p+cl p*cl
           x1)
        (inductionCl _ p psing p+cl p*cl
           x2)
    inductionCl _ p psing p+cl p*cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p+cl p*cl
           x1)
        (inductionCl _ p psing p+cl p*cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpNonDistributiveAddPreSemiringTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpNonDistributiveAddPreSemiringTerm
          n)
       (x2 : OpNonDistributiveAddPreSemiringTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      ((x1 : OpNonDistributiveAddPreSemiringTerm
          n)
       (x2 : OpNonDistributiveAddPreSemiringTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      (x : OpNonDistributiveAddPreSemiringTerm
         n) -> P x
    inductionOp _ p pv p+ol p*ol (v
                                  x1) = pv x1
    inductionOp _ p pv p+ol p*ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p+ol p*ol
           x1)
        (inductionOp _ p pv p+ol p*ol
           x2)
    inductionOp _ p pv p+ol p*ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p+ol p*ol
           x1)
        (inductionOp _ p pv p+ol p*ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpNonDistributiveAddPreSemiringTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpNonDistributiveAddPreSemiringTerm2
          n
          A)
       (x2 : OpNonDistributiveAddPreSemiringTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      ((x1 : OpNonDistributiveAddPreSemiringTerm2
          n
          A)
       (x2 : OpNonDistributiveAddPreSemiringTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      (x : OpNonDistributiveAddPreSemiringTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p+ol2 p*ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 p*ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 p*ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p*ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p+ol2 p*ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           p*ol2
           x2)
    +L' :
      NonDistributiveAddPreSemiringTerm ->
      NonDistributiveAddPreSemiringTerm ->
      NonDistributiveAddPreSemiringTerm
    +L' x1 x2 = +L x1 x2
    *L' :
      NonDistributiveAddPreSemiringTerm ->
      NonDistributiveAddPreSemiringTerm ->
      NonDistributiveAddPreSemiringTerm
    *L' x1 x2 = *L x1 x2
    stageB :
      NonDistributiveAddPreSemiringTerm ->
      Staged
        NonDistributiveAddPreSemiringTerm
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    +Cl' :
      (A : Set) ->
      ClNonDistributiveAddPreSemiringTerm
        A ->
      ClNonDistributiveAddPreSemiringTerm
        A ->
      ClNonDistributiveAddPreSemiringTerm
        A
    +Cl' _ x1 x2 = +Cl x1 x2
    *Cl' :
      (A : Set) ->
      ClNonDistributiveAddPreSemiringTerm
        A ->
      ClNonDistributiveAddPreSemiringTerm
        A ->
      ClNonDistributiveAddPreSemiringTerm
        A
    *Cl' _ x1 x2 = *Cl x1 x2
    stageCl :
      (A : Set) ->
      ClNonDistributiveAddPreSemiringTerm
        A ->
      Staged
        (ClNonDistributiveAddPreSemiringTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    +OL' :
      (n : Nat) ->
      OpNonDistributiveAddPreSemiringTerm
        n ->
      OpNonDistributiveAddPreSemiringTerm
        n ->
      OpNonDistributiveAddPreSemiringTerm
        n
    +OL' _ x1 x2 = +OL x1 x2
    *OL' :
      (n : Nat) ->
      OpNonDistributiveAddPreSemiringTerm
        n ->
      OpNonDistributiveAddPreSemiringTerm
        n ->
      OpNonDistributiveAddPreSemiringTerm
        n
    *OL' _ x1 x2 = *OL x1 x2
    stageOp :
      (n : Nat) ->
      OpNonDistributiveAddPreSemiringTerm
        n ->
      Staged
        (OpNonDistributiveAddPreSemiringTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    +OL2' :
      (n : Nat) (A : Set) ->
      OpNonDistributiveAddPreSemiringTerm2
        n
        A ->
      OpNonDistributiveAddPreSemiringTerm2
        n
        A ->
      OpNonDistributiveAddPreSemiringTerm2
        n
        A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    *OL2' :
      (n : Nat) (A : Set) ->
      OpNonDistributiveAddPreSemiringTerm2
        n
        A ->
      OpNonDistributiveAddPreSemiringTerm2
        n
        A ->
      OpNonDistributiveAddPreSemiringTerm2
        n
        A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpNonDistributiveAddPreSemiringTerm2
        n
        A ->
      Staged
        (OpNonDistributiveAddPreSemiringTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record NonDistributiveAddPreSemiringTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        +T : Repr A -> Repr A -> Repr A
        *T : Repr A -> Repr A -> Repr A
  
  module NonassociativeNondistributiveRing where
    record NonassociativeNondistributiveRing
      (A : Set) : Set where
      constructor NonassociativeNondistributiveRingC
      field
        * : A -> A -> A
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        inv : A -> A
        leftInverse_inv_op_1 :
          (x : A) -> * x (inv x) == 1
        rightInverse_inv_op_1 :
          (x : A) -> * (inv x) x == 1
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        + : A -> A -> A
    record NonassociativeNondistributiveRingSig
      (AS : Set) : Set where
      constructor NonassociativeNondistributiveRingSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
        invS : AS -> AS
        +S : AS -> AS -> AS
    record NonassociativeNondistributiveRingProd
      (AP : Set) : Set where
      constructor NonassociativeNondistributiveRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P xP (invP xP) == 1P
        rightInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P (invP xP) xP == 1P
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
    record NonassociativeNondistributiveRingHom
      (A1 : Set) (A2 : Set)
      (No1 : NonassociativeNondistributiveRing
         A1)
      (No2 : NonassociativeNondistributiveRing
         A2) : Set where
      constructor NonassociativeNondistributiveRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* No1 x1 x2) ==
            * No2 (hom x1) (hom x2)
        pres-1 : hom (1 No1) == 1 No2
        pres-inv :
          (x1 : A1) ->
          hom (inv No1 x1) ==
            inv No2 (hom x1)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ No1 x1 x2) ==
            + No2 (hom x1) (hom x2)
    record NonassociativeNondistributiveRingRelInterp
      (A1 : Set) (A2 : Set)
      (No1 : NonassociativeNondistributiveRing
         A1)
      (No2 : NonassociativeNondistributiveRing
         A2) : Set where
      constructor NonassociativeNondistributiveRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* No1 x1 x2)
            (* No2 y1 y2)
        interp-1 :
          interp (1 No1) (1 No2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv No1 x1) (inv No2 y1)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ No1 x1 x2)
            (+ No2 y1 y2)
    data NonassociativeNondistributiveRingTerm
      : Set where
      *L :
        NonassociativeNondistributiveRingTerm ->
        NonassociativeNondistributiveRingTerm ->
        NonassociativeNondistributiveRingTerm
      1L :
        NonassociativeNondistributiveRingTerm
      invL :
        NonassociativeNondistributiveRingTerm ->
        NonassociativeNondistributiveRingTerm
      +L :
        NonassociativeNondistributiveRingTerm ->
        NonassociativeNondistributiveRingTerm ->
        NonassociativeNondistributiveRingTerm
    data ClNonassociativeNondistributiveRingTerm
      (A : Set) : Set where
      sing :
        A ->
        ClNonassociativeNondistributiveRingTerm
          A
      *Cl :
        ClNonassociativeNondistributiveRingTerm
          A ->
        ClNonassociativeNondistributiveRingTerm
          A ->
        ClNonassociativeNondistributiveRingTerm
          A
      1Cl :
        ClNonassociativeNondistributiveRingTerm
          A
      invCl :
        ClNonassociativeNondistributiveRingTerm
          A ->
        ClNonassociativeNondistributiveRingTerm
          A
      +Cl :
        ClNonassociativeNondistributiveRingTerm
          A ->
        ClNonassociativeNondistributiveRingTerm
          A ->
        ClNonassociativeNondistributiveRingTerm
          A
    data OpNonassociativeNondistributiveRingTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpNonassociativeNondistributiveRingTerm
          n
      *OL :
        OpNonassociativeNondistributiveRingTerm
          n ->
        OpNonassociativeNondistributiveRingTerm
          n ->
        OpNonassociativeNondistributiveRingTerm
          n
      1OL :
        OpNonassociativeNondistributiveRingTerm
          n
      invOL :
        OpNonassociativeNondistributiveRingTerm
          n ->
        OpNonassociativeNondistributiveRingTerm
          n
      +OL :
        OpNonassociativeNondistributiveRingTerm
          n ->
        OpNonassociativeNondistributiveRingTerm
          n ->
        OpNonassociativeNondistributiveRingTerm
          n
    data OpNonassociativeNondistributiveRingTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpNonassociativeNondistributiveRingTerm2
          n
          A
      sing2 :
        A ->
        OpNonassociativeNondistributiveRingTerm2
          n
          A
      *OL2 :
        OpNonassociativeNondistributiveRingTerm2
          n
          A ->
        OpNonassociativeNondistributiveRingTerm2
          n
          A ->
        OpNonassociativeNondistributiveRingTerm2
          n
          A
      1OL2 :
        OpNonassociativeNondistributiveRingTerm2
          n
          A
      invOL2 :
        OpNonassociativeNondistributiveRingTerm2
          n
          A ->
        OpNonassociativeNondistributiveRingTerm2
          n
          A
      +OL2 :
        OpNonassociativeNondistributiveRingTerm2
          n
          A ->
        OpNonassociativeNondistributiveRingTerm2
          n
          A ->
        OpNonassociativeNondistributiveRingTerm2
          n
          A
    simplifyB :
      NonassociativeNondistributiveRingTerm ->
      NonassociativeNondistributiveRingTerm
    simplifyB (*L (1L) x) = x
    simplifyB (*L x (1L)) = x
    simplifyB (*L x (invL x)) = 1L
    simplifyB (*L (invL x) x) = 1L
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (1L) = 1L
    simplifyB (invL x1) =
      invL (simplifyB x1)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClNonassociativeNondistributiveRingTerm
        A ->
      ClNonassociativeNondistributiveRingTerm
        A
    simplifyCl _ (*Cl (1Cl) x) = x
    simplifyCl _ (*Cl x (1Cl)) = x
    simplifyCl _ (*Cl x (invCl x)) =
      1Cl
    simplifyCl _ (*Cl (invCl x) x) =
      1Cl
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (invCl x1) =
      invCl (simplifyCl _ x1)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpNonassociativeNondistributiveRingTerm
        n ->
      OpNonassociativeNondistributiveRingTerm
        n
    simplifyOp _ (*OL (1OL) x) = x
    simplifyOp _ (*OL x (1OL)) = x
    simplifyOp _ (*OL x (invOL x)) =
      1OL
    simplifyOp _ (*OL (invOL x) x) =
      1OL
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (invOL x1) =
      invOL (simplifyOp _ x1)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpNonassociativeNondistributiveRingTerm2
        n
        A ->
      OpNonassociativeNondistributiveRingTerm2
        n
        A
    simplifyOpE _ _ (*OL2
                     (1OL2)
                     x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (1OL2)) = x
    simplifyOpE _ _ (*OL2
                     x
                     (invOL2 x)) = 1OL2
    simplifyOpE _ _ (*OL2
                     (invOL2 x)
                     x) = 1OL2
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (invOL2 x1) =
      invOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      NonassociativeNondistributiveRing
        A ->
      NonassociativeNondistributiveRingTerm ->
      A
    evalB _ No (*L x1 x2) =
      * No (evalB _ No x1)
        (evalB _ No x2)
    evalB _ No (1L) = 1 No
    evalB _ No (invL x1) =
      inv No (evalB _ No x1)
    evalB _ No (+L x1 x2) =
      + No (evalB _ No x1)
        (evalB _ No x2)
    evalCl :
      (A : Set) ->
      NonassociativeNondistributiveRing
        A ->
      ClNonassociativeNondistributiveRingTerm
        A -> A
    evalCl _ No (sing x1) = x1
    evalCl _ No (*Cl x1 x2) =
      * No (evalCl _ No x1)
        (evalCl _ No x2)
    evalCl _ No (1Cl) = 1 No
    evalCl _ No (invCl x1) =
      inv No (evalCl _ No x1)
    evalCl _ No (+Cl x1 x2) =
      + No (evalCl _ No x1)
        (evalCl _ No x2)
    evalOp :
      (A : Set) (n : Nat) ->
      NonassociativeNondistributiveRing
        A ->
      Vec A n ->
      OpNonassociativeNondistributiveRingTerm
        n -> A
    evalOp _ n No vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n No vars (*OL x1 x2) =
      * No (evalOp _ n No vars x1)
        (evalOp _ n No vars x2)
    evalOp _ n No vars (1OL) = 1 No
    evalOp _ n No vars (invOL x1) =
      inv No (evalOp _ n No vars x1)
    evalOp _ n No vars (+OL x1 x2) =
      + No (evalOp _ n No vars x1)
        (evalOp _ n No vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      NonassociativeNondistributiveRing
        A ->
      Vec A n ->
      OpNonassociativeNondistributiveRingTerm2
        n
        A -> A
    evalOpE _ n No vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n No vars (sing2 x1) =
      x1
    evalOpE _ n No vars (*OL2
                         x1
                         x2) =
      * No (evalOpE _ n No vars x1)
        (evalOpE _ n No vars x2)
    evalOpE _ n No vars (1OL2) =
      1 No
    evalOpE _ n No vars (invOL2
                         x1) =
      inv No (evalOpE _ n No vars x1)
    evalOpE _ n No vars (+OL2
                         x1
                         x2) =
      + No (evalOpE _ n No vars x1)
        (evalOpE _ n No vars x2)
    inductionB :
      (P : NonassociativeNondistributiveRingTerm ->
           Set) ->
      ((x1 : NonassociativeNondistributiveRingTerm)
       (x2 : NonassociativeNondistributiveRingTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      P 1L ->
      ((x1 : NonassociativeNondistributiveRingTerm) ->
       P x1 -> P (invL x1)) ->
      ((x1 : NonassociativeNondistributiveRingTerm)
       (x2 : NonassociativeNondistributiveRingTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : NonassociativeNondistributiveRingTerm) ->
      P x
    inductionB p p*l p1l pinvl p+l (*L
                                    x1
                                    x2) =
      p*l _ _
        (inductionB p p*l p1l pinvl p+l
           x1)
        (inductionB p p*l p1l pinvl p+l
           x2)
    inductionB p p*l p1l pinvl p+l (1L) =
      p1l
    inductionB p p*l p1l pinvl p+l (invL
                                    x1) =
      pinvl _
        (inductionB p p*l p1l pinvl p+l
           x1)
    inductionB p p*l p1l pinvl p+l (+L
                                    x1
                                    x2) =
      p+l _ _
        (inductionB p p*l p1l pinvl p+l
           x1)
        (inductionB p p*l p1l pinvl p+l
           x2)
    inductionCl :
      (A : Set)
      (P : ClNonassociativeNondistributiveRingTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClNonassociativeNondistributiveRingTerm
          A)
       (x2 : ClNonassociativeNondistributiveRingTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      P 1Cl ->
      ((x1 : ClNonassociativeNondistributiveRingTerm
          A) -> P x1 -> P (invCl x1)) ->
      ((x1 : ClNonassociativeNondistributiveRingTerm
          A)
       (x2 : ClNonassociativeNondistributiveRingTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClNonassociativeNondistributiveRingTerm
         A) -> P x
    inductionCl _ p psing p*cl p1cl pinvcl p+cl (sing
                                                 x1) = psing x1
    inductionCl _ p psing p*cl p1cl pinvcl p+cl (*Cl
                                                 x1
                                                 x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p1cl
           pinvcl
           p+cl
           x1)
        (inductionCl _ p psing p*cl p1cl
           pinvcl
           p+cl
           x2)
    inductionCl _ p psing p*cl p1cl pinvcl p+cl (1Cl) =
      p1cl
    inductionCl _ p psing p*cl p1cl pinvcl p+cl (invCl
                                                 x1) =
      pinvcl _
        (inductionCl _ p psing p*cl p1cl
           pinvcl
           p+cl
           x1)
    inductionCl _ p psing p*cl p1cl pinvcl p+cl (+Cl
                                                 x1
                                                 x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p1cl
           pinvcl
           p+cl
           x1)
        (inductionCl _ p psing p*cl p1cl
           pinvcl
           p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpNonassociativeNondistributiveRingTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpNonassociativeNondistributiveRingTerm
          n)
       (x2 : OpNonassociativeNondistributiveRingTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      P 1OL ->
      ((x1 : OpNonassociativeNondistributiveRingTerm
          n) -> P x1 -> P (invOL x1)) ->
      ((x1 : OpNonassociativeNondistributiveRingTerm
          n)
       (x2 : OpNonassociativeNondistributiveRingTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpNonassociativeNondistributiveRingTerm
         n) -> P x
    inductionOp _ p pv p*ol p1ol pinvol p+ol (v
                                              x1) = pv x1
    inductionOp _ p pv p*ol p1ol pinvol p+ol (*OL
                                              x1
                                              x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p1ol
           pinvol
           p+ol
           x1)
        (inductionOp _ p pv p*ol p1ol
           pinvol
           p+ol
           x2)
    inductionOp _ p pv p*ol p1ol pinvol p+ol (1OL) =
      p1ol
    inductionOp _ p pv p*ol p1ol pinvol p+ol (invOL
                                              x1) =
      pinvol _
        (inductionOp _ p pv p*ol p1ol
           pinvol
           p+ol
           x1)
    inductionOp _ p pv p*ol p1ol pinvol p+ol (+OL
                                              x1
                                              x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p1ol
           pinvol
           p+ol
           x1)
        (inductionOp _ p pv p*ol p1ol
           pinvol
           p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpNonassociativeNondistributiveRingTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpNonassociativeNondistributiveRingTerm2
          n
          A)
       (x2 : OpNonassociativeNondistributiveRingTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      P 1OL2 ->
      ((x1 : OpNonassociativeNondistributiveRingTerm2
          n
          A) -> P x1 -> P (invOL2 x1)) ->
      ((x1 : OpNonassociativeNondistributiveRingTerm2
          n
          A)
       (x2 : OpNonassociativeNondistributiveRingTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpNonassociativeNondistributiveRingTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 pinvol2 p+ol2 (v2
                                                             x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 pinvol2 p+ol2 (sing2
                                                             x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 pinvol2 p+ol2 (*OL2
                                                             x1
                                                             x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           pinvol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           pinvol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 pinvol2 p+ol2 (1OL2) =
      p1ol2
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 pinvol2 p+ol2 (invOL2
                                                             x1) =
      pinvol2 _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           pinvol2
           p+ol2
           x1)
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 pinvol2 p+ol2 (+OL2
                                                             x1
                                                             x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           pinvol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           pinvol2
           p+ol2
           x2)
    *L' :
      NonassociativeNondistributiveRingTerm ->
      NonassociativeNondistributiveRingTerm ->
      NonassociativeNondistributiveRingTerm
    *L' x1 x2 = *L x1 x2
    1L' :
      NonassociativeNondistributiveRingTerm
    1L' = 1L
    invL' :
      NonassociativeNondistributiveRingTerm ->
      NonassociativeNondistributiveRingTerm
    invL' x1 = invL x1
    +L' :
      NonassociativeNondistributiveRingTerm ->
      NonassociativeNondistributiveRingTerm ->
      NonassociativeNondistributiveRingTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      NonassociativeNondistributiveRingTerm ->
      Staged
        NonassociativeNondistributiveRingTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (1L) = Now 1L
    stageB (invL x1) =
      stage1 _ _ invL'
        (codeLift1 _ _ invL')
        (stageB x1)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClNonassociativeNondistributiveRingTerm
        A ->
      ClNonassociativeNondistributiveRingTerm
        A ->
      ClNonassociativeNondistributiveRingTerm
        A
    *Cl' _ x1 x2 = *Cl x1 x2
    1Cl' :
      (A : Set) ->
      ClNonassociativeNondistributiveRingTerm
        A
    1Cl' _ = 1Cl
    invCl' :
      (A : Set) ->
      ClNonassociativeNondistributiveRingTerm
        A ->
      ClNonassociativeNondistributiveRingTerm
        A
    invCl' _ x1 = invCl x1
    +Cl' :
      (A : Set) ->
      ClNonassociativeNondistributiveRingTerm
        A ->
      ClNonassociativeNondistributiveRingTerm
        A ->
      ClNonassociativeNondistributiveRingTerm
        A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClNonassociativeNondistributiveRingTerm
        A ->
      Staged
        (ClNonassociativeNondistributiveRingTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (1Cl) = Now 1Cl
    stageCl _ (invCl x1) =
      stage1 _ _ (invCl' _)
        (codeLift1 _ _ (invCl' _))
        (stageCl _ x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpNonassociativeNondistributiveRingTerm
        n ->
      OpNonassociativeNondistributiveRingTerm
        n ->
      OpNonassociativeNondistributiveRingTerm
        n
    *OL' _ x1 x2 = *OL x1 x2
    1OL' :
      (n : Nat) ->
      OpNonassociativeNondistributiveRingTerm
        n
    1OL' _ = 1OL
    invOL' :
      (n : Nat) ->
      OpNonassociativeNondistributiveRingTerm
        n ->
      OpNonassociativeNondistributiveRingTerm
        n
    invOL' _ x1 = invOL x1
    +OL' :
      (n : Nat) ->
      OpNonassociativeNondistributiveRingTerm
        n ->
      OpNonassociativeNondistributiveRingTerm
        n ->
      OpNonassociativeNondistributiveRingTerm
        n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpNonassociativeNondistributiveRingTerm
        n ->
      Staged
        (OpNonassociativeNondistributiveRingTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (1OL) = Now 1OL
    stageOp _ (invOL x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (stageOp _ x1)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpNonassociativeNondistributiveRingTerm2
        n
        A ->
      OpNonassociativeNondistributiveRingTerm2
        n
        A ->
      OpNonassociativeNondistributiveRingTerm2
        n
        A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    1OL2' :
      (n : Nat) (A : Set) ->
      OpNonassociativeNondistributiveRingTerm2
        n
        A
    1OL2' _ _ = 1OL2
    invOL2' :
      (n : Nat) (A : Set) ->
      OpNonassociativeNondistributiveRingTerm2
        n
        A ->
      OpNonassociativeNondistributiveRingTerm2
        n
        A
    invOL2' _ _ x1 = invOL2 x1
    +OL2' :
      (n : Nat) (A : Set) ->
      OpNonassociativeNondistributiveRingTerm2
        n
        A ->
      OpNonassociativeNondistributiveRingTerm2
        n
        A ->
      OpNonassociativeNondistributiveRingTerm2
        n
        A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpNonassociativeNondistributiveRingTerm2
        n
        A ->
      Staged
        (OpNonassociativeNondistributiveRingTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (1OL2) = Now 1OL2
    stageOpE _ _ (invOL2 x1) =
      stage1 _ _ (invOL2' _ _)
        (codeLift1 _ _ (invOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record NonassociativeNondistributiveRingTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        1T : Repr A
        invT : Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module NonassociativeRing where
    record NonassociativeRing
      (A : Set) : Set where
      constructor NonassociativeRingC
      field
        * : A -> A -> A
        + : A -> A -> A
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        inv : A -> A
        leftInverse_inv_op_1 :
          (x : A) -> * x (inv x) == 1
        rightInverse_inv_op_1 :
          (x : A) -> * (inv x) x == 1
        commutative_* :
          (x : A) (y : A) ->
          * x y == * y x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record NonassociativeRingSig
      (AS : Set) : Set where
      constructor NonassociativeRingSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        1S : AS
        invS : AS -> AS
    record NonassociativeRingProd
      (AP : Set) : Set where
      constructor NonassociativeRingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P xP (invP xP) == 1P
        rightInverse_inv_op_1P :
          (xP : Prod AP AP) ->
          *P (invP xP) xP == 1P
        commutative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *P xP yP == *P yP xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record NonassociativeRingHom
      (A1 : Set) (A2 : Set)
      (No1 : NonassociativeRing A1)
      (No2 : NonassociativeRing A2) :
      Set where
      constructor NonassociativeRingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* No1 x1 x2) ==
            * No2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ No1 x1 x2) ==
            + No2 (hom x1) (hom x2)
        pres-1 : hom (1 No1) == 1 No2
        pres-inv :
          (x1 : A1) ->
          hom (inv No1 x1) ==
            inv No2 (hom x1)
    record NonassociativeRingRelInterp
      (A1 : Set) (A2 : Set)
      (No1 : NonassociativeRing A1)
      (No2 : NonassociativeRing A2) :
      Set where
      constructor NonassociativeRingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* No1 x1 x2)
            (* No2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ No1 x1 x2)
            (+ No2 y1 y2)
        interp-1 :
          interp (1 No1) (1 No2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv No1 x1) (inv No2 y1)
    data NonassociativeRingTerm
      : Set where
      *L :
        NonassociativeRingTerm ->
        NonassociativeRingTerm ->
        NonassociativeRingTerm
      +L :
        NonassociativeRingTerm ->
        NonassociativeRingTerm ->
        NonassociativeRingTerm
      1L : NonassociativeRingTerm
      invL :
        NonassociativeRingTerm ->
        NonassociativeRingTerm
    data ClNonassociativeRingTerm
      (A : Set) : Set where
      sing :
        A -> ClNonassociativeRingTerm A
      *Cl :
        ClNonassociativeRingTerm A ->
        ClNonassociativeRingTerm A ->
        ClNonassociativeRingTerm A
      +Cl :
        ClNonassociativeRingTerm A ->
        ClNonassociativeRingTerm A ->
        ClNonassociativeRingTerm A
      1Cl : ClNonassociativeRingTerm A
      invCl :
        ClNonassociativeRingTerm A ->
        ClNonassociativeRingTerm A
    data OpNonassociativeRingTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpNonassociativeRingTerm n
      *OL :
        OpNonassociativeRingTerm n ->
        OpNonassociativeRingTerm n ->
        OpNonassociativeRingTerm n
      +OL :
        OpNonassociativeRingTerm n ->
        OpNonassociativeRingTerm n ->
        OpNonassociativeRingTerm n
      1OL : OpNonassociativeRingTerm n
      invOL :
        OpNonassociativeRingTerm n ->
        OpNonassociativeRingTerm n
    data OpNonassociativeRingTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpNonassociativeRingTerm2 n A
      sing2 :
        A ->
        OpNonassociativeRingTerm2 n A
      *OL2 :
        OpNonassociativeRingTerm2 n A ->
        OpNonassociativeRingTerm2 n A ->
        OpNonassociativeRingTerm2 n A
      +OL2 :
        OpNonassociativeRingTerm2 n A ->
        OpNonassociativeRingTerm2 n A ->
        OpNonassociativeRingTerm2 n A
      1OL2 :
        OpNonassociativeRingTerm2 n A
      invOL2 :
        OpNonassociativeRingTerm2 n A ->
        OpNonassociativeRingTerm2 n A
    simplifyB :
      NonassociativeRingTerm ->
      NonassociativeRingTerm
    simplifyB (*L (1L) x) = x
    simplifyB (*L x (1L)) = x
    simplifyB (*L x (invL x)) = 1L
    simplifyB (*L (invL x) x) = 1L
    simplifyB (+L
               (*L x y)
               (*L x z)) = *L x (+L y z)
    simplifyB (+L
               (*L y x)
               (*L z x)) = *L (+L y z) x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (1L) = 1L
    simplifyB (invL x1) =
      invL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClNonassociativeRingTerm A ->
      ClNonassociativeRingTerm A
    simplifyCl _ (*Cl (1Cl) x) = x
    simplifyCl _ (*Cl x (1Cl)) = x
    simplifyCl _ (*Cl x (invCl x)) =
      1Cl
    simplifyCl _ (*Cl (invCl x) x) =
      1Cl
    simplifyCl _ (+Cl
                  (*Cl x y)
                  (*Cl x z)) = *Cl x (+Cl y z)
    simplifyCl _ (+Cl
                  (*Cl y x)
                  (*Cl z x)) = *Cl (+Cl y z) x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (invCl x1) =
      invCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpNonassociativeRingTerm n ->
      OpNonassociativeRingTerm n
    simplifyOp _ (*OL (1OL) x) = x
    simplifyOp _ (*OL x (1OL)) = x
    simplifyOp _ (*OL x (invOL x)) =
      1OL
    simplifyOp _ (*OL (invOL x) x) =
      1OL
    simplifyOp _ (+OL
                  (*OL x y)
                  (*OL x z)) = *OL x (+OL y z)
    simplifyOp _ (+OL
                  (*OL y x)
                  (*OL z x)) = *OL (+OL y z) x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (invOL x1) =
      invOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpNonassociativeRingTerm2 n A ->
      OpNonassociativeRingTerm2 n A
    simplifyOpE _ _ (*OL2
                     (1OL2)
                     x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (1OL2)) = x
    simplifyOpE _ _ (*OL2
                     x
                     (invOL2 x)) = 1OL2
    simplifyOpE _ _ (*OL2
                     (invOL2 x)
                     x) = 1OL2
    simplifyOpE _ _ (+OL2
                     (*OL2 x y)
                     (*OL2 x z)) = *OL2 x (+OL2 y z)
    simplifyOpE _ _ (+OL2
                     (*OL2 y x)
                     (*OL2 z x)) = *OL2 (+OL2 y z) x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (invOL2 x1) =
      invOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      NonassociativeRing A ->
      NonassociativeRingTerm -> A
    evalB _ No (*L x1 x2) =
      * No (evalB _ No x1)
        (evalB _ No x2)
    evalB _ No (+L x1 x2) =
      + No (evalB _ No x1)
        (evalB _ No x2)
    evalB _ No (1L) = 1 No
    evalB _ No (invL x1) =
      inv No (evalB _ No x1)
    evalCl :
      (A : Set) ->
      NonassociativeRing A ->
      ClNonassociativeRingTerm A -> A
    evalCl _ No (sing x1) = x1
    evalCl _ No (*Cl x1 x2) =
      * No (evalCl _ No x1)
        (evalCl _ No x2)
    evalCl _ No (+Cl x1 x2) =
      + No (evalCl _ No x1)
        (evalCl _ No x2)
    evalCl _ No (1Cl) = 1 No
    evalCl _ No (invCl x1) =
      inv No (evalCl _ No x1)
    evalOp :
      (A : Set) (n : Nat) ->
      NonassociativeRing A ->
      Vec A n ->
      OpNonassociativeRingTerm n -> A
    evalOp _ n No vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n No vars (*OL x1 x2) =
      * No (evalOp _ n No vars x1)
        (evalOp _ n No vars x2)
    evalOp _ n No vars (+OL x1 x2) =
      + No (evalOp _ n No vars x1)
        (evalOp _ n No vars x2)
    evalOp _ n No vars (1OL) = 1 No
    evalOp _ n No vars (invOL x1) =
      inv No (evalOp _ n No vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      NonassociativeRing A ->
      Vec A n ->
      OpNonassociativeRingTerm2 n A ->
      A
    evalOpE _ n No vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n No vars (sing2 x1) =
      x1
    evalOpE _ n No vars (*OL2
                         x1
                         x2) =
      * No (evalOpE _ n No vars x1)
        (evalOpE _ n No vars x2)
    evalOpE _ n No vars (+OL2
                         x1
                         x2) =
      + No (evalOpE _ n No vars x1)
        (evalOpE _ n No vars x2)
    evalOpE _ n No vars (1OL2) =
      1 No
    evalOpE _ n No vars (invOL2
                         x1) =
      inv No (evalOpE _ n No vars x1)
    inductionB :
      (P : NonassociativeRingTerm ->
           Set) ->
      ((x1 : NonassociativeRingTerm)
       (x2 : NonassociativeRingTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : NonassociativeRingTerm)
       (x2 : NonassociativeRingTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      P 1L ->
      ((x1 : NonassociativeRingTerm) ->
       P x1 -> P (invL x1)) ->
      (x : NonassociativeRingTerm) ->
      P x
    inductionB p p*l p+l p1l pinvl (*L
                                    x1
                                    x2) =
      p*l _ _
        (inductionB p p*l p+l p1l pinvl
           x1)
        (inductionB p p*l p+l p1l pinvl
           x2)
    inductionB p p*l p+l p1l pinvl (+L
                                    x1
                                    x2) =
      p+l _ _
        (inductionB p p*l p+l p1l pinvl
           x1)
        (inductionB p p*l p+l p1l pinvl
           x2)
    inductionB p p*l p+l p1l pinvl (1L) =
      p1l
    inductionB p p*l p+l p1l pinvl (invL
                                    x1) =
      pinvl _
        (inductionB p p*l p+l p1l pinvl
           x1)
    inductionCl :
      (A : Set)
      (P : ClNonassociativeRingTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClNonassociativeRingTerm
          A)
       (x2 : ClNonassociativeRingTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClNonassociativeRingTerm
          A)
       (x2 : ClNonassociativeRingTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      P 1Cl ->
      ((x1 : ClNonassociativeRingTerm
          A) -> P x1 -> P (invCl x1)) ->
      (x : ClNonassociativeRingTerm
         A) -> P x
    inductionCl _ p psing p*cl p+cl p1cl pinvcl (sing
                                                 x1) = psing x1
    inductionCl _ p psing p*cl p+cl p1cl pinvcl (*Cl
                                                 x1
                                                 x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           p1cl
           pinvcl
           x1)
        (inductionCl _ p psing p*cl p+cl
           p1cl
           pinvcl
           x2)
    inductionCl _ p psing p*cl p+cl p1cl pinvcl (+Cl
                                                 x1
                                                 x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           p1cl
           pinvcl
           x1)
        (inductionCl _ p psing p*cl p+cl
           p1cl
           pinvcl
           x2)
    inductionCl _ p psing p*cl p+cl p1cl pinvcl (1Cl) =
      p1cl
    inductionCl _ p psing p*cl p+cl p1cl pinvcl (invCl
                                                 x1) =
      pinvcl _
        (inductionCl _ p psing p*cl p+cl
           p1cl
           pinvcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpNonassociativeRingTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpNonassociativeRingTerm
          n)
       (x2 : OpNonassociativeRingTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpNonassociativeRingTerm
          n)
       (x2 : OpNonassociativeRingTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      P 1OL ->
      ((x1 : OpNonassociativeRingTerm
          n) -> P x1 -> P (invOL x1)) ->
      (x : OpNonassociativeRingTerm
         n) -> P x
    inductionOp _ p pv p*ol p+ol p1ol pinvol (v
                                              x1) = pv x1
    inductionOp _ p pv p*ol p+ol p1ol pinvol (*OL
                                              x1
                                              x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           p1ol
           pinvol
           x1)
        (inductionOp _ p pv p*ol p+ol
           p1ol
           pinvol
           x2)
    inductionOp _ p pv p*ol p+ol p1ol pinvol (+OL
                                              x1
                                              x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           p1ol
           pinvol
           x1)
        (inductionOp _ p pv p*ol p+ol
           p1ol
           pinvol
           x2)
    inductionOp _ p pv p*ol p+ol p1ol pinvol (1OL) =
      p1ol
    inductionOp _ p pv p*ol p+ol p1ol pinvol (invOL
                                              x1) =
      pinvol _
        (inductionOp _ p pv p*ol p+ol
           p1ol
           pinvol
           x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpNonassociativeRingTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpNonassociativeRingTerm2
          n
          A)
       (x2 : OpNonassociativeRingTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpNonassociativeRingTerm2
          n
          A)
       (x2 : OpNonassociativeRingTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      P 1OL2 ->
      ((x1 : OpNonassociativeRingTerm2
          n
          A) -> P x1 -> P (invOL2 x1)) ->
      (x : OpNonassociativeRingTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p1ol2 pinvol2 (v2
                                                             x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p1ol2 pinvol2 (sing2
                                                             x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p1ol2 pinvol2 (*OL2
                                                             x1
                                                             x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p1ol2
           pinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p1ol2
           pinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p1ol2 pinvol2 (+OL2
                                                             x1
                                                             x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p1ol2
           pinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p1ol2
           pinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p1ol2 pinvol2 (1OL2) =
      p1ol2
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p1ol2 pinvol2 (invOL2
                                                             x1) =
      pinvol2 _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p1ol2
           pinvol2
           x1)
    *L' :
      NonassociativeRingTerm ->
      NonassociativeRingTerm ->
      NonassociativeRingTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      NonassociativeRingTerm ->
      NonassociativeRingTerm ->
      NonassociativeRingTerm
    +L' x1 x2 = +L x1 x2
    1L' : NonassociativeRingTerm
    1L' = 1L
    invL' :
      NonassociativeRingTerm ->
      NonassociativeRingTerm
    invL' x1 = invL x1
    stageB :
      NonassociativeRingTerm ->
      Staged NonassociativeRingTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (1L) = Now 1L
    stageB (invL x1) =
      stage1 _ _ invL'
        (codeLift1 _ _ invL')
        (stageB x1)
    *Cl' :
      (A : Set) ->
      ClNonassociativeRingTerm A ->
      ClNonassociativeRingTerm A ->
      ClNonassociativeRingTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClNonassociativeRingTerm A ->
      ClNonassociativeRingTerm A ->
      ClNonassociativeRingTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    1Cl' :
      (A : Set) ->
      ClNonassociativeRingTerm A
    1Cl' _ = 1Cl
    invCl' :
      (A : Set) ->
      ClNonassociativeRingTerm A ->
      ClNonassociativeRingTerm A
    invCl' _ x1 = invCl x1
    stageCl :
      (A : Set) ->
      ClNonassociativeRingTerm A ->
      Staged
        (ClNonassociativeRingTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (1Cl) = Now 1Cl
    stageCl _ (invCl x1) =
      stage1 _ _ (invCl' _)
        (codeLift1 _ _ (invCl' _))
        (stageCl _ x1)
    *OL' :
      (n : Nat) ->
      OpNonassociativeRingTerm n ->
      OpNonassociativeRingTerm n ->
      OpNonassociativeRingTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpNonassociativeRingTerm n ->
      OpNonassociativeRingTerm n ->
      OpNonassociativeRingTerm n
    +OL' _ x1 x2 = +OL x1 x2
    1OL' :
      (n : Nat) ->
      OpNonassociativeRingTerm n
    1OL' _ = 1OL
    invOL' :
      (n : Nat) ->
      OpNonassociativeRingTerm n ->
      OpNonassociativeRingTerm n
    invOL' _ x1 = invOL x1
    stageOp :
      (n : Nat) ->
      OpNonassociativeRingTerm n ->
      Staged
        (OpNonassociativeRingTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (1OL) = Now 1OL
    stageOp _ (invOL x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (stageOp _ x1)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpNonassociativeRingTerm2 n A ->
      OpNonassociativeRingTerm2 n A ->
      OpNonassociativeRingTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpNonassociativeRingTerm2 n A ->
      OpNonassociativeRingTerm2 n A ->
      OpNonassociativeRingTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    1OL2' :
      (n : Nat) (A : Set) ->
      OpNonassociativeRingTerm2 n A
    1OL2' _ _ = 1OL2
    invOL2' :
      (n : Nat) (A : Set) ->
      OpNonassociativeRingTerm2 n A ->
      OpNonassociativeRingTerm2 n A
    invOL2' _ _ x1 = invOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpNonassociativeRingTerm2 n A ->
      Staged
        (OpNonassociativeRingTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (1OL2) = Now 1OL2
    stageOpE _ _ (invOL2 x1) =
      stage1 _ _ (invOL2' _ _)
        (codeLift1 _ _ (invOL2' _ _))
        (stageOpE _ _ x1)
    record NonassociativeRingTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
        1T : Repr A
        invT : Repr A -> Repr A
  
  module NormalBand where
    record NormalBand
      (A : Set) : Set where
      constructor NormalBandC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        idempotent_op :
          (x : A) -> op x x == x
        middleCommute_* :
          (x : A) (y : A) (z : A) ->
          op (op (op x y) z) x ==
            op (op (op x z) y) x
    record NormalBandSig
      (AS : Set) : Set where
      constructor NormalBandSigSigC
      field
        opS : AS -> AS -> AS
    record NormalBandProd
      (AP : Set) : Set where
      constructor NormalBandProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        idempotent_opP :
          (xP : Prod AP AP) ->
          opP xP xP == xP
        middleCommute_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP (opP xP yP) zP) xP ==
            opP (opP (opP xP zP) yP) xP
    record NormalBandHom
      (A1 : Set) (A2 : Set)
      (No1 : NormalBand A1)
      (No2 : NormalBand A2) :
      Set where
      constructor NormalBandHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op No1 x1 x2) ==
            op No2 (hom x1) (hom x2)
    record NormalBandRelInterp
      (A1 : Set) (A2 : Set)
      (No1 : NormalBand A1)
      (No2 : NormalBand A2) :
      Set where
      constructor NormalBandRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op No1 x1 x2)
            (op No2 y1 y2)
    data NormalBandTerm : Set where
      opL :
        NormalBandTerm ->
        NormalBandTerm -> NormalBandTerm
    data ClNormalBandTerm
      (A : Set) : Set where
      sing : A -> ClNormalBandTerm A
      opCl :
        ClNormalBandTerm A ->
        ClNormalBandTerm A ->
        ClNormalBandTerm A
    data OpNormalBandTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpNormalBandTerm n
      opOL :
        OpNormalBandTerm n ->
        OpNormalBandTerm n ->
        OpNormalBandTerm n
    data OpNormalBandTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpNormalBandTerm2 n A
      sing2 :
        A -> OpNormalBandTerm2 n A
      opOL2 :
        OpNormalBandTerm2 n A ->
        OpNormalBandTerm2 n A ->
        OpNormalBandTerm2 n A
    simplifyB :
      NormalBandTerm -> NormalBandTerm
    simplifyB (opL x x) = x
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClNormalBandTerm A ->
      ClNormalBandTerm A
    simplifyCl _ (opCl x x) = x
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpNormalBandTerm n ->
      OpNormalBandTerm n
    simplifyOp _ (opOL x x) = x
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpNormalBandTerm2 n A ->
      OpNormalBandTerm2 n A
    simplifyOpE _ _ (opOL2 x x) = x
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      NormalBand A ->
      NormalBandTerm -> A
    evalB _ No (opL x1 x2) =
      op No (evalB _ No x1)
        (evalB _ No x2)
    evalCl :
      (A : Set) ->
      NormalBand A ->
      ClNormalBandTerm A -> A
    evalCl _ No (sing x1) = x1
    evalCl _ No (opCl x1 x2) =
      op No (evalCl _ No x1)
        (evalCl _ No x2)
    evalOp :
      (A : Set) (n : Nat) ->
      NormalBand A ->
      Vec A n ->
      OpNormalBandTerm n -> A
    evalOp _ n No vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n No vars (opOL
                        x1
                        x2) =
      op No (evalOp _ n No vars x1)
        (evalOp _ n No vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      NormalBand A ->
      Vec A n ->
      OpNormalBandTerm2 n A -> A
    evalOpE _ n No vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n No vars (sing2 x1) =
      x1
    evalOpE _ n No vars (opOL2
                         x1
                         x2) =
      op No (evalOpE _ n No vars x1)
        (evalOpE _ n No vars x2)
    inductionB :
      (P : NormalBandTerm -> Set) ->
      ((x1 : NormalBandTerm)
       (x2 : NormalBandTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : NormalBandTerm) -> P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClNormalBandTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClNormalBandTerm A)
       (x2 : ClNormalBandTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClNormalBandTerm A) -> P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpNormalBandTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpNormalBandTerm n)
       (x2 : OpNormalBandTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpNormalBandTerm n) -> P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpNormalBandTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpNormalBandTerm2 n A)
       (x2 : OpNormalBandTerm2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpNormalBandTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      NormalBandTerm ->
      NormalBandTerm -> NormalBandTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      NormalBandTerm ->
      Staged NormalBandTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClNormalBandTerm A ->
      ClNormalBandTerm A ->
      ClNormalBandTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClNormalBandTerm A ->
      Staged (ClNormalBandTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpNormalBandTerm n ->
      OpNormalBandTerm n ->
      OpNormalBandTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpNormalBandTerm n ->
      Staged (OpNormalBandTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpNormalBandTerm2 n A ->
      OpNormalBandTerm2 n A ->
      OpNormalBandTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpNormalBandTerm2 n A ->
      Staged (OpNormalBandTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record NormalBandTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module OrDeMorgran where
    record OrDeMorgran
      (A : Set) : Set where
      constructor OrDeMorgranC
      field
        * : A -> A -> A
        + : A -> A -> A
        prim : A -> A
        orDeMorgan_+_*_prim :
          (x : A) (y : A) (z : A) ->
          prim (+ x y) ==
            * (prim x) (prim y)
    record OrDeMorgranSig
      (AS : Set) : Set where
      constructor OrDeMorgranSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        primS : AS -> AS
    record OrDeMorgranProd
      (AP : Set) : Set where
      constructor OrDeMorgranProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        orDeMorgan_+_*_primP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          primP (+P xP yP) ==
            *P (primP xP) (primP yP)
    record OrDeMorgranHom
      (A1 : Set) (A2 : Set)
      (Or1 : OrDeMorgran A1)
      (Or2 : OrDeMorgran A2) :
      Set where
      constructor OrDeMorgranHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Or1 x1 x2) ==
            * Or2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Or1 x1 x2) ==
            + Or2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Or1 x1) ==
            prim Or2 (hom x1)
    record OrDeMorgranRelInterp
      (A1 : Set) (A2 : Set)
      (Or1 : OrDeMorgran A1)
      (Or2 : OrDeMorgran A2) :
      Set where
      constructor OrDeMorgranRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Or1 x1 x2)
            (* Or2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Or1 x1 x2)
            (+ Or2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Or1 x1)
            (prim Or2 y1)
    data OrDeMorgranTerm : Set where
      *L :
        OrDeMorgranTerm ->
        OrDeMorgranTerm ->
        OrDeMorgranTerm
      +L :
        OrDeMorgranTerm ->
        OrDeMorgranTerm ->
        OrDeMorgranTerm
      primL :
        OrDeMorgranTerm ->
        OrDeMorgranTerm
    data ClOrDeMorgranTerm
      (A : Set) : Set where
      sing :
        A -> ClOrDeMorgranTerm A
      *Cl :
        ClOrDeMorgranTerm A ->
        ClOrDeMorgranTerm A ->
        ClOrDeMorgranTerm A
      +Cl :
        ClOrDeMorgranTerm A ->
        ClOrDeMorgranTerm A ->
        ClOrDeMorgranTerm A
      primCl :
        ClOrDeMorgranTerm A ->
        ClOrDeMorgranTerm A
    data OpOrDeMorgranTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpOrDeMorgranTerm n
      *OL :
        OpOrDeMorgranTerm n ->
        OpOrDeMorgranTerm n ->
        OpOrDeMorgranTerm n
      +OL :
        OpOrDeMorgranTerm n ->
        OpOrDeMorgranTerm n ->
        OpOrDeMorgranTerm n
      primOL :
        OpOrDeMorgranTerm n ->
        OpOrDeMorgranTerm n
    data OpOrDeMorgranTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpOrDeMorgranTerm2 n A
      sing2 :
        A -> OpOrDeMorgranTerm2 n A
      *OL2 :
        OpOrDeMorgranTerm2 n A ->
        OpOrDeMorgranTerm2 n A ->
        OpOrDeMorgranTerm2 n A
      +OL2 :
        OpOrDeMorgranTerm2 n A ->
        OpOrDeMorgranTerm2 n A ->
        OpOrDeMorgranTerm2 n A
      primOL2 :
        OpOrDeMorgranTerm2 n A ->
        OpOrDeMorgranTerm2 n A
    simplifyB :
      OrDeMorgranTerm ->
      OrDeMorgranTerm
    simplifyB (*L
               (primL x)
               (primL y)) = primL (+L x y)
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClOrDeMorgranTerm A ->
      ClOrDeMorgranTerm A
    simplifyCl _ (*Cl
                  (primCl x)
                  (primCl y)) = primCl (+Cl x y)
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpOrDeMorgranTerm n ->
      OpOrDeMorgranTerm n
    simplifyOp _ (*OL
                  (primOL x)
                  (primOL y)) = primOL (+OL x y)
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpOrDeMorgranTerm2 n A ->
      OpOrDeMorgranTerm2 n A
    simplifyOpE _ _ (*OL2
                     (primOL2 x)
                     (primOL2 y)) =
      primOL2 (+OL2 x y)
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      OrDeMorgran A ->
      OrDeMorgranTerm -> A
    evalB _ Or (*L x1 x2) =
      * Or (evalB _ Or x1)
        (evalB _ Or x2)
    evalB _ Or (+L x1 x2) =
      + Or (evalB _ Or x1)
        (evalB _ Or x2)
    evalB _ Or (primL x1) =
      prim Or (evalB _ Or x1)
    evalCl :
      (A : Set) ->
      OrDeMorgran A ->
      ClOrDeMorgranTerm A -> A
    evalCl _ Or (sing x1) = x1
    evalCl _ Or (*Cl x1 x2) =
      * Or (evalCl _ Or x1)
        (evalCl _ Or x2)
    evalCl _ Or (+Cl x1 x2) =
      + Or (evalCl _ Or x1)
        (evalCl _ Or x2)
    evalCl _ Or (primCl x1) =
      prim Or (evalCl _ Or x1)
    evalOp :
      (A : Set) (n : Nat) ->
      OrDeMorgran A ->
      Vec A n ->
      OpOrDeMorgranTerm n -> A
    evalOp _ n Or vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Or vars (*OL x1 x2) =
      * Or (evalOp _ n Or vars x1)
        (evalOp _ n Or vars x2)
    evalOp _ n Or vars (+OL x1 x2) =
      + Or (evalOp _ n Or vars x1)
        (evalOp _ n Or vars x2)
    evalOp _ n Or vars (primOL x1) =
      prim Or (evalOp _ n Or vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      OrDeMorgran A ->
      Vec A n ->
      OpOrDeMorgranTerm2 n A -> A
    evalOpE _ n Or vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Or vars (sing2 x1) =
      x1
    evalOpE _ n Or vars (*OL2
                         x1
                         x2) =
      * Or (evalOpE _ n Or vars x1)
        (evalOpE _ n Or vars x2)
    evalOpE _ n Or vars (+OL2
                         x1
                         x2) =
      + Or (evalOpE _ n Or vars x1)
        (evalOpE _ n Or vars x2)
    evalOpE _ n Or vars (primOL2
                         x1) =
      prim Or (evalOpE _ n Or vars x1)
    inductionB :
      (P : OrDeMorgranTerm -> Set) ->
      ((x1 : OrDeMorgranTerm)
       (x2 : OrDeMorgranTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : OrDeMorgranTerm)
       (x2 : OrDeMorgranTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      ((x1 : OrDeMorgranTerm) ->
       P x1 -> P (primL x1)) ->
      (x : OrDeMorgranTerm) -> P x
    inductionB p p*l p+l ppriml (*L
                                 x1
                                 x2) =
      p*l _ _
        (inductionB p p*l p+l ppriml x1)
        (inductionB p p*l p+l ppriml x2)
    inductionB p p*l p+l ppriml (+L
                                 x1
                                 x2) =
      p+l _ _
        (inductionB p p*l p+l ppriml x1)
        (inductionB p p*l p+l ppriml x2)
    inductionB p p*l p+l ppriml (primL
                                 x1) =
      ppriml _
        (inductionB p p*l p+l ppriml x1)
    inductionCl :
      (A : Set)
      (P : ClOrDeMorgranTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClOrDeMorgranTerm A)
       (x2 : ClOrDeMorgranTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClOrDeMorgranTerm A)
       (x2 : ClOrDeMorgranTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      ((x1 : ClOrDeMorgranTerm A) ->
       P x1 -> P (primCl x1)) ->
      (x : ClOrDeMorgranTerm A) -> P x
    inductionCl _ p psing p*cl p+cl pprimcl (sing
                                             x1) = psing x1
    inductionCl _ p psing p*cl p+cl pprimcl (*Cl
                                             x1
                                             x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x1)
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x2)
    inductionCl _ p psing p*cl p+cl pprimcl (+Cl
                                             x1
                                             x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x1)
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x2)
    inductionCl _ p psing p*cl p+cl pprimcl (primCl
                                             x1) =
      pprimcl _
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpOrDeMorgranTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpOrDeMorgranTerm n)
       (x2 : OpOrDeMorgranTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpOrDeMorgranTerm n)
       (x2 : OpOrDeMorgranTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      ((x1 : OpOrDeMorgranTerm n) ->
       P x1 -> P (primOL x1)) ->
      (x : OpOrDeMorgranTerm n) -> P x
    inductionOp _ p pv p*ol p+ol pprimol (v
                                          x1) = pv x1
    inductionOp _ p pv p*ol p+ol pprimol (*OL
                                          x1
                                          x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x1)
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x2)
    inductionOp _ p pv p*ol p+ol pprimol (+OL
                                          x1
                                          x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x1)
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x2)
    inductionOp _ p pv p*ol p+ol pprimol (primOL
                                          x1) =
      pprimol _
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpOrDeMorgranTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpOrDeMorgranTerm2 n A)
       (x2 : OpOrDeMorgranTerm2 n A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpOrDeMorgranTerm2 n A)
       (x2 : OpOrDeMorgranTerm2 n A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      ((x1 : OpOrDeMorgranTerm2 n
          A) -> P x1 -> P (primOL2 x1)) ->
      (x : OpOrDeMorgranTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (v2
                                                        x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (sing2
                                                        x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (*OL2
                                                        x1
                                                        x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (+OL2
                                                        x1
                                                        x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (primOL2
                                                        x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x1)
    *L' :
      OrDeMorgranTerm ->
      OrDeMorgranTerm ->
      OrDeMorgranTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      OrDeMorgranTerm ->
      OrDeMorgranTerm ->
      OrDeMorgranTerm
    +L' x1 x2 = +L x1 x2
    primL' :
      OrDeMorgranTerm ->
      OrDeMorgranTerm
    primL' x1 = primL x1
    stageB :
      OrDeMorgranTerm ->
      Staged OrDeMorgranTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    *Cl' :
      (A : Set) ->
      ClOrDeMorgranTerm A ->
      ClOrDeMorgranTerm A ->
      ClOrDeMorgranTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClOrDeMorgranTerm A ->
      ClOrDeMorgranTerm A ->
      ClOrDeMorgranTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    primCl' :
      (A : Set) ->
      ClOrDeMorgranTerm A ->
      ClOrDeMorgranTerm A
    primCl' _ x1 = primCl x1
    stageCl :
      (A : Set) ->
      ClOrDeMorgranTerm A ->
      Staged (ClOrDeMorgranTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    *OL' :
      (n : Nat) ->
      OpOrDeMorgranTerm n ->
      OpOrDeMorgranTerm n ->
      OpOrDeMorgranTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpOrDeMorgranTerm n ->
      OpOrDeMorgranTerm n ->
      OpOrDeMorgranTerm n
    +OL' _ x1 x2 = +OL x1 x2
    primOL' :
      (n : Nat) ->
      OpOrDeMorgranTerm n ->
      OpOrDeMorgranTerm n
    primOL' _ x1 = primOL x1
    stageOp :
      (n : Nat) ->
      OpOrDeMorgranTerm n ->
      Staged (OpOrDeMorgranTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpOrDeMorgranTerm2 n A ->
      OpOrDeMorgranTerm2 n A ->
      OpOrDeMorgranTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpOrDeMorgranTerm2 n A ->
      OpOrDeMorgranTerm2 n A ->
      OpOrDeMorgranTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    primOL2' :
      (n : Nat) (A : Set) ->
      OpOrDeMorgranTerm2 n A ->
      OpOrDeMorgranTerm2 n A
    primOL2' _ _ x1 = primOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpOrDeMorgranTerm2 n A ->
      Staged (OpOrDeMorgranTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    record OrDeMorgranTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
        primT : Repr A -> Repr A
  
  module Pointed where
    record Pointed
      (A : Set) : Set where
      constructor PointedC
      field
        e : A
    record PointedSig
      (AS : Set) : Set where
      constructor PointedSigSigC
      field
        eS : AS
    record PointedProd
      (AP : Set) : Set where
      constructor PointedProdC
      field
        eP : Prod AP AP
    record PointedHom
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed A1)
      (Po2 : Pointed A2) : Set where
      constructor PointedHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Po1) == e Po2
    record PointedRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed A1)
      (Po2 : Pointed A2) : Set where
      constructor PointedRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Po1) (e Po2)
    data PointedTerm : Set where
      eL : PointedTerm
    data ClPointedTerm
      (A : Set) : Set where
      sing : A -> ClPointedTerm A
      eCl : ClPointedTerm A
    data OpPointedTerm
      (n : Nat) : Set where
      v : Fin n -> OpPointedTerm n
      eOL : OpPointedTerm n
    data OpPointedTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpPointedTerm2 n A
      sing2 : A -> OpPointedTerm2 n A
      eOL2 : OpPointedTerm2 n A
    simplifyB :
      PointedTerm -> PointedTerm
    simplifyB (eL) = eL
    simplifyCl :
      (A : Set) ->
      ClPointedTerm A ->
      ClPointedTerm A
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpPointedTerm n ->
      OpPointedTerm n
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpPointedTerm2 n A ->
      OpPointedTerm2 n A
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Pointed A -> PointedTerm -> A
    evalB _ Po (eL) = e Po
    evalCl :
      (A : Set) ->
      Pointed A ->
      ClPointedTerm A -> A
    evalCl _ Po (sing x1) = x1
    evalCl _ Po (eCl) = e Po
    evalOp :
      (A : Set) (n : Nat) ->
      Pointed A ->
      Vec A n -> OpPointedTerm n -> A
    evalOp _ n Po vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Po vars (eOL) = e Po
    evalOpE :
      (A : Set) (n : Nat) ->
      Pointed A ->
      Vec A n ->
      OpPointedTerm2 n A -> A
    evalOpE _ n Po vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Po vars (sing2 x1) =
      x1
    evalOpE _ n Po vars (eOL2) =
      e Po
    inductionB :
      (P : PointedTerm -> Set) ->
      P eL -> (x : PointedTerm) -> P x
    inductionB p pel (eL) = pel
    inductionCl :
      (A : Set)
      (P : ClPointedTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P eCl ->
      (x : ClPointedTerm A) -> P x
    inductionCl _ p psing pecl (sing
                                x1) = psing x1
    inductionCl _ p psing pecl (eCl) =
      pecl
    inductionOp :
      (n : Nat)
      (P : OpPointedTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P eOL ->
      (x : OpPointedTerm n) -> P x
    inductionOp _ p pv peol (v x1) =
      pv x1
    inductionOp _ p pv peol (eOL) =
      peol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpPointedTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P eOL2 ->
      (x : OpPointedTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 peol2 (v2
                                         x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 peol2 (sing2
                                         x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 peol2 (eOL2) =
      peol2
    eL' : PointedTerm
    eL' = eL
    stageB :
      PointedTerm ->
      Staged PointedTerm
    stageB (eL) = Now eL
    eCl' :
      (A : Set) -> ClPointedTerm A
    eCl' _ = eCl
    stageCl :
      (A : Set) ->
      ClPointedTerm A ->
      Staged (ClPointedTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (eCl) = Now eCl
    eOL' :
      (n : Nat) -> OpPointedTerm n
    eOL' _ = eOL
    stageOp :
      (n : Nat) ->
      OpPointedTerm n ->
      Staged (OpPointedTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (eOL) = Now eOL
    eOL2' :
      (n : Nat) (A : Set) ->
      OpPointedTerm2 n A
    eOL2' _ _ = eOL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpPointedTerm2 n A ->
      Staged (OpPointedTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (eOL2) = Now eOL2
    record PointedTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        eT : Repr A
  
  module Pointed0Magma where
    record Pointed0Magma
      (A : Set) : Set where
      constructor Pointed0MagmaC
      field
        0 : A
        op : A -> A -> A
    record Pointed0MagmaSig
      (AS : Set) : Set where
      constructor Pointed0MagmaSigSigC
      field
        0S : AS
        opS : AS -> AS -> AS
    record Pointed0MagmaProd
      (AP : Set) : Set where
      constructor Pointed0MagmaProdC
      field
        0P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record Pointed0MagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed0Magma A1)
      (Po2 : Pointed0Magma A2) :
      Set where
      constructor Pointed0MagmaHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Po1) == 0 Po2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Po1 x1 x2) ==
            op Po2 (hom x1) (hom x2)
    record Pointed0MagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed0Magma A1)
      (Po2 : Pointed0Magma A2) :
      Set where
      constructor Pointed0MagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Po1) (0 Po2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Po1 x1 x2)
            (op Po2 y1 y2)
    data Pointed0MagmaTerm
      : Set where
      0L : Pointed0MagmaTerm
      opL :
        Pointed0MagmaTerm ->
        Pointed0MagmaTerm ->
        Pointed0MagmaTerm
    data ClPointed0MagmaTerm
      (A : Set) : Set where
      sing :
        A -> ClPointed0MagmaTerm A
      0Cl : ClPointed0MagmaTerm A
      opCl :
        ClPointed0MagmaTerm A ->
        ClPointed0MagmaTerm A ->
        ClPointed0MagmaTerm A
    data OpPointed0MagmaTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpPointed0MagmaTerm n
      0OL : OpPointed0MagmaTerm n
      opOL :
        OpPointed0MagmaTerm n ->
        OpPointed0MagmaTerm n ->
        OpPointed0MagmaTerm n
    data OpPointed0MagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpPointed0MagmaTerm2 n A
      sing2 :
        A -> OpPointed0MagmaTerm2 n A
      0OL2 : OpPointed0MagmaTerm2 n A
      opOL2 :
        OpPointed0MagmaTerm2 n A ->
        OpPointed0MagmaTerm2 n A ->
        OpPointed0MagmaTerm2 n A
    simplifyB :
      Pointed0MagmaTerm ->
      Pointed0MagmaTerm
    simplifyB (0L) = 0L
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClPointed0MagmaTerm A ->
      ClPointed0MagmaTerm A
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpPointed0MagmaTerm n ->
      OpPointed0MagmaTerm n
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpPointed0MagmaTerm2 n A ->
      OpPointed0MagmaTerm2 n A
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Pointed0Magma A ->
      Pointed0MagmaTerm -> A
    evalB _ Po (0L) = 0 Po
    evalB _ Po (opL x1 x2) =
      op Po (evalB _ Po x1)
        (evalB _ Po x2)
    evalCl :
      (A : Set) ->
      Pointed0Magma A ->
      ClPointed0MagmaTerm A -> A
    evalCl _ Po (sing x1) = x1
    evalCl _ Po (0Cl) = 0 Po
    evalCl _ Po (opCl x1 x2) =
      op Po (evalCl _ Po x1)
        (evalCl _ Po x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Pointed0Magma A ->
      Vec A n ->
      OpPointed0MagmaTerm n -> A
    evalOp _ n Po vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Po vars (0OL) = 0 Po
    evalOp _ n Po vars (opOL
                        x1
                        x2) =
      op Po (evalOp _ n Po vars x1)
        (evalOp _ n Po vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Pointed0Magma A ->
      Vec A n ->
      OpPointed0MagmaTerm2 n A -> A
    evalOpE _ n Po vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Po vars (sing2 x1) =
      x1
    evalOpE _ n Po vars (0OL2) =
      0 Po
    evalOpE _ n Po vars (opOL2
                         x1
                         x2) =
      op Po (evalOpE _ n Po vars x1)
        (evalOpE _ n Po vars x2)
    inductionB :
      (P : Pointed0MagmaTerm ->
           Set) ->
      P 0L ->
      ((x1 : Pointed0MagmaTerm)
       (x2 : Pointed0MagmaTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : Pointed0MagmaTerm) -> P x
    inductionB p p0l popl (0L) = p0l
    inductionB p p0l popl (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p p0l popl x1)
        (inductionB p p0l popl x2)
    inductionCl :
      (A : Set)
      (P : ClPointed0MagmaTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 0Cl ->
      ((x1 : ClPointed0MagmaTerm A)
       (x2 : ClPointed0MagmaTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClPointed0MagmaTerm A) ->
      P x
    inductionCl _ p psing p0cl popcl (sing
                                      x1) = psing x1
    inductionCl _ p psing p0cl popcl (0Cl) =
      p0cl
    inductionCl _ p psing p0cl popcl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing p0cl
           popcl
           x1)
        (inductionCl _ p psing p0cl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpPointed0MagmaTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 0OL ->
      ((x1 : OpPointed0MagmaTerm n)
       (x2 : OpPointed0MagmaTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpPointed0MagmaTerm n) ->
      P x
    inductionOp _ p pv p0ol popol (v
                                   x1) = pv x1
    inductionOp _ p pv p0ol popol (0OL) =
      p0ol
    inductionOp _ p pv p0ol popol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv p0ol popol
           x1)
        (inductionOp _ p pv p0ol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpPointed0MagmaTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 0OL2 ->
      ((x1 : OpPointed0MagmaTerm2 n A)
       (x2 : OpPointed0MagmaTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpPointed0MagmaTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p0ol2 popol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 popol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 popol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p0ol2 popol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           popol2
           x2)
    0L' : Pointed0MagmaTerm
    0L' = 0L
    opL' :
      Pointed0MagmaTerm ->
      Pointed0MagmaTerm ->
      Pointed0MagmaTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      Pointed0MagmaTerm ->
      Staged Pointed0MagmaTerm
    stageB (0L) = Now 0L
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    0Cl' :
      (A : Set) ->
      ClPointed0MagmaTerm A
    0Cl' _ = 0Cl
    opCl' :
      (A : Set) ->
      ClPointed0MagmaTerm A ->
      ClPointed0MagmaTerm A ->
      ClPointed0MagmaTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClPointed0MagmaTerm A ->
      Staged (ClPointed0MagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    0OL' :
      (n : Nat) ->
      OpPointed0MagmaTerm n
    0OL' _ = 0OL
    opOL' :
      (n : Nat) ->
      OpPointed0MagmaTerm n ->
      OpPointed0MagmaTerm n ->
      OpPointed0MagmaTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpPointed0MagmaTerm n ->
      Staged (OpPointed0MagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (0OL) = Now 0OL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    0OL2' :
      (n : Nat) (A : Set) ->
      OpPointed0MagmaTerm2 n A
    0OL2' _ _ = 0OL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpPointed0MagmaTerm2 n A ->
      OpPointed0MagmaTerm2 n A ->
      OpPointed0MagmaTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpPointed0MagmaTerm2 n A ->
      Staged
        (OpPointed0MagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record Pointed0MagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        0T : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module Pointed1Magma where
    record Pointed1Magma
      (A : Set) : Set where
      constructor Pointed1MagmaC
      field
        1 : A
        op : A -> A -> A
    record Pointed1MagmaSig
      (AS : Set) : Set where
      constructor Pointed1MagmaSigSigC
      field
        1S : AS
        opS : AS -> AS -> AS
    record Pointed1MagmaProd
      (AP : Set) : Set where
      constructor Pointed1MagmaProdC
      field
        1P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record Pointed1MagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed1Magma A1)
      (Po2 : Pointed1Magma A2) :
      Set where
      constructor Pointed1MagmaHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Po1) == 1 Po2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Po1 x1 x2) ==
            op Po2 (hom x1) (hom x2)
    record Pointed1MagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : Pointed1Magma A1)
      (Po2 : Pointed1Magma A2) :
      Set where
      constructor Pointed1MagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Po1) (1 Po2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Po1 x1 x2)
            (op Po2 y1 y2)
    data Pointed1MagmaTerm
      : Set where
      1L : Pointed1MagmaTerm
      opL :
        Pointed1MagmaTerm ->
        Pointed1MagmaTerm ->
        Pointed1MagmaTerm
    data ClPointed1MagmaTerm
      (A : Set) : Set where
      sing :
        A -> ClPointed1MagmaTerm A
      1Cl : ClPointed1MagmaTerm A
      opCl :
        ClPointed1MagmaTerm A ->
        ClPointed1MagmaTerm A ->
        ClPointed1MagmaTerm A
    data OpPointed1MagmaTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpPointed1MagmaTerm n
      1OL : OpPointed1MagmaTerm n
      opOL :
        OpPointed1MagmaTerm n ->
        OpPointed1MagmaTerm n ->
        OpPointed1MagmaTerm n
    data OpPointed1MagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpPointed1MagmaTerm2 n A
      sing2 :
        A -> OpPointed1MagmaTerm2 n A
      1OL2 : OpPointed1MagmaTerm2 n A
      opOL2 :
        OpPointed1MagmaTerm2 n A ->
        OpPointed1MagmaTerm2 n A ->
        OpPointed1MagmaTerm2 n A
    simplifyB :
      Pointed1MagmaTerm ->
      Pointed1MagmaTerm
    simplifyB (1L) = 1L
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClPointed1MagmaTerm A ->
      ClPointed1MagmaTerm A
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpPointed1MagmaTerm n ->
      OpPointed1MagmaTerm n
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpPointed1MagmaTerm2 n A ->
      OpPointed1MagmaTerm2 n A
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Pointed1Magma A ->
      Pointed1MagmaTerm -> A
    evalB _ Po (1L) = 1 Po
    evalB _ Po (opL x1 x2) =
      op Po (evalB _ Po x1)
        (evalB _ Po x2)
    evalCl :
      (A : Set) ->
      Pointed1Magma A ->
      ClPointed1MagmaTerm A -> A
    evalCl _ Po (sing x1) = x1
    evalCl _ Po (1Cl) = 1 Po
    evalCl _ Po (opCl x1 x2) =
      op Po (evalCl _ Po x1)
        (evalCl _ Po x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Pointed1Magma A ->
      Vec A n ->
      OpPointed1MagmaTerm n -> A
    evalOp _ n Po vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Po vars (1OL) = 1 Po
    evalOp _ n Po vars (opOL
                        x1
                        x2) =
      op Po (evalOp _ n Po vars x1)
        (evalOp _ n Po vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Pointed1Magma A ->
      Vec A n ->
      OpPointed1MagmaTerm2 n A -> A
    evalOpE _ n Po vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Po vars (sing2 x1) =
      x1
    evalOpE _ n Po vars (1OL2) =
      1 Po
    evalOpE _ n Po vars (opOL2
                         x1
                         x2) =
      op Po (evalOpE _ n Po vars x1)
        (evalOpE _ n Po vars x2)
    inductionB :
      (P : Pointed1MagmaTerm ->
           Set) ->
      P 1L ->
      ((x1 : Pointed1MagmaTerm)
       (x2 : Pointed1MagmaTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : Pointed1MagmaTerm) -> P x
    inductionB p p1l popl (1L) = p1l
    inductionB p p1l popl (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p p1l popl x1)
        (inductionB p p1l popl x2)
    inductionCl :
      (A : Set)
      (P : ClPointed1MagmaTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 1Cl ->
      ((x1 : ClPointed1MagmaTerm A)
       (x2 : ClPointed1MagmaTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClPointed1MagmaTerm A) ->
      P x
    inductionCl _ p psing p1cl popcl (sing
                                      x1) = psing x1
    inductionCl _ p psing p1cl popcl (1Cl) =
      p1cl
    inductionCl _ p psing p1cl popcl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing p1cl
           popcl
           x1)
        (inductionCl _ p psing p1cl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpPointed1MagmaTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 1OL ->
      ((x1 : OpPointed1MagmaTerm n)
       (x2 : OpPointed1MagmaTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpPointed1MagmaTerm n) ->
      P x
    inductionOp _ p pv p1ol popol (v
                                   x1) = pv x1
    inductionOp _ p pv p1ol popol (1OL) =
      p1ol
    inductionOp _ p pv p1ol popol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv p1ol popol
           x1)
        (inductionOp _ p pv p1ol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpPointed1MagmaTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 1OL2 ->
      ((x1 : OpPointed1MagmaTerm2 n A)
       (x2 : OpPointed1MagmaTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpPointed1MagmaTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p1ol2 popol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p1ol2 popol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p1ol2 popol2 (1OL2) =
      p1ol2
    inductionOpE _ _ p pv2 psing2 p1ol2 popol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p1ol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p1ol2
           popol2
           x2)
    1L' : Pointed1MagmaTerm
    1L' = 1L
    opL' :
      Pointed1MagmaTerm ->
      Pointed1MagmaTerm ->
      Pointed1MagmaTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      Pointed1MagmaTerm ->
      Staged Pointed1MagmaTerm
    stageB (1L) = Now 1L
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    1Cl' :
      (A : Set) ->
      ClPointed1MagmaTerm A
    1Cl' _ = 1Cl
    opCl' :
      (A : Set) ->
      ClPointed1MagmaTerm A ->
      ClPointed1MagmaTerm A ->
      ClPointed1MagmaTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClPointed1MagmaTerm A ->
      Staged (ClPointed1MagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (1Cl) = Now 1Cl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    1OL' :
      (n : Nat) ->
      OpPointed1MagmaTerm n
    1OL' _ = 1OL
    opOL' :
      (n : Nat) ->
      OpPointed1MagmaTerm n ->
      OpPointed1MagmaTerm n ->
      OpPointed1MagmaTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpPointed1MagmaTerm n ->
      Staged (OpPointed1MagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (1OL) = Now 1OL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    1OL2' :
      (n : Nat) (A : Set) ->
      OpPointed1MagmaTerm2 n A
    1OL2' _ _ = 1OL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpPointed1MagmaTerm2 n A ->
      OpPointed1MagmaTerm2 n A ->
      OpPointed1MagmaTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpPointed1MagmaTerm2 n A ->
      Staged
        (OpPointed1MagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (1OL2) = Now 1OL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record Pointed1MagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        1T : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module PointedInvolutiveMagma0Sig where
    record PointedInvolutiveMagma0Sig
      (A : Set) : Set where
      constructor PointedInvolutiveMagma0SigC
      field
        * : A -> A -> A
        prim : A -> A
        0 : A
    record PointedInvolutiveMagma0SigSig
      (AS : Set) : Set where
      constructor PointedInvolutiveMagma0SigSigSigC
      field
        *S : AS -> AS -> AS
        primS : AS -> AS
        0S : AS
    record PointedInvolutiveMagma0SigProd
      (AP : Set) : Set where
      constructor PointedInvolutiveMagma0SigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        0P : Prod AP AP
    record PointedInvolutiveMagma0SigHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedInvolutiveMagma0Sig
         A1)
      (Po2 : PointedInvolutiveMagma0Sig
         A2) : Set where
      constructor PointedInvolutiveMagma0SigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Po1 x1 x2) ==
            * Po2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Po1 x1) ==
            prim Po2 (hom x1)
        pres-0 : hom (0 Po1) == 0 Po2
    record PointedInvolutiveMagma0SigRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedInvolutiveMagma0Sig
         A1)
      (Po2 : PointedInvolutiveMagma0Sig
         A2) : Set where
      constructor PointedInvolutiveMagma0SigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Po1 x1 x2)
            (* Po2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Po1 x1)
            (prim Po2 y1)
        interp-0 :
          interp (0 Po1) (0 Po2)
    data PointedInvolutiveMagma0SigTerm
      : Set where
      *L :
        PointedInvolutiveMagma0SigTerm ->
        PointedInvolutiveMagma0SigTerm ->
        PointedInvolutiveMagma0SigTerm
      primL :
        PointedInvolutiveMagma0SigTerm ->
        PointedInvolutiveMagma0SigTerm
      0L :
        PointedInvolutiveMagma0SigTerm
    data ClPointedInvolutiveMagma0SigTerm
      (A : Set) : Set where
      sing :
        A ->
        ClPointedInvolutiveMagma0SigTerm
          A
      *Cl :
        ClPointedInvolutiveMagma0SigTerm
          A ->
        ClPointedInvolutiveMagma0SigTerm
          A ->
        ClPointedInvolutiveMagma0SigTerm
          A
      primCl :
        ClPointedInvolutiveMagma0SigTerm
          A ->
        ClPointedInvolutiveMagma0SigTerm
          A
      0Cl :
        ClPointedInvolutiveMagma0SigTerm
          A
    data OpPointedInvolutiveMagma0SigTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpPointedInvolutiveMagma0SigTerm
          n
      *OL :
        OpPointedInvolutiveMagma0SigTerm
          n ->
        OpPointedInvolutiveMagma0SigTerm
          n ->
        OpPointedInvolutiveMagma0SigTerm
          n
      primOL :
        OpPointedInvolutiveMagma0SigTerm
          n ->
        OpPointedInvolutiveMagma0SigTerm
          n
      0OL :
        OpPointedInvolutiveMagma0SigTerm
          n
    data OpPointedInvolutiveMagma0SigTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpPointedInvolutiveMagma0SigTerm2
          n
          A
      sing2 :
        A ->
        OpPointedInvolutiveMagma0SigTerm2
          n
          A
      *OL2 :
        OpPointedInvolutiveMagma0SigTerm2
          n
          A ->
        OpPointedInvolutiveMagma0SigTerm2
          n
          A ->
        OpPointedInvolutiveMagma0SigTerm2
          n
          A
      primOL2 :
        OpPointedInvolutiveMagma0SigTerm2
          n
          A ->
        OpPointedInvolutiveMagma0SigTerm2
          n
          A
      0OL2 :
        OpPointedInvolutiveMagma0SigTerm2
          n
          A
    simplifyB :
      PointedInvolutiveMagma0SigTerm ->
      PointedInvolutiveMagma0SigTerm
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyB (0L) = 0L
    simplifyCl :
      (A : Set) ->
      ClPointedInvolutiveMagma0SigTerm
        A ->
      ClPointedInvolutiveMagma0SigTerm
        A
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpPointedInvolutiveMagma0SigTerm
        n ->
      OpPointedInvolutiveMagma0SigTerm
        n
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpPointedInvolutiveMagma0SigTerm2
        n
        A ->
      OpPointedInvolutiveMagma0SigTerm2
        n
        A
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      PointedInvolutiveMagma0Sig A ->
      PointedInvolutiveMagma0SigTerm ->
      A
    evalB _ Po (*L x1 x2) =
      * Po (evalB _ Po x1)
        (evalB _ Po x2)
    evalB _ Po (primL x1) =
      prim Po (evalB _ Po x1)
    evalB _ Po (0L) = 0 Po
    evalCl :
      (A : Set) ->
      PointedInvolutiveMagma0Sig A ->
      ClPointedInvolutiveMagma0SigTerm
        A -> A
    evalCl _ Po (sing x1) = x1
    evalCl _ Po (*Cl x1 x2) =
      * Po (evalCl _ Po x1)
        (evalCl _ Po x2)
    evalCl _ Po (primCl x1) =
      prim Po (evalCl _ Po x1)
    evalCl _ Po (0Cl) = 0 Po
    evalOp :
      (A : Set) (n : Nat) ->
      PointedInvolutiveMagma0Sig A ->
      Vec A n ->
      OpPointedInvolutiveMagma0SigTerm
        n -> A
    evalOp _ n Po vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Po vars (*OL x1 x2) =
      * Po (evalOp _ n Po vars x1)
        (evalOp _ n Po vars x2)
    evalOp _ n Po vars (primOL x1) =
      prim Po (evalOp _ n Po vars x1)
    evalOp _ n Po vars (0OL) = 0 Po
    evalOpE :
      (A : Set) (n : Nat) ->
      PointedInvolutiveMagma0Sig A ->
      Vec A n ->
      OpPointedInvolutiveMagma0SigTerm2
        n
        A -> A
    evalOpE _ n Po vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Po vars (sing2 x1) =
      x1
    evalOpE _ n Po vars (*OL2
                         x1
                         x2) =
      * Po (evalOpE _ n Po vars x1)
        (evalOpE _ n Po vars x2)
    evalOpE _ n Po vars (primOL2
                         x1) =
      prim Po (evalOpE _ n Po vars x1)
    evalOpE _ n Po vars (0OL2) =
      0 Po
    inductionB :
      (P : PointedInvolutiveMagma0SigTerm ->
           Set) ->
      ((x1 : PointedInvolutiveMagma0SigTerm)
       (x2 : PointedInvolutiveMagma0SigTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : PointedInvolutiveMagma0SigTerm) ->
       P x1 -> P (primL x1)) ->
      P 0L ->
      (x : PointedInvolutiveMagma0SigTerm) ->
      P x
    inductionB p p*l ppriml p0l (*L
                                 x1
                                 x2) =
      p*l _ _
        (inductionB p p*l ppriml p0l x1)
        (inductionB p p*l ppriml p0l x2)
    inductionB p p*l ppriml p0l (primL
                                 x1) =
      ppriml _
        (inductionB p p*l ppriml p0l x1)
    inductionB p p*l ppriml p0l (0L) =
      p0l
    inductionCl :
      (A : Set)
      (P : ClPointedInvolutiveMagma0SigTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClPointedInvolutiveMagma0SigTerm
          A)
       (x2 : ClPointedInvolutiveMagma0SigTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClPointedInvolutiveMagma0SigTerm
          A) -> P x1 -> P (primCl x1)) ->
      P 0Cl ->
      (x : ClPointedInvolutiveMagma0SigTerm
         A) -> P x
    inductionCl _ p psing p*cl pprimcl p0cl (sing
                                             x1) = psing x1
    inductionCl _ p psing p*cl pprimcl p0cl (*Cl
                                             x1
                                             x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl
           pprimcl
           p0cl
           x1)
        (inductionCl _ p psing p*cl
           pprimcl
           p0cl
           x2)
    inductionCl _ p psing p*cl pprimcl p0cl (primCl
                                             x1) =
      pprimcl _
        (inductionCl _ p psing p*cl
           pprimcl
           p0cl
           x1)
    inductionCl _ p psing p*cl pprimcl p0cl (0Cl) =
      p0cl
    inductionOp :
      (n : Nat)
      (P : OpPointedInvolutiveMagma0SigTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpPointedInvolutiveMagma0SigTerm
          n)
       (x2 : OpPointedInvolutiveMagma0SigTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpPointedInvolutiveMagma0SigTerm
          n) -> P x1 -> P (primOL x1)) ->
      P 0OL ->
      (x : OpPointedInvolutiveMagma0SigTerm
         n) -> P x
    inductionOp _ p pv p*ol pprimol p0ol (v
                                          x1) = pv x1
    inductionOp _ p pv p*ol pprimol p0ol (*OL
                                          x1
                                          x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol pprimol
           p0ol
           x1)
        (inductionOp _ p pv p*ol pprimol
           p0ol
           x2)
    inductionOp _ p pv p*ol pprimol p0ol (primOL
                                          x1) =
      pprimol _
        (inductionOp _ p pv p*ol pprimol
           p0ol
           x1)
    inductionOp _ p pv p*ol pprimol p0ol (0OL) =
      p0ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpPointedInvolutiveMagma0SigTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpPointedInvolutiveMagma0SigTerm2
          n
          A)
       (x2 : OpPointedInvolutiveMagma0SigTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpPointedInvolutiveMagma0SigTerm2
          n
          A) -> P x1 -> P (primOL2 x1)) ->
      P 0OL2 ->
      (x : OpPointedInvolutiveMagma0SigTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 pprimol2 p0ol2 (v2
                                                        x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 pprimol2 p0ol2 (sing2
                                                        x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 pprimol2 p0ol2 (*OL2
                                                        x1
                                                        x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           pprimol2
           p0ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           pprimol2
           p0ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 pprimol2 p0ol2 (primOL2
                                                        x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           pprimol2
           p0ol2
           x1)
    inductionOpE _ _ p pv2 psing2 p*ol2 pprimol2 p0ol2 (0OL2) =
      p0ol2
    *L' :
      PointedInvolutiveMagma0SigTerm ->
      PointedInvolutiveMagma0SigTerm ->
      PointedInvolutiveMagma0SigTerm
    *L' x1 x2 = *L x1 x2
    primL' :
      PointedInvolutiveMagma0SigTerm ->
      PointedInvolutiveMagma0SigTerm
    primL' x1 = primL x1
    0L' :
      PointedInvolutiveMagma0SigTerm
    0L' = 0L
    stageB :
      PointedInvolutiveMagma0SigTerm ->
      Staged
        PointedInvolutiveMagma0SigTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    stageB (0L) = Now 0L
    *Cl' :
      (A : Set) ->
      ClPointedInvolutiveMagma0SigTerm
        A ->
      ClPointedInvolutiveMagma0SigTerm
        A ->
      ClPointedInvolutiveMagma0SigTerm
        A
    *Cl' _ x1 x2 = *Cl x1 x2
    primCl' :
      (A : Set) ->
      ClPointedInvolutiveMagma0SigTerm
        A ->
      ClPointedInvolutiveMagma0SigTerm
        A
    primCl' _ x1 = primCl x1
    0Cl' :
      (A : Set) ->
      ClPointedInvolutiveMagma0SigTerm
        A
    0Cl' _ = 0Cl
    stageCl :
      (A : Set) ->
      ClPointedInvolutiveMagma0SigTerm
        A ->
      Staged
        (ClPointedInvolutiveMagma0SigTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    stageCl _ (0Cl) = Now 0Cl
    *OL' :
      (n : Nat) ->
      OpPointedInvolutiveMagma0SigTerm
        n ->
      OpPointedInvolutiveMagma0SigTerm
        n ->
      OpPointedInvolutiveMagma0SigTerm
        n
    *OL' _ x1 x2 = *OL x1 x2
    primOL' :
      (n : Nat) ->
      OpPointedInvolutiveMagma0SigTerm
        n ->
      OpPointedInvolutiveMagma0SigTerm
        n
    primOL' _ x1 = primOL x1
    0OL' :
      (n : Nat) ->
      OpPointedInvolutiveMagma0SigTerm
        n
    0OL' _ = 0OL
    stageOp :
      (n : Nat) ->
      OpPointedInvolutiveMagma0SigTerm
        n ->
      Staged
        (OpPointedInvolutiveMagma0SigTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    stageOp _ (0OL) = Now 0OL
    *OL2' :
      (n : Nat) (A : Set) ->
      OpPointedInvolutiveMagma0SigTerm2
        n
        A ->
      OpPointedInvolutiveMagma0SigTerm2
        n
        A ->
      OpPointedInvolutiveMagma0SigTerm2
        n
        A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    primOL2' :
      (n : Nat) (A : Set) ->
      OpPointedInvolutiveMagma0SigTerm2
        n
        A ->
      OpPointedInvolutiveMagma0SigTerm2
        n
        A
    primOL2' _ _ x1 = primOL2 x1
    0OL2' :
      (n : Nat) (A : Set) ->
      OpPointedInvolutiveMagma0SigTerm2
        n
        A
    0OL2' _ _ = 0OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpPointedInvolutiveMagma0SigTerm2
        n
        A ->
      Staged
        (OpPointedInvolutiveMagma0SigTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (0OL2) = Now 0OL2
    record PointedInvolutiveMagma0SigTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        primT : Repr A -> Repr A
        0T : Repr A
  
  module PointedMagma where
    record PointedMagma
      (A : Set) : Set where
      constructor PointedMagmaC
      field
        e : A
        op : A -> A -> A
    record PointedMagmaSig
      (AS : Set) : Set where
      constructor PointedMagmaSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record PointedMagmaProd
      (AP : Set) : Set where
      constructor PointedMagmaProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record PointedMagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedMagma A1)
      (Po2 : PointedMagma A2) :
      Set where
      constructor PointedMagmaHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Po1) == e Po2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Po1 x1 x2) ==
            op Po2 (hom x1) (hom x2)
    record PointedMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedMagma A1)
      (Po2 : PointedMagma A2) :
      Set where
      constructor PointedMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Po1) (e Po2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Po1 x1 x2)
            (op Po2 y1 y2)
    data PointedMagmaTerm
      : Set where
      eL : PointedMagmaTerm
      opL :
        PointedMagmaTerm ->
        PointedMagmaTerm ->
        PointedMagmaTerm
    data ClPointedMagmaTerm
      (A : Set) : Set where
      sing :
        A -> ClPointedMagmaTerm A
      eCl : ClPointedMagmaTerm A
      opCl :
        ClPointedMagmaTerm A ->
        ClPointedMagmaTerm A ->
        ClPointedMagmaTerm A
    data OpPointedMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpPointedMagmaTerm n
      eOL : OpPointedMagmaTerm n
      opOL :
        OpPointedMagmaTerm n ->
        OpPointedMagmaTerm n ->
        OpPointedMagmaTerm n
    data OpPointedMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpPointedMagmaTerm2 n A
      sing2 :
        A -> OpPointedMagmaTerm2 n A
      eOL2 : OpPointedMagmaTerm2 n A
      opOL2 :
        OpPointedMagmaTerm2 n A ->
        OpPointedMagmaTerm2 n A ->
        OpPointedMagmaTerm2 n A
    simplifyB :
      PointedMagmaTerm ->
      PointedMagmaTerm
    simplifyB (eL) = eL
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClPointedMagmaTerm A ->
      ClPointedMagmaTerm A
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpPointedMagmaTerm n ->
      OpPointedMagmaTerm n
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpPointedMagmaTerm2 n A ->
      OpPointedMagmaTerm2 n A
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      PointedMagma A ->
      PointedMagmaTerm -> A
    evalB _ Po (eL) = e Po
    evalB _ Po (opL x1 x2) =
      op Po (evalB _ Po x1)
        (evalB _ Po x2)
    evalCl :
      (A : Set) ->
      PointedMagma A ->
      ClPointedMagmaTerm A -> A
    evalCl _ Po (sing x1) = x1
    evalCl _ Po (eCl) = e Po
    evalCl _ Po (opCl x1 x2) =
      op Po (evalCl _ Po x1)
        (evalCl _ Po x2)
    evalOp :
      (A : Set) (n : Nat) ->
      PointedMagma A ->
      Vec A n ->
      OpPointedMagmaTerm n -> A
    evalOp _ n Po vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Po vars (eOL) = e Po
    evalOp _ n Po vars (opOL
                        x1
                        x2) =
      op Po (evalOp _ n Po vars x1)
        (evalOp _ n Po vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      PointedMagma A ->
      Vec A n ->
      OpPointedMagmaTerm2 n A -> A
    evalOpE _ n Po vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Po vars (sing2 x1) =
      x1
    evalOpE _ n Po vars (eOL2) =
      e Po
    evalOpE _ n Po vars (opOL2
                         x1
                         x2) =
      op Po (evalOpE _ n Po vars x1)
        (evalOpE _ n Po vars x2)
    inductionB :
      (P : PointedMagmaTerm -> Set) ->
      P eL ->
      ((x1 : PointedMagmaTerm)
       (x2 : PointedMagmaTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : PointedMagmaTerm) -> P x
    inductionB p pel popl (eL) = pel
    inductionB p pel popl (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p pel popl x1)
        (inductionB p pel popl x2)
    inductionCl :
      (A : Set)
      (P : ClPointedMagmaTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P eCl ->
      ((x1 : ClPointedMagmaTerm A)
       (x2 : ClPointedMagmaTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClPointedMagmaTerm A) ->
      P x
    inductionCl _ p psing pecl popcl (sing
                                      x1) = psing x1
    inductionCl _ p psing pecl popcl (eCl) =
      pecl
    inductionCl _ p psing pecl popcl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing pecl
           popcl
           x1)
        (inductionCl _ p psing pecl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpPointedMagmaTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P eOL ->
      ((x1 : OpPointedMagmaTerm n)
       (x2 : OpPointedMagmaTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpPointedMagmaTerm n) ->
      P x
    inductionOp _ p pv peol popol (v
                                   x1) = pv x1
    inductionOp _ p pv peol popol (eOL) =
      peol
    inductionOp _ p pv peol popol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv peol popol
           x1)
        (inductionOp _ p pv peol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpPointedMagmaTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P eOL2 ->
      ((x1 : OpPointedMagmaTerm2 n A)
       (x2 : OpPointedMagmaTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpPointedMagmaTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x2)
    eL' : PointedMagmaTerm
    eL' = eL
    opL' :
      PointedMagmaTerm ->
      PointedMagmaTerm ->
      PointedMagmaTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      PointedMagmaTerm ->
      Staged PointedMagmaTerm
    stageB (eL) = Now eL
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    eCl' :
      (A : Set) ->
      ClPointedMagmaTerm A
    eCl' _ = eCl
    opCl' :
      (A : Set) ->
      ClPointedMagmaTerm A ->
      ClPointedMagmaTerm A ->
      ClPointedMagmaTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClPointedMagmaTerm A ->
      Staged (ClPointedMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (eCl) = Now eCl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    eOL' :
      (n : Nat) ->
      OpPointedMagmaTerm n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      OpPointedMagmaTerm n ->
      OpPointedMagmaTerm n ->
      OpPointedMagmaTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpPointedMagmaTerm n ->
      Staged (OpPointedMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (eOL) = Now eOL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    eOL2' :
      (n : Nat) (A : Set) ->
      OpPointedMagmaTerm2 n A
    eOL2' _ _ = eOL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpPointedMagmaTerm2 n A ->
      OpPointedMagmaTerm2 n A ->
      OpPointedMagmaTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpPointedMagmaTerm2 n A ->
      Staged (OpPointedMagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record PointedMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        eT : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module PointedOne where
    record PointedOne
      (A : Set) : Set where
      constructor PointedOneC
      field
        1 : A
    record PointedOneSig
      (AS : Set) : Set where
      constructor PointedOneSigSigC
      field
        1S : AS
    record PointedOneProd
      (AP : Set) : Set where
      constructor PointedOneProdC
      field
        1P : Prod AP AP
    record PointedOneHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedOne A1)
      (Po2 : PointedOne A2) :
      Set where
      constructor PointedOneHomC
      field
        hom : A1 -> A2
        pres-1 : hom (1 Po1) == 1 Po2
    record PointedOneRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedOne A1)
      (Po2 : PointedOne A2) :
      Set where
      constructor PointedOneRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-1 :
          interp (1 Po1) (1 Po2)
    data PointedOneTerm : Set where
      1L : PointedOneTerm
    data ClPointedOneTerm
      (A : Set) : Set where
      sing : A -> ClPointedOneTerm A
      1Cl : ClPointedOneTerm A
    data OpPointedOneTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpPointedOneTerm n
      1OL : OpPointedOneTerm n
    data OpPointedOneTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpPointedOneTerm2 n A
      sing2 :
        A -> OpPointedOneTerm2 n A
      1OL2 : OpPointedOneTerm2 n A
    simplifyB :
      PointedOneTerm -> PointedOneTerm
    simplifyB (1L) = 1L
    simplifyCl :
      (A : Set) ->
      ClPointedOneTerm A ->
      ClPointedOneTerm A
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpPointedOneTerm n ->
      OpPointedOneTerm n
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpPointedOneTerm2 n A ->
      OpPointedOneTerm2 n A
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      PointedOne A ->
      PointedOneTerm -> A
    evalB _ Po (1L) = 1 Po
    evalCl :
      (A : Set) ->
      PointedOne A ->
      ClPointedOneTerm A -> A
    evalCl _ Po (sing x1) = x1
    evalCl _ Po (1Cl) = 1 Po
    evalOp :
      (A : Set) (n : Nat) ->
      PointedOne A ->
      Vec A n ->
      OpPointedOneTerm n -> A
    evalOp _ n Po vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Po vars (1OL) = 1 Po
    evalOpE :
      (A : Set) (n : Nat) ->
      PointedOne A ->
      Vec A n ->
      OpPointedOneTerm2 n A -> A
    evalOpE _ n Po vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Po vars (sing2 x1) =
      x1
    evalOpE _ n Po vars (1OL2) =
      1 Po
    inductionB :
      (P : PointedOneTerm -> Set) ->
      P 1L ->
      (x : PointedOneTerm) -> P x
    inductionB p p1l (1L) = p1l
    inductionCl :
      (A : Set)
      (P : ClPointedOneTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 1Cl ->
      (x : ClPointedOneTerm A) -> P x
    inductionCl _ p psing p1cl (sing
                                x1) = psing x1
    inductionCl _ p psing p1cl (1Cl) =
      p1cl
    inductionOp :
      (n : Nat)
      (P : OpPointedOneTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 1OL ->
      (x : OpPointedOneTerm n) -> P x
    inductionOp _ p pv p1ol (v x1) =
      pv x1
    inductionOp _ p pv p1ol (1OL) =
      p1ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpPointedOneTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 1OL2 ->
      (x : OpPointedOneTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p1ol2 (v2
                                         x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p1ol2 (sing2
                                         x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p1ol2 (1OL2) =
      p1ol2
    1L' : PointedOneTerm
    1L' = 1L
    stageB :
      PointedOneTerm ->
      Staged PointedOneTerm
    stageB (1L) = Now 1L
    1Cl' :
      (A : Set) -> ClPointedOneTerm A
    1Cl' _ = 1Cl
    stageCl :
      (A : Set) ->
      ClPointedOneTerm A ->
      Staged (ClPointedOneTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (1Cl) = Now 1Cl
    1OL' :
      (n : Nat) -> OpPointedOneTerm n
    1OL' _ = 1OL
    stageOp :
      (n : Nat) ->
      OpPointedOneTerm n ->
      Staged (OpPointedOneTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (1OL) = Now 1OL
    1OL2' :
      (n : Nat) (A : Set) ->
      OpPointedOneTerm2 n A
    1OL2' _ _ = 1OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpPointedOneTerm2 n A ->
      Staged (OpPointedOneTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (1OL2) = Now 1OL2
    record PointedOneTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        1T : Repr A
  
  module PointedPlusMagma where
    record PointedPlusMagma
      (A : Set) : Set where
      constructor PointedPlusMagmaC
      field
        + : A -> A -> A
        e : A
    record PointedPlusMagmaSig
      (AS : Set) : Set where
      constructor PointedPlusMagmaSigSigC
      field
        +S : AS -> AS -> AS
        eS : AS
    record PointedPlusMagmaProd
      (AP : Set) : Set where
      constructor PointedPlusMagmaProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
    record PointedPlusMagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedPlusMagma A1)
      (Po2 : PointedPlusMagma A2) :
      Set where
      constructor PointedPlusMagmaHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Po1 x1 x2) ==
            + Po2 (hom x1) (hom x2)
        pres-e : hom (e Po1) == e Po2
    record PointedPlusMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedPlusMagma A1)
      (Po2 : PointedPlusMagma A2) :
      Set where
      constructor PointedPlusMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Po1 x1 x2)
            (+ Po2 y1 y2)
        interp-e :
          interp (e Po1) (e Po2)
    data PointedPlusMagmaTerm
      : Set where
      +L :
        PointedPlusMagmaTerm ->
        PointedPlusMagmaTerm ->
        PointedPlusMagmaTerm
      eL : PointedPlusMagmaTerm
    data ClPointedPlusMagmaTerm
      (A : Set) : Set where
      sing :
        A -> ClPointedPlusMagmaTerm A
      +Cl :
        ClPointedPlusMagmaTerm A ->
        ClPointedPlusMagmaTerm A ->
        ClPointedPlusMagmaTerm A
      eCl : ClPointedPlusMagmaTerm A
    data OpPointedPlusMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpPointedPlusMagmaTerm n
      +OL :
        OpPointedPlusMagmaTerm n ->
        OpPointedPlusMagmaTerm n ->
        OpPointedPlusMagmaTerm n
      eOL : OpPointedPlusMagmaTerm n
    data OpPointedPlusMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpPointedPlusMagmaTerm2 n A
      sing2 :
        A -> OpPointedPlusMagmaTerm2 n A
      +OL2 :
        OpPointedPlusMagmaTerm2 n A ->
        OpPointedPlusMagmaTerm2 n A ->
        OpPointedPlusMagmaTerm2 n A
      eOL2 :
        OpPointedPlusMagmaTerm2 n A
    simplifyB :
      PointedPlusMagmaTerm ->
      PointedPlusMagmaTerm
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (eL) = eL
    simplifyCl :
      (A : Set) ->
      ClPointedPlusMagmaTerm A ->
      ClPointedPlusMagmaTerm A
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpPointedPlusMagmaTerm n ->
      OpPointedPlusMagmaTerm n
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpPointedPlusMagmaTerm2 n A ->
      OpPointedPlusMagmaTerm2 n A
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      PointedPlusMagma A ->
      PointedPlusMagmaTerm -> A
    evalB _ Po (+L x1 x2) =
      + Po (evalB _ Po x1)
        (evalB _ Po x2)
    evalB _ Po (eL) = e Po
    evalCl :
      (A : Set) ->
      PointedPlusMagma A ->
      ClPointedPlusMagmaTerm A -> A
    evalCl _ Po (sing x1) = x1
    evalCl _ Po (+Cl x1 x2) =
      + Po (evalCl _ Po x1)
        (evalCl _ Po x2)
    evalCl _ Po (eCl) = e Po
    evalOp :
      (A : Set) (n : Nat) ->
      PointedPlusMagma A ->
      Vec A n ->
      OpPointedPlusMagmaTerm n -> A
    evalOp _ n Po vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Po vars (+OL x1 x2) =
      + Po (evalOp _ n Po vars x1)
        (evalOp _ n Po vars x2)
    evalOp _ n Po vars (eOL) = e Po
    evalOpE :
      (A : Set) (n : Nat) ->
      PointedPlusMagma A ->
      Vec A n ->
      OpPointedPlusMagmaTerm2 n A -> A
    evalOpE _ n Po vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Po vars (sing2 x1) =
      x1
    evalOpE _ n Po vars (+OL2
                         x1
                         x2) =
      + Po (evalOpE _ n Po vars x1)
        (evalOpE _ n Po vars x2)
    evalOpE _ n Po vars (eOL2) =
      e Po
    inductionB :
      (P : PointedPlusMagmaTerm ->
           Set) ->
      ((x1 : PointedPlusMagmaTerm)
       (x2 : PointedPlusMagmaTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      P eL ->
      (x : PointedPlusMagmaTerm) ->
      P x
    inductionB p p+l pel (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p+l pel x1)
        (inductionB p p+l pel x2)
    inductionB p p+l pel (eL) = pel
    inductionCl :
      (A : Set)
      (P : ClPointedPlusMagmaTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClPointedPlusMagmaTerm A)
       (x2 : ClPointedPlusMagmaTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      P eCl ->
      (x : ClPointedPlusMagmaTerm
         A) -> P x
    inductionCl _ p psing p+cl pecl (sing
                                     x1) = psing x1
    inductionCl _ p psing p+cl pecl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p+cl pecl
           x1)
        (inductionCl _ p psing p+cl pecl
           x2)
    inductionCl _ p psing p+cl pecl (eCl) =
      pecl
    inductionOp :
      (n : Nat)
      (P : OpPointedPlusMagmaTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpPointedPlusMagmaTerm n)
       (x2 : OpPointedPlusMagmaTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      P eOL ->
      (x : OpPointedPlusMagmaTerm
         n) -> P x
    inductionOp _ p pv p+ol peol (v
                                  x1) = pv x1
    inductionOp _ p pv p+ol peol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p+ol peol
           x1)
        (inductionOp _ p pv p+ol peol
           x2)
    inductionOp _ p pv p+ol peol (eOL) =
      peol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpPointedPlusMagmaTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpPointedPlusMagmaTerm2 n
          A)
       (x2 : OpPointedPlusMagmaTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      P eOL2 ->
      (x : OpPointedPlusMagmaTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p+ol2 peol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 peol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 peol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           peol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           peol2
           x2)
    inductionOpE _ _ p pv2 psing2 p+ol2 peol2 (eOL2) =
      peol2
    +L' :
      PointedPlusMagmaTerm ->
      PointedPlusMagmaTerm ->
      PointedPlusMagmaTerm
    +L' x1 x2 = +L x1 x2
    eL' : PointedPlusMagmaTerm
    eL' = eL
    stageB :
      PointedPlusMagmaTerm ->
      Staged PointedPlusMagmaTerm
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (eL) = Now eL
    +Cl' :
      (A : Set) ->
      ClPointedPlusMagmaTerm A ->
      ClPointedPlusMagmaTerm A ->
      ClPointedPlusMagmaTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    eCl' :
      (A : Set) ->
      ClPointedPlusMagmaTerm A
    eCl' _ = eCl
    stageCl :
      (A : Set) ->
      ClPointedPlusMagmaTerm A ->
      Staged
        (ClPointedPlusMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (eCl) = Now eCl
    +OL' :
      (n : Nat) ->
      OpPointedPlusMagmaTerm n ->
      OpPointedPlusMagmaTerm n ->
      OpPointedPlusMagmaTerm n
    +OL' _ x1 x2 = +OL x1 x2
    eOL' :
      (n : Nat) ->
      OpPointedPlusMagmaTerm n
    eOL' _ = eOL
    stageOp :
      (n : Nat) ->
      OpPointedPlusMagmaTerm n ->
      Staged
        (OpPointedPlusMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (eOL) = Now eOL
    +OL2' :
      (n : Nat) (A : Set) ->
      OpPointedPlusMagmaTerm2 n A ->
      OpPointedPlusMagmaTerm2 n A ->
      OpPointedPlusMagmaTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    eOL2' :
      (n : Nat) (A : Set) ->
      OpPointedPlusMagmaTerm2 n A
    eOL2' _ _ = eOL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpPointedPlusMagmaTerm2 n A ->
      Staged
        (OpPointedPlusMagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (eOL2) = Now eOL2
    record PointedPlusMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        +T : Repr A -> Repr A -> Repr A
        eT : Repr A
  
  module PointedSemigroup where
    record PointedSemigroup
      (A : Set) : Set where
      constructor PointedSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        e : A
    record PointedSemigroupSig
      (AS : Set) : Set where
      constructor PointedSemigroupSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record PointedSemigroupProd
      (AP : Set) : Set where
      constructor PointedSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record PointedSemigroupHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedSemigroup A1)
      (Po2 : PointedSemigroup A2) :
      Set where
      constructor PointedSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Po1 x1 x2) ==
            op Po2 (hom x1) (hom x2)
        pres-e : hom (e Po1) == e Po2
    record PointedSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedSemigroup A1)
      (Po2 : PointedSemigroup A2) :
      Set where
      constructor PointedSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Po1 x1 x2)
            (op Po2 y1 y2)
        interp-e :
          interp (e Po1) (e Po2)
    data PointedSemigroupTerm
      : Set where
      opL :
        PointedSemigroupTerm ->
        PointedSemigroupTerm ->
        PointedSemigroupTerm
      eL : PointedSemigroupTerm
    data ClPointedSemigroupTerm
      (A : Set) : Set where
      sing :
        A -> ClPointedSemigroupTerm A
      opCl :
        ClPointedSemigroupTerm A ->
        ClPointedSemigroupTerm A ->
        ClPointedSemigroupTerm A
      eCl : ClPointedSemigroupTerm A
    data OpPointedSemigroupTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpPointedSemigroupTerm n
      opOL :
        OpPointedSemigroupTerm n ->
        OpPointedSemigroupTerm n ->
        OpPointedSemigroupTerm n
      eOL : OpPointedSemigroupTerm n
    data OpPointedSemigroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpPointedSemigroupTerm2 n A
      sing2 :
        A -> OpPointedSemigroupTerm2 n A
      opOL2 :
        OpPointedSemigroupTerm2 n A ->
        OpPointedSemigroupTerm2 n A ->
        OpPointedSemigroupTerm2 n A
      eOL2 :
        OpPointedSemigroupTerm2 n A
    simplifyB :
      PointedSemigroupTerm ->
      PointedSemigroupTerm
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (eL) = eL
    simplifyCl :
      (A : Set) ->
      ClPointedSemigroupTerm A ->
      ClPointedSemigroupTerm A
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpPointedSemigroupTerm n ->
      OpPointedSemigroupTerm n
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpPointedSemigroupTerm2 n A ->
      OpPointedSemigroupTerm2 n A
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      PointedSemigroup A ->
      PointedSemigroupTerm -> A
    evalB _ Po (opL x1 x2) =
      op Po (evalB _ Po x1)
        (evalB _ Po x2)
    evalB _ Po (eL) = e Po
    evalCl :
      (A : Set) ->
      PointedSemigroup A ->
      ClPointedSemigroupTerm A -> A
    evalCl _ Po (sing x1) = x1
    evalCl _ Po (opCl x1 x2) =
      op Po (evalCl _ Po x1)
        (evalCl _ Po x2)
    evalCl _ Po (eCl) = e Po
    evalOp :
      (A : Set) (n : Nat) ->
      PointedSemigroup A ->
      Vec A n ->
      OpPointedSemigroupTerm n -> A
    evalOp _ n Po vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Po vars (opOL
                        x1
                        x2) =
      op Po (evalOp _ n Po vars x1)
        (evalOp _ n Po vars x2)
    evalOp _ n Po vars (eOL) = e Po
    evalOpE :
      (A : Set) (n : Nat) ->
      PointedSemigroup A ->
      Vec A n ->
      OpPointedSemigroupTerm2 n A -> A
    evalOpE _ n Po vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Po vars (sing2 x1) =
      x1
    evalOpE _ n Po vars (opOL2
                         x1
                         x2) =
      op Po (evalOpE _ n Po vars x1)
        (evalOpE _ n Po vars x2)
    evalOpE _ n Po vars (eOL2) =
      e Po
    inductionB :
      (P : PointedSemigroupTerm ->
           Set) ->
      ((x1 : PointedSemigroupTerm)
       (x2 : PointedSemigroupTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      P eL ->
      (x : PointedSemigroupTerm) ->
      P x
    inductionB p popl pel (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p popl pel x1)
        (inductionB p popl pel x2)
    inductionB p popl pel (eL) = pel
    inductionCl :
      (A : Set)
      (P : ClPointedSemigroupTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClPointedSemigroupTerm A)
       (x2 : ClPointedSemigroupTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      P eCl ->
      (x : ClPointedSemigroupTerm
         A) -> P x
    inductionCl _ p psing popcl pecl (sing
                                      x1) = psing x1
    inductionCl _ p psing popcl pecl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing popcl
           pecl
           x1)
        (inductionCl _ p psing popcl
           pecl
           x2)
    inductionCl _ p psing popcl pecl (eCl) =
      pecl
    inductionOp :
      (n : Nat)
      (P : OpPointedSemigroupTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpPointedSemigroupTerm n)
       (x2 : OpPointedSemigroupTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      P eOL ->
      (x : OpPointedSemigroupTerm
         n) -> P x
    inductionOp _ p pv popol peol (v
                                   x1) = pv x1
    inductionOp _ p pv popol peol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv popol peol
           x1)
        (inductionOp _ p pv popol peol
           x2)
    inductionOp _ p pv popol peol (eOL) =
      peol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpPointedSemigroupTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpPointedSemigroupTerm2 n
          A)
       (x2 : OpPointedSemigroupTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      P eOL2 ->
      (x : OpPointedSemigroupTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (eOL2) =
      peol2
    opL' :
      PointedSemigroupTerm ->
      PointedSemigroupTerm ->
      PointedSemigroupTerm
    opL' x1 x2 = opL x1 x2
    eL' : PointedSemigroupTerm
    eL' = eL
    stageB :
      PointedSemigroupTerm ->
      Staged PointedSemigroupTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (eL) = Now eL
    opCl' :
      (A : Set) ->
      ClPointedSemigroupTerm A ->
      ClPointedSemigroupTerm A ->
      ClPointedSemigroupTerm A
    opCl' _ x1 x2 = opCl x1 x2
    eCl' :
      (A : Set) ->
      ClPointedSemigroupTerm A
    eCl' _ = eCl
    stageCl :
      (A : Set) ->
      ClPointedSemigroupTerm A ->
      Staged
        (ClPointedSemigroupTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (eCl) = Now eCl
    opOL' :
      (n : Nat) ->
      OpPointedSemigroupTerm n ->
      OpPointedSemigroupTerm n ->
      OpPointedSemigroupTerm n
    opOL' _ x1 x2 = opOL x1 x2
    eOL' :
      (n : Nat) ->
      OpPointedSemigroupTerm n
    eOL' _ = eOL
    stageOp :
      (n : Nat) ->
      OpPointedSemigroupTerm n ->
      Staged
        (OpPointedSemigroupTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (eOL) = Now eOL
    opOL2' :
      (n : Nat) (A : Set) ->
      OpPointedSemigroupTerm2 n A ->
      OpPointedSemigroupTerm2 n A ->
      OpPointedSemigroupTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    eOL2' :
      (n : Nat) (A : Set) ->
      OpPointedSemigroupTerm2 n A
    eOL2' _ _ = eOL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpPointedSemigroupTerm2 n A ->
      Staged
        (OpPointedSemigroupTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (eOL2) = Now eOL2
    record PointedSemigroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
        eT : Repr A
  
  module PointedSteinerMagma where
    record PointedSteinerMagma
      (A : Set) : Set where
      constructor PointedSteinerMagmaC
      field
        op : A -> A -> A
        e : A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
        antiAbsorbent :
          (x : A) (y : A) ->
          op x (op x y) == y
    record PointedSteinerMagmaSig
      (AS : Set) : Set where
      constructor PointedSteinerMagmaSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record PointedSteinerMagmaProd
      (AP : Set) : Set where
      constructor PointedSteinerMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
        antiAbsorbentP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (opP xP yP) == yP
    record PointedSteinerMagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedSteinerMagma A1)
      (Po2 : PointedSteinerMagma A2) :
      Set where
      constructor PointedSteinerMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Po1 x1 x2) ==
            op Po2 (hom x1) (hom x2)
        pres-e : hom (e Po1) == e Po2
    record PointedSteinerMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedSteinerMagma A1)
      (Po2 : PointedSteinerMagma A2) :
      Set where
      constructor PointedSteinerMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Po1 x1 x2)
            (op Po2 y1 y2)
        interp-e :
          interp (e Po1) (e Po2)
    data PointedSteinerMagmaTerm
      : Set where
      opL :
        PointedSteinerMagmaTerm ->
        PointedSteinerMagmaTerm ->
        PointedSteinerMagmaTerm
      eL : PointedSteinerMagmaTerm
    data ClPointedSteinerMagmaTerm
      (A : Set) : Set where
      sing :
        A -> ClPointedSteinerMagmaTerm A
      opCl :
        ClPointedSteinerMagmaTerm A ->
        ClPointedSteinerMagmaTerm A ->
        ClPointedSteinerMagmaTerm A
      eCl :
        ClPointedSteinerMagmaTerm A
    data OpPointedSteinerMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpPointedSteinerMagmaTerm n
      opOL :
        OpPointedSteinerMagmaTerm n ->
        OpPointedSteinerMagmaTerm n ->
        OpPointedSteinerMagmaTerm n
      eOL :
        OpPointedSteinerMagmaTerm n
    data OpPointedSteinerMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpPointedSteinerMagmaTerm2 n A
      sing2 :
        A ->
        OpPointedSteinerMagmaTerm2 n A
      opOL2 :
        OpPointedSteinerMagmaTerm2 n
          A ->
        OpPointedSteinerMagmaTerm2 n
          A ->
        OpPointedSteinerMagmaTerm2 n A
      eOL2 :
        OpPointedSteinerMagmaTerm2 n A
    simplifyB :
      PointedSteinerMagmaTerm ->
      PointedSteinerMagmaTerm
    simplifyB (opL x (opL x y)) = y
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (eL) = eL
    simplifyCl :
      (A : Set) ->
      ClPointedSteinerMagmaTerm A ->
      ClPointedSteinerMagmaTerm A
    simplifyCl _ (opCl
                  x
                  (opCl x y)) = y
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpPointedSteinerMagmaTerm n ->
      OpPointedSteinerMagmaTerm n
    simplifyOp _ (opOL
                  x
                  (opOL x y)) = y
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpPointedSteinerMagmaTerm2 n
        A ->
      OpPointedSteinerMagmaTerm2 n A
    simplifyOpE _ _ (opOL2
                     x
                     (opOL2 x y)) = y
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      PointedSteinerMagma A ->
      PointedSteinerMagmaTerm -> A
    evalB _ Po (opL x1 x2) =
      op Po (evalB _ Po x1)
        (evalB _ Po x2)
    evalB _ Po (eL) = e Po
    evalCl :
      (A : Set) ->
      PointedSteinerMagma A ->
      ClPointedSteinerMagmaTerm A -> A
    evalCl _ Po (sing x1) = x1
    evalCl _ Po (opCl x1 x2) =
      op Po (evalCl _ Po x1)
        (evalCl _ Po x2)
    evalCl _ Po (eCl) = e Po
    evalOp :
      (A : Set) (n : Nat) ->
      PointedSteinerMagma A ->
      Vec A n ->
      OpPointedSteinerMagmaTerm n -> A
    evalOp _ n Po vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Po vars (opOL
                        x1
                        x2) =
      op Po (evalOp _ n Po vars x1)
        (evalOp _ n Po vars x2)
    evalOp _ n Po vars (eOL) = e Po
    evalOpE :
      (A : Set) (n : Nat) ->
      PointedSteinerMagma A ->
      Vec A n ->
      OpPointedSteinerMagmaTerm2 n
        A -> A
    evalOpE _ n Po vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Po vars (sing2 x1) =
      x1
    evalOpE _ n Po vars (opOL2
                         x1
                         x2) =
      op Po (evalOpE _ n Po vars x1)
        (evalOpE _ n Po vars x2)
    evalOpE _ n Po vars (eOL2) =
      e Po
    inductionB :
      (P : PointedSteinerMagmaTerm ->
           Set) ->
      ((x1 : PointedSteinerMagmaTerm)
       (x2 : PointedSteinerMagmaTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      P eL ->
      (x : PointedSteinerMagmaTerm) ->
      P x
    inductionB p popl pel (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p popl pel x1)
        (inductionB p popl pel x2)
    inductionB p popl pel (eL) = pel
    inductionCl :
      (A : Set)
      (P : ClPointedSteinerMagmaTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClPointedSteinerMagmaTerm
          A)
       (x2 : ClPointedSteinerMagmaTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      P eCl ->
      (x : ClPointedSteinerMagmaTerm
         A) -> P x
    inductionCl _ p psing popcl pecl (sing
                                      x1) = psing x1
    inductionCl _ p psing popcl pecl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing popcl
           pecl
           x1)
        (inductionCl _ p psing popcl
           pecl
           x2)
    inductionCl _ p psing popcl pecl (eCl) =
      pecl
    inductionOp :
      (n : Nat)
      (P : OpPointedSteinerMagmaTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpPointedSteinerMagmaTerm
          n)
       (x2 : OpPointedSteinerMagmaTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      P eOL ->
      (x : OpPointedSteinerMagmaTerm
         n) -> P x
    inductionOp _ p pv popol peol (v
                                   x1) = pv x1
    inductionOp _ p pv popol peol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv popol peol
           x1)
        (inductionOp _ p pv popol peol
           x2)
    inductionOp _ p pv popol peol (eOL) =
      peol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpPointedSteinerMagmaTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpPointedSteinerMagmaTerm2
          n
          A)
       (x2 : OpPointedSteinerMagmaTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      P eOL2 ->
      (x : OpPointedSteinerMagmaTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (eOL2) =
      peol2
    opL' :
      PointedSteinerMagmaTerm ->
      PointedSteinerMagmaTerm ->
      PointedSteinerMagmaTerm
    opL' x1 x2 = opL x1 x2
    eL' : PointedSteinerMagmaTerm
    eL' = eL
    stageB :
      PointedSteinerMagmaTerm ->
      Staged PointedSteinerMagmaTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (eL) = Now eL
    opCl' :
      (A : Set) ->
      ClPointedSteinerMagmaTerm A ->
      ClPointedSteinerMagmaTerm A ->
      ClPointedSteinerMagmaTerm A
    opCl' _ x1 x2 = opCl x1 x2
    eCl' :
      (A : Set) ->
      ClPointedSteinerMagmaTerm A
    eCl' _ = eCl
    stageCl :
      (A : Set) ->
      ClPointedSteinerMagmaTerm A ->
      Staged
        (ClPointedSteinerMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (eCl) = Now eCl
    opOL' :
      (n : Nat) ->
      OpPointedSteinerMagmaTerm n ->
      OpPointedSteinerMagmaTerm n ->
      OpPointedSteinerMagmaTerm n
    opOL' _ x1 x2 = opOL x1 x2
    eOL' :
      (n : Nat) ->
      OpPointedSteinerMagmaTerm n
    eOL' _ = eOL
    stageOp :
      (n : Nat) ->
      OpPointedSteinerMagmaTerm n ->
      Staged
        (OpPointedSteinerMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (eOL) = Now eOL
    opOL2' :
      (n : Nat) (A : Set) ->
      OpPointedSteinerMagmaTerm2 n
        A ->
      OpPointedSteinerMagmaTerm2 n
        A ->
      OpPointedSteinerMagmaTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    eOL2' :
      (n : Nat) (A : Set) ->
      OpPointedSteinerMagmaTerm2 n A
    eOL2' _ _ = eOL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpPointedSteinerMagmaTerm2 n
        A ->
      Staged
        (OpPointedSteinerMagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (eOL2) = Now eOL2
    record PointedSteinerMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
        eT : Repr A
  
  module PointedTimesMagma where
    record PointedTimesMagma
      (A : Set) : Set where
      constructor PointedTimesMagmaC
      field
        * : A -> A -> A
        e : A
    record PointedTimesMagmaSig
      (AS : Set) : Set where
      constructor PointedTimesMagmaSigSigC
      field
        *S : AS -> AS -> AS
        eS : AS
    record PointedTimesMagmaProd
      (AP : Set) : Set where
      constructor PointedTimesMagmaProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
    record PointedTimesMagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedTimesMagma A1)
      (Po2 : PointedTimesMagma A2) :
      Set where
      constructor PointedTimesMagmaHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Po1 x1 x2) ==
            * Po2 (hom x1) (hom x2)
        pres-e : hom (e Po1) == e Po2
    record PointedTimesMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedTimesMagma A1)
      (Po2 : PointedTimesMagma A2) :
      Set where
      constructor PointedTimesMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Po1 x1 x2)
            (* Po2 y1 y2)
        interp-e :
          interp (e Po1) (e Po2)
    data PointedTimesMagmaTerm
      : Set where
      *L :
        PointedTimesMagmaTerm ->
        PointedTimesMagmaTerm ->
        PointedTimesMagmaTerm
      eL : PointedTimesMagmaTerm
    data ClPointedTimesMagmaTerm
      (A : Set) : Set where
      sing :
        A -> ClPointedTimesMagmaTerm A
      *Cl :
        ClPointedTimesMagmaTerm A ->
        ClPointedTimesMagmaTerm A ->
        ClPointedTimesMagmaTerm A
      eCl : ClPointedTimesMagmaTerm A
    data OpPointedTimesMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpPointedTimesMagmaTerm n
      *OL :
        OpPointedTimesMagmaTerm n ->
        OpPointedTimesMagmaTerm n ->
        OpPointedTimesMagmaTerm n
      eOL : OpPointedTimesMagmaTerm n
    data OpPointedTimesMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpPointedTimesMagmaTerm2 n A
      sing2 :
        A ->
        OpPointedTimesMagmaTerm2 n A
      *OL2 :
        OpPointedTimesMagmaTerm2 n A ->
        OpPointedTimesMagmaTerm2 n A ->
        OpPointedTimesMagmaTerm2 n A
      eOL2 :
        OpPointedTimesMagmaTerm2 n A
    simplifyB :
      PointedTimesMagmaTerm ->
      PointedTimesMagmaTerm
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (eL) = eL
    simplifyCl :
      (A : Set) ->
      ClPointedTimesMagmaTerm A ->
      ClPointedTimesMagmaTerm A
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpPointedTimesMagmaTerm n ->
      OpPointedTimesMagmaTerm n
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpPointedTimesMagmaTerm2 n A ->
      OpPointedTimesMagmaTerm2 n A
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      PointedTimesMagma A ->
      PointedTimesMagmaTerm -> A
    evalB _ Po (*L x1 x2) =
      * Po (evalB _ Po x1)
        (evalB _ Po x2)
    evalB _ Po (eL) = e Po
    evalCl :
      (A : Set) ->
      PointedTimesMagma A ->
      ClPointedTimesMagmaTerm A -> A
    evalCl _ Po (sing x1) = x1
    evalCl _ Po (*Cl x1 x2) =
      * Po (evalCl _ Po x1)
        (evalCl _ Po x2)
    evalCl _ Po (eCl) = e Po
    evalOp :
      (A : Set) (n : Nat) ->
      PointedTimesMagma A ->
      Vec A n ->
      OpPointedTimesMagmaTerm n -> A
    evalOp _ n Po vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Po vars (*OL x1 x2) =
      * Po (evalOp _ n Po vars x1)
        (evalOp _ n Po vars x2)
    evalOp _ n Po vars (eOL) = e Po
    evalOpE :
      (A : Set) (n : Nat) ->
      PointedTimesMagma A ->
      Vec A n ->
      OpPointedTimesMagmaTerm2 n A ->
      A
    evalOpE _ n Po vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Po vars (sing2 x1) =
      x1
    evalOpE _ n Po vars (*OL2
                         x1
                         x2) =
      * Po (evalOpE _ n Po vars x1)
        (evalOpE _ n Po vars x2)
    evalOpE _ n Po vars (eOL2) =
      e Po
    inductionB :
      (P : PointedTimesMagmaTerm ->
           Set) ->
      ((x1 : PointedTimesMagmaTerm)
       (x2 : PointedTimesMagmaTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      P eL ->
      (x : PointedTimesMagmaTerm) ->
      P x
    inductionB p p*l pel (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p*l pel x1)
        (inductionB p p*l pel x2)
    inductionB p p*l pel (eL) = pel
    inductionCl :
      (A : Set)
      (P : ClPointedTimesMagmaTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClPointedTimesMagmaTerm
          A)
       (x2 : ClPointedTimesMagmaTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      P eCl ->
      (x : ClPointedTimesMagmaTerm
         A) -> P x
    inductionCl _ p psing p*cl pecl (sing
                                     x1) = psing x1
    inductionCl _ p psing p*cl pecl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl pecl
           x1)
        (inductionCl _ p psing p*cl pecl
           x2)
    inductionCl _ p psing p*cl pecl (eCl) =
      pecl
    inductionOp :
      (n : Nat)
      (P : OpPointedTimesMagmaTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpPointedTimesMagmaTerm
          n)
       (x2 : OpPointedTimesMagmaTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      P eOL ->
      (x : OpPointedTimesMagmaTerm
         n) -> P x
    inductionOp _ p pv p*ol peol (v
                                  x1) = pv x1
    inductionOp _ p pv p*ol peol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol peol
           x1)
        (inductionOp _ p pv p*ol peol
           x2)
    inductionOp _ p pv p*ol peol (eOL) =
      peol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpPointedTimesMagmaTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpPointedTimesMagmaTerm2
          n
          A)
       (x2 : OpPointedTimesMagmaTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      P eOL2 ->
      (x : OpPointedTimesMagmaTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 peol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 peol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 peol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           peol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           peol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 peol2 (eOL2) =
      peol2
    *L' :
      PointedTimesMagmaTerm ->
      PointedTimesMagmaTerm ->
      PointedTimesMagmaTerm
    *L' x1 x2 = *L x1 x2
    eL' : PointedTimesMagmaTerm
    eL' = eL
    stageB :
      PointedTimesMagmaTerm ->
      Staged PointedTimesMagmaTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (eL) = Now eL
    *Cl' :
      (A : Set) ->
      ClPointedTimesMagmaTerm A ->
      ClPointedTimesMagmaTerm A ->
      ClPointedTimesMagmaTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    eCl' :
      (A : Set) ->
      ClPointedTimesMagmaTerm A
    eCl' _ = eCl
    stageCl :
      (A : Set) ->
      ClPointedTimesMagmaTerm A ->
      Staged
        (ClPointedTimesMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (eCl) = Now eCl
    *OL' :
      (n : Nat) ->
      OpPointedTimesMagmaTerm n ->
      OpPointedTimesMagmaTerm n ->
      OpPointedTimesMagmaTerm n
    *OL' _ x1 x2 = *OL x1 x2
    eOL' :
      (n : Nat) ->
      OpPointedTimesMagmaTerm n
    eOL' _ = eOL
    stageOp :
      (n : Nat) ->
      OpPointedTimesMagmaTerm n ->
      Staged
        (OpPointedTimesMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (eOL) = Now eOL
    *OL2' :
      (n : Nat) (A : Set) ->
      OpPointedTimesMagmaTerm2 n A ->
      OpPointedTimesMagmaTerm2 n A ->
      OpPointedTimesMagmaTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    eOL2' :
      (n : Nat) (A : Set) ->
      OpPointedTimesMagmaTerm2 n A
    eOL2' _ _ = eOL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpPointedTimesMagmaTerm2 n A ->
      Staged
        (OpPointedTimesMagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (eOL2) = Now eOL2
    record PointedTimesMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        eT : Repr A
  
  module PointedTimesZeroMagma where
    record PointedTimesZeroMagma
      (A : Set) : Set where
      constructor PointedTimesZeroMagmaC
      field
        0 : A
        * : A -> A -> A
    record PointedTimesZeroMagmaSig
      (AS : Set) : Set where
      constructor PointedTimesZeroMagmaSigSigC
      field
        0S : AS
        *S : AS -> AS -> AS
    record PointedTimesZeroMagmaProd
      (AP : Set) : Set where
      constructor PointedTimesZeroMagmaProdC
      field
        0P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record PointedTimesZeroMagmaHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedTimesZeroMagma A1)
      (Po2 : PointedTimesZeroMagma
         A2) : Set where
      constructor PointedTimesZeroMagmaHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Po1) == 0 Po2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Po1 x1 x2) ==
            * Po2 (hom x1) (hom x2)
    record PointedTimesZeroMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedTimesZeroMagma A1)
      (Po2 : PointedTimesZeroMagma
         A2) : Set where
      constructor PointedTimesZeroMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Po1) (0 Po2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Po1 x1 x2)
            (* Po2 y1 y2)
    data PointedTimesZeroMagmaTerm
      : Set where
      0L : PointedTimesZeroMagmaTerm
      *L :
        PointedTimesZeroMagmaTerm ->
        PointedTimesZeroMagmaTerm ->
        PointedTimesZeroMagmaTerm
    data ClPointedTimesZeroMagmaTerm
      (A : Set) : Set where
      sing :
        A ->
        ClPointedTimesZeroMagmaTerm A
      0Cl :
        ClPointedTimesZeroMagmaTerm A
      *Cl :
        ClPointedTimesZeroMagmaTerm A ->
        ClPointedTimesZeroMagmaTerm A ->
        ClPointedTimesZeroMagmaTerm A
    data OpPointedTimesZeroMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpPointedTimesZeroMagmaTerm n
      0OL :
        OpPointedTimesZeroMagmaTerm n
      *OL :
        OpPointedTimesZeroMagmaTerm n ->
        OpPointedTimesZeroMagmaTerm n ->
        OpPointedTimesZeroMagmaTerm n
    data OpPointedTimesZeroMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpPointedTimesZeroMagmaTerm2 n A
      sing2 :
        A ->
        OpPointedTimesZeroMagmaTerm2 n A
      0OL2 :
        OpPointedTimesZeroMagmaTerm2 n A
      *OL2 :
        OpPointedTimesZeroMagmaTerm2 n
          A ->
        OpPointedTimesZeroMagmaTerm2 n
          A ->
        OpPointedTimesZeroMagmaTerm2 n A
    simplifyB :
      PointedTimesZeroMagmaTerm ->
      PointedTimesZeroMagmaTerm
    simplifyB (0L) = 0L
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClPointedTimesZeroMagmaTerm A ->
      ClPointedTimesZeroMagmaTerm A
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpPointedTimesZeroMagmaTerm n ->
      OpPointedTimesZeroMagmaTerm n
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpPointedTimesZeroMagmaTerm2 n
        A ->
      OpPointedTimesZeroMagmaTerm2 n A
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      PointedTimesZeroMagma A ->
      PointedTimesZeroMagmaTerm -> A
    evalB _ Po (0L) = 0 Po
    evalB _ Po (*L x1 x2) =
      * Po (evalB _ Po x1)
        (evalB _ Po x2)
    evalCl :
      (A : Set) ->
      PointedTimesZeroMagma A ->
      ClPointedTimesZeroMagmaTerm A ->
      A
    evalCl _ Po (sing x1) = x1
    evalCl _ Po (0Cl) = 0 Po
    evalCl _ Po (*Cl x1 x2) =
      * Po (evalCl _ Po x1)
        (evalCl _ Po x2)
    evalOp :
      (A : Set) (n : Nat) ->
      PointedTimesZeroMagma A ->
      Vec A n ->
      OpPointedTimesZeroMagmaTerm n ->
      A
    evalOp _ n Po vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Po vars (0OL) = 0 Po
    evalOp _ n Po vars (*OL x1 x2) =
      * Po (evalOp _ n Po vars x1)
        (evalOp _ n Po vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      PointedTimesZeroMagma A ->
      Vec A n ->
      OpPointedTimesZeroMagmaTerm2 n
        A -> A
    evalOpE _ n Po vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Po vars (sing2 x1) =
      x1
    evalOpE _ n Po vars (0OL2) =
      0 Po
    evalOpE _ n Po vars (*OL2
                         x1
                         x2) =
      * Po (evalOpE _ n Po vars x1)
        (evalOpE _ n Po vars x2)
    inductionB :
      (P : PointedTimesZeroMagmaTerm ->
           Set) ->
      P 0L ->
      ((x1 : PointedTimesZeroMagmaTerm)
       (x2 : PointedTimesZeroMagmaTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      (x : PointedTimesZeroMagmaTerm) ->
      P x
    inductionB p p0l p*l (0L) = p0l
    inductionB p p0l p*l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p0l p*l x1)
        (inductionB p p0l p*l x2)
    inductionCl :
      (A : Set)
      (P : ClPointedTimesZeroMagmaTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 0Cl ->
      ((x1 : ClPointedTimesZeroMagmaTerm
          A)
       (x2 : ClPointedTimesZeroMagmaTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      (x : ClPointedTimesZeroMagmaTerm
         A) -> P x
    inductionCl _ p psing p0cl p*cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p0cl p*cl (0Cl) =
      p0cl
    inductionCl _ p psing p0cl p*cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p0cl p*cl
           x1)
        (inductionCl _ p psing p0cl p*cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpPointedTimesZeroMagmaTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 0OL ->
      ((x1 : OpPointedTimesZeroMagmaTerm
          n)
       (x2 : OpPointedTimesZeroMagmaTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      (x : OpPointedTimesZeroMagmaTerm
         n) -> P x
    inductionOp _ p pv p0ol p*ol (v
                                  x1) = pv x1
    inductionOp _ p pv p0ol p*ol (0OL) =
      p0ol
    inductionOp _ p pv p0ol p*ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p0ol p*ol
           x1)
        (inductionOp _ p pv p0ol p*ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpPointedTimesZeroMagmaTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 0OL2 ->
      ((x1 : OpPointedTimesZeroMagmaTerm2
          n
          A)
       (x2 : OpPointedTimesZeroMagmaTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      (x : OpPointedTimesZeroMagmaTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p0ol2 p*ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p*ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p*ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p0ol2 p*ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p*ol2
           x2)
    0L' : PointedTimesZeroMagmaTerm
    0L' = 0L
    *L' :
      PointedTimesZeroMagmaTerm ->
      PointedTimesZeroMagmaTerm ->
      PointedTimesZeroMagmaTerm
    *L' x1 x2 = *L x1 x2
    stageB :
      PointedTimesZeroMagmaTerm ->
      Staged PointedTimesZeroMagmaTerm
    stageB (0L) = Now 0L
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    0Cl' :
      (A : Set) ->
      ClPointedTimesZeroMagmaTerm A
    0Cl' _ = 0Cl
    *Cl' :
      (A : Set) ->
      ClPointedTimesZeroMagmaTerm A ->
      ClPointedTimesZeroMagmaTerm A ->
      ClPointedTimesZeroMagmaTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    stageCl :
      (A : Set) ->
      ClPointedTimesZeroMagmaTerm A ->
      Staged
        (ClPointedTimesZeroMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    0OL' :
      (n : Nat) ->
      OpPointedTimesZeroMagmaTerm n
    0OL' _ = 0OL
    *OL' :
      (n : Nat) ->
      OpPointedTimesZeroMagmaTerm n ->
      OpPointedTimesZeroMagmaTerm n ->
      OpPointedTimesZeroMagmaTerm n
    *OL' _ x1 x2 = *OL x1 x2
    stageOp :
      (n : Nat) ->
      OpPointedTimesZeroMagmaTerm n ->
      Staged
        (OpPointedTimesZeroMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (0OL) = Now 0OL
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    0OL2' :
      (n : Nat) (A : Set) ->
      OpPointedTimesZeroMagmaTerm2 n A
    0OL2' _ _ = 0OL2
    *OL2' :
      (n : Nat) (A : Set) ->
      OpPointedTimesZeroMagmaTerm2 n
        A ->
      OpPointedTimesZeroMagmaTerm2 n
        A ->
      OpPointedTimesZeroMagmaTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpPointedTimesZeroMagmaTerm2 n
        A ->
      Staged
        (OpPointedTimesZeroMagmaTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record PointedTimesZeroMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        0T : Repr A
        *T : Repr A -> Repr A -> Repr A
  
  module PointedUnarySystem where
    record PointedUnarySystem
      (A : Set) : Set where
      constructor PointedUnarySystemC
      field
        prim : A -> A
        e : A
    record PointedUnarySystemSig
      (AS : Set) : Set where
      constructor PointedUnarySystemSigSigC
      field
        primS : AS -> AS
        eS : AS
    record PointedUnarySystemProd
      (AP : Set) : Set where
      constructor PointedUnarySystemProdC
      field
        primP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
    record PointedUnarySystemHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedUnarySystem A1)
      (Po2 : PointedUnarySystem A2) :
      Set where
      constructor PointedUnarySystemHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Po1 x1) ==
            prim Po2 (hom x1)
        pres-e : hom (e Po1) == e Po2
    record PointedUnarySystemRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedUnarySystem A1)
      (Po2 : PointedUnarySystem A2) :
      Set where
      constructor PointedUnarySystemRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Po1 x1)
            (prim Po2 y1)
        interp-e :
          interp (e Po1) (e Po2)
    data PointedUnarySystemTerm
      : Set where
      primL :
        PointedUnarySystemTerm ->
        PointedUnarySystemTerm
      eL : PointedUnarySystemTerm
    data ClPointedUnarySystemTerm
      (A : Set) : Set where
      sing :
        A -> ClPointedUnarySystemTerm A
      primCl :
        ClPointedUnarySystemTerm A ->
        ClPointedUnarySystemTerm A
      eCl : ClPointedUnarySystemTerm A
    data OpPointedUnarySystemTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpPointedUnarySystemTerm n
      primOL :
        OpPointedUnarySystemTerm n ->
        OpPointedUnarySystemTerm n
      eOL : OpPointedUnarySystemTerm n
    data OpPointedUnarySystemTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpPointedUnarySystemTerm2 n A
      sing2 :
        A ->
        OpPointedUnarySystemTerm2 n A
      primOL2 :
        OpPointedUnarySystemTerm2 n A ->
        OpPointedUnarySystemTerm2 n A
      eOL2 :
        OpPointedUnarySystemTerm2 n A
    simplifyB :
      PointedUnarySystemTerm ->
      PointedUnarySystemTerm
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyB (eL) = eL
    simplifyCl :
      (A : Set) ->
      ClPointedUnarySystemTerm A ->
      ClPointedUnarySystemTerm A
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpPointedUnarySystemTerm n ->
      OpPointedUnarySystemTerm n
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpPointedUnarySystemTerm2 n A ->
      OpPointedUnarySystemTerm2 n A
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      PointedUnarySystem A ->
      PointedUnarySystemTerm -> A
    evalB _ Po (primL x1) =
      prim Po (evalB _ Po x1)
    evalB _ Po (eL) = e Po
    evalCl :
      (A : Set) ->
      PointedUnarySystem A ->
      ClPointedUnarySystemTerm A -> A
    evalCl _ Po (sing x1) = x1
    evalCl _ Po (primCl x1) =
      prim Po (evalCl _ Po x1)
    evalCl _ Po (eCl) = e Po
    evalOp :
      (A : Set) (n : Nat) ->
      PointedUnarySystem A ->
      Vec A n ->
      OpPointedUnarySystemTerm n -> A
    evalOp _ n Po vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Po vars (primOL x1) =
      prim Po (evalOp _ n Po vars x1)
    evalOp _ n Po vars (eOL) = e Po
    evalOpE :
      (A : Set) (n : Nat) ->
      PointedUnarySystem A ->
      Vec A n ->
      OpPointedUnarySystemTerm2 n A ->
      A
    evalOpE _ n Po vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Po vars (sing2 x1) =
      x1
    evalOpE _ n Po vars (primOL2
                         x1) =
      prim Po (evalOpE _ n Po vars x1)
    evalOpE _ n Po vars (eOL2) =
      e Po
    inductionB :
      (P : PointedUnarySystemTerm ->
           Set) ->
      ((x1 : PointedUnarySystemTerm) ->
       P x1 -> P (primL x1)) ->
      P eL ->
      (x : PointedUnarySystemTerm) ->
      P x
    inductionB p ppriml pel (primL
                             x1) =
      ppriml _
        (inductionB p ppriml pel x1)
    inductionB p ppriml pel (eL) =
      pel
    inductionCl :
      (A : Set)
      (P : ClPointedUnarySystemTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClPointedUnarySystemTerm
          A) -> P x1 -> P (primCl x1)) ->
      P eCl ->
      (x : ClPointedUnarySystemTerm
         A) -> P x
    inductionCl _ p psing pprimcl pecl (sing
                                        x1) = psing x1
    inductionCl _ p psing pprimcl pecl (primCl
                                        x1) =
      pprimcl _
        (inductionCl _ p psing pprimcl
           pecl
           x1)
    inductionCl _ p psing pprimcl pecl (eCl) =
      pecl
    inductionOp :
      (n : Nat)
      (P : OpPointedUnarySystemTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpPointedUnarySystemTerm
          n) -> P x1 -> P (primOL x1)) ->
      P eOL ->
      (x : OpPointedUnarySystemTerm
         n) -> P x
    inductionOp _ p pv pprimol peol (v
                                     x1) = pv x1
    inductionOp _ p pv pprimol peol (primOL
                                     x1) =
      pprimol _
        (inductionOp _ p pv pprimol peol
           x1)
    inductionOp _ p pv pprimol peol (eOL) =
      peol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpPointedUnarySystemTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpPointedUnarySystemTerm2
          n
          A) -> P x1 -> P (primOL2 x1)) ->
      P eOL2 ->
      (x : OpPointedUnarySystemTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 pprimol2 peol2 (v2
                                                  x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 peol2 (sing2
                                                  x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 peol2 (primOL2
                                                  x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           peol2
           x1)
    inductionOpE _ _ p pv2 psing2 pprimol2 peol2 (eOL2) =
      peol2
    primL' :
      PointedUnarySystemTerm ->
      PointedUnarySystemTerm
    primL' x1 = primL x1
    eL' : PointedUnarySystemTerm
    eL' = eL
    stageB :
      PointedUnarySystemTerm ->
      Staged PointedUnarySystemTerm
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    stageB (eL) = Now eL
    primCl' :
      (A : Set) ->
      ClPointedUnarySystemTerm A ->
      ClPointedUnarySystemTerm A
    primCl' _ x1 = primCl x1
    eCl' :
      (A : Set) ->
      ClPointedUnarySystemTerm A
    eCl' _ = eCl
    stageCl :
      (A : Set) ->
      ClPointedUnarySystemTerm A ->
      Staged
        (ClPointedUnarySystemTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    stageCl _ (eCl) = Now eCl
    primOL' :
      (n : Nat) ->
      OpPointedUnarySystemTerm n ->
      OpPointedUnarySystemTerm n
    primOL' _ x1 = primOL x1
    eOL' :
      (n : Nat) ->
      OpPointedUnarySystemTerm n
    eOL' _ = eOL
    stageOp :
      (n : Nat) ->
      OpPointedUnarySystemTerm n ->
      Staged
        (OpPointedUnarySystemTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    stageOp _ (eOL) = Now eOL
    primOL2' :
      (n : Nat) (A : Set) ->
      OpPointedUnarySystemTerm2 n A ->
      OpPointedUnarySystemTerm2 n A
    primOL2' _ _ x1 = primOL2 x1
    eOL2' :
      (n : Nat) (A : Set) ->
      OpPointedUnarySystemTerm2 n A
    eOL2' _ _ = eOL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpPointedUnarySystemTerm2 n A ->
      Staged
        (OpPointedUnarySystemTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (eOL2) = Now eOL2
    record PointedUnarySystemTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        primT : Repr A -> Repr A
        eT : Repr A
  
  module PointedZero where
    record PointedZero
      (A : Set) : Set where
      constructor PointedZeroC
      field
        0 : A
    record PointedZeroSig
      (AS : Set) : Set where
      constructor PointedZeroSigSigC
      field
        0S : AS
    record PointedZeroProd
      (AP : Set) : Set where
      constructor PointedZeroProdC
      field
        0P : Prod AP AP
    record PointedZeroHom
      (A1 : Set) (A2 : Set)
      (Po1 : PointedZero A1)
      (Po2 : PointedZero A2) :
      Set where
      constructor PointedZeroHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Po1) == 0 Po2
    record PointedZeroRelInterp
      (A1 : Set) (A2 : Set)
      (Po1 : PointedZero A1)
      (Po2 : PointedZero A2) :
      Set where
      constructor PointedZeroRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Po1) (0 Po2)
    data PointedZeroTerm : Set where
      0L : PointedZeroTerm
    data ClPointedZeroTerm
      (A : Set) : Set where
      sing :
        A -> ClPointedZeroTerm A
      0Cl : ClPointedZeroTerm A
    data OpPointedZeroTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpPointedZeroTerm n
      0OL : OpPointedZeroTerm n
    data OpPointedZeroTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpPointedZeroTerm2 n A
      sing2 :
        A -> OpPointedZeroTerm2 n A
      0OL2 : OpPointedZeroTerm2 n A
    simplifyB :
      PointedZeroTerm ->
      PointedZeroTerm
    simplifyB (0L) = 0L
    simplifyCl :
      (A : Set) ->
      ClPointedZeroTerm A ->
      ClPointedZeroTerm A
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpPointedZeroTerm n ->
      OpPointedZeroTerm n
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpPointedZeroTerm2 n A ->
      OpPointedZeroTerm2 n A
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      PointedZero A ->
      PointedZeroTerm -> A
    evalB _ Po (0L) = 0 Po
    evalCl :
      (A : Set) ->
      PointedZero A ->
      ClPointedZeroTerm A -> A
    evalCl _ Po (sing x1) = x1
    evalCl _ Po (0Cl) = 0 Po
    evalOp :
      (A : Set) (n : Nat) ->
      PointedZero A ->
      Vec A n ->
      OpPointedZeroTerm n -> A
    evalOp _ n Po vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Po vars (0OL) = 0 Po
    evalOpE :
      (A : Set) (n : Nat) ->
      PointedZero A ->
      Vec A n ->
      OpPointedZeroTerm2 n A -> A
    evalOpE _ n Po vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Po vars (sing2 x1) =
      x1
    evalOpE _ n Po vars (0OL2) =
      0 Po
    inductionB :
      (P : PointedZeroTerm -> Set) ->
      P 0L ->
      (x : PointedZeroTerm) -> P x
    inductionB p p0l (0L) = p0l
    inductionCl :
      (A : Set)
      (P : ClPointedZeroTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 0Cl ->
      (x : ClPointedZeroTerm A) -> P x
    inductionCl _ p psing p0cl (sing
                                x1) = psing x1
    inductionCl _ p psing p0cl (0Cl) =
      p0cl
    inductionOp :
      (n : Nat)
      (P : OpPointedZeroTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 0OL ->
      (x : OpPointedZeroTerm n) -> P x
    inductionOp _ p pv p0ol (v x1) =
      pv x1
    inductionOp _ p pv p0ol (0OL) =
      p0ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpPointedZeroTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 0OL2 ->
      (x : OpPointedZeroTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p0ol2 (v2
                                         x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 (sing2
                                         x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 (0OL2) =
      p0ol2
    0L' : PointedZeroTerm
    0L' = 0L
    stageB :
      PointedZeroTerm ->
      Staged PointedZeroTerm
    stageB (0L) = Now 0L
    0Cl' :
      (A : Set) -> ClPointedZeroTerm A
    0Cl' _ = 0Cl
    stageCl :
      (A : Set) ->
      ClPointedZeroTerm A ->
      Staged (ClPointedZeroTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (0Cl) = Now 0Cl
    0OL' :
      (n : Nat) -> OpPointedZeroTerm n
    0OL' _ = 0OL
    stageOp :
      (n : Nat) ->
      OpPointedZeroTerm n ->
      Staged (OpPointedZeroTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (0OL) = Now 0OL
    0OL2' :
      (n : Nat) (A : Set) ->
      OpPointedZeroTerm2 n A
    0OL2' _ _ = 0OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpPointedZeroTerm2 n A ->
      Staged (OpPointedZeroTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (0OL2) = Now 0OL2
    record PointedZeroTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        0T : Repr A
  
  module PreSemiring where
    record PreSemiring
      (A : Set) : Set where
      constructor PreSemiringC
      field
        * : A -> A -> A
        + : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record PreSemiringSig
      (AS : Set) : Set where
      constructor PreSemiringSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record PreSemiringProd
      (AP : Set) : Set where
      constructor PreSemiringProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record PreSemiringHom
      (A1 : Set) (A2 : Set)
      (Pr1 : PreSemiring A1)
      (Pr2 : PreSemiring A2) :
      Set where
      constructor PreSemiringHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Pr1 x1 x2) ==
            * Pr2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Pr1 x1 x2) ==
            + Pr2 (hom x1) (hom x2)
    record PreSemiringRelInterp
      (A1 : Set) (A2 : Set)
      (Pr1 : PreSemiring A1)
      (Pr2 : PreSemiring A2) :
      Set where
      constructor PreSemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Pr1 x1 x2)
            (* Pr2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Pr1 x1 x2)
            (+ Pr2 y1 y2)
    data PreSemiringTerm : Set where
      *L :
        PreSemiringTerm ->
        PreSemiringTerm ->
        PreSemiringTerm
      +L :
        PreSemiringTerm ->
        PreSemiringTerm ->
        PreSemiringTerm
    data ClPreSemiringTerm
      (A : Set) : Set where
      sing :
        A -> ClPreSemiringTerm A
      *Cl :
        ClPreSemiringTerm A ->
        ClPreSemiringTerm A ->
        ClPreSemiringTerm A
      +Cl :
        ClPreSemiringTerm A ->
        ClPreSemiringTerm A ->
        ClPreSemiringTerm A
    data OpPreSemiringTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpPreSemiringTerm n
      *OL :
        OpPreSemiringTerm n ->
        OpPreSemiringTerm n ->
        OpPreSemiringTerm n
      +OL :
        OpPreSemiringTerm n ->
        OpPreSemiringTerm n ->
        OpPreSemiringTerm n
    data OpPreSemiringTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpPreSemiringTerm2 n A
      sing2 :
        A -> OpPreSemiringTerm2 n A
      *OL2 :
        OpPreSemiringTerm2 n A ->
        OpPreSemiringTerm2 n A ->
        OpPreSemiringTerm2 n A
      +OL2 :
        OpPreSemiringTerm2 n A ->
        OpPreSemiringTerm2 n A ->
        OpPreSemiringTerm2 n A
    simplifyB :
      PreSemiringTerm ->
      PreSemiringTerm
    simplifyB (+L
               (*L x y)
               (*L x z)) = *L x (+L y z)
    simplifyB (+L
               (*L y x)
               (*L z x)) = *L (+L y z) x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClPreSemiringTerm A ->
      ClPreSemiringTerm A
    simplifyCl _ (+Cl
                  (*Cl x y)
                  (*Cl x z)) = *Cl x (+Cl y z)
    simplifyCl _ (+Cl
                  (*Cl y x)
                  (*Cl z x)) = *Cl (+Cl y z) x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpPreSemiringTerm n ->
      OpPreSemiringTerm n
    simplifyOp _ (+OL
                  (*OL x y)
                  (*OL x z)) = *OL x (+OL y z)
    simplifyOp _ (+OL
                  (*OL y x)
                  (*OL z x)) = *OL (+OL y z) x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpPreSemiringTerm2 n A ->
      OpPreSemiringTerm2 n A
    simplifyOpE _ _ (+OL2
                     (*OL2 x y)
                     (*OL2 x z)) = *OL2 x (+OL2 y z)
    simplifyOpE _ _ (+OL2
                     (*OL2 y x)
                     (*OL2 z x)) = *OL2 (+OL2 y z) x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      PreSemiring A ->
      PreSemiringTerm -> A
    evalB _ Pr (*L x1 x2) =
      * Pr (evalB _ Pr x1)
        (evalB _ Pr x2)
    evalB _ Pr (+L x1 x2) =
      + Pr (evalB _ Pr x1)
        (evalB _ Pr x2)
    evalCl :
      (A : Set) ->
      PreSemiring A ->
      ClPreSemiringTerm A -> A
    evalCl _ Pr (sing x1) = x1
    evalCl _ Pr (*Cl x1 x2) =
      * Pr (evalCl _ Pr x1)
        (evalCl _ Pr x2)
    evalCl _ Pr (+Cl x1 x2) =
      + Pr (evalCl _ Pr x1)
        (evalCl _ Pr x2)
    evalOp :
      (A : Set) (n : Nat) ->
      PreSemiring A ->
      Vec A n ->
      OpPreSemiringTerm n -> A
    evalOp _ n Pr vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Pr vars (*OL x1 x2) =
      * Pr (evalOp _ n Pr vars x1)
        (evalOp _ n Pr vars x2)
    evalOp _ n Pr vars (+OL x1 x2) =
      + Pr (evalOp _ n Pr vars x1)
        (evalOp _ n Pr vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      PreSemiring A ->
      Vec A n ->
      OpPreSemiringTerm2 n A -> A
    evalOpE _ n Pr vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Pr vars (sing2 x1) =
      x1
    evalOpE _ n Pr vars (*OL2
                         x1
                         x2) =
      * Pr (evalOpE _ n Pr vars x1)
        (evalOpE _ n Pr vars x2)
    evalOpE _ n Pr vars (+OL2
                         x1
                         x2) =
      + Pr (evalOpE _ n Pr vars x1)
        (evalOpE _ n Pr vars x2)
    inductionB :
      (P : PreSemiringTerm -> Set) ->
      ((x1 : PreSemiringTerm)
       (x2 : PreSemiringTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : PreSemiringTerm)
       (x2 : PreSemiringTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : PreSemiringTerm) -> P x
    inductionB p p*l p+l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionB p p*l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClPreSemiringTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClPreSemiringTerm A)
       (x2 : ClPreSemiringTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClPreSemiringTerm A)
       (x2 : ClPreSemiringTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClPreSemiringTerm A) -> P x
    inductionCl _ p psing p*cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p*cl p+cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionCl _ p psing p*cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpPreSemiringTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpPreSemiringTerm n)
       (x2 : OpPreSemiringTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpPreSemiringTerm n)
       (x2 : OpPreSemiringTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpPreSemiringTerm n) -> P x
    inductionOp _ p pv p*ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p*ol p+ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOp _ p pv p*ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpPreSemiringTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpPreSemiringTerm2 n A)
       (x2 : OpPreSemiringTerm2 n A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpPreSemiringTerm2 n A)
       (x2 : OpPreSemiringTerm2 n A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpPreSemiringTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    *L' :
      PreSemiringTerm ->
      PreSemiringTerm ->
      PreSemiringTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      PreSemiringTerm ->
      PreSemiringTerm ->
      PreSemiringTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      PreSemiringTerm ->
      Staged PreSemiringTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClPreSemiringTerm A ->
      ClPreSemiringTerm A ->
      ClPreSemiringTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClPreSemiringTerm A ->
      ClPreSemiringTerm A ->
      ClPreSemiringTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClPreSemiringTerm A ->
      Staged (ClPreSemiringTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpPreSemiringTerm n ->
      OpPreSemiringTerm n ->
      OpPreSemiringTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpPreSemiringTerm n ->
      OpPreSemiringTerm n ->
      OpPreSemiringTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpPreSemiringTerm n ->
      Staged (OpPreSemiringTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpPreSemiringTerm2 n A ->
      OpPreSemiringTerm2 n A ->
      OpPreSemiringTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpPreSemiringTerm2 n A ->
      OpPreSemiringTerm2 n A ->
      OpPreSemiringTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpPreSemiringTerm2 n A ->
      Staged (OpPreSemiringTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record PreSemiringTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module PrimAdditiveGroup where
    record PrimAdditiveGroup
      (A : Set) : Set where
      constructor PrimAdditiveGroupC
      field
        0_ : A
        *_ : A -> A -> A
        lunit_0_ :
          (x : A) -> *_ 0_ x == x
        runit_0_ :
          (x : A) -> *_ x 0_ == x
        associative_*_ :
          (x : A) (y : A) (z : A) ->
          *_ (*_ x y) z == *_ x (*_ y z)
        inv_ : A -> A
        leftInverse_inv_op_0_ :
          (x : A) -> *_ x (inv_ x) == 0_
        rightInverse_inv_op_0_ :
          (x : A) -> *_ (inv_ x) x == 0_
        commutative_*_ :
          (x : A) (y : A) ->
          *_ x y == *_ y x
    record PrimAdditiveGroupSig
      (AS : Set) : Set where
      constructor PrimAdditiveGroupSigSigC
      field
        0_S : AS
        *_S : AS -> AS -> AS
        inv_S : AS -> AS
    record PrimAdditiveGroupProd
      (AP : Set) : Set where
      constructor PrimAdditiveGroupProdC
      field
        0_P : Prod AP AP
        *_P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        inv_P : Prod AP AP -> Prod AP AP
        lunit_0_P :
          (xP : Prod AP AP) ->
          *_P 0_P xP == xP
        runit_0_P :
          (xP : Prod AP AP) ->
          *_P xP 0_P == xP
        associative_*_P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *_P (*_P xP yP) zP ==
            *_P xP (*_P yP zP)
        leftInverse_inv_op_0_P :
          (xP : Prod AP AP) ->
          *_P xP (inv_P xP) == 0_P
        rightInverse_inv_op_0_P :
          (xP : Prod AP AP) ->
          *_P (inv_P xP) xP == 0_P
        commutative_*_P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          *_P xP yP == *_P yP xP
    record PrimAdditiveGroupHom
      (A1 : Set) (A2 : Set)
      (Pr1 : PrimAdditiveGroup A1)
      (Pr2 : PrimAdditiveGroup A2) :
      Set where
      constructor PrimAdditiveGroupHomC
      field
        hom : A1 -> A2
        pres-0_ : hom (0_ Pr1) == 0_ Pr2
        pres-*_ :
          (x1 : A1) (x2 : A1) ->
          hom (*_ Pr1 x1 x2) ==
            *_ Pr2 (hom x1) (hom x2)
        pres-inv_ :
          (x1 : A1) ->
          hom (inv_ Pr1 x1) ==
            inv_ Pr2 (hom x1)
    record PrimAdditiveGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Pr1 : PrimAdditiveGroup A1)
      (Pr2 : PrimAdditiveGroup A2) :
      Set where
      constructor PrimAdditiveGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0_ :
          interp (0_ Pr1) (0_ Pr2)
        interp-*_ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (*_ Pr1 x1 x2)
            (*_ Pr2 y1 y2)
        interp-inv_ :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv_ Pr1 x1)
            (inv_ Pr2 y1)
    data PrimAdditiveGroupTerm
      : Set where
      0_L : PrimAdditiveGroupTerm
      *_L :
        PrimAdditiveGroupTerm ->
        PrimAdditiveGroupTerm ->
        PrimAdditiveGroupTerm
      inv_L :
        PrimAdditiveGroupTerm ->
        PrimAdditiveGroupTerm
    data ClPrimAdditiveGroupTerm
      (A : Set) : Set where
      sing :
        A -> ClPrimAdditiveGroupTerm A
      0_Cl : ClPrimAdditiveGroupTerm A
      *_Cl :
        ClPrimAdditiveGroupTerm A ->
        ClPrimAdditiveGroupTerm A ->
        ClPrimAdditiveGroupTerm A
      inv_Cl :
        ClPrimAdditiveGroupTerm A ->
        ClPrimAdditiveGroupTerm A
    data OpPrimAdditiveGroupTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpPrimAdditiveGroupTerm n
      0_OL : OpPrimAdditiveGroupTerm n
      *_OL :
        OpPrimAdditiveGroupTerm n ->
        OpPrimAdditiveGroupTerm n ->
        OpPrimAdditiveGroupTerm n
      inv_OL :
        OpPrimAdditiveGroupTerm n ->
        OpPrimAdditiveGroupTerm n
    data OpPrimAdditiveGroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpPrimAdditiveGroupTerm2 n A
      sing2 :
        A ->
        OpPrimAdditiveGroupTerm2 n A
      0_OL2 :
        OpPrimAdditiveGroupTerm2 n A
      *_OL2 :
        OpPrimAdditiveGroupTerm2 n A ->
        OpPrimAdditiveGroupTerm2 n A ->
        OpPrimAdditiveGroupTerm2 n A
      inv_OL2 :
        OpPrimAdditiveGroupTerm2 n A ->
        OpPrimAdditiveGroupTerm2 n A
    simplifyB :
      PrimAdditiveGroupTerm ->
      PrimAdditiveGroupTerm
    simplifyB (*_L (0_L) x) = x
    simplifyB (*_L x (0_L)) = x
    simplifyB (*_L x (inv_L x)) =
      0_L
    simplifyB (*_L (inv_L x) x) =
      0_L
    simplifyB (0_L) = 0_L
    simplifyB (*_L x1 x2) =
      *_L (simplifyB x1)
        (simplifyB x2)
    simplifyB (inv_L x1) =
      inv_L (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClPrimAdditiveGroupTerm A ->
      ClPrimAdditiveGroupTerm A
    simplifyCl _ (*_Cl (0_Cl) x) = x
    simplifyCl _ (*_Cl x (0_Cl)) = x
    simplifyCl _ (*_Cl
                  x
                  (inv_Cl x)) = 0_Cl
    simplifyCl _ (*_Cl
                  (inv_Cl x)
                  x) = 0_Cl
    simplifyCl _ (0_Cl) = 0_Cl
    simplifyCl _ (*_Cl x1 x2) =
      *_Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (inv_Cl x1) =
      inv_Cl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpPrimAdditiveGroupTerm n ->
      OpPrimAdditiveGroupTerm n
    simplifyOp _ (*_OL (0_OL) x) = x
    simplifyOp _ (*_OL x (0_OL)) = x
    simplifyOp _ (*_OL
                  x
                  (inv_OL x)) = 0_OL
    simplifyOp _ (*_OL
                  (inv_OL x)
                  x) = 0_OL
    simplifyOp _ (0_OL) = 0_OL
    simplifyOp _ (*_OL x1 x2) =
      *_OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (inv_OL x1) =
      inv_OL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpPrimAdditiveGroupTerm2 n A ->
      OpPrimAdditiveGroupTerm2 n A
    simplifyOpE _ _ (*_OL2
                     (0_OL2)
                     x) = x
    simplifyOpE _ _ (*_OL2
                     x
                     (0_OL2)) = x
    simplifyOpE _ _ (*_OL2
                     x
                     (inv_OL2 x)) = 0_OL2
    simplifyOpE _ _ (*_OL2
                     (inv_OL2 x)
                     x) = 0_OL2
    simplifyOpE _ _ (0_OL2) = 0_OL2
    simplifyOpE _ _ (*_OL2 x1 x2) =
      *_OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (inv_OL2 x1) =
      inv_OL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      PrimAdditiveGroup A ->
      PrimAdditiveGroupTerm -> A
    evalB _ Pr (0_L) = 0_ Pr
    evalB _ Pr (*_L x1 x2) =
      *_ Pr (evalB _ Pr x1)
        (evalB _ Pr x2)
    evalB _ Pr (inv_L x1) =
      inv_ Pr (evalB _ Pr x1)
    evalCl :
      (A : Set) ->
      PrimAdditiveGroup A ->
      ClPrimAdditiveGroupTerm A -> A
    evalCl _ Pr (sing x1) = x1
    evalCl _ Pr (0_Cl) = 0_ Pr
    evalCl _ Pr (*_Cl x1 x2) =
      *_ Pr (evalCl _ Pr x1)
        (evalCl _ Pr x2)
    evalCl _ Pr (inv_Cl x1) =
      inv_ Pr (evalCl _ Pr x1)
    evalOp :
      (A : Set) (n : Nat) ->
      PrimAdditiveGroup A ->
      Vec A n ->
      OpPrimAdditiveGroupTerm n -> A
    evalOp _ n Pr vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Pr vars (0_OL) =
      0_ Pr
    evalOp _ n Pr vars (*_OL
                        x1
                        x2) =
      *_ Pr (evalOp _ n Pr vars x1)
        (evalOp _ n Pr vars x2)
    evalOp _ n Pr vars (inv_OL x1) =
      inv_ Pr (evalOp _ n Pr vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      PrimAdditiveGroup A ->
      Vec A n ->
      OpPrimAdditiveGroupTerm2 n A ->
      A
    evalOpE _ n Pr vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Pr vars (sing2 x1) =
      x1
    evalOpE _ n Pr vars (0_OL2) =
      0_ Pr
    evalOpE _ n Pr vars (*_OL2
                         x1
                         x2) =
      *_ Pr (evalOpE _ n Pr vars x1)
        (evalOpE _ n Pr vars x2)
    evalOpE _ n Pr vars (inv_OL2
                         x1) =
      inv_ Pr (evalOpE _ n Pr vars x1)
    inductionB :
      (P : PrimAdditiveGroupTerm ->
           Set) ->
      P 0_L ->
      ((x1 : PrimAdditiveGroupTerm)
       (x2 : PrimAdditiveGroupTerm) ->
       P x1 ->
       P x2 -> P (*_L x1 x2)) ->
      ((x1 : PrimAdditiveGroupTerm) ->
       P x1 -> P (inv_L x1)) ->
      (x : PrimAdditiveGroupTerm) ->
      P x
    inductionB p p0_l p*_l pinv_l (0_L) =
      p0_l
    inductionB p p0_l p*_l pinv_l (*_L
                                   x1
                                   x2) =
      p*_l _ _
        (inductionB p p0_l p*_l pinv_l
           x1)
        (inductionB p p0_l p*_l pinv_l
           x2)
    inductionB p p0_l p*_l pinv_l (inv_L
                                   x1) =
      pinv_l _
        (inductionB p p0_l p*_l pinv_l
           x1)
    inductionCl :
      (A : Set)
      (P : ClPrimAdditiveGroupTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 0_Cl ->
      ((x1 : ClPrimAdditiveGroupTerm
          A)
       (x2 : ClPrimAdditiveGroupTerm
          A) ->
       P x1 ->
       P x2 -> P (*_Cl x1 x2)) ->
      ((x1 : ClPrimAdditiveGroupTerm
          A) -> P x1 -> P (inv_Cl x1)) ->
      (x : ClPrimAdditiveGroupTerm
         A) -> P x
    inductionCl _ p psing p0_cl p*_cl pinv_cl (sing
                                               x1) = psing x1
    inductionCl _ p psing p0_cl p*_cl pinv_cl (0_Cl) =
      p0_cl
    inductionCl _ p psing p0_cl p*_cl pinv_cl (*_Cl
                                               x1
                                               x2) =
      p*_cl _ _
        (inductionCl _ p psing p0_cl
           p*_cl
           pinv_cl
           x1)
        (inductionCl _ p psing p0_cl
           p*_cl
           pinv_cl
           x2)
    inductionCl _ p psing p0_cl p*_cl pinv_cl (inv_Cl
                                               x1) =
      pinv_cl _
        (inductionCl _ p psing p0_cl
           p*_cl
           pinv_cl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpPrimAdditiveGroupTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 0_OL ->
      ((x1 : OpPrimAdditiveGroupTerm
          n)
       (x2 : OpPrimAdditiveGroupTerm
          n) ->
       P x1 ->
       P x2 -> P (*_OL x1 x2)) ->
      ((x1 : OpPrimAdditiveGroupTerm
          n) -> P x1 -> P (inv_OL x1)) ->
      (x : OpPrimAdditiveGroupTerm
         n) -> P x
    inductionOp _ p pv p0_ol p*_ol pinv_ol (v
                                            x1) = pv x1
    inductionOp _ p pv p0_ol p*_ol pinv_ol (0_OL) =
      p0_ol
    inductionOp _ p pv p0_ol p*_ol pinv_ol (*_OL
                                            x1
                                            x2) =
      p*_ol _ _
        (inductionOp _ p pv p0_ol p*_ol
           pinv_ol
           x1)
        (inductionOp _ p pv p0_ol p*_ol
           pinv_ol
           x2)
    inductionOp _ p pv p0_ol p*_ol pinv_ol (inv_OL
                                            x1) =
      pinv_ol _
        (inductionOp _ p pv p0_ol p*_ol
           pinv_ol
           x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpPrimAdditiveGroupTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 0_OL2 ->
      ((x1 : OpPrimAdditiveGroupTerm2
          n
          A)
       (x2 : OpPrimAdditiveGroupTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*_OL2 x1 x2)) ->
      ((x1 : OpPrimAdditiveGroupTerm2
          n
          A) -> P x1 -> P (inv_OL2 x1)) ->
      (x : OpPrimAdditiveGroupTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p0_ol2 p*_ol2 pinv_ol2 (v2
                                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p0_ol2 p*_ol2 pinv_ol2 (sing2
                                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p0_ol2 p*_ol2 pinv_ol2 (0_OL2) =
      p0_ol2
    inductionOpE _ _ p pv2 psing2 p0_ol2 p*_ol2 pinv_ol2 (*_OL2
                                                          x1
                                                          x2) =
      p*_ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0_ol2
           p*_ol2
           pinv_ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0_ol2
           p*_ol2
           pinv_ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p0_ol2 p*_ol2 pinv_ol2 (inv_OL2
                                                          x1) =
      pinv_ol2 _
        (inductionOpE _ _ p pv2 psing2
           p0_ol2
           p*_ol2
           pinv_ol2
           x1)
    0_L' : PrimAdditiveGroupTerm
    0_L' = 0_L
    *_L' :
      PrimAdditiveGroupTerm ->
      PrimAdditiveGroupTerm ->
      PrimAdditiveGroupTerm
    *_L' x1 x2 = *_L x1 x2
    inv_L' :
      PrimAdditiveGroupTerm ->
      PrimAdditiveGroupTerm
    inv_L' x1 = inv_L x1
    stageB :
      PrimAdditiveGroupTerm ->
      Staged PrimAdditiveGroupTerm
    stageB (0_L) = Now 0_L
    stageB (*_L x1 x2) =
      stage2 _ _ _ *_L'
        (codeLift2 _ _ _ *_L')
        (stageB x1)
        (stageB x2)
    stageB (inv_L x1) =
      stage1 _ _ inv_L'
        (codeLift1 _ _ inv_L')
        (stageB x1)
    0_Cl' :
      (A : Set) ->
      ClPrimAdditiveGroupTerm A
    0_Cl' _ = 0_Cl
    *_Cl' :
      (A : Set) ->
      ClPrimAdditiveGroupTerm A ->
      ClPrimAdditiveGroupTerm A ->
      ClPrimAdditiveGroupTerm A
    *_Cl' _ x1 x2 = *_Cl x1 x2
    inv_Cl' :
      (A : Set) ->
      ClPrimAdditiveGroupTerm A ->
      ClPrimAdditiveGroupTerm A
    inv_Cl' _ x1 = inv_Cl x1
    stageCl :
      (A : Set) ->
      ClPrimAdditiveGroupTerm A ->
      Staged
        (ClPrimAdditiveGroupTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (0_Cl) = Now 0_Cl
    stageCl _ (*_Cl x1 x2) =
      stage2 _ _ _ (*_Cl' _)
        (codeLift2 _ _ _ (*_Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (inv_Cl x1) =
      stage1 _ _ (inv_Cl' _)
        (codeLift1 _ _ (inv_Cl' _))
        (stageCl _ x1)
    0_OL' :
      (n : Nat) ->
      OpPrimAdditiveGroupTerm n
    0_OL' _ = 0_OL
    *_OL' :
      (n : Nat) ->
      OpPrimAdditiveGroupTerm n ->
      OpPrimAdditiveGroupTerm n ->
      OpPrimAdditiveGroupTerm n
    *_OL' _ x1 x2 = *_OL x1 x2
    inv_OL' :
      (n : Nat) ->
      OpPrimAdditiveGroupTerm n ->
      OpPrimAdditiveGroupTerm n
    inv_OL' _ x1 = inv_OL x1
    stageOp :
      (n : Nat) ->
      OpPrimAdditiveGroupTerm n ->
      Staged
        (OpPrimAdditiveGroupTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (0_OL) = Now 0_OL
    stageOp _ (*_OL x1 x2) =
      stage2 _ _ _ (*_OL' _)
        (codeLift2 _ _ _ (*_OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (inv_OL x1) =
      stage1 _ _ (inv_OL' _)
        (codeLift1 _ _ (inv_OL' _))
        (stageOp _ x1)
    0_OL2' :
      (n : Nat) (A : Set) ->
      OpPrimAdditiveGroupTerm2 n A
    0_OL2' _ _ = 0_OL2
    *_OL2' :
      (n : Nat) (A : Set) ->
      OpPrimAdditiveGroupTerm2 n A ->
      OpPrimAdditiveGroupTerm2 n A ->
      OpPrimAdditiveGroupTerm2 n A
    *_OL2' _ _ x1 x2 = *_OL2 x1 x2
    inv_OL2' :
      (n : Nat) (A : Set) ->
      OpPrimAdditiveGroupTerm2 n A ->
      OpPrimAdditiveGroupTerm2 n A
    inv_OL2' _ _ x1 = inv_OL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpPrimAdditiveGroupTerm2 n A ->
      Staged
        (OpPrimAdditiveGroupTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (0_OL2) = Now 0_OL2
    stageOpE _ _ (*_OL2 x1 x2) =
      stage2 _ _ _ (*_OL2' _ _)
        (codeLift2 _ _ _ (*_OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (inv_OL2 x1) =
      stage1 _ _ (inv_OL2' _ _)
        (codeLift1 _ _ (inv_OL2' _ _))
        (stageOpE _ _ x1)
    record PrimAdditiveGroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        0_T : Repr A
        *_T : Repr A -> Repr A -> Repr A
        inv_T : Repr A -> Repr A
  
  module PrimRingoidSig where
    record PrimRingoidSig
      (A : Set) : Set where
      constructor PrimRingoidSigC
      field
        * : A -> A -> A
        + : A -> A -> A
        prim : A -> A
    record PrimRingoidSigSig
      (AS : Set) : Set where
      constructor PrimRingoidSigSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        primS : AS -> AS
    record PrimRingoidSigProd
      (AP : Set) : Set where
      constructor PrimRingoidSigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
    record PrimRingoidSigHom
      (A1 : Set) (A2 : Set)
      (Pr1 : PrimRingoidSig A1)
      (Pr2 : PrimRingoidSig A2) :
      Set where
      constructor PrimRingoidSigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Pr1 x1 x2) ==
            * Pr2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Pr1 x1 x2) ==
            + Pr2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Pr1 x1) ==
            prim Pr2 (hom x1)
    record PrimRingoidSigRelInterp
      (A1 : Set) (A2 : Set)
      (Pr1 : PrimRingoidSig A1)
      (Pr2 : PrimRingoidSig A2) :
      Set where
      constructor PrimRingoidSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Pr1 x1 x2)
            (* Pr2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Pr1 x1 x2)
            (+ Pr2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Pr1 x1)
            (prim Pr2 y1)
    data PrimRingoidSigTerm
      : Set where
      *L :
        PrimRingoidSigTerm ->
        PrimRingoidSigTerm ->
        PrimRingoidSigTerm
      +L :
        PrimRingoidSigTerm ->
        PrimRingoidSigTerm ->
        PrimRingoidSigTerm
      primL :
        PrimRingoidSigTerm ->
        PrimRingoidSigTerm
    data ClPrimRingoidSigTerm
      (A : Set) : Set where
      sing :
        A -> ClPrimRingoidSigTerm A
      *Cl :
        ClPrimRingoidSigTerm A ->
        ClPrimRingoidSigTerm A ->
        ClPrimRingoidSigTerm A
      +Cl :
        ClPrimRingoidSigTerm A ->
        ClPrimRingoidSigTerm A ->
        ClPrimRingoidSigTerm A
      primCl :
        ClPrimRingoidSigTerm A ->
        ClPrimRingoidSigTerm A
    data OpPrimRingoidSigTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpPrimRingoidSigTerm n
      *OL :
        OpPrimRingoidSigTerm n ->
        OpPrimRingoidSigTerm n ->
        OpPrimRingoidSigTerm n
      +OL :
        OpPrimRingoidSigTerm n ->
        OpPrimRingoidSigTerm n ->
        OpPrimRingoidSigTerm n
      primOL :
        OpPrimRingoidSigTerm n ->
        OpPrimRingoidSigTerm n
    data OpPrimRingoidSigTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpPrimRingoidSigTerm2 n A
      sing2 :
        A -> OpPrimRingoidSigTerm2 n A
      *OL2 :
        OpPrimRingoidSigTerm2 n A ->
        OpPrimRingoidSigTerm2 n A ->
        OpPrimRingoidSigTerm2 n A
      +OL2 :
        OpPrimRingoidSigTerm2 n A ->
        OpPrimRingoidSigTerm2 n A ->
        OpPrimRingoidSigTerm2 n A
      primOL2 :
        OpPrimRingoidSigTerm2 n A ->
        OpPrimRingoidSigTerm2 n A
    simplifyB :
      PrimRingoidSigTerm ->
      PrimRingoidSigTerm
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClPrimRingoidSigTerm A ->
      ClPrimRingoidSigTerm A
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpPrimRingoidSigTerm n ->
      OpPrimRingoidSigTerm n
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpPrimRingoidSigTerm2 n A ->
      OpPrimRingoidSigTerm2 n A
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      PrimRingoidSig A ->
      PrimRingoidSigTerm -> A
    evalB _ Pr (*L x1 x2) =
      * Pr (evalB _ Pr x1)
        (evalB _ Pr x2)
    evalB _ Pr (+L x1 x2) =
      + Pr (evalB _ Pr x1)
        (evalB _ Pr x2)
    evalB _ Pr (primL x1) =
      prim Pr (evalB _ Pr x1)
    evalCl :
      (A : Set) ->
      PrimRingoidSig A ->
      ClPrimRingoidSigTerm A -> A
    evalCl _ Pr (sing x1) = x1
    evalCl _ Pr (*Cl x1 x2) =
      * Pr (evalCl _ Pr x1)
        (evalCl _ Pr x2)
    evalCl _ Pr (+Cl x1 x2) =
      + Pr (evalCl _ Pr x1)
        (evalCl _ Pr x2)
    evalCl _ Pr (primCl x1) =
      prim Pr (evalCl _ Pr x1)
    evalOp :
      (A : Set) (n : Nat) ->
      PrimRingoidSig A ->
      Vec A n ->
      OpPrimRingoidSigTerm n -> A
    evalOp _ n Pr vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Pr vars (*OL x1 x2) =
      * Pr (evalOp _ n Pr vars x1)
        (evalOp _ n Pr vars x2)
    evalOp _ n Pr vars (+OL x1 x2) =
      + Pr (evalOp _ n Pr vars x1)
        (evalOp _ n Pr vars x2)
    evalOp _ n Pr vars (primOL x1) =
      prim Pr (evalOp _ n Pr vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      PrimRingoidSig A ->
      Vec A n ->
      OpPrimRingoidSigTerm2 n A -> A
    evalOpE _ n Pr vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Pr vars (sing2 x1) =
      x1
    evalOpE _ n Pr vars (*OL2
                         x1
                         x2) =
      * Pr (evalOpE _ n Pr vars x1)
        (evalOpE _ n Pr vars x2)
    evalOpE _ n Pr vars (+OL2
                         x1
                         x2) =
      + Pr (evalOpE _ n Pr vars x1)
        (evalOpE _ n Pr vars x2)
    evalOpE _ n Pr vars (primOL2
                         x1) =
      prim Pr (evalOpE _ n Pr vars x1)
    inductionB :
      (P : PrimRingoidSigTerm ->
           Set) ->
      ((x1 : PrimRingoidSigTerm)
       (x2 : PrimRingoidSigTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : PrimRingoidSigTerm)
       (x2 : PrimRingoidSigTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      ((x1 : PrimRingoidSigTerm) ->
       P x1 -> P (primL x1)) ->
      (x : PrimRingoidSigTerm) -> P x
    inductionB p p*l p+l ppriml (*L
                                 x1
                                 x2) =
      p*l _ _
        (inductionB p p*l p+l ppriml x1)
        (inductionB p p*l p+l ppriml x2)
    inductionB p p*l p+l ppriml (+L
                                 x1
                                 x2) =
      p+l _ _
        (inductionB p p*l p+l ppriml x1)
        (inductionB p p*l p+l ppriml x2)
    inductionB p p*l p+l ppriml (primL
                                 x1) =
      ppriml _
        (inductionB p p*l p+l ppriml x1)
    inductionCl :
      (A : Set)
      (P : ClPrimRingoidSigTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClPrimRingoidSigTerm A)
       (x2 : ClPrimRingoidSigTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClPrimRingoidSigTerm A)
       (x2 : ClPrimRingoidSigTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      ((x1 : ClPrimRingoidSigTerm
          A) -> P x1 -> P (primCl x1)) ->
      (x : ClPrimRingoidSigTerm A) ->
      P x
    inductionCl _ p psing p*cl p+cl pprimcl (sing
                                             x1) = psing x1
    inductionCl _ p psing p*cl p+cl pprimcl (*Cl
                                             x1
                                             x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x1)
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x2)
    inductionCl _ p psing p*cl p+cl pprimcl (+Cl
                                             x1
                                             x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x1)
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x2)
    inductionCl _ p psing p*cl p+cl pprimcl (primCl
                                             x1) =
      pprimcl _
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpPrimRingoidSigTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpPrimRingoidSigTerm n)
       (x2 : OpPrimRingoidSigTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpPrimRingoidSigTerm n)
       (x2 : OpPrimRingoidSigTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      ((x1 : OpPrimRingoidSigTerm
          n) -> P x1 -> P (primOL x1)) ->
      (x : OpPrimRingoidSigTerm n) ->
      P x
    inductionOp _ p pv p*ol p+ol pprimol (v
                                          x1) = pv x1
    inductionOp _ p pv p*ol p+ol pprimol (*OL
                                          x1
                                          x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x1)
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x2)
    inductionOp _ p pv p*ol p+ol pprimol (+OL
                                          x1
                                          x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x1)
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x2)
    inductionOp _ p pv p*ol p+ol pprimol (primOL
                                          x1) =
      pprimol _
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpPrimRingoidSigTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpPrimRingoidSigTerm2 n
          A)
       (x2 : OpPrimRingoidSigTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpPrimRingoidSigTerm2 n
          A)
       (x2 : OpPrimRingoidSigTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      ((x1 : OpPrimRingoidSigTerm2 n
          A) -> P x1 -> P (primOL2 x1)) ->
      (x : OpPrimRingoidSigTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (v2
                                                        x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (sing2
                                                        x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (*OL2
                                                        x1
                                                        x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (+OL2
                                                        x1
                                                        x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (primOL2
                                                        x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x1)
    *L' :
      PrimRingoidSigTerm ->
      PrimRingoidSigTerm ->
      PrimRingoidSigTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      PrimRingoidSigTerm ->
      PrimRingoidSigTerm ->
      PrimRingoidSigTerm
    +L' x1 x2 = +L x1 x2
    primL' :
      PrimRingoidSigTerm ->
      PrimRingoidSigTerm
    primL' x1 = primL x1
    stageB :
      PrimRingoidSigTerm ->
      Staged PrimRingoidSigTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    *Cl' :
      (A : Set) ->
      ClPrimRingoidSigTerm A ->
      ClPrimRingoidSigTerm A ->
      ClPrimRingoidSigTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClPrimRingoidSigTerm A ->
      ClPrimRingoidSigTerm A ->
      ClPrimRingoidSigTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    primCl' :
      (A : Set) ->
      ClPrimRingoidSigTerm A ->
      ClPrimRingoidSigTerm A
    primCl' _ x1 = primCl x1
    stageCl :
      (A : Set) ->
      ClPrimRingoidSigTerm A ->
      Staged (ClPrimRingoidSigTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    *OL' :
      (n : Nat) ->
      OpPrimRingoidSigTerm n ->
      OpPrimRingoidSigTerm n ->
      OpPrimRingoidSigTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpPrimRingoidSigTerm n ->
      OpPrimRingoidSigTerm n ->
      OpPrimRingoidSigTerm n
    +OL' _ x1 x2 = +OL x1 x2
    primOL' :
      (n : Nat) ->
      OpPrimRingoidSigTerm n ->
      OpPrimRingoidSigTerm n
    primOL' _ x1 = primOL x1
    stageOp :
      (n : Nat) ->
      OpPrimRingoidSigTerm n ->
      Staged (OpPrimRingoidSigTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpPrimRingoidSigTerm2 n A ->
      OpPrimRingoidSigTerm2 n A ->
      OpPrimRingoidSigTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpPrimRingoidSigTerm2 n A ->
      OpPrimRingoidSigTerm2 n A ->
      OpPrimRingoidSigTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    primOL2' :
      (n : Nat) (A : Set) ->
      OpPrimRingoidSigTerm2 n A ->
      OpPrimRingoidSigTerm2 n A
    primOL2' _ _ x1 = primOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpPrimRingoidSigTerm2 n A ->
      Staged
        (OpPrimRingoidSigTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    record PrimRingoidSigTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
        primT : Repr A -> Repr A
  
  module PseudoInverse where
    record PseudoInverse
      (A : Set) : Set where
      constructor PseudoInverseC
      field
        inv : A -> A
        op : A -> A -> A
        quasiInverse_inv_op_e :
          (x : A) ->
          op (op x (inv x)) x == x
    record PseudoInverseSig
      (AS : Set) : Set where
      constructor PseudoInverseSigSigC
      field
        invS : AS -> AS
        opS : AS -> AS -> AS
    record PseudoInverseProd
      (AP : Set) : Set where
      constructor PseudoInverseProdC
      field
        invP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        quasiInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (opP xP (invP xP)) xP == xP
    record PseudoInverseHom
      (A1 : Set) (A2 : Set)
      (Ps1 : PseudoInverse A1)
      (Ps2 : PseudoInverse A2) :
      Set where
      constructor PseudoInverseHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv Ps1 x1) ==
            inv Ps2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ps1 x1 x2) ==
            op Ps2 (hom x1) (hom x2)
    record PseudoInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Ps1 : PseudoInverse A1)
      (Ps2 : PseudoInverse A2) :
      Set where
      constructor PseudoInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Ps1 x1) (inv Ps2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ps1 x1 x2)
            (op Ps2 y1 y2)
    data PseudoInverseTerm
      : Set where
      invL :
        PseudoInverseTerm ->
        PseudoInverseTerm
      opL :
        PseudoInverseTerm ->
        PseudoInverseTerm ->
        PseudoInverseTerm
    data ClPseudoInverseTerm
      (A : Set) : Set where
      sing :
        A -> ClPseudoInverseTerm A
      invCl :
        ClPseudoInverseTerm A ->
        ClPseudoInverseTerm A
      opCl :
        ClPseudoInverseTerm A ->
        ClPseudoInverseTerm A ->
        ClPseudoInverseTerm A
    data OpPseudoInverseTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpPseudoInverseTerm n
      invOL :
        OpPseudoInverseTerm n ->
        OpPseudoInverseTerm n
      opOL :
        OpPseudoInverseTerm n ->
        OpPseudoInverseTerm n ->
        OpPseudoInverseTerm n
    data OpPseudoInverseTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpPseudoInverseTerm2 n A
      sing2 :
        A -> OpPseudoInverseTerm2 n A
      invOL2 :
        OpPseudoInverseTerm2 n A ->
        OpPseudoInverseTerm2 n A
      opOL2 :
        OpPseudoInverseTerm2 n A ->
        OpPseudoInverseTerm2 n A ->
        OpPseudoInverseTerm2 n A
    simplifyB :
      PseudoInverseTerm ->
      PseudoInverseTerm
    simplifyB (opL
               (opL x (invL x))
               x) = x
    simplifyB (invL x1) =
      invL (simplifyB x1)
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClPseudoInverseTerm A ->
      ClPseudoInverseTerm A
    simplifyCl _ (opCl
                  (opCl x (invCl x))
                  x) = x
    simplifyCl _ (invCl x1) =
      invCl (simplifyCl _ x1)
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpPseudoInverseTerm n ->
      OpPseudoInverseTerm n
    simplifyOp _ (opOL
                  (opOL x (invOL x))
                  x) = x
    simplifyOp _ (invOL x1) =
      invOL (simplifyOp _ x1)
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpPseudoInverseTerm2 n A ->
      OpPseudoInverseTerm2 n A
    simplifyOpE _ _ (opOL2
                     (opOL2 x (invOL2 x))
                     x) = x
    simplifyOpE _ _ (invOL2 x1) =
      invOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      PseudoInverse A ->
      PseudoInverseTerm -> A
    evalB _ Ps (invL x1) =
      inv Ps (evalB _ Ps x1)
    evalB _ Ps (opL x1 x2) =
      op Ps (evalB _ Ps x1)
        (evalB _ Ps x2)
    evalCl :
      (A : Set) ->
      PseudoInverse A ->
      ClPseudoInverseTerm A -> A
    evalCl _ Ps (sing x1) = x1
    evalCl _ Ps (invCl x1) =
      inv Ps (evalCl _ Ps x1)
    evalCl _ Ps (opCl x1 x2) =
      op Ps (evalCl _ Ps x1)
        (evalCl _ Ps x2)
    evalOp :
      (A : Set) (n : Nat) ->
      PseudoInverse A ->
      Vec A n ->
      OpPseudoInverseTerm n -> A
    evalOp _ n Ps vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ps vars (invOL x1) =
      inv Ps (evalOp _ n Ps vars x1)
    evalOp _ n Ps vars (opOL
                        x1
                        x2) =
      op Ps (evalOp _ n Ps vars x1)
        (evalOp _ n Ps vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      PseudoInverse A ->
      Vec A n ->
      OpPseudoInverseTerm2 n A -> A
    evalOpE _ n Ps vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ps vars (sing2 x1) =
      x1
    evalOpE _ n Ps vars (invOL2
                         x1) =
      inv Ps (evalOpE _ n Ps vars x1)
    evalOpE _ n Ps vars (opOL2
                         x1
                         x2) =
      op Ps (evalOpE _ n Ps vars x1)
        (evalOpE _ n Ps vars x2)
    inductionB :
      (P : PseudoInverseTerm ->
           Set) ->
      ((x1 : PseudoInverseTerm) ->
       P x1 -> P (invL x1)) ->
      ((x1 : PseudoInverseTerm)
       (x2 : PseudoInverseTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : PseudoInverseTerm) -> P x
    inductionB p pinvl popl (invL
                             x1) =
      pinvl _
        (inductionB p pinvl popl x1)
    inductionB p pinvl popl (opL
                             x1
                             x2) =
      popl _ _
        (inductionB p pinvl popl x1)
        (inductionB p pinvl popl x2)
    inductionCl :
      (A : Set)
      (P : ClPseudoInverseTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClPseudoInverseTerm A) ->
       P x1 -> P (invCl x1)) ->
      ((x1 : ClPseudoInverseTerm A)
       (x2 : ClPseudoInverseTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClPseudoInverseTerm A) ->
      P x
    inductionCl _ p psing pinvcl popcl (sing
                                        x1) = psing x1
    inductionCl _ p psing pinvcl popcl (invCl
                                        x1) =
      pinvcl _
        (inductionCl _ p psing pinvcl
           popcl
           x1)
    inductionCl _ p psing pinvcl popcl (opCl
                                        x1
                                        x2) =
      popcl _ _
        (inductionCl _ p psing pinvcl
           popcl
           x1)
        (inductionCl _ p psing pinvcl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpPseudoInverseTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpPseudoInverseTerm n) ->
       P x1 -> P (invOL x1)) ->
      ((x1 : OpPseudoInverseTerm n)
       (x2 : OpPseudoInverseTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpPseudoInverseTerm n) ->
      P x
    inductionOp _ p pv pinvol popol (v
                                     x1) = pv x1
    inductionOp _ p pv pinvol popol (invOL
                                     x1) =
      pinvol _
        (inductionOp _ p pv pinvol popol
           x1)
    inductionOp _ p pv pinvol popol (opOL
                                     x1
                                     x2) =
      popol _ _
        (inductionOp _ p pv pinvol popol
           x1)
        (inductionOp _ p pv pinvol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpPseudoInverseTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpPseudoInverseTerm2 n
          A) -> P x1 -> P (invOL2 x1)) ->
      ((x1 : OpPseudoInverseTerm2 n A)
       (x2 : OpPseudoInverseTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpPseudoInverseTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 pinvol2 popol2 (v2
                                                  x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pinvol2 popol2 (sing2
                                                  x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pinvol2 popol2 (invOL2
                                                  x1) =
      pinvol2 _
        (inductionOpE _ _ p pv2 psing2
           pinvol2
           popol2
           x1)
    inductionOpE _ _ p pv2 psing2 pinvol2 popol2 (opOL2
                                                  x1
                                                  x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           pinvol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           pinvol2
           popol2
           x2)
    invL' :
      PseudoInverseTerm ->
      PseudoInverseTerm
    invL' x1 = invL x1
    opL' :
      PseudoInverseTerm ->
      PseudoInverseTerm ->
      PseudoInverseTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      PseudoInverseTerm ->
      Staged PseudoInverseTerm
    stageB (invL x1) =
      stage1 _ _ invL'
        (codeLift1 _ _ invL')
        (stageB x1)
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    invCl' :
      (A : Set) ->
      ClPseudoInverseTerm A ->
      ClPseudoInverseTerm A
    invCl' _ x1 = invCl x1
    opCl' :
      (A : Set) ->
      ClPseudoInverseTerm A ->
      ClPseudoInverseTerm A ->
      ClPseudoInverseTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClPseudoInverseTerm A ->
      Staged (ClPseudoInverseTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (invCl x1) =
      stage1 _ _ (invCl' _)
        (codeLift1 _ _ (invCl' _))
        (stageCl _ x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    invOL' :
      (n : Nat) ->
      OpPseudoInverseTerm n ->
      OpPseudoInverseTerm n
    invOL' _ x1 = invOL x1
    opOL' :
      (n : Nat) ->
      OpPseudoInverseTerm n ->
      OpPseudoInverseTerm n ->
      OpPseudoInverseTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpPseudoInverseTerm n ->
      Staged (OpPseudoInverseTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (invOL x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (stageOp _ x1)
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    invOL2' :
      (n : Nat) (A : Set) ->
      OpPseudoInverseTerm2 n A ->
      OpPseudoInverseTerm2 n A
    invOL2' _ _ x1 = invOL2 x1
    opOL2' :
      (n : Nat) (A : Set) ->
      OpPseudoInverseTerm2 n A ->
      OpPseudoInverseTerm2 n A ->
      OpPseudoInverseTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpPseudoInverseTerm2 n A ->
      Staged
        (OpPseudoInverseTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (invOL2 x1) =
      stage1 _ _ (invOL2' _ _)
        (codeLift1 _ _ (invOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record PseudoInverseTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        invT : Repr A -> Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module PseudoInverseSig where
    record PseudoInverseSig
      (A : Set) : Set where
      constructor PseudoInverseSigC
      field
        inv : A -> A
        op : A -> A -> A
    record PseudoInverseSigSig
      (AS : Set) : Set where
      constructor PseudoInverseSigSigSigC
      field
        invS : AS -> AS
        opS : AS -> AS -> AS
    record PseudoInverseSigProd
      (AP : Set) : Set where
      constructor PseudoInverseSigProdC
      field
        invP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record PseudoInverseSigHom
      (A1 : Set) (A2 : Set)
      (Ps1 : PseudoInverseSig A1)
      (Ps2 : PseudoInverseSig A2) :
      Set where
      constructor PseudoInverseSigHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv Ps1 x1) ==
            inv Ps2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ps1 x1 x2) ==
            op Ps2 (hom x1) (hom x2)
    record PseudoInverseSigRelInterp
      (A1 : Set) (A2 : Set)
      (Ps1 : PseudoInverseSig A1)
      (Ps2 : PseudoInverseSig A2) :
      Set where
      constructor PseudoInverseSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Ps1 x1) (inv Ps2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ps1 x1 x2)
            (op Ps2 y1 y2)
    data PseudoInverseSigTerm
      : Set where
      invL :
        PseudoInverseSigTerm ->
        PseudoInverseSigTerm
      opL :
        PseudoInverseSigTerm ->
        PseudoInverseSigTerm ->
        PseudoInverseSigTerm
    data ClPseudoInverseSigTerm
      (A : Set) : Set where
      sing :
        A -> ClPseudoInverseSigTerm A
      invCl :
        ClPseudoInverseSigTerm A ->
        ClPseudoInverseSigTerm A
      opCl :
        ClPseudoInverseSigTerm A ->
        ClPseudoInverseSigTerm A ->
        ClPseudoInverseSigTerm A
    data OpPseudoInverseSigTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpPseudoInverseSigTerm n
      invOL :
        OpPseudoInverseSigTerm n ->
        OpPseudoInverseSigTerm n
      opOL :
        OpPseudoInverseSigTerm n ->
        OpPseudoInverseSigTerm n ->
        OpPseudoInverseSigTerm n
    data OpPseudoInverseSigTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpPseudoInverseSigTerm2 n A
      sing2 :
        A -> OpPseudoInverseSigTerm2 n A
      invOL2 :
        OpPseudoInverseSigTerm2 n A ->
        OpPseudoInverseSigTerm2 n A
      opOL2 :
        OpPseudoInverseSigTerm2 n A ->
        OpPseudoInverseSigTerm2 n A ->
        OpPseudoInverseSigTerm2 n A
    simplifyB :
      PseudoInverseSigTerm ->
      PseudoInverseSigTerm
    simplifyB (invL x1) =
      invL (simplifyB x1)
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClPseudoInverseSigTerm A ->
      ClPseudoInverseSigTerm A
    simplifyCl _ (invCl x1) =
      invCl (simplifyCl _ x1)
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpPseudoInverseSigTerm n ->
      OpPseudoInverseSigTerm n
    simplifyOp _ (invOL x1) =
      invOL (simplifyOp _ x1)
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpPseudoInverseSigTerm2 n A ->
      OpPseudoInverseSigTerm2 n A
    simplifyOpE _ _ (invOL2 x1) =
      invOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      PseudoInverseSig A ->
      PseudoInverseSigTerm -> A
    evalB _ Ps (invL x1) =
      inv Ps (evalB _ Ps x1)
    evalB _ Ps (opL x1 x2) =
      op Ps (evalB _ Ps x1)
        (evalB _ Ps x2)
    evalCl :
      (A : Set) ->
      PseudoInverseSig A ->
      ClPseudoInverseSigTerm A -> A
    evalCl _ Ps (sing x1) = x1
    evalCl _ Ps (invCl x1) =
      inv Ps (evalCl _ Ps x1)
    evalCl _ Ps (opCl x1 x2) =
      op Ps (evalCl _ Ps x1)
        (evalCl _ Ps x2)
    evalOp :
      (A : Set) (n : Nat) ->
      PseudoInverseSig A ->
      Vec A n ->
      OpPseudoInverseSigTerm n -> A
    evalOp _ n Ps vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ps vars (invOL x1) =
      inv Ps (evalOp _ n Ps vars x1)
    evalOp _ n Ps vars (opOL
                        x1
                        x2) =
      op Ps (evalOp _ n Ps vars x1)
        (evalOp _ n Ps vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      PseudoInverseSig A ->
      Vec A n ->
      OpPseudoInverseSigTerm2 n A -> A
    evalOpE _ n Ps vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ps vars (sing2 x1) =
      x1
    evalOpE _ n Ps vars (invOL2
                         x1) =
      inv Ps (evalOpE _ n Ps vars x1)
    evalOpE _ n Ps vars (opOL2
                         x1
                         x2) =
      op Ps (evalOpE _ n Ps vars x1)
        (evalOpE _ n Ps vars x2)
    inductionB :
      (P : PseudoInverseSigTerm ->
           Set) ->
      ((x1 : PseudoInverseSigTerm) ->
       P x1 -> P (invL x1)) ->
      ((x1 : PseudoInverseSigTerm)
       (x2 : PseudoInverseSigTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : PseudoInverseSigTerm) ->
      P x
    inductionB p pinvl popl (invL
                             x1) =
      pinvl _
        (inductionB p pinvl popl x1)
    inductionB p pinvl popl (opL
                             x1
                             x2) =
      popl _ _
        (inductionB p pinvl popl x1)
        (inductionB p pinvl popl x2)
    inductionCl :
      (A : Set)
      (P : ClPseudoInverseSigTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClPseudoInverseSigTerm
          A) -> P x1 -> P (invCl x1)) ->
      ((x1 : ClPseudoInverseSigTerm A)
       (x2 : ClPseudoInverseSigTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClPseudoInverseSigTerm
         A) -> P x
    inductionCl _ p psing pinvcl popcl (sing
                                        x1) = psing x1
    inductionCl _ p psing pinvcl popcl (invCl
                                        x1) =
      pinvcl _
        (inductionCl _ p psing pinvcl
           popcl
           x1)
    inductionCl _ p psing pinvcl popcl (opCl
                                        x1
                                        x2) =
      popcl _ _
        (inductionCl _ p psing pinvcl
           popcl
           x1)
        (inductionCl _ p psing pinvcl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpPseudoInverseSigTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpPseudoInverseSigTerm
          n) -> P x1 -> P (invOL x1)) ->
      ((x1 : OpPseudoInverseSigTerm n)
       (x2 : OpPseudoInverseSigTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpPseudoInverseSigTerm
         n) -> P x
    inductionOp _ p pv pinvol popol (v
                                     x1) = pv x1
    inductionOp _ p pv pinvol popol (invOL
                                     x1) =
      pinvol _
        (inductionOp _ p pv pinvol popol
           x1)
    inductionOp _ p pv pinvol popol (opOL
                                     x1
                                     x2) =
      popol _ _
        (inductionOp _ p pv pinvol popol
           x1)
        (inductionOp _ p pv pinvol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpPseudoInverseSigTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpPseudoInverseSigTerm2 n
          A) -> P x1 -> P (invOL2 x1)) ->
      ((x1 : OpPseudoInverseSigTerm2 n
          A)
       (x2 : OpPseudoInverseSigTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpPseudoInverseSigTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 pinvol2 popol2 (v2
                                                  x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pinvol2 popol2 (sing2
                                                  x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pinvol2 popol2 (invOL2
                                                  x1) =
      pinvol2 _
        (inductionOpE _ _ p pv2 psing2
           pinvol2
           popol2
           x1)
    inductionOpE _ _ p pv2 psing2 pinvol2 popol2 (opOL2
                                                  x1
                                                  x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           pinvol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           pinvol2
           popol2
           x2)
    invL' :
      PseudoInverseSigTerm ->
      PseudoInverseSigTerm
    invL' x1 = invL x1
    opL' :
      PseudoInverseSigTerm ->
      PseudoInverseSigTerm ->
      PseudoInverseSigTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      PseudoInverseSigTerm ->
      Staged PseudoInverseSigTerm
    stageB (invL x1) =
      stage1 _ _ invL'
        (codeLift1 _ _ invL')
        (stageB x1)
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    invCl' :
      (A : Set) ->
      ClPseudoInverseSigTerm A ->
      ClPseudoInverseSigTerm A
    invCl' _ x1 = invCl x1
    opCl' :
      (A : Set) ->
      ClPseudoInverseSigTerm A ->
      ClPseudoInverseSigTerm A ->
      ClPseudoInverseSigTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClPseudoInverseSigTerm A ->
      Staged
        (ClPseudoInverseSigTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (invCl x1) =
      stage1 _ _ (invCl' _)
        (codeLift1 _ _ (invCl' _))
        (stageCl _ x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    invOL' :
      (n : Nat) ->
      OpPseudoInverseSigTerm n ->
      OpPseudoInverseSigTerm n
    invOL' _ x1 = invOL x1
    opOL' :
      (n : Nat) ->
      OpPseudoInverseSigTerm n ->
      OpPseudoInverseSigTerm n ->
      OpPseudoInverseSigTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpPseudoInverseSigTerm n ->
      Staged
        (OpPseudoInverseSigTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (invOL x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (stageOp _ x1)
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    invOL2' :
      (n : Nat) (A : Set) ->
      OpPseudoInverseSigTerm2 n A ->
      OpPseudoInverseSigTerm2 n A
    invOL2' _ _ x1 = invOL2 x1
    opOL2' :
      (n : Nat) (A : Set) ->
      OpPseudoInverseSigTerm2 n A ->
      OpPseudoInverseSigTerm2 n A ->
      OpPseudoInverseSigTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpPseudoInverseSigTerm2 n A ->
      Staged
        (OpPseudoInverseSigTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (invOL2 x1) =
      stage1 _ _ (invOL2' _ _)
        (codeLift1 _ _ (invOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record PseudoInverseSigTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        invT : Repr A -> Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module PseudoInvolution where
    record PseudoInvolution
      (A : Set) : Set where
      constructor PseudoInvolutionC
      field
        inv : A -> A
        op : A -> A -> A
        quasiRightInverse_inv_op_e :
          (x : A) ->
          op (op (inv x) x) (inv x) ==
            inv x
    record PseudoInvolutionSig
      (AS : Set) : Set where
      constructor PseudoInvolutionSigSigC
      field
        invS : AS -> AS
        opS : AS -> AS -> AS
    record PseudoInvolutionProd
      (AP : Set) : Set where
      constructor PseudoInvolutionProdC
      field
        invP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        quasiRightInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (opP (invP xP) xP)
            (invP xP) == invP xP
    record PseudoInvolutionHom
      (A1 : Set) (A2 : Set)
      (Ps1 : PseudoInvolution A1)
      (Ps2 : PseudoInvolution A2) :
      Set where
      constructor PseudoInvolutionHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv Ps1 x1) ==
            inv Ps2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ps1 x1 x2) ==
            op Ps2 (hom x1) (hom x2)
    record PseudoInvolutionRelInterp
      (A1 : Set) (A2 : Set)
      (Ps1 : PseudoInvolution A1)
      (Ps2 : PseudoInvolution A2) :
      Set where
      constructor PseudoInvolutionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Ps1 x1) (inv Ps2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ps1 x1 x2)
            (op Ps2 y1 y2)
    data PseudoInvolutionTerm
      : Set where
      invL :
        PseudoInvolutionTerm ->
        PseudoInvolutionTerm
      opL :
        PseudoInvolutionTerm ->
        PseudoInvolutionTerm ->
        PseudoInvolutionTerm
    data ClPseudoInvolutionTerm
      (A : Set) : Set where
      sing :
        A -> ClPseudoInvolutionTerm A
      invCl :
        ClPseudoInvolutionTerm A ->
        ClPseudoInvolutionTerm A
      opCl :
        ClPseudoInvolutionTerm A ->
        ClPseudoInvolutionTerm A ->
        ClPseudoInvolutionTerm A
    data OpPseudoInvolutionTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpPseudoInvolutionTerm n
      invOL :
        OpPseudoInvolutionTerm n ->
        OpPseudoInvolutionTerm n
      opOL :
        OpPseudoInvolutionTerm n ->
        OpPseudoInvolutionTerm n ->
        OpPseudoInvolutionTerm n
    data OpPseudoInvolutionTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpPseudoInvolutionTerm2 n A
      sing2 :
        A -> OpPseudoInvolutionTerm2 n A
      invOL2 :
        OpPseudoInvolutionTerm2 n A ->
        OpPseudoInvolutionTerm2 n A
      opOL2 :
        OpPseudoInvolutionTerm2 n A ->
        OpPseudoInvolutionTerm2 n A ->
        OpPseudoInvolutionTerm2 n A
    simplifyB :
      PseudoInvolutionTerm ->
      PseudoInvolutionTerm
    simplifyB (opL
               (opL (invL x) x)
               (invL x)) = invL x
    simplifyB (invL x1) =
      invL (simplifyB x1)
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClPseudoInvolutionTerm A ->
      ClPseudoInvolutionTerm A
    simplifyCl _ (opCl
                  (opCl (invCl x) x)
                  (invCl x)) = invCl x
    simplifyCl _ (invCl x1) =
      invCl (simplifyCl _ x1)
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpPseudoInvolutionTerm n ->
      OpPseudoInvolutionTerm n
    simplifyOp _ (opOL
                  (opOL (invOL x) x)
                  (invOL x)) = invOL x
    simplifyOp _ (invOL x1) =
      invOL (simplifyOp _ x1)
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpPseudoInvolutionTerm2 n A ->
      OpPseudoInvolutionTerm2 n A
    simplifyOpE _ _ (opOL2
                     (opOL2 (invOL2 x) x)
                     (invOL2 x)) = invOL2 x
    simplifyOpE _ _ (invOL2 x1) =
      invOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      PseudoInvolution A ->
      PseudoInvolutionTerm -> A
    evalB _ Ps (invL x1) =
      inv Ps (evalB _ Ps x1)
    evalB _ Ps (opL x1 x2) =
      op Ps (evalB _ Ps x1)
        (evalB _ Ps x2)
    evalCl :
      (A : Set) ->
      PseudoInvolution A ->
      ClPseudoInvolutionTerm A -> A
    evalCl _ Ps (sing x1) = x1
    evalCl _ Ps (invCl x1) =
      inv Ps (evalCl _ Ps x1)
    evalCl _ Ps (opCl x1 x2) =
      op Ps (evalCl _ Ps x1)
        (evalCl _ Ps x2)
    evalOp :
      (A : Set) (n : Nat) ->
      PseudoInvolution A ->
      Vec A n ->
      OpPseudoInvolutionTerm n -> A
    evalOp _ n Ps vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ps vars (invOL x1) =
      inv Ps (evalOp _ n Ps vars x1)
    evalOp _ n Ps vars (opOL
                        x1
                        x2) =
      op Ps (evalOp _ n Ps vars x1)
        (evalOp _ n Ps vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      PseudoInvolution A ->
      Vec A n ->
      OpPseudoInvolutionTerm2 n A -> A
    evalOpE _ n Ps vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ps vars (sing2 x1) =
      x1
    evalOpE _ n Ps vars (invOL2
                         x1) =
      inv Ps (evalOpE _ n Ps vars x1)
    evalOpE _ n Ps vars (opOL2
                         x1
                         x2) =
      op Ps (evalOpE _ n Ps vars x1)
        (evalOpE _ n Ps vars x2)
    inductionB :
      (P : PseudoInvolutionTerm ->
           Set) ->
      ((x1 : PseudoInvolutionTerm) ->
       P x1 -> P (invL x1)) ->
      ((x1 : PseudoInvolutionTerm)
       (x2 : PseudoInvolutionTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : PseudoInvolutionTerm) ->
      P x
    inductionB p pinvl popl (invL
                             x1) =
      pinvl _
        (inductionB p pinvl popl x1)
    inductionB p pinvl popl (opL
                             x1
                             x2) =
      popl _ _
        (inductionB p pinvl popl x1)
        (inductionB p pinvl popl x2)
    inductionCl :
      (A : Set)
      (P : ClPseudoInvolutionTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClPseudoInvolutionTerm
          A) -> P x1 -> P (invCl x1)) ->
      ((x1 : ClPseudoInvolutionTerm A)
       (x2 : ClPseudoInvolutionTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClPseudoInvolutionTerm
         A) -> P x
    inductionCl _ p psing pinvcl popcl (sing
                                        x1) = psing x1
    inductionCl _ p psing pinvcl popcl (invCl
                                        x1) =
      pinvcl _
        (inductionCl _ p psing pinvcl
           popcl
           x1)
    inductionCl _ p psing pinvcl popcl (opCl
                                        x1
                                        x2) =
      popcl _ _
        (inductionCl _ p psing pinvcl
           popcl
           x1)
        (inductionCl _ p psing pinvcl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpPseudoInvolutionTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpPseudoInvolutionTerm
          n) -> P x1 -> P (invOL x1)) ->
      ((x1 : OpPseudoInvolutionTerm n)
       (x2 : OpPseudoInvolutionTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpPseudoInvolutionTerm
         n) -> P x
    inductionOp _ p pv pinvol popol (v
                                     x1) = pv x1
    inductionOp _ p pv pinvol popol (invOL
                                     x1) =
      pinvol _
        (inductionOp _ p pv pinvol popol
           x1)
    inductionOp _ p pv pinvol popol (opOL
                                     x1
                                     x2) =
      popol _ _
        (inductionOp _ p pv pinvol popol
           x1)
        (inductionOp _ p pv pinvol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpPseudoInvolutionTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpPseudoInvolutionTerm2 n
          A) -> P x1 -> P (invOL2 x1)) ->
      ((x1 : OpPseudoInvolutionTerm2 n
          A)
       (x2 : OpPseudoInvolutionTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpPseudoInvolutionTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 pinvol2 popol2 (v2
                                                  x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pinvol2 popol2 (sing2
                                                  x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pinvol2 popol2 (invOL2
                                                  x1) =
      pinvol2 _
        (inductionOpE _ _ p pv2 psing2
           pinvol2
           popol2
           x1)
    inductionOpE _ _ p pv2 psing2 pinvol2 popol2 (opOL2
                                                  x1
                                                  x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           pinvol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           pinvol2
           popol2
           x2)
    invL' :
      PseudoInvolutionTerm ->
      PseudoInvolutionTerm
    invL' x1 = invL x1
    opL' :
      PseudoInvolutionTerm ->
      PseudoInvolutionTerm ->
      PseudoInvolutionTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      PseudoInvolutionTerm ->
      Staged PseudoInvolutionTerm
    stageB (invL x1) =
      stage1 _ _ invL'
        (codeLift1 _ _ invL')
        (stageB x1)
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    invCl' :
      (A : Set) ->
      ClPseudoInvolutionTerm A ->
      ClPseudoInvolutionTerm A
    invCl' _ x1 = invCl x1
    opCl' :
      (A : Set) ->
      ClPseudoInvolutionTerm A ->
      ClPseudoInvolutionTerm A ->
      ClPseudoInvolutionTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClPseudoInvolutionTerm A ->
      Staged
        (ClPseudoInvolutionTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (invCl x1) =
      stage1 _ _ (invCl' _)
        (codeLift1 _ _ (invCl' _))
        (stageCl _ x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    invOL' :
      (n : Nat) ->
      OpPseudoInvolutionTerm n ->
      OpPseudoInvolutionTerm n
    invOL' _ x1 = invOL x1
    opOL' :
      (n : Nat) ->
      OpPseudoInvolutionTerm n ->
      OpPseudoInvolutionTerm n ->
      OpPseudoInvolutionTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpPseudoInvolutionTerm n ->
      Staged
        (OpPseudoInvolutionTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (invOL x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (stageOp _ x1)
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    invOL2' :
      (n : Nat) (A : Set) ->
      OpPseudoInvolutionTerm2 n A ->
      OpPseudoInvolutionTerm2 n A
    invOL2' _ _ x1 = invOL2 x1
    opOL2' :
      (n : Nat) (A : Set) ->
      OpPseudoInvolutionTerm2 n A ->
      OpPseudoInvolutionTerm2 n A ->
      OpPseudoInvolutionTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpPseudoInvolutionTerm2 n A ->
      Staged
        (OpPseudoInvolutionTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (invOL2 x1) =
      stage1 _ _ (invOL2' _ _)
        (codeLift1 _ _ (invOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record PseudoInvolutionTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        invT : Repr A -> Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module Quandle where
    record Quandle
      (A : Set) : Set where
      constructor QuandleC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
        leftInverse :
          (x : A) (y : A) ->
          <| (|> x y) x == y
        rightInverse :
          (x : A) (y : A) ->
          |> x (<| y x) == y
        idempotent_|> :
          (x : A) -> |> x x == x
        idempotent_<| :
          (x : A) -> <| x x == x
    record QuandleSig
      (AS : Set) : Set where
      constructor QuandleSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record QuandleProd
      (AP : Set) : Set where
      constructor QuandleProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
        leftInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          <|P (|>P xP yP) xP == yP
        rightInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          |>P xP (<|P yP xP) == yP
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
        idempotent_<|P :
          (xP : Prod AP AP) ->
          <|P xP xP == xP
    record QuandleHom
      (A1 : Set) (A2 : Set)
      (Qu1 : Quandle A1)
      (Qu2 : Quandle A2) : Set where
      constructor QuandleHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Qu1 x1 x2) ==
            |> Qu2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Qu1 x1 x2) ==
            <| Qu2 (hom x1) (hom x2)
    record QuandleRelInterp
      (A1 : Set) (A2 : Set)
      (Qu1 : Quandle A1)
      (Qu2 : Quandle A2) : Set where
      constructor QuandleRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Qu1 x1 x2)
            (|> Qu2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Qu1 x1 x2)
            (<| Qu2 y1 y2)
    data QuandleTerm : Set where
      |>L :
        QuandleTerm ->
        QuandleTerm -> QuandleTerm
      <|L :
        QuandleTerm ->
        QuandleTerm -> QuandleTerm
    data ClQuandleTerm
      (A : Set) : Set where
      sing : A -> ClQuandleTerm A
      |>Cl :
        ClQuandleTerm A ->
        ClQuandleTerm A ->
        ClQuandleTerm A
      <|Cl :
        ClQuandleTerm A ->
        ClQuandleTerm A ->
        ClQuandleTerm A
    data OpQuandleTerm
      (n : Nat) : Set where
      v : Fin n -> OpQuandleTerm n
      |>OL :
        OpQuandleTerm n ->
        OpQuandleTerm n ->
        OpQuandleTerm n
      <|OL :
        OpQuandleTerm n ->
        OpQuandleTerm n ->
        OpQuandleTerm n
    data OpQuandleTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpQuandleTerm2 n A
      sing2 : A -> OpQuandleTerm2 n A
      |>OL2 :
        OpQuandleTerm2 n A ->
        OpQuandleTerm2 n A ->
        OpQuandleTerm2 n A
      <|OL2 :
        OpQuandleTerm2 n A ->
        OpQuandleTerm2 n A ->
        OpQuandleTerm2 n A
    simplifyB :
      QuandleTerm -> QuandleTerm
    simplifyB (|>L
               (|>L x y)
               (|>L x z)) = |>L x (|>L y z)
    simplifyB (<|L
               (<|L y x)
               (<|L z x)) = <|L (<|L y z) x
    simplifyB (<|L (|>L x y) x) = y
    simplifyB (|>L x (<|L y x)) = y
    simplifyB (|>L x x) = x
    simplifyB (<|L x x) = x
    simplifyB (|>L x1 x2) =
      |>L (simplifyB x1)
        (simplifyB x2)
    simplifyB (<|L x1 x2) =
      <|L (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClQuandleTerm A ->
      ClQuandleTerm A
    simplifyCl _ (|>Cl
                  (|>Cl x y)
                  (|>Cl x z)) = |>Cl x (|>Cl y z)
    simplifyCl _ (<|Cl
                  (<|Cl y x)
                  (<|Cl z x)) = <|Cl (<|Cl y z) x
    simplifyCl _ (<|Cl
                  (|>Cl x y)
                  x) = y
    simplifyCl _ (|>Cl
                  x
                  (<|Cl y x)) = y
    simplifyCl _ (|>Cl x x) = x
    simplifyCl _ (<|Cl x x) = x
    simplifyCl _ (|>Cl x1 x2) =
      |>Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (<|Cl x1 x2) =
      <|Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpQuandleTerm n ->
      OpQuandleTerm n
    simplifyOp _ (|>OL
                  (|>OL x y)
                  (|>OL x z)) = |>OL x (|>OL y z)
    simplifyOp _ (<|OL
                  (<|OL y x)
                  (<|OL z x)) = <|OL (<|OL y z) x
    simplifyOp _ (<|OL
                  (|>OL x y)
                  x) = y
    simplifyOp _ (|>OL
                  x
                  (<|OL y x)) = y
    simplifyOp _ (|>OL x x) = x
    simplifyOp _ (<|OL x x) = x
    simplifyOp _ (|>OL x1 x2) =
      |>OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (<|OL x1 x2) =
      <|OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpQuandleTerm2 n A ->
      OpQuandleTerm2 n A
    simplifyOpE _ _ (|>OL2
                     (|>OL2 x y)
                     (|>OL2 x z)) =
      |>OL2 x (|>OL2 y z)
    simplifyOpE _ _ (<|OL2
                     (<|OL2 y x)
                     (<|OL2 z x)) =
      <|OL2 (<|OL2 y z) x
    simplifyOpE _ _ (<|OL2
                     (|>OL2 x y)
                     x) = y
    simplifyOpE _ _ (|>OL2
                     x
                     (<|OL2 y x)) = y
    simplifyOpE _ _ (|>OL2 x x) = x
    simplifyOpE _ _ (<|OL2 x x) = x
    simplifyOpE _ _ (|>OL2 x1 x2) =
      |>OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (<|OL2 x1 x2) =
      <|OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Quandle A -> QuandleTerm -> A
    evalB _ Qu (|>L x1 x2) =
      |> Qu (evalB _ Qu x1)
        (evalB _ Qu x2)
    evalB _ Qu (<|L x1 x2) =
      <| Qu (evalB _ Qu x1)
        (evalB _ Qu x2)
    evalCl :
      (A : Set) ->
      Quandle A ->
      ClQuandleTerm A -> A
    evalCl _ Qu (sing x1) = x1
    evalCl _ Qu (|>Cl x1 x2) =
      |> Qu (evalCl _ Qu x1)
        (evalCl _ Qu x2)
    evalCl _ Qu (<|Cl x1 x2) =
      <| Qu (evalCl _ Qu x1)
        (evalCl _ Qu x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Quandle A ->
      Vec A n -> OpQuandleTerm n -> A
    evalOp _ n Qu vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Qu vars (|>OL
                        x1
                        x2) =
      |> Qu (evalOp _ n Qu vars x1)
        (evalOp _ n Qu vars x2)
    evalOp _ n Qu vars (<|OL
                        x1
                        x2) =
      <| Qu (evalOp _ n Qu vars x1)
        (evalOp _ n Qu vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Quandle A ->
      Vec A n ->
      OpQuandleTerm2 n A -> A
    evalOpE _ n Qu vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Qu vars (sing2 x1) =
      x1
    evalOpE _ n Qu vars (|>OL2
                         x1
                         x2) =
      |> Qu (evalOpE _ n Qu vars x1)
        (evalOpE _ n Qu vars x2)
    evalOpE _ n Qu vars (<|OL2
                         x1
                         x2) =
      <| Qu (evalOpE _ n Qu vars x1)
        (evalOpE _ n Qu vars x2)
    inductionB :
      (P : QuandleTerm -> Set) ->
      ((x1 : QuandleTerm)
       (x2 : QuandleTerm) ->
       P x1 ->
       P x2 -> P (|>L x1 x2)) ->
      ((x1 : QuandleTerm)
       (x2 : QuandleTerm) ->
       P x1 ->
       P x2 -> P (<|L x1 x2)) ->
      (x : QuandleTerm) -> P x
    inductionB p p|>l p<|l (|>L
                            x1
                            x2) =
      p|>l _ _
        (inductionB p p|>l p<|l x1)
        (inductionB p p|>l p<|l x2)
    inductionB p p|>l p<|l (<|L
                            x1
                            x2) =
      p<|l _ _
        (inductionB p p|>l p<|l x1)
        (inductionB p p|>l p<|l x2)
    inductionCl :
      (A : Set)
      (P : ClQuandleTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClQuandleTerm A)
       (x2 : ClQuandleTerm A) ->
       P x1 ->
       P x2 -> P (|>Cl x1 x2)) ->
      ((x1 : ClQuandleTerm A)
       (x2 : ClQuandleTerm A) ->
       P x1 ->
       P x2 -> P (<|Cl x1 x2)) ->
      (x : ClQuandleTerm A) -> P x
    inductionCl _ p psing p|>cl p<|cl (sing
                                       x1) = psing x1
    inductionCl _ p psing p|>cl p<|cl (|>Cl
                                       x1
                                       x2) =
      p|>cl _ _
        (inductionCl _ p psing p|>cl
           p<|cl
           x1)
        (inductionCl _ p psing p|>cl
           p<|cl
           x2)
    inductionCl _ p psing p|>cl p<|cl (<|Cl
                                       x1
                                       x2) =
      p<|cl _ _
        (inductionCl _ p psing p|>cl
           p<|cl
           x1)
        (inductionCl _ p psing p|>cl
           p<|cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpQuandleTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpQuandleTerm n)
       (x2 : OpQuandleTerm n) ->
       P x1 ->
       P x2 -> P (|>OL x1 x2)) ->
      ((x1 : OpQuandleTerm n)
       (x2 : OpQuandleTerm n) ->
       P x1 ->
       P x2 -> P (<|OL x1 x2)) ->
      (x : OpQuandleTerm n) -> P x
    inductionOp _ p pv p|>ol p<|ol (v
                                    x1) = pv x1
    inductionOp _ p pv p|>ol p<|ol (|>OL
                                    x1
                                    x2) =
      p|>ol _ _
        (inductionOp _ p pv p|>ol p<|ol
           x1)
        (inductionOp _ p pv p|>ol p<|ol
           x2)
    inductionOp _ p pv p|>ol p<|ol (<|OL
                                    x1
                                    x2) =
      p<|ol _ _
        (inductionOp _ p pv p|>ol p<|ol
           x1)
        (inductionOp _ p pv p|>ol p<|ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpQuandleTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpQuandleTerm2 n A)
       (x2 : OpQuandleTerm2 n A) ->
       P x1 ->
       P x2 -> P (|>OL2 x1 x2)) ->
      ((x1 : OpQuandleTerm2 n A)
       (x2 : OpQuandleTerm2 n A) ->
       P x1 ->
       P x2 -> P (<|OL2 x1 x2)) ->
      (x : OpQuandleTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (v2
                                                 x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (sing2
                                                 x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (|>OL2
                                                 x1
                                                 x2) =
      p|>ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (<|OL2
                                                 x1
                                                 x2) =
      p<|ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x2)
    |>L' :
      QuandleTerm ->
      QuandleTerm -> QuandleTerm
    |>L' x1 x2 = |>L x1 x2
    <|L' :
      QuandleTerm ->
      QuandleTerm -> QuandleTerm
    <|L' x1 x2 = <|L x1 x2
    stageB :
      QuandleTerm ->
      Staged QuandleTerm
    stageB (|>L x1 x2) =
      stage2 _ _ _ |>L'
        (codeLift2 _ _ _ |>L')
        (stageB x1)
        (stageB x2)
    stageB (<|L x1 x2) =
      stage2 _ _ _ <|L'
        (codeLift2 _ _ _ <|L')
        (stageB x1)
        (stageB x2)
    |>Cl' :
      (A : Set) ->
      ClQuandleTerm A ->
      ClQuandleTerm A ->
      ClQuandleTerm A
    |>Cl' _ x1 x2 = |>Cl x1 x2
    <|Cl' :
      (A : Set) ->
      ClQuandleTerm A ->
      ClQuandleTerm A ->
      ClQuandleTerm A
    <|Cl' _ x1 x2 = <|Cl x1 x2
    stageCl :
      (A : Set) ->
      ClQuandleTerm A ->
      Staged (ClQuandleTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (|>Cl x1 x2) =
      stage2 _ _ _ (|>Cl' _)
        (codeLift2 _ _ _ (|>Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (<|Cl x1 x2) =
      stage2 _ _ _ (<|Cl' _)
        (codeLift2 _ _ _ (<|Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    |>OL' :
      (n : Nat) ->
      OpQuandleTerm n ->
      OpQuandleTerm n ->
      OpQuandleTerm n
    |>OL' _ x1 x2 = |>OL x1 x2
    <|OL' :
      (n : Nat) ->
      OpQuandleTerm n ->
      OpQuandleTerm n ->
      OpQuandleTerm n
    <|OL' _ x1 x2 = <|OL x1 x2
    stageOp :
      (n : Nat) ->
      OpQuandleTerm n ->
      Staged (OpQuandleTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (|>OL x1 x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (<|OL x1 x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    |>OL2' :
      (n : Nat) (A : Set) ->
      OpQuandleTerm2 n A ->
      OpQuandleTerm2 n A ->
      OpQuandleTerm2 n A
    |>OL2' _ _ x1 x2 = |>OL2 x1 x2
    <|OL2' :
      (n : Nat) (A : Set) ->
      OpQuandleTerm2 n A ->
      OpQuandleTerm2 n A ->
      OpQuandleTerm2 n A
    <|OL2' _ _ x1 x2 = <|OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpQuandleTerm2 n A ->
      Staged (OpQuandleTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (|>OL2 x1 x2) =
      stage2 _ _ _ (|>OL2' _ _)
        (codeLift2 _ _ _ (|>OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (<|OL2 x1 x2) =
      stage2 _ _ _ (<|OL2' _ _)
        (codeLift2 _ _ _ (<|OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record QuandleTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        |>T : Repr A -> Repr A -> Repr A
        <|T : Repr A -> Repr A -> Repr A
  
  module QuasiGroup where
    record QuasiGroup
      (A : Set) : Set where
      constructor QuasiGroupC
      field
        op : A -> A -> A
        linv : A -> A -> A
        leftCancel :
          (x : A) (y : A) ->
          op x (linv x y) == y
        lefCancelOp :
          (x : A) (y : A) ->
          linv x (op x y) == y
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
    record QuasiGroupSig
      (AS : Set) : Set where
      constructor QuasiGroupSigSigC
      field
        opS : AS -> AS -> AS
        linvS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record QuasiGroupProd
      (AP : Set) : Set where
      constructor QuasiGroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        linvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (linvP xP yP) == yP
        lefCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          linvP xP (opP xP yP) == yP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
    record QuasiGroupHom
      (A1 : Set) (A2 : Set)
      (Qu1 : QuasiGroup A1)
      (Qu2 : QuasiGroup A2) :
      Set where
      constructor QuasiGroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Qu1 x1 x2) ==
            op Qu2 (hom x1) (hom x2)
        pres-linv :
          (x1 : A1) (x2 : A1) ->
          hom (linv Qu1 x1 x2) ==
            linv Qu2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Qu1 x1 x2) ==
            rinv Qu2 (hom x1) (hom x2)
    record QuasiGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Qu1 : QuasiGroup A1)
      (Qu2 : QuasiGroup A2) :
      Set where
      constructor QuasiGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Qu1 x1 x2)
            (op Qu2 y1 y2)
        interp-linv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (linv Qu1 x1 x2)
            (linv Qu2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Qu1 x1 x2)
            (rinv Qu2 y1 y2)
    data QuasiGroupTerm : Set where
      opL :
        QuasiGroupTerm ->
        QuasiGroupTerm -> QuasiGroupTerm
      linvL :
        QuasiGroupTerm ->
        QuasiGroupTerm -> QuasiGroupTerm
      rinvL :
        QuasiGroupTerm ->
        QuasiGroupTerm -> QuasiGroupTerm
    data ClQuasiGroupTerm
      (A : Set) : Set where
      sing : A -> ClQuasiGroupTerm A
      opCl :
        ClQuasiGroupTerm A ->
        ClQuasiGroupTerm A ->
        ClQuasiGroupTerm A
      linvCl :
        ClQuasiGroupTerm A ->
        ClQuasiGroupTerm A ->
        ClQuasiGroupTerm A
      rinvCl :
        ClQuasiGroupTerm A ->
        ClQuasiGroupTerm A ->
        ClQuasiGroupTerm A
    data OpQuasiGroupTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpQuasiGroupTerm n
      opOL :
        OpQuasiGroupTerm n ->
        OpQuasiGroupTerm n ->
        OpQuasiGroupTerm n
      linvOL :
        OpQuasiGroupTerm n ->
        OpQuasiGroupTerm n ->
        OpQuasiGroupTerm n
      rinvOL :
        OpQuasiGroupTerm n ->
        OpQuasiGroupTerm n ->
        OpQuasiGroupTerm n
    data OpQuasiGroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpQuasiGroupTerm2 n A
      sing2 :
        A -> OpQuasiGroupTerm2 n A
      opOL2 :
        OpQuasiGroupTerm2 n A ->
        OpQuasiGroupTerm2 n A ->
        OpQuasiGroupTerm2 n A
      linvOL2 :
        OpQuasiGroupTerm2 n A ->
        OpQuasiGroupTerm2 n A ->
        OpQuasiGroupTerm2 n A
      rinvOL2 :
        OpQuasiGroupTerm2 n A ->
        OpQuasiGroupTerm2 n A ->
        OpQuasiGroupTerm2 n A
    simplifyB :
      QuasiGroupTerm -> QuasiGroupTerm
    simplifyB (opL x (linvL x y)) =
      y
    simplifyB (linvL x (opL x y)) =
      y
    simplifyB (opL (rinvL y x) x) =
      y
    simplifyB (rinvL (opL y x) x) =
      y
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (linvL x1 x2) =
      linvL (simplifyB x1)
        (simplifyB x2)
    simplifyB (rinvL x1 x2) =
      rinvL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClQuasiGroupTerm A ->
      ClQuasiGroupTerm A
    simplifyCl _ (opCl
                  x
                  (linvCl x y)) = y
    simplifyCl _ (linvCl
                  x
                  (opCl x y)) = y
    simplifyCl _ (opCl
                  (rinvCl y x)
                  x) = y
    simplifyCl _ (rinvCl
                  (opCl y x)
                  x) = y
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (linvCl x1 x2) =
      linvCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (rinvCl x1 x2) =
      rinvCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpQuasiGroupTerm n ->
      OpQuasiGroupTerm n
    simplifyOp _ (opOL
                  x
                  (linvOL x y)) = y
    simplifyOp _ (linvOL
                  x
                  (opOL x y)) = y
    simplifyOp _ (opOL
                  (rinvOL y x)
                  x) = y
    simplifyOp _ (rinvOL
                  (opOL y x)
                  x) = y
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (linvOL x1 x2) =
      linvOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (rinvOL x1 x2) =
      rinvOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpQuasiGroupTerm2 n A ->
      OpQuasiGroupTerm2 n A
    simplifyOpE _ _ (opOL2
                     x
                     (linvOL2 x y)) = y
    simplifyOpE _ _ (linvOL2
                     x
                     (opOL2 x y)) = y
    simplifyOpE _ _ (opOL2
                     (rinvOL2 y x)
                     x) = y
    simplifyOpE _ _ (rinvOL2
                     (opOL2 y x)
                     x) = y
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (linvOL2
                     x1
                     x2) =
      linvOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (rinvOL2
                     x1
                     x2) =
      rinvOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      QuasiGroup A ->
      QuasiGroupTerm -> A
    evalB _ Qu (opL x1 x2) =
      op Qu (evalB _ Qu x1)
        (evalB _ Qu x2)
    evalB _ Qu (linvL x1 x2) =
      linv Qu (evalB _ Qu x1)
        (evalB _ Qu x2)
    evalB _ Qu (rinvL x1 x2) =
      rinv Qu (evalB _ Qu x1)
        (evalB _ Qu x2)
    evalCl :
      (A : Set) ->
      QuasiGroup A ->
      ClQuasiGroupTerm A -> A
    evalCl _ Qu (sing x1) = x1
    evalCl _ Qu (opCl x1 x2) =
      op Qu (evalCl _ Qu x1)
        (evalCl _ Qu x2)
    evalCl _ Qu (linvCl x1 x2) =
      linv Qu (evalCl _ Qu x1)
        (evalCl _ Qu x2)
    evalCl _ Qu (rinvCl x1 x2) =
      rinv Qu (evalCl _ Qu x1)
        (evalCl _ Qu x2)
    evalOp :
      (A : Set) (n : Nat) ->
      QuasiGroup A ->
      Vec A n ->
      OpQuasiGroupTerm n -> A
    evalOp _ n Qu vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Qu vars (opOL
                        x1
                        x2) =
      op Qu (evalOp _ n Qu vars x1)
        (evalOp _ n Qu vars x2)
    evalOp _ n Qu vars (linvOL
                        x1
                        x2) =
      linv Qu (evalOp _ n Qu vars x1)
        (evalOp _ n Qu vars x2)
    evalOp _ n Qu vars (rinvOL
                        x1
                        x2) =
      rinv Qu (evalOp _ n Qu vars x1)
        (evalOp _ n Qu vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      QuasiGroup A ->
      Vec A n ->
      OpQuasiGroupTerm2 n A -> A
    evalOpE _ n Qu vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Qu vars (sing2 x1) =
      x1
    evalOpE _ n Qu vars (opOL2
                         x1
                         x2) =
      op Qu (evalOpE _ n Qu vars x1)
        (evalOpE _ n Qu vars x2)
    evalOpE _ n Qu vars (linvOL2
                         x1
                         x2) =
      linv Qu (evalOpE _ n Qu vars x1)
        (evalOpE _ n Qu vars x2)
    evalOpE _ n Qu vars (rinvOL2
                         x1
                         x2) =
      rinv Qu (evalOpE _ n Qu vars x1)
        (evalOpE _ n Qu vars x2)
    inductionB :
      (P : QuasiGroupTerm -> Set) ->
      ((x1 : QuasiGroupTerm)
       (x2 : QuasiGroupTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      ((x1 : QuasiGroupTerm)
       (x2 : QuasiGroupTerm) ->
       P x1 ->
       P x2 -> P (linvL x1 x2)) ->
      ((x1 : QuasiGroupTerm)
       (x2 : QuasiGroupTerm) ->
       P x1 ->
       P x2 -> P (rinvL x1 x2)) ->
      (x : QuasiGroupTerm) -> P x
    inductionB p popl plinvl prinvl (opL
                                     x1
                                     x2) =
      popl _ _
        (inductionB p popl plinvl prinvl
           x1)
        (inductionB p popl plinvl prinvl
           x2)
    inductionB p popl plinvl prinvl (linvL
                                     x1
                                     x2) =
      plinvl _ _
        (inductionB p popl plinvl prinvl
           x1)
        (inductionB p popl plinvl prinvl
           x2)
    inductionB p popl plinvl prinvl (rinvL
                                     x1
                                     x2) =
      prinvl _ _
        (inductionB p popl plinvl prinvl
           x1)
        (inductionB p popl plinvl prinvl
           x2)
    inductionCl :
      (A : Set)
      (P : ClQuasiGroupTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClQuasiGroupTerm A)
       (x2 : ClQuasiGroupTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      ((x1 : ClQuasiGroupTerm A)
       (x2 : ClQuasiGroupTerm A) ->
       P x1 ->
       P x2 -> P (linvCl x1 x2)) ->
      ((x1 : ClQuasiGroupTerm A)
       (x2 : ClQuasiGroupTerm A) ->
       P x1 ->
       P x2 -> P (rinvCl x1 x2)) ->
      (x : ClQuasiGroupTerm A) -> P x
    inductionCl _ p psing popcl plinvcl prinvcl (sing
                                                 x1) = psing x1
    inductionCl _ p psing popcl plinvcl prinvcl (opCl
                                                 x1
                                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl
           plinvcl
           prinvcl
           x1)
        (inductionCl _ p psing popcl
           plinvcl
           prinvcl
           x2)
    inductionCl _ p psing popcl plinvcl prinvcl (linvCl
                                                 x1
                                                 x2) =
      plinvcl _ _
        (inductionCl _ p psing popcl
           plinvcl
           prinvcl
           x1)
        (inductionCl _ p psing popcl
           plinvcl
           prinvcl
           x2)
    inductionCl _ p psing popcl plinvcl prinvcl (rinvCl
                                                 x1
                                                 x2) =
      prinvcl _ _
        (inductionCl _ p psing popcl
           plinvcl
           prinvcl
           x1)
        (inductionCl _ p psing popcl
           plinvcl
           prinvcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpQuasiGroupTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpQuasiGroupTerm n)
       (x2 : OpQuasiGroupTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      ((x1 : OpQuasiGroupTerm n)
       (x2 : OpQuasiGroupTerm n) ->
       P x1 ->
       P x2 -> P (linvOL x1 x2)) ->
      ((x1 : OpQuasiGroupTerm n)
       (x2 : OpQuasiGroupTerm n) ->
       P x1 ->
       P x2 -> P (rinvOL x1 x2)) ->
      (x : OpQuasiGroupTerm n) -> P x
    inductionOp _ p pv popol plinvol prinvol (v
                                              x1) = pv x1
    inductionOp _ p pv popol plinvol prinvol (opOL
                                              x1
                                              x2) =
      popol _ _
        (inductionOp _ p pv popol
           plinvol
           prinvol
           x1)
        (inductionOp _ p pv popol
           plinvol
           prinvol
           x2)
    inductionOp _ p pv popol plinvol prinvol (linvOL
                                              x1
                                              x2) =
      plinvol _ _
        (inductionOp _ p pv popol
           plinvol
           prinvol
           x1)
        (inductionOp _ p pv popol
           plinvol
           prinvol
           x2)
    inductionOp _ p pv popol plinvol prinvol (rinvOL
                                              x1
                                              x2) =
      prinvol _ _
        (inductionOp _ p pv popol
           plinvol
           prinvol
           x1)
        (inductionOp _ p pv popol
           plinvol
           prinvol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpQuasiGroupTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpQuasiGroupTerm2 n A)
       (x2 : OpQuasiGroupTerm2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      ((x1 : OpQuasiGroupTerm2 n A)
       (x2 : OpQuasiGroupTerm2 n A) ->
       P x1 ->
       P x2 -> P (linvOL2 x1 x2)) ->
      ((x1 : OpQuasiGroupTerm2 n A)
       (x2 : OpQuasiGroupTerm2 n A) ->
       P x1 ->
       P x2 -> P (rinvOL2 x1 x2)) ->
      (x : OpQuasiGroupTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 prinvol2 (v2
                                                            x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 prinvol2 (sing2
                                                            x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 prinvol2 (opOL2
                                                            x1
                                                            x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           prinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           prinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 prinvol2 (linvOL2
                                                            x1
                                                            x2) =
      plinvol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           prinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           prinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 plinvol2 prinvol2 (rinvOL2
                                                            x1
                                                            x2) =
      prinvol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           prinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           plinvol2
           prinvol2
           x2)
    opL' :
      QuasiGroupTerm ->
      QuasiGroupTerm -> QuasiGroupTerm
    opL' x1 x2 = opL x1 x2
    linvL' :
      QuasiGroupTerm ->
      QuasiGroupTerm -> QuasiGroupTerm
    linvL' x1 x2 = linvL x1 x2
    rinvL' :
      QuasiGroupTerm ->
      QuasiGroupTerm -> QuasiGroupTerm
    rinvL' x1 x2 = rinvL x1 x2
    stageB :
      QuasiGroupTerm ->
      Staged QuasiGroupTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (linvL x1 x2) =
      stage2 _ _ _ linvL'
        (codeLift2 _ _ _ linvL')
        (stageB x1)
        (stageB x2)
    stageB (rinvL x1 x2) =
      stage2 _ _ _ rinvL'
        (codeLift2 _ _ _ rinvL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClQuasiGroupTerm A ->
      ClQuasiGroupTerm A ->
      ClQuasiGroupTerm A
    opCl' _ x1 x2 = opCl x1 x2
    linvCl' :
      (A : Set) ->
      ClQuasiGroupTerm A ->
      ClQuasiGroupTerm A ->
      ClQuasiGroupTerm A
    linvCl' _ x1 x2 = linvCl x1 x2
    rinvCl' :
      (A : Set) ->
      ClQuasiGroupTerm A ->
      ClQuasiGroupTerm A ->
      ClQuasiGroupTerm A
    rinvCl' _ x1 x2 = rinvCl x1 x2
    stageCl :
      (A : Set) ->
      ClQuasiGroupTerm A ->
      Staged (ClQuasiGroupTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (linvCl x1 x2) =
      stage2 _ _ _ (linvCl' _)
        (codeLift2 _ _ _ (linvCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (rinvCl x1 x2) =
      stage2 _ _ _ (rinvCl' _)
        (codeLift2 _ _ _ (rinvCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpQuasiGroupTerm n ->
      OpQuasiGroupTerm n ->
      OpQuasiGroupTerm n
    opOL' _ x1 x2 = opOL x1 x2
    linvOL' :
      (n : Nat) ->
      OpQuasiGroupTerm n ->
      OpQuasiGroupTerm n ->
      OpQuasiGroupTerm n
    linvOL' _ x1 x2 = linvOL x1 x2
    rinvOL' :
      (n : Nat) ->
      OpQuasiGroupTerm n ->
      OpQuasiGroupTerm n ->
      OpQuasiGroupTerm n
    rinvOL' _ x1 x2 = rinvOL x1 x2
    stageOp :
      (n : Nat) ->
      OpQuasiGroupTerm n ->
      Staged (OpQuasiGroupTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (linvOL x1 x2) =
      stage2 _ _ _ (linvOL' _)
        (codeLift2 _ _ _ (linvOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (rinvOL x1 x2) =
      stage2 _ _ _ (rinvOL' _)
        (codeLift2 _ _ _ (rinvOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpQuasiGroupTerm2 n A ->
      OpQuasiGroupTerm2 n A ->
      OpQuasiGroupTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    linvOL2' :
      (n : Nat) (A : Set) ->
      OpQuasiGroupTerm2 n A ->
      OpQuasiGroupTerm2 n A ->
      OpQuasiGroupTerm2 n A
    linvOL2' _ _ x1 x2 =
      linvOL2 x1 x2
    rinvOL2' :
      (n : Nat) (A : Set) ->
      OpQuasiGroupTerm2 n A ->
      OpQuasiGroupTerm2 n A ->
      OpQuasiGroupTerm2 n A
    rinvOL2' _ _ x1 x2 =
      rinvOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpQuasiGroupTerm2 n A ->
      Staged (OpQuasiGroupTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (linvOL2 x1 x2) =
      stage2 _ _ _ (linvOL2' _ _)
        (codeLift2 _ _ _ (linvOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (rinvOL2 x1 x2) =
      stage2 _ _ _ (rinvOL2' _ _)
        (codeLift2 _ _ _ (rinvOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record QuasiGroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
        linvT :
          Repr A -> Repr A -> Repr A
        rinvT :
          Repr A -> Repr A -> Repr A
  
  module QuasiInverse where
    record QuasiInverse
      (A : Set) : Set where
      constructor QuasiInverseC
      field
        inv : A -> A
        op : A -> A -> A
        quasiInverse_inv_op_e :
          (x : A) ->
          op (op x (inv x)) x == x
        quasiRightInverse_inv_op_e :
          (x : A) ->
          op (op (inv x) x) (inv x) ==
            inv x
    record QuasiInverseSig
      (AS : Set) : Set where
      constructor QuasiInverseSigSigC
      field
        invS : AS -> AS
        opS : AS -> AS -> AS
    record QuasiInverseProd
      (AP : Set) : Set where
      constructor QuasiInverseProdC
      field
        invP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        quasiInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (opP xP (invP xP)) xP == xP
        quasiRightInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (opP (invP xP) xP)
            (invP xP) == invP xP
    record QuasiInverseHom
      (A1 : Set) (A2 : Set)
      (Qu1 : QuasiInverse A1)
      (Qu2 : QuasiInverse A2) :
      Set where
      constructor QuasiInverseHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv Qu1 x1) ==
            inv Qu2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Qu1 x1 x2) ==
            op Qu2 (hom x1) (hom x2)
    record QuasiInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Qu1 : QuasiInverse A1)
      (Qu2 : QuasiInverse A2) :
      Set where
      constructor QuasiInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Qu1 x1) (inv Qu2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Qu1 x1 x2)
            (op Qu2 y1 y2)
    data QuasiInverseTerm
      : Set where
      invL :
        QuasiInverseTerm ->
        QuasiInverseTerm
      opL :
        QuasiInverseTerm ->
        QuasiInverseTerm ->
        QuasiInverseTerm
    data ClQuasiInverseTerm
      (A : Set) : Set where
      sing :
        A -> ClQuasiInverseTerm A
      invCl :
        ClQuasiInverseTerm A ->
        ClQuasiInverseTerm A
      opCl :
        ClQuasiInverseTerm A ->
        ClQuasiInverseTerm A ->
        ClQuasiInverseTerm A
    data OpQuasiInverseTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpQuasiInverseTerm n
      invOL :
        OpQuasiInverseTerm n ->
        OpQuasiInverseTerm n
      opOL :
        OpQuasiInverseTerm n ->
        OpQuasiInverseTerm n ->
        OpQuasiInverseTerm n
    data OpQuasiInverseTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpQuasiInverseTerm2 n A
      sing2 :
        A -> OpQuasiInverseTerm2 n A
      invOL2 :
        OpQuasiInverseTerm2 n A ->
        OpQuasiInverseTerm2 n A
      opOL2 :
        OpQuasiInverseTerm2 n A ->
        OpQuasiInverseTerm2 n A ->
        OpQuasiInverseTerm2 n A
    simplifyB :
      QuasiInverseTerm ->
      QuasiInverseTerm
    simplifyB (opL
               (opL x (invL x))
               x) = x
    simplifyB (opL
               (opL (invL x) x)
               (invL x)) = invL x
    simplifyB (invL x1) =
      invL (simplifyB x1)
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClQuasiInverseTerm A ->
      ClQuasiInverseTerm A
    simplifyCl _ (opCl
                  (opCl x (invCl x))
                  x) = x
    simplifyCl _ (opCl
                  (opCl (invCl x) x)
                  (invCl x)) = invCl x
    simplifyCl _ (invCl x1) =
      invCl (simplifyCl _ x1)
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpQuasiInverseTerm n ->
      OpQuasiInverseTerm n
    simplifyOp _ (opOL
                  (opOL x (invOL x))
                  x) = x
    simplifyOp _ (opOL
                  (opOL (invOL x) x)
                  (invOL x)) = invOL x
    simplifyOp _ (invOL x1) =
      invOL (simplifyOp _ x1)
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpQuasiInverseTerm2 n A ->
      OpQuasiInverseTerm2 n A
    simplifyOpE _ _ (opOL2
                     (opOL2 x (invOL2 x))
                     x) = x
    simplifyOpE _ _ (opOL2
                     (opOL2 (invOL2 x) x)
                     (invOL2 x)) = invOL2 x
    simplifyOpE _ _ (invOL2 x1) =
      invOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      QuasiInverse A ->
      QuasiInverseTerm -> A
    evalB _ Qu (invL x1) =
      inv Qu (evalB _ Qu x1)
    evalB _ Qu (opL x1 x2) =
      op Qu (evalB _ Qu x1)
        (evalB _ Qu x2)
    evalCl :
      (A : Set) ->
      QuasiInverse A ->
      ClQuasiInverseTerm A -> A
    evalCl _ Qu (sing x1) = x1
    evalCl _ Qu (invCl x1) =
      inv Qu (evalCl _ Qu x1)
    evalCl _ Qu (opCl x1 x2) =
      op Qu (evalCl _ Qu x1)
        (evalCl _ Qu x2)
    evalOp :
      (A : Set) (n : Nat) ->
      QuasiInverse A ->
      Vec A n ->
      OpQuasiInverseTerm n -> A
    evalOp _ n Qu vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Qu vars (invOL x1) =
      inv Qu (evalOp _ n Qu vars x1)
    evalOp _ n Qu vars (opOL
                        x1
                        x2) =
      op Qu (evalOp _ n Qu vars x1)
        (evalOp _ n Qu vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      QuasiInverse A ->
      Vec A n ->
      OpQuasiInverseTerm2 n A -> A
    evalOpE _ n Qu vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Qu vars (sing2 x1) =
      x1
    evalOpE _ n Qu vars (invOL2
                         x1) =
      inv Qu (evalOpE _ n Qu vars x1)
    evalOpE _ n Qu vars (opOL2
                         x1
                         x2) =
      op Qu (evalOpE _ n Qu vars x1)
        (evalOpE _ n Qu vars x2)
    inductionB :
      (P : QuasiInverseTerm -> Set) ->
      ((x1 : QuasiInverseTerm) ->
       P x1 -> P (invL x1)) ->
      ((x1 : QuasiInverseTerm)
       (x2 : QuasiInverseTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : QuasiInverseTerm) -> P x
    inductionB p pinvl popl (invL
                             x1) =
      pinvl _
        (inductionB p pinvl popl x1)
    inductionB p pinvl popl (opL
                             x1
                             x2) =
      popl _ _
        (inductionB p pinvl popl x1)
        (inductionB p pinvl popl x2)
    inductionCl :
      (A : Set)
      (P : ClQuasiInverseTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClQuasiInverseTerm A) ->
       P x1 -> P (invCl x1)) ->
      ((x1 : ClQuasiInverseTerm A)
       (x2 : ClQuasiInverseTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClQuasiInverseTerm A) ->
      P x
    inductionCl _ p psing pinvcl popcl (sing
                                        x1) = psing x1
    inductionCl _ p psing pinvcl popcl (invCl
                                        x1) =
      pinvcl _
        (inductionCl _ p psing pinvcl
           popcl
           x1)
    inductionCl _ p psing pinvcl popcl (opCl
                                        x1
                                        x2) =
      popcl _ _
        (inductionCl _ p psing pinvcl
           popcl
           x1)
        (inductionCl _ p psing pinvcl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpQuasiInverseTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpQuasiInverseTerm n) ->
       P x1 -> P (invOL x1)) ->
      ((x1 : OpQuasiInverseTerm n)
       (x2 : OpQuasiInverseTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpQuasiInverseTerm n) ->
      P x
    inductionOp _ p pv pinvol popol (v
                                     x1) = pv x1
    inductionOp _ p pv pinvol popol (invOL
                                     x1) =
      pinvol _
        (inductionOp _ p pv pinvol popol
           x1)
    inductionOp _ p pv pinvol popol (opOL
                                     x1
                                     x2) =
      popol _ _
        (inductionOp _ p pv pinvol popol
           x1)
        (inductionOp _ p pv pinvol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpQuasiInverseTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpQuasiInverseTerm2 n
          A) -> P x1 -> P (invOL2 x1)) ->
      ((x1 : OpQuasiInverseTerm2 n A)
       (x2 : OpQuasiInverseTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpQuasiInverseTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 pinvol2 popol2 (v2
                                                  x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pinvol2 popol2 (sing2
                                                  x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pinvol2 popol2 (invOL2
                                                  x1) =
      pinvol2 _
        (inductionOpE _ _ p pv2 psing2
           pinvol2
           popol2
           x1)
    inductionOpE _ _ p pv2 psing2 pinvol2 popol2 (opOL2
                                                  x1
                                                  x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           pinvol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           pinvol2
           popol2
           x2)
    invL' :
      QuasiInverseTerm ->
      QuasiInverseTerm
    invL' x1 = invL x1
    opL' :
      QuasiInverseTerm ->
      QuasiInverseTerm ->
      QuasiInverseTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      QuasiInverseTerm ->
      Staged QuasiInverseTerm
    stageB (invL x1) =
      stage1 _ _ invL'
        (codeLift1 _ _ invL')
        (stageB x1)
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    invCl' :
      (A : Set) ->
      ClQuasiInverseTerm A ->
      ClQuasiInverseTerm A
    invCl' _ x1 = invCl x1
    opCl' :
      (A : Set) ->
      ClQuasiInverseTerm A ->
      ClQuasiInverseTerm A ->
      ClQuasiInverseTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClQuasiInverseTerm A ->
      Staged (ClQuasiInverseTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (invCl x1) =
      stage1 _ _ (invCl' _)
        (codeLift1 _ _ (invCl' _))
        (stageCl _ x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    invOL' :
      (n : Nat) ->
      OpQuasiInverseTerm n ->
      OpQuasiInverseTerm n
    invOL' _ x1 = invOL x1
    opOL' :
      (n : Nat) ->
      OpQuasiInverseTerm n ->
      OpQuasiInverseTerm n ->
      OpQuasiInverseTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpQuasiInverseTerm n ->
      Staged (OpQuasiInverseTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (invOL x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (stageOp _ x1)
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    invOL2' :
      (n : Nat) (A : Set) ->
      OpQuasiInverseTerm2 n A ->
      OpQuasiInverseTerm2 n A
    invOL2' _ _ x1 = invOL2 x1
    opOL2' :
      (n : Nat) (A : Set) ->
      OpQuasiInverseTerm2 n A ->
      OpQuasiInverseTerm2 n A ->
      OpQuasiInverseTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpQuasiInverseTerm2 n A ->
      Staged (OpQuasiInverseTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (invOL2 x1) =
      stage1 _ _ (invOL2' _ _)
        (codeLift1 _ _ (invOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record QuasiInverseTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        invT : Repr A -> Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module Rack where
    record Rack
      (A : Set) : Set where
      constructor RackC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
        leftInverse :
          (x : A) (y : A) ->
          <| (|> x y) x == y
        rightInverse :
          (x : A) (y : A) ->
          |> x (<| y x) == y
    record RackSig
      (AS : Set) : Set where
      constructor RackSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record RackProd
      (AP : Set) : Set where
      constructor RackProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
        leftInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          <|P (|>P xP yP) xP == yP
        rightInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          |>P xP (<|P yP xP) == yP
    record RackHom
      (A1 : Set) (A2 : Set)
      (Ra1 : Rack A1)
      (Ra2 : Rack A2) : Set where
      constructor RackHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ra1 x1 x2) ==
            |> Ra2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ra1 x1 x2) ==
            <| Ra2 (hom x1) (hom x2)
    record RackRelInterp
      (A1 : Set) (A2 : Set)
      (Ra1 : Rack A1)
      (Ra2 : Rack A2) : Set where
      constructor RackRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ra1 x1 x2)
            (|> Ra2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ra1 x1 x2)
            (<| Ra2 y1 y2)
    data RackTerm : Set where
      |>L :
        RackTerm -> RackTerm -> RackTerm
      <|L :
        RackTerm -> RackTerm -> RackTerm
    data ClRackTerm
      (A : Set) : Set where
      sing : A -> ClRackTerm A
      |>Cl :
        ClRackTerm A ->
        ClRackTerm A -> ClRackTerm A
      <|Cl :
        ClRackTerm A ->
        ClRackTerm A -> ClRackTerm A
    data OpRackTerm
      (n : Nat) : Set where
      v : Fin n -> OpRackTerm n
      |>OL :
        OpRackTerm n ->
        OpRackTerm n -> OpRackTerm n
      <|OL :
        OpRackTerm n ->
        OpRackTerm n -> OpRackTerm n
    data OpRackTerm2
      (n : Nat) (A : Set) : Set where
      v2 : Fin n -> OpRackTerm2 n A
      sing2 : A -> OpRackTerm2 n A
      |>OL2 :
        OpRackTerm2 n A ->
        OpRackTerm2 n A ->
        OpRackTerm2 n A
      <|OL2 :
        OpRackTerm2 n A ->
        OpRackTerm2 n A ->
        OpRackTerm2 n A
    simplifyB : RackTerm -> RackTerm
    simplifyB (|>L
               (|>L x y)
               (|>L x z)) = |>L x (|>L y z)
    simplifyB (<|L
               (<|L y x)
               (<|L z x)) = <|L (<|L y z) x
    simplifyB (<|L (|>L x y) x) = y
    simplifyB (|>L x (<|L y x)) = y
    simplifyB (|>L x1 x2) =
      |>L (simplifyB x1)
        (simplifyB x2)
    simplifyB (<|L x1 x2) =
      <|L (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRackTerm A -> ClRackTerm A
    simplifyCl _ (|>Cl
                  (|>Cl x y)
                  (|>Cl x z)) = |>Cl x (|>Cl y z)
    simplifyCl _ (<|Cl
                  (<|Cl y x)
                  (<|Cl z x)) = <|Cl (<|Cl y z) x
    simplifyCl _ (<|Cl
                  (|>Cl x y)
                  x) = y
    simplifyCl _ (|>Cl
                  x
                  (<|Cl y x)) = y
    simplifyCl _ (|>Cl x1 x2) =
      |>Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (<|Cl x1 x2) =
      <|Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRackTerm n -> OpRackTerm n
    simplifyOp _ (|>OL
                  (|>OL x y)
                  (|>OL x z)) = |>OL x (|>OL y z)
    simplifyOp _ (<|OL
                  (<|OL y x)
                  (<|OL z x)) = <|OL (<|OL y z) x
    simplifyOp _ (<|OL
                  (|>OL x y)
                  x) = y
    simplifyOp _ (|>OL
                  x
                  (<|OL y x)) = y
    simplifyOp _ (|>OL x1 x2) =
      |>OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (<|OL x1 x2) =
      <|OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRackTerm2 n A ->
      OpRackTerm2 n A
    simplifyOpE _ _ (|>OL2
                     (|>OL2 x y)
                     (|>OL2 x z)) =
      |>OL2 x (|>OL2 y z)
    simplifyOpE _ _ (<|OL2
                     (<|OL2 y x)
                     (<|OL2 z x)) =
      <|OL2 (<|OL2 y z) x
    simplifyOpE _ _ (<|OL2
                     (|>OL2 x y)
                     x) = y
    simplifyOpE _ _ (|>OL2
                     x
                     (<|OL2 y x)) = y
    simplifyOpE _ _ (|>OL2 x1 x2) =
      |>OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (<|OL2 x1 x2) =
      <|OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Rack A -> RackTerm -> A
    evalB _ Ra (|>L x1 x2) =
      |> Ra (evalB _ Ra x1)
        (evalB _ Ra x2)
    evalB _ Ra (<|L x1 x2) =
      <| Ra (evalB _ Ra x1)
        (evalB _ Ra x2)
    evalCl :
      (A : Set) ->
      Rack A -> ClRackTerm A -> A
    evalCl _ Ra (sing x1) = x1
    evalCl _ Ra (|>Cl x1 x2) =
      |> Ra (evalCl _ Ra x1)
        (evalCl _ Ra x2)
    evalCl _ Ra (<|Cl x1 x2) =
      <| Ra (evalCl _ Ra x1)
        (evalCl _ Ra x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Rack A ->
      Vec A n -> OpRackTerm n -> A
    evalOp _ n Ra vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ra vars (|>OL
                        x1
                        x2) =
      |> Ra (evalOp _ n Ra vars x1)
        (evalOp _ n Ra vars x2)
    evalOp _ n Ra vars (<|OL
                        x1
                        x2) =
      <| Ra (evalOp _ n Ra vars x1)
        (evalOp _ n Ra vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Rack A ->
      Vec A n -> OpRackTerm2 n A -> A
    evalOpE _ n Ra vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ra vars (sing2 x1) =
      x1
    evalOpE _ n Ra vars (|>OL2
                         x1
                         x2) =
      |> Ra (evalOpE _ n Ra vars x1)
        (evalOpE _ n Ra vars x2)
    evalOpE _ n Ra vars (<|OL2
                         x1
                         x2) =
      <| Ra (evalOpE _ n Ra vars x1)
        (evalOpE _ n Ra vars x2)
    inductionB :
      (P : RackTerm -> Set) ->
      ((x1 : RackTerm)
       (x2 : RackTerm) ->
       P x1 ->
       P x2 -> P (|>L x1 x2)) ->
      ((x1 : RackTerm)
       (x2 : RackTerm) ->
       P x1 ->
       P x2 -> P (<|L x1 x2)) ->
      (x : RackTerm) -> P x
    inductionB p p|>l p<|l (|>L
                            x1
                            x2) =
      p|>l _ _
        (inductionB p p|>l p<|l x1)
        (inductionB p p|>l p<|l x2)
    inductionB p p|>l p<|l (<|L
                            x1
                            x2) =
      p<|l _ _
        (inductionB p p|>l p<|l x1)
        (inductionB p p|>l p<|l x2)
    inductionCl :
      (A : Set)
      (P : ClRackTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRackTerm A)
       (x2 : ClRackTerm A) ->
       P x1 ->
       P x2 -> P (|>Cl x1 x2)) ->
      ((x1 : ClRackTerm A)
       (x2 : ClRackTerm A) ->
       P x1 ->
       P x2 -> P (<|Cl x1 x2)) ->
      (x : ClRackTerm A) -> P x
    inductionCl _ p psing p|>cl p<|cl (sing
                                       x1) = psing x1
    inductionCl _ p psing p|>cl p<|cl (|>Cl
                                       x1
                                       x2) =
      p|>cl _ _
        (inductionCl _ p psing p|>cl
           p<|cl
           x1)
        (inductionCl _ p psing p|>cl
           p<|cl
           x2)
    inductionCl _ p psing p|>cl p<|cl (<|Cl
                                       x1
                                       x2) =
      p<|cl _ _
        (inductionCl _ p psing p|>cl
           p<|cl
           x1)
        (inductionCl _ p psing p|>cl
           p<|cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpRackTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRackTerm n)
       (x2 : OpRackTerm n) ->
       P x1 ->
       P x2 -> P (|>OL x1 x2)) ->
      ((x1 : OpRackTerm n)
       (x2 : OpRackTerm n) ->
       P x1 ->
       P x2 -> P (<|OL x1 x2)) ->
      (x : OpRackTerm n) -> P x
    inductionOp _ p pv p|>ol p<|ol (v
                                    x1) = pv x1
    inductionOp _ p pv p|>ol p<|ol (|>OL
                                    x1
                                    x2) =
      p|>ol _ _
        (inductionOp _ p pv p|>ol p<|ol
           x1)
        (inductionOp _ p pv p|>ol p<|ol
           x2)
    inductionOp _ p pv p|>ol p<|ol (<|OL
                                    x1
                                    x2) =
      p<|ol _ _
        (inductionOp _ p pv p|>ol p<|ol
           x1)
        (inductionOp _ p pv p|>ol p<|ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRackTerm2 n A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRackTerm2 n A)
       (x2 : OpRackTerm2 n A) ->
       P x1 ->
       P x2 -> P (|>OL2 x1 x2)) ->
      ((x1 : OpRackTerm2 n A)
       (x2 : OpRackTerm2 n A) ->
       P x1 ->
       P x2 -> P (<|OL2 x1 x2)) ->
      (x : OpRackTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (v2
                                                 x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (sing2
                                                 x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (|>OL2
                                                 x1
                                                 x2) =
      p|>ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (<|OL2
                                                 x1
                                                 x2) =
      p<|ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x2)
    |>L' :
      RackTerm -> RackTerm -> RackTerm
    |>L' x1 x2 = |>L x1 x2
    <|L' :
      RackTerm -> RackTerm -> RackTerm
    <|L' x1 x2 = <|L x1 x2
    stageB :
      RackTerm -> Staged RackTerm
    stageB (|>L x1 x2) =
      stage2 _ _ _ |>L'
        (codeLift2 _ _ _ |>L')
        (stageB x1)
        (stageB x2)
    stageB (<|L x1 x2) =
      stage2 _ _ _ <|L'
        (codeLift2 _ _ _ <|L')
        (stageB x1)
        (stageB x2)
    |>Cl' :
      (A : Set) ->
      ClRackTerm A ->
      ClRackTerm A -> ClRackTerm A
    |>Cl' _ x1 x2 = |>Cl x1 x2
    <|Cl' :
      (A : Set) ->
      ClRackTerm A ->
      ClRackTerm A -> ClRackTerm A
    <|Cl' _ x1 x2 = <|Cl x1 x2
    stageCl :
      (A : Set) ->
      ClRackTerm A ->
      Staged (ClRackTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (|>Cl x1 x2) =
      stage2 _ _ _ (|>Cl' _)
        (codeLift2 _ _ _ (|>Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (<|Cl x1 x2) =
      stage2 _ _ _ (<|Cl' _)
        (codeLift2 _ _ _ (<|Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    |>OL' :
      (n : Nat) ->
      OpRackTerm n ->
      OpRackTerm n -> OpRackTerm n
    |>OL' _ x1 x2 = |>OL x1 x2
    <|OL' :
      (n : Nat) ->
      OpRackTerm n ->
      OpRackTerm n -> OpRackTerm n
    <|OL' _ x1 x2 = <|OL x1 x2
    stageOp :
      (n : Nat) ->
      OpRackTerm n ->
      Staged (OpRackTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (|>OL x1 x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (<|OL x1 x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    |>OL2' :
      (n : Nat) (A : Set) ->
      OpRackTerm2 n A ->
      OpRackTerm2 n A ->
      OpRackTerm2 n A
    |>OL2' _ _ x1 x2 = |>OL2 x1 x2
    <|OL2' :
      (n : Nat) (A : Set) ->
      OpRackTerm2 n A ->
      OpRackTerm2 n A ->
      OpRackTerm2 n A
    <|OL2' _ _ x1 x2 = <|OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRackTerm2 n A ->
      Staged (OpRackTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (|>OL2 x1 x2) =
      stage2 _ _ _ (|>OL2' _ _)
        (codeLift2 _ _ _ (|>OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (<|OL2 x1 x2) =
      stage2 _ _ _ (<|OL2' _ _)
        (codeLift2 _ _ _ (<|OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RackTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        |>T : Repr A -> Repr A -> Repr A
        <|T : Repr A -> Repr A -> Repr A
  
  module RectangularBand where
    record RectangularBand
      (A : Set) : Set where
      constructor RectangularBandC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        idempotent_op :
          (x : A) -> op x x == x
        middleCommute_* :
          (x : A) (y : A) (z : A) ->
          op (op (op x y) z) x ==
            op (op (op x z) y) x
    record RectangularBandSig
      (AS : Set) : Set where
      constructor RectangularBandSigSigC
      field
        opS : AS -> AS -> AS
    record RectangularBandProd
      (AP : Set) : Set where
      constructor RectangularBandProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        idempotent_opP :
          (xP : Prod AP AP) ->
          opP xP xP == xP
        middleCommute_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP (opP xP yP) zP) xP ==
            opP (opP (opP xP zP) yP) xP
    record RectangularBandHom
      (A1 : Set) (A2 : Set)
      (Re1 : RectangularBand A1)
      (Re2 : RectangularBand A2) :
      Set where
      constructor RectangularBandHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Re1 x1 x2) ==
            op Re2 (hom x1) (hom x2)
    record RectangularBandRelInterp
      (A1 : Set) (A2 : Set)
      (Re1 : RectangularBand A1)
      (Re2 : RectangularBand A2) :
      Set where
      constructor RectangularBandRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Re1 x1 x2)
            (op Re2 y1 y2)
    data RectangularBandTerm
      : Set where
      opL :
        RectangularBandTerm ->
        RectangularBandTerm ->
        RectangularBandTerm
    data ClRectangularBandTerm
      (A : Set) : Set where
      sing :
        A -> ClRectangularBandTerm A
      opCl :
        ClRectangularBandTerm A ->
        ClRectangularBandTerm A ->
        ClRectangularBandTerm A
    data OpRectangularBandTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpRectangularBandTerm n
      opOL :
        OpRectangularBandTerm n ->
        OpRectangularBandTerm n ->
        OpRectangularBandTerm n
    data OpRectangularBandTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpRectangularBandTerm2 n A
      sing2 :
        A -> OpRectangularBandTerm2 n A
      opOL2 :
        OpRectangularBandTerm2 n A ->
        OpRectangularBandTerm2 n A ->
        OpRectangularBandTerm2 n A
    simplifyB :
      RectangularBandTerm ->
      RectangularBandTerm
    simplifyB (opL x x) = x
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRectangularBandTerm A ->
      ClRectangularBandTerm A
    simplifyCl _ (opCl x x) = x
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRectangularBandTerm n ->
      OpRectangularBandTerm n
    simplifyOp _ (opOL x x) = x
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRectangularBandTerm2 n A ->
      OpRectangularBandTerm2 n A
    simplifyOpE _ _ (opOL2 x x) = x
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RectangularBand A ->
      RectangularBandTerm -> A
    evalB _ Re (opL x1 x2) =
      op Re (evalB _ Re x1)
        (evalB _ Re x2)
    evalCl :
      (A : Set) ->
      RectangularBand A ->
      ClRectangularBandTerm A -> A
    evalCl _ Re (sing x1) = x1
    evalCl _ Re (opCl x1 x2) =
      op Re (evalCl _ Re x1)
        (evalCl _ Re x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RectangularBand A ->
      Vec A n ->
      OpRectangularBandTerm n -> A
    evalOp _ n Re vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Re vars (opOL
                        x1
                        x2) =
      op Re (evalOp _ n Re vars x1)
        (evalOp _ n Re vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RectangularBand A ->
      Vec A n ->
      OpRectangularBandTerm2 n A -> A
    evalOpE _ n Re vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Re vars (sing2 x1) =
      x1
    evalOpE _ n Re vars (opOL2
                         x1
                         x2) =
      op Re (evalOpE _ n Re vars x1)
        (evalOpE _ n Re vars x2)
    inductionB :
      (P : RectangularBandTerm ->
           Set) ->
      ((x1 : RectangularBandTerm)
       (x2 : RectangularBandTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : RectangularBandTerm) -> P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClRectangularBandTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRectangularBandTerm A)
       (x2 : ClRectangularBandTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClRectangularBandTerm A) ->
      P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpRectangularBandTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRectangularBandTerm n)
       (x2 : OpRectangularBandTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpRectangularBandTerm n) ->
      P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRectangularBandTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRectangularBandTerm2 n
          A)
       (x2 : OpRectangularBandTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpRectangularBandTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      RectangularBandTerm ->
      RectangularBandTerm ->
      RectangularBandTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      RectangularBandTerm ->
      Staged RectangularBandTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClRectangularBandTerm A ->
      ClRectangularBandTerm A ->
      ClRectangularBandTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClRectangularBandTerm A ->
      Staged (ClRectangularBandTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpRectangularBandTerm n ->
      OpRectangularBandTerm n ->
      OpRectangularBandTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpRectangularBandTerm n ->
      Staged (OpRectangularBandTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpRectangularBandTerm2 n A ->
      OpRectangularBandTerm2 n A ->
      OpRectangularBandTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRectangularBandTerm2 n A ->
      Staged
        (OpRectangularBandTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RectangularBandTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module RegularSemigroup where
    record RegularSemigroup
      (A : Set) : Set where
      constructor RegularSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        inv : A -> A
        quasiInverse_inv_op_e :
          (x : A) ->
          op (op x (inv x)) x == x
    record RegularSemigroupSig
      (AS : Set) : Set where
      constructor RegularSemigroupSigSigC
      field
        opS : AS -> AS -> AS
        invS : AS -> AS
    record RegularSemigroupProd
      (AP : Set) : Set where
      constructor RegularSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        invP : Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        quasiInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (opP xP (invP xP)) xP == xP
    record RegularSemigroupHom
      (A1 : Set) (A2 : Set)
      (Re1 : RegularSemigroup A1)
      (Re2 : RegularSemigroup A2) :
      Set where
      constructor RegularSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Re1 x1 x2) ==
            op Re2 (hom x1) (hom x2)
        pres-inv :
          (x1 : A1) ->
          hom (inv Re1 x1) ==
            inv Re2 (hom x1)
    record RegularSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Re1 : RegularSemigroup A1)
      (Re2 : RegularSemigroup A2) :
      Set where
      constructor RegularSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Re1 x1 x2)
            (op Re2 y1 y2)
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Re1 x1) (inv Re2 y1)
    data RegularSemigroupTerm
      : Set where
      opL :
        RegularSemigroupTerm ->
        RegularSemigroupTerm ->
        RegularSemigroupTerm
      invL :
        RegularSemigroupTerm ->
        RegularSemigroupTerm
    data ClRegularSemigroupTerm
      (A : Set) : Set where
      sing :
        A -> ClRegularSemigroupTerm A
      opCl :
        ClRegularSemigroupTerm A ->
        ClRegularSemigroupTerm A ->
        ClRegularSemigroupTerm A
      invCl :
        ClRegularSemigroupTerm A ->
        ClRegularSemigroupTerm A
    data OpRegularSemigroupTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpRegularSemigroupTerm n
      opOL :
        OpRegularSemigroupTerm n ->
        OpRegularSemigroupTerm n ->
        OpRegularSemigroupTerm n
      invOL :
        OpRegularSemigroupTerm n ->
        OpRegularSemigroupTerm n
    data OpRegularSemigroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpRegularSemigroupTerm2 n A
      sing2 :
        A -> OpRegularSemigroupTerm2 n A
      opOL2 :
        OpRegularSemigroupTerm2 n A ->
        OpRegularSemigroupTerm2 n A ->
        OpRegularSemigroupTerm2 n A
      invOL2 :
        OpRegularSemigroupTerm2 n A ->
        OpRegularSemigroupTerm2 n A
    simplifyB :
      RegularSemigroupTerm ->
      RegularSemigroupTerm
    simplifyB (opL
               (opL x (invL x))
               x) = x
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (invL x1) =
      invL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClRegularSemigroupTerm A ->
      ClRegularSemigroupTerm A
    simplifyCl _ (opCl
                  (opCl x (invCl x))
                  x) = x
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (invCl x1) =
      invCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRegularSemigroupTerm n ->
      OpRegularSemigroupTerm n
    simplifyOp _ (opOL
                  (opOL x (invOL x))
                  x) = x
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (invOL x1) =
      invOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRegularSemigroupTerm2 n A ->
      OpRegularSemigroupTerm2 n A
    simplifyOpE _ _ (opOL2
                     (opOL2 x (invOL2 x))
                     x) = x
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (invOL2 x1) =
      invOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RegularSemigroup A ->
      RegularSemigroupTerm -> A
    evalB _ Re (opL x1 x2) =
      op Re (evalB _ Re x1)
        (evalB _ Re x2)
    evalB _ Re (invL x1) =
      inv Re (evalB _ Re x1)
    evalCl :
      (A : Set) ->
      RegularSemigroup A ->
      ClRegularSemigroupTerm A -> A
    evalCl _ Re (sing x1) = x1
    evalCl _ Re (opCl x1 x2) =
      op Re (evalCl _ Re x1)
        (evalCl _ Re x2)
    evalCl _ Re (invCl x1) =
      inv Re (evalCl _ Re x1)
    evalOp :
      (A : Set) (n : Nat) ->
      RegularSemigroup A ->
      Vec A n ->
      OpRegularSemigroupTerm n -> A
    evalOp _ n Re vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Re vars (opOL
                        x1
                        x2) =
      op Re (evalOp _ n Re vars x1)
        (evalOp _ n Re vars x2)
    evalOp _ n Re vars (invOL x1) =
      inv Re (evalOp _ n Re vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      RegularSemigroup A ->
      Vec A n ->
      OpRegularSemigroupTerm2 n A -> A
    evalOpE _ n Re vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Re vars (sing2 x1) =
      x1
    evalOpE _ n Re vars (opOL2
                         x1
                         x2) =
      op Re (evalOpE _ n Re vars x1)
        (evalOpE _ n Re vars x2)
    evalOpE _ n Re vars (invOL2
                         x1) =
      inv Re (evalOpE _ n Re vars x1)
    inductionB :
      (P : RegularSemigroupTerm ->
           Set) ->
      ((x1 : RegularSemigroupTerm)
       (x2 : RegularSemigroupTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      ((x1 : RegularSemigroupTerm) ->
       P x1 -> P (invL x1)) ->
      (x : RegularSemigroupTerm) ->
      P x
    inductionB p popl pinvl (opL
                             x1
                             x2) =
      popl _ _
        (inductionB p popl pinvl x1)
        (inductionB p popl pinvl x2)
    inductionB p popl pinvl (invL
                             x1) =
      pinvl _
        (inductionB p popl pinvl x1)
    inductionCl :
      (A : Set)
      (P : ClRegularSemigroupTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRegularSemigroupTerm A)
       (x2 : ClRegularSemigroupTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      ((x1 : ClRegularSemigroupTerm
          A) -> P x1 -> P (invCl x1)) ->
      (x : ClRegularSemigroupTerm
         A) -> P x
    inductionCl _ p psing popcl pinvcl (sing
                                        x1) = psing x1
    inductionCl _ p psing popcl pinvcl (opCl
                                        x1
                                        x2) =
      popcl _ _
        (inductionCl _ p psing popcl
           pinvcl
           x1)
        (inductionCl _ p psing popcl
           pinvcl
           x2)
    inductionCl _ p psing popcl pinvcl (invCl
                                        x1) =
      pinvcl _
        (inductionCl _ p psing popcl
           pinvcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpRegularSemigroupTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRegularSemigroupTerm n)
       (x2 : OpRegularSemigroupTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      ((x1 : OpRegularSemigroupTerm
          n) -> P x1 -> P (invOL x1)) ->
      (x : OpRegularSemigroupTerm
         n) -> P x
    inductionOp _ p pv popol pinvol (v
                                     x1) = pv x1
    inductionOp _ p pv popol pinvol (opOL
                                     x1
                                     x2) =
      popol _ _
        (inductionOp _ p pv popol pinvol
           x1)
        (inductionOp _ p pv popol pinvol
           x2)
    inductionOp _ p pv popol pinvol (invOL
                                     x1) =
      pinvol _
        (inductionOp _ p pv popol pinvol
           x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRegularSemigroupTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRegularSemigroupTerm2 n
          A)
       (x2 : OpRegularSemigroupTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      ((x1 : OpRegularSemigroupTerm2 n
          A) -> P x1 -> P (invOL2 x1)) ->
      (x : OpRegularSemigroupTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 pinvol2 (v2
                                                  x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 pinvol2 (sing2
                                                  x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 pinvol2 (opOL2
                                                  x1
                                                  x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           pinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           pinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 pinvol2 (invOL2
                                                  x1) =
      pinvol2 _
        (inductionOpE _ _ p pv2 psing2
           popol2
           pinvol2
           x1)
    opL' :
      RegularSemigroupTerm ->
      RegularSemigroupTerm ->
      RegularSemigroupTerm
    opL' x1 x2 = opL x1 x2
    invL' :
      RegularSemigroupTerm ->
      RegularSemigroupTerm
    invL' x1 = invL x1
    stageB :
      RegularSemigroupTerm ->
      Staged RegularSemigroupTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (invL x1) =
      stage1 _ _ invL'
        (codeLift1 _ _ invL')
        (stageB x1)
    opCl' :
      (A : Set) ->
      ClRegularSemigroupTerm A ->
      ClRegularSemigroupTerm A ->
      ClRegularSemigroupTerm A
    opCl' _ x1 x2 = opCl x1 x2
    invCl' :
      (A : Set) ->
      ClRegularSemigroupTerm A ->
      ClRegularSemigroupTerm A
    invCl' _ x1 = invCl x1
    stageCl :
      (A : Set) ->
      ClRegularSemigroupTerm A ->
      Staged
        (ClRegularSemigroupTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (invCl x1) =
      stage1 _ _ (invCl' _)
        (codeLift1 _ _ (invCl' _))
        (stageCl _ x1)
    opOL' :
      (n : Nat) ->
      OpRegularSemigroupTerm n ->
      OpRegularSemigroupTerm n ->
      OpRegularSemigroupTerm n
    opOL' _ x1 x2 = opOL x1 x2
    invOL' :
      (n : Nat) ->
      OpRegularSemigroupTerm n ->
      OpRegularSemigroupTerm n
    invOL' _ x1 = invOL x1
    stageOp :
      (n : Nat) ->
      OpRegularSemigroupTerm n ->
      Staged
        (OpRegularSemigroupTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (invOL x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (stageOp _ x1)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpRegularSemigroupTerm2 n A ->
      OpRegularSemigroupTerm2 n A ->
      OpRegularSemigroupTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    invOL2' :
      (n : Nat) (A : Set) ->
      OpRegularSemigroupTerm2 n A ->
      OpRegularSemigroupTerm2 n A
    invOL2' _ _ x1 = invOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRegularSemigroupTerm2 n A ->
      Staged
        (OpRegularSemigroupTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (invOL2 x1) =
      stage1 _ _ (invOL2' _ _)
        (codeLift1 _ _ (invOL2' _ _))
        (stageOpE _ _ x1)
    record RegularSemigroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
        invT : Repr A -> Repr A
  
  module Right0 where
    record Right0
      (A : Set) : Set where
      constructor Right0C
      field
        0 : A
        op : A -> A -> A
        rightZero_op_0 :
          (x : A) -> op x 0 == 0
    record Right0Sig
      (AS : Set) : Set where
      constructor Right0SigSigC
      field
        0S : AS
        opS : AS -> AS -> AS
    record Right0Prod
      (AP : Set) : Set where
      constructor Right0ProdC
      field
        0P : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          opP xP 0P == 0P
    record Right0Hom
      (A1 : Set) (A2 : Set)
      (Ri1 : Right0 A1)
      (Ri2 : Right0 A2) : Set where
      constructor Right0HomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ri1) == 0 Ri2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record Right0RelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Right0 A1)
      (Ri2 : Right0 A2) : Set where
      constructor Right0RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ri1) (0 Ri2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data Right0LTerm : Set where
      0L : Right0LTerm
      opL :
        Right0LTerm ->
        Right0LTerm -> Right0LTerm
    data ClRight0ClTerm
      (A : Set) : Set where
      sing : A -> ClRight0ClTerm A
      0Cl : ClRight0ClTerm A
      opCl :
        ClRight0ClTerm A ->
        ClRight0ClTerm A ->
        ClRight0ClTerm A
    data OpRight0OLTerm
      (n : Nat) : Set where
      v : Fin n -> OpRight0OLTerm n
      0OL : OpRight0OLTerm n
      opOL :
        OpRight0OLTerm n ->
        OpRight0OLTerm n ->
        OpRight0OLTerm n
    data OpRight0OL2Term2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpRight0OL2Term2 n A
      sing2 :
        A -> OpRight0OL2Term2 n A
      0OL2 : OpRight0OL2Term2 n A
      opOL2 :
        OpRight0OL2Term2 n A ->
        OpRight0OL2Term2 n A ->
        OpRight0OL2Term2 n A
    simplifyB :
      Right0LTerm -> Right0LTerm
    simplifyB (opL x (0L)) = 0L
    simplifyB (0L) = 0L
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRight0ClTerm A ->
      ClRight0ClTerm A
    simplifyCl _ (opCl x (0Cl)) =
      0Cl
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRight0OLTerm n ->
      OpRight0OLTerm n
    simplifyOp _ (opOL x (0OL)) =
      0OL
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRight0OL2Term2 n A ->
      OpRight0OL2Term2 n A
    simplifyOpE _ _ (opOL2
                     x
                     (0OL2)) = 0OL2
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Right0 A -> Right0LTerm -> A
    evalB _ Ri (0L) = 0 Ri
    evalB _ Ri (opL x1 x2) =
      op Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      Right0 A ->
      ClRight0ClTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (0Cl) = 0 Ri
    evalCl _ Ri (opCl x1 x2) =
      op Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Right0 A ->
      Vec A n -> OpRight0OLTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (0OL) = 0 Ri
    evalOp _ n Ri vars (opOL
                        x1
                        x2) =
      op Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Right0 A ->
      Vec A n ->
      OpRight0OL2Term2 n A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (0OL2) =
      0 Ri
    evalOpE _ n Ri vars (opOL2
                         x1
                         x2) =
      op Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : Right0LTerm -> Set) ->
      P 0L ->
      ((x1 : Right0LTerm)
       (x2 : Right0LTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : Right0LTerm) -> P x
    inductionB p p0l popl (0L) = p0l
    inductionB p p0l popl (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p p0l popl x1)
        (inductionB p p0l popl x2)
    inductionCl :
      (A : Set)
      (P : ClRight0ClTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 0Cl ->
      ((x1 : ClRight0ClTerm A)
       (x2 : ClRight0ClTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClRight0ClTerm A) -> P x
    inductionCl _ p psing p0cl popcl (sing
                                      x1) = psing x1
    inductionCl _ p psing p0cl popcl (0Cl) =
      p0cl
    inductionCl _ p psing p0cl popcl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing p0cl
           popcl
           x1)
        (inductionCl _ p psing p0cl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpRight0OLTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 0OL ->
      ((x1 : OpRight0OLTerm n)
       (x2 : OpRight0OLTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpRight0OLTerm n) -> P x
    inductionOp _ p pv p0ol popol (v
                                   x1) = pv x1
    inductionOp _ p pv p0ol popol (0OL) =
      p0ol
    inductionOp _ p pv p0ol popol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv p0ol popol
           x1)
        (inductionOp _ p pv p0ol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRight0OL2Term2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 0OL2 ->
      ((x1 : OpRight0OL2Term2 n A)
       (x2 : OpRight0OL2Term2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpRight0OL2Term2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p0ol2 popol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 popol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 popol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p0ol2 popol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           popol2
           x2)
    0L' : Right0LTerm
    0L' = 0L
    opL' :
      Right0LTerm ->
      Right0LTerm -> Right0LTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      Right0LTerm ->
      Staged Right0LTerm
    stageB (0L) = Now 0L
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    0Cl' :
      (A : Set) -> ClRight0ClTerm A
    0Cl' _ = 0Cl
    opCl' :
      (A : Set) ->
      ClRight0ClTerm A ->
      ClRight0ClTerm A ->
      ClRight0ClTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClRight0ClTerm A ->
      Staged (ClRight0ClTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    0OL' :
      (n : Nat) -> OpRight0OLTerm n
    0OL' _ = 0OL
    opOL' :
      (n : Nat) ->
      OpRight0OLTerm n ->
      OpRight0OLTerm n ->
      OpRight0OLTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpRight0OLTerm n ->
      Staged (OpRight0OLTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (0OL) = Now 0OL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    0OL2' :
      (n : Nat) (A : Set) ->
      OpRight0OL2Term2 n A
    0OL2' _ _ = 0OL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpRight0OL2Term2 n A ->
      OpRight0OL2Term2 n A ->
      OpRight0OL2Term2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRight0OL2Term2 n A ->
      Staged (OpRight0OL2Term2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record Right0Tagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        0T : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module RightBiMagma where
    record RightBiMagma
      (A : Set) : Set where
      constructor RightBiMagmaC
      field
        op : A -> A -> A
        rinv : A -> A -> A
    record RightBiMagmaSig
      (AS : Set) : Set where
      constructor RightBiMagmaSigSigC
      field
        opS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record RightBiMagmaProd
      (AP : Set) : Set where
      constructor RightBiMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record RightBiMagmaHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightBiMagma A1)
      (Ri2 : RightBiMagma A2) :
      Set where
      constructor RightBiMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Ri1 x1 x2) ==
            rinv Ri2 (hom x1) (hom x2)
    record RightBiMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightBiMagma A1)
      (Ri2 : RightBiMagma A2) :
      Set where
      constructor RightBiMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Ri1 x1 x2)
            (rinv Ri2 y1 y2)
    data RightBiMagmaTerm
      : Set where
      opL :
        RightBiMagmaTerm ->
        RightBiMagmaTerm ->
        RightBiMagmaTerm
      rinvL :
        RightBiMagmaTerm ->
        RightBiMagmaTerm ->
        RightBiMagmaTerm
    data ClRightBiMagmaTerm
      (A : Set) : Set where
      sing :
        A -> ClRightBiMagmaTerm A
      opCl :
        ClRightBiMagmaTerm A ->
        ClRightBiMagmaTerm A ->
        ClRightBiMagmaTerm A
      rinvCl :
        ClRightBiMagmaTerm A ->
        ClRightBiMagmaTerm A ->
        ClRightBiMagmaTerm A
    data OpRightBiMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpRightBiMagmaTerm n
      opOL :
        OpRightBiMagmaTerm n ->
        OpRightBiMagmaTerm n ->
        OpRightBiMagmaTerm n
      rinvOL :
        OpRightBiMagmaTerm n ->
        OpRightBiMagmaTerm n ->
        OpRightBiMagmaTerm n
    data OpRightBiMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpRightBiMagmaTerm2 n A
      sing2 :
        A -> OpRightBiMagmaTerm2 n A
      opOL2 :
        OpRightBiMagmaTerm2 n A ->
        OpRightBiMagmaTerm2 n A ->
        OpRightBiMagmaTerm2 n A
      rinvOL2 :
        OpRightBiMagmaTerm2 n A ->
        OpRightBiMagmaTerm2 n A ->
        OpRightBiMagmaTerm2 n A
    simplifyB :
      RightBiMagmaTerm ->
      RightBiMagmaTerm
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (rinvL x1 x2) =
      rinvL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRightBiMagmaTerm A ->
      ClRightBiMagmaTerm A
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (rinvCl x1 x2) =
      rinvCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRightBiMagmaTerm n ->
      OpRightBiMagmaTerm n
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (rinvOL x1 x2) =
      rinvOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRightBiMagmaTerm2 n A ->
      OpRightBiMagmaTerm2 n A
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (rinvOL2
                     x1
                     x2) =
      rinvOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RightBiMagma A ->
      RightBiMagmaTerm -> A
    evalB _ Ri (opL x1 x2) =
      op Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalB _ Ri (rinvL x1 x2) =
      rinv Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      RightBiMagma A ->
      ClRightBiMagmaTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (opCl x1 x2) =
      op Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalCl _ Ri (rinvCl x1 x2) =
      rinv Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RightBiMagma A ->
      Vec A n ->
      OpRightBiMagmaTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (opOL
                        x1
                        x2) =
      op Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOp _ n Ri vars (rinvOL
                        x1
                        x2) =
      rinv Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RightBiMagma A ->
      Vec A n ->
      OpRightBiMagmaTerm2 n A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (opOL2
                         x1
                         x2) =
      op Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    evalOpE _ n Ri vars (rinvOL2
                         x1
                         x2) =
      rinv Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RightBiMagmaTerm -> Set) ->
      ((x1 : RightBiMagmaTerm)
       (x2 : RightBiMagmaTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      ((x1 : RightBiMagmaTerm)
       (x2 : RightBiMagmaTerm) ->
       P x1 ->
       P x2 -> P (rinvL x1 x2)) ->
      (x : RightBiMagmaTerm) -> P x
    inductionB p popl prinvl (opL
                              x1
                              x2) =
      popl _ _
        (inductionB p popl prinvl x1)
        (inductionB p popl prinvl x2)
    inductionB p popl prinvl (rinvL
                              x1
                              x2) =
      prinvl _ _
        (inductionB p popl prinvl x1)
        (inductionB p popl prinvl x2)
    inductionCl :
      (A : Set)
      (P : ClRightBiMagmaTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRightBiMagmaTerm A)
       (x2 : ClRightBiMagmaTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      ((x1 : ClRightBiMagmaTerm A)
       (x2 : ClRightBiMagmaTerm A) ->
       P x1 ->
       P x2 -> P (rinvCl x1 x2)) ->
      (x : ClRightBiMagmaTerm A) ->
      P x
    inductionCl _ p psing popcl prinvcl (sing
                                         x1) = psing x1
    inductionCl _ p psing popcl prinvcl (opCl
                                         x1
                                         x2) =
      popcl _ _
        (inductionCl _ p psing popcl
           prinvcl
           x1)
        (inductionCl _ p psing popcl
           prinvcl
           x2)
    inductionCl _ p psing popcl prinvcl (rinvCl
                                         x1
                                         x2) =
      prinvcl _ _
        (inductionCl _ p psing popcl
           prinvcl
           x1)
        (inductionCl _ p psing popcl
           prinvcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpRightBiMagmaTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRightBiMagmaTerm n)
       (x2 : OpRightBiMagmaTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      ((x1 : OpRightBiMagmaTerm n)
       (x2 : OpRightBiMagmaTerm n) ->
       P x1 ->
       P x2 -> P (rinvOL x1 x2)) ->
      (x : OpRightBiMagmaTerm n) ->
      P x
    inductionOp _ p pv popol prinvol (v
                                      x1) = pv x1
    inductionOp _ p pv popol prinvol (opOL
                                      x1
                                      x2) =
      popol _ _
        (inductionOp _ p pv popol
           prinvol
           x1)
        (inductionOp _ p pv popol
           prinvol
           x2)
    inductionOp _ p pv popol prinvol (rinvOL
                                      x1
                                      x2) =
      prinvol _ _
        (inductionOp _ p pv popol
           prinvol
           x1)
        (inductionOp _ p pv popol
           prinvol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRightBiMagmaTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRightBiMagmaTerm2 n A)
       (x2 : OpRightBiMagmaTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      ((x1 : OpRightBiMagmaTerm2 n A)
       (x2 : OpRightBiMagmaTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (rinvOL2 x1 x2)) ->
      (x : OpRightBiMagmaTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 popol2 prinvol2 (v2
                                                   x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 prinvol2 (sing2
                                                   x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 prinvol2 (opOL2
                                                   x1
                                                   x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           prinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           prinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 prinvol2 (rinvOL2
                                                   x1
                                                   x2) =
      prinvol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           prinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           prinvol2
           x2)
    opL' :
      RightBiMagmaTerm ->
      RightBiMagmaTerm ->
      RightBiMagmaTerm
    opL' x1 x2 = opL x1 x2
    rinvL' :
      RightBiMagmaTerm ->
      RightBiMagmaTerm ->
      RightBiMagmaTerm
    rinvL' x1 x2 = rinvL x1 x2
    stageB :
      RightBiMagmaTerm ->
      Staged RightBiMagmaTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (rinvL x1 x2) =
      stage2 _ _ _ rinvL'
        (codeLift2 _ _ _ rinvL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClRightBiMagmaTerm A ->
      ClRightBiMagmaTerm A ->
      ClRightBiMagmaTerm A
    opCl' _ x1 x2 = opCl x1 x2
    rinvCl' :
      (A : Set) ->
      ClRightBiMagmaTerm A ->
      ClRightBiMagmaTerm A ->
      ClRightBiMagmaTerm A
    rinvCl' _ x1 x2 = rinvCl x1 x2
    stageCl :
      (A : Set) ->
      ClRightBiMagmaTerm A ->
      Staged (ClRightBiMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (rinvCl x1 x2) =
      stage2 _ _ _ (rinvCl' _)
        (codeLift2 _ _ _ (rinvCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpRightBiMagmaTerm n ->
      OpRightBiMagmaTerm n ->
      OpRightBiMagmaTerm n
    opOL' _ x1 x2 = opOL x1 x2
    rinvOL' :
      (n : Nat) ->
      OpRightBiMagmaTerm n ->
      OpRightBiMagmaTerm n ->
      OpRightBiMagmaTerm n
    rinvOL' _ x1 x2 = rinvOL x1 x2
    stageOp :
      (n : Nat) ->
      OpRightBiMagmaTerm n ->
      Staged (OpRightBiMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (rinvOL x1 x2) =
      stage2 _ _ _ (rinvOL' _)
        (codeLift2 _ _ _ (rinvOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpRightBiMagmaTerm2 n A ->
      OpRightBiMagmaTerm2 n A ->
      OpRightBiMagmaTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    rinvOL2' :
      (n : Nat) (A : Set) ->
      OpRightBiMagmaTerm2 n A ->
      OpRightBiMagmaTerm2 n A ->
      OpRightBiMagmaTerm2 n A
    rinvOL2' _ _ x1 x2 =
      rinvOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRightBiMagmaTerm2 n A ->
      Staged (OpRightBiMagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (rinvOL2 x1 x2) =
      stage2 _ _ _ (rinvOL2' _ _)
        (codeLift2 _ _ _ (rinvOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RightBiMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
        rinvT :
          Repr A -> Repr A -> Repr A
  
  module RightBinaryInverse where
    record RightBinaryInverse
      (A : Set) : Set where
      constructor RightBinaryInverseC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        rightInverse :
          (x : A) (y : A) ->
          |> x (<| y x) == y
    record RightBinaryInverseSig
      (AS : Set) : Set where
      constructor RightBinaryInverseSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record RightBinaryInverseProd
      (AP : Set) : Set where
      constructor RightBinaryInverseProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightInverseP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          |>P xP (<|P yP xP) == yP
    record RightBinaryInverseHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightBinaryInverse A1)
      (Ri2 : RightBinaryInverse A2) :
      Set where
      constructor RightBinaryInverseHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ri1 x1 x2) ==
            |> Ri2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
    record RightBinaryInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightBinaryInverse A1)
      (Ri2 : RightBinaryInverse A2) :
      Set where
      constructor RightBinaryInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ri1 x1 x2)
            (|> Ri2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
    data RightBinaryInverseTerm
      : Set where
      |>L :
        RightBinaryInverseTerm ->
        RightBinaryInverseTerm ->
        RightBinaryInverseTerm
      <|L :
        RightBinaryInverseTerm ->
        RightBinaryInverseTerm ->
        RightBinaryInverseTerm
    data ClRightBinaryInverseTerm
      (A : Set) : Set where
      sing :
        A -> ClRightBinaryInverseTerm A
      |>Cl :
        ClRightBinaryInverseTerm A ->
        ClRightBinaryInverseTerm A ->
        ClRightBinaryInverseTerm A
      <|Cl :
        ClRightBinaryInverseTerm A ->
        ClRightBinaryInverseTerm A ->
        ClRightBinaryInverseTerm A
    data OpRightBinaryInverseTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpRightBinaryInverseTerm n
      |>OL :
        OpRightBinaryInverseTerm n ->
        OpRightBinaryInverseTerm n ->
        OpRightBinaryInverseTerm n
      <|OL :
        OpRightBinaryInverseTerm n ->
        OpRightBinaryInverseTerm n ->
        OpRightBinaryInverseTerm n
    data OpRightBinaryInverseTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpRightBinaryInverseTerm2 n A
      sing2 :
        A ->
        OpRightBinaryInverseTerm2 n A
      |>OL2 :
        OpRightBinaryInverseTerm2 n A ->
        OpRightBinaryInverseTerm2 n A ->
        OpRightBinaryInverseTerm2 n A
      <|OL2 :
        OpRightBinaryInverseTerm2 n A ->
        OpRightBinaryInverseTerm2 n A ->
        OpRightBinaryInverseTerm2 n A
    simplifyB :
      RightBinaryInverseTerm ->
      RightBinaryInverseTerm
    simplifyB (|>L x (<|L y x)) = y
    simplifyB (|>L x1 x2) =
      |>L (simplifyB x1)
        (simplifyB x2)
    simplifyB (<|L x1 x2) =
      <|L (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRightBinaryInverseTerm A ->
      ClRightBinaryInverseTerm A
    simplifyCl _ (|>Cl
                  x
                  (<|Cl y x)) = y
    simplifyCl _ (|>Cl x1 x2) =
      |>Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (<|Cl x1 x2) =
      <|Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRightBinaryInverseTerm n ->
      OpRightBinaryInverseTerm n
    simplifyOp _ (|>OL
                  x
                  (<|OL y x)) = y
    simplifyOp _ (|>OL x1 x2) =
      |>OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (<|OL x1 x2) =
      <|OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRightBinaryInverseTerm2 n A ->
      OpRightBinaryInverseTerm2 n A
    simplifyOpE _ _ (|>OL2
                     x
                     (<|OL2 y x)) = y
    simplifyOpE _ _ (|>OL2 x1 x2) =
      |>OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (<|OL2 x1 x2) =
      <|OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RightBinaryInverse A ->
      RightBinaryInverseTerm -> A
    evalB _ Ri (|>L x1 x2) =
      |> Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalB _ Ri (<|L x1 x2) =
      <| Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      RightBinaryInverse A ->
      ClRightBinaryInverseTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (|>Cl x1 x2) =
      |> Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalCl _ Ri (<|Cl x1 x2) =
      <| Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RightBinaryInverse A ->
      Vec A n ->
      OpRightBinaryInverseTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (|>OL
                        x1
                        x2) =
      |> Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOp _ n Ri vars (<|OL
                        x1
                        x2) =
      <| Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RightBinaryInverse A ->
      Vec A n ->
      OpRightBinaryInverseTerm2 n A ->
      A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (|>OL2
                         x1
                         x2) =
      |> Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    evalOpE _ n Ri vars (<|OL2
                         x1
                         x2) =
      <| Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RightBinaryInverseTerm ->
           Set) ->
      ((x1 : RightBinaryInverseTerm)
       (x2 : RightBinaryInverseTerm) ->
       P x1 ->
       P x2 -> P (|>L x1 x2)) ->
      ((x1 : RightBinaryInverseTerm)
       (x2 : RightBinaryInverseTerm) ->
       P x1 ->
       P x2 -> P (<|L x1 x2)) ->
      (x : RightBinaryInverseTerm) ->
      P x
    inductionB p p|>l p<|l (|>L
                            x1
                            x2) =
      p|>l _ _
        (inductionB p p|>l p<|l x1)
        (inductionB p p|>l p<|l x2)
    inductionB p p|>l p<|l (<|L
                            x1
                            x2) =
      p<|l _ _
        (inductionB p p|>l p<|l x1)
        (inductionB p p|>l p<|l x2)
    inductionCl :
      (A : Set)
      (P : ClRightBinaryInverseTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRightBinaryInverseTerm
          A)
       (x2 : ClRightBinaryInverseTerm
          A) ->
       P x1 ->
       P x2 -> P (|>Cl x1 x2)) ->
      ((x1 : ClRightBinaryInverseTerm
          A)
       (x2 : ClRightBinaryInverseTerm
          A) ->
       P x1 ->
       P x2 -> P (<|Cl x1 x2)) ->
      (x : ClRightBinaryInverseTerm
         A) -> P x
    inductionCl _ p psing p|>cl p<|cl (sing
                                       x1) = psing x1
    inductionCl _ p psing p|>cl p<|cl (|>Cl
                                       x1
                                       x2) =
      p|>cl _ _
        (inductionCl _ p psing p|>cl
           p<|cl
           x1)
        (inductionCl _ p psing p|>cl
           p<|cl
           x2)
    inductionCl _ p psing p|>cl p<|cl (<|Cl
                                       x1
                                       x2) =
      p<|cl _ _
        (inductionCl _ p psing p|>cl
           p<|cl
           x1)
        (inductionCl _ p psing p|>cl
           p<|cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpRightBinaryInverseTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRightBinaryInverseTerm
          n)
       (x2 : OpRightBinaryInverseTerm
          n) ->
       P x1 ->
       P x2 -> P (|>OL x1 x2)) ->
      ((x1 : OpRightBinaryInverseTerm
          n)
       (x2 : OpRightBinaryInverseTerm
          n) ->
       P x1 ->
       P x2 -> P (<|OL x1 x2)) ->
      (x : OpRightBinaryInverseTerm
         n) -> P x
    inductionOp _ p pv p|>ol p<|ol (v
                                    x1) = pv x1
    inductionOp _ p pv p|>ol p<|ol (|>OL
                                    x1
                                    x2) =
      p|>ol _ _
        (inductionOp _ p pv p|>ol p<|ol
           x1)
        (inductionOp _ p pv p|>ol p<|ol
           x2)
    inductionOp _ p pv p|>ol p<|ol (<|OL
                                    x1
                                    x2) =
      p<|ol _ _
        (inductionOp _ p pv p|>ol p<|ol
           x1)
        (inductionOp _ p pv p|>ol p<|ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRightBinaryInverseTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRightBinaryInverseTerm2
          n
          A)
       (x2 : OpRightBinaryInverseTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (|>OL2 x1 x2)) ->
      ((x1 : OpRightBinaryInverseTerm2
          n
          A)
       (x2 : OpRightBinaryInverseTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (<|OL2 x1 x2)) ->
      (x : OpRightBinaryInverseTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (v2
                                                 x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (sing2
                                                 x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (|>OL2
                                                 x1
                                                 x2) =
      p|>ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (<|OL2
                                                 x1
                                                 x2) =
      p<|ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x2)
    |>L' :
      RightBinaryInverseTerm ->
      RightBinaryInverseTerm ->
      RightBinaryInverseTerm
    |>L' x1 x2 = |>L x1 x2
    <|L' :
      RightBinaryInverseTerm ->
      RightBinaryInverseTerm ->
      RightBinaryInverseTerm
    <|L' x1 x2 = <|L x1 x2
    stageB :
      RightBinaryInverseTerm ->
      Staged RightBinaryInverseTerm
    stageB (|>L x1 x2) =
      stage2 _ _ _ |>L'
        (codeLift2 _ _ _ |>L')
        (stageB x1)
        (stageB x2)
    stageB (<|L x1 x2) =
      stage2 _ _ _ <|L'
        (codeLift2 _ _ _ <|L')
        (stageB x1)
        (stageB x2)
    |>Cl' :
      (A : Set) ->
      ClRightBinaryInverseTerm A ->
      ClRightBinaryInverseTerm A ->
      ClRightBinaryInverseTerm A
    |>Cl' _ x1 x2 = |>Cl x1 x2
    <|Cl' :
      (A : Set) ->
      ClRightBinaryInverseTerm A ->
      ClRightBinaryInverseTerm A ->
      ClRightBinaryInverseTerm A
    <|Cl' _ x1 x2 = <|Cl x1 x2
    stageCl :
      (A : Set) ->
      ClRightBinaryInverseTerm A ->
      Staged
        (ClRightBinaryInverseTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (|>Cl x1 x2) =
      stage2 _ _ _ (|>Cl' _)
        (codeLift2 _ _ _ (|>Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (<|Cl x1 x2) =
      stage2 _ _ _ (<|Cl' _)
        (codeLift2 _ _ _ (<|Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    |>OL' :
      (n : Nat) ->
      OpRightBinaryInverseTerm n ->
      OpRightBinaryInverseTerm n ->
      OpRightBinaryInverseTerm n
    |>OL' _ x1 x2 = |>OL x1 x2
    <|OL' :
      (n : Nat) ->
      OpRightBinaryInverseTerm n ->
      OpRightBinaryInverseTerm n ->
      OpRightBinaryInverseTerm n
    <|OL' _ x1 x2 = <|OL x1 x2
    stageOp :
      (n : Nat) ->
      OpRightBinaryInverseTerm n ->
      Staged
        (OpRightBinaryInverseTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (|>OL x1 x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (<|OL x1 x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    |>OL2' :
      (n : Nat) (A : Set) ->
      OpRightBinaryInverseTerm2 n A ->
      OpRightBinaryInverseTerm2 n A ->
      OpRightBinaryInverseTerm2 n A
    |>OL2' _ _ x1 x2 = |>OL2 x1 x2
    <|OL2' :
      (n : Nat) (A : Set) ->
      OpRightBinaryInverseTerm2 n A ->
      OpRightBinaryInverseTerm2 n A ->
      OpRightBinaryInverseTerm2 n A
    <|OL2' _ _ x1 x2 = <|OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRightBinaryInverseTerm2 n A ->
      Staged
        (OpRightBinaryInverseTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (|>OL2 x1 x2) =
      stage2 _ _ _ (|>OL2' _ _)
        (codeLift2 _ _ _ (|>OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (<|OL2 x1 x2) =
      stage2 _ _ _ (<|OL2' _ _)
        (codeLift2 _ _ _ (<|OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RightBinaryInverseTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        |>T : Repr A -> Repr A -> Repr A
        <|T : Repr A -> Repr A -> Repr A
  
  module RightCancellative where
    record RightCancellative
      (A : Set) : Set where
      constructor RightCancellativeC
      field
        op : A -> A -> A
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
    record RightCancellativeSig
      (AS : Set) : Set where
      constructor RightCancellativeSigSigC
      field
        opS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record RightCancellativeProd
      (AP : Set) : Set where
      constructor RightCancellativeProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
    record RightCancellativeHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellative A1)
      (Ri2 : RightCancellative A2) :
      Set where
      constructor RightCancellativeHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Ri1 x1 x2) ==
            rinv Ri2 (hom x1) (hom x2)
    record RightCancellativeRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellative A1)
      (Ri2 : RightCancellative A2) :
      Set where
      constructor RightCancellativeRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Ri1 x1 x2)
            (rinv Ri2 y1 y2)
    data RightCancellativeTerm
      : Set where
      opL :
        RightCancellativeTerm ->
        RightCancellativeTerm ->
        RightCancellativeTerm
      rinvL :
        RightCancellativeTerm ->
        RightCancellativeTerm ->
        RightCancellativeTerm
    data ClRightCancellativeTerm
      (A : Set) : Set where
      sing :
        A -> ClRightCancellativeTerm A
      opCl :
        ClRightCancellativeTerm A ->
        ClRightCancellativeTerm A ->
        ClRightCancellativeTerm A
      rinvCl :
        ClRightCancellativeTerm A ->
        ClRightCancellativeTerm A ->
        ClRightCancellativeTerm A
    data OpRightCancellativeTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpRightCancellativeTerm n
      opOL :
        OpRightCancellativeTerm n ->
        OpRightCancellativeTerm n ->
        OpRightCancellativeTerm n
      rinvOL :
        OpRightCancellativeTerm n ->
        OpRightCancellativeTerm n ->
        OpRightCancellativeTerm n
    data OpRightCancellativeTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpRightCancellativeTerm2 n A
      sing2 :
        A ->
        OpRightCancellativeTerm2 n A
      opOL2 :
        OpRightCancellativeTerm2 n A ->
        OpRightCancellativeTerm2 n A ->
        OpRightCancellativeTerm2 n A
      rinvOL2 :
        OpRightCancellativeTerm2 n A ->
        OpRightCancellativeTerm2 n A ->
        OpRightCancellativeTerm2 n A
    simplifyB :
      RightCancellativeTerm ->
      RightCancellativeTerm
    simplifyB (opL (rinvL y x) x) =
      y
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (rinvL x1 x2) =
      rinvL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRightCancellativeTerm A ->
      ClRightCancellativeTerm A
    simplifyCl _ (opCl
                  (rinvCl y x)
                  x) = y
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (rinvCl x1 x2) =
      rinvCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRightCancellativeTerm n ->
      OpRightCancellativeTerm n
    simplifyOp _ (opOL
                  (rinvOL y x)
                  x) = y
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (rinvOL x1 x2) =
      rinvOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRightCancellativeTerm2 n A ->
      OpRightCancellativeTerm2 n A
    simplifyOpE _ _ (opOL2
                     (rinvOL2 y x)
                     x) = y
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (rinvOL2
                     x1
                     x2) =
      rinvOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RightCancellative A ->
      RightCancellativeTerm -> A
    evalB _ Ri (opL x1 x2) =
      op Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalB _ Ri (rinvL x1 x2) =
      rinv Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      RightCancellative A ->
      ClRightCancellativeTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (opCl x1 x2) =
      op Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalCl _ Ri (rinvCl x1 x2) =
      rinv Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RightCancellative A ->
      Vec A n ->
      OpRightCancellativeTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (opOL
                        x1
                        x2) =
      op Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOp _ n Ri vars (rinvOL
                        x1
                        x2) =
      rinv Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RightCancellative A ->
      Vec A n ->
      OpRightCancellativeTerm2 n A ->
      A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (opOL2
                         x1
                         x2) =
      op Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    evalOpE _ n Ri vars (rinvOL2
                         x1
                         x2) =
      rinv Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RightCancellativeTerm ->
           Set) ->
      ((x1 : RightCancellativeTerm)
       (x2 : RightCancellativeTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      ((x1 : RightCancellativeTerm)
       (x2 : RightCancellativeTerm) ->
       P x1 ->
       P x2 -> P (rinvL x1 x2)) ->
      (x : RightCancellativeTerm) ->
      P x
    inductionB p popl prinvl (opL
                              x1
                              x2) =
      popl _ _
        (inductionB p popl prinvl x1)
        (inductionB p popl prinvl x2)
    inductionB p popl prinvl (rinvL
                              x1
                              x2) =
      prinvl _ _
        (inductionB p popl prinvl x1)
        (inductionB p popl prinvl x2)
    inductionCl :
      (A : Set)
      (P : ClRightCancellativeTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRightCancellativeTerm
          A)
       (x2 : ClRightCancellativeTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      ((x1 : ClRightCancellativeTerm
          A)
       (x2 : ClRightCancellativeTerm
          A) ->
       P x1 ->
       P x2 -> P (rinvCl x1 x2)) ->
      (x : ClRightCancellativeTerm
         A) -> P x
    inductionCl _ p psing popcl prinvcl (sing
                                         x1) = psing x1
    inductionCl _ p psing popcl prinvcl (opCl
                                         x1
                                         x2) =
      popcl _ _
        (inductionCl _ p psing popcl
           prinvcl
           x1)
        (inductionCl _ p psing popcl
           prinvcl
           x2)
    inductionCl _ p psing popcl prinvcl (rinvCl
                                         x1
                                         x2) =
      prinvcl _ _
        (inductionCl _ p psing popcl
           prinvcl
           x1)
        (inductionCl _ p psing popcl
           prinvcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpRightCancellativeTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRightCancellativeTerm
          n)
       (x2 : OpRightCancellativeTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      ((x1 : OpRightCancellativeTerm
          n)
       (x2 : OpRightCancellativeTerm
          n) ->
       P x1 ->
       P x2 -> P (rinvOL x1 x2)) ->
      (x : OpRightCancellativeTerm
         n) -> P x
    inductionOp _ p pv popol prinvol (v
                                      x1) = pv x1
    inductionOp _ p pv popol prinvol (opOL
                                      x1
                                      x2) =
      popol _ _
        (inductionOp _ p pv popol
           prinvol
           x1)
        (inductionOp _ p pv popol
           prinvol
           x2)
    inductionOp _ p pv popol prinvol (rinvOL
                                      x1
                                      x2) =
      prinvol _ _
        (inductionOp _ p pv popol
           prinvol
           x1)
        (inductionOp _ p pv popol
           prinvol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRightCancellativeTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRightCancellativeTerm2
          n
          A)
       (x2 : OpRightCancellativeTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      ((x1 : OpRightCancellativeTerm2
          n
          A)
       (x2 : OpRightCancellativeTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (rinvOL2 x1 x2)) ->
      (x : OpRightCancellativeTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 prinvol2 (v2
                                                   x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 prinvol2 (sing2
                                                   x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 prinvol2 (opOL2
                                                   x1
                                                   x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           prinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           prinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 prinvol2 (rinvOL2
                                                   x1
                                                   x2) =
      prinvol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           prinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           prinvol2
           x2)
    opL' :
      RightCancellativeTerm ->
      RightCancellativeTerm ->
      RightCancellativeTerm
    opL' x1 x2 = opL x1 x2
    rinvL' :
      RightCancellativeTerm ->
      RightCancellativeTerm ->
      RightCancellativeTerm
    rinvL' x1 x2 = rinvL x1 x2
    stageB :
      RightCancellativeTerm ->
      Staged RightCancellativeTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (rinvL x1 x2) =
      stage2 _ _ _ rinvL'
        (codeLift2 _ _ _ rinvL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClRightCancellativeTerm A ->
      ClRightCancellativeTerm A ->
      ClRightCancellativeTerm A
    opCl' _ x1 x2 = opCl x1 x2
    rinvCl' :
      (A : Set) ->
      ClRightCancellativeTerm A ->
      ClRightCancellativeTerm A ->
      ClRightCancellativeTerm A
    rinvCl' _ x1 x2 = rinvCl x1 x2
    stageCl :
      (A : Set) ->
      ClRightCancellativeTerm A ->
      Staged
        (ClRightCancellativeTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (rinvCl x1 x2) =
      stage2 _ _ _ (rinvCl' _)
        (codeLift2 _ _ _ (rinvCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpRightCancellativeTerm n ->
      OpRightCancellativeTerm n ->
      OpRightCancellativeTerm n
    opOL' _ x1 x2 = opOL x1 x2
    rinvOL' :
      (n : Nat) ->
      OpRightCancellativeTerm n ->
      OpRightCancellativeTerm n ->
      OpRightCancellativeTerm n
    rinvOL' _ x1 x2 = rinvOL x1 x2
    stageOp :
      (n : Nat) ->
      OpRightCancellativeTerm n ->
      Staged
        (OpRightCancellativeTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (rinvOL x1 x2) =
      stage2 _ _ _ (rinvOL' _)
        (codeLift2 _ _ _ (rinvOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpRightCancellativeTerm2 n A ->
      OpRightCancellativeTerm2 n A ->
      OpRightCancellativeTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    rinvOL2' :
      (n : Nat) (A : Set) ->
      OpRightCancellativeTerm2 n A ->
      OpRightCancellativeTerm2 n A ->
      OpRightCancellativeTerm2 n A
    rinvOL2' _ _ x1 x2 =
      rinvOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRightCancellativeTerm2 n A ->
      Staged
        (OpRightCancellativeTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (rinvOL2 x1 x2) =
      stage2 _ _ _ (rinvOL2' _ _)
        (codeLift2 _ _ _ (rinvOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RightCancellativeTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
        rinvT :
          Repr A -> Repr A -> Repr A
  
  module RightCancellativeMagma where
    record RightCancellativeMagma
      (A : Set) : Set where
      constructor RightCancellativeMagmaC
      field
        op : A -> A -> A
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
    record RightCancellativeMagmaSig
      (AS : Set) : Set where
      constructor RightCancellativeMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record RightCancellativeMagmaProd
      (AP : Set) : Set where
      constructor RightCancellativeMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
    record RightCancellativeMagmaHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellativeMagma
         A1)
      (Ri2 : RightCancellativeMagma
         A2) : Set where
      constructor RightCancellativeMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record RightCancellativeMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellativeMagma
         A1)
      (Ri2 : RightCancellativeMagma
         A2) : Set where
      constructor RightCancellativeMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data RightCancellativeMagmaTerm
      : Set where
      opL :
        RightCancellativeMagmaTerm ->
        RightCancellativeMagmaTerm ->
        RightCancellativeMagmaTerm
    data ClRightCancellativeMagmaTerm
      (A : Set) : Set where
      sing :
        A ->
        ClRightCancellativeMagmaTerm A
      opCl :
        ClRightCancellativeMagmaTerm
          A ->
        ClRightCancellativeMagmaTerm
          A ->
        ClRightCancellativeMagmaTerm A
    data OpRightCancellativeMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpRightCancellativeMagmaTerm n
      opOL :
        OpRightCancellativeMagmaTerm
          n ->
        OpRightCancellativeMagmaTerm
          n ->
        OpRightCancellativeMagmaTerm n
    data OpRightCancellativeMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpRightCancellativeMagmaTerm2 n
          A
      sing2 :
        A ->
        OpRightCancellativeMagmaTerm2 n
          A
      opOL2 :
        OpRightCancellativeMagmaTerm2 n
          A ->
        OpRightCancellativeMagmaTerm2 n
          A ->
        OpRightCancellativeMagmaTerm2 n
          A
    simplifyB :
      RightCancellativeMagmaTerm ->
      RightCancellativeMagmaTerm
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRightCancellativeMagmaTerm
        A ->
      ClRightCancellativeMagmaTerm A
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRightCancellativeMagmaTerm
        n ->
      OpRightCancellativeMagmaTerm n
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRightCancellativeMagmaTerm2 n
        A ->
      OpRightCancellativeMagmaTerm2 n
        A
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RightCancellativeMagma A ->
      RightCancellativeMagmaTerm -> A
    evalB _ Ri (opL x1 x2) =
      op Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      RightCancellativeMagma A ->
      ClRightCancellativeMagmaTerm
        A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (opCl x1 x2) =
      op Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RightCancellativeMagma A ->
      Vec A n ->
      OpRightCancellativeMagmaTerm
        n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (opOL
                        x1
                        x2) =
      op Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RightCancellativeMagma A ->
      Vec A n ->
      OpRightCancellativeMagmaTerm2 n
        A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (opOL2
                         x1
                         x2) =
      op Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RightCancellativeMagmaTerm ->
           Set) ->
      ((x1 : RightCancellativeMagmaTerm)
       (x2 : RightCancellativeMagmaTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : RightCancellativeMagmaTerm) ->
      P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClRightCancellativeMagmaTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRightCancellativeMagmaTerm
          A)
       (x2 : ClRightCancellativeMagmaTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClRightCancellativeMagmaTerm
         A) -> P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpRightCancellativeMagmaTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRightCancellativeMagmaTerm
          n)
       (x2 : OpRightCancellativeMagmaTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpRightCancellativeMagmaTerm
         n) -> P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRightCancellativeMagmaTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRightCancellativeMagmaTerm2
          n
          A)
       (x2 : OpRightCancellativeMagmaTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpRightCancellativeMagmaTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      RightCancellativeMagmaTerm ->
      RightCancellativeMagmaTerm ->
      RightCancellativeMagmaTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      RightCancellativeMagmaTerm ->
      Staged
        RightCancellativeMagmaTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClRightCancellativeMagmaTerm
        A ->
      ClRightCancellativeMagmaTerm
        A ->
      ClRightCancellativeMagmaTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClRightCancellativeMagmaTerm
        A ->
      Staged
        (ClRightCancellativeMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpRightCancellativeMagmaTerm
        n ->
      OpRightCancellativeMagmaTerm
        n ->
      OpRightCancellativeMagmaTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpRightCancellativeMagmaTerm
        n ->
      Staged
        (OpRightCancellativeMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpRightCancellativeMagmaTerm2 n
        A ->
      OpRightCancellativeMagmaTerm2 n
        A ->
      OpRightCancellativeMagmaTerm2 n
        A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRightCancellativeMagmaTerm2 n
        A ->
      Staged
        (OpRightCancellativeMagmaTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RightCancellativeMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module RightCancellativeOp where
    record RightCancellativeOp
      (A : Set) : Set where
      constructor RightCancellativeOpC
      field
        op : A -> A -> A
        rinv : A -> A -> A
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
    record RightCancellativeOpSig
      (AS : Set) : Set where
      constructor RightCancellativeOpSigSigC
      field
        opS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record RightCancellativeOpProd
      (AP : Set) : Set where
      constructor RightCancellativeOpProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
    record RightCancellativeOpHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellativeOp A1)
      (Ri2 : RightCancellativeOp A2) :
      Set where
      constructor RightCancellativeOpHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Ri1 x1 x2) ==
            rinv Ri2 (hom x1) (hom x2)
    record RightCancellativeOpRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellativeOp A1)
      (Ri2 : RightCancellativeOp A2) :
      Set where
      constructor RightCancellativeOpRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Ri1 x1 x2)
            (rinv Ri2 y1 y2)
    data RightCancellativeOpTerm
      : Set where
      opL :
        RightCancellativeOpTerm ->
        RightCancellativeOpTerm ->
        RightCancellativeOpTerm
      rinvL :
        RightCancellativeOpTerm ->
        RightCancellativeOpTerm ->
        RightCancellativeOpTerm
    data ClRightCancellativeOpTerm
      (A : Set) : Set where
      sing :
        A -> ClRightCancellativeOpTerm A
      opCl :
        ClRightCancellativeOpTerm A ->
        ClRightCancellativeOpTerm A ->
        ClRightCancellativeOpTerm A
      rinvCl :
        ClRightCancellativeOpTerm A ->
        ClRightCancellativeOpTerm A ->
        ClRightCancellativeOpTerm A
    data OpRightCancellativeOpTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpRightCancellativeOpTerm n
      opOL :
        OpRightCancellativeOpTerm n ->
        OpRightCancellativeOpTerm n ->
        OpRightCancellativeOpTerm n
      rinvOL :
        OpRightCancellativeOpTerm n ->
        OpRightCancellativeOpTerm n ->
        OpRightCancellativeOpTerm n
    data OpRightCancellativeOpTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpRightCancellativeOpTerm2 n A
      sing2 :
        A ->
        OpRightCancellativeOpTerm2 n A
      opOL2 :
        OpRightCancellativeOpTerm2 n
          A ->
        OpRightCancellativeOpTerm2 n
          A ->
        OpRightCancellativeOpTerm2 n A
      rinvOL2 :
        OpRightCancellativeOpTerm2 n
          A ->
        OpRightCancellativeOpTerm2 n
          A ->
        OpRightCancellativeOpTerm2 n A
    simplifyB :
      RightCancellativeOpTerm ->
      RightCancellativeOpTerm
    simplifyB (rinvL (opL y x) x) =
      y
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (rinvL x1 x2) =
      rinvL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRightCancellativeOpTerm A ->
      ClRightCancellativeOpTerm A
    simplifyCl _ (rinvCl
                  (opCl y x)
                  x) = y
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (rinvCl x1 x2) =
      rinvCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRightCancellativeOpTerm n ->
      OpRightCancellativeOpTerm n
    simplifyOp _ (rinvOL
                  (opOL y x)
                  x) = y
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (rinvOL x1 x2) =
      rinvOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRightCancellativeOpTerm2 n
        A ->
      OpRightCancellativeOpTerm2 n A
    simplifyOpE _ _ (rinvOL2
                     (opOL2 y x)
                     x) = y
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (rinvOL2
                     x1
                     x2) =
      rinvOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RightCancellativeOp A ->
      RightCancellativeOpTerm -> A
    evalB _ Ri (opL x1 x2) =
      op Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalB _ Ri (rinvL x1 x2) =
      rinv Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      RightCancellativeOp A ->
      ClRightCancellativeOpTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (opCl x1 x2) =
      op Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalCl _ Ri (rinvCl x1 x2) =
      rinv Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RightCancellativeOp A ->
      Vec A n ->
      OpRightCancellativeOpTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (opOL
                        x1
                        x2) =
      op Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOp _ n Ri vars (rinvOL
                        x1
                        x2) =
      rinv Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RightCancellativeOp A ->
      Vec A n ->
      OpRightCancellativeOpTerm2 n
        A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (opOL2
                         x1
                         x2) =
      op Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    evalOpE _ n Ri vars (rinvOL2
                         x1
                         x2) =
      rinv Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RightCancellativeOpTerm ->
           Set) ->
      ((x1 : RightCancellativeOpTerm)
       (x2 : RightCancellativeOpTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      ((x1 : RightCancellativeOpTerm)
       (x2 : RightCancellativeOpTerm) ->
       P x1 ->
       P x2 -> P (rinvL x1 x2)) ->
      (x : RightCancellativeOpTerm) ->
      P x
    inductionB p popl prinvl (opL
                              x1
                              x2) =
      popl _ _
        (inductionB p popl prinvl x1)
        (inductionB p popl prinvl x2)
    inductionB p popl prinvl (rinvL
                              x1
                              x2) =
      prinvl _ _
        (inductionB p popl prinvl x1)
        (inductionB p popl prinvl x2)
    inductionCl :
      (A : Set)
      (P : ClRightCancellativeOpTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRightCancellativeOpTerm
          A)
       (x2 : ClRightCancellativeOpTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      ((x1 : ClRightCancellativeOpTerm
          A)
       (x2 : ClRightCancellativeOpTerm
          A) ->
       P x1 ->
       P x2 -> P (rinvCl x1 x2)) ->
      (x : ClRightCancellativeOpTerm
         A) -> P x
    inductionCl _ p psing popcl prinvcl (sing
                                         x1) = psing x1
    inductionCl _ p psing popcl prinvcl (opCl
                                         x1
                                         x2) =
      popcl _ _
        (inductionCl _ p psing popcl
           prinvcl
           x1)
        (inductionCl _ p psing popcl
           prinvcl
           x2)
    inductionCl _ p psing popcl prinvcl (rinvCl
                                         x1
                                         x2) =
      prinvcl _ _
        (inductionCl _ p psing popcl
           prinvcl
           x1)
        (inductionCl _ p psing popcl
           prinvcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpRightCancellativeOpTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRightCancellativeOpTerm
          n)
       (x2 : OpRightCancellativeOpTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      ((x1 : OpRightCancellativeOpTerm
          n)
       (x2 : OpRightCancellativeOpTerm
          n) ->
       P x1 ->
       P x2 -> P (rinvOL x1 x2)) ->
      (x : OpRightCancellativeOpTerm
         n) -> P x
    inductionOp _ p pv popol prinvol (v
                                      x1) = pv x1
    inductionOp _ p pv popol prinvol (opOL
                                      x1
                                      x2) =
      popol _ _
        (inductionOp _ p pv popol
           prinvol
           x1)
        (inductionOp _ p pv popol
           prinvol
           x2)
    inductionOp _ p pv popol prinvol (rinvOL
                                      x1
                                      x2) =
      prinvol _ _
        (inductionOp _ p pv popol
           prinvol
           x1)
        (inductionOp _ p pv popol
           prinvol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRightCancellativeOpTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRightCancellativeOpTerm2
          n
          A)
       (x2 : OpRightCancellativeOpTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      ((x1 : OpRightCancellativeOpTerm2
          n
          A)
       (x2 : OpRightCancellativeOpTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (rinvOL2 x1 x2)) ->
      (x : OpRightCancellativeOpTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 prinvol2 (v2
                                                   x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 prinvol2 (sing2
                                                   x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 prinvol2 (opOL2
                                                   x1
                                                   x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           prinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           prinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 prinvol2 (rinvOL2
                                                   x1
                                                   x2) =
      prinvol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           prinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           prinvol2
           x2)
    opL' :
      RightCancellativeOpTerm ->
      RightCancellativeOpTerm ->
      RightCancellativeOpTerm
    opL' x1 x2 = opL x1 x2
    rinvL' :
      RightCancellativeOpTerm ->
      RightCancellativeOpTerm ->
      RightCancellativeOpTerm
    rinvL' x1 x2 = rinvL x1 x2
    stageB :
      RightCancellativeOpTerm ->
      Staged RightCancellativeOpTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (rinvL x1 x2) =
      stage2 _ _ _ rinvL'
        (codeLift2 _ _ _ rinvL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClRightCancellativeOpTerm A ->
      ClRightCancellativeOpTerm A ->
      ClRightCancellativeOpTerm A
    opCl' _ x1 x2 = opCl x1 x2
    rinvCl' :
      (A : Set) ->
      ClRightCancellativeOpTerm A ->
      ClRightCancellativeOpTerm A ->
      ClRightCancellativeOpTerm A
    rinvCl' _ x1 x2 = rinvCl x1 x2
    stageCl :
      (A : Set) ->
      ClRightCancellativeOpTerm A ->
      Staged
        (ClRightCancellativeOpTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (rinvCl x1 x2) =
      stage2 _ _ _ (rinvCl' _)
        (codeLift2 _ _ _ (rinvCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpRightCancellativeOpTerm n ->
      OpRightCancellativeOpTerm n ->
      OpRightCancellativeOpTerm n
    opOL' _ x1 x2 = opOL x1 x2
    rinvOL' :
      (n : Nat) ->
      OpRightCancellativeOpTerm n ->
      OpRightCancellativeOpTerm n ->
      OpRightCancellativeOpTerm n
    rinvOL' _ x1 x2 = rinvOL x1 x2
    stageOp :
      (n : Nat) ->
      OpRightCancellativeOpTerm n ->
      Staged
        (OpRightCancellativeOpTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (rinvOL x1 x2) =
      stage2 _ _ _ (rinvOL' _)
        (codeLift2 _ _ _ (rinvOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpRightCancellativeOpTerm2 n
        A ->
      OpRightCancellativeOpTerm2 n
        A ->
      OpRightCancellativeOpTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    rinvOL2' :
      (n : Nat) (A : Set) ->
      OpRightCancellativeOpTerm2 n
        A ->
      OpRightCancellativeOpTerm2 n
        A ->
      OpRightCancellativeOpTerm2 n A
    rinvOL2' _ _ x1 x2 =
      rinvOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRightCancellativeOpTerm2 n
        A ->
      Staged
        (OpRightCancellativeOpTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (rinvOL2 x1 x2) =
      stage2 _ _ _ (rinvOL2' _ _)
        (codeLift2 _ _ _ (rinvOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RightCancellativeOpTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
        rinvT :
          Repr A -> Repr A -> Repr A
  
  module RightCancellativeSemigroup where
    record RightCancellativeSemigroup
      (A : Set) : Set where
      constructor RightCancellativeSemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
        rightCancellative :
          (x : A) (y : A) (z : A) ->
          op x z == op y z -> x == y
    record RightCancellativeSemigroupSig
      (AS : Set) : Set where
      constructor RightCancellativeSemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record RightCancellativeSemigroupProd
      (AP : Set) : Set where
      constructor RightCancellativeSemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
        rightCancellativeP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP xP zP == opP yP zP ->
          xP == yP
    record RightCancellativeSemigroupHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellativeSemigroup
         A1)
      (Ri2 : RightCancellativeSemigroup
         A2) : Set where
      constructor RightCancellativeSemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record RightCancellativeSemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightCancellativeSemigroup
         A1)
      (Ri2 : RightCancellativeSemigroup
         A2) : Set where
      constructor RightCancellativeSemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data RightCancellativeSemigroupTerm
      : Set where
      opL :
        RightCancellativeSemigroupTerm ->
        RightCancellativeSemigroupTerm ->
        RightCancellativeSemigroupTerm
    data ClRightCancellativeSemigroupTerm
      (A : Set) : Set where
      sing :
        A ->
        ClRightCancellativeSemigroupTerm
          A
      opCl :
        ClRightCancellativeSemigroupTerm
          A ->
        ClRightCancellativeSemigroupTerm
          A ->
        ClRightCancellativeSemigroupTerm
          A
    data OpRightCancellativeSemigroupTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpRightCancellativeSemigroupTerm
          n
      opOL :
        OpRightCancellativeSemigroupTerm
          n ->
        OpRightCancellativeSemigroupTerm
          n ->
        OpRightCancellativeSemigroupTerm
          n
    data OpRightCancellativeSemigroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpRightCancellativeSemigroupTerm2
          n
          A
      sing2 :
        A ->
        OpRightCancellativeSemigroupTerm2
          n
          A
      opOL2 :
        OpRightCancellativeSemigroupTerm2
          n
          A ->
        OpRightCancellativeSemigroupTerm2
          n
          A ->
        OpRightCancellativeSemigroupTerm2
          n
          A
    simplifyB :
      RightCancellativeSemigroupTerm ->
      RightCancellativeSemigroupTerm
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRightCancellativeSemigroupTerm
        A ->
      ClRightCancellativeSemigroupTerm
        A
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRightCancellativeSemigroupTerm
        n ->
      OpRightCancellativeSemigroupTerm
        n
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRightCancellativeSemigroupTerm2
        n
        A ->
      OpRightCancellativeSemigroupTerm2
        n
        A
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RightCancellativeSemigroup A ->
      RightCancellativeSemigroupTerm ->
      A
    evalB _ Ri (opL x1 x2) =
      op Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      RightCancellativeSemigroup A ->
      ClRightCancellativeSemigroupTerm
        A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (opCl x1 x2) =
      op Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RightCancellativeSemigroup A ->
      Vec A n ->
      OpRightCancellativeSemigroupTerm
        n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (opOL
                        x1
                        x2) =
      op Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RightCancellativeSemigroup A ->
      Vec A n ->
      OpRightCancellativeSemigroupTerm2
        n
        A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (opOL2
                         x1
                         x2) =
      op Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RightCancellativeSemigroupTerm ->
           Set) ->
      ((x1 : RightCancellativeSemigroupTerm)
       (x2 : RightCancellativeSemigroupTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : RightCancellativeSemigroupTerm) ->
      P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClRightCancellativeSemigroupTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRightCancellativeSemigroupTerm
          A)
       (x2 : ClRightCancellativeSemigroupTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClRightCancellativeSemigroupTerm
         A) -> P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpRightCancellativeSemigroupTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRightCancellativeSemigroupTerm
          n)
       (x2 : OpRightCancellativeSemigroupTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpRightCancellativeSemigroupTerm
         n) -> P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRightCancellativeSemigroupTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRightCancellativeSemigroupTerm2
          n
          A)
       (x2 : OpRightCancellativeSemigroupTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpRightCancellativeSemigroupTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      RightCancellativeSemigroupTerm ->
      RightCancellativeSemigroupTerm ->
      RightCancellativeSemigroupTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      RightCancellativeSemigroupTerm ->
      Staged
        RightCancellativeSemigroupTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClRightCancellativeSemigroupTerm
        A ->
      ClRightCancellativeSemigroupTerm
        A ->
      ClRightCancellativeSemigroupTerm
        A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClRightCancellativeSemigroupTerm
        A ->
      Staged
        (ClRightCancellativeSemigroupTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpRightCancellativeSemigroupTerm
        n ->
      OpRightCancellativeSemigroupTerm
        n ->
      OpRightCancellativeSemigroupTerm
        n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpRightCancellativeSemigroupTerm
        n ->
      Staged
        (OpRightCancellativeSemigroupTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpRightCancellativeSemigroupTerm2
        n
        A ->
      OpRightCancellativeSemigroupTerm2
        n
        A ->
      OpRightCancellativeSemigroupTerm2
        n
        A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRightCancellativeSemigroupTerm2
        n
        A ->
      Staged
        (OpRightCancellativeSemigroupTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RightCancellativeSemigroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module RightDistributiveMagma where
    record RightDistributiveMagma
      (A : Set) : Set where
      constructor RightDistributiveMagmaC
      field
        op : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          op (op y z) x ==
            op (op y x) (op z x)
    record RightDistributiveMagmaSig
      (AS : Set) : Set where
      constructor RightDistributiveMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record RightDistributiveMagmaProd
      (AP : Set) : Set where
      constructor RightDistributiveMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP yP zP) xP ==
            opP (opP yP xP) (opP zP xP)
    record RightDistributiveMagmaHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightDistributiveMagma
         A1)
      (Ri2 : RightDistributiveMagma
         A2) : Set where
      constructor RightDistributiveMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record RightDistributiveMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightDistributiveMagma
         A1)
      (Ri2 : RightDistributiveMagma
         A2) : Set where
      constructor RightDistributiveMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data RightDistributiveMagmaTerm
      : Set where
      opL :
        RightDistributiveMagmaTerm ->
        RightDistributiveMagmaTerm ->
        RightDistributiveMagmaTerm
    data ClRightDistributiveMagmaTerm
      (A : Set) : Set where
      sing :
        A ->
        ClRightDistributiveMagmaTerm A
      opCl :
        ClRightDistributiveMagmaTerm
          A ->
        ClRightDistributiveMagmaTerm
          A ->
        ClRightDistributiveMagmaTerm A
    data OpRightDistributiveMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpRightDistributiveMagmaTerm n
      opOL :
        OpRightDistributiveMagmaTerm
          n ->
        OpRightDistributiveMagmaTerm
          n ->
        OpRightDistributiveMagmaTerm n
    data OpRightDistributiveMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpRightDistributiveMagmaTerm2 n
          A
      sing2 :
        A ->
        OpRightDistributiveMagmaTerm2 n
          A
      opOL2 :
        OpRightDistributiveMagmaTerm2 n
          A ->
        OpRightDistributiveMagmaTerm2 n
          A ->
        OpRightDistributiveMagmaTerm2 n
          A
    simplifyB :
      RightDistributiveMagmaTerm ->
      RightDistributiveMagmaTerm
    simplifyB (opL
               (opL y x)
               (opL z x)) = opL (opL y z) x
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRightDistributiveMagmaTerm
        A ->
      ClRightDistributiveMagmaTerm A
    simplifyCl _ (opCl
                  (opCl y x)
                  (opCl z x)) = opCl (opCl y z) x
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRightDistributiveMagmaTerm
        n ->
      OpRightDistributiveMagmaTerm n
    simplifyOp _ (opOL
                  (opOL y x)
                  (opOL z x)) = opOL (opOL y z) x
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRightDistributiveMagmaTerm2 n
        A ->
      OpRightDistributiveMagmaTerm2 n
        A
    simplifyOpE _ _ (opOL2
                     (opOL2 y x)
                     (opOL2 z x)) =
      opOL2 (opOL2 y z) x
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RightDistributiveMagma A ->
      RightDistributiveMagmaTerm -> A
    evalB _ Ri (opL x1 x2) =
      op Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      RightDistributiveMagma A ->
      ClRightDistributiveMagmaTerm
        A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (opCl x1 x2) =
      op Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RightDistributiveMagma A ->
      Vec A n ->
      OpRightDistributiveMagmaTerm
        n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (opOL
                        x1
                        x2) =
      op Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RightDistributiveMagma A ->
      Vec A n ->
      OpRightDistributiveMagmaTerm2 n
        A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (opOL2
                         x1
                         x2) =
      op Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RightDistributiveMagmaTerm ->
           Set) ->
      ((x1 : RightDistributiveMagmaTerm)
       (x2 : RightDistributiveMagmaTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : RightDistributiveMagmaTerm) ->
      P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClRightDistributiveMagmaTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRightDistributiveMagmaTerm
          A)
       (x2 : ClRightDistributiveMagmaTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClRightDistributiveMagmaTerm
         A) -> P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpRightDistributiveMagmaTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRightDistributiveMagmaTerm
          n)
       (x2 : OpRightDistributiveMagmaTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpRightDistributiveMagmaTerm
         n) -> P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRightDistributiveMagmaTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRightDistributiveMagmaTerm2
          n
          A)
       (x2 : OpRightDistributiveMagmaTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpRightDistributiveMagmaTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      RightDistributiveMagmaTerm ->
      RightDistributiveMagmaTerm ->
      RightDistributiveMagmaTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      RightDistributiveMagmaTerm ->
      Staged
        RightDistributiveMagmaTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClRightDistributiveMagmaTerm
        A ->
      ClRightDistributiveMagmaTerm
        A ->
      ClRightDistributiveMagmaTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClRightDistributiveMagmaTerm
        A ->
      Staged
        (ClRightDistributiveMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpRightDistributiveMagmaTerm
        n ->
      OpRightDistributiveMagmaTerm
        n ->
      OpRightDistributiveMagmaTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpRightDistributiveMagmaTerm
        n ->
      Staged
        (OpRightDistributiveMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpRightDistributiveMagmaTerm2 n
        A ->
      OpRightDistributiveMagmaTerm2 n
        A ->
      OpRightDistributiveMagmaTerm2 n
        A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRightDistributiveMagmaTerm2 n
        A ->
      Staged
        (OpRightDistributiveMagmaTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RightDistributiveMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module RightIdempotence where
    record RightIdempotence
      (A : Set) : Set where
      constructor RightIdempotenceC
      field
        <| : A -> A -> A
        idempotent_<| :
          (x : A) -> <| x x == x
    record RightIdempotenceSig
      (AS : Set) : Set where
      constructor RightIdempotenceSigSigC
      field
        <|S : AS -> AS -> AS
    record RightIdempotenceProd
      (AP : Set) : Set where
      constructor RightIdempotenceProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        idempotent_<|P :
          (xP : Prod AP AP) ->
          <|P xP xP == xP
    record RightIdempotenceHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightIdempotence A1)
      (Ri2 : RightIdempotence A2) :
      Set where
      constructor RightIdempotenceHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
    record RightIdempotenceRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightIdempotence A1)
      (Ri2 : RightIdempotence A2) :
      Set where
      constructor RightIdempotenceRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
    data RightIdempotenceTerm
      : Set where
      <|L :
        RightIdempotenceTerm ->
        RightIdempotenceTerm ->
        RightIdempotenceTerm
    data ClRightIdempotenceTerm
      (A : Set) : Set where
      sing :
        A -> ClRightIdempotenceTerm A
      <|Cl :
        ClRightIdempotenceTerm A ->
        ClRightIdempotenceTerm A ->
        ClRightIdempotenceTerm A
    data OpRightIdempotenceTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpRightIdempotenceTerm n
      <|OL :
        OpRightIdempotenceTerm n ->
        OpRightIdempotenceTerm n ->
        OpRightIdempotenceTerm n
    data OpRightIdempotenceTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpRightIdempotenceTerm2 n A
      sing2 :
        A -> OpRightIdempotenceTerm2 n A
      <|OL2 :
        OpRightIdempotenceTerm2 n A ->
        OpRightIdempotenceTerm2 n A ->
        OpRightIdempotenceTerm2 n A
    simplifyB :
      RightIdempotenceTerm ->
      RightIdempotenceTerm
    simplifyB (<|L x x) = x
    simplifyB (<|L x1 x2) =
      <|L (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRightIdempotenceTerm A ->
      ClRightIdempotenceTerm A
    simplifyCl _ (<|Cl x x) = x
    simplifyCl _ (<|Cl x1 x2) =
      <|Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRightIdempotenceTerm n ->
      OpRightIdempotenceTerm n
    simplifyOp _ (<|OL x x) = x
    simplifyOp _ (<|OL x1 x2) =
      <|OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRightIdempotenceTerm2 n A ->
      OpRightIdempotenceTerm2 n A
    simplifyOpE _ _ (<|OL2 x x) = x
    simplifyOpE _ _ (<|OL2 x1 x2) =
      <|OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RightIdempotence A ->
      RightIdempotenceTerm -> A
    evalB _ Ri (<|L x1 x2) =
      <| Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      RightIdempotence A ->
      ClRightIdempotenceTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (<|Cl x1 x2) =
      <| Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RightIdempotence A ->
      Vec A n ->
      OpRightIdempotenceTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (<|OL
                        x1
                        x2) =
      <| Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RightIdempotence A ->
      Vec A n ->
      OpRightIdempotenceTerm2 n A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (<|OL2
                         x1
                         x2) =
      <| Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RightIdempotenceTerm ->
           Set) ->
      ((x1 : RightIdempotenceTerm)
       (x2 : RightIdempotenceTerm) ->
       P x1 ->
       P x2 -> P (<|L x1 x2)) ->
      (x : RightIdempotenceTerm) ->
      P x
    inductionB p p<|l (<|L x1 x2) =
      p<|l _ _ (inductionB p p<|l x1)
        (inductionB p p<|l x2)
    inductionCl :
      (A : Set)
      (P : ClRightIdempotenceTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRightIdempotenceTerm A)
       (x2 : ClRightIdempotenceTerm
          A) ->
       P x1 ->
       P x2 -> P (<|Cl x1 x2)) ->
      (x : ClRightIdempotenceTerm
         A) -> P x
    inductionCl _ p psing p<|cl (sing
                                 x1) = psing x1
    inductionCl _ p psing p<|cl (<|Cl
                                 x1
                                 x2) =
      p<|cl _ _
        (inductionCl _ p psing p<|cl x1)
        (inductionCl _ p psing p<|cl x2)
    inductionOp :
      (n : Nat)
      (P : OpRightIdempotenceTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRightIdempotenceTerm n)
       (x2 : OpRightIdempotenceTerm
          n) ->
       P x1 ->
       P x2 -> P (<|OL x1 x2)) ->
      (x : OpRightIdempotenceTerm
         n) -> P x
    inductionOp _ p pv p<|ol (v
                              x1) = pv x1
    inductionOp _ p pv p<|ol (<|OL
                              x1
                              x2) =
      p<|ol _ _
        (inductionOp _ p pv p<|ol x1)
        (inductionOp _ p pv p<|ol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRightIdempotenceTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRightIdempotenceTerm2 n
          A)
       (x2 : OpRightIdempotenceTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (<|OL2 x1 x2)) ->
      (x : OpRightIdempotenceTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p<|ol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p<|ol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p<|ol2 (<|OL2
                                          x1
                                          x2) =
      p<|ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p<|ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p<|ol2
           x2)
    <|L' :
      RightIdempotenceTerm ->
      RightIdempotenceTerm ->
      RightIdempotenceTerm
    <|L' x1 x2 = <|L x1 x2
    stageB :
      RightIdempotenceTerm ->
      Staged RightIdempotenceTerm
    stageB (<|L x1 x2) =
      stage2 _ _ _ <|L'
        (codeLift2 _ _ _ <|L')
        (stageB x1)
        (stageB x2)
    <|Cl' :
      (A : Set) ->
      ClRightIdempotenceTerm A ->
      ClRightIdempotenceTerm A ->
      ClRightIdempotenceTerm A
    <|Cl' _ x1 x2 = <|Cl x1 x2
    stageCl :
      (A : Set) ->
      ClRightIdempotenceTerm A ->
      Staged
        (ClRightIdempotenceTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (<|Cl x1 x2) =
      stage2 _ _ _ (<|Cl' _)
        (codeLift2 _ _ _ (<|Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    <|OL' :
      (n : Nat) ->
      OpRightIdempotenceTerm n ->
      OpRightIdempotenceTerm n ->
      OpRightIdempotenceTerm n
    <|OL' _ x1 x2 = <|OL x1 x2
    stageOp :
      (n : Nat) ->
      OpRightIdempotenceTerm n ->
      Staged
        (OpRightIdempotenceTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (<|OL x1 x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    <|OL2' :
      (n : Nat) (A : Set) ->
      OpRightIdempotenceTerm2 n A ->
      OpRightIdempotenceTerm2 n A ->
      OpRightIdempotenceTerm2 n A
    <|OL2' _ _ x1 x2 = <|OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRightIdempotenceTerm2 n A ->
      Staged
        (OpRightIdempotenceTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (<|OL2 x1 x2) =
      stage2 _ _ _ (<|OL2' _ _)
        (codeLift2 _ _ _ (<|OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RightIdempotenceTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        <|T : Repr A -> Repr A -> Repr A
  
  module RightInverse where
    record RightInverse
      (A : Set) : Set where
      constructor RightInverseC
      field
        inv : A -> A
        e : A
        op : A -> A -> A
        rightInverse_inv_op_e :
          (x : A) -> op (inv x) x == e
    record RightInverseSig
      (AS : Set) : Set where
      constructor RightInverseSigSigC
      field
        invS : AS -> AS
        eS : AS
        opS : AS -> AS -> AS
    record RightInverseProd
      (AP : Set) : Set where
      constructor RightInverseProdC
      field
        invP : Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightInverse_inv_op_eP :
          (xP : Prod AP AP) ->
          opP (invP xP) xP == eP
    record RightInverseHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightInverse A1)
      (Ri2 : RightInverse A2) :
      Set where
      constructor RightInverseHomC
      field
        hom : A1 -> A2
        pres-inv :
          (x1 : A1) ->
          hom (inv Ri1 x1) ==
            inv Ri2 (hom x1)
        pres-e : hom (e Ri1) == e Ri2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record RightInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightInverse A1)
      (Ri2 : RightInverse A2) :
      Set where
      constructor RightInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-inv :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (inv Ri1 x1) (inv Ri2 y1)
        interp-e :
          interp (e Ri1) (e Ri2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data RightInverseLTerm
      : Set where
      invL :
        RightInverseLTerm ->
        RightInverseLTerm
      eL : RightInverseLTerm
      opL :
        RightInverseLTerm ->
        RightInverseLTerm ->
        RightInverseLTerm
    data ClRightInverseClTerm
      (A : Set) : Set where
      sing :
        A -> ClRightInverseClTerm A
      invCl :
        ClRightInverseClTerm A ->
        ClRightInverseClTerm A
      eCl : ClRightInverseClTerm A
      opCl :
        ClRightInverseClTerm A ->
        ClRightInverseClTerm A ->
        ClRightInverseClTerm A
    data OpRightInverseOLTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpRightInverseOLTerm n
      invOL :
        OpRightInverseOLTerm n ->
        OpRightInverseOLTerm n
      eOL : OpRightInverseOLTerm n
      opOL :
        OpRightInverseOLTerm n ->
        OpRightInverseOLTerm n ->
        OpRightInverseOLTerm n
    data OpRightInverseOL2Term2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpRightInverseOL2Term2 n A
      sing2 :
        A -> OpRightInverseOL2Term2 n A
      invOL2 :
        OpRightInverseOL2Term2 n A ->
        OpRightInverseOL2Term2 n A
      eOL2 :
        OpRightInverseOL2Term2 n A
      opOL2 :
        OpRightInverseOL2Term2 n A ->
        OpRightInverseOL2Term2 n A ->
        OpRightInverseOL2Term2 n A
    simplifyB :
      RightInverseLTerm ->
      RightInverseLTerm
    simplifyB (opL (invL x) x) = eL
    simplifyB (invL x1) =
      invL (simplifyB x1)
    simplifyB (eL) = eL
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRightInverseClTerm A ->
      ClRightInverseClTerm A
    simplifyCl _ (opCl
                  (invCl x)
                  x) = eCl
    simplifyCl _ (invCl x1) =
      invCl (simplifyCl _ x1)
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRightInverseOLTerm n ->
      OpRightInverseOLTerm n
    simplifyOp _ (opOL
                  (invOL x)
                  x) = eOL
    simplifyOp _ (invOL x1) =
      invOL (simplifyOp _ x1)
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRightInverseOL2Term2 n A ->
      OpRightInverseOL2Term2 n A
    simplifyOpE _ _ (opOL2
                     (invOL2 x)
                     x) = eOL2
    simplifyOpE _ _ (invOL2 x1) =
      invOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RightInverse A ->
      RightInverseLTerm -> A
    evalB _ Ri (invL x1) =
      inv Ri (evalB _ Ri x1)
    evalB _ Ri (eL) = e Ri
    evalB _ Ri (opL x1 x2) =
      op Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      RightInverse A ->
      ClRightInverseClTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (invCl x1) =
      inv Ri (evalCl _ Ri x1)
    evalCl _ Ri (eCl) = e Ri
    evalCl _ Ri (opCl x1 x2) =
      op Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RightInverse A ->
      Vec A n ->
      OpRightInverseOLTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (invOL x1) =
      inv Ri (evalOp _ n Ri vars x1)
    evalOp _ n Ri vars (eOL) = e Ri
    evalOp _ n Ri vars (opOL
                        x1
                        x2) =
      op Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RightInverse A ->
      Vec A n ->
      OpRightInverseOL2Term2 n A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (invOL2
                         x1) =
      inv Ri (evalOpE _ n Ri vars x1)
    evalOpE _ n Ri vars (eOL2) =
      e Ri
    evalOpE _ n Ri vars (opOL2
                         x1
                         x2) =
      op Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RightInverseLTerm ->
           Set) ->
      ((x1 : RightInverseLTerm) ->
       P x1 -> P (invL x1)) ->
      P eL ->
      ((x1 : RightInverseLTerm)
       (x2 : RightInverseLTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : RightInverseLTerm) -> P x
    inductionB p pinvl pel popl (invL
                                 x1) =
      pinvl _
        (inductionB p pinvl pel popl x1)
    inductionB p pinvl pel popl (eL) =
      pel
    inductionB p pinvl pel popl (opL
                                 x1
                                 x2) =
      popl _ _
        (inductionB p pinvl pel popl x1)
        (inductionB p pinvl pel popl x2)
    inductionCl :
      (A : Set)
      (P : ClRightInverseClTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRightInverseClTerm
          A) -> P x1 -> P (invCl x1)) ->
      P eCl ->
      ((x1 : ClRightInverseClTerm A)
       (x2 : ClRightInverseClTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClRightInverseClTerm A) ->
      P x
    inductionCl _ p psing pinvcl pecl popcl (sing
                                             x1) = psing x1
    inductionCl _ p psing pinvcl pecl popcl (invCl
                                             x1) =
      pinvcl _
        (inductionCl _ p psing pinvcl
           pecl
           popcl
           x1)
    inductionCl _ p psing pinvcl pecl popcl (eCl) =
      pecl
    inductionCl _ p psing pinvcl pecl popcl (opCl
                                             x1
                                             x2) =
      popcl _ _
        (inductionCl _ p psing pinvcl
           pecl
           popcl
           x1)
        (inductionCl _ p psing pinvcl
           pecl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpRightInverseOLTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRightInverseOLTerm
          n) -> P x1 -> P (invOL x1)) ->
      P eOL ->
      ((x1 : OpRightInverseOLTerm n)
       (x2 : OpRightInverseOLTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpRightInverseOLTerm n) ->
      P x
    inductionOp _ p pv pinvol peol popol (v
                                          x1) = pv x1
    inductionOp _ p pv pinvol peol popol (invOL
                                          x1) =
      pinvol _
        (inductionOp _ p pv pinvol peol
           popol
           x1)
    inductionOp _ p pv pinvol peol popol (eOL) =
      peol
    inductionOp _ p pv pinvol peol popol (opOL
                                          x1
                                          x2) =
      popol _ _
        (inductionOp _ p pv pinvol peol
           popol
           x1)
        (inductionOp _ p pv pinvol peol
           popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRightInverseOL2Term2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRightInverseOL2Term2 n
          A) -> P x1 -> P (invOL2 x1)) ->
      P eOL2 ->
      ((x1 : OpRightInverseOL2Term2 n
          A)
       (x2 : OpRightInverseOL2Term2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpRightInverseOL2Term2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 pinvol2 peol2 popol2 (v2
                                                        x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pinvol2 peol2 popol2 (sing2
                                                        x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pinvol2 peol2 popol2 (invOL2
                                                        x1) =
      pinvol2 _
        (inductionOpE _ _ p pv2 psing2
           pinvol2
           peol2
           popol2
           x1)
    inductionOpE _ _ p pv2 psing2 pinvol2 peol2 popol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 pinvol2 peol2 popol2 (opOL2
                                                        x1
                                                        x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           pinvol2
           peol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           pinvol2
           peol2
           popol2
           x2)
    invL' :
      RightInverseLTerm ->
      RightInverseLTerm
    invL' x1 = invL x1
    eL' : RightInverseLTerm
    eL' = eL
    opL' :
      RightInverseLTerm ->
      RightInverseLTerm ->
      RightInverseLTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      RightInverseLTerm ->
      Staged RightInverseLTerm
    stageB (invL x1) =
      stage1 _ _ invL'
        (codeLift1 _ _ invL')
        (stageB x1)
    stageB (eL) = Now eL
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    invCl' :
      (A : Set) ->
      ClRightInverseClTerm A ->
      ClRightInverseClTerm A
    invCl' _ x1 = invCl x1
    eCl' :
      (A : Set) ->
      ClRightInverseClTerm A
    eCl' _ = eCl
    opCl' :
      (A : Set) ->
      ClRightInverseClTerm A ->
      ClRightInverseClTerm A ->
      ClRightInverseClTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClRightInverseClTerm A ->
      Staged (ClRightInverseClTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (invCl x1) =
      stage1 _ _ (invCl' _)
        (codeLift1 _ _ (invCl' _))
        (stageCl _ x1)
    stageCl _ (eCl) = Now eCl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    invOL' :
      (n : Nat) ->
      OpRightInverseOLTerm n ->
      OpRightInverseOLTerm n
    invOL' _ x1 = invOL x1
    eOL' :
      (n : Nat) ->
      OpRightInverseOLTerm n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      OpRightInverseOLTerm n ->
      OpRightInverseOLTerm n ->
      OpRightInverseOLTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpRightInverseOLTerm n ->
      Staged (OpRightInverseOLTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (invOL x1) =
      stage1 _ _ (invOL' _)
        (codeLift1 _ _ (invOL' _))
        (stageOp _ x1)
    stageOp _ (eOL) = Now eOL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    invOL2' :
      (n : Nat) (A : Set) ->
      OpRightInverseOL2Term2 n A ->
      OpRightInverseOL2Term2 n A
    invOL2' _ _ x1 = invOL2 x1
    eOL2' :
      (n : Nat) (A : Set) ->
      OpRightInverseOL2Term2 n A
    eOL2' _ _ = eOL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpRightInverseOL2Term2 n A ->
      OpRightInverseOL2Term2 n A ->
      OpRightInverseOL2Term2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRightInverseOL2Term2 n A ->
      Staged
        (OpRightInverseOL2Term2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (invOL2 x1) =
      stage1 _ _ (invOL2' _ _)
        (codeLift1 _ _ (invOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RightInverseTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        invT : Repr A -> Repr A
        eT : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module RightInverseMagma where
    record RightInverseMagma
      (A : Set) : Set where
      constructor RightInverseMagmaC
      field
        rinv : A -> A -> A
    record RightInverseMagmaSig
      (AS : Set) : Set where
      constructor RightInverseMagmaSigSigC
      field
        rinvS : AS -> AS -> AS
    record RightInverseMagmaProd
      (AP : Set) : Set where
      constructor RightInverseMagmaProdC
      field
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record RightInverseMagmaHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightInverseMagma A1)
      (Ri2 : RightInverseMagma A2) :
      Set where
      constructor RightInverseMagmaHomC
      field
        hom : A1 -> A2
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Ri1 x1 x2) ==
            rinv Ri2 (hom x1) (hom x2)
    record RightInverseMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightInverseMagma A1)
      (Ri2 : RightInverseMagma A2) :
      Set where
      constructor RightInverseMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Ri1 x1 x2)
            (rinv Ri2 y1 y2)
    data RightInverseMagmaTerm
      : Set where
      rinvL :
        RightInverseMagmaTerm ->
        RightInverseMagmaTerm ->
        RightInverseMagmaTerm
    data ClRightInverseMagmaTerm
      (A : Set) : Set where
      sing :
        A -> ClRightInverseMagmaTerm A
      rinvCl :
        ClRightInverseMagmaTerm A ->
        ClRightInverseMagmaTerm A ->
        ClRightInverseMagmaTerm A
    data OpRightInverseMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpRightInverseMagmaTerm n
      rinvOL :
        OpRightInverseMagmaTerm n ->
        OpRightInverseMagmaTerm n ->
        OpRightInverseMagmaTerm n
    data OpRightInverseMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpRightInverseMagmaTerm2 n A
      sing2 :
        A ->
        OpRightInverseMagmaTerm2 n A
      rinvOL2 :
        OpRightInverseMagmaTerm2 n A ->
        OpRightInverseMagmaTerm2 n A ->
        OpRightInverseMagmaTerm2 n A
    simplifyB :
      RightInverseMagmaTerm ->
      RightInverseMagmaTerm
    simplifyB (rinvL x1 x2) =
      rinvL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRightInverseMagmaTerm A ->
      ClRightInverseMagmaTerm A
    simplifyCl _ (rinvCl x1 x2) =
      rinvCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRightInverseMagmaTerm n ->
      OpRightInverseMagmaTerm n
    simplifyOp _ (rinvOL x1 x2) =
      rinvOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRightInverseMagmaTerm2 n A ->
      OpRightInverseMagmaTerm2 n A
    simplifyOpE _ _ (rinvOL2
                     x1
                     x2) =
      rinvOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RightInverseMagma A ->
      RightInverseMagmaTerm -> A
    evalB _ Ri (rinvL x1 x2) =
      rinv Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      RightInverseMagma A ->
      ClRightInverseMagmaTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (rinvCl x1 x2) =
      rinv Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RightInverseMagma A ->
      Vec A n ->
      OpRightInverseMagmaTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (rinvOL
                        x1
                        x2) =
      rinv Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RightInverseMagma A ->
      Vec A n ->
      OpRightInverseMagmaTerm2 n A ->
      A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (rinvOL2
                         x1
                         x2) =
      rinv Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RightInverseMagmaTerm ->
           Set) ->
      ((x1 : RightInverseMagmaTerm)
       (x2 : RightInverseMagmaTerm) ->
       P x1 ->
       P x2 -> P (rinvL x1 x2)) ->
      (x : RightInverseMagmaTerm) ->
      P x
    inductionB p prinvl (rinvL
                         x1
                         x2) =
      prinvl _ _
        (inductionB p prinvl x1)
        (inductionB p prinvl x2)
    inductionCl :
      (A : Set)
      (P : ClRightInverseMagmaTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRightInverseMagmaTerm
          A)
       (x2 : ClRightInverseMagmaTerm
          A) ->
       P x1 ->
       P x2 -> P (rinvCl x1 x2)) ->
      (x : ClRightInverseMagmaTerm
         A) -> P x
    inductionCl _ p psing prinvcl (sing
                                   x1) = psing x1
    inductionCl _ p psing prinvcl (rinvCl
                                   x1
                                   x2) =
      prinvcl _ _
        (inductionCl _ p psing prinvcl
           x1)
        (inductionCl _ p psing prinvcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpRightInverseMagmaTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRightInverseMagmaTerm
          n)
       (x2 : OpRightInverseMagmaTerm
          n) ->
       P x1 ->
       P x2 -> P (rinvOL x1 x2)) ->
      (x : OpRightInverseMagmaTerm
         n) -> P x
    inductionOp _ p pv prinvol (v
                                x1) = pv x1
    inductionOp _ p pv prinvol (rinvOL
                                x1
                                x2) =
      prinvol _ _
        (inductionOp _ p pv prinvol x1)
        (inductionOp _ p pv prinvol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRightInverseMagmaTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRightInverseMagmaTerm2
          n
          A)
       (x2 : OpRightInverseMagmaTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (rinvOL2 x1 x2)) ->
      (x : OpRightInverseMagmaTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 prinvol2 (v2
                                            x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 prinvol2 (sing2
                                            x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 prinvol2 (rinvOL2
                                            x1
                                            x2) =
      prinvol2 _ _
        (inductionOpE _ _ p pv2 psing2
           prinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           prinvol2
           x2)
    rinvL' :
      RightInverseMagmaTerm ->
      RightInverseMagmaTerm ->
      RightInverseMagmaTerm
    rinvL' x1 x2 = rinvL x1 x2
    stageB :
      RightInverseMagmaTerm ->
      Staged RightInverseMagmaTerm
    stageB (rinvL x1 x2) =
      stage2 _ _ _ rinvL'
        (codeLift2 _ _ _ rinvL')
        (stageB x1)
        (stageB x2)
    rinvCl' :
      (A : Set) ->
      ClRightInverseMagmaTerm A ->
      ClRightInverseMagmaTerm A ->
      ClRightInverseMagmaTerm A
    rinvCl' _ x1 x2 = rinvCl x1 x2
    stageCl :
      (A : Set) ->
      ClRightInverseMagmaTerm A ->
      Staged
        (ClRightInverseMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (rinvCl x1 x2) =
      stage2 _ _ _ (rinvCl' _)
        (codeLift2 _ _ _ (rinvCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    rinvOL' :
      (n : Nat) ->
      OpRightInverseMagmaTerm n ->
      OpRightInverseMagmaTerm n ->
      OpRightInverseMagmaTerm n
    rinvOL' _ x1 x2 = rinvOL x1 x2
    stageOp :
      (n : Nat) ->
      OpRightInverseMagmaTerm n ->
      Staged
        (OpRightInverseMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (rinvOL x1 x2) =
      stage2 _ _ _ (rinvOL' _)
        (codeLift2 _ _ _ (rinvOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    rinvOL2' :
      (n : Nat) (A : Set) ->
      OpRightInverseMagmaTerm2 n A ->
      OpRightInverseMagmaTerm2 n A ->
      OpRightInverseMagmaTerm2 n A
    rinvOL2' _ _ x1 x2 =
      rinvOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRightInverseMagmaTerm2 n A ->
      Staged
        (OpRightInverseMagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (rinvOL2 x1 x2) =
      stage2 _ _ _ (rinvOL2' _ _)
        (codeLift2 _ _ _ (rinvOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RightInverseMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        rinvT :
          Repr A -> Repr A -> Repr A
  
  module RightMonoid where
    record RightMonoid
      (A : Set) : Set where
      constructor RightMonoidC
      field
        op : A -> A -> A
        e : A
        runit_e : (x : A) -> op x e == x
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record RightMonoidSig
      (AS : Set) : Set where
      constructor RightMonoidSigSigC
      field
        opS : AS -> AS -> AS
        eS : AS
    record RightMonoidProd
      (AP : Set) : Set where
      constructor RightMonoidProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        eP : Prod AP AP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record RightMonoidHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightMonoid A1)
      (Ri2 : RightMonoid A2) :
      Set where
      constructor RightMonoidHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
        pres-e : hom (e Ri1) == e Ri2
    record RightMonoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightMonoid A1)
      (Ri2 : RightMonoid A2) :
      Set where
      constructor RightMonoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
        interp-e :
          interp (e Ri1) (e Ri2)
    data RightMonoidTerm : Set where
      opL :
        RightMonoidTerm ->
        RightMonoidTerm ->
        RightMonoidTerm
      eL : RightMonoidTerm
    data ClRightMonoidTerm
      (A : Set) : Set where
      sing :
        A -> ClRightMonoidTerm A
      opCl :
        ClRightMonoidTerm A ->
        ClRightMonoidTerm A ->
        ClRightMonoidTerm A
      eCl : ClRightMonoidTerm A
    data OpRightMonoidTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpRightMonoidTerm n
      opOL :
        OpRightMonoidTerm n ->
        OpRightMonoidTerm n ->
        OpRightMonoidTerm n
      eOL : OpRightMonoidTerm n
    data OpRightMonoidTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpRightMonoidTerm2 n A
      sing2 :
        A -> OpRightMonoidTerm2 n A
      opOL2 :
        OpRightMonoidTerm2 n A ->
        OpRightMonoidTerm2 n A ->
        OpRightMonoidTerm2 n A
      eOL2 : OpRightMonoidTerm2 n A
    simplifyB :
      RightMonoidTerm ->
      RightMonoidTerm
    simplifyB (opL x (eL)) = x
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (eL) = eL
    simplifyCl :
      (A : Set) ->
      ClRightMonoidTerm A ->
      ClRightMonoidTerm A
    simplifyCl _ (opCl x (eCl)) = x
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRightMonoidTerm n ->
      OpRightMonoidTerm n
    simplifyOp _ (opOL x (eOL)) = x
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRightMonoidTerm2 n A ->
      OpRightMonoidTerm2 n A
    simplifyOpE _ _ (opOL2
                     x
                     (eOL2)) = x
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RightMonoid A ->
      RightMonoidTerm -> A
    evalB _ Ri (opL x1 x2) =
      op Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalB _ Ri (eL) = e Ri
    evalCl :
      (A : Set) ->
      RightMonoid A ->
      ClRightMonoidTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (opCl x1 x2) =
      op Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalCl _ Ri (eCl) = e Ri
    evalOp :
      (A : Set) (n : Nat) ->
      RightMonoid A ->
      Vec A n ->
      OpRightMonoidTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (opOL
                        x1
                        x2) =
      op Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOp _ n Ri vars (eOL) = e Ri
    evalOpE :
      (A : Set) (n : Nat) ->
      RightMonoid A ->
      Vec A n ->
      OpRightMonoidTerm2 n A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (opOL2
                         x1
                         x2) =
      op Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    evalOpE _ n Ri vars (eOL2) =
      e Ri
    inductionB :
      (P : RightMonoidTerm -> Set) ->
      ((x1 : RightMonoidTerm)
       (x2 : RightMonoidTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      P eL ->
      (x : RightMonoidTerm) -> P x
    inductionB p popl pel (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p popl pel x1)
        (inductionB p popl pel x2)
    inductionB p popl pel (eL) = pel
    inductionCl :
      (A : Set)
      (P : ClRightMonoidTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRightMonoidTerm A)
       (x2 : ClRightMonoidTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      P eCl ->
      (x : ClRightMonoidTerm A) -> P x
    inductionCl _ p psing popcl pecl (sing
                                      x1) = psing x1
    inductionCl _ p psing popcl pecl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing popcl
           pecl
           x1)
        (inductionCl _ p psing popcl
           pecl
           x2)
    inductionCl _ p psing popcl pecl (eCl) =
      pecl
    inductionOp :
      (n : Nat)
      (P : OpRightMonoidTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRightMonoidTerm n)
       (x2 : OpRightMonoidTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      P eOL ->
      (x : OpRightMonoidTerm n) -> P x
    inductionOp _ p pv popol peol (v
                                   x1) = pv x1
    inductionOp _ p pv popol peol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv popol peol
           x1)
        (inductionOp _ p pv popol peol
           x2)
    inductionOp _ p pv popol peol (eOL) =
      peol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRightMonoidTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRightMonoidTerm2 n A)
       (x2 : OpRightMonoidTerm2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      P eOL2 ->
      (x : OpRightMonoidTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           peol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 peol2 (eOL2) =
      peol2
    opL' :
      RightMonoidTerm ->
      RightMonoidTerm ->
      RightMonoidTerm
    opL' x1 x2 = opL x1 x2
    eL' : RightMonoidTerm
    eL' = eL
    stageB :
      RightMonoidTerm ->
      Staged RightMonoidTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (eL) = Now eL
    opCl' :
      (A : Set) ->
      ClRightMonoidTerm A ->
      ClRightMonoidTerm A ->
      ClRightMonoidTerm A
    opCl' _ x1 x2 = opCl x1 x2
    eCl' :
      (A : Set) -> ClRightMonoidTerm A
    eCl' _ = eCl
    stageCl :
      (A : Set) ->
      ClRightMonoidTerm A ->
      Staged (ClRightMonoidTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (eCl) = Now eCl
    opOL' :
      (n : Nat) ->
      OpRightMonoidTerm n ->
      OpRightMonoidTerm n ->
      OpRightMonoidTerm n
    opOL' _ x1 x2 = opOL x1 x2
    eOL' :
      (n : Nat) -> OpRightMonoidTerm n
    eOL' _ = eOL
    stageOp :
      (n : Nat) ->
      OpRightMonoidTerm n ->
      Staged (OpRightMonoidTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (eOL) = Now eOL
    opOL2' :
      (n : Nat) (A : Set) ->
      OpRightMonoidTerm2 n A ->
      OpRightMonoidTerm2 n A ->
      OpRightMonoidTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    eOL2' :
      (n : Nat) (A : Set) ->
      OpRightMonoidTerm2 n A
    eOL2' _ _ = eOL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRightMonoidTerm2 n A ->
      Staged (OpRightMonoidTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (eOL2) = Now eOL2
    record RightMonoidTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
        eT : Repr A
  
  module RightPreSemiring where
    record RightPreSemiring
      (A : Set) : Set where
      constructor RightPreSemiringC
      field
        * : A -> A -> A
        + : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
    record RightPreSemiringSig
      (AS : Set) : Set where
      constructor RightPreSemiringSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record RightPreSemiringProd
      (AP : Set) : Set where
      constructor RightPreSemiringProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
    record RightPreSemiringHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightPreSemiring A1)
      (Ri2 : RightPreSemiring A2) :
      Set where
      constructor RightPreSemiringHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
    record RightPreSemiringRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightPreSemiring A1)
      (Ri2 : RightPreSemiring A2) :
      Set where
      constructor RightPreSemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
    data RightPreSemiringTerm
      : Set where
      *L :
        RightPreSemiringTerm ->
        RightPreSemiringTerm ->
        RightPreSemiringTerm
      +L :
        RightPreSemiringTerm ->
        RightPreSemiringTerm ->
        RightPreSemiringTerm
    data ClRightPreSemiringTerm
      (A : Set) : Set where
      sing :
        A -> ClRightPreSemiringTerm A
      *Cl :
        ClRightPreSemiringTerm A ->
        ClRightPreSemiringTerm A ->
        ClRightPreSemiringTerm A
      +Cl :
        ClRightPreSemiringTerm A ->
        ClRightPreSemiringTerm A ->
        ClRightPreSemiringTerm A
    data OpRightPreSemiringTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpRightPreSemiringTerm n
      *OL :
        OpRightPreSemiringTerm n ->
        OpRightPreSemiringTerm n ->
        OpRightPreSemiringTerm n
      +OL :
        OpRightPreSemiringTerm n ->
        OpRightPreSemiringTerm n ->
        OpRightPreSemiringTerm n
    data OpRightPreSemiringTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpRightPreSemiringTerm2 n A
      sing2 :
        A -> OpRightPreSemiringTerm2 n A
      *OL2 :
        OpRightPreSemiringTerm2 n A ->
        OpRightPreSemiringTerm2 n A ->
        OpRightPreSemiringTerm2 n A
      +OL2 :
        OpRightPreSemiringTerm2 n A ->
        OpRightPreSemiringTerm2 n A ->
        OpRightPreSemiringTerm2 n A
    simplifyB :
      RightPreSemiringTerm ->
      RightPreSemiringTerm
    simplifyB (+L
               (*L y x)
               (*L z x)) = *L (+L y z) x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRightPreSemiringTerm A ->
      ClRightPreSemiringTerm A
    simplifyCl _ (+Cl
                  (*Cl y x)
                  (*Cl z x)) = *Cl (+Cl y z) x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRightPreSemiringTerm n ->
      OpRightPreSemiringTerm n
    simplifyOp _ (+OL
                  (*OL y x)
                  (*OL z x)) = *OL (+OL y z) x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRightPreSemiringTerm2 n A ->
      OpRightPreSemiringTerm2 n A
    simplifyOpE _ _ (+OL2
                     (*OL2 y x)
                     (*OL2 z x)) = *OL2 (+OL2 y z) x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RightPreSemiring A ->
      RightPreSemiringTerm -> A
    evalB _ Ri (*L x1 x2) =
      * Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalB _ Ri (+L x1 x2) =
      + Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      RightPreSemiring A ->
      ClRightPreSemiringTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (*Cl x1 x2) =
      * Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalCl _ Ri (+Cl x1 x2) =
      + Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RightPreSemiring A ->
      Vec A n ->
      OpRightPreSemiringTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (*OL x1 x2) =
      * Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOp _ n Ri vars (+OL x1 x2) =
      + Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RightPreSemiring A ->
      Vec A n ->
      OpRightPreSemiringTerm2 n A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (*OL2
                         x1
                         x2) =
      * Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    evalOpE _ n Ri vars (+OL2
                         x1
                         x2) =
      + Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RightPreSemiringTerm ->
           Set) ->
      ((x1 : RightPreSemiringTerm)
       (x2 : RightPreSemiringTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : RightPreSemiringTerm)
       (x2 : RightPreSemiringTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : RightPreSemiringTerm) ->
      P x
    inductionB p p*l p+l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionB p p*l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClRightPreSemiringTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRightPreSemiringTerm A)
       (x2 : ClRightPreSemiringTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClRightPreSemiringTerm A)
       (x2 : ClRightPreSemiringTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClRightPreSemiringTerm
         A) -> P x
    inductionCl _ p psing p*cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p*cl p+cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionCl _ p psing p*cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpRightPreSemiringTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRightPreSemiringTerm n)
       (x2 : OpRightPreSemiringTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpRightPreSemiringTerm n)
       (x2 : OpRightPreSemiringTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpRightPreSemiringTerm
         n) -> P x
    inductionOp _ p pv p*ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p*ol p+ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOp _ p pv p*ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRightPreSemiringTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRightPreSemiringTerm2 n
          A)
       (x2 : OpRightPreSemiringTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpRightPreSemiringTerm2 n
          A)
       (x2 : OpRightPreSemiringTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpRightPreSemiringTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    *L' :
      RightPreSemiringTerm ->
      RightPreSemiringTerm ->
      RightPreSemiringTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      RightPreSemiringTerm ->
      RightPreSemiringTerm ->
      RightPreSemiringTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      RightPreSemiringTerm ->
      Staged RightPreSemiringTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClRightPreSemiringTerm A ->
      ClRightPreSemiringTerm A ->
      ClRightPreSemiringTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClRightPreSemiringTerm A ->
      ClRightPreSemiringTerm A ->
      ClRightPreSemiringTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClRightPreSemiringTerm A ->
      Staged
        (ClRightPreSemiringTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpRightPreSemiringTerm n ->
      OpRightPreSemiringTerm n ->
      OpRightPreSemiringTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpRightPreSemiringTerm n ->
      OpRightPreSemiringTerm n ->
      OpRightPreSemiringTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpRightPreSemiringTerm n ->
      Staged
        (OpRightPreSemiringTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpRightPreSemiringTerm2 n A ->
      OpRightPreSemiringTerm2 n A ->
      OpRightPreSemiringTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpRightPreSemiringTerm2 n A ->
      OpRightPreSemiringTerm2 n A ->
      OpRightPreSemiringTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRightPreSemiringTerm2 n A ->
      Staged
        (OpRightPreSemiringTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RightPreSemiringTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module RightQuasiGroup where
    record RightQuasiGroup
      (A : Set) : Set where
      constructor RightQuasiGroupC
      field
        op : A -> A -> A
        rinv : A -> A -> A
        rightCancel :
          (x : A) (y : A) ->
          op (rinv y x) x == y
        rightCancelOp :
          (x : A) (y : A) ->
          rinv (op y x) x == y
    record RightQuasiGroupSig
      (AS : Set) : Set where
      constructor RightQuasiGroupSigSigC
      field
        opS : AS -> AS -> AS
        rinvS : AS -> AS -> AS
    record RightQuasiGroupProd
      (AP : Set) : Set where
      constructor RightQuasiGroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rinvP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightCancelP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP (rinvP yP xP) xP == yP
        rightCancelOpP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          rinvP (opP yP xP) xP == yP
    record RightQuasiGroupHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightQuasiGroup A1)
      (Ri2 : RightQuasiGroup A2) :
      Set where
      constructor RightQuasiGroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
        pres-rinv :
          (x1 : A1) (x2 : A1) ->
          hom (rinv Ri1 x1 x2) ==
            rinv Ri2 (hom x1) (hom x2)
    record RightQuasiGroupRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightQuasiGroup A1)
      (Ri2 : RightQuasiGroup A2) :
      Set where
      constructor RightQuasiGroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
        interp-rinv :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (rinv Ri1 x1 x2)
            (rinv Ri2 y1 y2)
    data RightQuasiGroupTerm
      : Set where
      opL :
        RightQuasiGroupTerm ->
        RightQuasiGroupTerm ->
        RightQuasiGroupTerm
      rinvL :
        RightQuasiGroupTerm ->
        RightQuasiGroupTerm ->
        RightQuasiGroupTerm
    data ClRightQuasiGroupTerm
      (A : Set) : Set where
      sing :
        A -> ClRightQuasiGroupTerm A
      opCl :
        ClRightQuasiGroupTerm A ->
        ClRightQuasiGroupTerm A ->
        ClRightQuasiGroupTerm A
      rinvCl :
        ClRightQuasiGroupTerm A ->
        ClRightQuasiGroupTerm A ->
        ClRightQuasiGroupTerm A
    data OpRightQuasiGroupTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpRightQuasiGroupTerm n
      opOL :
        OpRightQuasiGroupTerm n ->
        OpRightQuasiGroupTerm n ->
        OpRightQuasiGroupTerm n
      rinvOL :
        OpRightQuasiGroupTerm n ->
        OpRightQuasiGroupTerm n ->
        OpRightQuasiGroupTerm n
    data OpRightQuasiGroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpRightQuasiGroupTerm2 n A
      sing2 :
        A -> OpRightQuasiGroupTerm2 n A
      opOL2 :
        OpRightQuasiGroupTerm2 n A ->
        OpRightQuasiGroupTerm2 n A ->
        OpRightQuasiGroupTerm2 n A
      rinvOL2 :
        OpRightQuasiGroupTerm2 n A ->
        OpRightQuasiGroupTerm2 n A ->
        OpRightQuasiGroupTerm2 n A
    simplifyB :
      RightQuasiGroupTerm ->
      RightQuasiGroupTerm
    simplifyB (opL (rinvL y x) x) =
      y
    simplifyB (rinvL (opL y x) x) =
      y
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyB (rinvL x1 x2) =
      rinvL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRightQuasiGroupTerm A ->
      ClRightQuasiGroupTerm A
    simplifyCl _ (opCl
                  (rinvCl y x)
                  x) = y
    simplifyCl _ (rinvCl
                  (opCl y x)
                  x) = y
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (rinvCl x1 x2) =
      rinvCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRightQuasiGroupTerm n ->
      OpRightQuasiGroupTerm n
    simplifyOp _ (opOL
                  (rinvOL y x)
                  x) = y
    simplifyOp _ (rinvOL
                  (opOL y x)
                  x) = y
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (rinvOL x1 x2) =
      rinvOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRightQuasiGroupTerm2 n A ->
      OpRightQuasiGroupTerm2 n A
    simplifyOpE _ _ (opOL2
                     (rinvOL2 y x)
                     x) = y
    simplifyOpE _ _ (rinvOL2
                     (opOL2 y x)
                     x) = y
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (rinvOL2
                     x1
                     x2) =
      rinvOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RightQuasiGroup A ->
      RightQuasiGroupTerm -> A
    evalB _ Ri (opL x1 x2) =
      op Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalB _ Ri (rinvL x1 x2) =
      rinv Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      RightQuasiGroup A ->
      ClRightQuasiGroupTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (opCl x1 x2) =
      op Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalCl _ Ri (rinvCl x1 x2) =
      rinv Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RightQuasiGroup A ->
      Vec A n ->
      OpRightQuasiGroupTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (opOL
                        x1
                        x2) =
      op Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOp _ n Ri vars (rinvOL
                        x1
                        x2) =
      rinv Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RightQuasiGroup A ->
      Vec A n ->
      OpRightQuasiGroupTerm2 n A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (opOL2
                         x1
                         x2) =
      op Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    evalOpE _ n Ri vars (rinvOL2
                         x1
                         x2) =
      rinv Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RightQuasiGroupTerm ->
           Set) ->
      ((x1 : RightQuasiGroupTerm)
       (x2 : RightQuasiGroupTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      ((x1 : RightQuasiGroupTerm)
       (x2 : RightQuasiGroupTerm) ->
       P x1 ->
       P x2 -> P (rinvL x1 x2)) ->
      (x : RightQuasiGroupTerm) -> P x
    inductionB p popl prinvl (opL
                              x1
                              x2) =
      popl _ _
        (inductionB p popl prinvl x1)
        (inductionB p popl prinvl x2)
    inductionB p popl prinvl (rinvL
                              x1
                              x2) =
      prinvl _ _
        (inductionB p popl prinvl x1)
        (inductionB p popl prinvl x2)
    inductionCl :
      (A : Set)
      (P : ClRightQuasiGroupTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRightQuasiGroupTerm A)
       (x2 : ClRightQuasiGroupTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      ((x1 : ClRightQuasiGroupTerm A)
       (x2 : ClRightQuasiGroupTerm
          A) ->
       P x1 ->
       P x2 -> P (rinvCl x1 x2)) ->
      (x : ClRightQuasiGroupTerm A) ->
      P x
    inductionCl _ p psing popcl prinvcl (sing
                                         x1) = psing x1
    inductionCl _ p psing popcl prinvcl (opCl
                                         x1
                                         x2) =
      popcl _ _
        (inductionCl _ p psing popcl
           prinvcl
           x1)
        (inductionCl _ p psing popcl
           prinvcl
           x2)
    inductionCl _ p psing popcl prinvcl (rinvCl
                                         x1
                                         x2) =
      prinvcl _ _
        (inductionCl _ p psing popcl
           prinvcl
           x1)
        (inductionCl _ p psing popcl
           prinvcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpRightQuasiGroupTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRightQuasiGroupTerm n)
       (x2 : OpRightQuasiGroupTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      ((x1 : OpRightQuasiGroupTerm n)
       (x2 : OpRightQuasiGroupTerm
          n) ->
       P x1 ->
       P x2 -> P (rinvOL x1 x2)) ->
      (x : OpRightQuasiGroupTerm n) ->
      P x
    inductionOp _ p pv popol prinvol (v
                                      x1) = pv x1
    inductionOp _ p pv popol prinvol (opOL
                                      x1
                                      x2) =
      popol _ _
        (inductionOp _ p pv popol
           prinvol
           x1)
        (inductionOp _ p pv popol
           prinvol
           x2)
    inductionOp _ p pv popol prinvol (rinvOL
                                      x1
                                      x2) =
      prinvol _ _
        (inductionOp _ p pv popol
           prinvol
           x1)
        (inductionOp _ p pv popol
           prinvol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRightQuasiGroupTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRightQuasiGroupTerm2 n
          A)
       (x2 : OpRightQuasiGroupTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      ((x1 : OpRightQuasiGroupTerm2 n
          A)
       (x2 : OpRightQuasiGroupTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (rinvOL2 x1 x2)) ->
      (x : OpRightQuasiGroupTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 prinvol2 (v2
                                                   x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 prinvol2 (sing2
                                                   x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 prinvol2 (opOL2
                                                   x1
                                                   x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           prinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           prinvol2
           x2)
    inductionOpE _ _ p pv2 psing2 popol2 prinvol2 (rinvOL2
                                                   x1
                                                   x2) =
      prinvol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           prinvol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           prinvol2
           x2)
    opL' :
      RightQuasiGroupTerm ->
      RightQuasiGroupTerm ->
      RightQuasiGroupTerm
    opL' x1 x2 = opL x1 x2
    rinvL' :
      RightQuasiGroupTerm ->
      RightQuasiGroupTerm ->
      RightQuasiGroupTerm
    rinvL' x1 x2 = rinvL x1 x2
    stageB :
      RightQuasiGroupTerm ->
      Staged RightQuasiGroupTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    stageB (rinvL x1 x2) =
      stage2 _ _ _ rinvL'
        (codeLift2 _ _ _ rinvL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClRightQuasiGroupTerm A ->
      ClRightQuasiGroupTerm A ->
      ClRightQuasiGroupTerm A
    opCl' _ x1 x2 = opCl x1 x2
    rinvCl' :
      (A : Set) ->
      ClRightQuasiGroupTerm A ->
      ClRightQuasiGroupTerm A ->
      ClRightQuasiGroupTerm A
    rinvCl' _ x1 x2 = rinvCl x1 x2
    stageCl :
      (A : Set) ->
      ClRightQuasiGroupTerm A ->
      Staged (ClRightQuasiGroupTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (rinvCl x1 x2) =
      stage2 _ _ _ (rinvCl' _)
        (codeLift2 _ _ _ (rinvCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpRightQuasiGroupTerm n ->
      OpRightQuasiGroupTerm n ->
      OpRightQuasiGroupTerm n
    opOL' _ x1 x2 = opOL x1 x2
    rinvOL' :
      (n : Nat) ->
      OpRightQuasiGroupTerm n ->
      OpRightQuasiGroupTerm n ->
      OpRightQuasiGroupTerm n
    rinvOL' _ x1 x2 = rinvOL x1 x2
    stageOp :
      (n : Nat) ->
      OpRightQuasiGroupTerm n ->
      Staged (OpRightQuasiGroupTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (rinvOL x1 x2) =
      stage2 _ _ _ (rinvOL' _)
        (codeLift2 _ _ _ (rinvOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpRightQuasiGroupTerm2 n A ->
      OpRightQuasiGroupTerm2 n A ->
      OpRightQuasiGroupTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    rinvOL2' :
      (n : Nat) (A : Set) ->
      OpRightQuasiGroupTerm2 n A ->
      OpRightQuasiGroupTerm2 n A ->
      OpRightQuasiGroupTerm2 n A
    rinvOL2' _ _ x1 x2 =
      rinvOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRightQuasiGroupTerm2 n A ->
      Staged
        (OpRightQuasiGroupTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (rinvOL2 x1 x2) =
      stage2 _ _ _ (rinvOL2' _ _)
        (codeLift2 _ _ _ (rinvOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RightQuasiGroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
        rinvT :
          Repr A -> Repr A -> Repr A
  
  module RightRack where
    record RightRack
      (A : Set) : Set where
      constructor RightRackC
      field
        <| : A -> A -> A
        |> : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
    record RightRackSig
      (AS : Set) : Set where
      constructor RightRackSigSigC
      field
        <|S : AS -> AS -> AS
        |>S : AS -> AS -> AS
    record RightRackProd
      (AP : Set) : Set where
      constructor RightRackProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
    record RightRackHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightRack A1)
      (Ri2 : RightRack A2) : Set where
      constructor RightRackHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ri1 x1 x2) ==
            |> Ri2 (hom x1) (hom x2)
    record RightRackRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightRack A1)
      (Ri2 : RightRack A2) : Set where
      constructor RightRackRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ri1 x1 x2)
            (|> Ri2 y1 y2)
    data RightRackTerm : Set where
      <|L :
        RightRackTerm ->
        RightRackTerm -> RightRackTerm
      |>L :
        RightRackTerm ->
        RightRackTerm -> RightRackTerm
    data ClRightRackTerm
      (A : Set) : Set where
      sing : A -> ClRightRackTerm A
      <|Cl :
        ClRightRackTerm A ->
        ClRightRackTerm A ->
        ClRightRackTerm A
      |>Cl :
        ClRightRackTerm A ->
        ClRightRackTerm A ->
        ClRightRackTerm A
    data OpRightRackTerm
      (n : Nat) : Set where
      v : Fin n -> OpRightRackTerm n
      <|OL :
        OpRightRackTerm n ->
        OpRightRackTerm n ->
        OpRightRackTerm n
      |>OL :
        OpRightRackTerm n ->
        OpRightRackTerm n ->
        OpRightRackTerm n
    data OpRightRackTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpRightRackTerm2 n A
      sing2 :
        A -> OpRightRackTerm2 n A
      <|OL2 :
        OpRightRackTerm2 n A ->
        OpRightRackTerm2 n A ->
        OpRightRackTerm2 n A
      |>OL2 :
        OpRightRackTerm2 n A ->
        OpRightRackTerm2 n A ->
        OpRightRackTerm2 n A
    simplifyB :
      RightRackTerm -> RightRackTerm
    simplifyB (<|L
               (<|L y x)
               (<|L z x)) = <|L (<|L y z) x
    simplifyB (<|L x1 x2) =
      <|L (simplifyB x1)
        (simplifyB x2)
    simplifyB (|>L x1 x2) =
      |>L (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRightRackTerm A ->
      ClRightRackTerm A
    simplifyCl _ (<|Cl
                  (<|Cl y x)
                  (<|Cl z x)) = <|Cl (<|Cl y z) x
    simplifyCl _ (<|Cl x1 x2) =
      <|Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (|>Cl x1 x2) =
      |>Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRightRackTerm n ->
      OpRightRackTerm n
    simplifyOp _ (<|OL
                  (<|OL y x)
                  (<|OL z x)) = <|OL (<|OL y z) x
    simplifyOp _ (<|OL x1 x2) =
      <|OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (|>OL x1 x2) =
      |>OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRightRackTerm2 n A ->
      OpRightRackTerm2 n A
    simplifyOpE _ _ (<|OL2
                     (<|OL2 y x)
                     (<|OL2 z x)) =
      <|OL2 (<|OL2 y z) x
    simplifyOpE _ _ (<|OL2 x1 x2) =
      <|OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (|>OL2 x1 x2) =
      |>OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RightRack A ->
      RightRackTerm -> A
    evalB _ Ri (<|L x1 x2) =
      <| Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalB _ Ri (|>L x1 x2) =
      |> Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      RightRack A ->
      ClRightRackTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (<|Cl x1 x2) =
      <| Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalCl _ Ri (|>Cl x1 x2) =
      |> Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RightRack A ->
      Vec A n ->
      OpRightRackTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (<|OL
                        x1
                        x2) =
      <| Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOp _ n Ri vars (|>OL
                        x1
                        x2) =
      |> Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RightRack A ->
      Vec A n ->
      OpRightRackTerm2 n A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (<|OL2
                         x1
                         x2) =
      <| Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    evalOpE _ n Ri vars (|>OL2
                         x1
                         x2) =
      |> Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RightRackTerm -> Set) ->
      ((x1 : RightRackTerm)
       (x2 : RightRackTerm) ->
       P x1 ->
       P x2 -> P (<|L x1 x2)) ->
      ((x1 : RightRackTerm)
       (x2 : RightRackTerm) ->
       P x1 ->
       P x2 -> P (|>L x1 x2)) ->
      (x : RightRackTerm) -> P x
    inductionB p p<|l p|>l (<|L
                            x1
                            x2) =
      p<|l _ _
        (inductionB p p<|l p|>l x1)
        (inductionB p p<|l p|>l x2)
    inductionB p p<|l p|>l (|>L
                            x1
                            x2) =
      p|>l _ _
        (inductionB p p<|l p|>l x1)
        (inductionB p p<|l p|>l x2)
    inductionCl :
      (A : Set)
      (P : ClRightRackTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRightRackTerm A)
       (x2 : ClRightRackTerm A) ->
       P x1 ->
       P x2 -> P (<|Cl x1 x2)) ->
      ((x1 : ClRightRackTerm A)
       (x2 : ClRightRackTerm A) ->
       P x1 ->
       P x2 -> P (|>Cl x1 x2)) ->
      (x : ClRightRackTerm A) -> P x
    inductionCl _ p psing p<|cl p|>cl (sing
                                       x1) = psing x1
    inductionCl _ p psing p<|cl p|>cl (<|Cl
                                       x1
                                       x2) =
      p<|cl _ _
        (inductionCl _ p psing p<|cl
           p|>cl
           x1)
        (inductionCl _ p psing p<|cl
           p|>cl
           x2)
    inductionCl _ p psing p<|cl p|>cl (|>Cl
                                       x1
                                       x2) =
      p|>cl _ _
        (inductionCl _ p psing p<|cl
           p|>cl
           x1)
        (inductionCl _ p psing p<|cl
           p|>cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpRightRackTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRightRackTerm n)
       (x2 : OpRightRackTerm n) ->
       P x1 ->
       P x2 -> P (<|OL x1 x2)) ->
      ((x1 : OpRightRackTerm n)
       (x2 : OpRightRackTerm n) ->
       P x1 ->
       P x2 -> P (|>OL x1 x2)) ->
      (x : OpRightRackTerm n) -> P x
    inductionOp _ p pv p<|ol p|>ol (v
                                    x1) = pv x1
    inductionOp _ p pv p<|ol p|>ol (<|OL
                                    x1
                                    x2) =
      p<|ol _ _
        (inductionOp _ p pv p<|ol p|>ol
           x1)
        (inductionOp _ p pv p<|ol p|>ol
           x2)
    inductionOp _ p pv p<|ol p|>ol (|>OL
                                    x1
                                    x2) =
      p|>ol _ _
        (inductionOp _ p pv p<|ol p|>ol
           x1)
        (inductionOp _ p pv p<|ol p|>ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRightRackTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRightRackTerm2 n A)
       (x2 : OpRightRackTerm2 n A) ->
       P x1 ->
       P x2 -> P (<|OL2 x1 x2)) ->
      ((x1 : OpRightRackTerm2 n A)
       (x2 : OpRightRackTerm2 n A) ->
       P x1 ->
       P x2 -> P (|>OL2 x1 x2)) ->
      (x : OpRightRackTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p<|ol2 p|>ol2 (v2
                                                 x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p<|ol2 p|>ol2 (sing2
                                                 x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p<|ol2 p|>ol2 (<|OL2
                                                 x1
                                                 x2) =
      p<|ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p<|ol2
           p|>ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p<|ol2
           p|>ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p<|ol2 p|>ol2 (|>OL2
                                                 x1
                                                 x2) =
      p|>ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p<|ol2
           p|>ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p<|ol2
           p|>ol2
           x2)
    <|L' :
      RightRackTerm ->
      RightRackTerm -> RightRackTerm
    <|L' x1 x2 = <|L x1 x2
    |>L' :
      RightRackTerm ->
      RightRackTerm -> RightRackTerm
    |>L' x1 x2 = |>L x1 x2
    stageB :
      RightRackTerm ->
      Staged RightRackTerm
    stageB (<|L x1 x2) =
      stage2 _ _ _ <|L'
        (codeLift2 _ _ _ <|L')
        (stageB x1)
        (stageB x2)
    stageB (|>L x1 x2) =
      stage2 _ _ _ |>L'
        (codeLift2 _ _ _ |>L')
        (stageB x1)
        (stageB x2)
    <|Cl' :
      (A : Set) ->
      ClRightRackTerm A ->
      ClRightRackTerm A ->
      ClRightRackTerm A
    <|Cl' _ x1 x2 = <|Cl x1 x2
    |>Cl' :
      (A : Set) ->
      ClRightRackTerm A ->
      ClRightRackTerm A ->
      ClRightRackTerm A
    |>Cl' _ x1 x2 = |>Cl x1 x2
    stageCl :
      (A : Set) ->
      ClRightRackTerm A ->
      Staged (ClRightRackTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (<|Cl x1 x2) =
      stage2 _ _ _ (<|Cl' _)
        (codeLift2 _ _ _ (<|Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (|>Cl x1 x2) =
      stage2 _ _ _ (|>Cl' _)
        (codeLift2 _ _ _ (|>Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    <|OL' :
      (n : Nat) ->
      OpRightRackTerm n ->
      OpRightRackTerm n ->
      OpRightRackTerm n
    <|OL' _ x1 x2 = <|OL x1 x2
    |>OL' :
      (n : Nat) ->
      OpRightRackTerm n ->
      OpRightRackTerm n ->
      OpRightRackTerm n
    |>OL' _ x1 x2 = |>OL x1 x2
    stageOp :
      (n : Nat) ->
      OpRightRackTerm n ->
      Staged (OpRightRackTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (<|OL x1 x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (|>OL x1 x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    <|OL2' :
      (n : Nat) (A : Set) ->
      OpRightRackTerm2 n A ->
      OpRightRackTerm2 n A ->
      OpRightRackTerm2 n A
    <|OL2' _ _ x1 x2 = <|OL2 x1 x2
    |>OL2' :
      (n : Nat) (A : Set) ->
      OpRightRackTerm2 n A ->
      OpRightRackTerm2 n A ->
      OpRightRackTerm2 n A
    |>OL2' _ _ x1 x2 = |>OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRightRackTerm2 n A ->
      Staged (OpRightRackTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (<|OL2 x1 x2) =
      stage2 _ _ _ (<|OL2' _ _)
        (codeLift2 _ _ _ (<|OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (|>OL2 x1 x2) =
      stage2 _ _ _ (|>OL2' _ _)
        (codeLift2 _ _ _ (|>OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RightRackTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        <|T : Repr A -> Repr A -> Repr A
        |>T : Repr A -> Repr A -> Repr A
  
  module RightRingoid where
    record RightRingoid
      (A : Set) : Set where
      constructor RightRingoidC
      field
        * : A -> A -> A
        + : A -> A -> A
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record RightRingoidSig
      (AS : Set) : Set where
      constructor RightRingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record RightRingoidProd
      (AP : Set) : Set where
      constructor RightRingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record RightRingoidHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightRingoid A1)
      (Ri2 : RightRingoid A2) :
      Set where
      constructor RightRingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
    record RightRingoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightRingoid A1)
      (Ri2 : RightRingoid A2) :
      Set where
      constructor RightRingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
    data RightRingoidTerm
      : Set where
      *L :
        RightRingoidTerm ->
        RightRingoidTerm ->
        RightRingoidTerm
      +L :
        RightRingoidTerm ->
        RightRingoidTerm ->
        RightRingoidTerm
    data ClRightRingoidTerm
      (A : Set) : Set where
      sing :
        A -> ClRightRingoidTerm A
      *Cl :
        ClRightRingoidTerm A ->
        ClRightRingoidTerm A ->
        ClRightRingoidTerm A
      +Cl :
        ClRightRingoidTerm A ->
        ClRightRingoidTerm A ->
        ClRightRingoidTerm A
    data OpRightRingoidTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpRightRingoidTerm n
      *OL :
        OpRightRingoidTerm n ->
        OpRightRingoidTerm n ->
        OpRightRingoidTerm n
      +OL :
        OpRightRingoidTerm n ->
        OpRightRingoidTerm n ->
        OpRightRingoidTerm n
    data OpRightRingoidTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpRightRingoidTerm2 n A
      sing2 :
        A -> OpRightRingoidTerm2 n A
      *OL2 :
        OpRightRingoidTerm2 n A ->
        OpRightRingoidTerm2 n A ->
        OpRightRingoidTerm2 n A
      +OL2 :
        OpRightRingoidTerm2 n A ->
        OpRightRingoidTerm2 n A ->
        OpRightRingoidTerm2 n A
    simplifyB :
      RightRingoidTerm ->
      RightRingoidTerm
    simplifyB (+L
               (*L y x)
               (*L z x)) = *L (+L y z) x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRightRingoidTerm A ->
      ClRightRingoidTerm A
    simplifyCl _ (+Cl
                  (*Cl y x)
                  (*Cl z x)) = *Cl (+Cl y z) x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRightRingoidTerm n ->
      OpRightRingoidTerm n
    simplifyOp _ (+OL
                  (*OL y x)
                  (*OL z x)) = *OL (+OL y z) x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRightRingoidTerm2 n A ->
      OpRightRingoidTerm2 n A
    simplifyOpE _ _ (+OL2
                     (*OL2 y x)
                     (*OL2 z x)) = *OL2 (+OL2 y z) x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RightRingoid A ->
      RightRingoidTerm -> A
    evalB _ Ri (*L x1 x2) =
      * Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalB _ Ri (+L x1 x2) =
      + Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      RightRingoid A ->
      ClRightRingoidTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (*Cl x1 x2) =
      * Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalCl _ Ri (+Cl x1 x2) =
      + Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RightRingoid A ->
      Vec A n ->
      OpRightRingoidTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (*OL x1 x2) =
      * Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOp _ n Ri vars (+OL x1 x2) =
      + Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RightRingoid A ->
      Vec A n ->
      OpRightRingoidTerm2 n A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (*OL2
                         x1
                         x2) =
      * Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    evalOpE _ n Ri vars (+OL2
                         x1
                         x2) =
      + Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RightRingoidTerm -> Set) ->
      ((x1 : RightRingoidTerm)
       (x2 : RightRingoidTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : RightRingoidTerm)
       (x2 : RightRingoidTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : RightRingoidTerm) -> P x
    inductionB p p*l p+l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionB p p*l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClRightRingoidTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRightRingoidTerm A)
       (x2 : ClRightRingoidTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClRightRingoidTerm A)
       (x2 : ClRightRingoidTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClRightRingoidTerm A) ->
      P x
    inductionCl _ p psing p*cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p*cl p+cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionCl _ p psing p*cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpRightRingoidTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRightRingoidTerm n)
       (x2 : OpRightRingoidTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpRightRingoidTerm n)
       (x2 : OpRightRingoidTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpRightRingoidTerm n) ->
      P x
    inductionOp _ p pv p*ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p*ol p+ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOp _ p pv p*ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRightRingoidTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRightRingoidTerm2 n A)
       (x2 : OpRightRingoidTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpRightRingoidTerm2 n A)
       (x2 : OpRightRingoidTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpRightRingoidTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    *L' :
      RightRingoidTerm ->
      RightRingoidTerm ->
      RightRingoidTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      RightRingoidTerm ->
      RightRingoidTerm ->
      RightRingoidTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      RightRingoidTerm ->
      Staged RightRingoidTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClRightRingoidTerm A ->
      ClRightRingoidTerm A ->
      ClRightRingoidTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClRightRingoidTerm A ->
      ClRightRingoidTerm A ->
      ClRightRingoidTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClRightRingoidTerm A ->
      Staged (ClRightRingoidTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpRightRingoidTerm n ->
      OpRightRingoidTerm n ->
      OpRightRingoidTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpRightRingoidTerm n ->
      OpRightRingoidTerm n ->
      OpRightRingoidTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpRightRingoidTerm n ->
      Staged (OpRightRingoidTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpRightRingoidTerm2 n A ->
      OpRightRingoidTerm2 n A ->
      OpRightRingoidTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpRightRingoidTerm2 n A ->
      OpRightRingoidTerm2 n A ->
      OpRightRingoidTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRightRingoidTerm2 n A ->
      Staged (OpRightRingoidTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RightRingoidTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module RightSelfInverse where
    record RightSelfInverse
      (A : Set) : Set where
      constructor RightSelfInverseC
      field
        |> : A -> A -> A
        rightSelfInverse_|> :
          (x : A) (y : A) ->
          |> (|> x y) y == x
    record RightSelfInverseSig
      (AS : Set) : Set where
      constructor RightSelfInverseSigSigC
      field
        |>S : AS -> AS -> AS
    record RightSelfInverseProd
      (AP : Set) : Set where
      constructor RightSelfInverseProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightSelfInverse_|>P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          |>P (|>P xP yP) yP == xP
    record RightSelfInverseHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSelfInverse A1)
      (Ri2 : RightSelfInverse A2) :
      Set where
      constructor RightSelfInverseHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ri1 x1 x2) ==
            |> Ri2 (hom x1) (hom x2)
    record RightSelfInverseRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSelfInverse A1)
      (Ri2 : RightSelfInverse A2) :
      Set where
      constructor RightSelfInverseRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ri1 x1 x2)
            (|> Ri2 y1 y2)
    data RightSelfInverseTerm
      : Set where
      |>L :
        RightSelfInverseTerm ->
        RightSelfInverseTerm ->
        RightSelfInverseTerm
    data ClRightSelfInverseTerm
      (A : Set) : Set where
      sing :
        A -> ClRightSelfInverseTerm A
      |>Cl :
        ClRightSelfInverseTerm A ->
        ClRightSelfInverseTerm A ->
        ClRightSelfInverseTerm A
    data OpRightSelfInverseTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpRightSelfInverseTerm n
      |>OL :
        OpRightSelfInverseTerm n ->
        OpRightSelfInverseTerm n ->
        OpRightSelfInverseTerm n
    data OpRightSelfInverseTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpRightSelfInverseTerm2 n A
      sing2 :
        A -> OpRightSelfInverseTerm2 n A
      |>OL2 :
        OpRightSelfInverseTerm2 n A ->
        OpRightSelfInverseTerm2 n A ->
        OpRightSelfInverseTerm2 n A
    simplifyB :
      RightSelfInverseTerm ->
      RightSelfInverseTerm
    simplifyB (|>L (|>L x y) y) = x
    simplifyB (|>L x1 x2) =
      |>L (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRightSelfInverseTerm A ->
      ClRightSelfInverseTerm A
    simplifyCl _ (|>Cl
                  (|>Cl x y)
                  y) = x
    simplifyCl _ (|>Cl x1 x2) =
      |>Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRightSelfInverseTerm n ->
      OpRightSelfInverseTerm n
    simplifyOp _ (|>OL
                  (|>OL x y)
                  y) = x
    simplifyOp _ (|>OL x1 x2) =
      |>OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRightSelfInverseTerm2 n A ->
      OpRightSelfInverseTerm2 n A
    simplifyOpE _ _ (|>OL2
                     (|>OL2 x y)
                     y) = x
    simplifyOpE _ _ (|>OL2 x1 x2) =
      |>OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RightSelfInverse A ->
      RightSelfInverseTerm -> A
    evalB _ Ri (|>L x1 x2) =
      |> Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      RightSelfInverse A ->
      ClRightSelfInverseTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (|>Cl x1 x2) =
      |> Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RightSelfInverse A ->
      Vec A n ->
      OpRightSelfInverseTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (|>OL
                        x1
                        x2) =
      |> Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RightSelfInverse A ->
      Vec A n ->
      OpRightSelfInverseTerm2 n A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (|>OL2
                         x1
                         x2) =
      |> Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RightSelfInverseTerm ->
           Set) ->
      ((x1 : RightSelfInverseTerm)
       (x2 : RightSelfInverseTerm) ->
       P x1 ->
       P x2 -> P (|>L x1 x2)) ->
      (x : RightSelfInverseTerm) ->
      P x
    inductionB p p|>l (|>L x1 x2) =
      p|>l _ _ (inductionB p p|>l x1)
        (inductionB p p|>l x2)
    inductionCl :
      (A : Set)
      (P : ClRightSelfInverseTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRightSelfInverseTerm A)
       (x2 : ClRightSelfInverseTerm
          A) ->
       P x1 ->
       P x2 -> P (|>Cl x1 x2)) ->
      (x : ClRightSelfInverseTerm
         A) -> P x
    inductionCl _ p psing p|>cl (sing
                                 x1) = psing x1
    inductionCl _ p psing p|>cl (|>Cl
                                 x1
                                 x2) =
      p|>cl _ _
        (inductionCl _ p psing p|>cl x1)
        (inductionCl _ p psing p|>cl x2)
    inductionOp :
      (n : Nat)
      (P : OpRightSelfInverseTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRightSelfInverseTerm n)
       (x2 : OpRightSelfInverseTerm
          n) ->
       P x1 ->
       P x2 -> P (|>OL x1 x2)) ->
      (x : OpRightSelfInverseTerm
         n) -> P x
    inductionOp _ p pv p|>ol (v
                              x1) = pv x1
    inductionOp _ p pv p|>ol (|>OL
                              x1
                              x2) =
      p|>ol _ _
        (inductionOp _ p pv p|>ol x1)
        (inductionOp _ p pv p|>ol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRightSelfInverseTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRightSelfInverseTerm2 n
          A)
       (x2 : OpRightSelfInverseTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (|>OL2 x1 x2)) ->
      (x : OpRightSelfInverseTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p|>ol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 (|>OL2
                                          x1
                                          x2) =
      p|>ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           x2)
    |>L' :
      RightSelfInverseTerm ->
      RightSelfInverseTerm ->
      RightSelfInverseTerm
    |>L' x1 x2 = |>L x1 x2
    stageB :
      RightSelfInverseTerm ->
      Staged RightSelfInverseTerm
    stageB (|>L x1 x2) =
      stage2 _ _ _ |>L'
        (codeLift2 _ _ _ |>L')
        (stageB x1)
        (stageB x2)
    |>Cl' :
      (A : Set) ->
      ClRightSelfInverseTerm A ->
      ClRightSelfInverseTerm A ->
      ClRightSelfInverseTerm A
    |>Cl' _ x1 x2 = |>Cl x1 x2
    stageCl :
      (A : Set) ->
      ClRightSelfInverseTerm A ->
      Staged
        (ClRightSelfInverseTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (|>Cl x1 x2) =
      stage2 _ _ _ (|>Cl' _)
        (codeLift2 _ _ _ (|>Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    |>OL' :
      (n : Nat) ->
      OpRightSelfInverseTerm n ->
      OpRightSelfInverseTerm n ->
      OpRightSelfInverseTerm n
    |>OL' _ x1 x2 = |>OL x1 x2
    stageOp :
      (n : Nat) ->
      OpRightSelfInverseTerm n ->
      Staged
        (OpRightSelfInverseTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (|>OL x1 x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    |>OL2' :
      (n : Nat) (A : Set) ->
      OpRightSelfInverseTerm2 n A ->
      OpRightSelfInverseTerm2 n A ->
      OpRightSelfInverseTerm2 n A
    |>OL2' _ _ x1 x2 = |>OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRightSelfInverseTerm2 n A ->
      Staged
        (OpRightSelfInverseTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (|>OL2 x1 x2) =
      stage2 _ _ _ (|>OL2' _ _)
        (codeLift2 _ _ _ (|>OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RightSelfInverseTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        |>T : Repr A -> Repr A -> Repr A
  
  module RightShelf where
    record RightShelf
      (A : Set) : Set where
      constructor RightShelfC
      field
        <| : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
    record RightShelfSig
      (AS : Set) : Set where
      constructor RightShelfSigSigC
      field
        <|S : AS -> AS -> AS
    record RightShelfProd
      (AP : Set) : Set where
      constructor RightShelfProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
    record RightShelfHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightShelf A1)
      (Ri2 : RightShelf A2) :
      Set where
      constructor RightShelfHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
    record RightShelfRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightShelf A1)
      (Ri2 : RightShelf A2) :
      Set where
      constructor RightShelfRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
    data RightShelfTerm : Set where
      <|L :
        RightShelfTerm ->
        RightShelfTerm -> RightShelfTerm
    data ClRightShelfTerm
      (A : Set) : Set where
      sing : A -> ClRightShelfTerm A
      <|Cl :
        ClRightShelfTerm A ->
        ClRightShelfTerm A ->
        ClRightShelfTerm A
    data OpRightShelfTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpRightShelfTerm n
      <|OL :
        OpRightShelfTerm n ->
        OpRightShelfTerm n ->
        OpRightShelfTerm n
    data OpRightShelfTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpRightShelfTerm2 n A
      sing2 :
        A -> OpRightShelfTerm2 n A
      <|OL2 :
        OpRightShelfTerm2 n A ->
        OpRightShelfTerm2 n A ->
        OpRightShelfTerm2 n A
    simplifyB :
      RightShelfTerm -> RightShelfTerm
    simplifyB (<|L
               (<|L y x)
               (<|L z x)) = <|L (<|L y z) x
    simplifyB (<|L x1 x2) =
      <|L (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRightShelfTerm A ->
      ClRightShelfTerm A
    simplifyCl _ (<|Cl
                  (<|Cl y x)
                  (<|Cl z x)) = <|Cl (<|Cl y z) x
    simplifyCl _ (<|Cl x1 x2) =
      <|Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRightShelfTerm n ->
      OpRightShelfTerm n
    simplifyOp _ (<|OL
                  (<|OL y x)
                  (<|OL z x)) = <|OL (<|OL y z) x
    simplifyOp _ (<|OL x1 x2) =
      <|OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRightShelfTerm2 n A ->
      OpRightShelfTerm2 n A
    simplifyOpE _ _ (<|OL2
                     (<|OL2 y x)
                     (<|OL2 z x)) =
      <|OL2 (<|OL2 y z) x
    simplifyOpE _ _ (<|OL2 x1 x2) =
      <|OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RightShelf A ->
      RightShelfTerm -> A
    evalB _ Ri (<|L x1 x2) =
      <| Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      RightShelf A ->
      ClRightShelfTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (<|Cl x1 x2) =
      <| Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RightShelf A ->
      Vec A n ->
      OpRightShelfTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (<|OL
                        x1
                        x2) =
      <| Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RightShelf A ->
      Vec A n ->
      OpRightShelfTerm2 n A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (<|OL2
                         x1
                         x2) =
      <| Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RightShelfTerm -> Set) ->
      ((x1 : RightShelfTerm)
       (x2 : RightShelfTerm) ->
       P x1 ->
       P x2 -> P (<|L x1 x2)) ->
      (x : RightShelfTerm) -> P x
    inductionB p p<|l (<|L x1 x2) =
      p<|l _ _ (inductionB p p<|l x1)
        (inductionB p p<|l x2)
    inductionCl :
      (A : Set)
      (P : ClRightShelfTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRightShelfTerm A)
       (x2 : ClRightShelfTerm A) ->
       P x1 ->
       P x2 -> P (<|Cl x1 x2)) ->
      (x : ClRightShelfTerm A) -> P x
    inductionCl _ p psing p<|cl (sing
                                 x1) = psing x1
    inductionCl _ p psing p<|cl (<|Cl
                                 x1
                                 x2) =
      p<|cl _ _
        (inductionCl _ p psing p<|cl x1)
        (inductionCl _ p psing p<|cl x2)
    inductionOp :
      (n : Nat)
      (P : OpRightShelfTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRightShelfTerm n)
       (x2 : OpRightShelfTerm n) ->
       P x1 ->
       P x2 -> P (<|OL x1 x2)) ->
      (x : OpRightShelfTerm n) -> P x
    inductionOp _ p pv p<|ol (v
                              x1) = pv x1
    inductionOp _ p pv p<|ol (<|OL
                              x1
                              x2) =
      p<|ol _ _
        (inductionOp _ p pv p<|ol x1)
        (inductionOp _ p pv p<|ol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRightShelfTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRightShelfTerm2 n A)
       (x2 : OpRightShelfTerm2 n A) ->
       P x1 ->
       P x2 -> P (<|OL2 x1 x2)) ->
      (x : OpRightShelfTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p<|ol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p<|ol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p<|ol2 (<|OL2
                                          x1
                                          x2) =
      p<|ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p<|ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p<|ol2
           x2)
    <|L' :
      RightShelfTerm ->
      RightShelfTerm -> RightShelfTerm
    <|L' x1 x2 = <|L x1 x2
    stageB :
      RightShelfTerm ->
      Staged RightShelfTerm
    stageB (<|L x1 x2) =
      stage2 _ _ _ <|L'
        (codeLift2 _ _ _ <|L')
        (stageB x1)
        (stageB x2)
    <|Cl' :
      (A : Set) ->
      ClRightShelfTerm A ->
      ClRightShelfTerm A ->
      ClRightShelfTerm A
    <|Cl' _ x1 x2 = <|Cl x1 x2
    stageCl :
      (A : Set) ->
      ClRightShelfTerm A ->
      Staged (ClRightShelfTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (<|Cl x1 x2) =
      stage2 _ _ _ (<|Cl' _)
        (codeLift2 _ _ _ (<|Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    <|OL' :
      (n : Nat) ->
      OpRightShelfTerm n ->
      OpRightShelfTerm n ->
      OpRightShelfTerm n
    <|OL' _ x1 x2 = <|OL x1 x2
    stageOp :
      (n : Nat) ->
      OpRightShelfTerm n ->
      Staged (OpRightShelfTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (<|OL x1 x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    <|OL2' :
      (n : Nat) (A : Set) ->
      OpRightShelfTerm2 n A ->
      OpRightShelfTerm2 n A ->
      OpRightShelfTerm2 n A
    <|OL2' _ _ x1 x2 = <|OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRightShelfTerm2 n A ->
      Staged (OpRightShelfTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (<|OL2 x1 x2) =
      stage2 _ _ _ (<|OL2' _ _)
        (codeLift2 _ _ _ (<|OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RightShelfTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        <|T : Repr A -> Repr A -> Repr A
  
  module RightShelfSig where
    record RightShelfSig
      (A : Set) : Set where
      constructor RightShelfSigC
      field
        <| : A -> A -> A
    record RightShelfSigSig
      (AS : Set) : Set where
      constructor RightShelfSigSigSigC
      field
        <|S : AS -> AS -> AS
    record RightShelfSigProd
      (AP : Set) : Set where
      constructor RightShelfSigProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record RightShelfSigHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightShelfSig A1)
      (Ri2 : RightShelfSig A2) :
      Set where
      constructor RightShelfSigHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
    record RightShelfSigRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightShelfSig A1)
      (Ri2 : RightShelfSig A2) :
      Set where
      constructor RightShelfSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
    data RightShelfSigTerm
      : Set where
      <|L :
        RightShelfSigTerm ->
        RightShelfSigTerm ->
        RightShelfSigTerm
    data ClRightShelfSigTerm
      (A : Set) : Set where
      sing :
        A -> ClRightShelfSigTerm A
      <|Cl :
        ClRightShelfSigTerm A ->
        ClRightShelfSigTerm A ->
        ClRightShelfSigTerm A
    data OpRightShelfSigTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpRightShelfSigTerm n
      <|OL :
        OpRightShelfSigTerm n ->
        OpRightShelfSigTerm n ->
        OpRightShelfSigTerm n
    data OpRightShelfSigTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpRightShelfSigTerm2 n A
      sing2 :
        A -> OpRightShelfSigTerm2 n A
      <|OL2 :
        OpRightShelfSigTerm2 n A ->
        OpRightShelfSigTerm2 n A ->
        OpRightShelfSigTerm2 n A
    simplifyB :
      RightShelfSigTerm ->
      RightShelfSigTerm
    simplifyB (<|L x1 x2) =
      <|L (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRightShelfSigTerm A ->
      ClRightShelfSigTerm A
    simplifyCl _ (<|Cl x1 x2) =
      <|Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRightShelfSigTerm n ->
      OpRightShelfSigTerm n
    simplifyOp _ (<|OL x1 x2) =
      <|OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRightShelfSigTerm2 n A ->
      OpRightShelfSigTerm2 n A
    simplifyOpE _ _ (<|OL2 x1 x2) =
      <|OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RightShelfSig A ->
      RightShelfSigTerm -> A
    evalB _ Ri (<|L x1 x2) =
      <| Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      RightShelfSig A ->
      ClRightShelfSigTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (<|Cl x1 x2) =
      <| Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RightShelfSig A ->
      Vec A n ->
      OpRightShelfSigTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (<|OL
                        x1
                        x2) =
      <| Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RightShelfSig A ->
      Vec A n ->
      OpRightShelfSigTerm2 n A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (<|OL2
                         x1
                         x2) =
      <| Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RightShelfSigTerm ->
           Set) ->
      ((x1 : RightShelfSigTerm)
       (x2 : RightShelfSigTerm) ->
       P x1 ->
       P x2 -> P (<|L x1 x2)) ->
      (x : RightShelfSigTerm) -> P x
    inductionB p p<|l (<|L x1 x2) =
      p<|l _ _ (inductionB p p<|l x1)
        (inductionB p p<|l x2)
    inductionCl :
      (A : Set)
      (P : ClRightShelfSigTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRightShelfSigTerm A)
       (x2 : ClRightShelfSigTerm A) ->
       P x1 ->
       P x2 -> P (<|Cl x1 x2)) ->
      (x : ClRightShelfSigTerm A) ->
      P x
    inductionCl _ p psing p<|cl (sing
                                 x1) = psing x1
    inductionCl _ p psing p<|cl (<|Cl
                                 x1
                                 x2) =
      p<|cl _ _
        (inductionCl _ p psing p<|cl x1)
        (inductionCl _ p psing p<|cl x2)
    inductionOp :
      (n : Nat)
      (P : OpRightShelfSigTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRightShelfSigTerm n)
       (x2 : OpRightShelfSigTerm n) ->
       P x1 ->
       P x2 -> P (<|OL x1 x2)) ->
      (x : OpRightShelfSigTerm n) ->
      P x
    inductionOp _ p pv p<|ol (v
                              x1) = pv x1
    inductionOp _ p pv p<|ol (<|OL
                              x1
                              x2) =
      p<|ol _ _
        (inductionOp _ p pv p<|ol x1)
        (inductionOp _ p pv p<|ol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRightShelfSigTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRightShelfSigTerm2 n A)
       (x2 : OpRightShelfSigTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (<|OL2 x1 x2)) ->
      (x : OpRightShelfSigTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p<|ol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p<|ol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p<|ol2 (<|OL2
                                          x1
                                          x2) =
      p<|ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p<|ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p<|ol2
           x2)
    <|L' :
      RightShelfSigTerm ->
      RightShelfSigTerm ->
      RightShelfSigTerm
    <|L' x1 x2 = <|L x1 x2
    stageB :
      RightShelfSigTerm ->
      Staged RightShelfSigTerm
    stageB (<|L x1 x2) =
      stage2 _ _ _ <|L'
        (codeLift2 _ _ _ <|L')
        (stageB x1)
        (stageB x2)
    <|Cl' :
      (A : Set) ->
      ClRightShelfSigTerm A ->
      ClRightShelfSigTerm A ->
      ClRightShelfSigTerm A
    <|Cl' _ x1 x2 = <|Cl x1 x2
    stageCl :
      (A : Set) ->
      ClRightShelfSigTerm A ->
      Staged (ClRightShelfSigTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (<|Cl x1 x2) =
      stage2 _ _ _ (<|Cl' _)
        (codeLift2 _ _ _ (<|Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    <|OL' :
      (n : Nat) ->
      OpRightShelfSigTerm n ->
      OpRightShelfSigTerm n ->
      OpRightShelfSigTerm n
    <|OL' _ x1 x2 = <|OL x1 x2
    stageOp :
      (n : Nat) ->
      OpRightShelfSigTerm n ->
      Staged (OpRightShelfSigTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (<|OL x1 x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    <|OL2' :
      (n : Nat) (A : Set) ->
      OpRightShelfSigTerm2 n A ->
      OpRightShelfSigTerm2 n A ->
      OpRightShelfSigTerm2 n A
    <|OL2' _ _ x1 x2 = <|OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRightShelfSigTerm2 n A ->
      Staged
        (OpRightShelfSigTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (<|OL2 x1 x2) =
      stage2 _ _ _ (<|OL2' _ _)
        (codeLift2 _ _ _ (<|OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RightShelfSigTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        <|T : Repr A -> Repr A -> Repr A
  
  module RightSpindle where
    record RightSpindle
      (A : Set) : Set where
      constructor RightSpindleC
      field
        <| : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
        idempotent_<| :
          (x : A) -> <| x x == x
    record RightSpindleSig
      (AS : Set) : Set where
      constructor RightSpindleSigSigC
      field
        <|S : AS -> AS -> AS
    record RightSpindleProd
      (AP : Set) : Set where
      constructor RightSpindleProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
        idempotent_<|P :
          (xP : Prod AP AP) ->
          <|P xP xP == xP
    record RightSpindleHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSpindle A1)
      (Ri2 : RightSpindle A2) :
      Set where
      constructor RightSpindleHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
    record RightSpindleRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSpindle A1)
      (Ri2 : RightSpindle A2) :
      Set where
      constructor RightSpindleRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
    data RightSpindleTerm
      : Set where
      <|L :
        RightSpindleTerm ->
        RightSpindleTerm ->
        RightSpindleTerm
    data ClRightSpindleTerm
      (A : Set) : Set where
      sing :
        A -> ClRightSpindleTerm A
      <|Cl :
        ClRightSpindleTerm A ->
        ClRightSpindleTerm A ->
        ClRightSpindleTerm A
    data OpRightSpindleTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpRightSpindleTerm n
      <|OL :
        OpRightSpindleTerm n ->
        OpRightSpindleTerm n ->
        OpRightSpindleTerm n
    data OpRightSpindleTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpRightSpindleTerm2 n A
      sing2 :
        A -> OpRightSpindleTerm2 n A
      <|OL2 :
        OpRightSpindleTerm2 n A ->
        OpRightSpindleTerm2 n A ->
        OpRightSpindleTerm2 n A
    simplifyB :
      RightSpindleTerm ->
      RightSpindleTerm
    simplifyB (<|L
               (<|L y x)
               (<|L z x)) = <|L (<|L y z) x
    simplifyB (<|L x x) = x
    simplifyB (<|L x1 x2) =
      <|L (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRightSpindleTerm A ->
      ClRightSpindleTerm A
    simplifyCl _ (<|Cl
                  (<|Cl y x)
                  (<|Cl z x)) = <|Cl (<|Cl y z) x
    simplifyCl _ (<|Cl x x) = x
    simplifyCl _ (<|Cl x1 x2) =
      <|Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRightSpindleTerm n ->
      OpRightSpindleTerm n
    simplifyOp _ (<|OL
                  (<|OL y x)
                  (<|OL z x)) = <|OL (<|OL y z) x
    simplifyOp _ (<|OL x x) = x
    simplifyOp _ (<|OL x1 x2) =
      <|OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRightSpindleTerm2 n A ->
      OpRightSpindleTerm2 n A
    simplifyOpE _ _ (<|OL2
                     (<|OL2 y x)
                     (<|OL2 z x)) =
      <|OL2 (<|OL2 y z) x
    simplifyOpE _ _ (<|OL2 x x) = x
    simplifyOpE _ _ (<|OL2 x1 x2) =
      <|OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RightSpindle A ->
      RightSpindleTerm -> A
    evalB _ Ri (<|L x1 x2) =
      <| Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      RightSpindle A ->
      ClRightSpindleTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (<|Cl x1 x2) =
      <| Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RightSpindle A ->
      Vec A n ->
      OpRightSpindleTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (<|OL
                        x1
                        x2) =
      <| Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RightSpindle A ->
      Vec A n ->
      OpRightSpindleTerm2 n A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (<|OL2
                         x1
                         x2) =
      <| Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RightSpindleTerm -> Set) ->
      ((x1 : RightSpindleTerm)
       (x2 : RightSpindleTerm) ->
       P x1 ->
       P x2 -> P (<|L x1 x2)) ->
      (x : RightSpindleTerm) -> P x
    inductionB p p<|l (<|L x1 x2) =
      p<|l _ _ (inductionB p p<|l x1)
        (inductionB p p<|l x2)
    inductionCl :
      (A : Set)
      (P : ClRightSpindleTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRightSpindleTerm A)
       (x2 : ClRightSpindleTerm A) ->
       P x1 ->
       P x2 -> P (<|Cl x1 x2)) ->
      (x : ClRightSpindleTerm A) ->
      P x
    inductionCl _ p psing p<|cl (sing
                                 x1) = psing x1
    inductionCl _ p psing p<|cl (<|Cl
                                 x1
                                 x2) =
      p<|cl _ _
        (inductionCl _ p psing p<|cl x1)
        (inductionCl _ p psing p<|cl x2)
    inductionOp :
      (n : Nat)
      (P : OpRightSpindleTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRightSpindleTerm n)
       (x2 : OpRightSpindleTerm n) ->
       P x1 ->
       P x2 -> P (<|OL x1 x2)) ->
      (x : OpRightSpindleTerm n) ->
      P x
    inductionOp _ p pv p<|ol (v
                              x1) = pv x1
    inductionOp _ p pv p<|ol (<|OL
                              x1
                              x2) =
      p<|ol _ _
        (inductionOp _ p pv p<|ol x1)
        (inductionOp _ p pv p<|ol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRightSpindleTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRightSpindleTerm2 n A)
       (x2 : OpRightSpindleTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (<|OL2 x1 x2)) ->
      (x : OpRightSpindleTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p<|ol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p<|ol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p<|ol2 (<|OL2
                                          x1
                                          x2) =
      p<|ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p<|ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p<|ol2
           x2)
    <|L' :
      RightSpindleTerm ->
      RightSpindleTerm ->
      RightSpindleTerm
    <|L' x1 x2 = <|L x1 x2
    stageB :
      RightSpindleTerm ->
      Staged RightSpindleTerm
    stageB (<|L x1 x2) =
      stage2 _ _ _ <|L'
        (codeLift2 _ _ _ <|L')
        (stageB x1)
        (stageB x2)
    <|Cl' :
      (A : Set) ->
      ClRightSpindleTerm A ->
      ClRightSpindleTerm A ->
      ClRightSpindleTerm A
    <|Cl' _ x1 x2 = <|Cl x1 x2
    stageCl :
      (A : Set) ->
      ClRightSpindleTerm A ->
      Staged (ClRightSpindleTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (<|Cl x1 x2) =
      stage2 _ _ _ (<|Cl' _)
        (codeLift2 _ _ _ (<|Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    <|OL' :
      (n : Nat) ->
      OpRightSpindleTerm n ->
      OpRightSpindleTerm n ->
      OpRightSpindleTerm n
    <|OL' _ x1 x2 = <|OL x1 x2
    stageOp :
      (n : Nat) ->
      OpRightSpindleTerm n ->
      Staged (OpRightSpindleTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (<|OL x1 x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    <|OL2' :
      (n : Nat) (A : Set) ->
      OpRightSpindleTerm2 n A ->
      OpRightSpindleTerm2 n A ->
      OpRightSpindleTerm2 n A
    <|OL2' _ _ x1 x2 = <|OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRightSpindleTerm2 n A ->
      Staged (OpRightSpindleTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (<|OL2 x1 x2) =
      stage2 _ _ _ (<|OL2' _ _)
        (codeLift2 _ _ _ (<|OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RightSpindleTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        <|T : Repr A -> Repr A -> Repr A
  
  module RightSpindle_Shelf where
    record RightSpindle_Shelf
      (A : Set) : Set where
      constructor RightSpindle_ShelfC
      field
        <| : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
        idempotent_<| :
          (x : A) -> <| x x == x
        |> : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
    record RightSpindle_ShelfSig
      (AS : Set) : Set where
      constructor RightSpindle_ShelfSigSigC
      field
        <|S : AS -> AS -> AS
        |>S : AS -> AS -> AS
    record RightSpindle_ShelfProd
      (AP : Set) : Set where
      constructor RightSpindle_ShelfProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
        idempotent_<|P :
          (xP : Prod AP AP) ->
          <|P xP xP == xP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
    record RightSpindle_ShelfHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSpindle_Shelf A1)
      (Ri2 : RightSpindle_Shelf A2) :
      Set where
      constructor RightSpindle_ShelfHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ri1 x1 x2) ==
            |> Ri2 (hom x1) (hom x2)
    record RightSpindle_ShelfRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSpindle_Shelf A1)
      (Ri2 : RightSpindle_Shelf A2) :
      Set where
      constructor RightSpindle_ShelfRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ri1 x1 x2)
            (|> Ri2 y1 y2)
    data RightSpindle_ShelfTerm
      : Set where
      <|L :
        RightSpindle_ShelfTerm ->
        RightSpindle_ShelfTerm ->
        RightSpindle_ShelfTerm
      |>L :
        RightSpindle_ShelfTerm ->
        RightSpindle_ShelfTerm ->
        RightSpindle_ShelfTerm
    data ClRightSpindle_ShelfTerm
      (A : Set) : Set where
      sing :
        A -> ClRightSpindle_ShelfTerm A
      <|Cl :
        ClRightSpindle_ShelfTerm A ->
        ClRightSpindle_ShelfTerm A ->
        ClRightSpindle_ShelfTerm A
      |>Cl :
        ClRightSpindle_ShelfTerm A ->
        ClRightSpindle_ShelfTerm A ->
        ClRightSpindle_ShelfTerm A
    data OpRightSpindle_ShelfTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpRightSpindle_ShelfTerm n
      <|OL :
        OpRightSpindle_ShelfTerm n ->
        OpRightSpindle_ShelfTerm n ->
        OpRightSpindle_ShelfTerm n
      |>OL :
        OpRightSpindle_ShelfTerm n ->
        OpRightSpindle_ShelfTerm n ->
        OpRightSpindle_ShelfTerm n
    data OpRightSpindle_ShelfTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpRightSpindle_ShelfTerm2 n A
      sing2 :
        A ->
        OpRightSpindle_ShelfTerm2 n A
      <|OL2 :
        OpRightSpindle_ShelfTerm2 n A ->
        OpRightSpindle_ShelfTerm2 n A ->
        OpRightSpindle_ShelfTerm2 n A
      |>OL2 :
        OpRightSpindle_ShelfTerm2 n A ->
        OpRightSpindle_ShelfTerm2 n A ->
        OpRightSpindle_ShelfTerm2 n A
    simplifyB :
      RightSpindle_ShelfTerm ->
      RightSpindle_ShelfTerm
    simplifyB (<|L
               (<|L y x)
               (<|L z x)) = <|L (<|L y z) x
    simplifyB (<|L x x) = x
    simplifyB (|>L
               (|>L x y)
               (|>L x z)) = |>L x (|>L y z)
    simplifyB (<|L x1 x2) =
      <|L (simplifyB x1)
        (simplifyB x2)
    simplifyB (|>L x1 x2) =
      |>L (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRightSpindle_ShelfTerm A ->
      ClRightSpindle_ShelfTerm A
    simplifyCl _ (<|Cl
                  (<|Cl y x)
                  (<|Cl z x)) = <|Cl (<|Cl y z) x
    simplifyCl _ (<|Cl x x) = x
    simplifyCl _ (|>Cl
                  (|>Cl x y)
                  (|>Cl x z)) = |>Cl x (|>Cl y z)
    simplifyCl _ (<|Cl x1 x2) =
      <|Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (|>Cl x1 x2) =
      |>Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRightSpindle_ShelfTerm n ->
      OpRightSpindle_ShelfTerm n
    simplifyOp _ (<|OL
                  (<|OL y x)
                  (<|OL z x)) = <|OL (<|OL y z) x
    simplifyOp _ (<|OL x x) = x
    simplifyOp _ (|>OL
                  (|>OL x y)
                  (|>OL x z)) = |>OL x (|>OL y z)
    simplifyOp _ (<|OL x1 x2) =
      <|OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (|>OL x1 x2) =
      |>OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRightSpindle_ShelfTerm2 n A ->
      OpRightSpindle_ShelfTerm2 n A
    simplifyOpE _ _ (<|OL2
                     (<|OL2 y x)
                     (<|OL2 z x)) =
      <|OL2 (<|OL2 y z) x
    simplifyOpE _ _ (<|OL2 x x) = x
    simplifyOpE _ _ (|>OL2
                     (|>OL2 x y)
                     (|>OL2 x z)) =
      |>OL2 x (|>OL2 y z)
    simplifyOpE _ _ (<|OL2 x1 x2) =
      <|OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (|>OL2 x1 x2) =
      |>OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RightSpindle_Shelf A ->
      RightSpindle_ShelfTerm -> A
    evalB _ Ri (<|L x1 x2) =
      <| Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalB _ Ri (|>L x1 x2) =
      |> Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      RightSpindle_Shelf A ->
      ClRightSpindle_ShelfTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (<|Cl x1 x2) =
      <| Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalCl _ Ri (|>Cl x1 x2) =
      |> Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RightSpindle_Shelf A ->
      Vec A n ->
      OpRightSpindle_ShelfTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (<|OL
                        x1
                        x2) =
      <| Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOp _ n Ri vars (|>OL
                        x1
                        x2) =
      |> Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RightSpindle_Shelf A ->
      Vec A n ->
      OpRightSpindle_ShelfTerm2 n A ->
      A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (<|OL2
                         x1
                         x2) =
      <| Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    evalOpE _ n Ri vars (|>OL2
                         x1
                         x2) =
      |> Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RightSpindle_ShelfTerm ->
           Set) ->
      ((x1 : RightSpindle_ShelfTerm)
       (x2 : RightSpindle_ShelfTerm) ->
       P x1 ->
       P x2 -> P (<|L x1 x2)) ->
      ((x1 : RightSpindle_ShelfTerm)
       (x2 : RightSpindle_ShelfTerm) ->
       P x1 ->
       P x2 -> P (|>L x1 x2)) ->
      (x : RightSpindle_ShelfTerm) ->
      P x
    inductionB p p<|l p|>l (<|L
                            x1
                            x2) =
      p<|l _ _
        (inductionB p p<|l p|>l x1)
        (inductionB p p<|l p|>l x2)
    inductionB p p<|l p|>l (|>L
                            x1
                            x2) =
      p|>l _ _
        (inductionB p p<|l p|>l x1)
        (inductionB p p<|l p|>l x2)
    inductionCl :
      (A : Set)
      (P : ClRightSpindle_ShelfTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRightSpindle_ShelfTerm
          A)
       (x2 : ClRightSpindle_ShelfTerm
          A) ->
       P x1 ->
       P x2 -> P (<|Cl x1 x2)) ->
      ((x1 : ClRightSpindle_ShelfTerm
          A)
       (x2 : ClRightSpindle_ShelfTerm
          A) ->
       P x1 ->
       P x2 -> P (|>Cl x1 x2)) ->
      (x : ClRightSpindle_ShelfTerm
         A) -> P x
    inductionCl _ p psing p<|cl p|>cl (sing
                                       x1) = psing x1
    inductionCl _ p psing p<|cl p|>cl (<|Cl
                                       x1
                                       x2) =
      p<|cl _ _
        (inductionCl _ p psing p<|cl
           p|>cl
           x1)
        (inductionCl _ p psing p<|cl
           p|>cl
           x2)
    inductionCl _ p psing p<|cl p|>cl (|>Cl
                                       x1
                                       x2) =
      p|>cl _ _
        (inductionCl _ p psing p<|cl
           p|>cl
           x1)
        (inductionCl _ p psing p<|cl
           p|>cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpRightSpindle_ShelfTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRightSpindle_ShelfTerm
          n)
       (x2 : OpRightSpindle_ShelfTerm
          n) ->
       P x1 ->
       P x2 -> P (<|OL x1 x2)) ->
      ((x1 : OpRightSpindle_ShelfTerm
          n)
       (x2 : OpRightSpindle_ShelfTerm
          n) ->
       P x1 ->
       P x2 -> P (|>OL x1 x2)) ->
      (x : OpRightSpindle_ShelfTerm
         n) -> P x
    inductionOp _ p pv p<|ol p|>ol (v
                                    x1) = pv x1
    inductionOp _ p pv p<|ol p|>ol (<|OL
                                    x1
                                    x2) =
      p<|ol _ _
        (inductionOp _ p pv p<|ol p|>ol
           x1)
        (inductionOp _ p pv p<|ol p|>ol
           x2)
    inductionOp _ p pv p<|ol p|>ol (|>OL
                                    x1
                                    x2) =
      p|>ol _ _
        (inductionOp _ p pv p<|ol p|>ol
           x1)
        (inductionOp _ p pv p<|ol p|>ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRightSpindle_ShelfTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRightSpindle_ShelfTerm2
          n
          A)
       (x2 : OpRightSpindle_ShelfTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (<|OL2 x1 x2)) ->
      ((x1 : OpRightSpindle_ShelfTerm2
          n
          A)
       (x2 : OpRightSpindle_ShelfTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (|>OL2 x1 x2)) ->
      (x : OpRightSpindle_ShelfTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p<|ol2 p|>ol2 (v2
                                                 x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p<|ol2 p|>ol2 (sing2
                                                 x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p<|ol2 p|>ol2 (<|OL2
                                                 x1
                                                 x2) =
      p<|ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p<|ol2
           p|>ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p<|ol2
           p|>ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p<|ol2 p|>ol2 (|>OL2
                                                 x1
                                                 x2) =
      p|>ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p<|ol2
           p|>ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p<|ol2
           p|>ol2
           x2)
    <|L' :
      RightSpindle_ShelfTerm ->
      RightSpindle_ShelfTerm ->
      RightSpindle_ShelfTerm
    <|L' x1 x2 = <|L x1 x2
    |>L' :
      RightSpindle_ShelfTerm ->
      RightSpindle_ShelfTerm ->
      RightSpindle_ShelfTerm
    |>L' x1 x2 = |>L x1 x2
    stageB :
      RightSpindle_ShelfTerm ->
      Staged RightSpindle_ShelfTerm
    stageB (<|L x1 x2) =
      stage2 _ _ _ <|L'
        (codeLift2 _ _ _ <|L')
        (stageB x1)
        (stageB x2)
    stageB (|>L x1 x2) =
      stage2 _ _ _ |>L'
        (codeLift2 _ _ _ |>L')
        (stageB x1)
        (stageB x2)
    <|Cl' :
      (A : Set) ->
      ClRightSpindle_ShelfTerm A ->
      ClRightSpindle_ShelfTerm A ->
      ClRightSpindle_ShelfTerm A
    <|Cl' _ x1 x2 = <|Cl x1 x2
    |>Cl' :
      (A : Set) ->
      ClRightSpindle_ShelfTerm A ->
      ClRightSpindle_ShelfTerm A ->
      ClRightSpindle_ShelfTerm A
    |>Cl' _ x1 x2 = |>Cl x1 x2
    stageCl :
      (A : Set) ->
      ClRightSpindle_ShelfTerm A ->
      Staged
        (ClRightSpindle_ShelfTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (<|Cl x1 x2) =
      stage2 _ _ _ (<|Cl' _)
        (codeLift2 _ _ _ (<|Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (|>Cl x1 x2) =
      stage2 _ _ _ (|>Cl' _)
        (codeLift2 _ _ _ (|>Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    <|OL' :
      (n : Nat) ->
      OpRightSpindle_ShelfTerm n ->
      OpRightSpindle_ShelfTerm n ->
      OpRightSpindle_ShelfTerm n
    <|OL' _ x1 x2 = <|OL x1 x2
    |>OL' :
      (n : Nat) ->
      OpRightSpindle_ShelfTerm n ->
      OpRightSpindle_ShelfTerm n ->
      OpRightSpindle_ShelfTerm n
    |>OL' _ x1 x2 = |>OL x1 x2
    stageOp :
      (n : Nat) ->
      OpRightSpindle_ShelfTerm n ->
      Staged
        (OpRightSpindle_ShelfTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (<|OL x1 x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (|>OL x1 x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    <|OL2' :
      (n : Nat) (A : Set) ->
      OpRightSpindle_ShelfTerm2 n A ->
      OpRightSpindle_ShelfTerm2 n A ->
      OpRightSpindle_ShelfTerm2 n A
    <|OL2' _ _ x1 x2 = <|OL2 x1 x2
    |>OL2' :
      (n : Nat) (A : Set) ->
      OpRightSpindle_ShelfTerm2 n A ->
      OpRightSpindle_ShelfTerm2 n A ->
      OpRightSpindle_ShelfTerm2 n A
    |>OL2' _ _ x1 x2 = |>OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRightSpindle_ShelfTerm2 n A ->
      Staged
        (OpRightSpindle_ShelfTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (<|OL2 x1 x2) =
      stage2 _ _ _ (<|OL2' _ _)
        (codeLift2 _ _ _ (<|OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (|>OL2 x1 x2) =
      stage2 _ _ _ (|>OL2' _ _)
        (codeLift2 _ _ _ (|>OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RightSpindle_ShelfTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        <|T : Repr A -> Repr A -> Repr A
        |>T : Repr A -> Repr A -> Repr A
  
  module RightSpindle_ShelfSig where
    record RightSpindle_ShelfSig
      (A : Set) : Set where
      constructor RightSpindle_ShelfSigC
      field
        <| : A -> A -> A
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
        idempotent_<| :
          (x : A) -> <| x x == x
        |> : A -> A -> A
    record RightSpindle_ShelfSigSig
      (AS : Set) : Set where
      constructor RightSpindle_ShelfSigSigSigC
      field
        <|S : AS -> AS -> AS
        |>S : AS -> AS -> AS
    record RightSpindle_ShelfSigProd
      (AP : Set) : Set where
      constructor RightSpindle_ShelfSigProdC
      field
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
        idempotent_<|P :
          (xP : Prod AP AP) ->
          <|P xP xP == xP
    record RightSpindle_ShelfSigHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSpindle_ShelfSig A1)
      (Ri2 : RightSpindle_ShelfSig
         A2) : Set where
      constructor RightSpindle_ShelfSigHomC
      field
        hom : A1 -> A2
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Ri1 x1 x2) ==
            <| Ri2 (hom x1) (hom x2)
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Ri1 x1 x2) ==
            |> Ri2 (hom x1) (hom x2)
    record RightSpindle_ShelfSigRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightSpindle_ShelfSig A1)
      (Ri2 : RightSpindle_ShelfSig
         A2) : Set where
      constructor RightSpindle_ShelfSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Ri1 x1 x2)
            (<| Ri2 y1 y2)
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Ri1 x1 x2)
            (|> Ri2 y1 y2)
    data RightSpindle_ShelfSigTerm
      : Set where
      <|L :
        RightSpindle_ShelfSigTerm ->
        RightSpindle_ShelfSigTerm ->
        RightSpindle_ShelfSigTerm
      |>L :
        RightSpindle_ShelfSigTerm ->
        RightSpindle_ShelfSigTerm ->
        RightSpindle_ShelfSigTerm
    data ClRightSpindle_ShelfSigTerm
      (A : Set) : Set where
      sing :
        A ->
        ClRightSpindle_ShelfSigTerm A
      <|Cl :
        ClRightSpindle_ShelfSigTerm A ->
        ClRightSpindle_ShelfSigTerm A ->
        ClRightSpindle_ShelfSigTerm A
      |>Cl :
        ClRightSpindle_ShelfSigTerm A ->
        ClRightSpindle_ShelfSigTerm A ->
        ClRightSpindle_ShelfSigTerm A
    data OpRightSpindle_ShelfSigTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpRightSpindle_ShelfSigTerm n
      <|OL :
        OpRightSpindle_ShelfSigTerm n ->
        OpRightSpindle_ShelfSigTerm n ->
        OpRightSpindle_ShelfSigTerm n
      |>OL :
        OpRightSpindle_ShelfSigTerm n ->
        OpRightSpindle_ShelfSigTerm n ->
        OpRightSpindle_ShelfSigTerm n
    data OpRightSpindle_ShelfSigTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpRightSpindle_ShelfSigTerm2 n A
      sing2 :
        A ->
        OpRightSpindle_ShelfSigTerm2 n A
      <|OL2 :
        OpRightSpindle_ShelfSigTerm2 n
          A ->
        OpRightSpindle_ShelfSigTerm2 n
          A ->
        OpRightSpindle_ShelfSigTerm2 n A
      |>OL2 :
        OpRightSpindle_ShelfSigTerm2 n
          A ->
        OpRightSpindle_ShelfSigTerm2 n
          A ->
        OpRightSpindle_ShelfSigTerm2 n A
    simplifyB :
      RightSpindle_ShelfSigTerm ->
      RightSpindle_ShelfSigTerm
    simplifyB (<|L
               (<|L y x)
               (<|L z x)) = <|L (<|L y z) x
    simplifyB (<|L x x) = x
    simplifyB (<|L x1 x2) =
      <|L (simplifyB x1)
        (simplifyB x2)
    simplifyB (|>L x1 x2) =
      |>L (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRightSpindle_ShelfSigTerm A ->
      ClRightSpindle_ShelfSigTerm A
    simplifyCl _ (<|Cl
                  (<|Cl y x)
                  (<|Cl z x)) = <|Cl (<|Cl y z) x
    simplifyCl _ (<|Cl x x) = x
    simplifyCl _ (<|Cl x1 x2) =
      <|Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (|>Cl x1 x2) =
      |>Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRightSpindle_ShelfSigTerm n ->
      OpRightSpindle_ShelfSigTerm n
    simplifyOp _ (<|OL
                  (<|OL y x)
                  (<|OL z x)) = <|OL (<|OL y z) x
    simplifyOp _ (<|OL x x) = x
    simplifyOp _ (<|OL x1 x2) =
      <|OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (|>OL x1 x2) =
      |>OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRightSpindle_ShelfSigTerm2 n
        A ->
      OpRightSpindle_ShelfSigTerm2 n A
    simplifyOpE _ _ (<|OL2
                     (<|OL2 y x)
                     (<|OL2 z x)) =
      <|OL2 (<|OL2 y z) x
    simplifyOpE _ _ (<|OL2 x x) = x
    simplifyOpE _ _ (<|OL2 x1 x2) =
      <|OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (|>OL2 x1 x2) =
      |>OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RightSpindle_ShelfSig A ->
      RightSpindle_ShelfSigTerm -> A
    evalB _ Ri (<|L x1 x2) =
      <| Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalB _ Ri (|>L x1 x2) =
      |> Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      RightSpindle_ShelfSig A ->
      ClRightSpindle_ShelfSigTerm A ->
      A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (<|Cl x1 x2) =
      <| Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalCl _ Ri (|>Cl x1 x2) =
      |> Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RightSpindle_ShelfSig A ->
      Vec A n ->
      OpRightSpindle_ShelfSigTerm n ->
      A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (<|OL
                        x1
                        x2) =
      <| Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOp _ n Ri vars (|>OL
                        x1
                        x2) =
      |> Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RightSpindle_ShelfSig A ->
      Vec A n ->
      OpRightSpindle_ShelfSigTerm2 n
        A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (<|OL2
                         x1
                         x2) =
      <| Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    evalOpE _ n Ri vars (|>OL2
                         x1
                         x2) =
      |> Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RightSpindle_ShelfSigTerm ->
           Set) ->
      ((x1 : RightSpindle_ShelfSigTerm)
       (x2 : RightSpindle_ShelfSigTerm) ->
       P x1 ->
       P x2 -> P (<|L x1 x2)) ->
      ((x1 : RightSpindle_ShelfSigTerm)
       (x2 : RightSpindle_ShelfSigTerm) ->
       P x1 ->
       P x2 -> P (|>L x1 x2)) ->
      (x : RightSpindle_ShelfSigTerm) ->
      P x
    inductionB p p<|l p|>l (<|L
                            x1
                            x2) =
      p<|l _ _
        (inductionB p p<|l p|>l x1)
        (inductionB p p<|l p|>l x2)
    inductionB p p<|l p|>l (|>L
                            x1
                            x2) =
      p|>l _ _
        (inductionB p p<|l p|>l x1)
        (inductionB p p<|l p|>l x2)
    inductionCl :
      (A : Set)
      (P : ClRightSpindle_ShelfSigTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRightSpindle_ShelfSigTerm
          A)
       (x2 : ClRightSpindle_ShelfSigTerm
          A) ->
       P x1 ->
       P x2 -> P (<|Cl x1 x2)) ->
      ((x1 : ClRightSpindle_ShelfSigTerm
          A)
       (x2 : ClRightSpindle_ShelfSigTerm
          A) ->
       P x1 ->
       P x2 -> P (|>Cl x1 x2)) ->
      (x : ClRightSpindle_ShelfSigTerm
         A) -> P x
    inductionCl _ p psing p<|cl p|>cl (sing
                                       x1) = psing x1
    inductionCl _ p psing p<|cl p|>cl (<|Cl
                                       x1
                                       x2) =
      p<|cl _ _
        (inductionCl _ p psing p<|cl
           p|>cl
           x1)
        (inductionCl _ p psing p<|cl
           p|>cl
           x2)
    inductionCl _ p psing p<|cl p|>cl (|>Cl
                                       x1
                                       x2) =
      p|>cl _ _
        (inductionCl _ p psing p<|cl
           p|>cl
           x1)
        (inductionCl _ p psing p<|cl
           p|>cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpRightSpindle_ShelfSigTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRightSpindle_ShelfSigTerm
          n)
       (x2 : OpRightSpindle_ShelfSigTerm
          n) ->
       P x1 ->
       P x2 -> P (<|OL x1 x2)) ->
      ((x1 : OpRightSpindle_ShelfSigTerm
          n)
       (x2 : OpRightSpindle_ShelfSigTerm
          n) ->
       P x1 ->
       P x2 -> P (|>OL x1 x2)) ->
      (x : OpRightSpindle_ShelfSigTerm
         n) -> P x
    inductionOp _ p pv p<|ol p|>ol (v
                                    x1) = pv x1
    inductionOp _ p pv p<|ol p|>ol (<|OL
                                    x1
                                    x2) =
      p<|ol _ _
        (inductionOp _ p pv p<|ol p|>ol
           x1)
        (inductionOp _ p pv p<|ol p|>ol
           x2)
    inductionOp _ p pv p<|ol p|>ol (|>OL
                                    x1
                                    x2) =
      p|>ol _ _
        (inductionOp _ p pv p<|ol p|>ol
           x1)
        (inductionOp _ p pv p<|ol p|>ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRightSpindle_ShelfSigTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRightSpindle_ShelfSigTerm2
          n
          A)
       (x2 : OpRightSpindle_ShelfSigTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (<|OL2 x1 x2)) ->
      ((x1 : OpRightSpindle_ShelfSigTerm2
          n
          A)
       (x2 : OpRightSpindle_ShelfSigTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (|>OL2 x1 x2)) ->
      (x : OpRightSpindle_ShelfSigTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p<|ol2 p|>ol2 (v2
                                                 x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p<|ol2 p|>ol2 (sing2
                                                 x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p<|ol2 p|>ol2 (<|OL2
                                                 x1
                                                 x2) =
      p<|ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p<|ol2
           p|>ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p<|ol2
           p|>ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p<|ol2 p|>ol2 (|>OL2
                                                 x1
                                                 x2) =
      p|>ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p<|ol2
           p|>ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p<|ol2
           p|>ol2
           x2)
    <|L' :
      RightSpindle_ShelfSigTerm ->
      RightSpindle_ShelfSigTerm ->
      RightSpindle_ShelfSigTerm
    <|L' x1 x2 = <|L x1 x2
    |>L' :
      RightSpindle_ShelfSigTerm ->
      RightSpindle_ShelfSigTerm ->
      RightSpindle_ShelfSigTerm
    |>L' x1 x2 = |>L x1 x2
    stageB :
      RightSpindle_ShelfSigTerm ->
      Staged RightSpindle_ShelfSigTerm
    stageB (<|L x1 x2) =
      stage2 _ _ _ <|L'
        (codeLift2 _ _ _ <|L')
        (stageB x1)
        (stageB x2)
    stageB (|>L x1 x2) =
      stage2 _ _ _ |>L'
        (codeLift2 _ _ _ |>L')
        (stageB x1)
        (stageB x2)
    <|Cl' :
      (A : Set) ->
      ClRightSpindle_ShelfSigTerm A ->
      ClRightSpindle_ShelfSigTerm A ->
      ClRightSpindle_ShelfSigTerm A
    <|Cl' _ x1 x2 = <|Cl x1 x2
    |>Cl' :
      (A : Set) ->
      ClRightSpindle_ShelfSigTerm A ->
      ClRightSpindle_ShelfSigTerm A ->
      ClRightSpindle_ShelfSigTerm A
    |>Cl' _ x1 x2 = |>Cl x1 x2
    stageCl :
      (A : Set) ->
      ClRightSpindle_ShelfSigTerm A ->
      Staged
        (ClRightSpindle_ShelfSigTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (<|Cl x1 x2) =
      stage2 _ _ _ (<|Cl' _)
        (codeLift2 _ _ _ (<|Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (|>Cl x1 x2) =
      stage2 _ _ _ (|>Cl' _)
        (codeLift2 _ _ _ (|>Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    <|OL' :
      (n : Nat) ->
      OpRightSpindle_ShelfSigTerm n ->
      OpRightSpindle_ShelfSigTerm n ->
      OpRightSpindle_ShelfSigTerm n
    <|OL' _ x1 x2 = <|OL x1 x2
    |>OL' :
      (n : Nat) ->
      OpRightSpindle_ShelfSigTerm n ->
      OpRightSpindle_ShelfSigTerm n ->
      OpRightSpindle_ShelfSigTerm n
    |>OL' _ x1 x2 = |>OL x1 x2
    stageOp :
      (n : Nat) ->
      OpRightSpindle_ShelfSigTerm n ->
      Staged
        (OpRightSpindle_ShelfSigTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (<|OL x1 x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (|>OL x1 x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    <|OL2' :
      (n : Nat) (A : Set) ->
      OpRightSpindle_ShelfSigTerm2 n
        A ->
      OpRightSpindle_ShelfSigTerm2 n
        A ->
      OpRightSpindle_ShelfSigTerm2 n A
    <|OL2' _ _ x1 x2 = <|OL2 x1 x2
    |>OL2' :
      (n : Nat) (A : Set) ->
      OpRightSpindle_ShelfSigTerm2 n
        A ->
      OpRightSpindle_ShelfSigTerm2 n
        A ->
      OpRightSpindle_ShelfSigTerm2 n A
    |>OL2' _ _ x1 x2 = |>OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRightSpindle_ShelfSigTerm2 n
        A ->
      Staged
        (OpRightSpindle_ShelfSigTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (<|OL2 x1 x2) =
      stage2 _ _ _ (<|OL2' _ _)
        (codeLift2 _ _ _ (<|OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (|>OL2 x1 x2) =
      stage2 _ _ _ (|>OL2' _ _)
        (codeLift2 _ _ _ (|>OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RightSpindle_ShelfSigTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        <|T : Repr A -> Repr A -> Repr A
        |>T : Repr A -> Repr A -> Repr A
  
  module RightUnital where
    record RightUnital
      (A : Set) : Set where
      constructor RightUnitalC
      field
        e : A
        op : A -> A -> A
        runit_e : (x : A) -> op x e == x
    record RightUnitalSig
      (AS : Set) : Set where
      constructor RightUnitalSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record RightUnitalProd
      (AP : Set) : Set where
      constructor RightUnitalProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
    record RightUnitalHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightUnital A1)
      (Ri2 : RightUnital A2) :
      Set where
      constructor RightUnitalHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Ri1) == e Ri2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record RightUnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightUnital A1)
      (Ri2 : RightUnital A2) :
      Set where
      constructor RightUnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Ri1) (e Ri2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data RightUnitalTerm : Set where
      eL : RightUnitalTerm
      opL :
        RightUnitalTerm ->
        RightUnitalTerm ->
        RightUnitalTerm
    data ClRightUnitalTerm
      (A : Set) : Set where
      sing :
        A -> ClRightUnitalTerm A
      eCl : ClRightUnitalTerm A
      opCl :
        ClRightUnitalTerm A ->
        ClRightUnitalTerm A ->
        ClRightUnitalTerm A
    data OpRightUnitalTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpRightUnitalTerm n
      eOL : OpRightUnitalTerm n
      opOL :
        OpRightUnitalTerm n ->
        OpRightUnitalTerm n ->
        OpRightUnitalTerm n
    data OpRightUnitalTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpRightUnitalTerm2 n A
      sing2 :
        A -> OpRightUnitalTerm2 n A
      eOL2 : OpRightUnitalTerm2 n A
      opOL2 :
        OpRightUnitalTerm2 n A ->
        OpRightUnitalTerm2 n A ->
        OpRightUnitalTerm2 n A
    simplifyB :
      RightUnitalTerm ->
      RightUnitalTerm
    simplifyB (opL x (eL)) = x
    simplifyB (eL) = eL
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRightUnitalTerm A ->
      ClRightUnitalTerm A
    simplifyCl _ (opCl x (eCl)) = x
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRightUnitalTerm n ->
      OpRightUnitalTerm n
    simplifyOp _ (opOL x (eOL)) = x
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRightUnitalTerm2 n A ->
      OpRightUnitalTerm2 n A
    simplifyOpE _ _ (opOL2
                     x
                     (eOL2)) = x
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RightUnital A ->
      RightUnitalTerm -> A
    evalB _ Ri (eL) = e Ri
    evalB _ Ri (opL x1 x2) =
      op Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      RightUnital A ->
      ClRightUnitalTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (eCl) = e Ri
    evalCl _ Ri (opCl x1 x2) =
      op Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RightUnital A ->
      Vec A n ->
      OpRightUnitalTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (eOL) = e Ri
    evalOp _ n Ri vars (opOL
                        x1
                        x2) =
      op Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RightUnital A ->
      Vec A n ->
      OpRightUnitalTerm2 n A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (eOL2) =
      e Ri
    evalOpE _ n Ri vars (opOL2
                         x1
                         x2) =
      op Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RightUnitalTerm -> Set) ->
      P eL ->
      ((x1 : RightUnitalTerm)
       (x2 : RightUnitalTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : RightUnitalTerm) -> P x
    inductionB p pel popl (eL) = pel
    inductionB p pel popl (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p pel popl x1)
        (inductionB p pel popl x2)
    inductionCl :
      (A : Set)
      (P : ClRightUnitalTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P eCl ->
      ((x1 : ClRightUnitalTerm A)
       (x2 : ClRightUnitalTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClRightUnitalTerm A) -> P x
    inductionCl _ p psing pecl popcl (sing
                                      x1) = psing x1
    inductionCl _ p psing pecl popcl (eCl) =
      pecl
    inductionCl _ p psing pecl popcl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing pecl
           popcl
           x1)
        (inductionCl _ p psing pecl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpRightUnitalTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P eOL ->
      ((x1 : OpRightUnitalTerm n)
       (x2 : OpRightUnitalTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpRightUnitalTerm n) -> P x
    inductionOp _ p pv peol popol (v
                                   x1) = pv x1
    inductionOp _ p pv peol popol (eOL) =
      peol
    inductionOp _ p pv peol popol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv peol popol
           x1)
        (inductionOp _ p pv peol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRightUnitalTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P eOL2 ->
      ((x1 : OpRightUnitalTerm2 n A)
       (x2 : OpRightUnitalTerm2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpRightUnitalTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x2)
    eL' : RightUnitalTerm
    eL' = eL
    opL' :
      RightUnitalTerm ->
      RightUnitalTerm ->
      RightUnitalTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      RightUnitalTerm ->
      Staged RightUnitalTerm
    stageB (eL) = Now eL
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    eCl' :
      (A : Set) -> ClRightUnitalTerm A
    eCl' _ = eCl
    opCl' :
      (A : Set) ->
      ClRightUnitalTerm A ->
      ClRightUnitalTerm A ->
      ClRightUnitalTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClRightUnitalTerm A ->
      Staged (ClRightUnitalTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (eCl) = Now eCl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    eOL' :
      (n : Nat) -> OpRightUnitalTerm n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      OpRightUnitalTerm n ->
      OpRightUnitalTerm n ->
      OpRightUnitalTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpRightUnitalTerm n ->
      Staged (OpRightUnitalTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (eOL) = Now eOL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    eOL2' :
      (n : Nat) (A : Set) ->
      OpRightUnitalTerm2 n A
    eOL2' _ _ = eOL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpRightUnitalTerm2 n A ->
      OpRightUnitalTerm2 n A ->
      OpRightUnitalTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRightUnitalTerm2 n A ->
      Staged (OpRightUnitalTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RightUnitalTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        eT : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module RightZero where
    record RightZero
      (A : Set) : Set where
      constructor RightZeroC
      field
        e : A
        op : A -> A -> A
        rightZero_op_e :
          (x : A) -> op x e == e
    record RightZeroSig
      (AS : Set) : Set where
      constructor RightZeroSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record RightZeroProd
      (AP : Set) : Set where
      constructor RightZeroProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        rightZero_op_eP :
          (xP : Prod AP AP) ->
          opP xP eP == eP
    record RightZeroHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RightZero A1)
      (Ri2 : RightZero A2) : Set where
      constructor RightZeroHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Ri1) == e Ri2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ri1 x1 x2) ==
            op Ri2 (hom x1) (hom x2)
    record RightZeroRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RightZero A1)
      (Ri2 : RightZero A2) : Set where
      constructor RightZeroRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Ri1) (e Ri2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ri1 x1 x2)
            (op Ri2 y1 y2)
    data RightZeroTerm : Set where
      eL : RightZeroTerm
      opL :
        RightZeroTerm ->
        RightZeroTerm -> RightZeroTerm
    data ClRightZeroTerm
      (A : Set) : Set where
      sing : A -> ClRightZeroTerm A
      eCl : ClRightZeroTerm A
      opCl :
        ClRightZeroTerm A ->
        ClRightZeroTerm A ->
        ClRightZeroTerm A
    data OpRightZeroTerm
      (n : Nat) : Set where
      v : Fin n -> OpRightZeroTerm n
      eOL : OpRightZeroTerm n
      opOL :
        OpRightZeroTerm n ->
        OpRightZeroTerm n ->
        OpRightZeroTerm n
    data OpRightZeroTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpRightZeroTerm2 n A
      sing2 :
        A -> OpRightZeroTerm2 n A
      eOL2 : OpRightZeroTerm2 n A
      opOL2 :
        OpRightZeroTerm2 n A ->
        OpRightZeroTerm2 n A ->
        OpRightZeroTerm2 n A
    simplifyB :
      RightZeroTerm -> RightZeroTerm
    simplifyB (opL x (eL)) = eL
    simplifyB (eL) = eL
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRightZeroTerm A ->
      ClRightZeroTerm A
    simplifyCl _ (opCl x (eCl)) =
      eCl
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRightZeroTerm n ->
      OpRightZeroTerm n
    simplifyOp _ (opOL x (eOL)) =
      eOL
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRightZeroTerm2 n A ->
      OpRightZeroTerm2 n A
    simplifyOpE _ _ (opOL2
                     x
                     (eOL2)) = eOL2
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RightZero A ->
      RightZeroTerm -> A
    evalB _ Ri (eL) = e Ri
    evalB _ Ri (opL x1 x2) =
      op Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      RightZero A ->
      ClRightZeroTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (eCl) = e Ri
    evalCl _ Ri (opCl x1 x2) =
      op Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RightZero A ->
      Vec A n ->
      OpRightZeroTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (eOL) = e Ri
    evalOp _ n Ri vars (opOL
                        x1
                        x2) =
      op Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RightZero A ->
      Vec A n ->
      OpRightZeroTerm2 n A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (eOL2) =
      e Ri
    evalOpE _ n Ri vars (opOL2
                         x1
                         x2) =
      op Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RightZeroTerm -> Set) ->
      P eL ->
      ((x1 : RightZeroTerm)
       (x2 : RightZeroTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : RightZeroTerm) -> P x
    inductionB p pel popl (eL) = pel
    inductionB p pel popl (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p pel popl x1)
        (inductionB p pel popl x2)
    inductionCl :
      (A : Set)
      (P : ClRightZeroTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P eCl ->
      ((x1 : ClRightZeroTerm A)
       (x2 : ClRightZeroTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClRightZeroTerm A) -> P x
    inductionCl _ p psing pecl popcl (sing
                                      x1) = psing x1
    inductionCl _ p psing pecl popcl (eCl) =
      pecl
    inductionCl _ p psing pecl popcl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing pecl
           popcl
           x1)
        (inductionCl _ p psing pecl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpRightZeroTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P eOL ->
      ((x1 : OpRightZeroTerm n)
       (x2 : OpRightZeroTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpRightZeroTerm n) -> P x
    inductionOp _ p pv peol popol (v
                                   x1) = pv x1
    inductionOp _ p pv peol popol (eOL) =
      peol
    inductionOp _ p pv peol popol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv peol popol
           x1)
        (inductionOp _ p pv peol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRightZeroTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P eOL2 ->
      ((x1 : OpRightZeroTerm2 n A)
       (x2 : OpRightZeroTerm2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpRightZeroTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x2)
    eL' : RightZeroTerm
    eL' = eL
    opL' :
      RightZeroTerm ->
      RightZeroTerm -> RightZeroTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      RightZeroTerm ->
      Staged RightZeroTerm
    stageB (eL) = Now eL
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    eCl' :
      (A : Set) -> ClRightZeroTerm A
    eCl' _ = eCl
    opCl' :
      (A : Set) ->
      ClRightZeroTerm A ->
      ClRightZeroTerm A ->
      ClRightZeroTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClRightZeroTerm A ->
      Staged (ClRightZeroTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (eCl) = Now eCl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    eOL' :
      (n : Nat) -> OpRightZeroTerm n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      OpRightZeroTerm n ->
      OpRightZeroTerm n ->
      OpRightZeroTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpRightZeroTerm n ->
      Staged (OpRightZeroTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (eOL) = Now eOL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    eOL2' :
      (n : Nat) (A : Set) ->
      OpRightZeroTerm2 n A
    eOL2' _ _ = eOL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpRightZeroTerm2 n A ->
      OpRightZeroTerm2 n A ->
      OpRightZeroTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRightZeroTerm2 n A ->
      Staged (OpRightZeroTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RightZeroTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        eT : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module Ring where
    record Ring
      (A : Set) : Set where
      constructor RingC
      field
        * : A -> A -> A
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
    record RingSig
      (AS : Set) : Set where
      constructor RingSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        negS : AS -> AS
        1S : AS
    record RingProd
      (AP : Set) : Set where
      constructor RingProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
    record RingHom
      (A1 : Set) (A2 : Set)
      (Ri1 : Ring A1)
      (Ri2 : Ring A2) : Set where
      constructor RingHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
        pres-0 : hom (0 Ri1) == 0 Ri2
        pres-neg :
          (x1 : A1) ->
          hom (neg Ri1 x1) ==
            neg Ri2 (hom x1)
        pres-1 : hom (1 Ri1) == 1 Ri2
    record RingRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Ring A1)
      (Ri2 : Ring A2) : Set where
      constructor RingRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
        interp-0 :
          interp (0 Ri1) (0 Ri2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Ri1 x1) (neg Ri2 y1)
        interp-1 :
          interp (1 Ri1) (1 Ri2)
    data RingTerm : Set where
      *L :
        RingTerm -> RingTerm -> RingTerm
      +L :
        RingTerm -> RingTerm -> RingTerm
      0L : RingTerm
      negL : RingTerm -> RingTerm
      1L : RingTerm
    data ClRingTerm
      (A : Set) : Set where
      sing : A -> ClRingTerm A
      *Cl :
        ClRingTerm A ->
        ClRingTerm A -> ClRingTerm A
      +Cl :
        ClRingTerm A ->
        ClRingTerm A -> ClRingTerm A
      0Cl : ClRingTerm A
      negCl :
        ClRingTerm A -> ClRingTerm A
      1Cl : ClRingTerm A
    data OpRingTerm
      (n : Nat) : Set where
      v : Fin n -> OpRingTerm n
      *OL :
        OpRingTerm n ->
        OpRingTerm n -> OpRingTerm n
      +OL :
        OpRingTerm n ->
        OpRingTerm n -> OpRingTerm n
      0OL : OpRingTerm n
      negOL :
        OpRingTerm n -> OpRingTerm n
      1OL : OpRingTerm n
    data OpRingTerm2
      (n : Nat) (A : Set) : Set where
      v2 : Fin n -> OpRingTerm2 n A
      sing2 : A -> OpRingTerm2 n A
      *OL2 :
        OpRingTerm2 n A ->
        OpRingTerm2 n A ->
        OpRingTerm2 n A
      +OL2 :
        OpRingTerm2 n A ->
        OpRingTerm2 n A ->
        OpRingTerm2 n A
      0OL2 : OpRingTerm2 n A
      negOL2 :
        OpRingTerm2 n A ->
        OpRingTerm2 n A
      1OL2 : OpRingTerm2 n A
    simplifyB : RingTerm -> RingTerm
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (+L
               (*L x y)
               (*L x z)) = *L x (+L y z)
    simplifyB (+L
               (*L y x)
               (*L z x)) = *L (+L y z) x
    simplifyB (+L x (negL x)) = 0L
    simplifyB (+L (negL x) x) = 0L
    simplifyB (*L (1L) x) = x
    simplifyB (*L x (1L)) = x
    simplifyB (*L (0L) x) = 0L
    simplifyB (*L x (0L)) = 0L
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (0L) = 0L
    simplifyB (negL x1) =
      negL (simplifyB x1)
    simplifyB (1L) = 1L
    simplifyCl :
      (A : Set) ->
      ClRingTerm A -> ClRingTerm A
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (+Cl
                  (*Cl x y)
                  (*Cl x z)) = *Cl x (+Cl y z)
    simplifyCl _ (+Cl
                  (*Cl y x)
                  (*Cl z x)) = *Cl (+Cl y z) x
    simplifyCl _ (+Cl x (negCl x)) =
      0Cl
    simplifyCl _ (+Cl (negCl x) x) =
      0Cl
    simplifyCl _ (*Cl (1Cl) x) = x
    simplifyCl _ (*Cl x (1Cl)) = x
    simplifyCl _ (*Cl (0Cl) x) = 0Cl
    simplifyCl _ (*Cl x (0Cl)) = 0Cl
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (negCl x1) =
      negCl (simplifyCl _ x1)
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRingTerm n -> OpRingTerm n
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (+OL
                  (*OL x y)
                  (*OL x z)) = *OL x (+OL y z)
    simplifyOp _ (+OL
                  (*OL y x)
                  (*OL z x)) = *OL (+OL y z) x
    simplifyOp _ (+OL x (negOL x)) =
      0OL
    simplifyOp _ (+OL (negOL x) x) =
      0OL
    simplifyOp _ (*OL (1OL) x) = x
    simplifyOp _ (*OL x (1OL)) = x
    simplifyOp _ (*OL (0OL) x) = 0OL
    simplifyOp _ (*OL x (0OL)) = 0OL
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (negOL x1) =
      negOL (simplifyOp _ x1)
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRingTerm2 n A ->
      OpRingTerm2 n A
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (+OL2
                     (*OL2 x y)
                     (*OL2 x z)) = *OL2 x (+OL2 y z)
    simplifyOpE _ _ (+OL2
                     (*OL2 y x)
                     (*OL2 z x)) = *OL2 (+OL2 y z) x
    simplifyOpE _ _ (+OL2
                     x
                     (negOL2 x)) = 0OL2
    simplifyOpE _ _ (+OL2
                     (negOL2 x)
                     x) = 0OL2
    simplifyOpE _ _ (*OL2
                     (1OL2)
                     x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (1OL2)) = x
    simplifyOpE _ _ (*OL2
                     (0OL2)
                     x) = 0OL2
    simplifyOpE _ _ (*OL2
                     x
                     (0OL2)) = 0OL2
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (negOL2 x1) =
      negOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Ring A -> RingTerm -> A
    evalB _ Ri (*L x1 x2) =
      * Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalB _ Ri (+L x1 x2) =
      + Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalB _ Ri (0L) = 0 Ri
    evalB _ Ri (negL x1) =
      neg Ri (evalB _ Ri x1)
    evalB _ Ri (1L) = 1 Ri
    evalCl :
      (A : Set) ->
      Ring A -> ClRingTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (*Cl x1 x2) =
      * Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalCl _ Ri (+Cl x1 x2) =
      + Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalCl _ Ri (0Cl) = 0 Ri
    evalCl _ Ri (negCl x1) =
      neg Ri (evalCl _ Ri x1)
    evalCl _ Ri (1Cl) = 1 Ri
    evalOp :
      (A : Set) (n : Nat) ->
      Ring A ->
      Vec A n -> OpRingTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (*OL x1 x2) =
      * Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOp _ n Ri vars (+OL x1 x2) =
      + Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOp _ n Ri vars (0OL) = 0 Ri
    evalOp _ n Ri vars (negOL x1) =
      neg Ri (evalOp _ n Ri vars x1)
    evalOp _ n Ri vars (1OL) = 1 Ri
    evalOpE :
      (A : Set) (n : Nat) ->
      Ring A ->
      Vec A n -> OpRingTerm2 n A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (*OL2
                         x1
                         x2) =
      * Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    evalOpE _ n Ri vars (+OL2
                         x1
                         x2) =
      + Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    evalOpE _ n Ri vars (0OL2) =
      0 Ri
    evalOpE _ n Ri vars (negOL2
                         x1) =
      neg Ri (evalOpE _ n Ri vars x1)
    evalOpE _ n Ri vars (1OL2) =
      1 Ri
    inductionB :
      (P : RingTerm -> Set) ->
      ((x1 : RingTerm)
       (x2 : RingTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : RingTerm)
       (x2 : RingTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      P 0L ->
      ((x1 : RingTerm) ->
       P x1 -> P (negL x1)) ->
      P 1L -> (x : RingTerm) -> P x
    inductionB p p*l p+l p0l pnegl p1l (*L
                                        x1
                                        x2) =
      p*l _ _
        (inductionB p p*l p+l p0l pnegl
           p1l
           x1)
        (inductionB p p*l p+l p0l pnegl
           p1l
           x2)
    inductionB p p*l p+l p0l pnegl p1l (+L
                                        x1
                                        x2) =
      p+l _ _
        (inductionB p p*l p+l p0l pnegl
           p1l
           x1)
        (inductionB p p*l p+l p0l pnegl
           p1l
           x2)
    inductionB p p*l p+l p0l pnegl p1l (0L) =
      p0l
    inductionB p p*l p+l p0l pnegl p1l (negL
                                        x1) =
      pnegl _
        (inductionB p p*l p+l p0l pnegl
           p1l
           x1)
    inductionB p p*l p+l p0l pnegl p1l (1L) =
      p1l
    inductionCl :
      (A : Set)
      (P : ClRingTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRingTerm A)
       (x2 : ClRingTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClRingTerm A)
       (x2 : ClRingTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      P 0Cl ->
      ((x1 : ClRingTerm A) ->
       P x1 -> P (negCl x1)) ->
      P 1Cl ->
      (x : ClRingTerm A) -> P x
    inductionCl _ p psing p*cl p+cl p0cl pnegcl p1cl (sing
                                                      x1) = psing x1
    inductionCl _ p psing p*cl p+cl p0cl pnegcl p1cl (*Cl
                                                      x1
                                                      x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           p0cl
           pnegcl
           p1cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           p0cl
           pnegcl
           p1cl
           x2)
    inductionCl _ p psing p*cl p+cl p0cl pnegcl p1cl (+Cl
                                                      x1
                                                      x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           p0cl
           pnegcl
           p1cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           p0cl
           pnegcl
           p1cl
           x2)
    inductionCl _ p psing p*cl p+cl p0cl pnegcl p1cl (0Cl) =
      p0cl
    inductionCl _ p psing p*cl p+cl p0cl pnegcl p1cl (negCl
                                                      x1) =
      pnegcl _
        (inductionCl _ p psing p*cl p+cl
           p0cl
           pnegcl
           p1cl
           x1)
    inductionCl _ p psing p*cl p+cl p0cl pnegcl p1cl (1Cl) =
      p1cl
    inductionOp :
      (n : Nat)
      (P : OpRingTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRingTerm n)
       (x2 : OpRingTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpRingTerm n)
       (x2 : OpRingTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      P 0OL ->
      ((x1 : OpRingTerm n) ->
       P x1 -> P (negOL x1)) ->
      P 1OL ->
      (x : OpRingTerm n) -> P x
    inductionOp _ p pv p*ol p+ol p0ol pnegol p1ol (v
                                                   x1) = pv x1
    inductionOp _ p pv p*ol p+ol p0ol pnegol p1ol (*OL
                                                   x1
                                                   x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           p0ol
           pnegol
           p1ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           p0ol
           pnegol
           p1ol
           x2)
    inductionOp _ p pv p*ol p+ol p0ol pnegol p1ol (+OL
                                                   x1
                                                   x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           p0ol
           pnegol
           p1ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           p0ol
           pnegol
           p1ol
           x2)
    inductionOp _ p pv p*ol p+ol p0ol pnegol p1ol (0OL) =
      p0ol
    inductionOp _ p pv p*ol p+ol p0ol pnegol p1ol (negOL
                                                   x1) =
      pnegol _
        (inductionOp _ p pv p*ol p+ol
           p0ol
           pnegol
           p1ol
           x1)
    inductionOp _ p pv p*ol p+ol p0ol pnegol p1ol (1OL) =
      p1ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRingTerm2 n A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRingTerm2 n A)
       (x2 : OpRingTerm2 n A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpRingTerm2 n A)
       (x2 : OpRingTerm2 n A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      P 0OL2 ->
      ((x1 : OpRingTerm2 n A) ->
       P x1 -> P (negOL2 x1)) ->
      P 1OL2 ->
      (x : OpRingTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 (v2
                                                                   x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 (sing2
                                                                   x1) =
      psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 (*OL2
                                                                   x1
                                                                   x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           pnegol2
           p1ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           pnegol2
           p1ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 (+OL2
                                                                   x1
                                                                   x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           pnegol2
           p1ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           pnegol2
           p1ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 (negOL2
                                                                   x1) =
      pnegol2 _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           pnegol2
           p1ol2
           x1)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 pnegol2 p1ol2 (1OL2) =
      p1ol2
    *L' :
      RingTerm -> RingTerm -> RingTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      RingTerm -> RingTerm -> RingTerm
    +L' x1 x2 = +L x1 x2
    0L' : RingTerm
    0L' = 0L
    negL' : RingTerm -> RingTerm
    negL' x1 = negL x1
    1L' : RingTerm
    1L' = 1L
    stageB :
      RingTerm -> Staged RingTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (0L) = Now 0L
    stageB (negL x1) =
      stage1 _ _ negL'
        (codeLift1 _ _ negL')
        (stageB x1)
    stageB (1L) = Now 1L
    *Cl' :
      (A : Set) ->
      ClRingTerm A ->
      ClRingTerm A -> ClRingTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClRingTerm A ->
      ClRingTerm A -> ClRingTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    0Cl' : (A : Set) -> ClRingTerm A
    0Cl' _ = 0Cl
    negCl' :
      (A : Set) ->
      ClRingTerm A -> ClRingTerm A
    negCl' _ x1 = negCl x1
    1Cl' : (A : Set) -> ClRingTerm A
    1Cl' _ = 1Cl
    stageCl :
      (A : Set) ->
      ClRingTerm A ->
      Staged (ClRingTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (negCl x1) =
      stage1 _ _ (negCl' _)
        (codeLift1 _ _ (negCl' _))
        (stageCl _ x1)
    stageCl _ (1Cl) = Now 1Cl
    *OL' :
      (n : Nat) ->
      OpRingTerm n ->
      OpRingTerm n -> OpRingTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpRingTerm n ->
      OpRingTerm n -> OpRingTerm n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' : (n : Nat) -> OpRingTerm n
    0OL' _ = 0OL
    negOL' :
      (n : Nat) ->
      OpRingTerm n -> OpRingTerm n
    negOL' _ x1 = negOL x1
    1OL' : (n : Nat) -> OpRingTerm n
    1OL' _ = 1OL
    stageOp :
      (n : Nat) ->
      OpRingTerm n ->
      Staged (OpRingTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (0OL) = Now 0OL
    stageOp _ (negOL x1) =
      stage1 _ _ (negOL' _)
        (codeLift1 _ _ (negOL' _))
        (stageOp _ x1)
    stageOp _ (1OL) = Now 1OL
    *OL2' :
      (n : Nat) (A : Set) ->
      OpRingTerm2 n A ->
      OpRingTerm2 n A ->
      OpRingTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpRingTerm2 n A ->
      OpRingTerm2 n A ->
      OpRingTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    0OL2' :
      (n : Nat) (A : Set) ->
      OpRingTerm2 n A
    0OL2' _ _ = 0OL2
    negOL2' :
      (n : Nat) (A : Set) ->
      OpRingTerm2 n A ->
      OpRingTerm2 n A
    negOL2' _ _ x1 = negOL2 x1
    1OL2' :
      (n : Nat) (A : Set) ->
      OpRingTerm2 n A
    1OL2' _ _ = 1OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRingTerm2 n A ->
      Staged (OpRingTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (negOL2 x1) =
      stage1 _ _ (negOL2' _ _)
        (codeLift1 _ _ (negOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (1OL2) = Now 1OL2
    record RingTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
        0T : Repr A
        negT : Repr A -> Repr A
        1T : Repr A
  
  module Ringoid where
    record Ringoid
      (A : Set) : Set where
      constructor RingoidC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record RingoidSig
      (AS : Set) : Set where
      constructor RingoidSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record RingoidProd
      (AP : Set) : Set where
      constructor RingoidProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record RingoidHom
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid A1)
      (Ri2 : Ringoid A2) : Set where
      constructor RingoidHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
    record RingoidRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid A1)
      (Ri2 : Ringoid A2) : Set where
      constructor RingoidRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
    data RingoidTerm : Set where
      *L :
        RingoidTerm ->
        RingoidTerm -> RingoidTerm
      +L :
        RingoidTerm ->
        RingoidTerm -> RingoidTerm
    data ClRingoidTerm
      (A : Set) : Set where
      sing : A -> ClRingoidTerm A
      *Cl :
        ClRingoidTerm A ->
        ClRingoidTerm A ->
        ClRingoidTerm A
      +Cl :
        ClRingoidTerm A ->
        ClRingoidTerm A ->
        ClRingoidTerm A
    data OpRingoidTerm
      (n : Nat) : Set where
      v : Fin n -> OpRingoidTerm n
      *OL :
        OpRingoidTerm n ->
        OpRingoidTerm n ->
        OpRingoidTerm n
      +OL :
        OpRingoidTerm n ->
        OpRingoidTerm n ->
        OpRingoidTerm n
    data OpRingoidTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpRingoidTerm2 n A
      sing2 : A -> OpRingoidTerm2 n A
      *OL2 :
        OpRingoidTerm2 n A ->
        OpRingoidTerm2 n A ->
        OpRingoidTerm2 n A
      +OL2 :
        OpRingoidTerm2 n A ->
        OpRingoidTerm2 n A ->
        OpRingoidTerm2 n A
    simplifyB :
      RingoidTerm -> RingoidTerm
    simplifyB (+L
               (*L x y)
               (*L x z)) = *L x (+L y z)
    simplifyB (+L
               (*L y x)
               (*L z x)) = *L (+L y z) x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRingoidTerm A ->
      ClRingoidTerm A
    simplifyCl _ (+Cl
                  (*Cl x y)
                  (*Cl x z)) = *Cl x (+Cl y z)
    simplifyCl _ (+Cl
                  (*Cl y x)
                  (*Cl z x)) = *Cl (+Cl y z) x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRingoidTerm n ->
      OpRingoidTerm n
    simplifyOp _ (+OL
                  (*OL x y)
                  (*OL x z)) = *OL x (+OL y z)
    simplifyOp _ (+OL
                  (*OL y x)
                  (*OL z x)) = *OL (+OL y z) x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRingoidTerm2 n A ->
      OpRingoidTerm2 n A
    simplifyOpE _ _ (+OL2
                     (*OL2 x y)
                     (*OL2 x z)) = *OL2 x (+OL2 y z)
    simplifyOpE _ _ (+OL2
                     (*OL2 y x)
                     (*OL2 z x)) = *OL2 (+OL2 y z) x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Ringoid A -> RingoidTerm -> A
    evalB _ Ri (*L x1 x2) =
      * Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalB _ Ri (+L x1 x2) =
      + Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      Ringoid A ->
      ClRingoidTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (*Cl x1 x2) =
      * Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalCl _ Ri (+Cl x1 x2) =
      + Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Ringoid A ->
      Vec A n -> OpRingoidTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (*OL x1 x2) =
      * Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOp _ n Ri vars (+OL x1 x2) =
      + Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Ringoid A ->
      Vec A n ->
      OpRingoidTerm2 n A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (*OL2
                         x1
                         x2) =
      * Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    evalOpE _ n Ri vars (+OL2
                         x1
                         x2) =
      + Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RingoidTerm -> Set) ->
      ((x1 : RingoidTerm)
       (x2 : RingoidTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : RingoidTerm)
       (x2 : RingoidTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : RingoidTerm) -> P x
    inductionB p p*l p+l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionB p p*l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClRingoidTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRingoidTerm A)
       (x2 : ClRingoidTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClRingoidTerm A)
       (x2 : ClRingoidTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClRingoidTerm A) -> P x
    inductionCl _ p psing p*cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p*cl p+cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionCl _ p psing p*cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpRingoidTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRingoidTerm n)
       (x2 : OpRingoidTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpRingoidTerm n)
       (x2 : OpRingoidTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpRingoidTerm n) -> P x
    inductionOp _ p pv p*ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p*ol p+ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOp _ p pv p*ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRingoidTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRingoidTerm2 n A)
       (x2 : OpRingoidTerm2 n A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpRingoidTerm2 n A)
       (x2 : OpRingoidTerm2 n A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpRingoidTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    *L' :
      RingoidTerm ->
      RingoidTerm -> RingoidTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      RingoidTerm ->
      RingoidTerm -> RingoidTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      RingoidTerm ->
      Staged RingoidTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClRingoidTerm A ->
      ClRingoidTerm A ->
      ClRingoidTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClRingoidTerm A ->
      ClRingoidTerm A ->
      ClRingoidTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClRingoidTerm A ->
      Staged (ClRingoidTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpRingoidTerm n ->
      OpRingoidTerm n ->
      OpRingoidTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpRingoidTerm n ->
      OpRingoidTerm n ->
      OpRingoidTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpRingoidTerm n ->
      Staged (OpRingoidTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpRingoidTerm2 n A ->
      OpRingoidTerm2 n A ->
      OpRingoidTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpRingoidTerm2 n A ->
      OpRingoidTerm2 n A ->
      OpRingoidTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRingoidTerm2 n A ->
      Staged (OpRingoidTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RingoidTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module Ringoid01Sig where
    record Ringoid01Sig
      (A : Set) : Set where
      constructor Ringoid01SigC
      field
        * : A -> A -> A
        + : A -> A -> A
        0 : A
        1 : A
    record Ringoid01SigSig
      (AS : Set) : Set where
      constructor Ringoid01SigSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
        1S : AS
    record Ringoid01SigProd
      (AP : Set) : Set where
      constructor Ringoid01SigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        1P : Prod AP AP
    record Ringoid01SigHom
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid01Sig A1)
      (Ri2 : Ringoid01Sig A2) :
      Set where
      constructor Ringoid01SigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
        pres-0 : hom (0 Ri1) == 0 Ri2
        pres-1 : hom (1 Ri1) == 1 Ri2
    record Ringoid01SigRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid01Sig A1)
      (Ri2 : Ringoid01Sig A2) :
      Set where
      constructor Ringoid01SigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
        interp-0 :
          interp (0 Ri1) (0 Ri2)
        interp-1 :
          interp (1 Ri1) (1 Ri2)
    data Ringoid01SigTerm
      : Set where
      *L :
        Ringoid01SigTerm ->
        Ringoid01SigTerm ->
        Ringoid01SigTerm
      +L :
        Ringoid01SigTerm ->
        Ringoid01SigTerm ->
        Ringoid01SigTerm
      0L : Ringoid01SigTerm
      1L : Ringoid01SigTerm
    data ClRingoid01SigTerm
      (A : Set) : Set where
      sing :
        A -> ClRingoid01SigTerm A
      *Cl :
        ClRingoid01SigTerm A ->
        ClRingoid01SigTerm A ->
        ClRingoid01SigTerm A
      +Cl :
        ClRingoid01SigTerm A ->
        ClRingoid01SigTerm A ->
        ClRingoid01SigTerm A
      0Cl : ClRingoid01SigTerm A
      1Cl : ClRingoid01SigTerm A
    data OpRingoid01SigTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpRingoid01SigTerm n
      *OL :
        OpRingoid01SigTerm n ->
        OpRingoid01SigTerm n ->
        OpRingoid01SigTerm n
      +OL :
        OpRingoid01SigTerm n ->
        OpRingoid01SigTerm n ->
        OpRingoid01SigTerm n
      0OL : OpRingoid01SigTerm n
      1OL : OpRingoid01SigTerm n
    data OpRingoid01SigTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpRingoid01SigTerm2 n A
      sing2 :
        A -> OpRingoid01SigTerm2 n A
      *OL2 :
        OpRingoid01SigTerm2 n A ->
        OpRingoid01SigTerm2 n A ->
        OpRingoid01SigTerm2 n A
      +OL2 :
        OpRingoid01SigTerm2 n A ->
        OpRingoid01SigTerm2 n A ->
        OpRingoid01SigTerm2 n A
      0OL2 : OpRingoid01SigTerm2 n A
      1OL2 : OpRingoid01SigTerm2 n A
    simplifyB :
      Ringoid01SigTerm ->
      Ringoid01SigTerm
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (0L) = 0L
    simplifyB (1L) = 1L
    simplifyCl :
      (A : Set) ->
      ClRingoid01SigTerm A ->
      ClRingoid01SigTerm A
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRingoid01SigTerm n ->
      OpRingoid01SigTerm n
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRingoid01SigTerm2 n A ->
      OpRingoid01SigTerm2 n A
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Ringoid01Sig A ->
      Ringoid01SigTerm -> A
    evalB _ Ri (*L x1 x2) =
      * Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalB _ Ri (+L x1 x2) =
      + Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalB _ Ri (0L) = 0 Ri
    evalB _ Ri (1L) = 1 Ri
    evalCl :
      (A : Set) ->
      Ringoid01Sig A ->
      ClRingoid01SigTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (*Cl x1 x2) =
      * Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalCl _ Ri (+Cl x1 x2) =
      + Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalCl _ Ri (0Cl) = 0 Ri
    evalCl _ Ri (1Cl) = 1 Ri
    evalOp :
      (A : Set) (n : Nat) ->
      Ringoid01Sig A ->
      Vec A n ->
      OpRingoid01SigTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (*OL x1 x2) =
      * Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOp _ n Ri vars (+OL x1 x2) =
      + Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOp _ n Ri vars (0OL) = 0 Ri
    evalOp _ n Ri vars (1OL) = 1 Ri
    evalOpE :
      (A : Set) (n : Nat) ->
      Ringoid01Sig A ->
      Vec A n ->
      OpRingoid01SigTerm2 n A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (*OL2
                         x1
                         x2) =
      * Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    evalOpE _ n Ri vars (+OL2
                         x1
                         x2) =
      + Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    evalOpE _ n Ri vars (0OL2) =
      0 Ri
    evalOpE _ n Ri vars (1OL2) =
      1 Ri
    inductionB :
      (P : Ringoid01SigTerm -> Set) ->
      ((x1 : Ringoid01SigTerm)
       (x2 : Ringoid01SigTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : Ringoid01SigTerm)
       (x2 : Ringoid01SigTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      P 0L ->
      P 1L ->
      (x : Ringoid01SigTerm) -> P x
    inductionB p p*l p+l p0l p1l (*L
                                  x1
                                  x2) =
      p*l _ _
        (inductionB p p*l p+l p0l p1l
           x1)
        (inductionB p p*l p+l p0l p1l
           x2)
    inductionB p p*l p+l p0l p1l (+L
                                  x1
                                  x2) =
      p+l _ _
        (inductionB p p*l p+l p0l p1l
           x1)
        (inductionB p p*l p+l p0l p1l
           x2)
    inductionB p p*l p+l p0l p1l (0L) =
      p0l
    inductionB p p*l p+l p0l p1l (1L) =
      p1l
    inductionCl :
      (A : Set)
      (P : ClRingoid01SigTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRingoid01SigTerm A)
       (x2 : ClRingoid01SigTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClRingoid01SigTerm A)
       (x2 : ClRingoid01SigTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      P 0Cl ->
      P 1Cl ->
      (x : ClRingoid01SigTerm A) ->
      P x
    inductionCl _ p psing p*cl p+cl p0cl p1cl (sing
                                               x1) = psing x1
    inductionCl _ p psing p*cl p+cl p0cl p1cl (*Cl
                                               x1
                                               x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           p0cl
           p1cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           p0cl
           p1cl
           x2)
    inductionCl _ p psing p*cl p+cl p0cl p1cl (+Cl
                                               x1
                                               x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           p0cl
           p1cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           p0cl
           p1cl
           x2)
    inductionCl _ p psing p*cl p+cl p0cl p1cl (0Cl) =
      p0cl
    inductionCl _ p psing p*cl p+cl p0cl p1cl (1Cl) =
      p1cl
    inductionOp :
      (n : Nat)
      (P : OpRingoid01SigTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRingoid01SigTerm n)
       (x2 : OpRingoid01SigTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpRingoid01SigTerm n)
       (x2 : OpRingoid01SigTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      P 0OL ->
      P 1OL ->
      (x : OpRingoid01SigTerm n) ->
      P x
    inductionOp _ p pv p*ol p+ol p0ol p1ol (v
                                            x1) = pv x1
    inductionOp _ p pv p*ol p+ol p0ol p1ol (*OL
                                            x1
                                            x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           p0ol
           p1ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           p0ol
           p1ol
           x2)
    inductionOp _ p pv p*ol p+ol p0ol p1ol (+OL
                                            x1
                                            x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           p0ol
           p1ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           p0ol
           p1ol
           x2)
    inductionOp _ p pv p*ol p+ol p0ol p1ol (0OL) =
      p0ol
    inductionOp _ p pv p*ol p+ol p0ol p1ol (1OL) =
      p1ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRingoid01SigTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRingoid01SigTerm2 n A)
       (x2 : OpRingoid01SigTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpRingoid01SigTerm2 n A)
       (x2 : OpRingoid01SigTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      P 0OL2 ->
      P 1OL2 ->
      (x : OpRingoid01SigTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (v2
                                                           x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (sing2
                                                           x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (*OL2
                                                           x1
                                                           x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           p1ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           p1ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (+OL2
                                                           x1
                                                           x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           p1ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           p1ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 p1ol2 (1OL2) =
      p1ol2
    *L' :
      Ringoid01SigTerm ->
      Ringoid01SigTerm ->
      Ringoid01SigTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      Ringoid01SigTerm ->
      Ringoid01SigTerm ->
      Ringoid01SigTerm
    +L' x1 x2 = +L x1 x2
    0L' : Ringoid01SigTerm
    0L' = 0L
    1L' : Ringoid01SigTerm
    1L' = 1L
    stageB :
      Ringoid01SigTerm ->
      Staged Ringoid01SigTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (0L) = Now 0L
    stageB (1L) = Now 1L
    *Cl' :
      (A : Set) ->
      ClRingoid01SigTerm A ->
      ClRingoid01SigTerm A ->
      ClRingoid01SigTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClRingoid01SigTerm A ->
      ClRingoid01SigTerm A ->
      ClRingoid01SigTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    0Cl' :
      (A : Set) ->
      ClRingoid01SigTerm A
    0Cl' _ = 0Cl
    1Cl' :
      (A : Set) ->
      ClRingoid01SigTerm A
    1Cl' _ = 1Cl
    stageCl :
      (A : Set) ->
      ClRingoid01SigTerm A ->
      Staged (ClRingoid01SigTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (1Cl) = Now 1Cl
    *OL' :
      (n : Nat) ->
      OpRingoid01SigTerm n ->
      OpRingoid01SigTerm n ->
      OpRingoid01SigTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpRingoid01SigTerm n ->
      OpRingoid01SigTerm n ->
      OpRingoid01SigTerm n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      OpRingoid01SigTerm n
    0OL' _ = 0OL
    1OL' :
      (n : Nat) ->
      OpRingoid01SigTerm n
    1OL' _ = 1OL
    stageOp :
      (n : Nat) ->
      OpRingoid01SigTerm n ->
      Staged (OpRingoid01SigTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (0OL) = Now 0OL
    stageOp _ (1OL) = Now 1OL
    *OL2' :
      (n : Nat) (A : Set) ->
      OpRingoid01SigTerm2 n A ->
      OpRingoid01SigTerm2 n A ->
      OpRingoid01SigTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpRingoid01SigTerm2 n A ->
      OpRingoid01SigTerm2 n A ->
      OpRingoid01SigTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    0OL2' :
      (n : Nat) (A : Set) ->
      OpRingoid01SigTerm2 n A
    0OL2' _ _ = 0OL2
    1OL2' :
      (n : Nat) (A : Set) ->
      OpRingoid01SigTerm2 n A
    1OL2' _ _ = 1OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRingoid01SigTerm2 n A ->
      Staged (OpRingoid01SigTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (1OL2) = Now 1OL2
    record Ringoid01SigTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
        0T : Repr A
        1T : Repr A
  
  module Ringoid0Sig where
    record Ringoid0Sig
      (A : Set) : Set where
      constructor Ringoid0SigC
      field
        0 : A
        + : A -> A -> A
        * : A -> A -> A
    record Ringoid0SigSig
      (AS : Set) : Set where
      constructor Ringoid0SigSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
    record Ringoid0SigProd
      (AP : Set) : Set where
      constructor Ringoid0SigProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record Ringoid0SigHom
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid0Sig A1)
      (Ri2 : Ringoid0Sig A2) :
      Set where
      constructor Ringoid0SigHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ri1) == 0 Ri2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
    record Ringoid0SigRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid0Sig A1)
      (Ri2 : Ringoid0Sig A2) :
      Set where
      constructor Ringoid0SigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ri1) (0 Ri2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
    data Ringoid0SigTerm : Set where
      0L : Ringoid0SigTerm
      +L :
        Ringoid0SigTerm ->
        Ringoid0SigTerm ->
        Ringoid0SigTerm
      *L :
        Ringoid0SigTerm ->
        Ringoid0SigTerm ->
        Ringoid0SigTerm
    data ClRingoid0SigTerm
      (A : Set) : Set where
      sing :
        A -> ClRingoid0SigTerm A
      0Cl : ClRingoid0SigTerm A
      +Cl :
        ClRingoid0SigTerm A ->
        ClRingoid0SigTerm A ->
        ClRingoid0SigTerm A
      *Cl :
        ClRingoid0SigTerm A ->
        ClRingoid0SigTerm A ->
        ClRingoid0SigTerm A
    data OpRingoid0SigTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpRingoid0SigTerm n
      0OL : OpRingoid0SigTerm n
      +OL :
        OpRingoid0SigTerm n ->
        OpRingoid0SigTerm n ->
        OpRingoid0SigTerm n
      *OL :
        OpRingoid0SigTerm n ->
        OpRingoid0SigTerm n ->
        OpRingoid0SigTerm n
    data OpRingoid0SigTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpRingoid0SigTerm2 n A
      sing2 :
        A -> OpRingoid0SigTerm2 n A
      0OL2 : OpRingoid0SigTerm2 n A
      +OL2 :
        OpRingoid0SigTerm2 n A ->
        OpRingoid0SigTerm2 n A ->
        OpRingoid0SigTerm2 n A
      *OL2 :
        OpRingoid0SigTerm2 n A ->
        OpRingoid0SigTerm2 n A ->
        OpRingoid0SigTerm2 n A
    simplifyB :
      Ringoid0SigTerm ->
      Ringoid0SigTerm
    simplifyB (0L) = 0L
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRingoid0SigTerm A ->
      ClRingoid0SigTerm A
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRingoid0SigTerm n ->
      OpRingoid0SigTerm n
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRingoid0SigTerm2 n A ->
      OpRingoid0SigTerm2 n A
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Ringoid0Sig A ->
      Ringoid0SigTerm -> A
    evalB _ Ri (0L) = 0 Ri
    evalB _ Ri (+L x1 x2) =
      + Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalB _ Ri (*L x1 x2) =
      * Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      Ringoid0Sig A ->
      ClRingoid0SigTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (0Cl) = 0 Ri
    evalCl _ Ri (+Cl x1 x2) =
      + Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalCl _ Ri (*Cl x1 x2) =
      * Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Ringoid0Sig A ->
      Vec A n ->
      OpRingoid0SigTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (0OL) = 0 Ri
    evalOp _ n Ri vars (+OL x1 x2) =
      + Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOp _ n Ri vars (*OL x1 x2) =
      * Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Ringoid0Sig A ->
      Vec A n ->
      OpRingoid0SigTerm2 n A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (0OL2) =
      0 Ri
    evalOpE _ n Ri vars (+OL2
                         x1
                         x2) =
      + Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    evalOpE _ n Ri vars (*OL2
                         x1
                         x2) =
      * Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : Ringoid0SigTerm -> Set) ->
      P 0L ->
      ((x1 : Ringoid0SigTerm)
       (x2 : Ringoid0SigTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      ((x1 : Ringoid0SigTerm)
       (x2 : Ringoid0SigTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      (x : Ringoid0SigTerm) -> P x
    inductionB p p0l p+l p*l (0L) =
      p0l
    inductionB p p0l p+l p*l (+L
                              x1
                              x2) =
      p+l _ _
        (inductionB p p0l p+l p*l x1)
        (inductionB p p0l p+l p*l x2)
    inductionB p p0l p+l p*l (*L
                              x1
                              x2) =
      p*l _ _
        (inductionB p p0l p+l p*l x1)
        (inductionB p p0l p+l p*l x2)
    inductionCl :
      (A : Set)
      (P : ClRingoid0SigTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 0Cl ->
      ((x1 : ClRingoid0SigTerm A)
       (x2 : ClRingoid0SigTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      ((x1 : ClRingoid0SigTerm A)
       (x2 : ClRingoid0SigTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      (x : ClRingoid0SigTerm A) -> P x
    inductionCl _ p psing p0cl p+cl p*cl (sing
                                          x1) = psing x1
    inductionCl _ p psing p0cl p+cl p*cl (0Cl) =
      p0cl
    inductionCl _ p psing p0cl p+cl p*cl (+Cl
                                          x1
                                          x2) =
      p+cl _ _
        (inductionCl _ p psing p0cl p+cl
           p*cl
           x1)
        (inductionCl _ p psing p0cl p+cl
           p*cl
           x2)
    inductionCl _ p psing p0cl p+cl p*cl (*Cl
                                          x1
                                          x2) =
      p*cl _ _
        (inductionCl _ p psing p0cl p+cl
           p*cl
           x1)
        (inductionCl _ p psing p0cl p+cl
           p*cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpRingoid0SigTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 0OL ->
      ((x1 : OpRingoid0SigTerm n)
       (x2 : OpRingoid0SigTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      ((x1 : OpRingoid0SigTerm n)
       (x2 : OpRingoid0SigTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      (x : OpRingoid0SigTerm n) -> P x
    inductionOp _ p pv p0ol p+ol p*ol (v
                                       x1) = pv x1
    inductionOp _ p pv p0ol p+ol p*ol (0OL) =
      p0ol
    inductionOp _ p pv p0ol p+ol p*ol (+OL
                                       x1
                                       x2) =
      p+ol _ _
        (inductionOp _ p pv p0ol p+ol
           p*ol
           x1)
        (inductionOp _ p pv p0ol p+ol
           p*ol
           x2)
    inductionOp _ p pv p0ol p+ol p*ol (*OL
                                       x1
                                       x2) =
      p*ol _ _
        (inductionOp _ p pv p0ol p+ol
           p*ol
           x1)
        (inductionOp _ p pv p0ol p+ol
           p*ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRingoid0SigTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 0OL2 ->
      ((x1 : OpRingoid0SigTerm2 n A)
       (x2 : OpRingoid0SigTerm2 n A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      ((x1 : OpRingoid0SigTerm2 n A)
       (x2 : OpRingoid0SigTerm2 n A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      (x : OpRingoid0SigTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 (v2
                                                     x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 (sing2
                                                     x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 (+OL2
                                                     x1
                                                     x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           p*ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 (*OL2
                                                     x1
                                                     x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           p*ol2
           x2)
    0L' : Ringoid0SigTerm
    0L' = 0L
    +L' :
      Ringoid0SigTerm ->
      Ringoid0SigTerm ->
      Ringoid0SigTerm
    +L' x1 x2 = +L x1 x2
    *L' :
      Ringoid0SigTerm ->
      Ringoid0SigTerm ->
      Ringoid0SigTerm
    *L' x1 x2 = *L x1 x2
    stageB :
      Ringoid0SigTerm ->
      Staged Ringoid0SigTerm
    stageB (0L) = Now 0L
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    0Cl' :
      (A : Set) -> ClRingoid0SigTerm A
    0Cl' _ = 0Cl
    +Cl' :
      (A : Set) ->
      ClRingoid0SigTerm A ->
      ClRingoid0SigTerm A ->
      ClRingoid0SigTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    *Cl' :
      (A : Set) ->
      ClRingoid0SigTerm A ->
      ClRingoid0SigTerm A ->
      ClRingoid0SigTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    stageCl :
      (A : Set) ->
      ClRingoid0SigTerm A ->
      Staged (ClRingoid0SigTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    0OL' :
      (n : Nat) -> OpRingoid0SigTerm n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      OpRingoid0SigTerm n ->
      OpRingoid0SigTerm n ->
      OpRingoid0SigTerm n
    +OL' _ x1 x2 = +OL x1 x2
    *OL' :
      (n : Nat) ->
      OpRingoid0SigTerm n ->
      OpRingoid0SigTerm n ->
      OpRingoid0SigTerm n
    *OL' _ x1 x2 = *OL x1 x2
    stageOp :
      (n : Nat) ->
      OpRingoid0SigTerm n ->
      Staged (OpRingoid0SigTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (0OL) = Now 0OL
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    0OL2' :
      (n : Nat) (A : Set) ->
      OpRingoid0SigTerm2 n A
    0OL2' _ _ = 0OL2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpRingoid0SigTerm2 n A ->
      OpRingoid0SigTerm2 n A ->
      OpRingoid0SigTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    *OL2' :
      (n : Nat) (A : Set) ->
      OpRingoid0SigTerm2 n A ->
      OpRingoid0SigTerm2 n A ->
      OpRingoid0SigTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRingoid0SigTerm2 n A ->
      Staged (OpRingoid0SigTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record Ringoid0SigTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        0T : Repr A
        +T : Repr A -> Repr A -> Repr A
        *T : Repr A -> Repr A -> Repr A
  
  module Ringoid1 where
    record Ringoid1
      (A : Set) : Set where
      constructor Ringoid1C
      field
        * : A -> A -> A
        + : A -> A -> A
        1 : A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record Ringoid1Sig
      (AS : Set) : Set where
      constructor Ringoid1SigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        1S : AS
    record Ringoid1Prod
      (AP : Set) : Set where
      constructor Ringoid1ProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record Ringoid1Hom
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid1 A1)
      (Ri2 : Ringoid1 A2) : Set where
      constructor Ringoid1HomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
        pres-1 : hom (1 Ri1) == 1 Ri2
    record Ringoid1RelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid1 A1)
      (Ri2 : Ringoid1 A2) : Set where
      constructor Ringoid1RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
        interp-1 :
          interp (1 Ri1) (1 Ri2)
    data Ringoid1LTerm : Set where
      *L :
        Ringoid1LTerm ->
        Ringoid1LTerm -> Ringoid1LTerm
      +L :
        Ringoid1LTerm ->
        Ringoid1LTerm -> Ringoid1LTerm
      1L : Ringoid1LTerm
    data ClRingoid1ClTerm
      (A : Set) : Set where
      sing : A -> ClRingoid1ClTerm A
      *Cl :
        ClRingoid1ClTerm A ->
        ClRingoid1ClTerm A ->
        ClRingoid1ClTerm A
      +Cl :
        ClRingoid1ClTerm A ->
        ClRingoid1ClTerm A ->
        ClRingoid1ClTerm A
      1Cl : ClRingoid1ClTerm A
    data OpRingoid1OLTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpRingoid1OLTerm n
      *OL :
        OpRingoid1OLTerm n ->
        OpRingoid1OLTerm n ->
        OpRingoid1OLTerm n
      +OL :
        OpRingoid1OLTerm n ->
        OpRingoid1OLTerm n ->
        OpRingoid1OLTerm n
      1OL : OpRingoid1OLTerm n
    data OpRingoid1OL2Term2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpRingoid1OL2Term2 n A
      sing2 :
        A -> OpRingoid1OL2Term2 n A
      *OL2 :
        OpRingoid1OL2Term2 n A ->
        OpRingoid1OL2Term2 n A ->
        OpRingoid1OL2Term2 n A
      +OL2 :
        OpRingoid1OL2Term2 n A ->
        OpRingoid1OL2Term2 n A ->
        OpRingoid1OL2Term2 n A
      1OL2 : OpRingoid1OL2Term2 n A
    simplifyB :
      Ringoid1LTerm -> Ringoid1LTerm
    simplifyB (+L
               (*L x y)
               (*L x z)) = *L x (+L y z)
    simplifyB (+L
               (*L y x)
               (*L z x)) = *L (+L y z) x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (1L) = 1L
    simplifyCl :
      (A : Set) ->
      ClRingoid1ClTerm A ->
      ClRingoid1ClTerm A
    simplifyCl _ (+Cl
                  (*Cl x y)
                  (*Cl x z)) = *Cl x (+Cl y z)
    simplifyCl _ (+Cl
                  (*Cl y x)
                  (*Cl z x)) = *Cl (+Cl y z) x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRingoid1OLTerm n ->
      OpRingoid1OLTerm n
    simplifyOp _ (+OL
                  (*OL x y)
                  (*OL x z)) = *OL x (+OL y z)
    simplifyOp _ (+OL
                  (*OL y x)
                  (*OL z x)) = *OL (+OL y z) x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRingoid1OL2Term2 n A ->
      OpRingoid1OL2Term2 n A
    simplifyOpE _ _ (+OL2
                     (*OL2 x y)
                     (*OL2 x z)) = *OL2 x (+OL2 y z)
    simplifyOpE _ _ (+OL2
                     (*OL2 y x)
                     (*OL2 z x)) = *OL2 (+OL2 y z) x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Ringoid1 A -> Ringoid1LTerm -> A
    evalB _ Ri (*L x1 x2) =
      * Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalB _ Ri (+L x1 x2) =
      + Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalB _ Ri (1L) = 1 Ri
    evalCl :
      (A : Set) ->
      Ringoid1 A ->
      ClRingoid1ClTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (*Cl x1 x2) =
      * Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalCl _ Ri (+Cl x1 x2) =
      + Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalCl _ Ri (1Cl) = 1 Ri
    evalOp :
      (A : Set) (n : Nat) ->
      Ringoid1 A ->
      Vec A n ->
      OpRingoid1OLTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (*OL x1 x2) =
      * Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOp _ n Ri vars (+OL x1 x2) =
      + Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOp _ n Ri vars (1OL) = 1 Ri
    evalOpE :
      (A : Set) (n : Nat) ->
      Ringoid1 A ->
      Vec A n ->
      OpRingoid1OL2Term2 n A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (*OL2
                         x1
                         x2) =
      * Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    evalOpE _ n Ri vars (+OL2
                         x1
                         x2) =
      + Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    evalOpE _ n Ri vars (1OL2) =
      1 Ri
    inductionB :
      (P : Ringoid1LTerm -> Set) ->
      ((x1 : Ringoid1LTerm)
       (x2 : Ringoid1LTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : Ringoid1LTerm)
       (x2 : Ringoid1LTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      P 1L ->
      (x : Ringoid1LTerm) -> P x
    inductionB p p*l p+l p1l (*L
                              x1
                              x2) =
      p*l _ _
        (inductionB p p*l p+l p1l x1)
        (inductionB p p*l p+l p1l x2)
    inductionB p p*l p+l p1l (+L
                              x1
                              x2) =
      p+l _ _
        (inductionB p p*l p+l p1l x1)
        (inductionB p p*l p+l p1l x2)
    inductionB p p*l p+l p1l (1L) =
      p1l
    inductionCl :
      (A : Set)
      (P : ClRingoid1ClTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRingoid1ClTerm A)
       (x2 : ClRingoid1ClTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClRingoid1ClTerm A)
       (x2 : ClRingoid1ClTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      P 1Cl ->
      (x : ClRingoid1ClTerm A) -> P x
    inductionCl _ p psing p*cl p+cl p1cl (sing
                                          x1) = psing x1
    inductionCl _ p psing p*cl p+cl p1cl (*Cl
                                          x1
                                          x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           p1cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           p1cl
           x2)
    inductionCl _ p psing p*cl p+cl p1cl (+Cl
                                          x1
                                          x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           p1cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           p1cl
           x2)
    inductionCl _ p psing p*cl p+cl p1cl (1Cl) =
      p1cl
    inductionOp :
      (n : Nat)
      (P : OpRingoid1OLTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRingoid1OLTerm n)
       (x2 : OpRingoid1OLTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpRingoid1OLTerm n)
       (x2 : OpRingoid1OLTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      P 1OL ->
      (x : OpRingoid1OLTerm n) -> P x
    inductionOp _ p pv p*ol p+ol p1ol (v
                                       x1) = pv x1
    inductionOp _ p pv p*ol p+ol p1ol (*OL
                                       x1
                                       x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           p1ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           p1ol
           x2)
    inductionOp _ p pv p*ol p+ol p1ol (+OL
                                       x1
                                       x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           p1ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           p1ol
           x2)
    inductionOp _ p pv p*ol p+ol p1ol (1OL) =
      p1ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRingoid1OL2Term2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRingoid1OL2Term2 n A)
       (x2 : OpRingoid1OL2Term2 n A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpRingoid1OL2Term2 n A)
       (x2 : OpRingoid1OL2Term2 n A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      P 1OL2 ->
      (x : OpRingoid1OL2Term2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p1ol2 (v2
                                                     x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p1ol2 (sing2
                                                     x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p1ol2 (*OL2
                                                     x1
                                                     x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p1ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p1ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p1ol2 (+OL2
                                                     x1
                                                     x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p1ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p1ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p1ol2 (1OL2) =
      p1ol2
    *L' :
      Ringoid1LTerm ->
      Ringoid1LTerm -> Ringoid1LTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      Ringoid1LTerm ->
      Ringoid1LTerm -> Ringoid1LTerm
    +L' x1 x2 = +L x1 x2
    1L' : Ringoid1LTerm
    1L' = 1L
    stageB :
      Ringoid1LTerm ->
      Staged Ringoid1LTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (1L) = Now 1L
    *Cl' :
      (A : Set) ->
      ClRingoid1ClTerm A ->
      ClRingoid1ClTerm A ->
      ClRingoid1ClTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClRingoid1ClTerm A ->
      ClRingoid1ClTerm A ->
      ClRingoid1ClTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    1Cl' :
      (A : Set) -> ClRingoid1ClTerm A
    1Cl' _ = 1Cl
    stageCl :
      (A : Set) ->
      ClRingoid1ClTerm A ->
      Staged (ClRingoid1ClTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (1Cl) = Now 1Cl
    *OL' :
      (n : Nat) ->
      OpRingoid1OLTerm n ->
      OpRingoid1OLTerm n ->
      OpRingoid1OLTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpRingoid1OLTerm n ->
      OpRingoid1OLTerm n ->
      OpRingoid1OLTerm n
    +OL' _ x1 x2 = +OL x1 x2
    1OL' :
      (n : Nat) -> OpRingoid1OLTerm n
    1OL' _ = 1OL
    stageOp :
      (n : Nat) ->
      OpRingoid1OLTerm n ->
      Staged (OpRingoid1OLTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (1OL) = Now 1OL
    *OL2' :
      (n : Nat) (A : Set) ->
      OpRingoid1OL2Term2 n A ->
      OpRingoid1OL2Term2 n A ->
      OpRingoid1OL2Term2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpRingoid1OL2Term2 n A ->
      OpRingoid1OL2Term2 n A ->
      OpRingoid1OL2Term2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    1OL2' :
      (n : Nat) (A : Set) ->
      OpRingoid1OL2Term2 n A
    1OL2' _ _ = 1OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRingoid1OL2Term2 n A ->
      Staged (OpRingoid1OL2Term2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (1OL2) = Now 1OL2
    record Ringoid1Tagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
        1T : Repr A
  
  module Ringoid1Sig where
    record Ringoid1Sig
      (A : Set) : Set where
      constructor Ringoid1SigC
      field
        * : A -> A -> A
        1 : A
        + : A -> A -> A
    record Ringoid1SigSig
      (AS : Set) : Set where
      constructor Ringoid1SigSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
        +S : AS -> AS -> AS
    record Ringoid1SigProd
      (AP : Set) : Set where
      constructor Ringoid1SigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record Ringoid1SigHom
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid1Sig A1)
      (Ri2 : Ringoid1Sig A2) :
      Set where
      constructor Ringoid1SigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-1 : hom (1 Ri1) == 1 Ri2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
    record Ringoid1SigRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : Ringoid1Sig A1)
      (Ri2 : Ringoid1Sig A2) :
      Set where
      constructor Ringoid1SigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-1 :
          interp (1 Ri1) (1 Ri2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
    data Ringoid1SigTerm : Set where
      *L :
        Ringoid1SigTerm ->
        Ringoid1SigTerm ->
        Ringoid1SigTerm
      1L : Ringoid1SigTerm
      +L :
        Ringoid1SigTerm ->
        Ringoid1SigTerm ->
        Ringoid1SigTerm
    data ClRingoid1SigTerm
      (A : Set) : Set where
      sing :
        A -> ClRingoid1SigTerm A
      *Cl :
        ClRingoid1SigTerm A ->
        ClRingoid1SigTerm A ->
        ClRingoid1SigTerm A
      1Cl : ClRingoid1SigTerm A
      +Cl :
        ClRingoid1SigTerm A ->
        ClRingoid1SigTerm A ->
        ClRingoid1SigTerm A
    data OpRingoid1SigTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpRingoid1SigTerm n
      *OL :
        OpRingoid1SigTerm n ->
        OpRingoid1SigTerm n ->
        OpRingoid1SigTerm n
      1OL : OpRingoid1SigTerm n
      +OL :
        OpRingoid1SigTerm n ->
        OpRingoid1SigTerm n ->
        OpRingoid1SigTerm n
    data OpRingoid1SigTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpRingoid1SigTerm2 n A
      sing2 :
        A -> OpRingoid1SigTerm2 n A
      *OL2 :
        OpRingoid1SigTerm2 n A ->
        OpRingoid1SigTerm2 n A ->
        OpRingoid1SigTerm2 n A
      1OL2 : OpRingoid1SigTerm2 n A
      +OL2 :
        OpRingoid1SigTerm2 n A ->
        OpRingoid1SigTerm2 n A ->
        OpRingoid1SigTerm2 n A
    simplifyB :
      Ringoid1SigTerm ->
      Ringoid1SigTerm
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (1L) = 1L
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRingoid1SigTerm A ->
      ClRingoid1SigTerm A
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRingoid1SigTerm n ->
      OpRingoid1SigTerm n
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRingoid1SigTerm2 n A ->
      OpRingoid1SigTerm2 n A
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Ringoid1Sig A ->
      Ringoid1SigTerm -> A
    evalB _ Ri (*L x1 x2) =
      * Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalB _ Ri (1L) = 1 Ri
    evalB _ Ri (+L x1 x2) =
      + Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      Ringoid1Sig A ->
      ClRingoid1SigTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (*Cl x1 x2) =
      * Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalCl _ Ri (1Cl) = 1 Ri
    evalCl _ Ri (+Cl x1 x2) =
      + Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Ringoid1Sig A ->
      Vec A n ->
      OpRingoid1SigTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (*OL x1 x2) =
      * Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOp _ n Ri vars (1OL) = 1 Ri
    evalOp _ n Ri vars (+OL x1 x2) =
      + Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Ringoid1Sig A ->
      Vec A n ->
      OpRingoid1SigTerm2 n A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (*OL2
                         x1
                         x2) =
      * Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    evalOpE _ n Ri vars (1OL2) =
      1 Ri
    evalOpE _ n Ri vars (+OL2
                         x1
                         x2) =
      + Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : Ringoid1SigTerm -> Set) ->
      ((x1 : Ringoid1SigTerm)
       (x2 : Ringoid1SigTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      P 1L ->
      ((x1 : Ringoid1SigTerm)
       (x2 : Ringoid1SigTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : Ringoid1SigTerm) -> P x
    inductionB p p*l p1l p+l (*L
                              x1
                              x2) =
      p*l _ _
        (inductionB p p*l p1l p+l x1)
        (inductionB p p*l p1l p+l x2)
    inductionB p p*l p1l p+l (1L) =
      p1l
    inductionB p p*l p1l p+l (+L
                              x1
                              x2) =
      p+l _ _
        (inductionB p p*l p1l p+l x1)
        (inductionB p p*l p1l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClRingoid1SigTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRingoid1SigTerm A)
       (x2 : ClRingoid1SigTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      P 1Cl ->
      ((x1 : ClRingoid1SigTerm A)
       (x2 : ClRingoid1SigTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClRingoid1SigTerm A) -> P x
    inductionCl _ p psing p*cl p1cl p+cl (sing
                                          x1) = psing x1
    inductionCl _ p psing p*cl p1cl p+cl (*Cl
                                          x1
                                          x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p1cl
           p+cl
           x1)
        (inductionCl _ p psing p*cl p1cl
           p+cl
           x2)
    inductionCl _ p psing p*cl p1cl p+cl (1Cl) =
      p1cl
    inductionCl _ p psing p*cl p1cl p+cl (+Cl
                                          x1
                                          x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p1cl
           p+cl
           x1)
        (inductionCl _ p psing p*cl p1cl
           p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpRingoid1SigTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRingoid1SigTerm n)
       (x2 : OpRingoid1SigTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      P 1OL ->
      ((x1 : OpRingoid1SigTerm n)
       (x2 : OpRingoid1SigTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpRingoid1SigTerm n) -> P x
    inductionOp _ p pv p*ol p1ol p+ol (v
                                       x1) = pv x1
    inductionOp _ p pv p*ol p1ol p+ol (*OL
                                       x1
                                       x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p1ol
           p+ol
           x1)
        (inductionOp _ p pv p*ol p1ol
           p+ol
           x2)
    inductionOp _ p pv p*ol p1ol p+ol (1OL) =
      p1ol
    inductionOp _ p pv p*ol p1ol p+ol (+OL
                                       x1
                                       x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p1ol
           p+ol
           x1)
        (inductionOp _ p pv p*ol p1ol
           p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRingoid1SigTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRingoid1SigTerm2 n A)
       (x2 : OpRingoid1SigTerm2 n A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      P 1OL2 ->
      ((x1 : OpRingoid1SigTerm2 n A)
       (x2 : OpRingoid1SigTerm2 n A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpRingoid1SigTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 (v2
                                                     x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 (sing2
                                                     x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 (*OL2
                                                     x1
                                                     x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 (1OL2) =
      p1ol2
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 (+OL2
                                                     x1
                                                     x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           p+ol2
           x2)
    *L' :
      Ringoid1SigTerm ->
      Ringoid1SigTerm ->
      Ringoid1SigTerm
    *L' x1 x2 = *L x1 x2
    1L' : Ringoid1SigTerm
    1L' = 1L
    +L' :
      Ringoid1SigTerm ->
      Ringoid1SigTerm ->
      Ringoid1SigTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      Ringoid1SigTerm ->
      Staged Ringoid1SigTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (1L) = Now 1L
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClRingoid1SigTerm A ->
      ClRingoid1SigTerm A ->
      ClRingoid1SigTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    1Cl' :
      (A : Set) -> ClRingoid1SigTerm A
    1Cl' _ = 1Cl
    +Cl' :
      (A : Set) ->
      ClRingoid1SigTerm A ->
      ClRingoid1SigTerm A ->
      ClRingoid1SigTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClRingoid1SigTerm A ->
      Staged (ClRingoid1SigTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (1Cl) = Now 1Cl
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpRingoid1SigTerm n ->
      OpRingoid1SigTerm n ->
      OpRingoid1SigTerm n
    *OL' _ x1 x2 = *OL x1 x2
    1OL' :
      (n : Nat) -> OpRingoid1SigTerm n
    1OL' _ = 1OL
    +OL' :
      (n : Nat) ->
      OpRingoid1SigTerm n ->
      OpRingoid1SigTerm n ->
      OpRingoid1SigTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpRingoid1SigTerm n ->
      Staged (OpRingoid1SigTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (1OL) = Now 1OL
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpRingoid1SigTerm2 n A ->
      OpRingoid1SigTerm2 n A ->
      OpRingoid1SigTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    1OL2' :
      (n : Nat) (A : Set) ->
      OpRingoid1SigTerm2 n A
    1OL2' _ _ = 1OL2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpRingoid1SigTerm2 n A ->
      OpRingoid1SigTerm2 n A ->
      OpRingoid1SigTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRingoid1SigTerm2 n A ->
      Staged (OpRingoid1SigTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (1OL2) = Now 1OL2
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record Ringoid1SigTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        1T : Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module RingoidSig where
    record RingoidSig
      (A : Set) : Set where
      constructor RingoidSigC
      field
        * : A -> A -> A
        + : A -> A -> A
    record RingoidSigSig
      (AS : Set) : Set where
      constructor RingoidSigSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record RingoidSigProd
      (AP : Set) : Set where
      constructor RingoidSigProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record RingoidSigHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidSig A1)
      (Ri2 : RingoidSig A2) :
      Set where
      constructor RingoidSigHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
    record RingoidSigRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidSig A1)
      (Ri2 : RingoidSig A2) :
      Set where
      constructor RingoidSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
    data RingoidSigTerm : Set where
      *L :
        RingoidSigTerm ->
        RingoidSigTerm -> RingoidSigTerm
      +L :
        RingoidSigTerm ->
        RingoidSigTerm -> RingoidSigTerm
    data ClRingoidSigTerm
      (A : Set) : Set where
      sing : A -> ClRingoidSigTerm A
      *Cl :
        ClRingoidSigTerm A ->
        ClRingoidSigTerm A ->
        ClRingoidSigTerm A
      +Cl :
        ClRingoidSigTerm A ->
        ClRingoidSigTerm A ->
        ClRingoidSigTerm A
    data OpRingoidSigTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpRingoidSigTerm n
      *OL :
        OpRingoidSigTerm n ->
        OpRingoidSigTerm n ->
        OpRingoidSigTerm n
      +OL :
        OpRingoidSigTerm n ->
        OpRingoidSigTerm n ->
        OpRingoidSigTerm n
    data OpRingoidSigTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpRingoidSigTerm2 n A
      sing2 :
        A -> OpRingoidSigTerm2 n A
      *OL2 :
        OpRingoidSigTerm2 n A ->
        OpRingoidSigTerm2 n A ->
        OpRingoidSigTerm2 n A
      +OL2 :
        OpRingoidSigTerm2 n A ->
        OpRingoidSigTerm2 n A ->
        OpRingoidSigTerm2 n A
    simplifyB :
      RingoidSigTerm -> RingoidSigTerm
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRingoidSigTerm A ->
      ClRingoidSigTerm A
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRingoidSigTerm n ->
      OpRingoidSigTerm n
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRingoidSigTerm2 n A ->
      OpRingoidSigTerm2 n A
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RingoidSig A ->
      RingoidSigTerm -> A
    evalB _ Ri (*L x1 x2) =
      * Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalB _ Ri (+L x1 x2) =
      + Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      RingoidSig A ->
      ClRingoidSigTerm A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (*Cl x1 x2) =
      * Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalCl _ Ri (+Cl x1 x2) =
      + Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RingoidSig A ->
      Vec A n ->
      OpRingoidSigTerm n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (*OL x1 x2) =
      * Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOp _ n Ri vars (+OL x1 x2) =
      + Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RingoidSig A ->
      Vec A n ->
      OpRingoidSigTerm2 n A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (*OL2
                         x1
                         x2) =
      * Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    evalOpE _ n Ri vars (+OL2
                         x1
                         x2) =
      + Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RingoidSigTerm -> Set) ->
      ((x1 : RingoidSigTerm)
       (x2 : RingoidSigTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : RingoidSigTerm)
       (x2 : RingoidSigTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : RingoidSigTerm) -> P x
    inductionB p p*l p+l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionB p p*l p+l (+L
                          x1
                          x2) =
      p+l _ _
        (inductionB p p*l p+l x1)
        (inductionB p p*l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClRingoidSigTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRingoidSigTerm A)
       (x2 : ClRingoidSigTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClRingoidSigTerm A)
       (x2 : ClRingoidSigTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClRingoidSigTerm A) -> P x
    inductionCl _ p psing p*cl p+cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p*cl p+cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionCl _ p psing p*cl p+cl (+Cl
                                     x1
                                     x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpRingoidSigTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRingoidSigTerm n)
       (x2 : OpRingoidSigTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpRingoidSigTerm n)
       (x2 : OpRingoidSigTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpRingoidSigTerm n) -> P x
    inductionOp _ p pv p*ol p+ol (v
                                  x1) = pv x1
    inductionOp _ p pv p*ol p+ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOp _ p pv p*ol p+ol (+OL
                                  x1
                                  x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRingoidSigTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRingoidSigTerm2 n A)
       (x2 : OpRingoidSigTerm2 n A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpRingoidSigTerm2 n A)
       (x2 : OpRingoidSigTerm2 n A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpRingoidSigTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 (+OL2
                                               x1
                                               x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           x2)
    *L' :
      RingoidSigTerm ->
      RingoidSigTerm -> RingoidSigTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      RingoidSigTerm ->
      RingoidSigTerm -> RingoidSigTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      RingoidSigTerm ->
      Staged RingoidSigTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClRingoidSigTerm A ->
      ClRingoidSigTerm A ->
      ClRingoidSigTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClRingoidSigTerm A ->
      ClRingoidSigTerm A ->
      ClRingoidSigTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClRingoidSigTerm A ->
      Staged (ClRingoidSigTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpRingoidSigTerm n ->
      OpRingoidSigTerm n ->
      OpRingoidSigTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpRingoidSigTerm n ->
      OpRingoidSigTerm n ->
      OpRingoidSigTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpRingoidSigTerm n ->
      Staged (OpRingoidSigTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpRingoidSigTerm2 n A ->
      OpRingoidSigTerm2 n A ->
      OpRingoidSigTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpRingoidSigTerm2 n A ->
      OpRingoidSigTerm2 n A ->
      OpRingoidSigTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRingoidSigTerm2 n A ->
      Staged (OpRingoidSigTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RingoidSigTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module RingoidWithAddAntiDistrib where
    record RingoidWithAddAntiDistrib
      (A : Set) : Set where
      constructor RingoidWithAddAntiDistribC
      field
        + : A -> A -> A
        prim : A -> A
        antidis_prim_+ :
          (x : A) (y : A) ->
          prim (+ x y) ==
            + (prim y) (prim x)
        * : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record RingoidWithAddAntiDistribSig
      (AS : Set) : Set where
      constructor RingoidWithAddAntiDistribSigSigC
      field
        +S : AS -> AS -> AS
        primS : AS -> AS
        *S : AS -> AS -> AS
    record RingoidWithAddAntiDistribProd
      (AP : Set) : Set where
      constructor RingoidWithAddAntiDistribProdC
      field
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        antidis_prim_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (+P xP yP) ==
            +P (primP yP) (primP xP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record RingoidWithAddAntiDistribHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidWithAddAntiDistrib
         A1)
      (Ri2 : RingoidWithAddAntiDistrib
         A2) : Set where
      constructor RingoidWithAddAntiDistribHomC
      field
        hom : A1 -> A2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Ri1 x1) ==
            prim Ri2 (hom x1)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
    record RingoidWithAddAntiDistribRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidWithAddAntiDistrib
         A1)
      (Ri2 : RingoidWithAddAntiDistrib
         A2) : Set where
      constructor RingoidWithAddAntiDistribRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Ri1 x1)
            (prim Ri2 y1)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
    data RingoidWithAddAntiDistribTerm
      : Set where
      +L :
        RingoidWithAddAntiDistribTerm ->
        RingoidWithAddAntiDistribTerm ->
        RingoidWithAddAntiDistribTerm
      primL :
        RingoidWithAddAntiDistribTerm ->
        RingoidWithAddAntiDistribTerm
      *L :
        RingoidWithAddAntiDistribTerm ->
        RingoidWithAddAntiDistribTerm ->
        RingoidWithAddAntiDistribTerm
    data ClRingoidWithAddAntiDistribTerm
      (A : Set) : Set where
      sing :
        A ->
        ClRingoidWithAddAntiDistribTerm
          A
      +Cl :
        ClRingoidWithAddAntiDistribTerm
          A ->
        ClRingoidWithAddAntiDistribTerm
          A ->
        ClRingoidWithAddAntiDistribTerm
          A
      primCl :
        ClRingoidWithAddAntiDistribTerm
          A ->
        ClRingoidWithAddAntiDistribTerm
          A
      *Cl :
        ClRingoidWithAddAntiDistribTerm
          A ->
        ClRingoidWithAddAntiDistribTerm
          A ->
        ClRingoidWithAddAntiDistribTerm
          A
    data OpRingoidWithAddAntiDistribTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpRingoidWithAddAntiDistribTerm
          n
      +OL :
        OpRingoidWithAddAntiDistribTerm
          n ->
        OpRingoidWithAddAntiDistribTerm
          n ->
        OpRingoidWithAddAntiDistribTerm
          n
      primOL :
        OpRingoidWithAddAntiDistribTerm
          n ->
        OpRingoidWithAddAntiDistribTerm
          n
      *OL :
        OpRingoidWithAddAntiDistribTerm
          n ->
        OpRingoidWithAddAntiDistribTerm
          n ->
        OpRingoidWithAddAntiDistribTerm
          n
    data OpRingoidWithAddAntiDistribTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpRingoidWithAddAntiDistribTerm2
          n
          A
      sing2 :
        A ->
        OpRingoidWithAddAntiDistribTerm2
          n
          A
      +OL2 :
        OpRingoidWithAddAntiDistribTerm2
          n
          A ->
        OpRingoidWithAddAntiDistribTerm2
          n
          A ->
        OpRingoidWithAddAntiDistribTerm2
          n
          A
      primOL2 :
        OpRingoidWithAddAntiDistribTerm2
          n
          A ->
        OpRingoidWithAddAntiDistribTerm2
          n
          A
      *OL2 :
        OpRingoidWithAddAntiDistribTerm2
          n
          A ->
        OpRingoidWithAddAntiDistribTerm2
          n
          A ->
        OpRingoidWithAddAntiDistribTerm2
          n
          A
    simplifyB :
      RingoidWithAddAntiDistribTerm ->
      RingoidWithAddAntiDistribTerm
    simplifyB (+L
               (primL y)
               (primL x)) = primL (+L x y)
    simplifyB (+L
               (*L x y)
               (*L x z)) = *L x (+L y z)
    simplifyB (+L
               (*L y x)
               (*L z x)) = *L (+L y z) x
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRingoidWithAddAntiDistribTerm
        A ->
      ClRingoidWithAddAntiDistribTerm
        A
    simplifyCl _ (+Cl
                  (primCl y)
                  (primCl x)) = primCl (+Cl x y)
    simplifyCl _ (+Cl
                  (*Cl x y)
                  (*Cl x z)) = *Cl x (+Cl y z)
    simplifyCl _ (+Cl
                  (*Cl y x)
                  (*Cl z x)) = *Cl (+Cl y z) x
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRingoidWithAddAntiDistribTerm
        n ->
      OpRingoidWithAddAntiDistribTerm
        n
    simplifyOp _ (+OL
                  (primOL y)
                  (primOL x)) = primOL (+OL x y)
    simplifyOp _ (+OL
                  (*OL x y)
                  (*OL x z)) = *OL x (+OL y z)
    simplifyOp _ (+OL
                  (*OL y x)
                  (*OL z x)) = *OL (+OL y z) x
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRingoidWithAddAntiDistribTerm2
        n
        A ->
      OpRingoidWithAddAntiDistribTerm2
        n
        A
    simplifyOpE _ _ (+OL2
                     (primOL2 y)
                     (primOL2 x)) =
      primOL2 (+OL2 x y)
    simplifyOpE _ _ (+OL2
                     (*OL2 x y)
                     (*OL2 x z)) = *OL2 x (+OL2 y z)
    simplifyOpE _ _ (+OL2
                     (*OL2 y x)
                     (*OL2 z x)) = *OL2 (+OL2 y z) x
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RingoidWithAddAntiDistrib A ->
      RingoidWithAddAntiDistribTerm ->
      A
    evalB _ Ri (+L x1 x2) =
      + Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalB _ Ri (primL x1) =
      prim Ri (evalB _ Ri x1)
    evalB _ Ri (*L x1 x2) =
      * Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      RingoidWithAddAntiDistrib A ->
      ClRingoidWithAddAntiDistribTerm
        A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (+Cl x1 x2) =
      + Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalCl _ Ri (primCl x1) =
      prim Ri (evalCl _ Ri x1)
    evalCl _ Ri (*Cl x1 x2) =
      * Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RingoidWithAddAntiDistrib A ->
      Vec A n ->
      OpRingoidWithAddAntiDistribTerm
        n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (+OL x1 x2) =
      + Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOp _ n Ri vars (primOL x1) =
      prim Ri (evalOp _ n Ri vars x1)
    evalOp _ n Ri vars (*OL x1 x2) =
      * Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RingoidWithAddAntiDistrib A ->
      Vec A n ->
      OpRingoidWithAddAntiDistribTerm2
        n
        A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (+OL2
                         x1
                         x2) =
      + Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    evalOpE _ n Ri vars (primOL2
                         x1) =
      prim Ri (evalOpE _ n Ri vars x1)
    evalOpE _ n Ri vars (*OL2
                         x1
                         x2) =
      * Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RingoidWithAddAntiDistribTerm ->
           Set) ->
      ((x1 : RingoidWithAddAntiDistribTerm)
       (x2 : RingoidWithAddAntiDistribTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      ((x1 : RingoidWithAddAntiDistribTerm) ->
       P x1 -> P (primL x1)) ->
      ((x1 : RingoidWithAddAntiDistribTerm)
       (x2 : RingoidWithAddAntiDistribTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      (x : RingoidWithAddAntiDistribTerm) ->
      P x
    inductionB p p+l ppriml p*l (+L
                                 x1
                                 x2) =
      p+l _ _
        (inductionB p p+l ppriml p*l x1)
        (inductionB p p+l ppriml p*l x2)
    inductionB p p+l ppriml p*l (primL
                                 x1) =
      ppriml _
        (inductionB p p+l ppriml p*l x1)
    inductionB p p+l ppriml p*l (*L
                                 x1
                                 x2) =
      p*l _ _
        (inductionB p p+l ppriml p*l x1)
        (inductionB p p+l ppriml p*l x2)
    inductionCl :
      (A : Set)
      (P : ClRingoidWithAddAntiDistribTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRingoidWithAddAntiDistribTerm
          A)
       (x2 : ClRingoidWithAddAntiDistribTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      ((x1 : ClRingoidWithAddAntiDistribTerm
          A) -> P x1 -> P (primCl x1)) ->
      ((x1 : ClRingoidWithAddAntiDistribTerm
          A)
       (x2 : ClRingoidWithAddAntiDistribTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      (x : ClRingoidWithAddAntiDistribTerm
         A) -> P x
    inductionCl _ p psing p+cl pprimcl p*cl (sing
                                             x1) = psing x1
    inductionCl _ p psing p+cl pprimcl p*cl (+Cl
                                             x1
                                             x2) =
      p+cl _ _
        (inductionCl _ p psing p+cl
           pprimcl
           p*cl
           x1)
        (inductionCl _ p psing p+cl
           pprimcl
           p*cl
           x2)
    inductionCl _ p psing p+cl pprimcl p*cl (primCl
                                             x1) =
      pprimcl _
        (inductionCl _ p psing p+cl
           pprimcl
           p*cl
           x1)
    inductionCl _ p psing p+cl pprimcl p*cl (*Cl
                                             x1
                                             x2) =
      p*cl _ _
        (inductionCl _ p psing p+cl
           pprimcl
           p*cl
           x1)
        (inductionCl _ p psing p+cl
           pprimcl
           p*cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpRingoidWithAddAntiDistribTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRingoidWithAddAntiDistribTerm
          n)
       (x2 : OpRingoidWithAddAntiDistribTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      ((x1 : OpRingoidWithAddAntiDistribTerm
          n) -> P x1 -> P (primOL x1)) ->
      ((x1 : OpRingoidWithAddAntiDistribTerm
          n)
       (x2 : OpRingoidWithAddAntiDistribTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      (x : OpRingoidWithAddAntiDistribTerm
         n) -> P x
    inductionOp _ p pv p+ol pprimol p*ol (v
                                          x1) = pv x1
    inductionOp _ p pv p+ol pprimol p*ol (+OL
                                          x1
                                          x2) =
      p+ol _ _
        (inductionOp _ p pv p+ol pprimol
           p*ol
           x1)
        (inductionOp _ p pv p+ol pprimol
           p*ol
           x2)
    inductionOp _ p pv p+ol pprimol p*ol (primOL
                                          x1) =
      pprimol _
        (inductionOp _ p pv p+ol pprimol
           p*ol
           x1)
    inductionOp _ p pv p+ol pprimol p*ol (*OL
                                          x1
                                          x2) =
      p*ol _ _
        (inductionOp _ p pv p+ol pprimol
           p*ol
           x1)
        (inductionOp _ p pv p+ol pprimol
           p*ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRingoidWithAddAntiDistribTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRingoidWithAddAntiDistribTerm2
          n
          A)
       (x2 : OpRingoidWithAddAntiDistribTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      ((x1 : OpRingoidWithAddAntiDistribTerm2
          n
          A) -> P x1 -> P (primOL2 x1)) ->
      ((x1 : OpRingoidWithAddAntiDistribTerm2
          n
          A)
       (x2 : OpRingoidWithAddAntiDistribTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      (x : OpRingoidWithAddAntiDistribTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p+ol2 pprimol2 p*ol2 (v2
                                                        x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 pprimol2 p*ol2 (sing2
                                                        x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p+ol2 pprimol2 p*ol2 (+OL2
                                                        x1
                                                        x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           pprimol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           pprimol2
           p*ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p+ol2 pprimol2 p*ol2 (primOL2
                                                        x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           pprimol2
           p*ol2
           x1)
    inductionOpE _ _ p pv2 psing2 p+ol2 pprimol2 p*ol2 (*OL2
                                                        x1
                                                        x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           pprimol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p+ol2
           pprimol2
           p*ol2
           x2)
    +L' :
      RingoidWithAddAntiDistribTerm ->
      RingoidWithAddAntiDistribTerm ->
      RingoidWithAddAntiDistribTerm
    +L' x1 x2 = +L x1 x2
    primL' :
      RingoidWithAddAntiDistribTerm ->
      RingoidWithAddAntiDistribTerm
    primL' x1 = primL x1
    *L' :
      RingoidWithAddAntiDistribTerm ->
      RingoidWithAddAntiDistribTerm ->
      RingoidWithAddAntiDistribTerm
    *L' x1 x2 = *L x1 x2
    stageB :
      RingoidWithAddAntiDistribTerm ->
      Staged
        RingoidWithAddAntiDistribTerm
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    +Cl' :
      (A : Set) ->
      ClRingoidWithAddAntiDistribTerm
        A ->
      ClRingoidWithAddAntiDistribTerm
        A ->
      ClRingoidWithAddAntiDistribTerm
        A
    +Cl' _ x1 x2 = +Cl x1 x2
    primCl' :
      (A : Set) ->
      ClRingoidWithAddAntiDistribTerm
        A ->
      ClRingoidWithAddAntiDistribTerm
        A
    primCl' _ x1 = primCl x1
    *Cl' :
      (A : Set) ->
      ClRingoidWithAddAntiDistribTerm
        A ->
      ClRingoidWithAddAntiDistribTerm
        A ->
      ClRingoidWithAddAntiDistribTerm
        A
    *Cl' _ x1 x2 = *Cl x1 x2
    stageCl :
      (A : Set) ->
      ClRingoidWithAddAntiDistribTerm
        A ->
      Staged
        (ClRingoidWithAddAntiDistribTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    +OL' :
      (n : Nat) ->
      OpRingoidWithAddAntiDistribTerm
        n ->
      OpRingoidWithAddAntiDistribTerm
        n ->
      OpRingoidWithAddAntiDistribTerm
        n
    +OL' _ x1 x2 = +OL x1 x2
    primOL' :
      (n : Nat) ->
      OpRingoidWithAddAntiDistribTerm
        n ->
      OpRingoidWithAddAntiDistribTerm
        n
    primOL' _ x1 = primOL x1
    *OL' :
      (n : Nat) ->
      OpRingoidWithAddAntiDistribTerm
        n ->
      OpRingoidWithAddAntiDistribTerm
        n ->
      OpRingoidWithAddAntiDistribTerm
        n
    *OL' _ x1 x2 = *OL x1 x2
    stageOp :
      (n : Nat) ->
      OpRingoidWithAddAntiDistribTerm
        n ->
      Staged
        (OpRingoidWithAddAntiDistribTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    +OL2' :
      (n : Nat) (A : Set) ->
      OpRingoidWithAddAntiDistribTerm2
        n
        A ->
      OpRingoidWithAddAntiDistribTerm2
        n
        A ->
      OpRingoidWithAddAntiDistribTerm2
        n
        A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    primOL2' :
      (n : Nat) (A : Set) ->
      OpRingoidWithAddAntiDistribTerm2
        n
        A ->
      OpRingoidWithAddAntiDistribTerm2
        n
        A
    primOL2' _ _ x1 = primOL2 x1
    *OL2' :
      (n : Nat) (A : Set) ->
      OpRingoidWithAddAntiDistribTerm2
        n
        A ->
      OpRingoidWithAddAntiDistribTerm2
        n
        A ->
      OpRingoidWithAddAntiDistribTerm2
        n
        A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRingoidWithAddAntiDistribTerm2
        n
        A ->
      Staged
        (OpRingoidWithAddAntiDistribTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RingoidWithAddAntiDistribTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        +T : Repr A -> Repr A -> Repr A
        primT : Repr A -> Repr A
        *T : Repr A -> Repr A -> Repr A
  
  module RingoidWithInvolution where
    record RingoidWithInvolution
      (A : Set) : Set where
      constructor RingoidWithInvolutionC
      field
        * : A -> A -> A
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        prim : A -> A
    record RingoidWithInvolutionSig
      (AS : Set) : Set where
      constructor RingoidWithInvolutionSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        primS : AS -> AS
    record RingoidWithInvolutionProd
      (AP : Set) : Set where
      constructor RingoidWithInvolutionProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record RingoidWithInvolutionHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidWithInvolution A1)
      (Ri2 : RingoidWithInvolution
         A2) : Set where
      constructor RingoidWithInvolutionHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Ri1 x1) ==
            prim Ri2 (hom x1)
    record RingoidWithInvolutionRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidWithInvolution A1)
      (Ri2 : RingoidWithInvolution
         A2) : Set where
      constructor RingoidWithInvolutionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Ri1 x1)
            (prim Ri2 y1)
    data RingoidWithInvolutionTerm
      : Set where
      *L :
        RingoidWithInvolutionTerm ->
        RingoidWithInvolutionTerm ->
        RingoidWithInvolutionTerm
      +L :
        RingoidWithInvolutionTerm ->
        RingoidWithInvolutionTerm ->
        RingoidWithInvolutionTerm
      primL :
        RingoidWithInvolutionTerm ->
        RingoidWithInvolutionTerm
    data ClRingoidWithInvolutionTerm
      (A : Set) : Set where
      sing :
        A ->
        ClRingoidWithInvolutionTerm A
      *Cl :
        ClRingoidWithInvolutionTerm A ->
        ClRingoidWithInvolutionTerm A ->
        ClRingoidWithInvolutionTerm A
      +Cl :
        ClRingoidWithInvolutionTerm A ->
        ClRingoidWithInvolutionTerm A ->
        ClRingoidWithInvolutionTerm A
      primCl :
        ClRingoidWithInvolutionTerm A ->
        ClRingoidWithInvolutionTerm A
    data OpRingoidWithInvolutionTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpRingoidWithInvolutionTerm n
      *OL :
        OpRingoidWithInvolutionTerm n ->
        OpRingoidWithInvolutionTerm n ->
        OpRingoidWithInvolutionTerm n
      +OL :
        OpRingoidWithInvolutionTerm n ->
        OpRingoidWithInvolutionTerm n ->
        OpRingoidWithInvolutionTerm n
      primOL :
        OpRingoidWithInvolutionTerm n ->
        OpRingoidWithInvolutionTerm n
    data OpRingoidWithInvolutionTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpRingoidWithInvolutionTerm2 n A
      sing2 :
        A ->
        OpRingoidWithInvolutionTerm2 n A
      *OL2 :
        OpRingoidWithInvolutionTerm2 n
          A ->
        OpRingoidWithInvolutionTerm2 n
          A ->
        OpRingoidWithInvolutionTerm2 n A
      +OL2 :
        OpRingoidWithInvolutionTerm2 n
          A ->
        OpRingoidWithInvolutionTerm2 n
          A ->
        OpRingoidWithInvolutionTerm2 n A
      primOL2 :
        OpRingoidWithInvolutionTerm2 n
          A ->
        OpRingoidWithInvolutionTerm2 n A
    simplifyB :
      RingoidWithInvolutionTerm ->
      RingoidWithInvolutionTerm
    simplifyB (+L
               (*L x y)
               (*L x z)) = *L x (+L y z)
    simplifyB (+L
               (*L y x)
               (*L z x)) = *L (+L y z) x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClRingoidWithInvolutionTerm A ->
      ClRingoidWithInvolutionTerm A
    simplifyCl _ (+Cl
                  (*Cl x y)
                  (*Cl x z)) = *Cl x (+Cl y z)
    simplifyCl _ (+Cl
                  (*Cl y x)
                  (*Cl z x)) = *Cl (+Cl y z) x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRingoidWithInvolutionTerm n ->
      OpRingoidWithInvolutionTerm n
    simplifyOp _ (+OL
                  (*OL x y)
                  (*OL x z)) = *OL x (+OL y z)
    simplifyOp _ (+OL
                  (*OL y x)
                  (*OL z x)) = *OL (+OL y z) x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRingoidWithInvolutionTerm2 n
        A ->
      OpRingoidWithInvolutionTerm2 n A
    simplifyOpE _ _ (+OL2
                     (*OL2 x y)
                     (*OL2 x z)) = *OL2 x (+OL2 y z)
    simplifyOpE _ _ (+OL2
                     (*OL2 y x)
                     (*OL2 z x)) = *OL2 (+OL2 y z) x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RingoidWithInvolution A ->
      RingoidWithInvolutionTerm -> A
    evalB _ Ri (*L x1 x2) =
      * Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalB _ Ri (+L x1 x2) =
      + Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalB _ Ri (primL x1) =
      prim Ri (evalB _ Ri x1)
    evalCl :
      (A : Set) ->
      RingoidWithInvolution A ->
      ClRingoidWithInvolutionTerm A ->
      A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (*Cl x1 x2) =
      * Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalCl _ Ri (+Cl x1 x2) =
      + Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalCl _ Ri (primCl x1) =
      prim Ri (evalCl _ Ri x1)
    evalOp :
      (A : Set) (n : Nat) ->
      RingoidWithInvolution A ->
      Vec A n ->
      OpRingoidWithInvolutionTerm n ->
      A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (*OL x1 x2) =
      * Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOp _ n Ri vars (+OL x1 x2) =
      + Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOp _ n Ri vars (primOL x1) =
      prim Ri (evalOp _ n Ri vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      RingoidWithInvolution A ->
      Vec A n ->
      OpRingoidWithInvolutionTerm2 n
        A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (*OL2
                         x1
                         x2) =
      * Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    evalOpE _ n Ri vars (+OL2
                         x1
                         x2) =
      + Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    evalOpE _ n Ri vars (primOL2
                         x1) =
      prim Ri (evalOpE _ n Ri vars x1)
    inductionB :
      (P : RingoidWithInvolutionTerm ->
           Set) ->
      ((x1 : RingoidWithInvolutionTerm)
       (x2 : RingoidWithInvolutionTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : RingoidWithInvolutionTerm)
       (x2 : RingoidWithInvolutionTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      ((x1 : RingoidWithInvolutionTerm) ->
       P x1 -> P (primL x1)) ->
      (x : RingoidWithInvolutionTerm) ->
      P x
    inductionB p p*l p+l ppriml (*L
                                 x1
                                 x2) =
      p*l _ _
        (inductionB p p*l p+l ppriml x1)
        (inductionB p p*l p+l ppriml x2)
    inductionB p p*l p+l ppriml (+L
                                 x1
                                 x2) =
      p+l _ _
        (inductionB p p*l p+l ppriml x1)
        (inductionB p p*l p+l ppriml x2)
    inductionB p p*l p+l ppriml (primL
                                 x1) =
      ppriml _
        (inductionB p p*l p+l ppriml x1)
    inductionCl :
      (A : Set)
      (P : ClRingoidWithInvolutionTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRingoidWithInvolutionTerm
          A)
       (x2 : ClRingoidWithInvolutionTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClRingoidWithInvolutionTerm
          A)
       (x2 : ClRingoidWithInvolutionTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      ((x1 : ClRingoidWithInvolutionTerm
          A) -> P x1 -> P (primCl x1)) ->
      (x : ClRingoidWithInvolutionTerm
         A) -> P x
    inductionCl _ p psing p*cl p+cl pprimcl (sing
                                             x1) = psing x1
    inductionCl _ p psing p*cl p+cl pprimcl (*Cl
                                             x1
                                             x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x1)
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x2)
    inductionCl _ p psing p*cl p+cl pprimcl (+Cl
                                             x1
                                             x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x1)
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x2)
    inductionCl _ p psing p*cl p+cl pprimcl (primCl
                                             x1) =
      pprimcl _
        (inductionCl _ p psing p*cl p+cl
           pprimcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpRingoidWithInvolutionTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRingoidWithInvolutionTerm
          n)
       (x2 : OpRingoidWithInvolutionTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpRingoidWithInvolutionTerm
          n)
       (x2 : OpRingoidWithInvolutionTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      ((x1 : OpRingoidWithInvolutionTerm
          n) -> P x1 -> P (primOL x1)) ->
      (x : OpRingoidWithInvolutionTerm
         n) -> P x
    inductionOp _ p pv p*ol p+ol pprimol (v
                                          x1) = pv x1
    inductionOp _ p pv p*ol p+ol pprimol (*OL
                                          x1
                                          x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x1)
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x2)
    inductionOp _ p pv p*ol p+ol pprimol (+OL
                                          x1
                                          x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x1)
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x2)
    inductionOp _ p pv p*ol p+ol pprimol (primOL
                                          x1) =
      pprimol _
        (inductionOp _ p pv p*ol p+ol
           pprimol
           x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRingoidWithInvolutionTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRingoidWithInvolutionTerm2
          n
          A)
       (x2 : OpRingoidWithInvolutionTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpRingoidWithInvolutionTerm2
          n
          A)
       (x2 : OpRingoidWithInvolutionTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      ((x1 : OpRingoidWithInvolutionTerm2
          n
          A) -> P x1 -> P (primOL2 x1)) ->
      (x : OpRingoidWithInvolutionTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (v2
                                                        x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (sing2
                                                        x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (*OL2
                                                        x1
                                                        x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (+OL2
                                                        x1
                                                        x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 pprimol2 (primOL2
                                                        x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           pprimol2
           x1)
    *L' :
      RingoidWithInvolutionTerm ->
      RingoidWithInvolutionTerm ->
      RingoidWithInvolutionTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      RingoidWithInvolutionTerm ->
      RingoidWithInvolutionTerm ->
      RingoidWithInvolutionTerm
    +L' x1 x2 = +L x1 x2
    primL' :
      RingoidWithInvolutionTerm ->
      RingoidWithInvolutionTerm
    primL' x1 = primL x1
    stageB :
      RingoidWithInvolutionTerm ->
      Staged RingoidWithInvolutionTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    *Cl' :
      (A : Set) ->
      ClRingoidWithInvolutionTerm A ->
      ClRingoidWithInvolutionTerm A ->
      ClRingoidWithInvolutionTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClRingoidWithInvolutionTerm A ->
      ClRingoidWithInvolutionTerm A ->
      ClRingoidWithInvolutionTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    primCl' :
      (A : Set) ->
      ClRingoidWithInvolutionTerm A ->
      ClRingoidWithInvolutionTerm A
    primCl' _ x1 = primCl x1
    stageCl :
      (A : Set) ->
      ClRingoidWithInvolutionTerm A ->
      Staged
        (ClRingoidWithInvolutionTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    *OL' :
      (n : Nat) ->
      OpRingoidWithInvolutionTerm n ->
      OpRingoidWithInvolutionTerm n ->
      OpRingoidWithInvolutionTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpRingoidWithInvolutionTerm n ->
      OpRingoidWithInvolutionTerm n ->
      OpRingoidWithInvolutionTerm n
    +OL' _ x1 x2 = +OL x1 x2
    primOL' :
      (n : Nat) ->
      OpRingoidWithInvolutionTerm n ->
      OpRingoidWithInvolutionTerm n
    primOL' _ x1 = primOL x1
    stageOp :
      (n : Nat) ->
      OpRingoidWithInvolutionTerm n ->
      Staged
        (OpRingoidWithInvolutionTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpRingoidWithInvolutionTerm2 n
        A ->
      OpRingoidWithInvolutionTerm2 n
        A ->
      OpRingoidWithInvolutionTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpRingoidWithInvolutionTerm2 n
        A ->
      OpRingoidWithInvolutionTerm2 n
        A ->
      OpRingoidWithInvolutionTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    primOL2' :
      (n : Nat) (A : Set) ->
      OpRingoidWithInvolutionTerm2 n
        A ->
      OpRingoidWithInvolutionTerm2 n A
    primOL2' _ _ x1 = primOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRingoidWithInvolutionTerm2 n
        A ->
      Staged
        (OpRingoidWithInvolutionTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    record RingoidWithInvolutionTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
        primT : Repr A -> Repr A
  
  module RingoidWithMultAntiDistrib where
    record RingoidWithMultAntiDistrib
      (A : Set) : Set where
      constructor RingoidWithMultAntiDistribC
      field
        * : A -> A -> A
        prim : A -> A
        antidis_prim_* :
          (x : A) (y : A) ->
          prim (* x y) ==
            * (prim y) (prim x)
        + : A -> A -> A
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record RingoidWithMultAntiDistribSig
      (AS : Set) : Set where
      constructor RingoidWithMultAntiDistribSigSigC
      field
        *S : AS -> AS -> AS
        primS : AS -> AS
        +S : AS -> AS -> AS
    record RingoidWithMultAntiDistribProd
      (AP : Set) : Set where
      constructor RingoidWithMultAntiDistribProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        primP : Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        antidis_prim_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (*P xP yP) ==
            *P (primP yP) (primP xP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record RingoidWithMultAntiDistribHom
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidWithMultAntiDistrib
         A1)
      (Ri2 : RingoidWithMultAntiDistrib
         A2) : Set where
      constructor RingoidWithMultAntiDistribHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ri1 x1 x2) ==
            * Ri2 (hom x1) (hom x2)
        pres-prim :
          (x1 : A1) ->
          hom (prim Ri1 x1) ==
            prim Ri2 (hom x1)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ri1 x1 x2) ==
            + Ri2 (hom x1) (hom x2)
    record RingoidWithMultAntiDistribRelInterp
      (A1 : Set) (A2 : Set)
      (Ri1 : RingoidWithMultAntiDistrib
         A1)
      (Ri2 : RingoidWithMultAntiDistrib
         A2) : Set where
      constructor RingoidWithMultAntiDistribRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ri1 x1 x2)
            (* Ri2 y1 y2)
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Ri1 x1)
            (prim Ri2 y1)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ri1 x1 x2)
            (+ Ri2 y1 y2)
    data RingoidWithMultAntiDistribTerm
      : Set where
      *L :
        RingoidWithMultAntiDistribTerm ->
        RingoidWithMultAntiDistribTerm ->
        RingoidWithMultAntiDistribTerm
      primL :
        RingoidWithMultAntiDistribTerm ->
        RingoidWithMultAntiDistribTerm
      +L :
        RingoidWithMultAntiDistribTerm ->
        RingoidWithMultAntiDistribTerm ->
        RingoidWithMultAntiDistribTerm
    data ClRingoidWithMultAntiDistribTerm
      (A : Set) : Set where
      sing :
        A ->
        ClRingoidWithMultAntiDistribTerm
          A
      *Cl :
        ClRingoidWithMultAntiDistribTerm
          A ->
        ClRingoidWithMultAntiDistribTerm
          A ->
        ClRingoidWithMultAntiDistribTerm
          A
      primCl :
        ClRingoidWithMultAntiDistribTerm
          A ->
        ClRingoidWithMultAntiDistribTerm
          A
      +Cl :
        ClRingoidWithMultAntiDistribTerm
          A ->
        ClRingoidWithMultAntiDistribTerm
          A ->
        ClRingoidWithMultAntiDistribTerm
          A
    data OpRingoidWithMultAntiDistribTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpRingoidWithMultAntiDistribTerm
          n
      *OL :
        OpRingoidWithMultAntiDistribTerm
          n ->
        OpRingoidWithMultAntiDistribTerm
          n ->
        OpRingoidWithMultAntiDistribTerm
          n
      primOL :
        OpRingoidWithMultAntiDistribTerm
          n ->
        OpRingoidWithMultAntiDistribTerm
          n
      +OL :
        OpRingoidWithMultAntiDistribTerm
          n ->
        OpRingoidWithMultAntiDistribTerm
          n ->
        OpRingoidWithMultAntiDistribTerm
          n
    data OpRingoidWithMultAntiDistribTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpRingoidWithMultAntiDistribTerm2
          n
          A
      sing2 :
        A ->
        OpRingoidWithMultAntiDistribTerm2
          n
          A
      *OL2 :
        OpRingoidWithMultAntiDistribTerm2
          n
          A ->
        OpRingoidWithMultAntiDistribTerm2
          n
          A ->
        OpRingoidWithMultAntiDistribTerm2
          n
          A
      primOL2 :
        OpRingoidWithMultAntiDistribTerm2
          n
          A ->
        OpRingoidWithMultAntiDistribTerm2
          n
          A
      +OL2 :
        OpRingoidWithMultAntiDistribTerm2
          n
          A ->
        OpRingoidWithMultAntiDistribTerm2
          n
          A ->
        OpRingoidWithMultAntiDistribTerm2
          n
          A
    simplifyB :
      RingoidWithMultAntiDistribTerm ->
      RingoidWithMultAntiDistribTerm
    simplifyB (*L
               (primL y)
               (primL x)) = primL (*L x y)
    simplifyB (+L
               (*L x y)
               (*L x z)) = *L x (+L y z)
    simplifyB (+L
               (*L y x)
               (*L z x)) = *L (+L y z) x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRingoidWithMultAntiDistribTerm
        A ->
      ClRingoidWithMultAntiDistribTerm
        A
    simplifyCl _ (*Cl
                  (primCl y)
                  (primCl x)) = primCl (*Cl x y)
    simplifyCl _ (+Cl
                  (*Cl x y)
                  (*Cl x z)) = *Cl x (+Cl y z)
    simplifyCl _ (+Cl
                  (*Cl y x)
                  (*Cl z x)) = *Cl (+Cl y z) x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRingoidWithMultAntiDistribTerm
        n ->
      OpRingoidWithMultAntiDistribTerm
        n
    simplifyOp _ (*OL
                  (primOL y)
                  (primOL x)) = primOL (*OL x y)
    simplifyOp _ (+OL
                  (*OL x y)
                  (*OL x z)) = *OL x (+OL y z)
    simplifyOp _ (+OL
                  (*OL y x)
                  (*OL z x)) = *OL (+OL y z) x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRingoidWithMultAntiDistribTerm2
        n
        A ->
      OpRingoidWithMultAntiDistribTerm2
        n
        A
    simplifyOpE _ _ (*OL2
                     (primOL2 y)
                     (primOL2 x)) =
      primOL2 (*OL2 x y)
    simplifyOpE _ _ (+OL2
                     (*OL2 x y)
                     (*OL2 x z)) = *OL2 x (+OL2 y z)
    simplifyOpE _ _ (+OL2
                     (*OL2 y x)
                     (*OL2 z x)) = *OL2 (+OL2 y z) x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      RingoidWithMultAntiDistrib A ->
      RingoidWithMultAntiDistribTerm ->
      A
    evalB _ Ri (*L x1 x2) =
      * Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalB _ Ri (primL x1) =
      prim Ri (evalB _ Ri x1)
    evalB _ Ri (+L x1 x2) =
      + Ri (evalB _ Ri x1)
        (evalB _ Ri x2)
    evalCl :
      (A : Set) ->
      RingoidWithMultAntiDistrib A ->
      ClRingoidWithMultAntiDistribTerm
        A -> A
    evalCl _ Ri (sing x1) = x1
    evalCl _ Ri (*Cl x1 x2) =
      * Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalCl _ Ri (primCl x1) =
      prim Ri (evalCl _ Ri x1)
    evalCl _ Ri (+Cl x1 x2) =
      + Ri (evalCl _ Ri x1)
        (evalCl _ Ri x2)
    evalOp :
      (A : Set) (n : Nat) ->
      RingoidWithMultAntiDistrib A ->
      Vec A n ->
      OpRingoidWithMultAntiDistribTerm
        n -> A
    evalOp _ n Ri vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ri vars (*OL x1 x2) =
      * Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOp _ n Ri vars (primOL x1) =
      prim Ri (evalOp _ n Ri vars x1)
    evalOp _ n Ri vars (+OL x1 x2) =
      + Ri (evalOp _ n Ri vars x1)
        (evalOp _ n Ri vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      RingoidWithMultAntiDistrib A ->
      Vec A n ->
      OpRingoidWithMultAntiDistribTerm2
        n
        A -> A
    evalOpE _ n Ri vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ri vars (sing2 x1) =
      x1
    evalOpE _ n Ri vars (*OL2
                         x1
                         x2) =
      * Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    evalOpE _ n Ri vars (primOL2
                         x1) =
      prim Ri (evalOpE _ n Ri vars x1)
    evalOpE _ n Ri vars (+OL2
                         x1
                         x2) =
      + Ri (evalOpE _ n Ri vars x1)
        (evalOpE _ n Ri vars x2)
    inductionB :
      (P : RingoidWithMultAntiDistribTerm ->
           Set) ->
      ((x1 : RingoidWithMultAntiDistribTerm)
       (x2 : RingoidWithMultAntiDistribTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : RingoidWithMultAntiDistribTerm) ->
       P x1 -> P (primL x1)) ->
      ((x1 : RingoidWithMultAntiDistribTerm)
       (x2 : RingoidWithMultAntiDistribTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : RingoidWithMultAntiDistribTerm) ->
      P x
    inductionB p p*l ppriml p+l (*L
                                 x1
                                 x2) =
      p*l _ _
        (inductionB p p*l ppriml p+l x1)
        (inductionB p p*l ppriml p+l x2)
    inductionB p p*l ppriml p+l (primL
                                 x1) =
      ppriml _
        (inductionB p p*l ppriml p+l x1)
    inductionB p p*l ppriml p+l (+L
                                 x1
                                 x2) =
      p+l _ _
        (inductionB p p*l ppriml p+l x1)
        (inductionB p p*l ppriml p+l x2)
    inductionCl :
      (A : Set)
      (P : ClRingoidWithMultAntiDistribTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClRingoidWithMultAntiDistribTerm
          A)
       (x2 : ClRingoidWithMultAntiDistribTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClRingoidWithMultAntiDistribTerm
          A) -> P x1 -> P (primCl x1)) ->
      ((x1 : ClRingoidWithMultAntiDistribTerm
          A)
       (x2 : ClRingoidWithMultAntiDistribTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClRingoidWithMultAntiDistribTerm
         A) -> P x
    inductionCl _ p psing p*cl pprimcl p+cl (sing
                                             x1) = psing x1
    inductionCl _ p psing p*cl pprimcl p+cl (*Cl
                                             x1
                                             x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl
           pprimcl
           p+cl
           x1)
        (inductionCl _ p psing p*cl
           pprimcl
           p+cl
           x2)
    inductionCl _ p psing p*cl pprimcl p+cl (primCl
                                             x1) =
      pprimcl _
        (inductionCl _ p psing p*cl
           pprimcl
           p+cl
           x1)
    inductionCl _ p psing p*cl pprimcl p+cl (+Cl
                                             x1
                                             x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl
           pprimcl
           p+cl
           x1)
        (inductionCl _ p psing p*cl
           pprimcl
           p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpRingoidWithMultAntiDistribTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpRingoidWithMultAntiDistribTerm
          n)
       (x2 : OpRingoidWithMultAntiDistribTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpRingoidWithMultAntiDistribTerm
          n) -> P x1 -> P (primOL x1)) ->
      ((x1 : OpRingoidWithMultAntiDistribTerm
          n)
       (x2 : OpRingoidWithMultAntiDistribTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpRingoidWithMultAntiDistribTerm
         n) -> P x
    inductionOp _ p pv p*ol pprimol p+ol (v
                                          x1) = pv x1
    inductionOp _ p pv p*ol pprimol p+ol (*OL
                                          x1
                                          x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol pprimol
           p+ol
           x1)
        (inductionOp _ p pv p*ol pprimol
           p+ol
           x2)
    inductionOp _ p pv p*ol pprimol p+ol (primOL
                                          x1) =
      pprimol _
        (inductionOp _ p pv p*ol pprimol
           p+ol
           x1)
    inductionOp _ p pv p*ol pprimol p+ol (+OL
                                          x1
                                          x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol pprimol
           p+ol
           x1)
        (inductionOp _ p pv p*ol pprimol
           p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRingoidWithMultAntiDistribTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpRingoidWithMultAntiDistribTerm2
          n
          A)
       (x2 : OpRingoidWithMultAntiDistribTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpRingoidWithMultAntiDistribTerm2
          n
          A) -> P x1 -> P (primOL2 x1)) ->
      ((x1 : OpRingoidWithMultAntiDistribTerm2
          n
          A)
       (x2 : OpRingoidWithMultAntiDistribTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpRingoidWithMultAntiDistribTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 pprimol2 p+ol2 (v2
                                                        x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 pprimol2 p+ol2 (sing2
                                                        x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 pprimol2 p+ol2 (*OL2
                                                        x1
                                                        x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           pprimol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           pprimol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 pprimol2 p+ol2 (primOL2
                                                        x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           pprimol2
           p+ol2
           x1)
    inductionOpE _ _ p pv2 psing2 p*ol2 pprimol2 p+ol2 (+OL2
                                                        x1
                                                        x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           pprimol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           pprimol2
           p+ol2
           x2)
    *L' :
      RingoidWithMultAntiDistribTerm ->
      RingoidWithMultAntiDistribTerm ->
      RingoidWithMultAntiDistribTerm
    *L' x1 x2 = *L x1 x2
    primL' :
      RingoidWithMultAntiDistribTerm ->
      RingoidWithMultAntiDistribTerm
    primL' x1 = primL x1
    +L' :
      RingoidWithMultAntiDistribTerm ->
      RingoidWithMultAntiDistribTerm ->
      RingoidWithMultAntiDistribTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      RingoidWithMultAntiDistribTerm ->
      Staged
        RingoidWithMultAntiDistribTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    *Cl' :
      (A : Set) ->
      ClRingoidWithMultAntiDistribTerm
        A ->
      ClRingoidWithMultAntiDistribTerm
        A ->
      ClRingoidWithMultAntiDistribTerm
        A
    *Cl' _ x1 x2 = *Cl x1 x2
    primCl' :
      (A : Set) ->
      ClRingoidWithMultAntiDistribTerm
        A ->
      ClRingoidWithMultAntiDistribTerm
        A
    primCl' _ x1 = primCl x1
    +Cl' :
      (A : Set) ->
      ClRingoidWithMultAntiDistribTerm
        A ->
      ClRingoidWithMultAntiDistribTerm
        A ->
      ClRingoidWithMultAntiDistribTerm
        A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClRingoidWithMultAntiDistribTerm
        A ->
      Staged
        (ClRingoidWithMultAntiDistribTerm
           A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    *OL' :
      (n : Nat) ->
      OpRingoidWithMultAntiDistribTerm
        n ->
      OpRingoidWithMultAntiDistribTerm
        n ->
      OpRingoidWithMultAntiDistribTerm
        n
    *OL' _ x1 x2 = *OL x1 x2
    primOL' :
      (n : Nat) ->
      OpRingoidWithMultAntiDistribTerm
        n ->
      OpRingoidWithMultAntiDistribTerm
        n
    primOL' _ x1 = primOL x1
    +OL' :
      (n : Nat) ->
      OpRingoidWithMultAntiDistribTerm
        n ->
      OpRingoidWithMultAntiDistribTerm
        n ->
      OpRingoidWithMultAntiDistribTerm
        n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpRingoidWithMultAntiDistribTerm
        n ->
      Staged
        (OpRingoidWithMultAntiDistribTerm
           n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    *OL2' :
      (n : Nat) (A : Set) ->
      OpRingoidWithMultAntiDistribTerm2
        n
        A ->
      OpRingoidWithMultAntiDistribTerm2
        n
        A ->
      OpRingoidWithMultAntiDistribTerm2
        n
        A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    primOL2' :
      (n : Nat) (A : Set) ->
      OpRingoidWithMultAntiDistribTerm2
        n
        A ->
      OpRingoidWithMultAntiDistribTerm2
        n
        A
    primOL2' _ _ x1 = primOL2 x1
    +OL2' :
      (n : Nat) (A : Set) ->
      OpRingoidWithMultAntiDistribTerm2
        n
        A ->
      OpRingoidWithMultAntiDistribTerm2
        n
        A ->
      OpRingoidWithMultAntiDistribTerm2
        n
        A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRingoidWithMultAntiDistribTerm2
        n
        A ->
      Staged
        (OpRingoidWithMultAntiDistribTerm2
           n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RingoidWithMultAntiDistribTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        primT : Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  
  module Rng where
    record Rng (A : Set) : Set where
      constructor RngC
      field
        0 : A
        + : A -> A -> A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        neg : A -> A
        leftInverse_inv_op_0 :
          (x : A) -> + x (neg x) == 0
        rightInverse_inv_op_0 :
          (x : A) -> + (neg x) x == 0
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record RngSig
      (AS : Set) : Set where
      constructor RngSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        negS : AS -> AS
        *S : AS -> AS -> AS
    record RngProd
      (AP : Set) : Set where
      constructor RngProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        negP : Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P xP (negP xP) == 0P
        rightInverse_inv_op_0P :
          (xP : Prod AP AP) ->
          +P (negP xP) xP == 0P
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record RngHom
      (A1 : Set) (A2 : Set)
      (Rn1 : Rng A1)
      (Rn2 : Rng A2) : Set where
      constructor RngHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Rn1) == 0 Rn2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Rn1 x1 x2) ==
            + Rn2 (hom x1) (hom x2)
        pres-neg :
          (x1 : A1) ->
          hom (neg Rn1 x1) ==
            neg Rn2 (hom x1)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Rn1 x1 x2) ==
            * Rn2 (hom x1) (hom x2)
    record RngRelInterp
      (A1 : Set) (A2 : Set)
      (Rn1 : Rng A1)
      (Rn2 : Rng A2) : Set where
      constructor RngRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Rn1) (0 Rn2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Rn1 x1 x2)
            (+ Rn2 y1 y2)
        interp-neg :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (neg Rn1 x1) (neg Rn2 y1)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Rn1 x1 x2)
            (* Rn2 y1 y2)
    data RngTerm : Set where
      0L : RngTerm
      +L :
        RngTerm -> RngTerm -> RngTerm
      negL : RngTerm -> RngTerm
      *L :
        RngTerm -> RngTerm -> RngTerm
    data ClRngTerm
      (A : Set) : Set where
      sing : A -> ClRngTerm A
      0Cl : ClRngTerm A
      +Cl :
        ClRngTerm A ->
        ClRngTerm A -> ClRngTerm A
      negCl :
        ClRngTerm A -> ClRngTerm A
      *Cl :
        ClRngTerm A ->
        ClRngTerm A -> ClRngTerm A
    data OpRngTerm
      (n : Nat) : Set where
      v : Fin n -> OpRngTerm n
      0OL : OpRngTerm n
      +OL :
        OpRngTerm n ->
        OpRngTerm n -> OpRngTerm n
      negOL :
        OpRngTerm n -> OpRngTerm n
      *OL :
        OpRngTerm n ->
        OpRngTerm n -> OpRngTerm n
    data OpRngTerm2
      (n : Nat) (A : Set) : Set where
      v2 : Fin n -> OpRngTerm2 n A
      sing2 : A -> OpRngTerm2 n A
      0OL2 : OpRngTerm2 n A
      +OL2 :
        OpRngTerm2 n A ->
        OpRngTerm2 n A -> OpRngTerm2 n A
      negOL2 :
        OpRngTerm2 n A -> OpRngTerm2 n A
      *OL2 :
        OpRngTerm2 n A ->
        OpRngTerm2 n A -> OpRngTerm2 n A
    simplifyB : RngTerm -> RngTerm
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (+L x (negL x)) = 0L
    simplifyB (+L (negL x) x) = 0L
    simplifyB (+L
               (*L x y)
               (*L x z)) = *L x (+L y z)
    simplifyB (+L
               (*L y x)
               (*L z x)) = *L (+L y z) x
    simplifyB (0L) = 0L
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (negL x1) =
      negL (simplifyB x1)
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClRngTerm A -> ClRngTerm A
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (+Cl x (negCl x)) =
      0Cl
    simplifyCl _ (+Cl (negCl x) x) =
      0Cl
    simplifyCl _ (+Cl
                  (*Cl x y)
                  (*Cl x z)) = *Cl x (+Cl y z)
    simplifyCl _ (+Cl
                  (*Cl y x)
                  (*Cl z x)) = *Cl (+Cl y z) x
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (negCl x1) =
      negCl (simplifyCl _ x1)
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpRngTerm n -> OpRngTerm n
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (+OL x (negOL x)) =
      0OL
    simplifyOp _ (+OL (negOL x) x) =
      0OL
    simplifyOp _ (+OL
                  (*OL x y)
                  (*OL x z)) = *OL x (+OL y z)
    simplifyOp _ (+OL
                  (*OL y x)
                  (*OL z x)) = *OL (+OL y z) x
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (negOL x1) =
      negOL (simplifyOp _ x1)
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpRngTerm2 n A -> OpRngTerm2 n A
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (+OL2
                     x
                     (negOL2 x)) = 0OL2
    simplifyOpE _ _ (+OL2
                     (negOL2 x)
                     x) = 0OL2
    simplifyOpE _ _ (+OL2
                     (*OL2 x y)
                     (*OL2 x z)) = *OL2 x (+OL2 y z)
    simplifyOpE _ _ (+OL2
                     (*OL2 y x)
                     (*OL2 z x)) = *OL2 (+OL2 y z) x
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (negOL2 x1) =
      negOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Rng A -> RngTerm -> A
    evalB _ Rn (0L) = 0 Rn
    evalB _ Rn (+L x1 x2) =
      + Rn (evalB _ Rn x1)
        (evalB _ Rn x2)
    evalB _ Rn (negL x1) =
      neg Rn (evalB _ Rn x1)
    evalB _ Rn (*L x1 x2) =
      * Rn (evalB _ Rn x1)
        (evalB _ Rn x2)
    evalCl :
      (A : Set) ->
      Rng A -> ClRngTerm A -> A
    evalCl _ Rn (sing x1) = x1
    evalCl _ Rn (0Cl) = 0 Rn
    evalCl _ Rn (+Cl x1 x2) =
      + Rn (evalCl _ Rn x1)
        (evalCl _ Rn x2)
    evalCl _ Rn (negCl x1) =
      neg Rn (evalCl _ Rn x1)
    evalCl _ Rn (*Cl x1 x2) =
      * Rn (evalCl _ Rn x1)
        (evalCl _ Rn x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Rng A ->
      Vec A n -> OpRngTerm n -> A
    evalOp _ n Rn vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Rn vars (0OL) = 0 Rn
    evalOp _ n Rn vars (+OL x1 x2) =
      + Rn (evalOp _ n Rn vars x1)
        (evalOp _ n Rn vars x2)
    evalOp _ n Rn vars (negOL x1) =
      neg Rn (evalOp _ n Rn vars x1)
    evalOp _ n Rn vars (*OL x1 x2) =
      * Rn (evalOp _ n Rn vars x1)
        (evalOp _ n Rn vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Rng A ->
      Vec A n -> OpRngTerm2 n A -> A
    evalOpE _ n Rn vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Rn vars (sing2 x1) =
      x1
    evalOpE _ n Rn vars (0OL2) =
      0 Rn
    evalOpE _ n Rn vars (+OL2
                         x1
                         x2) =
      + Rn (evalOpE _ n Rn vars x1)
        (evalOpE _ n Rn vars x2)
    evalOpE _ n Rn vars (negOL2
                         x1) =
      neg Rn (evalOpE _ n Rn vars x1)
    evalOpE _ n Rn vars (*OL2
                         x1
                         x2) =
      * Rn (evalOpE _ n Rn vars x1)
        (evalOpE _ n Rn vars x2)
    inductionB :
      (P : RngTerm -> Set) ->
      P 0L ->
      ((x1 : RngTerm)
       (x2 : RngTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      ((x1 : RngTerm) ->
       P x1 -> P (negL x1)) ->
      ((x1 : RngTerm)
       (x2 : RngTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      (x : RngTerm) -> P x
    inductionB p p0l p+l pnegl p*l (0L) =
      p0l
    inductionB p p0l p+l pnegl p*l (+L
                                    x1
                                    x2) =
      p+l _ _
        (inductionB p p0l p+l pnegl p*l
           x1)
        (inductionB p p0l p+l pnegl p*l
           x2)
    inductionB p p0l p+l pnegl p*l (negL
                                    x1) =
      pnegl _
        (inductionB p p0l p+l pnegl p*l
           x1)
    inductionB p p0l p+l pnegl p*l (*L
                                    x1
                                    x2) =
      p*l _ _
        (inductionB p p0l p+l pnegl p*l
           x1)
        (inductionB p p0l p+l pnegl p*l
           x2)
    inductionCl :
      (A : Set)
      (P : ClRngTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 0Cl ->
      ((x1 : ClRngTerm A)
       (x2 : ClRngTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      ((x1 : ClRngTerm A) ->
       P x1 -> P (negCl x1)) ->
      ((x1 : ClRngTerm A)
       (x2 : ClRngTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      (x : ClRngTerm A) -> P x
    inductionCl _ p psing p0cl p+cl pnegcl p*cl (sing
                                                 x1) = psing x1
    inductionCl _ p psing p0cl p+cl pnegcl p*cl (0Cl) =
      p0cl
    inductionCl _ p psing p0cl p+cl pnegcl p*cl (+Cl
                                                 x1
                                                 x2) =
      p+cl _ _
        (inductionCl _ p psing p0cl p+cl
           pnegcl
           p*cl
           x1)
        (inductionCl _ p psing p0cl p+cl
           pnegcl
           p*cl
           x2)
    inductionCl _ p psing p0cl p+cl pnegcl p*cl (negCl
                                                 x1) =
      pnegcl _
        (inductionCl _ p psing p0cl p+cl
           pnegcl
           p*cl
           x1)
    inductionCl _ p psing p0cl p+cl pnegcl p*cl (*Cl
                                                 x1
                                                 x2) =
      p*cl _ _
        (inductionCl _ p psing p0cl p+cl
           pnegcl
           p*cl
           x1)
        (inductionCl _ p psing p0cl p+cl
           pnegcl
           p*cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpRngTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 0OL ->
      ((x1 : OpRngTerm n)
       (x2 : OpRngTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      ((x1 : OpRngTerm n) ->
       P x1 -> P (negOL x1)) ->
      ((x1 : OpRngTerm n)
       (x2 : OpRngTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      (x : OpRngTerm n) -> P x
    inductionOp _ p pv p0ol p+ol pnegol p*ol (v
                                              x1) = pv x1
    inductionOp _ p pv p0ol p+ol pnegol p*ol (0OL) =
      p0ol
    inductionOp _ p pv p0ol p+ol pnegol p*ol (+OL
                                              x1
                                              x2) =
      p+ol _ _
        (inductionOp _ p pv p0ol p+ol
           pnegol
           p*ol
           x1)
        (inductionOp _ p pv p0ol p+ol
           pnegol
           p*ol
           x2)
    inductionOp _ p pv p0ol p+ol pnegol p*ol (negOL
                                              x1) =
      pnegol _
        (inductionOp _ p pv p0ol p+ol
           pnegol
           p*ol
           x1)
    inductionOp _ p pv p0ol p+ol pnegol p*ol (*OL
                                              x1
                                              x2) =
      p*ol _ _
        (inductionOp _ p pv p0ol p+ol
           pnegol
           p*ol
           x1)
        (inductionOp _ p pv p0ol p+ol
           pnegol
           p*ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpRngTerm2 n A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 0OL2 ->
      ((x1 : OpRngTerm2 n A)
       (x2 : OpRngTerm2 n A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      ((x1 : OpRngTerm2 n A) ->
       P x1 -> P (negOL2 x1)) ->
      ((x1 : OpRngTerm2 n A)
       (x2 : OpRngTerm2 n A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      (x : OpRngTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 pnegol2 p*ol2 (v2
                                                             x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 pnegol2 p*ol2 (sing2
                                                             x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 pnegol2 p*ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 pnegol2 p*ol2 (+OL2
                                                             x1
                                                             x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           pnegol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           pnegol2
           p*ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 pnegol2 p*ol2 (negOL2
                                                             x1) =
      pnegol2 _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           pnegol2
           p*ol2
           x1)
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 pnegol2 p*ol2 (*OL2
                                                             x1
                                                             x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           pnegol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           pnegol2
           p*ol2
           x2)
    0L' : RngTerm
    0L' = 0L
    +L' :
      RngTerm -> RngTerm -> RngTerm
    +L' x1 x2 = +L x1 x2
    negL' : RngTerm -> RngTerm
    negL' x1 = negL x1
    *L' :
      RngTerm -> RngTerm -> RngTerm
    *L' x1 x2 = *L x1 x2
    stageB :
      RngTerm -> Staged RngTerm
    stageB (0L) = Now 0L
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (negL x1) =
      stage1 _ _ negL'
        (codeLift1 _ _ negL')
        (stageB x1)
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    0Cl' : (A : Set) -> ClRngTerm A
    0Cl' _ = 0Cl
    +Cl' :
      (A : Set) ->
      ClRngTerm A ->
      ClRngTerm A -> ClRngTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    negCl' :
      (A : Set) ->
      ClRngTerm A -> ClRngTerm A
    negCl' _ x1 = negCl x1
    *Cl' :
      (A : Set) ->
      ClRngTerm A ->
      ClRngTerm A -> ClRngTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    stageCl :
      (A : Set) ->
      ClRngTerm A ->
      Staged (ClRngTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (negCl x1) =
      stage1 _ _ (negCl' _)
        (codeLift1 _ _ (negCl' _))
        (stageCl _ x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    0OL' : (n : Nat) -> OpRngTerm n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      OpRngTerm n ->
      OpRngTerm n -> OpRngTerm n
    +OL' _ x1 x2 = +OL x1 x2
    negOL' :
      (n : Nat) ->
      OpRngTerm n -> OpRngTerm n
    negOL' _ x1 = negOL x1
    *OL' :
      (n : Nat) ->
      OpRngTerm n ->
      OpRngTerm n -> OpRngTerm n
    *OL' _ x1 x2 = *OL x1 x2
    stageOp :
      (n : Nat) ->
      OpRngTerm n ->
      Staged (OpRngTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (0OL) = Now 0OL
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (negOL x1) =
      stage1 _ _ (negOL' _)
        (codeLift1 _ _ (negOL' _))
        (stageOp _ x1)
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    0OL2' :
      (n : Nat) (A : Set) ->
      OpRngTerm2 n A
    0OL2' _ _ = 0OL2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpRngTerm2 n A ->
      OpRngTerm2 n A -> OpRngTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    negOL2' :
      (n : Nat) (A : Set) ->
      OpRngTerm2 n A -> OpRngTerm2 n A
    negOL2' _ _ x1 = negOL2 x1
    *OL2' :
      (n : Nat) (A : Set) ->
      OpRngTerm2 n A ->
      OpRngTerm2 n A -> OpRngTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpRngTerm2 n A ->
      Staged (OpRngTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (negOL2 x1) =
      stage1 _ _ (negOL2' _ _)
        (codeLift1 _ _ (negOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record RngTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        0T : Repr A
        +T : Repr A -> Repr A -> Repr A
        negT : Repr A -> Repr A
        *T : Repr A -> Repr A -> Repr A
  
  module SemiRng where
    record SemiRng
      (A : Set) : Set where
      constructor SemiRngC
      field
        * : A -> A -> A
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record SemiRngSig
      (AS : Set) : Set where
      constructor SemiRngSigSigC
      field
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
        0S : AS
    record SemiRngProd
      (AP : Set) : Set where
      constructor SemiRngProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record SemiRngHom
      (A1 : Set) (A2 : Set)
      (Se1 : SemiRng A1)
      (Se2 : SemiRng A2) : Set where
      constructor SemiRngHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Se1 x1 x2) ==
            * Se2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Se1 x1 x2) ==
            + Se2 (hom x1) (hom x2)
        pres-0 : hom (0 Se1) == 0 Se2
    record SemiRngRelInterp
      (A1 : Set) (A2 : Set)
      (Se1 : SemiRng A1)
      (Se2 : SemiRng A2) : Set where
      constructor SemiRngRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Se1 x1 x2)
            (* Se2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Se1 x1 x2)
            (+ Se2 y1 y2)
        interp-0 :
          interp (0 Se1) (0 Se2)
    data SemiRngTerm : Set where
      *L :
        SemiRngTerm ->
        SemiRngTerm -> SemiRngTerm
      +L :
        SemiRngTerm ->
        SemiRngTerm -> SemiRngTerm
      0L : SemiRngTerm
    data ClSemiRngTerm
      (A : Set) : Set where
      sing : A -> ClSemiRngTerm A
      *Cl :
        ClSemiRngTerm A ->
        ClSemiRngTerm A ->
        ClSemiRngTerm A
      +Cl :
        ClSemiRngTerm A ->
        ClSemiRngTerm A ->
        ClSemiRngTerm A
      0Cl : ClSemiRngTerm A
    data OpSemiRngTerm
      (n : Nat) : Set where
      v : Fin n -> OpSemiRngTerm n
      *OL :
        OpSemiRngTerm n ->
        OpSemiRngTerm n ->
        OpSemiRngTerm n
      +OL :
        OpSemiRngTerm n ->
        OpSemiRngTerm n ->
        OpSemiRngTerm n
      0OL : OpSemiRngTerm n
    data OpSemiRngTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpSemiRngTerm2 n A
      sing2 : A -> OpSemiRngTerm2 n A
      *OL2 :
        OpSemiRngTerm2 n A ->
        OpSemiRngTerm2 n A ->
        OpSemiRngTerm2 n A
      +OL2 :
        OpSemiRngTerm2 n A ->
        OpSemiRngTerm2 n A ->
        OpSemiRngTerm2 n A
      0OL2 : OpSemiRngTerm2 n A
    simplifyB :
      SemiRngTerm -> SemiRngTerm
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (+L
               (*L x y)
               (*L x z)) = *L x (+L y z)
    simplifyB (+L
               (*L y x)
               (*L z x)) = *L (+L y z) x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (0L) = 0L
    simplifyCl :
      (A : Set) ->
      ClSemiRngTerm A ->
      ClSemiRngTerm A
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (+Cl
                  (*Cl x y)
                  (*Cl x z)) = *Cl x (+Cl y z)
    simplifyCl _ (+Cl
                  (*Cl y x)
                  (*Cl z x)) = *Cl (+Cl y z) x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpSemiRngTerm n ->
      OpSemiRngTerm n
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (+OL
                  (*OL x y)
                  (*OL x z)) = *OL x (+OL y z)
    simplifyOp _ (+OL
                  (*OL y x)
                  (*OL z x)) = *OL (+OL y z) x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpSemiRngTerm2 n A ->
      OpSemiRngTerm2 n A
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (+OL2
                     (*OL2 x y)
                     (*OL2 x z)) = *OL2 x (+OL2 y z)
    simplifyOpE _ _ (+OL2
                     (*OL2 y x)
                     (*OL2 z x)) = *OL2 (+OL2 y z) x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      SemiRng A -> SemiRngTerm -> A
    evalB _ Se (*L x1 x2) =
      * Se (evalB _ Se x1)
        (evalB _ Se x2)
    evalB _ Se (+L x1 x2) =
      + Se (evalB _ Se x1)
        (evalB _ Se x2)
    evalB _ Se (0L) = 0 Se
    evalCl :
      (A : Set) ->
      SemiRng A ->
      ClSemiRngTerm A -> A
    evalCl _ Se (sing x1) = x1
    evalCl _ Se (*Cl x1 x2) =
      * Se (evalCl _ Se x1)
        (evalCl _ Se x2)
    evalCl _ Se (+Cl x1 x2) =
      + Se (evalCl _ Se x1)
        (evalCl _ Se x2)
    evalCl _ Se (0Cl) = 0 Se
    evalOp :
      (A : Set) (n : Nat) ->
      SemiRng A ->
      Vec A n -> OpSemiRngTerm n -> A
    evalOp _ n Se vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Se vars (*OL x1 x2) =
      * Se (evalOp _ n Se vars x1)
        (evalOp _ n Se vars x2)
    evalOp _ n Se vars (+OL x1 x2) =
      + Se (evalOp _ n Se vars x1)
        (evalOp _ n Se vars x2)
    evalOp _ n Se vars (0OL) = 0 Se
    evalOpE :
      (A : Set) (n : Nat) ->
      SemiRng A ->
      Vec A n ->
      OpSemiRngTerm2 n A -> A
    evalOpE _ n Se vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Se vars (sing2 x1) =
      x1
    evalOpE _ n Se vars (*OL2
                         x1
                         x2) =
      * Se (evalOpE _ n Se vars x1)
        (evalOpE _ n Se vars x2)
    evalOpE _ n Se vars (+OL2
                         x1
                         x2) =
      + Se (evalOpE _ n Se vars x1)
        (evalOpE _ n Se vars x2)
    evalOpE _ n Se vars (0OL2) =
      0 Se
    inductionB :
      (P : SemiRngTerm -> Set) ->
      ((x1 : SemiRngTerm)
       (x2 : SemiRngTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : SemiRngTerm)
       (x2 : SemiRngTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      P 0L -> (x : SemiRngTerm) -> P x
    inductionB p p*l p+l p0l (*L
                              x1
                              x2) =
      p*l _ _
        (inductionB p p*l p+l p0l x1)
        (inductionB p p*l p+l p0l x2)
    inductionB p p*l p+l p0l (+L
                              x1
                              x2) =
      p+l _ _
        (inductionB p p*l p+l p0l x1)
        (inductionB p p*l p+l p0l x2)
    inductionB p p*l p+l p0l (0L) =
      p0l
    inductionCl :
      (A : Set)
      (P : ClSemiRngTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClSemiRngTerm A)
       (x2 : ClSemiRngTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClSemiRngTerm A)
       (x2 : ClSemiRngTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      P 0Cl ->
      (x : ClSemiRngTerm A) -> P x
    inductionCl _ p psing p*cl p+cl p0cl (sing
                                          x1) = psing x1
    inductionCl _ p psing p*cl p+cl p0cl (*Cl
                                          x1
                                          x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p+cl
           p0cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           p0cl
           x2)
    inductionCl _ p psing p*cl p+cl p0cl (+Cl
                                          x1
                                          x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p+cl
           p0cl
           x1)
        (inductionCl _ p psing p*cl p+cl
           p0cl
           x2)
    inductionCl _ p psing p*cl p+cl p0cl (0Cl) =
      p0cl
    inductionOp :
      (n : Nat)
      (P : OpSemiRngTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpSemiRngTerm n)
       (x2 : OpSemiRngTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpSemiRngTerm n)
       (x2 : OpSemiRngTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      P 0OL ->
      (x : OpSemiRngTerm n) -> P x
    inductionOp _ p pv p*ol p+ol p0ol (v
                                       x1) = pv x1
    inductionOp _ p pv p*ol p+ol p0ol (*OL
                                       x1
                                       x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p+ol
           p0ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           p0ol
           x2)
    inductionOp _ p pv p*ol p+ol p0ol (+OL
                                       x1
                                       x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p+ol
           p0ol
           x1)
        (inductionOp _ p pv p*ol p+ol
           p0ol
           x2)
    inductionOp _ p pv p*ol p+ol p0ol (0OL) =
      p0ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpSemiRngTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpSemiRngTerm2 n A)
       (x2 : OpSemiRngTerm2 n A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpSemiRngTerm2 n A)
       (x2 : OpSemiRngTerm2 n A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      P 0OL2 ->
      (x : OpSemiRngTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 (v2
                                                     x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 (sing2
                                                     x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 (*OL2
                                                     x1
                                                     x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 (+OL2
                                                     x1
                                                     x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p+ol2
           p0ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p+ol2 p0ol2 (0OL2) =
      p0ol2
    *L' :
      SemiRngTerm ->
      SemiRngTerm -> SemiRngTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      SemiRngTerm ->
      SemiRngTerm -> SemiRngTerm
    +L' x1 x2 = +L x1 x2
    0L' : SemiRngTerm
    0L' = 0L
    stageB :
      SemiRngTerm ->
      Staged SemiRngTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (0L) = Now 0L
    *Cl' :
      (A : Set) ->
      ClSemiRngTerm A ->
      ClSemiRngTerm A ->
      ClSemiRngTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClSemiRngTerm A ->
      ClSemiRngTerm A ->
      ClSemiRngTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    0Cl' :
      (A : Set) -> ClSemiRngTerm A
    0Cl' _ = 0Cl
    stageCl :
      (A : Set) ->
      ClSemiRngTerm A ->
      Staged (ClSemiRngTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (0Cl) = Now 0Cl
    *OL' :
      (n : Nat) ->
      OpSemiRngTerm n ->
      OpSemiRngTerm n ->
      OpSemiRngTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpSemiRngTerm n ->
      OpSemiRngTerm n ->
      OpSemiRngTerm n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) -> OpSemiRngTerm n
    0OL' _ = 0OL
    stageOp :
      (n : Nat) ->
      OpSemiRngTerm n ->
      Staged (OpSemiRngTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (0OL) = Now 0OL
    *OL2' :
      (n : Nat) (A : Set) ->
      OpSemiRngTerm2 n A ->
      OpSemiRngTerm2 n A ->
      OpSemiRngTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpSemiRngTerm2 n A ->
      OpSemiRngTerm2 n A ->
      OpSemiRngTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    0OL2' :
      (n : Nat) (A : Set) ->
      OpSemiRngTerm2 n A
    0OL2' _ _ = 0OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpSemiRngTerm2 n A ->
      Staged (OpSemiRngTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (0OL2) = Now 0OL2
    record SemiRngTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
        0T : Repr A
  
  module SemiRngWithUnit where
    record SemiRngWithUnit
      (A : Set) : Set where
      constructor SemiRngWithUnitC
      field
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        + : A -> A -> A
        0 : A
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
    record SemiRngWithUnitSig
      (AS : Set) : Set where
      constructor SemiRngWithUnitSigSigC
      field
        *S : AS -> AS -> AS
        1S : AS
        +S : AS -> AS -> AS
        0S : AS
    record SemiRngWithUnitProd
      (AP : Set) : Set where
      constructor SemiRngWithUnitProdC
      field
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        0P : Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
    record SemiRngWithUnitHom
      (A1 : Set) (A2 : Set)
      (Se1 : SemiRngWithUnit A1)
      (Se2 : SemiRngWithUnit A2) :
      Set where
      constructor SemiRngWithUnitHomC
      field
        hom : A1 -> A2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Se1 x1 x2) ==
            * Se2 (hom x1) (hom x2)
        pres-1 : hom (1 Se1) == 1 Se2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Se1 x1 x2) ==
            + Se2 (hom x1) (hom x2)
        pres-0 : hom (0 Se1) == 0 Se2
    record SemiRngWithUnitRelInterp
      (A1 : Set) (A2 : Set)
      (Se1 : SemiRngWithUnit A1)
      (Se2 : SemiRngWithUnit A2) :
      Set where
      constructor SemiRngWithUnitRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Se1 x1 x2)
            (* Se2 y1 y2)
        interp-1 :
          interp (1 Se1) (1 Se2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Se1 x1 x2)
            (+ Se2 y1 y2)
        interp-0 :
          interp (0 Se1) (0 Se2)
    data SemiRngWithUnitTerm
      : Set where
      *L :
        SemiRngWithUnitTerm ->
        SemiRngWithUnitTerm ->
        SemiRngWithUnitTerm
      1L : SemiRngWithUnitTerm
      +L :
        SemiRngWithUnitTerm ->
        SemiRngWithUnitTerm ->
        SemiRngWithUnitTerm
      0L : SemiRngWithUnitTerm
    data ClSemiRngWithUnitTerm
      (A : Set) : Set where
      sing :
        A -> ClSemiRngWithUnitTerm A
      *Cl :
        ClSemiRngWithUnitTerm A ->
        ClSemiRngWithUnitTerm A ->
        ClSemiRngWithUnitTerm A
      1Cl : ClSemiRngWithUnitTerm A
      +Cl :
        ClSemiRngWithUnitTerm A ->
        ClSemiRngWithUnitTerm A ->
        ClSemiRngWithUnitTerm A
      0Cl : ClSemiRngWithUnitTerm A
    data OpSemiRngWithUnitTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpSemiRngWithUnitTerm n
      *OL :
        OpSemiRngWithUnitTerm n ->
        OpSemiRngWithUnitTerm n ->
        OpSemiRngWithUnitTerm n
      1OL : OpSemiRngWithUnitTerm n
      +OL :
        OpSemiRngWithUnitTerm n ->
        OpSemiRngWithUnitTerm n ->
        OpSemiRngWithUnitTerm n
      0OL : OpSemiRngWithUnitTerm n
    data OpSemiRngWithUnitTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpSemiRngWithUnitTerm2 n A
      sing2 :
        A -> OpSemiRngWithUnitTerm2 n A
      *OL2 :
        OpSemiRngWithUnitTerm2 n A ->
        OpSemiRngWithUnitTerm2 n A ->
        OpSemiRngWithUnitTerm2 n A
      1OL2 :
        OpSemiRngWithUnitTerm2 n A
      +OL2 :
        OpSemiRngWithUnitTerm2 n A ->
        OpSemiRngWithUnitTerm2 n A ->
        OpSemiRngWithUnitTerm2 n A
      0OL2 :
        OpSemiRngWithUnitTerm2 n A
    simplifyB :
      SemiRngWithUnitTerm ->
      SemiRngWithUnitTerm
    simplifyB (*L (1L) x) = x
    simplifyB (*L x (1L)) = x
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (+L
               (*L x y)
               (*L x z)) = *L x (+L y z)
    simplifyB (+L
               (*L y x)
               (*L z x)) = *L (+L y z) x
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (1L) = 1L
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (0L) = 0L
    simplifyCl :
      (A : Set) ->
      ClSemiRngWithUnitTerm A ->
      ClSemiRngWithUnitTerm A
    simplifyCl _ (*Cl (1Cl) x) = x
    simplifyCl _ (*Cl x (1Cl)) = x
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (+Cl
                  (*Cl x y)
                  (*Cl x z)) = *Cl x (+Cl y z)
    simplifyCl _ (+Cl
                  (*Cl y x)
                  (*Cl z x)) = *Cl (+Cl y z) x
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpSemiRngWithUnitTerm n ->
      OpSemiRngWithUnitTerm n
    simplifyOp _ (*OL (1OL) x) = x
    simplifyOp _ (*OL x (1OL)) = x
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (+OL
                  (*OL x y)
                  (*OL x z)) = *OL x (+OL y z)
    simplifyOp _ (+OL
                  (*OL y x)
                  (*OL z x)) = *OL (+OL y z) x
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpSemiRngWithUnitTerm2 n A ->
      OpSemiRngWithUnitTerm2 n A
    simplifyOpE _ _ (*OL2
                     (1OL2)
                     x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (1OL2)) = x
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (+OL2
                     (*OL2 x y)
                     (*OL2 x z)) = *OL2 x (+OL2 y z)
    simplifyOpE _ _ (+OL2
                     (*OL2 y x)
                     (*OL2 z x)) = *OL2 (+OL2 y z) x
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      SemiRngWithUnit A ->
      SemiRngWithUnitTerm -> A
    evalB _ Se (*L x1 x2) =
      * Se (evalB _ Se x1)
        (evalB _ Se x2)
    evalB _ Se (1L) = 1 Se
    evalB _ Se (+L x1 x2) =
      + Se (evalB _ Se x1)
        (evalB _ Se x2)
    evalB _ Se (0L) = 0 Se
    evalCl :
      (A : Set) ->
      SemiRngWithUnit A ->
      ClSemiRngWithUnitTerm A -> A
    evalCl _ Se (sing x1) = x1
    evalCl _ Se (*Cl x1 x2) =
      * Se (evalCl _ Se x1)
        (evalCl _ Se x2)
    evalCl _ Se (1Cl) = 1 Se
    evalCl _ Se (+Cl x1 x2) =
      + Se (evalCl _ Se x1)
        (evalCl _ Se x2)
    evalCl _ Se (0Cl) = 0 Se
    evalOp :
      (A : Set) (n : Nat) ->
      SemiRngWithUnit A ->
      Vec A n ->
      OpSemiRngWithUnitTerm n -> A
    evalOp _ n Se vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Se vars (*OL x1 x2) =
      * Se (evalOp _ n Se vars x1)
        (evalOp _ n Se vars x2)
    evalOp _ n Se vars (1OL) = 1 Se
    evalOp _ n Se vars (+OL x1 x2) =
      + Se (evalOp _ n Se vars x1)
        (evalOp _ n Se vars x2)
    evalOp _ n Se vars (0OL) = 0 Se
    evalOpE :
      (A : Set) (n : Nat) ->
      SemiRngWithUnit A ->
      Vec A n ->
      OpSemiRngWithUnitTerm2 n A -> A
    evalOpE _ n Se vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Se vars (sing2 x1) =
      x1
    evalOpE _ n Se vars (*OL2
                         x1
                         x2) =
      * Se (evalOpE _ n Se vars x1)
        (evalOpE _ n Se vars x2)
    evalOpE _ n Se vars (1OL2) =
      1 Se
    evalOpE _ n Se vars (+OL2
                         x1
                         x2) =
      + Se (evalOpE _ n Se vars x1)
        (evalOpE _ n Se vars x2)
    evalOpE _ n Se vars (0OL2) =
      0 Se
    inductionB :
      (P : SemiRngWithUnitTerm ->
           Set) ->
      ((x1 : SemiRngWithUnitTerm)
       (x2 : SemiRngWithUnitTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      P 1L ->
      ((x1 : SemiRngWithUnitTerm)
       (x2 : SemiRngWithUnitTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      P 0L ->
      (x : SemiRngWithUnitTerm) -> P x
    inductionB p p*l p1l p+l p0l (*L
                                  x1
                                  x2) =
      p*l _ _
        (inductionB p p*l p1l p+l p0l
           x1)
        (inductionB p p*l p1l p+l p0l
           x2)
    inductionB p p*l p1l p+l p0l (1L) =
      p1l
    inductionB p p*l p1l p+l p0l (+L
                                  x1
                                  x2) =
      p+l _ _
        (inductionB p p*l p1l p+l p0l
           x1)
        (inductionB p p*l p1l p+l p0l
           x2)
    inductionB p p*l p1l p+l p0l (0L) =
      p0l
    inductionCl :
      (A : Set)
      (P : ClSemiRngWithUnitTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClSemiRngWithUnitTerm A)
       (x2 : ClSemiRngWithUnitTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      P 1Cl ->
      ((x1 : ClSemiRngWithUnitTerm A)
       (x2 : ClSemiRngWithUnitTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      P 0Cl ->
      (x : ClSemiRngWithUnitTerm A) ->
      P x
    inductionCl _ p psing p*cl p1cl p+cl p0cl (sing
                                               x1) = psing x1
    inductionCl _ p psing p*cl p1cl p+cl p0cl (*Cl
                                               x1
                                               x2) =
      p*cl _ _
        (inductionCl _ p psing p*cl p1cl
           p+cl
           p0cl
           x1)
        (inductionCl _ p psing p*cl p1cl
           p+cl
           p0cl
           x2)
    inductionCl _ p psing p*cl p1cl p+cl p0cl (1Cl) =
      p1cl
    inductionCl _ p psing p*cl p1cl p+cl p0cl (+Cl
                                               x1
                                               x2) =
      p+cl _ _
        (inductionCl _ p psing p*cl p1cl
           p+cl
           p0cl
           x1)
        (inductionCl _ p psing p*cl p1cl
           p+cl
           p0cl
           x2)
    inductionCl _ p psing p*cl p1cl p+cl p0cl (0Cl) =
      p0cl
    inductionOp :
      (n : Nat)
      (P : OpSemiRngWithUnitTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpSemiRngWithUnitTerm n)
       (x2 : OpSemiRngWithUnitTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      P 1OL ->
      ((x1 : OpSemiRngWithUnitTerm n)
       (x2 : OpSemiRngWithUnitTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      P 0OL ->
      (x : OpSemiRngWithUnitTerm n) ->
      P x
    inductionOp _ p pv p*ol p1ol p+ol p0ol (v
                                            x1) = pv x1
    inductionOp _ p pv p*ol p1ol p+ol p0ol (*OL
                                            x1
                                            x2) =
      p*ol _ _
        (inductionOp _ p pv p*ol p1ol
           p+ol
           p0ol
           x1)
        (inductionOp _ p pv p*ol p1ol
           p+ol
           p0ol
           x2)
    inductionOp _ p pv p*ol p1ol p+ol p0ol (1OL) =
      p1ol
    inductionOp _ p pv p*ol p1ol p+ol p0ol (+OL
                                            x1
                                            x2) =
      p+ol _ _
        (inductionOp _ p pv p*ol p1ol
           p+ol
           p0ol
           x1)
        (inductionOp _ p pv p*ol p1ol
           p+ol
           p0ol
           x2)
    inductionOp _ p pv p*ol p1ol p+ol p0ol (0OL) =
      p0ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpSemiRngWithUnitTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpSemiRngWithUnitTerm2 n
          A)
       (x2 : OpSemiRngWithUnitTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      P 1OL2 ->
      ((x1 : OpSemiRngWithUnitTerm2 n
          A)
       (x2 : OpSemiRngWithUnitTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      P 0OL2 ->
      (x : OpSemiRngWithUnitTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 (v2
                                                           x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 (sing2
                                                           x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 (*OL2
                                                           x1
                                                           x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           p+ol2
           p0ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           p+ol2
           p0ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 (1OL2) =
      p1ol2
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 (+OL2
                                                           x1
                                                           x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           p+ol2
           p0ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p*ol2
           p1ol2
           p+ol2
           p0ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p*ol2 p1ol2 p+ol2 p0ol2 (0OL2) =
      p0ol2
    *L' :
      SemiRngWithUnitTerm ->
      SemiRngWithUnitTerm ->
      SemiRngWithUnitTerm
    *L' x1 x2 = *L x1 x2
    1L' : SemiRngWithUnitTerm
    1L' = 1L
    +L' :
      SemiRngWithUnitTerm ->
      SemiRngWithUnitTerm ->
      SemiRngWithUnitTerm
    +L' x1 x2 = +L x1 x2
    0L' : SemiRngWithUnitTerm
    0L' = 0L
    stageB :
      SemiRngWithUnitTerm ->
      Staged SemiRngWithUnitTerm
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (1L) = Now 1L
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (0L) = Now 0L
    *Cl' :
      (A : Set) ->
      ClSemiRngWithUnitTerm A ->
      ClSemiRngWithUnitTerm A ->
      ClSemiRngWithUnitTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    1Cl' :
      (A : Set) ->
      ClSemiRngWithUnitTerm A
    1Cl' _ = 1Cl
    +Cl' :
      (A : Set) ->
      ClSemiRngWithUnitTerm A ->
      ClSemiRngWithUnitTerm A ->
      ClSemiRngWithUnitTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    0Cl' :
      (A : Set) ->
      ClSemiRngWithUnitTerm A
    0Cl' _ = 0Cl
    stageCl :
      (A : Set) ->
      ClSemiRngWithUnitTerm A ->
      Staged (ClSemiRngWithUnitTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (1Cl) = Now 1Cl
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (0Cl) = Now 0Cl
    *OL' :
      (n : Nat) ->
      OpSemiRngWithUnitTerm n ->
      OpSemiRngWithUnitTerm n ->
      OpSemiRngWithUnitTerm n
    *OL' _ x1 x2 = *OL x1 x2
    1OL' :
      (n : Nat) ->
      OpSemiRngWithUnitTerm n
    1OL' _ = 1OL
    +OL' :
      (n : Nat) ->
      OpSemiRngWithUnitTerm n ->
      OpSemiRngWithUnitTerm n ->
      OpSemiRngWithUnitTerm n
    +OL' _ x1 x2 = +OL x1 x2
    0OL' :
      (n : Nat) ->
      OpSemiRngWithUnitTerm n
    0OL' _ = 0OL
    stageOp :
      (n : Nat) ->
      OpSemiRngWithUnitTerm n ->
      Staged (OpSemiRngWithUnitTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (1OL) = Now 1OL
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (0OL) = Now 0OL
    *OL2' :
      (n : Nat) (A : Set) ->
      OpSemiRngWithUnitTerm2 n A ->
      OpSemiRngWithUnitTerm2 n A ->
      OpSemiRngWithUnitTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    1OL2' :
      (n : Nat) (A : Set) ->
      OpSemiRngWithUnitTerm2 n A
    1OL2' _ _ = 1OL2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpSemiRngWithUnitTerm2 n A ->
      OpSemiRngWithUnitTerm2 n A ->
      OpSemiRngWithUnitTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    0OL2' :
      (n : Nat) (A : Set) ->
      OpSemiRngWithUnitTerm2 n A
    0OL2' _ _ = 0OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpSemiRngWithUnitTerm2 n A ->
      Staged
        (OpSemiRngWithUnitTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (1OL2) = Now 1OL2
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (0OL2) = Now 0OL2
    record SemiRngWithUnitTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        *T : Repr A -> Repr A -> Repr A
        1T : Repr A
        +T : Repr A -> Repr A -> Repr A
        0T : Repr A
  
  module Semigroup where
    record Semigroup
      (A : Set) : Set where
      constructor SemigroupC
      field
        op : A -> A -> A
        associative_op :
          (x : A) (y : A) (z : A) ->
          op (op x y) z == op x (op y z)
    record SemigroupSig
      (AS : Set) : Set where
      constructor SemigroupSigSigC
      field
        opS : AS -> AS -> AS
    record SemigroupProd
      (AP : Set) : Set where
      constructor SemigroupProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        associative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          opP (opP xP yP) zP ==
            opP xP (opP yP zP)
    record SemigroupHom
      (A1 : Set) (A2 : Set)
      (Se1 : Semigroup A1)
      (Se2 : Semigroup A2) : Set where
      constructor SemigroupHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Se1 x1 x2) ==
            op Se2 (hom x1) (hom x2)
    record SemigroupRelInterp
      (A1 : Set) (A2 : Set)
      (Se1 : Semigroup A1)
      (Se2 : Semigroup A2) : Set where
      constructor SemigroupRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Se1 x1 x2)
            (op Se2 y1 y2)
    data SemigroupTerm : Set where
      opL :
        SemigroupTerm ->
        SemigroupTerm -> SemigroupTerm
    data ClSemigroupTerm
      (A : Set) : Set where
      sing : A -> ClSemigroupTerm A
      opCl :
        ClSemigroupTerm A ->
        ClSemigroupTerm A ->
        ClSemigroupTerm A
    data OpSemigroupTerm
      (n : Nat) : Set where
      v : Fin n -> OpSemigroupTerm n
      opOL :
        OpSemigroupTerm n ->
        OpSemigroupTerm n ->
        OpSemigroupTerm n
    data OpSemigroupTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpSemigroupTerm2 n A
      sing2 :
        A -> OpSemigroupTerm2 n A
      opOL2 :
        OpSemigroupTerm2 n A ->
        OpSemigroupTerm2 n A ->
        OpSemigroupTerm2 n A
    simplifyB :
      SemigroupTerm -> SemigroupTerm
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClSemigroupTerm A ->
      ClSemigroupTerm A
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpSemigroupTerm n ->
      OpSemigroupTerm n
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpSemigroupTerm2 n A ->
      OpSemigroupTerm2 n A
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Semigroup A ->
      SemigroupTerm -> A
    evalB _ Se (opL x1 x2) =
      op Se (evalB _ Se x1)
        (evalB _ Se x2)
    evalCl :
      (A : Set) ->
      Semigroup A ->
      ClSemigroupTerm A -> A
    evalCl _ Se (sing x1) = x1
    evalCl _ Se (opCl x1 x2) =
      op Se (evalCl _ Se x1)
        (evalCl _ Se x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Semigroup A ->
      Vec A n ->
      OpSemigroupTerm n -> A
    evalOp _ n Se vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Se vars (opOL
                        x1
                        x2) =
      op Se (evalOp _ n Se vars x1)
        (evalOp _ n Se vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Semigroup A ->
      Vec A n ->
      OpSemigroupTerm2 n A -> A
    evalOpE _ n Se vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Se vars (sing2 x1) =
      x1
    evalOpE _ n Se vars (opOL2
                         x1
                         x2) =
      op Se (evalOpE _ n Se vars x1)
        (evalOpE _ n Se vars x2)
    inductionB :
      (P : SemigroupTerm -> Set) ->
      ((x1 : SemigroupTerm)
       (x2 : SemigroupTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : SemigroupTerm) -> P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClSemigroupTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClSemigroupTerm A)
       (x2 : ClSemigroupTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClSemigroupTerm A) -> P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpSemigroupTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpSemigroupTerm n)
       (x2 : OpSemigroupTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpSemigroupTerm n) -> P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpSemigroupTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpSemigroupTerm2 n A)
       (x2 : OpSemigroupTerm2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpSemigroupTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      SemigroupTerm ->
      SemigroupTerm -> SemigroupTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      SemigroupTerm ->
      Staged SemigroupTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClSemigroupTerm A ->
      ClSemigroupTerm A ->
      ClSemigroupTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClSemigroupTerm A ->
      Staged (ClSemigroupTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpSemigroupTerm n ->
      OpSemigroupTerm n ->
      OpSemigroupTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpSemigroupTerm n ->
      Staged (OpSemigroupTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpSemigroupTerm2 n A ->
      OpSemigroupTerm2 n A ->
      OpSemigroupTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpSemigroupTerm2 n A ->
      Staged (OpSemigroupTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record SemigroupTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module Semiring where
    record Semiring
      (A : Set) : Set where
      constructor SemiringC
      field
        0 : A
        + : A -> A -> A
        * : A -> A -> A
        associative_* :
          (x : A) (y : A) (z : A) ->
          * (* x y) z == * x (* y z)
        1 : A
        lunit_1 : (x : A) -> * 1 x == x
        runit_1 : (x : A) -> * x 1 == x
        lunit_0 : (x : A) -> + 0 x == x
        runit_0 : (x : A) -> + x 0 == x
        associative_+ :
          (x : A) (y : A) (z : A) ->
          + (+ x y) z == + x (+ y z)
        commutative_+ :
          (x : A) (y : A) ->
          + x y == + y x
        leftDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * x (+ y z) == + (* x y) (* x z)
        rightDistributive_*_+ :
          (x : A) (y : A) (z : A) ->
          * (+ y z) x == + (* y x) (* z x)
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
    record SemiringSig
      (AS : Set) : Set where
      constructor SemiringSigSigC
      field
        0S : AS
        +S : AS -> AS -> AS
        *S : AS -> AS -> AS
        1S : AS
    record SemiringProd
      (AP : Set) : Set where
      constructor SemiringProdC
      field
        0P : Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        1P : Prod AP AP
        associative_*P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (*P xP yP) zP ==
            *P xP (*P yP zP)
        lunit_1P :
          (xP : Prod AP AP) ->
          *P 1P xP == xP
        runit_1P :
          (xP : Prod AP AP) ->
          *P xP 1P == xP
        lunit_0P :
          (xP : Prod AP AP) ->
          +P 0P xP == xP
        runit_0P :
          (xP : Prod AP AP) ->
          +P xP 0P == xP
        associative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          +P (+P xP yP) zP ==
            +P xP (+P yP zP)
        commutative_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          +P xP yP == +P yP xP
        leftDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P xP (+P yP zP) ==
            +P (*P xP yP) (*P xP zP)
        rightDistributive_*_+P :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          *P (+P yP zP) xP ==
            +P (*P yP xP) (*P zP xP)
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
    record SemiringHom
      (A1 : Set) (A2 : Set)
      (Se1 : Semiring A1)
      (Se2 : Semiring A2) : Set where
      constructor SemiringHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Se1) == 0 Se2
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Se1 x1 x2) ==
            + Se2 (hom x1) (hom x2)
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Se1 x1 x2) ==
            * Se2 (hom x1) (hom x2)
        pres-1 : hom (1 Se1) == 1 Se2
    record SemiringRelInterp
      (A1 : Set) (A2 : Set)
      (Se1 : Semiring A1)
      (Se2 : Semiring A2) : Set where
      constructor SemiringRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Se1) (0 Se2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Se1 x1 x2)
            (+ Se2 y1 y2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Se1 x1 x2)
            (* Se2 y1 y2)
        interp-1 :
          interp (1 Se1) (1 Se2)
    data SemiringTerm : Set where
      0L : SemiringTerm
      +L :
        SemiringTerm ->
        SemiringTerm -> SemiringTerm
      *L :
        SemiringTerm ->
        SemiringTerm -> SemiringTerm
      1L : SemiringTerm
    data ClSemiringTerm
      (A : Set) : Set where
      sing : A -> ClSemiringTerm A
      0Cl : ClSemiringTerm A
      +Cl :
        ClSemiringTerm A ->
        ClSemiringTerm A ->
        ClSemiringTerm A
      *Cl :
        ClSemiringTerm A ->
        ClSemiringTerm A ->
        ClSemiringTerm A
      1Cl : ClSemiringTerm A
    data OpSemiringTerm
      (n : Nat) : Set where
      v : Fin n -> OpSemiringTerm n
      0OL : OpSemiringTerm n
      +OL :
        OpSemiringTerm n ->
        OpSemiringTerm n ->
        OpSemiringTerm n
      *OL :
        OpSemiringTerm n ->
        OpSemiringTerm n ->
        OpSemiringTerm n
      1OL : OpSemiringTerm n
    data OpSemiringTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpSemiringTerm2 n A
      sing2 : A -> OpSemiringTerm2 n A
      0OL2 : OpSemiringTerm2 n A
      +OL2 :
        OpSemiringTerm2 n A ->
        OpSemiringTerm2 n A ->
        OpSemiringTerm2 n A
      *OL2 :
        OpSemiringTerm2 n A ->
        OpSemiringTerm2 n A ->
        OpSemiringTerm2 n A
      1OL2 : OpSemiringTerm2 n A
    simplifyB :
      SemiringTerm -> SemiringTerm
    simplifyB (*L (1L) x) = x
    simplifyB (*L x (1L)) = x
    simplifyB (+L (0L) x) = x
    simplifyB (+L x (0L)) = x
    simplifyB (+L
               (*L x y)
               (*L x z)) = *L x (+L y z)
    simplifyB (+L
               (*L y x)
               (*L z x)) = *L (+L y z) x
    simplifyB (*L (0L) x) = 0L
    simplifyB (*L x (0L)) = 0L
    simplifyB (0L) = 0L
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (1L) = 1L
    simplifyCl :
      (A : Set) ->
      ClSemiringTerm A ->
      ClSemiringTerm A
    simplifyCl _ (*Cl (1Cl) x) = x
    simplifyCl _ (*Cl x (1Cl)) = x
    simplifyCl _ (+Cl (0Cl) x) = x
    simplifyCl _ (+Cl x (0Cl)) = x
    simplifyCl _ (+Cl
                  (*Cl x y)
                  (*Cl x z)) = *Cl x (+Cl y z)
    simplifyCl _ (+Cl
                  (*Cl y x)
                  (*Cl z x)) = *Cl (+Cl y z) x
    simplifyCl _ (*Cl (0Cl) x) = 0Cl
    simplifyCl _ (*Cl x (0Cl)) = 0Cl
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (1Cl) = 1Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpSemiringTerm n ->
      OpSemiringTerm n
    simplifyOp _ (*OL (1OL) x) = x
    simplifyOp _ (*OL x (1OL)) = x
    simplifyOp _ (+OL (0OL) x) = x
    simplifyOp _ (+OL x (0OL)) = x
    simplifyOp _ (+OL
                  (*OL x y)
                  (*OL x z)) = *OL x (+OL y z)
    simplifyOp _ (+OL
                  (*OL y x)
                  (*OL z x)) = *OL (+OL y z) x
    simplifyOp _ (*OL (0OL) x) = 0OL
    simplifyOp _ (*OL x (0OL)) = 0OL
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (1OL) = 1OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpSemiringTerm2 n A ->
      OpSemiringTerm2 n A
    simplifyOpE _ _ (*OL2
                     (1OL2)
                     x) = x
    simplifyOpE _ _ (*OL2
                     x
                     (1OL2)) = x
    simplifyOpE _ _ (+OL2
                     (0OL2)
                     x) = x
    simplifyOpE _ _ (+OL2
                     x
                     (0OL2)) = x
    simplifyOpE _ _ (+OL2
                     (*OL2 x y)
                     (*OL2 x z)) = *OL2 x (+OL2 y z)
    simplifyOpE _ _ (+OL2
                     (*OL2 y x)
                     (*OL2 z x)) = *OL2 (+OL2 y z) x
    simplifyOpE _ _ (*OL2
                     (0OL2)
                     x) = 0OL2
    simplifyOpE _ _ (*OL2
                     x
                     (0OL2)) = 0OL2
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (1OL2) = 1OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Semiring A -> SemiringTerm -> A
    evalB _ Se (0L) = 0 Se
    evalB _ Se (+L x1 x2) =
      + Se (evalB _ Se x1)
        (evalB _ Se x2)
    evalB _ Se (*L x1 x2) =
      * Se (evalB _ Se x1)
        (evalB _ Se x2)
    evalB _ Se (1L) = 1 Se
    evalCl :
      (A : Set) ->
      Semiring A ->
      ClSemiringTerm A -> A
    evalCl _ Se (sing x1) = x1
    evalCl _ Se (0Cl) = 0 Se
    evalCl _ Se (+Cl x1 x2) =
      + Se (evalCl _ Se x1)
        (evalCl _ Se x2)
    evalCl _ Se (*Cl x1 x2) =
      * Se (evalCl _ Se x1)
        (evalCl _ Se x2)
    evalCl _ Se (1Cl) = 1 Se
    evalOp :
      (A : Set) (n : Nat) ->
      Semiring A ->
      Vec A n -> OpSemiringTerm n -> A
    evalOp _ n Se vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Se vars (0OL) = 0 Se
    evalOp _ n Se vars (+OL x1 x2) =
      + Se (evalOp _ n Se vars x1)
        (evalOp _ n Se vars x2)
    evalOp _ n Se vars (*OL x1 x2) =
      * Se (evalOp _ n Se vars x1)
        (evalOp _ n Se vars x2)
    evalOp _ n Se vars (1OL) = 1 Se
    evalOpE :
      (A : Set) (n : Nat) ->
      Semiring A ->
      Vec A n ->
      OpSemiringTerm2 n A -> A
    evalOpE _ n Se vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Se vars (sing2 x1) =
      x1
    evalOpE _ n Se vars (0OL2) =
      0 Se
    evalOpE _ n Se vars (+OL2
                         x1
                         x2) =
      + Se (evalOpE _ n Se vars x1)
        (evalOpE _ n Se vars x2)
    evalOpE _ n Se vars (*OL2
                         x1
                         x2) =
      * Se (evalOpE _ n Se vars x1)
        (evalOpE _ n Se vars x2)
    evalOpE _ n Se vars (1OL2) =
      1 Se
    inductionB :
      (P : SemiringTerm -> Set) ->
      P 0L ->
      ((x1 : SemiringTerm)
       (x2 : SemiringTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      ((x1 : SemiringTerm)
       (x2 : SemiringTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      P 1L ->
      (x : SemiringTerm) -> P x
    inductionB p p0l p+l p*l p1l (0L) =
      p0l
    inductionB p p0l p+l p*l p1l (+L
                                  x1
                                  x2) =
      p+l _ _
        (inductionB p p0l p+l p*l p1l
           x1)
        (inductionB p p0l p+l p*l p1l
           x2)
    inductionB p p0l p+l p*l p1l (*L
                                  x1
                                  x2) =
      p*l _ _
        (inductionB p p0l p+l p*l p1l
           x1)
        (inductionB p p0l p+l p*l p1l
           x2)
    inductionB p p0l p+l p*l p1l (1L) =
      p1l
    inductionCl :
      (A : Set)
      (P : ClSemiringTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 0Cl ->
      ((x1 : ClSemiringTerm A)
       (x2 : ClSemiringTerm A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      ((x1 : ClSemiringTerm A)
       (x2 : ClSemiringTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      P 1Cl ->
      (x : ClSemiringTerm A) -> P x
    inductionCl _ p psing p0cl p+cl p*cl p1cl (sing
                                               x1) = psing x1
    inductionCl _ p psing p0cl p+cl p*cl p1cl (0Cl) =
      p0cl
    inductionCl _ p psing p0cl p+cl p*cl p1cl (+Cl
                                               x1
                                               x2) =
      p+cl _ _
        (inductionCl _ p psing p0cl p+cl
           p*cl
           p1cl
           x1)
        (inductionCl _ p psing p0cl p+cl
           p*cl
           p1cl
           x2)
    inductionCl _ p psing p0cl p+cl p*cl p1cl (*Cl
                                               x1
                                               x2) =
      p*cl _ _
        (inductionCl _ p psing p0cl p+cl
           p*cl
           p1cl
           x1)
        (inductionCl _ p psing p0cl p+cl
           p*cl
           p1cl
           x2)
    inductionCl _ p psing p0cl p+cl p*cl p1cl (1Cl) =
      p1cl
    inductionOp :
      (n : Nat)
      (P : OpSemiringTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 0OL ->
      ((x1 : OpSemiringTerm n)
       (x2 : OpSemiringTerm n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      ((x1 : OpSemiringTerm n)
       (x2 : OpSemiringTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      P 1OL ->
      (x : OpSemiringTerm n) -> P x
    inductionOp _ p pv p0ol p+ol p*ol p1ol (v
                                            x1) = pv x1
    inductionOp _ p pv p0ol p+ol p*ol p1ol (0OL) =
      p0ol
    inductionOp _ p pv p0ol p+ol p*ol p1ol (+OL
                                            x1
                                            x2) =
      p+ol _ _
        (inductionOp _ p pv p0ol p+ol
           p*ol
           p1ol
           x1)
        (inductionOp _ p pv p0ol p+ol
           p*ol
           p1ol
           x2)
    inductionOp _ p pv p0ol p+ol p*ol p1ol (*OL
                                            x1
                                            x2) =
      p*ol _ _
        (inductionOp _ p pv p0ol p+ol
           p*ol
           p1ol
           x1)
        (inductionOp _ p pv p0ol p+ol
           p*ol
           p1ol
           x2)
    inductionOp _ p pv p0ol p+ol p*ol p1ol (1OL) =
      p1ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpSemiringTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 0OL2 ->
      ((x1 : OpSemiringTerm2 n A)
       (x2 : OpSemiringTerm2 n A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      ((x1 : OpSemiringTerm2 n A)
       (x2 : OpSemiringTerm2 n A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      P 1OL2 ->
      (x : OpSemiringTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 p1ol2 (v2
                                                           x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 p1ol2 (sing2
                                                           x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 p1ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 p1ol2 (+OL2
                                                           x1
                                                           x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           p*ol2
           p1ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           p*ol2
           p1ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 p1ol2 (*OL2
                                                           x1
                                                           x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           p*ol2
           p1ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p+ol2
           p*ol2
           p1ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p0ol2 p+ol2 p*ol2 p1ol2 (1OL2) =
      p1ol2
    0L' : SemiringTerm
    0L' = 0L
    +L' :
      SemiringTerm ->
      SemiringTerm -> SemiringTerm
    +L' x1 x2 = +L x1 x2
    *L' :
      SemiringTerm ->
      SemiringTerm -> SemiringTerm
    *L' x1 x2 = *L x1 x2
    1L' : SemiringTerm
    1L' = 1L
    stageB :
      SemiringTerm ->
      Staged SemiringTerm
    stageB (0L) = Now 0L
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (1L) = Now 1L
    0Cl' :
      (A : Set) -> ClSemiringTerm A
    0Cl' _ = 0Cl
    +Cl' :
      (A : Set) ->
      ClSemiringTerm A ->
      ClSemiringTerm A ->
      ClSemiringTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    *Cl' :
      (A : Set) ->
      ClSemiringTerm A ->
      ClSemiringTerm A ->
      ClSemiringTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    1Cl' :
      (A : Set) -> ClSemiringTerm A
    1Cl' _ = 1Cl
    stageCl :
      (A : Set) ->
      ClSemiringTerm A ->
      Staged (ClSemiringTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (1Cl) = Now 1Cl
    0OL' :
      (n : Nat) -> OpSemiringTerm n
    0OL' _ = 0OL
    +OL' :
      (n : Nat) ->
      OpSemiringTerm n ->
      OpSemiringTerm n ->
      OpSemiringTerm n
    +OL' _ x1 x2 = +OL x1 x2
    *OL' :
      (n : Nat) ->
      OpSemiringTerm n ->
      OpSemiringTerm n ->
      OpSemiringTerm n
    *OL' _ x1 x2 = *OL x1 x2
    1OL' :
      (n : Nat) -> OpSemiringTerm n
    1OL' _ = 1OL
    stageOp :
      (n : Nat) ->
      OpSemiringTerm n ->
      Staged (OpSemiringTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (0OL) = Now 0OL
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (1OL) = Now 1OL
    0OL2' :
      (n : Nat) (A : Set) ->
      OpSemiringTerm2 n A
    0OL2' _ _ = 0OL2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpSemiringTerm2 n A ->
      OpSemiringTerm2 n A ->
      OpSemiringTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    *OL2' :
      (n : Nat) (A : Set) ->
      OpSemiringTerm2 n A ->
      OpSemiringTerm2 n A ->
      OpSemiringTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    1OL2' :
      (n : Nat) (A : Set) ->
      OpSemiringTerm2 n A
    1OL2' _ _ = 1OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpSemiringTerm2 n A ->
      Staged (OpSemiringTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (1OL2) = Now 1OL2
    record SemiringTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        0T : Repr A
        +T : Repr A -> Repr A -> Repr A
        *T : Repr A -> Repr A -> Repr A
        1T : Repr A
  
  module Shelf where
    record Shelf
      (A : Set) : Set where
      constructor ShelfC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
    record ShelfSig
      (AS : Set) : Set where
      constructor ShelfSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record ShelfProd
      (AP : Set) : Set where
      constructor ShelfProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
    record ShelfHom
      (A1 : Set) (A2 : Set)
      (Sh1 : Shelf A1)
      (Sh2 : Shelf A2) : Set where
      constructor ShelfHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Sh1 x1 x2) ==
            |> Sh2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Sh1 x1 x2) ==
            <| Sh2 (hom x1) (hom x2)
    record ShelfRelInterp
      (A1 : Set) (A2 : Set)
      (Sh1 : Shelf A1)
      (Sh2 : Shelf A2) : Set where
      constructor ShelfRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Sh1 x1 x2)
            (|> Sh2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Sh1 x1 x2)
            (<| Sh2 y1 y2)
    data ShelfTerm : Set where
      |>L :
        ShelfTerm ->
        ShelfTerm -> ShelfTerm
      <|L :
        ShelfTerm ->
        ShelfTerm -> ShelfTerm
    data ClShelfTerm
      (A : Set) : Set where
      sing : A -> ClShelfTerm A
      |>Cl :
        ClShelfTerm A ->
        ClShelfTerm A -> ClShelfTerm A
      <|Cl :
        ClShelfTerm A ->
        ClShelfTerm A -> ClShelfTerm A
    data OpShelfTerm
      (n : Nat) : Set where
      v : Fin n -> OpShelfTerm n
      |>OL :
        OpShelfTerm n ->
        OpShelfTerm n -> OpShelfTerm n
      <|OL :
        OpShelfTerm n ->
        OpShelfTerm n -> OpShelfTerm n
    data OpShelfTerm2
      (n : Nat) (A : Set) : Set where
      v2 : Fin n -> OpShelfTerm2 n A
      sing2 : A -> OpShelfTerm2 n A
      |>OL2 :
        OpShelfTerm2 n A ->
        OpShelfTerm2 n A ->
        OpShelfTerm2 n A
      <|OL2 :
        OpShelfTerm2 n A ->
        OpShelfTerm2 n A ->
        OpShelfTerm2 n A
    simplifyB :
      ShelfTerm -> ShelfTerm
    simplifyB (|>L
               (|>L x y)
               (|>L x z)) = |>L x (|>L y z)
    simplifyB (<|L
               (<|L y x)
               (<|L z x)) = <|L (<|L y z) x
    simplifyB (|>L x1 x2) =
      |>L (simplifyB x1)
        (simplifyB x2)
    simplifyB (<|L x1 x2) =
      <|L (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClShelfTerm A -> ClShelfTerm A
    simplifyCl _ (|>Cl
                  (|>Cl x y)
                  (|>Cl x z)) = |>Cl x (|>Cl y z)
    simplifyCl _ (<|Cl
                  (<|Cl y x)
                  (<|Cl z x)) = <|Cl (<|Cl y z) x
    simplifyCl _ (|>Cl x1 x2) =
      |>Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (<|Cl x1 x2) =
      <|Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpShelfTerm n -> OpShelfTerm n
    simplifyOp _ (|>OL
                  (|>OL x y)
                  (|>OL x z)) = |>OL x (|>OL y z)
    simplifyOp _ (<|OL
                  (<|OL y x)
                  (<|OL z x)) = <|OL (<|OL y z) x
    simplifyOp _ (|>OL x1 x2) =
      |>OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (<|OL x1 x2) =
      <|OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpShelfTerm2 n A ->
      OpShelfTerm2 n A
    simplifyOpE _ _ (|>OL2
                     (|>OL2 x y)
                     (|>OL2 x z)) =
      |>OL2 x (|>OL2 y z)
    simplifyOpE _ _ (<|OL2
                     (<|OL2 y x)
                     (<|OL2 z x)) =
      <|OL2 (<|OL2 y z) x
    simplifyOpE _ _ (|>OL2 x1 x2) =
      |>OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (<|OL2 x1 x2) =
      <|OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Shelf A -> ShelfTerm -> A
    evalB _ Sh (|>L x1 x2) =
      |> Sh (evalB _ Sh x1)
        (evalB _ Sh x2)
    evalB _ Sh (<|L x1 x2) =
      <| Sh (evalB _ Sh x1)
        (evalB _ Sh x2)
    evalCl :
      (A : Set) ->
      Shelf A -> ClShelfTerm A -> A
    evalCl _ Sh (sing x1) = x1
    evalCl _ Sh (|>Cl x1 x2) =
      |> Sh (evalCl _ Sh x1)
        (evalCl _ Sh x2)
    evalCl _ Sh (<|Cl x1 x2) =
      <| Sh (evalCl _ Sh x1)
        (evalCl _ Sh x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Shelf A ->
      Vec A n -> OpShelfTerm n -> A
    evalOp _ n Sh vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Sh vars (|>OL
                        x1
                        x2) =
      |> Sh (evalOp _ n Sh vars x1)
        (evalOp _ n Sh vars x2)
    evalOp _ n Sh vars (<|OL
                        x1
                        x2) =
      <| Sh (evalOp _ n Sh vars x1)
        (evalOp _ n Sh vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Shelf A ->
      Vec A n -> OpShelfTerm2 n A -> A
    evalOpE _ n Sh vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Sh vars (sing2 x1) =
      x1
    evalOpE _ n Sh vars (|>OL2
                         x1
                         x2) =
      |> Sh (evalOpE _ n Sh vars x1)
        (evalOpE _ n Sh vars x2)
    evalOpE _ n Sh vars (<|OL2
                         x1
                         x2) =
      <| Sh (evalOpE _ n Sh vars x1)
        (evalOpE _ n Sh vars x2)
    inductionB :
      (P : ShelfTerm -> Set) ->
      ((x1 : ShelfTerm)
       (x2 : ShelfTerm) ->
       P x1 ->
       P x2 -> P (|>L x1 x2)) ->
      ((x1 : ShelfTerm)
       (x2 : ShelfTerm) ->
       P x1 ->
       P x2 -> P (<|L x1 x2)) ->
      (x : ShelfTerm) -> P x
    inductionB p p|>l p<|l (|>L
                            x1
                            x2) =
      p|>l _ _
        (inductionB p p|>l p<|l x1)
        (inductionB p p|>l p<|l x2)
    inductionB p p|>l p<|l (<|L
                            x1
                            x2) =
      p<|l _ _
        (inductionB p p|>l p<|l x1)
        (inductionB p p|>l p<|l x2)
    inductionCl :
      (A : Set)
      (P : ClShelfTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClShelfTerm A)
       (x2 : ClShelfTerm A) ->
       P x1 ->
       P x2 -> P (|>Cl x1 x2)) ->
      ((x1 : ClShelfTerm A)
       (x2 : ClShelfTerm A) ->
       P x1 ->
       P x2 -> P (<|Cl x1 x2)) ->
      (x : ClShelfTerm A) -> P x
    inductionCl _ p psing p|>cl p<|cl (sing
                                       x1) = psing x1
    inductionCl _ p psing p|>cl p<|cl (|>Cl
                                       x1
                                       x2) =
      p|>cl _ _
        (inductionCl _ p psing p|>cl
           p<|cl
           x1)
        (inductionCl _ p psing p|>cl
           p<|cl
           x2)
    inductionCl _ p psing p|>cl p<|cl (<|Cl
                                       x1
                                       x2) =
      p<|cl _ _
        (inductionCl _ p psing p|>cl
           p<|cl
           x1)
        (inductionCl _ p psing p|>cl
           p<|cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpShelfTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpShelfTerm n)
       (x2 : OpShelfTerm n) ->
       P x1 ->
       P x2 -> P (|>OL x1 x2)) ->
      ((x1 : OpShelfTerm n)
       (x2 : OpShelfTerm n) ->
       P x1 ->
       P x2 -> P (<|OL x1 x2)) ->
      (x : OpShelfTerm n) -> P x
    inductionOp _ p pv p|>ol p<|ol (v
                                    x1) = pv x1
    inductionOp _ p pv p|>ol p<|ol (|>OL
                                    x1
                                    x2) =
      p|>ol _ _
        (inductionOp _ p pv p|>ol p<|ol
           x1)
        (inductionOp _ p pv p|>ol p<|ol
           x2)
    inductionOp _ p pv p|>ol p<|ol (<|OL
                                    x1
                                    x2) =
      p<|ol _ _
        (inductionOp _ p pv p|>ol p<|ol
           x1)
        (inductionOp _ p pv p|>ol p<|ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpShelfTerm2 n A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpShelfTerm2 n A)
       (x2 : OpShelfTerm2 n A) ->
       P x1 ->
       P x2 -> P (|>OL2 x1 x2)) ->
      ((x1 : OpShelfTerm2 n A)
       (x2 : OpShelfTerm2 n A) ->
       P x1 ->
       P x2 -> P (<|OL2 x1 x2)) ->
      (x : OpShelfTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (v2
                                                 x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (sing2
                                                 x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (|>OL2
                                                 x1
                                                 x2) =
      p|>ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (<|OL2
                                                 x1
                                                 x2) =
      p<|ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x2)
    |>L' :
      ShelfTerm ->
      ShelfTerm -> ShelfTerm
    |>L' x1 x2 = |>L x1 x2
    <|L' :
      ShelfTerm ->
      ShelfTerm -> ShelfTerm
    <|L' x1 x2 = <|L x1 x2
    stageB :
      ShelfTerm -> Staged ShelfTerm
    stageB (|>L x1 x2) =
      stage2 _ _ _ |>L'
        (codeLift2 _ _ _ |>L')
        (stageB x1)
        (stageB x2)
    stageB (<|L x1 x2) =
      stage2 _ _ _ <|L'
        (codeLift2 _ _ _ <|L')
        (stageB x1)
        (stageB x2)
    |>Cl' :
      (A : Set) ->
      ClShelfTerm A ->
      ClShelfTerm A -> ClShelfTerm A
    |>Cl' _ x1 x2 = |>Cl x1 x2
    <|Cl' :
      (A : Set) ->
      ClShelfTerm A ->
      ClShelfTerm A -> ClShelfTerm A
    <|Cl' _ x1 x2 = <|Cl x1 x2
    stageCl :
      (A : Set) ->
      ClShelfTerm A ->
      Staged (ClShelfTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (|>Cl x1 x2) =
      stage2 _ _ _ (|>Cl' _)
        (codeLift2 _ _ _ (|>Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (<|Cl x1 x2) =
      stage2 _ _ _ (<|Cl' _)
        (codeLift2 _ _ _ (<|Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    |>OL' :
      (n : Nat) ->
      OpShelfTerm n ->
      OpShelfTerm n -> OpShelfTerm n
    |>OL' _ x1 x2 = |>OL x1 x2
    <|OL' :
      (n : Nat) ->
      OpShelfTerm n ->
      OpShelfTerm n -> OpShelfTerm n
    <|OL' _ x1 x2 = <|OL x1 x2
    stageOp :
      (n : Nat) ->
      OpShelfTerm n ->
      Staged (OpShelfTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (|>OL x1 x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (<|OL x1 x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    |>OL2' :
      (n : Nat) (A : Set) ->
      OpShelfTerm2 n A ->
      OpShelfTerm2 n A ->
      OpShelfTerm2 n A
    |>OL2' _ _ x1 x2 = |>OL2 x1 x2
    <|OL2' :
      (n : Nat) (A : Set) ->
      OpShelfTerm2 n A ->
      OpShelfTerm2 n A ->
      OpShelfTerm2 n A
    <|OL2' _ _ x1 x2 = <|OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpShelfTerm2 n A ->
      Staged (OpShelfTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (|>OL2 x1 x2) =
      stage2 _ _ _ (|>OL2' _ _)
        (codeLift2 _ _ _ (|>OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (<|OL2 x1 x2) =
      stage2 _ _ _ (<|OL2' _ _)
        (codeLift2 _ _ _ (<|OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record ShelfTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        |>T : Repr A -> Repr A -> Repr A
        <|T : Repr A -> Repr A -> Repr A
  
  module ShelfSig where
    record ShelfSig
      (A : Set) : Set where
      constructor ShelfSigC
      field
        |> : A -> A -> A
        <| : A -> A -> A
    record ShelfSigSig
      (AS : Set) : Set where
      constructor ShelfSigSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record ShelfSigProd
      (AP : Set) : Set where
      constructor ShelfSigProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
    record ShelfSigHom
      (A1 : Set) (A2 : Set)
      (Sh1 : ShelfSig A1)
      (Sh2 : ShelfSig A2) : Set where
      constructor ShelfSigHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Sh1 x1 x2) ==
            |> Sh2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Sh1 x1 x2) ==
            <| Sh2 (hom x1) (hom x2)
    record ShelfSigRelInterp
      (A1 : Set) (A2 : Set)
      (Sh1 : ShelfSig A1)
      (Sh2 : ShelfSig A2) : Set where
      constructor ShelfSigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Sh1 x1 x2)
            (|> Sh2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Sh1 x1 x2)
            (<| Sh2 y1 y2)
    data ShelfSigTerm : Set where
      |>L :
        ShelfSigTerm ->
        ShelfSigTerm -> ShelfSigTerm
      <|L :
        ShelfSigTerm ->
        ShelfSigTerm -> ShelfSigTerm
    data ClShelfSigTerm
      (A : Set) : Set where
      sing : A -> ClShelfSigTerm A
      |>Cl :
        ClShelfSigTerm A ->
        ClShelfSigTerm A ->
        ClShelfSigTerm A
      <|Cl :
        ClShelfSigTerm A ->
        ClShelfSigTerm A ->
        ClShelfSigTerm A
    data OpShelfSigTerm
      (n : Nat) : Set where
      v : Fin n -> OpShelfSigTerm n
      |>OL :
        OpShelfSigTerm n ->
        OpShelfSigTerm n ->
        OpShelfSigTerm n
      <|OL :
        OpShelfSigTerm n ->
        OpShelfSigTerm n ->
        OpShelfSigTerm n
    data OpShelfSigTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpShelfSigTerm2 n A
      sing2 : A -> OpShelfSigTerm2 n A
      |>OL2 :
        OpShelfSigTerm2 n A ->
        OpShelfSigTerm2 n A ->
        OpShelfSigTerm2 n A
      <|OL2 :
        OpShelfSigTerm2 n A ->
        OpShelfSigTerm2 n A ->
        OpShelfSigTerm2 n A
    simplifyB :
      ShelfSigTerm -> ShelfSigTerm
    simplifyB (|>L x1 x2) =
      |>L (simplifyB x1)
        (simplifyB x2)
    simplifyB (<|L x1 x2) =
      <|L (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClShelfSigTerm A ->
      ClShelfSigTerm A
    simplifyCl _ (|>Cl x1 x2) =
      |>Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (<|Cl x1 x2) =
      <|Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpShelfSigTerm n ->
      OpShelfSigTerm n
    simplifyOp _ (|>OL x1 x2) =
      |>OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (<|OL x1 x2) =
      <|OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpShelfSigTerm2 n A ->
      OpShelfSigTerm2 n A
    simplifyOpE _ _ (|>OL2 x1 x2) =
      |>OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (<|OL2 x1 x2) =
      <|OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      ShelfSig A -> ShelfSigTerm -> A
    evalB _ Sh (|>L x1 x2) =
      |> Sh (evalB _ Sh x1)
        (evalB _ Sh x2)
    evalB _ Sh (<|L x1 x2) =
      <| Sh (evalB _ Sh x1)
        (evalB _ Sh x2)
    evalCl :
      (A : Set) ->
      ShelfSig A ->
      ClShelfSigTerm A -> A
    evalCl _ Sh (sing x1) = x1
    evalCl _ Sh (|>Cl x1 x2) =
      |> Sh (evalCl _ Sh x1)
        (evalCl _ Sh x2)
    evalCl _ Sh (<|Cl x1 x2) =
      <| Sh (evalCl _ Sh x1)
        (evalCl _ Sh x2)
    evalOp :
      (A : Set) (n : Nat) ->
      ShelfSig A ->
      Vec A n -> OpShelfSigTerm n -> A
    evalOp _ n Sh vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Sh vars (|>OL
                        x1
                        x2) =
      |> Sh (evalOp _ n Sh vars x1)
        (evalOp _ n Sh vars x2)
    evalOp _ n Sh vars (<|OL
                        x1
                        x2) =
      <| Sh (evalOp _ n Sh vars x1)
        (evalOp _ n Sh vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      ShelfSig A ->
      Vec A n ->
      OpShelfSigTerm2 n A -> A
    evalOpE _ n Sh vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Sh vars (sing2 x1) =
      x1
    evalOpE _ n Sh vars (|>OL2
                         x1
                         x2) =
      |> Sh (evalOpE _ n Sh vars x1)
        (evalOpE _ n Sh vars x2)
    evalOpE _ n Sh vars (<|OL2
                         x1
                         x2) =
      <| Sh (evalOpE _ n Sh vars x1)
        (evalOpE _ n Sh vars x2)
    inductionB :
      (P : ShelfSigTerm -> Set) ->
      ((x1 : ShelfSigTerm)
       (x2 : ShelfSigTerm) ->
       P x1 ->
       P x2 -> P (|>L x1 x2)) ->
      ((x1 : ShelfSigTerm)
       (x2 : ShelfSigTerm) ->
       P x1 ->
       P x2 -> P (<|L x1 x2)) ->
      (x : ShelfSigTerm) -> P x
    inductionB p p|>l p<|l (|>L
                            x1
                            x2) =
      p|>l _ _
        (inductionB p p|>l p<|l x1)
        (inductionB p p|>l p<|l x2)
    inductionB p p|>l p<|l (<|L
                            x1
                            x2) =
      p<|l _ _
        (inductionB p p|>l p<|l x1)
        (inductionB p p|>l p<|l x2)
    inductionCl :
      (A : Set)
      (P : ClShelfSigTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClShelfSigTerm A)
       (x2 : ClShelfSigTerm A) ->
       P x1 ->
       P x2 -> P (|>Cl x1 x2)) ->
      ((x1 : ClShelfSigTerm A)
       (x2 : ClShelfSigTerm A) ->
       P x1 ->
       P x2 -> P (<|Cl x1 x2)) ->
      (x : ClShelfSigTerm A) -> P x
    inductionCl _ p psing p|>cl p<|cl (sing
                                       x1) = psing x1
    inductionCl _ p psing p|>cl p<|cl (|>Cl
                                       x1
                                       x2) =
      p|>cl _ _
        (inductionCl _ p psing p|>cl
           p<|cl
           x1)
        (inductionCl _ p psing p|>cl
           p<|cl
           x2)
    inductionCl _ p psing p|>cl p<|cl (<|Cl
                                       x1
                                       x2) =
      p<|cl _ _
        (inductionCl _ p psing p|>cl
           p<|cl
           x1)
        (inductionCl _ p psing p|>cl
           p<|cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpShelfSigTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpShelfSigTerm n)
       (x2 : OpShelfSigTerm n) ->
       P x1 ->
       P x2 -> P (|>OL x1 x2)) ->
      ((x1 : OpShelfSigTerm n)
       (x2 : OpShelfSigTerm n) ->
       P x1 ->
       P x2 -> P (<|OL x1 x2)) ->
      (x : OpShelfSigTerm n) -> P x
    inductionOp _ p pv p|>ol p<|ol (v
                                    x1) = pv x1
    inductionOp _ p pv p|>ol p<|ol (|>OL
                                    x1
                                    x2) =
      p|>ol _ _
        (inductionOp _ p pv p|>ol p<|ol
           x1)
        (inductionOp _ p pv p|>ol p<|ol
           x2)
    inductionOp _ p pv p|>ol p<|ol (<|OL
                                    x1
                                    x2) =
      p<|ol _ _
        (inductionOp _ p pv p|>ol p<|ol
           x1)
        (inductionOp _ p pv p|>ol p<|ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpShelfSigTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpShelfSigTerm2 n A)
       (x2 : OpShelfSigTerm2 n A) ->
       P x1 ->
       P x2 -> P (|>OL2 x1 x2)) ->
      ((x1 : OpShelfSigTerm2 n A)
       (x2 : OpShelfSigTerm2 n A) ->
       P x1 ->
       P x2 -> P (<|OL2 x1 x2)) ->
      (x : OpShelfSigTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (v2
                                                 x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (sing2
                                                 x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (|>OL2
                                                 x1
                                                 x2) =
      p|>ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (<|OL2
                                                 x1
                                                 x2) =
      p<|ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x2)
    |>L' :
      ShelfSigTerm ->
      ShelfSigTerm -> ShelfSigTerm
    |>L' x1 x2 = |>L x1 x2
    <|L' :
      ShelfSigTerm ->
      ShelfSigTerm -> ShelfSigTerm
    <|L' x1 x2 = <|L x1 x2
    stageB :
      ShelfSigTerm ->
      Staged ShelfSigTerm
    stageB (|>L x1 x2) =
      stage2 _ _ _ |>L'
        (codeLift2 _ _ _ |>L')
        (stageB x1)
        (stageB x2)
    stageB (<|L x1 x2) =
      stage2 _ _ _ <|L'
        (codeLift2 _ _ _ <|L')
        (stageB x1)
        (stageB x2)
    |>Cl' :
      (A : Set) ->
      ClShelfSigTerm A ->
      ClShelfSigTerm A ->
      ClShelfSigTerm A
    |>Cl' _ x1 x2 = |>Cl x1 x2
    <|Cl' :
      (A : Set) ->
      ClShelfSigTerm A ->
      ClShelfSigTerm A ->
      ClShelfSigTerm A
    <|Cl' _ x1 x2 = <|Cl x1 x2
    stageCl :
      (A : Set) ->
      ClShelfSigTerm A ->
      Staged (ClShelfSigTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (|>Cl x1 x2) =
      stage2 _ _ _ (|>Cl' _)
        (codeLift2 _ _ _ (|>Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (<|Cl x1 x2) =
      stage2 _ _ _ (<|Cl' _)
        (codeLift2 _ _ _ (<|Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    |>OL' :
      (n : Nat) ->
      OpShelfSigTerm n ->
      OpShelfSigTerm n ->
      OpShelfSigTerm n
    |>OL' _ x1 x2 = |>OL x1 x2
    <|OL' :
      (n : Nat) ->
      OpShelfSigTerm n ->
      OpShelfSigTerm n ->
      OpShelfSigTerm n
    <|OL' _ x1 x2 = <|OL x1 x2
    stageOp :
      (n : Nat) ->
      OpShelfSigTerm n ->
      Staged (OpShelfSigTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (|>OL x1 x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (<|OL x1 x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    |>OL2' :
      (n : Nat) (A : Set) ->
      OpShelfSigTerm2 n A ->
      OpShelfSigTerm2 n A ->
      OpShelfSigTerm2 n A
    |>OL2' _ _ x1 x2 = |>OL2 x1 x2
    <|OL2' :
      (n : Nat) (A : Set) ->
      OpShelfSigTerm2 n A ->
      OpShelfSigTerm2 n A ->
      OpShelfSigTerm2 n A
    <|OL2' _ _ x1 x2 = <|OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpShelfSigTerm2 n A ->
      Staged (OpShelfSigTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (|>OL2 x1 x2) =
      stage2 _ _ _ (|>OL2' _ _)
        (codeLift2 _ _ _ (|>OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (<|OL2 x1 x2) =
      stage2 _ _ _ (<|OL2' _ _)
        (codeLift2 _ _ _ (<|OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record ShelfSigTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        |>T : Repr A -> Repr A -> Repr A
        <|T : Repr A -> Repr A -> Repr A
  
  module Sloop where
    record Sloop
      (A : Set) : Set where
      constructor SloopC
      field
        e : A
        op : A -> A -> A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
        antiAbsorbent :
          (x : A) (y : A) ->
          op x (op x y) == y
        unipotence :
          (x : A) -> op x x == e
    record SloopSig
      (AS : Set) : Set where
      constructor SloopSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record SloopProd
      (AP : Set) : Set where
      constructor SloopProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
        antiAbsorbentP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (opP xP yP) == yP
        unipotenceP :
          (xP : Prod AP AP) ->
          opP xP xP == eP
    record SloopHom
      (A1 : Set) (A2 : Set)
      (Sl1 : Sloop A1)
      (Sl2 : Sloop A2) : Set where
      constructor SloopHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Sl1) == e Sl2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Sl1 x1 x2) ==
            op Sl2 (hom x1) (hom x2)
    record SloopRelInterp
      (A1 : Set) (A2 : Set)
      (Sl1 : Sloop A1)
      (Sl2 : Sloop A2) : Set where
      constructor SloopRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Sl1) (e Sl2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Sl1 x1 x2)
            (op Sl2 y1 y2)
    data SloopLTerm : Set where
      eL : SloopLTerm
      opL :
        SloopLTerm ->
        SloopLTerm -> SloopLTerm
    data ClSloopClTerm
      (A : Set) : Set where
      sing : A -> ClSloopClTerm A
      eCl : ClSloopClTerm A
      opCl :
        ClSloopClTerm A ->
        ClSloopClTerm A ->
        ClSloopClTerm A
    data OpSloopOLTerm
      (n : Nat) : Set where
      v : Fin n -> OpSloopOLTerm n
      eOL : OpSloopOLTerm n
      opOL :
        OpSloopOLTerm n ->
        OpSloopOLTerm n ->
        OpSloopOLTerm n
    data OpSloopOL2Term2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpSloopOL2Term2 n A
      sing2 : A -> OpSloopOL2Term2 n A
      eOL2 : OpSloopOL2Term2 n A
      opOL2 :
        OpSloopOL2Term2 n A ->
        OpSloopOL2Term2 n A ->
        OpSloopOL2Term2 n A
    simplifyB :
      SloopLTerm -> SloopLTerm
    simplifyB (opL x (opL x y)) = y
    simplifyB (opL x x) = eL
    simplifyB (eL) = eL
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClSloopClTerm A ->
      ClSloopClTerm A
    simplifyCl _ (opCl
                  x
                  (opCl x y)) = y
    simplifyCl _ (opCl x x) = eCl
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpSloopOLTerm n ->
      OpSloopOLTerm n
    simplifyOp _ (opOL
                  x
                  (opOL x y)) = y
    simplifyOp _ (opOL x x) = eOL
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpSloopOL2Term2 n A ->
      OpSloopOL2Term2 n A
    simplifyOpE _ _ (opOL2
                     x
                     (opOL2 x y)) = y
    simplifyOpE _ _ (opOL2 x x) =
      eOL2
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Sloop A -> SloopLTerm -> A
    evalB _ Sl (eL) = e Sl
    evalB _ Sl (opL x1 x2) =
      op Sl (evalB _ Sl x1)
        (evalB _ Sl x2)
    evalCl :
      (A : Set) ->
      Sloop A -> ClSloopClTerm A -> A
    evalCl _ Sl (sing x1) = x1
    evalCl _ Sl (eCl) = e Sl
    evalCl _ Sl (opCl x1 x2) =
      op Sl (evalCl _ Sl x1)
        (evalCl _ Sl x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Sloop A ->
      Vec A n -> OpSloopOLTerm n -> A
    evalOp _ n Sl vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Sl vars (eOL) = e Sl
    evalOp _ n Sl vars (opOL
                        x1
                        x2) =
      op Sl (evalOp _ n Sl vars x1)
        (evalOp _ n Sl vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Sloop A ->
      Vec A n ->
      OpSloopOL2Term2 n A -> A
    evalOpE _ n Sl vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Sl vars (sing2 x1) =
      x1
    evalOpE _ n Sl vars (eOL2) =
      e Sl
    evalOpE _ n Sl vars (opOL2
                         x1
                         x2) =
      op Sl (evalOpE _ n Sl vars x1)
        (evalOpE _ n Sl vars x2)
    inductionB :
      (P : SloopLTerm -> Set) ->
      P eL ->
      ((x1 : SloopLTerm)
       (x2 : SloopLTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : SloopLTerm) -> P x
    inductionB p pel popl (eL) = pel
    inductionB p pel popl (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p pel popl x1)
        (inductionB p pel popl x2)
    inductionCl :
      (A : Set)
      (P : ClSloopClTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P eCl ->
      ((x1 : ClSloopClTerm A)
       (x2 : ClSloopClTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClSloopClTerm A) -> P x
    inductionCl _ p psing pecl popcl (sing
                                      x1) = psing x1
    inductionCl _ p psing pecl popcl (eCl) =
      pecl
    inductionCl _ p psing pecl popcl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing pecl
           popcl
           x1)
        (inductionCl _ p psing pecl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpSloopOLTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P eOL ->
      ((x1 : OpSloopOLTerm n)
       (x2 : OpSloopOLTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpSloopOLTerm n) -> P x
    inductionOp _ p pv peol popol (v
                                   x1) = pv x1
    inductionOp _ p pv peol popol (eOL) =
      peol
    inductionOp _ p pv peol popol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv peol popol
           x1)
        (inductionOp _ p pv peol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpSloopOL2Term2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P eOL2 ->
      ((x1 : OpSloopOL2Term2 n A)
       (x2 : OpSloopOL2Term2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpSloopOL2Term2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x2)
    eL' : SloopLTerm
    eL' = eL
    opL' :
      SloopLTerm ->
      SloopLTerm -> SloopLTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      SloopLTerm -> Staged SloopLTerm
    stageB (eL) = Now eL
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    eCl' :
      (A : Set) -> ClSloopClTerm A
    eCl' _ = eCl
    opCl' :
      (A : Set) ->
      ClSloopClTerm A ->
      ClSloopClTerm A ->
      ClSloopClTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClSloopClTerm A ->
      Staged (ClSloopClTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (eCl) = Now eCl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    eOL' :
      (n : Nat) -> OpSloopOLTerm n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      OpSloopOLTerm n ->
      OpSloopOLTerm n ->
      OpSloopOLTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpSloopOLTerm n ->
      Staged (OpSloopOLTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (eOL) = Now eOL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    eOL2' :
      (n : Nat) (A : Set) ->
      OpSloopOL2Term2 n A
    eOL2' _ _ = eOL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpSloopOL2Term2 n A ->
      OpSloopOL2Term2 n A ->
      OpSloopOL2Term2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpSloopOL2Term2 n A ->
      Staged (OpSloopOL2Term2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record SloopTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        eT : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module Spindle where
    record Spindle
      (A : Set) : Set where
      constructor SpindleC
      field
        |> : A -> A -> A
        <| : A -> A -> A
        leftDistributive :
          (x : A) (y : A) (z : A) ->
          |> x (|> y z) ==
            |> (|> x y) (|> x z)
        rightDistributive :
          (x : A) (y : A) (z : A) ->
          <| (<| y z) x ==
            <| (<| y x) (<| z x)
        idempotent_|> :
          (x : A) -> |> x x == x
        idempotent_<| :
          (x : A) -> <| x x == x
    record SpindleSig
      (AS : Set) : Set where
      constructor SpindleSigSigC
      field
        |>S : AS -> AS -> AS
        <|S : AS -> AS -> AS
    record SpindleProd
      (AP : Set) : Set where
      constructor SpindleProdC
      field
        |>P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        <|P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          |>P xP (|>P yP zP) ==
            |>P (|>P xP yP) (|>P xP zP)
        rightDistributiveP :
          (xP : Prod AP AP)
          (yP : Prod AP AP)
          (zP : Prod AP AP) ->
          <|P (<|P yP zP) xP ==
            <|P (<|P yP xP) (<|P zP xP)
        idempotent_|>P :
          (xP : Prod AP AP) ->
          |>P xP xP == xP
        idempotent_<|P :
          (xP : Prod AP AP) ->
          <|P xP xP == xP
    record SpindleHom
      (A1 : Set) (A2 : Set)
      (Sp1 : Spindle A1)
      (Sp2 : Spindle A2) : Set where
      constructor SpindleHomC
      field
        hom : A1 -> A2
        pres-|> :
          (x1 : A1) (x2 : A1) ->
          hom (|> Sp1 x1 x2) ==
            |> Sp2 (hom x1) (hom x2)
        pres-<| :
          (x1 : A1) (x2 : A1) ->
          hom (<| Sp1 x1 x2) ==
            <| Sp2 (hom x1) (hom x2)
    record SpindleRelInterp
      (A1 : Set) (A2 : Set)
      (Sp1 : Spindle A1)
      (Sp2 : Spindle A2) : Set where
      constructor SpindleRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-|> :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (|> Sp1 x1 x2)
            (|> Sp2 y1 y2)
        interp-<| :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (<| Sp1 x1 x2)
            (<| Sp2 y1 y2)
    data SpindleTerm : Set where
      |>L :
        SpindleTerm ->
        SpindleTerm -> SpindleTerm
      <|L :
        SpindleTerm ->
        SpindleTerm -> SpindleTerm
    data ClSpindleTerm
      (A : Set) : Set where
      sing : A -> ClSpindleTerm A
      |>Cl :
        ClSpindleTerm A ->
        ClSpindleTerm A ->
        ClSpindleTerm A
      <|Cl :
        ClSpindleTerm A ->
        ClSpindleTerm A ->
        ClSpindleTerm A
    data OpSpindleTerm
      (n : Nat) : Set where
      v : Fin n -> OpSpindleTerm n
      |>OL :
        OpSpindleTerm n ->
        OpSpindleTerm n ->
        OpSpindleTerm n
      <|OL :
        OpSpindleTerm n ->
        OpSpindleTerm n ->
        OpSpindleTerm n
    data OpSpindleTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpSpindleTerm2 n A
      sing2 : A -> OpSpindleTerm2 n A
      |>OL2 :
        OpSpindleTerm2 n A ->
        OpSpindleTerm2 n A ->
        OpSpindleTerm2 n A
      <|OL2 :
        OpSpindleTerm2 n A ->
        OpSpindleTerm2 n A ->
        OpSpindleTerm2 n A
    simplifyB :
      SpindleTerm -> SpindleTerm
    simplifyB (|>L
               (|>L x y)
               (|>L x z)) = |>L x (|>L y z)
    simplifyB (<|L
               (<|L y x)
               (<|L z x)) = <|L (<|L y z) x
    simplifyB (|>L x x) = x
    simplifyB (<|L x x) = x
    simplifyB (|>L x1 x2) =
      |>L (simplifyB x1)
        (simplifyB x2)
    simplifyB (<|L x1 x2) =
      <|L (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClSpindleTerm A ->
      ClSpindleTerm A
    simplifyCl _ (|>Cl
                  (|>Cl x y)
                  (|>Cl x z)) = |>Cl x (|>Cl y z)
    simplifyCl _ (<|Cl
                  (<|Cl y x)
                  (<|Cl z x)) = <|Cl (<|Cl y z) x
    simplifyCl _ (|>Cl x x) = x
    simplifyCl _ (<|Cl x x) = x
    simplifyCl _ (|>Cl x1 x2) =
      |>Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (<|Cl x1 x2) =
      <|Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpSpindleTerm n ->
      OpSpindleTerm n
    simplifyOp _ (|>OL
                  (|>OL x y)
                  (|>OL x z)) = |>OL x (|>OL y z)
    simplifyOp _ (<|OL
                  (<|OL y x)
                  (<|OL z x)) = <|OL (<|OL y z) x
    simplifyOp _ (|>OL x x) = x
    simplifyOp _ (<|OL x x) = x
    simplifyOp _ (|>OL x1 x2) =
      |>OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (<|OL x1 x2) =
      <|OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpSpindleTerm2 n A ->
      OpSpindleTerm2 n A
    simplifyOpE _ _ (|>OL2
                     (|>OL2 x y)
                     (|>OL2 x z)) =
      |>OL2 x (|>OL2 y z)
    simplifyOpE _ _ (<|OL2
                     (<|OL2 y x)
                     (<|OL2 z x)) =
      <|OL2 (<|OL2 y z) x
    simplifyOpE _ _ (|>OL2 x x) = x
    simplifyOpE _ _ (<|OL2 x x) = x
    simplifyOpE _ _ (|>OL2 x1 x2) =
      |>OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (<|OL2 x1 x2) =
      <|OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Spindle A -> SpindleTerm -> A
    evalB _ Sp (|>L x1 x2) =
      |> Sp (evalB _ Sp x1)
        (evalB _ Sp x2)
    evalB _ Sp (<|L x1 x2) =
      <| Sp (evalB _ Sp x1)
        (evalB _ Sp x2)
    evalCl :
      (A : Set) ->
      Spindle A ->
      ClSpindleTerm A -> A
    evalCl _ Sp (sing x1) = x1
    evalCl _ Sp (|>Cl x1 x2) =
      |> Sp (evalCl _ Sp x1)
        (evalCl _ Sp x2)
    evalCl _ Sp (<|Cl x1 x2) =
      <| Sp (evalCl _ Sp x1)
        (evalCl _ Sp x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Spindle A ->
      Vec A n -> OpSpindleTerm n -> A
    evalOp _ n Sp vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Sp vars (|>OL
                        x1
                        x2) =
      |> Sp (evalOp _ n Sp vars x1)
        (evalOp _ n Sp vars x2)
    evalOp _ n Sp vars (<|OL
                        x1
                        x2) =
      <| Sp (evalOp _ n Sp vars x1)
        (evalOp _ n Sp vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Spindle A ->
      Vec A n ->
      OpSpindleTerm2 n A -> A
    evalOpE _ n Sp vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Sp vars (sing2 x1) =
      x1
    evalOpE _ n Sp vars (|>OL2
                         x1
                         x2) =
      |> Sp (evalOpE _ n Sp vars x1)
        (evalOpE _ n Sp vars x2)
    evalOpE _ n Sp vars (<|OL2
                         x1
                         x2) =
      <| Sp (evalOpE _ n Sp vars x1)
        (evalOpE _ n Sp vars x2)
    inductionB :
      (P : SpindleTerm -> Set) ->
      ((x1 : SpindleTerm)
       (x2 : SpindleTerm) ->
       P x1 ->
       P x2 -> P (|>L x1 x2)) ->
      ((x1 : SpindleTerm)
       (x2 : SpindleTerm) ->
       P x1 ->
       P x2 -> P (<|L x1 x2)) ->
      (x : SpindleTerm) -> P x
    inductionB p p|>l p<|l (|>L
                            x1
                            x2) =
      p|>l _ _
        (inductionB p p|>l p<|l x1)
        (inductionB p p|>l p<|l x2)
    inductionB p p|>l p<|l (<|L
                            x1
                            x2) =
      p<|l _ _
        (inductionB p p|>l p<|l x1)
        (inductionB p p|>l p<|l x2)
    inductionCl :
      (A : Set)
      (P : ClSpindleTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClSpindleTerm A)
       (x2 : ClSpindleTerm A) ->
       P x1 ->
       P x2 -> P (|>Cl x1 x2)) ->
      ((x1 : ClSpindleTerm A)
       (x2 : ClSpindleTerm A) ->
       P x1 ->
       P x2 -> P (<|Cl x1 x2)) ->
      (x : ClSpindleTerm A) -> P x
    inductionCl _ p psing p|>cl p<|cl (sing
                                       x1) = psing x1
    inductionCl _ p psing p|>cl p<|cl (|>Cl
                                       x1
                                       x2) =
      p|>cl _ _
        (inductionCl _ p psing p|>cl
           p<|cl
           x1)
        (inductionCl _ p psing p|>cl
           p<|cl
           x2)
    inductionCl _ p psing p|>cl p<|cl (<|Cl
                                       x1
                                       x2) =
      p<|cl _ _
        (inductionCl _ p psing p|>cl
           p<|cl
           x1)
        (inductionCl _ p psing p|>cl
           p<|cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpSpindleTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpSpindleTerm n)
       (x2 : OpSpindleTerm n) ->
       P x1 ->
       P x2 -> P (|>OL x1 x2)) ->
      ((x1 : OpSpindleTerm n)
       (x2 : OpSpindleTerm n) ->
       P x1 ->
       P x2 -> P (<|OL x1 x2)) ->
      (x : OpSpindleTerm n) -> P x
    inductionOp _ p pv p|>ol p<|ol (v
                                    x1) = pv x1
    inductionOp _ p pv p|>ol p<|ol (|>OL
                                    x1
                                    x2) =
      p|>ol _ _
        (inductionOp _ p pv p|>ol p<|ol
           x1)
        (inductionOp _ p pv p|>ol p<|ol
           x2)
    inductionOp _ p pv p|>ol p<|ol (<|OL
                                    x1
                                    x2) =
      p<|ol _ _
        (inductionOp _ p pv p|>ol p<|ol
           x1)
        (inductionOp _ p pv p|>ol p<|ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpSpindleTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpSpindleTerm2 n A)
       (x2 : OpSpindleTerm2 n A) ->
       P x1 ->
       P x2 -> P (|>OL2 x1 x2)) ->
      ((x1 : OpSpindleTerm2 n A)
       (x2 : OpSpindleTerm2 n A) ->
       P x1 ->
       P x2 -> P (<|OL2 x1 x2)) ->
      (x : OpSpindleTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (v2
                                                 x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (sing2
                                                 x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (|>OL2
                                                 x1
                                                 x2) =
      p|>ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p|>ol2 p<|ol2 (<|OL2
                                                 x1
                                                 x2) =
      p<|ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p|>ol2
           p<|ol2
           x2)
    |>L' :
      SpindleTerm ->
      SpindleTerm -> SpindleTerm
    |>L' x1 x2 = |>L x1 x2
    <|L' :
      SpindleTerm ->
      SpindleTerm -> SpindleTerm
    <|L' x1 x2 = <|L x1 x2
    stageB :
      SpindleTerm ->
      Staged SpindleTerm
    stageB (|>L x1 x2) =
      stage2 _ _ _ |>L'
        (codeLift2 _ _ _ |>L')
        (stageB x1)
        (stageB x2)
    stageB (<|L x1 x2) =
      stage2 _ _ _ <|L'
        (codeLift2 _ _ _ <|L')
        (stageB x1)
        (stageB x2)
    |>Cl' :
      (A : Set) ->
      ClSpindleTerm A ->
      ClSpindleTerm A ->
      ClSpindleTerm A
    |>Cl' _ x1 x2 = |>Cl x1 x2
    <|Cl' :
      (A : Set) ->
      ClSpindleTerm A ->
      ClSpindleTerm A ->
      ClSpindleTerm A
    <|Cl' _ x1 x2 = <|Cl x1 x2
    stageCl :
      (A : Set) ->
      ClSpindleTerm A ->
      Staged (ClSpindleTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (|>Cl x1 x2) =
      stage2 _ _ _ (|>Cl' _)
        (codeLift2 _ _ _ (|>Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (<|Cl x1 x2) =
      stage2 _ _ _ (<|Cl' _)
        (codeLift2 _ _ _ (<|Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    |>OL' :
      (n : Nat) ->
      OpSpindleTerm n ->
      OpSpindleTerm n ->
      OpSpindleTerm n
    |>OL' _ x1 x2 = |>OL x1 x2
    <|OL' :
      (n : Nat) ->
      OpSpindleTerm n ->
      OpSpindleTerm n ->
      OpSpindleTerm n
    <|OL' _ x1 x2 = <|OL x1 x2
    stageOp :
      (n : Nat) ->
      OpSpindleTerm n ->
      Staged (OpSpindleTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (|>OL x1 x2) =
      stage2 _ _ _ (|>OL' _)
        (codeLift2 _ _ _ (|>OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (<|OL x1 x2) =
      stage2 _ _ _ (<|OL' _)
        (codeLift2 _ _ _ (<|OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    |>OL2' :
      (n : Nat) (A : Set) ->
      OpSpindleTerm2 n A ->
      OpSpindleTerm2 n A ->
      OpSpindleTerm2 n A
    |>OL2' _ _ x1 x2 = |>OL2 x1 x2
    <|OL2' :
      (n : Nat) (A : Set) ->
      OpSpindleTerm2 n A ->
      OpSpindleTerm2 n A ->
      OpSpindleTerm2 n A
    <|OL2' _ _ x1 x2 = <|OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpSpindleTerm2 n A ->
      Staged (OpSpindleTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (|>OL2 x1 x2) =
      stage2 _ _ _ (|>OL2' _ _)
        (codeLift2 _ _ _ (|>OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (<|OL2 x1 x2) =
      stage2 _ _ _ (<|OL2' _ _)
        (codeLift2 _ _ _ (<|OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record SpindleTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        |>T : Repr A -> Repr A -> Repr A
        <|T : Repr A -> Repr A -> Repr A
  
  module Squag where
    record Squag
      (A : Set) : Set where
      constructor SquagC
      field
        op : A -> A -> A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
        antiAbsorbent :
          (x : A) (y : A) ->
          op x (op x y) == y
        idempotent_op :
          (x : A) -> op x x == x
    record SquagSig
      (AS : Set) : Set where
      constructor SquagSigSigC
      field
        opS : AS -> AS -> AS
    record SquagProd
      (AP : Set) : Set where
      constructor SquagProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
        antiAbsorbentP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (opP xP yP) == yP
        idempotent_opP :
          (xP : Prod AP AP) ->
          opP xP xP == xP
    record SquagHom
      (A1 : Set) (A2 : Set)
      (Sq1 : Squag A1)
      (Sq2 : Squag A2) : Set where
      constructor SquagHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Sq1 x1 x2) ==
            op Sq2 (hom x1) (hom x2)
    record SquagRelInterp
      (A1 : Set) (A2 : Set)
      (Sq1 : Squag A1)
      (Sq2 : Squag A2) : Set where
      constructor SquagRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Sq1 x1 x2)
            (op Sq2 y1 y2)
    data SquagTerm : Set where
      opL :
        SquagTerm ->
        SquagTerm -> SquagTerm
    data ClSquagTerm
      (A : Set) : Set where
      sing : A -> ClSquagTerm A
      opCl :
        ClSquagTerm A ->
        ClSquagTerm A -> ClSquagTerm A
    data OpSquagTerm
      (n : Nat) : Set where
      v : Fin n -> OpSquagTerm n
      opOL :
        OpSquagTerm n ->
        OpSquagTerm n -> OpSquagTerm n
    data OpSquagTerm2
      (n : Nat) (A : Set) : Set where
      v2 : Fin n -> OpSquagTerm2 n A
      sing2 : A -> OpSquagTerm2 n A
      opOL2 :
        OpSquagTerm2 n A ->
        OpSquagTerm2 n A ->
        OpSquagTerm2 n A
    simplifyB :
      SquagTerm -> SquagTerm
    simplifyB (opL x (opL x y)) = y
    simplifyB (opL x x) = x
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClSquagTerm A -> ClSquagTerm A
    simplifyCl _ (opCl
                  x
                  (opCl x y)) = y
    simplifyCl _ (opCl x x) = x
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpSquagTerm n -> OpSquagTerm n
    simplifyOp _ (opOL
                  x
                  (opOL x y)) = y
    simplifyOp _ (opOL x x) = x
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpSquagTerm2 n A ->
      OpSquagTerm2 n A
    simplifyOpE _ _ (opOL2
                     x
                     (opOL2 x y)) = y
    simplifyOpE _ _ (opOL2 x x) = x
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Squag A -> SquagTerm -> A
    evalB _ Sq (opL x1 x2) =
      op Sq (evalB _ Sq x1)
        (evalB _ Sq x2)
    evalCl :
      (A : Set) ->
      Squag A -> ClSquagTerm A -> A
    evalCl _ Sq (sing x1) = x1
    evalCl _ Sq (opCl x1 x2) =
      op Sq (evalCl _ Sq x1)
        (evalCl _ Sq x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Squag A ->
      Vec A n -> OpSquagTerm n -> A
    evalOp _ n Sq vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Sq vars (opOL
                        x1
                        x2) =
      op Sq (evalOp _ n Sq vars x1)
        (evalOp _ n Sq vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Squag A ->
      Vec A n -> OpSquagTerm2 n A -> A
    evalOpE _ n Sq vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Sq vars (sing2 x1) =
      x1
    evalOpE _ n Sq vars (opOL2
                         x1
                         x2) =
      op Sq (evalOpE _ n Sq vars x1)
        (evalOpE _ n Sq vars x2)
    inductionB :
      (P : SquagTerm -> Set) ->
      ((x1 : SquagTerm)
       (x2 : SquagTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : SquagTerm) -> P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClSquagTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClSquagTerm A)
       (x2 : ClSquagTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClSquagTerm A) -> P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpSquagTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpSquagTerm n)
       (x2 : OpSquagTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpSquagTerm n) -> P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpSquagTerm2 n A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpSquagTerm2 n A)
       (x2 : OpSquagTerm2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpSquagTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      SquagTerm ->
      SquagTerm -> SquagTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      SquagTerm -> Staged SquagTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClSquagTerm A ->
      ClSquagTerm A -> ClSquagTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClSquagTerm A ->
      Staged (ClSquagTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpSquagTerm n ->
      OpSquagTerm n -> OpSquagTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpSquagTerm n ->
      Staged (OpSquagTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpSquagTerm2 n A ->
      OpSquagTerm2 n A ->
      OpSquagTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpSquagTerm2 n A ->
      Staged (OpSquagTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record SquagTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module SteinerMagma where
    record SteinerMagma
      (A : Set) : Set where
      constructor SteinerMagmaC
      field
        op : A -> A -> A
        commutative_op :
          (x : A) (y : A) ->
          op x y == op y x
        antiAbsorbent :
          (x : A) (y : A) ->
          op x (op x y) == y
    record SteinerMagmaSig
      (AS : Set) : Set where
      constructor SteinerMagmaSigSigC
      field
        opS : AS -> AS -> AS
    record SteinerMagmaProd
      (AP : Set) : Set where
      constructor SteinerMagmaProdC
      field
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        commutative_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP yP == opP yP xP
        antiAbsorbentP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          opP xP (opP xP yP) == yP
    record SteinerMagmaHom
      (A1 : Set) (A2 : Set)
      (St1 : SteinerMagma A1)
      (St2 : SteinerMagma A2) :
      Set where
      constructor SteinerMagmaHomC
      field
        hom : A1 -> A2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op St1 x1 x2) ==
            op St2 (hom x1) (hom x2)
    record SteinerMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (St1 : SteinerMagma A1)
      (St2 : SteinerMagma A2) :
      Set where
      constructor SteinerMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op St1 x1 x2)
            (op St2 y1 y2)
    data SteinerMagmaTerm
      : Set where
      opL :
        SteinerMagmaTerm ->
        SteinerMagmaTerm ->
        SteinerMagmaTerm
    data ClSteinerMagmaTerm
      (A : Set) : Set where
      sing :
        A -> ClSteinerMagmaTerm A
      opCl :
        ClSteinerMagmaTerm A ->
        ClSteinerMagmaTerm A ->
        ClSteinerMagmaTerm A
    data OpSteinerMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpSteinerMagmaTerm n
      opOL :
        OpSteinerMagmaTerm n ->
        OpSteinerMagmaTerm n ->
        OpSteinerMagmaTerm n
    data OpSteinerMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpSteinerMagmaTerm2 n A
      sing2 :
        A -> OpSteinerMagmaTerm2 n A
      opOL2 :
        OpSteinerMagmaTerm2 n A ->
        OpSteinerMagmaTerm2 n A ->
        OpSteinerMagmaTerm2 n A
    simplifyB :
      SteinerMagmaTerm ->
      SteinerMagmaTerm
    simplifyB (opL x (opL x y)) = y
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClSteinerMagmaTerm A ->
      ClSteinerMagmaTerm A
    simplifyCl _ (opCl
                  x
                  (opCl x y)) = y
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpSteinerMagmaTerm n ->
      OpSteinerMagmaTerm n
    simplifyOp _ (opOL
                  x
                  (opOL x y)) = y
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpSteinerMagmaTerm2 n A ->
      OpSteinerMagmaTerm2 n A
    simplifyOpE _ _ (opOL2
                     x
                     (opOL2 x y)) = y
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      SteinerMagma A ->
      SteinerMagmaTerm -> A
    evalB _ St (opL x1 x2) =
      op St (evalB _ St x1)
        (evalB _ St x2)
    evalCl :
      (A : Set) ->
      SteinerMagma A ->
      ClSteinerMagmaTerm A -> A
    evalCl _ St (sing x1) = x1
    evalCl _ St (opCl x1 x2) =
      op St (evalCl _ St x1)
        (evalCl _ St x2)
    evalOp :
      (A : Set) (n : Nat) ->
      SteinerMagma A ->
      Vec A n ->
      OpSteinerMagmaTerm n -> A
    evalOp _ n St vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n St vars (opOL
                        x1
                        x2) =
      op St (evalOp _ n St vars x1)
        (evalOp _ n St vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      SteinerMagma A ->
      Vec A n ->
      OpSteinerMagmaTerm2 n A -> A
    evalOpE _ n St vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n St vars (sing2 x1) =
      x1
    evalOpE _ n St vars (opOL2
                         x1
                         x2) =
      op St (evalOpE _ n St vars x1)
        (evalOpE _ n St vars x2)
    inductionB :
      (P : SteinerMagmaTerm -> Set) ->
      ((x1 : SteinerMagmaTerm)
       (x2 : SteinerMagmaTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : SteinerMagmaTerm) -> P x
    inductionB p popl (opL x1 x2) =
      popl _ _ (inductionB p popl x1)
        (inductionB p popl x2)
    inductionCl :
      (A : Set)
      (P : ClSteinerMagmaTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClSteinerMagmaTerm A)
       (x2 : ClSteinerMagmaTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClSteinerMagmaTerm A) ->
      P x
    inductionCl _ p psing popcl (sing
                                 x1) = psing x1
    inductionCl _ p psing popcl (opCl
                                 x1
                                 x2) =
      popcl _ _
        (inductionCl _ p psing popcl x1)
        (inductionCl _ p psing popcl x2)
    inductionOp :
      (n : Nat)
      (P : OpSteinerMagmaTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpSteinerMagmaTerm n)
       (x2 : OpSteinerMagmaTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpSteinerMagmaTerm n) ->
      P x
    inductionOp _ p pv popol (v
                              x1) = pv x1
    inductionOp _ p pv popol (opOL
                              x1
                              x2) =
      popol _ _
        (inductionOp _ p pv popol x1)
        (inductionOp _ p pv popol x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpSteinerMagmaTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpSteinerMagmaTerm2 n A)
       (x2 : OpSteinerMagmaTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpSteinerMagmaTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 popol2 (v2
                                          x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (sing2
                                          x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 popol2 (opOL2
                                          x1
                                          x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           popol2
           x2)
    opL' :
      SteinerMagmaTerm ->
      SteinerMagmaTerm ->
      SteinerMagmaTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      SteinerMagmaTerm ->
      Staged SteinerMagmaTerm
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    opCl' :
      (A : Set) ->
      ClSteinerMagmaTerm A ->
      ClSteinerMagmaTerm A ->
      ClSteinerMagmaTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClSteinerMagmaTerm A ->
      Staged (ClSteinerMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    opOL' :
      (n : Nat) ->
      OpSteinerMagmaTerm n ->
      OpSteinerMagmaTerm n ->
      OpSteinerMagmaTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpSteinerMagmaTerm n ->
      Staged (OpSteinerMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    opOL2' :
      (n : Nat) (A : Set) ->
      OpSteinerMagmaTerm2 n A ->
      OpSteinerMagmaTerm2 n A ->
      OpSteinerMagmaTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpSteinerMagmaTerm2 n A ->
      Staged (OpSteinerMagmaTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record SteinerMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        opT : Repr A -> Repr A -> Repr A
  
  module TwoPointed where
    record TwoPointed
      (A : Set) : Set where
      constructor TwoPointedC
      field
        e1 : A
        e2 : A
    record TwoPointedSig
      (AS : Set) : Set where
      constructor TwoPointedSigSigC
      field
        e1S : AS
        e2S : AS
    record TwoPointedProd
      (AP : Set) : Set where
      constructor TwoPointedProdC
      field
        e1P : Prod AP AP
        e2P : Prod AP AP
    record TwoPointedHom
      (A1 : Set) (A2 : Set)
      (Tw1 : TwoPointed A1)
      (Tw2 : TwoPointed A2) :
      Set where
      constructor TwoPointedHomC
      field
        hom : A1 -> A2
        pres-e1 : hom (e1 Tw1) == e1 Tw2
        pres-e2 : hom (e2 Tw1) == e2 Tw2
    record TwoPointedRelInterp
      (A1 : Set) (A2 : Set)
      (Tw1 : TwoPointed A1)
      (Tw2 : TwoPointed A2) :
      Set where
      constructor TwoPointedRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e1 :
          interp (e1 Tw1) (e1 Tw2)
        interp-e2 :
          interp (e2 Tw1) (e2 Tw2)
    data TwoPointedTerm : Set where
      e1L : TwoPointedTerm
      e2L : TwoPointedTerm
    data ClTwoPointedTerm
      (A : Set) : Set where
      sing : A -> ClTwoPointedTerm A
      e1Cl : ClTwoPointedTerm A
      e2Cl : ClTwoPointedTerm A
    data OpTwoPointedTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpTwoPointedTerm n
      e1OL : OpTwoPointedTerm n
      e2OL : OpTwoPointedTerm n
    data OpTwoPointedTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpTwoPointedTerm2 n A
      sing2 :
        A -> OpTwoPointedTerm2 n A
      e1OL2 : OpTwoPointedTerm2 n A
      e2OL2 : OpTwoPointedTerm2 n A
    simplifyB :
      TwoPointedTerm -> TwoPointedTerm
    simplifyB (e1L) = e1L
    simplifyB (e2L) = e2L
    simplifyCl :
      (A : Set) ->
      ClTwoPointedTerm A ->
      ClTwoPointedTerm A
    simplifyCl _ (e1Cl) = e1Cl
    simplifyCl _ (e2Cl) = e2Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpTwoPointedTerm n ->
      OpTwoPointedTerm n
    simplifyOp _ (e1OL) = e1OL
    simplifyOp _ (e2OL) = e2OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpTwoPointedTerm2 n A ->
      OpTwoPointedTerm2 n A
    simplifyOpE _ _ (e1OL2) = e1OL2
    simplifyOpE _ _ (e2OL2) = e2OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      TwoPointed A ->
      TwoPointedTerm -> A
    evalB _ Tw (e1L) = e1 Tw
    evalB _ Tw (e2L) = e2 Tw
    evalCl :
      (A : Set) ->
      TwoPointed A ->
      ClTwoPointedTerm A -> A
    evalCl _ Tw (sing x1) = x1
    evalCl _ Tw (e1Cl) = e1 Tw
    evalCl _ Tw (e2Cl) = e2 Tw
    evalOp :
      (A : Set) (n : Nat) ->
      TwoPointed A ->
      Vec A n ->
      OpTwoPointedTerm n -> A
    evalOp _ n Tw vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Tw vars (e1OL) =
      e1 Tw
    evalOp _ n Tw vars (e2OL) =
      e2 Tw
    evalOpE :
      (A : Set) (n : Nat) ->
      TwoPointed A ->
      Vec A n ->
      OpTwoPointedTerm2 n A -> A
    evalOpE _ n Tw vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Tw vars (sing2 x1) =
      x1
    evalOpE _ n Tw vars (e1OL2) =
      e1 Tw
    evalOpE _ n Tw vars (e2OL2) =
      e2 Tw
    inductionB :
      (P : TwoPointedTerm -> Set) ->
      P e1L ->
      P e2L ->
      (x : TwoPointedTerm) -> P x
    inductionB p pe1l pe2l (e1L) =
      pe1l
    inductionB p pe1l pe2l (e2L) =
      pe2l
    inductionCl :
      (A : Set)
      (P : ClTwoPointedTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P e1Cl ->
      P e2Cl ->
      (x : ClTwoPointedTerm A) -> P x
    inductionCl _ p psing pe1cl pe2cl (sing
                                       x1) = psing x1
    inductionCl _ p psing pe1cl pe2cl (e1Cl) =
      pe1cl
    inductionCl _ p psing pe1cl pe2cl (e2Cl) =
      pe2cl
    inductionOp :
      (n : Nat)
      (P : OpTwoPointedTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P e1OL ->
      P e2OL ->
      (x : OpTwoPointedTerm n) -> P x
    inductionOp _ p pv pe1ol pe2ol (v
                                    x1) = pv x1
    inductionOp _ p pv pe1ol pe2ol (e1OL) =
      pe1ol
    inductionOp _ p pv pe1ol pe2ol (e2OL) =
      pe2ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpTwoPointedTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P e1OL2 ->
      P e2OL2 ->
      (x : OpTwoPointedTerm2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 pe1ol2 pe2ol2 (v2
                                                 x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pe1ol2 pe2ol2 (sing2
                                                 x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pe1ol2 pe2ol2 (e1OL2) =
      pe1ol2
    inductionOpE _ _ p pv2 psing2 pe1ol2 pe2ol2 (e2OL2) =
      pe2ol2
    e1L' : TwoPointedTerm
    e1L' = e1L
    e2L' : TwoPointedTerm
    e2L' = e2L
    stageB :
      TwoPointedTerm ->
      Staged TwoPointedTerm
    stageB (e1L) = Now e1L
    stageB (e2L) = Now e2L
    e1Cl' :
      (A : Set) -> ClTwoPointedTerm A
    e1Cl' _ = e1Cl
    e2Cl' :
      (A : Set) -> ClTwoPointedTerm A
    e2Cl' _ = e2Cl
    stageCl :
      (A : Set) ->
      ClTwoPointedTerm A ->
      Staged (ClTwoPointedTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (e1Cl) = Now e1Cl
    stageCl _ (e2Cl) = Now e2Cl
    e1OL' :
      (n : Nat) -> OpTwoPointedTerm n
    e1OL' _ = e1OL
    e2OL' :
      (n : Nat) -> OpTwoPointedTerm n
    e2OL' _ = e2OL
    stageOp :
      (n : Nat) ->
      OpTwoPointedTerm n ->
      Staged (OpTwoPointedTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (e1OL) = Now e1OL
    stageOp _ (e2OL) = Now e2OL
    e1OL2' :
      (n : Nat) (A : Set) ->
      OpTwoPointedTerm2 n A
    e1OL2' _ _ = e1OL2
    e2OL2' :
      (n : Nat) (A : Set) ->
      OpTwoPointedTerm2 n A
    e2OL2' _ _ = e2OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpTwoPointedTerm2 n A ->
      Staged (OpTwoPointedTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (e1OL2) = Now e1OL2
    stageOpE _ _ (e2OL2) = Now e2OL2
    record TwoPointedTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        e1T : Repr A
        e2T : Repr A
  
  module TwoPointed01 where
    record TwoPointed01
      (A : Set) : Set where
      constructor TwoPointed01C
      field
        e1 : A
        e2 : A
    record TwoPointed01Sig
      (AS : Set) : Set where
      constructor TwoPointed01SigSigC
      field
        e1S : AS
        e2S : AS
    record TwoPointed01Prod
      (AP : Set) : Set where
      constructor TwoPointed01ProdC
      field
        e1P : Prod AP AP
        e2P : Prod AP AP
    record TwoPointed01Hom
      (A1 : Set) (A2 : Set)
      (Tw1 : TwoPointed01 A1)
      (Tw2 : TwoPointed01 A2) :
      Set where
      constructor TwoPointed01HomC
      field
        hom : A1 -> A2
        pres-e1 : hom (e1 Tw1) == e1 Tw2
        pres-e2 : hom (e2 Tw1) == e2 Tw2
    record TwoPointed01RelInterp
      (A1 : Set) (A2 : Set)
      (Tw1 : TwoPointed01 A1)
      (Tw2 : TwoPointed01 A2) :
      Set where
      constructor TwoPointed01RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e1 :
          interp (e1 Tw1) (e1 Tw2)
        interp-e2 :
          interp (e2 Tw1) (e2 Tw2)
    data TwoPointed01Term
      : Set where
      e1L : TwoPointed01Term
      e2L : TwoPointed01Term
    data ClTwoPointed01Term
      (A : Set) : Set where
      sing :
        A -> ClTwoPointed01Term A
      e1Cl : ClTwoPointed01Term A
      e2Cl : ClTwoPointed01Term A
    data OpTwoPointed01Term
      (n : Nat) : Set where
      v :
        Fin n -> OpTwoPointed01Term n
      e1OL : OpTwoPointed01Term n
      e2OL : OpTwoPointed01Term n
    data OpTwoPointed01Term2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpTwoPointed01Term2 n A
      sing2 :
        A -> OpTwoPointed01Term2 n A
      e1OL2 : OpTwoPointed01Term2 n A
      e2OL2 : OpTwoPointed01Term2 n A
    simplifyB :
      TwoPointed01Term ->
      TwoPointed01Term
    simplifyB (e1L) = e1L
    simplifyB (e2L) = e2L
    simplifyCl :
      (A : Set) ->
      ClTwoPointed01Term A ->
      ClTwoPointed01Term A
    simplifyCl _ (e1Cl) = e1Cl
    simplifyCl _ (e2Cl) = e2Cl
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpTwoPointed01Term n ->
      OpTwoPointed01Term n
    simplifyOp _ (e1OL) = e1OL
    simplifyOp _ (e2OL) = e2OL
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpTwoPointed01Term2 n A ->
      OpTwoPointed01Term2 n A
    simplifyOpE _ _ (e1OL2) = e1OL2
    simplifyOpE _ _ (e2OL2) = e2OL2
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      TwoPointed01 A ->
      TwoPointed01Term -> A
    evalB _ Tw (e1L) = e1 Tw
    evalB _ Tw (e2L) = e2 Tw
    evalCl :
      (A : Set) ->
      TwoPointed01 A ->
      ClTwoPointed01Term A -> A
    evalCl _ Tw (sing x1) = x1
    evalCl _ Tw (e1Cl) = e1 Tw
    evalCl _ Tw (e2Cl) = e2 Tw
    evalOp :
      (A : Set) (n : Nat) ->
      TwoPointed01 A ->
      Vec A n ->
      OpTwoPointed01Term n -> A
    evalOp _ n Tw vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Tw vars (e1OL) =
      e1 Tw
    evalOp _ n Tw vars (e2OL) =
      e2 Tw
    evalOpE :
      (A : Set) (n : Nat) ->
      TwoPointed01 A ->
      Vec A n ->
      OpTwoPointed01Term2 n A -> A
    evalOpE _ n Tw vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Tw vars (sing2 x1) =
      x1
    evalOpE _ n Tw vars (e1OL2) =
      e1 Tw
    evalOpE _ n Tw vars (e2OL2) =
      e2 Tw
    inductionB :
      (P : TwoPointed01Term -> Set) ->
      P e1L ->
      P e2L ->
      (x : TwoPointed01Term) -> P x
    inductionB p pe1l pe2l (e1L) =
      pe1l
    inductionB p pe1l pe2l (e2L) =
      pe2l
    inductionCl :
      (A : Set)
      (P : ClTwoPointed01Term A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P e1Cl ->
      P e2Cl ->
      (x : ClTwoPointed01Term A) ->
      P x
    inductionCl _ p psing pe1cl pe2cl (sing
                                       x1) = psing x1
    inductionCl _ p psing pe1cl pe2cl (e1Cl) =
      pe1cl
    inductionCl _ p psing pe1cl pe2cl (e2Cl) =
      pe2cl
    inductionOp :
      (n : Nat)
      (P : OpTwoPointed01Term n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P e1OL ->
      P e2OL ->
      (x : OpTwoPointed01Term n) ->
      P x
    inductionOp _ p pv pe1ol pe2ol (v
                                    x1) = pv x1
    inductionOp _ p pv pe1ol pe2ol (e1OL) =
      pe1ol
    inductionOp _ p pv pe1ol pe2ol (e2OL) =
      pe2ol
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpTwoPointed01Term2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P e1OL2 ->
      P e2OL2 ->
      (x : OpTwoPointed01Term2 n A) ->
      P x
    inductionOpE _ _ p pv2 psing2 pe1ol2 pe2ol2 (v2
                                                 x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pe1ol2 pe2ol2 (sing2
                                                 x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pe1ol2 pe2ol2 (e1OL2) =
      pe1ol2
    inductionOpE _ _ p pv2 psing2 pe1ol2 pe2ol2 (e2OL2) =
      pe2ol2
    e1L' : TwoPointed01Term
    e1L' = e1L
    e2L' : TwoPointed01Term
    e2L' = e2L
    stageB :
      TwoPointed01Term ->
      Staged TwoPointed01Term
    stageB (e1L) = Now e1L
    stageB (e2L) = Now e2L
    e1Cl' :
      (A : Set) ->
      ClTwoPointed01Term A
    e1Cl' _ = e1Cl
    e2Cl' :
      (A : Set) ->
      ClTwoPointed01Term A
    e2Cl' _ = e2Cl
    stageCl :
      (A : Set) ->
      ClTwoPointed01Term A ->
      Staged (ClTwoPointed01Term A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (e1Cl) = Now e1Cl
    stageCl _ (e2Cl) = Now e2Cl
    e1OL' :
      (n : Nat) ->
      OpTwoPointed01Term n
    e1OL' _ = e1OL
    e2OL' :
      (n : Nat) ->
      OpTwoPointed01Term n
    e2OL' _ = e2OL
    stageOp :
      (n : Nat) ->
      OpTwoPointed01Term n ->
      Staged (OpTwoPointed01Term n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (e1OL) = Now e1OL
    stageOp _ (e2OL) = Now e2OL
    e1OL2' :
      (n : Nat) (A : Set) ->
      OpTwoPointed01Term2 n A
    e1OL2' _ _ = e1OL2
    e2OL2' :
      (n : Nat) (A : Set) ->
      OpTwoPointed01Term2 n A
    e2OL2' _ _ = e2OL2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpTwoPointed01Term2 n A ->
      Staged (OpTwoPointed01Term2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (e1OL2) = Now e1OL2
    stageOpE _ _ (e2OL2) = Now e2OL2
    record TwoPointed01Tagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        e1T : Repr A
        e2T : Repr A
  
  module UnaryAntiDistribution where
    record UnaryAntiDistribution
      (A : Set) : Set where
      constructor UnaryAntiDistributionC
      field
        prim : A -> A
        op : A -> A -> A
        antidis_prim_op :
          (x : A) (y : A) ->
          prim (op x y) ==
            op (prim y) (prim x)
    record UnaryAntiDistributionSig
      (AS : Set) : Set where
      constructor UnaryAntiDistributionSigSigC
      field
        primS : AS -> AS
        opS : AS -> AS -> AS
    record UnaryAntiDistributionProd
      (AP : Set) : Set where
      constructor UnaryAntiDistributionProdC
      field
        primP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        antidis_prim_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (opP xP yP) ==
            opP (primP yP) (primP xP)
    record UnaryAntiDistributionHom
      (A1 : Set) (A2 : Set)
      (Un1 : UnaryAntiDistribution A1)
      (Un2 : UnaryAntiDistribution
         A2) : Set where
      constructor UnaryAntiDistributionHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Un1 x1) ==
            prim Un2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Un1 x1 x2) ==
            op Un2 (hom x1) (hom x2)
    record UnaryAntiDistributionRelInterp
      (A1 : Set) (A2 : Set)
      (Un1 : UnaryAntiDistribution A1)
      (Un2 : UnaryAntiDistribution
         A2) : Set where
      constructor UnaryAntiDistributionRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Un1 x1)
            (prim Un2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Un1 x1 x2)
            (op Un2 y1 y2)
    data UnaryAntiDistributionTerm
      : Set where
      primL :
        UnaryAntiDistributionTerm ->
        UnaryAntiDistributionTerm
      opL :
        UnaryAntiDistributionTerm ->
        UnaryAntiDistributionTerm ->
        UnaryAntiDistributionTerm
    data ClUnaryAntiDistributionTerm
      (A : Set) : Set where
      sing :
        A ->
        ClUnaryAntiDistributionTerm A
      primCl :
        ClUnaryAntiDistributionTerm A ->
        ClUnaryAntiDistributionTerm A
      opCl :
        ClUnaryAntiDistributionTerm A ->
        ClUnaryAntiDistributionTerm A ->
        ClUnaryAntiDistributionTerm A
    data OpUnaryAntiDistributionTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpUnaryAntiDistributionTerm n
      primOL :
        OpUnaryAntiDistributionTerm n ->
        OpUnaryAntiDistributionTerm n
      opOL :
        OpUnaryAntiDistributionTerm n ->
        OpUnaryAntiDistributionTerm n ->
        OpUnaryAntiDistributionTerm n
    data OpUnaryAntiDistributionTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpUnaryAntiDistributionTerm2 n A
      sing2 :
        A ->
        OpUnaryAntiDistributionTerm2 n A
      primOL2 :
        OpUnaryAntiDistributionTerm2 n
          A ->
        OpUnaryAntiDistributionTerm2 n A
      opOL2 :
        OpUnaryAntiDistributionTerm2 n
          A ->
        OpUnaryAntiDistributionTerm2 n
          A ->
        OpUnaryAntiDistributionTerm2 n A
    simplifyB :
      UnaryAntiDistributionTerm ->
      UnaryAntiDistributionTerm
    simplifyB (opL
               (primL y)
               (primL x)) = primL (opL x y)
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClUnaryAntiDistributionTerm A ->
      ClUnaryAntiDistributionTerm A
    simplifyCl _ (opCl
                  (primCl y)
                  (primCl x)) = primCl (opCl x y)
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpUnaryAntiDistributionTerm n ->
      OpUnaryAntiDistributionTerm n
    simplifyOp _ (opOL
                  (primOL y)
                  (primOL x)) = primOL (opOL x y)
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpUnaryAntiDistributionTerm2 n
        A ->
      OpUnaryAntiDistributionTerm2 n A
    simplifyOpE _ _ (opOL2
                     (primOL2 y)
                     (primOL2 x)) =
      primOL2 (opOL2 x y)
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      UnaryAntiDistribution A ->
      UnaryAntiDistributionTerm -> A
    evalB _ Un (primL x1) =
      prim Un (evalB _ Un x1)
    evalB _ Un (opL x1 x2) =
      op Un (evalB _ Un x1)
        (evalB _ Un x2)
    evalCl :
      (A : Set) ->
      UnaryAntiDistribution A ->
      ClUnaryAntiDistributionTerm A ->
      A
    evalCl _ Un (sing x1) = x1
    evalCl _ Un (primCl x1) =
      prim Un (evalCl _ Un x1)
    evalCl _ Un (opCl x1 x2) =
      op Un (evalCl _ Un x1)
        (evalCl _ Un x2)
    evalOp :
      (A : Set) (n : Nat) ->
      UnaryAntiDistribution A ->
      Vec A n ->
      OpUnaryAntiDistributionTerm n ->
      A
    evalOp _ n Un vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Un vars (primOL x1) =
      prim Un (evalOp _ n Un vars x1)
    evalOp _ n Un vars (opOL
                        x1
                        x2) =
      op Un (evalOp _ n Un vars x1)
        (evalOp _ n Un vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      UnaryAntiDistribution A ->
      Vec A n ->
      OpUnaryAntiDistributionTerm2 n
        A -> A
    evalOpE _ n Un vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Un vars (sing2 x1) =
      x1
    evalOpE _ n Un vars (primOL2
                         x1) =
      prim Un (evalOpE _ n Un vars x1)
    evalOpE _ n Un vars (opOL2
                         x1
                         x2) =
      op Un (evalOpE _ n Un vars x1)
        (evalOpE _ n Un vars x2)
    inductionB :
      (P : UnaryAntiDistributionTerm ->
           Set) ->
      ((x1 : UnaryAntiDistributionTerm) ->
       P x1 -> P (primL x1)) ->
      ((x1 : UnaryAntiDistributionTerm)
       (x2 : UnaryAntiDistributionTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : UnaryAntiDistributionTerm) ->
      P x
    inductionB p ppriml popl (primL
                              x1) =
      ppriml _
        (inductionB p ppriml popl x1)
    inductionB p ppriml popl (opL
                              x1
                              x2) =
      popl _ _
        (inductionB p ppriml popl x1)
        (inductionB p ppriml popl x2)
    inductionCl :
      (A : Set)
      (P : ClUnaryAntiDistributionTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClUnaryAntiDistributionTerm
          A) -> P x1 -> P (primCl x1)) ->
      ((x1 : ClUnaryAntiDistributionTerm
          A)
       (x2 : ClUnaryAntiDistributionTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClUnaryAntiDistributionTerm
         A) -> P x
    inductionCl _ p psing pprimcl popcl (sing
                                         x1) = psing x1
    inductionCl _ p psing pprimcl popcl (primCl
                                         x1) =
      pprimcl _
        (inductionCl _ p psing pprimcl
           popcl
           x1)
    inductionCl _ p psing pprimcl popcl (opCl
                                         x1
                                         x2) =
      popcl _ _
        (inductionCl _ p psing pprimcl
           popcl
           x1)
        (inductionCl _ p psing pprimcl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpUnaryAntiDistributionTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpUnaryAntiDistributionTerm
          n) -> P x1 -> P (primOL x1)) ->
      ((x1 : OpUnaryAntiDistributionTerm
          n)
       (x2 : OpUnaryAntiDistributionTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpUnaryAntiDistributionTerm
         n) -> P x
    inductionOp _ p pv pprimol popol (v
                                      x1) = pv x1
    inductionOp _ p pv pprimol popol (primOL
                                      x1) =
      pprimol _
        (inductionOp _ p pv pprimol
           popol
           x1)
    inductionOp _ p pv pprimol popol (opOL
                                      x1
                                      x2) =
      popol _ _
        (inductionOp _ p pv pprimol
           popol
           x1)
        (inductionOp _ p pv pprimol
           popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpUnaryAntiDistributionTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpUnaryAntiDistributionTerm2
          n
          A) -> P x1 -> P (primOL2 x1)) ->
      ((x1 : OpUnaryAntiDistributionTerm2
          n
          A)
       (x2 : OpUnaryAntiDistributionTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpUnaryAntiDistributionTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 pprimol2 popol2 (v2
                                                   x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 popol2 (sing2
                                                   x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 popol2 (primOL2
                                                   x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           popol2
           x1)
    inductionOpE _ _ p pv2 psing2 pprimol2 popol2 (opOL2
                                                   x1
                                                   x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           popol2
           x2)
    primL' :
      UnaryAntiDistributionTerm ->
      UnaryAntiDistributionTerm
    primL' x1 = primL x1
    opL' :
      UnaryAntiDistributionTerm ->
      UnaryAntiDistributionTerm ->
      UnaryAntiDistributionTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      UnaryAntiDistributionTerm ->
      Staged UnaryAntiDistributionTerm
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    primCl' :
      (A : Set) ->
      ClUnaryAntiDistributionTerm A ->
      ClUnaryAntiDistributionTerm A
    primCl' _ x1 = primCl x1
    opCl' :
      (A : Set) ->
      ClUnaryAntiDistributionTerm A ->
      ClUnaryAntiDistributionTerm A ->
      ClUnaryAntiDistributionTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClUnaryAntiDistributionTerm A ->
      Staged
        (ClUnaryAntiDistributionTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    primOL' :
      (n : Nat) ->
      OpUnaryAntiDistributionTerm n ->
      OpUnaryAntiDistributionTerm n
    primOL' _ x1 = primOL x1
    opOL' :
      (n : Nat) ->
      OpUnaryAntiDistributionTerm n ->
      OpUnaryAntiDistributionTerm n ->
      OpUnaryAntiDistributionTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpUnaryAntiDistributionTerm n ->
      Staged
        (OpUnaryAntiDistributionTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    primOL2' :
      (n : Nat) (A : Set) ->
      OpUnaryAntiDistributionTerm2 n
        A ->
      OpUnaryAntiDistributionTerm2 n A
    primOL2' _ _ x1 = primOL2 x1
    opOL2' :
      (n : Nat) (A : Set) ->
      OpUnaryAntiDistributionTerm2 n
        A ->
      OpUnaryAntiDistributionTerm2 n
        A ->
      OpUnaryAntiDistributionTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpUnaryAntiDistributionTerm2 n
        A ->
      Staged
        (OpUnaryAntiDistributionTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record UnaryAntiDistributionTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        primT : Repr A -> Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module UnaryDistributes where
    record UnaryDistributes
      (A : Set) : Set where
      constructor UnaryDistributesC
      field
        prim : A -> A
        op : A -> A -> A
        distribute_prim_op :
          (x : A) (y : A) ->
          prim (op x y) ==
            op (prim x) (prim y)
    record UnaryDistributesSig
      (AS : Set) : Set where
      constructor UnaryDistributesSigSigC
      field
        primS : AS -> AS
        opS : AS -> AS -> AS
    record UnaryDistributesProd
      (AP : Set) : Set where
      constructor UnaryDistributesProdC
      field
        primP : Prod AP AP -> Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        distribute_prim_opP :
          (xP : Prod AP AP)
          (yP : Prod AP AP) ->
          primP (opP xP yP) ==
            opP (primP xP) (primP yP)
    record UnaryDistributesHom
      (A1 : Set) (A2 : Set)
      (Un1 : UnaryDistributes A1)
      (Un2 : UnaryDistributes A2) :
      Set where
      constructor UnaryDistributesHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Un1 x1) ==
            prim Un2 (hom x1)
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Un1 x1 x2) ==
            op Un2 (hom x1) (hom x2)
    record UnaryDistributesRelInterp
      (A1 : Set) (A2 : Set)
      (Un1 : UnaryDistributes A1)
      (Un2 : UnaryDistributes A2) :
      Set where
      constructor UnaryDistributesRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Un1 x1)
            (prim Un2 y1)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Un1 x1 x2)
            (op Un2 y1 y2)
    data UnaryDistributesTerm
      : Set where
      primL :
        UnaryDistributesTerm ->
        UnaryDistributesTerm
      opL :
        UnaryDistributesTerm ->
        UnaryDistributesTerm ->
        UnaryDistributesTerm
    data ClUnaryDistributesTerm
      (A : Set) : Set where
      sing :
        A -> ClUnaryDistributesTerm A
      primCl :
        ClUnaryDistributesTerm A ->
        ClUnaryDistributesTerm A
      opCl :
        ClUnaryDistributesTerm A ->
        ClUnaryDistributesTerm A ->
        ClUnaryDistributesTerm A
    data OpUnaryDistributesTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpUnaryDistributesTerm n
      primOL :
        OpUnaryDistributesTerm n ->
        OpUnaryDistributesTerm n
      opOL :
        OpUnaryDistributesTerm n ->
        OpUnaryDistributesTerm n ->
        OpUnaryDistributesTerm n
    data OpUnaryDistributesTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpUnaryDistributesTerm2 n A
      sing2 :
        A -> OpUnaryDistributesTerm2 n A
      primOL2 :
        OpUnaryDistributesTerm2 n A ->
        OpUnaryDistributesTerm2 n A
      opOL2 :
        OpUnaryDistributesTerm2 n A ->
        OpUnaryDistributesTerm2 n A ->
        OpUnaryDistributesTerm2 n A
    simplifyB :
      UnaryDistributesTerm ->
      UnaryDistributesTerm
    simplifyB (opL
               (primL x)
               (primL y)) = primL (opL x y)
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClUnaryDistributesTerm A ->
      ClUnaryDistributesTerm A
    simplifyCl _ (opCl
                  (primCl x)
                  (primCl y)) = primCl (opCl x y)
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpUnaryDistributesTerm n ->
      OpUnaryDistributesTerm n
    simplifyOp _ (opOL
                  (primOL x)
                  (primOL y)) = primOL (opOL x y)
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpUnaryDistributesTerm2 n A ->
      OpUnaryDistributesTerm2 n A
    simplifyOpE _ _ (opOL2
                     (primOL2 x)
                     (primOL2 y)) =
      primOL2 (opOL2 x y)
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      UnaryDistributes A ->
      UnaryDistributesTerm -> A
    evalB _ Un (primL x1) =
      prim Un (evalB _ Un x1)
    evalB _ Un (opL x1 x2) =
      op Un (evalB _ Un x1)
        (evalB _ Un x2)
    evalCl :
      (A : Set) ->
      UnaryDistributes A ->
      ClUnaryDistributesTerm A -> A
    evalCl _ Un (sing x1) = x1
    evalCl _ Un (primCl x1) =
      prim Un (evalCl _ Un x1)
    evalCl _ Un (opCl x1 x2) =
      op Un (evalCl _ Un x1)
        (evalCl _ Un x2)
    evalOp :
      (A : Set) (n : Nat) ->
      UnaryDistributes A ->
      Vec A n ->
      OpUnaryDistributesTerm n -> A
    evalOp _ n Un vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Un vars (primOL x1) =
      prim Un (evalOp _ n Un vars x1)
    evalOp _ n Un vars (opOL
                        x1
                        x2) =
      op Un (evalOp _ n Un vars x1)
        (evalOp _ n Un vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      UnaryDistributes A ->
      Vec A n ->
      OpUnaryDistributesTerm2 n A -> A
    evalOpE _ n Un vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Un vars (sing2 x1) =
      x1
    evalOpE _ n Un vars (primOL2
                         x1) =
      prim Un (evalOpE _ n Un vars x1)
    evalOpE _ n Un vars (opOL2
                         x1
                         x2) =
      op Un (evalOpE _ n Un vars x1)
        (evalOpE _ n Un vars x2)
    inductionB :
      (P : UnaryDistributesTerm ->
           Set) ->
      ((x1 : UnaryDistributesTerm) ->
       P x1 -> P (primL x1)) ->
      ((x1 : UnaryDistributesTerm)
       (x2 : UnaryDistributesTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : UnaryDistributesTerm) ->
      P x
    inductionB p ppriml popl (primL
                              x1) =
      ppriml _
        (inductionB p ppriml popl x1)
    inductionB p ppriml popl (opL
                              x1
                              x2) =
      popl _ _
        (inductionB p ppriml popl x1)
        (inductionB p ppriml popl x2)
    inductionCl :
      (A : Set)
      (P : ClUnaryDistributesTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClUnaryDistributesTerm
          A) -> P x1 -> P (primCl x1)) ->
      ((x1 : ClUnaryDistributesTerm A)
       (x2 : ClUnaryDistributesTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClUnaryDistributesTerm
         A) -> P x
    inductionCl _ p psing pprimcl popcl (sing
                                         x1) = psing x1
    inductionCl _ p psing pprimcl popcl (primCl
                                         x1) =
      pprimcl _
        (inductionCl _ p psing pprimcl
           popcl
           x1)
    inductionCl _ p psing pprimcl popcl (opCl
                                         x1
                                         x2) =
      popcl _ _
        (inductionCl _ p psing pprimcl
           popcl
           x1)
        (inductionCl _ p psing pprimcl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpUnaryDistributesTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpUnaryDistributesTerm
          n) -> P x1 -> P (primOL x1)) ->
      ((x1 : OpUnaryDistributesTerm n)
       (x2 : OpUnaryDistributesTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpUnaryDistributesTerm
         n) -> P x
    inductionOp _ p pv pprimol popol (v
                                      x1) = pv x1
    inductionOp _ p pv pprimol popol (primOL
                                      x1) =
      pprimol _
        (inductionOp _ p pv pprimol
           popol
           x1)
    inductionOp _ p pv pprimol popol (opOL
                                      x1
                                      x2) =
      popol _ _
        (inductionOp _ p pv pprimol
           popol
           x1)
        (inductionOp _ p pv pprimol
           popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpUnaryDistributesTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpUnaryDistributesTerm2 n
          A) -> P x1 -> P (primOL2 x1)) ->
      ((x1 : OpUnaryDistributesTerm2 n
          A)
       (x2 : OpUnaryDistributesTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpUnaryDistributesTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 pprimol2 popol2 (v2
                                                   x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 popol2 (sing2
                                                   x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 popol2 (primOL2
                                                   x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           popol2
           x1)
    inductionOpE _ _ p pv2 psing2 pprimol2 popol2 (opOL2
                                                   x1
                                                   x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           popol2
           x2)
    primL' :
      UnaryDistributesTerm ->
      UnaryDistributesTerm
    primL' x1 = primL x1
    opL' :
      UnaryDistributesTerm ->
      UnaryDistributesTerm ->
      UnaryDistributesTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      UnaryDistributesTerm ->
      Staged UnaryDistributesTerm
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    primCl' :
      (A : Set) ->
      ClUnaryDistributesTerm A ->
      ClUnaryDistributesTerm A
    primCl' _ x1 = primCl x1
    opCl' :
      (A : Set) ->
      ClUnaryDistributesTerm A ->
      ClUnaryDistributesTerm A ->
      ClUnaryDistributesTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClUnaryDistributesTerm A ->
      Staged
        (ClUnaryDistributesTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    primOL' :
      (n : Nat) ->
      OpUnaryDistributesTerm n ->
      OpUnaryDistributesTerm n
    primOL' _ x1 = primOL x1
    opOL' :
      (n : Nat) ->
      OpUnaryDistributesTerm n ->
      OpUnaryDistributesTerm n ->
      OpUnaryDistributesTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpUnaryDistributesTerm n ->
      Staged
        (OpUnaryDistributesTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    primOL2' :
      (n : Nat) (A : Set) ->
      OpUnaryDistributesTerm2 n A ->
      OpUnaryDistributesTerm2 n A
    primOL2' _ _ x1 = primOL2 x1
    opOL2' :
      (n : Nat) (A : Set) ->
      OpUnaryDistributesTerm2 n A ->
      OpUnaryDistributesTerm2 n A ->
      OpUnaryDistributesTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpUnaryDistributesTerm2 n A ->
      Staged
        (OpUnaryDistributesTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record UnaryDistributesTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        primT : Repr A -> Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module UnaryOperation where
    record UnaryOperation
      (A : Set) : Set where
      constructor UnaryOperationC
      field
        prim : A -> A
    record UnaryOperationSig
      (AS : Set) : Set where
      constructor UnaryOperationSigSigC
      field
        primS : AS -> AS
    record UnaryOperationProd
      (AP : Set) : Set where
      constructor UnaryOperationProdC
      field
        primP : Prod AP AP -> Prod AP AP
    record UnaryOperationHom
      (A1 : Set) (A2 : Set)
      (Un1 : UnaryOperation A1)
      (Un2 : UnaryOperation A2) :
      Set where
      constructor UnaryOperationHomC
      field
        hom : A1 -> A2
        pres-prim :
          (x1 : A1) ->
          hom (prim Un1 x1) ==
            prim Un2 (hom x1)
    record UnaryOperationRelInterp
      (A1 : Set) (A2 : Set)
      (Un1 : UnaryOperation A1)
      (Un2 : UnaryOperation A2) :
      Set where
      constructor UnaryOperationRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-prim :
          (x1 : A1) (y1 : A2) ->
          interp x1 y1 ->
          interp (prim Un1 x1)
            (prim Un2 y1)
    data UnaryOperationTerm
      : Set where
      primL :
        UnaryOperationTerm ->
        UnaryOperationTerm
    data ClUnaryOperationTerm
      (A : Set) : Set where
      sing :
        A -> ClUnaryOperationTerm A
      primCl :
        ClUnaryOperationTerm A ->
        ClUnaryOperationTerm A
    data OpUnaryOperationTerm
      (n : Nat) : Set where
      v :
        Fin n -> OpUnaryOperationTerm n
      primOL :
        OpUnaryOperationTerm n ->
        OpUnaryOperationTerm n
    data OpUnaryOperationTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpUnaryOperationTerm2 n A
      sing2 :
        A -> OpUnaryOperationTerm2 n A
      primOL2 :
        OpUnaryOperationTerm2 n A ->
        OpUnaryOperationTerm2 n A
    simplifyB :
      UnaryOperationTerm ->
      UnaryOperationTerm
    simplifyB (primL x1) =
      primL (simplifyB x1)
    simplifyCl :
      (A : Set) ->
      ClUnaryOperationTerm A ->
      ClUnaryOperationTerm A
    simplifyCl _ (primCl x1) =
      primCl (simplifyCl _ x1)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpUnaryOperationTerm n ->
      OpUnaryOperationTerm n
    simplifyOp _ (primOL x1) =
      primOL (simplifyOp _ x1)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpUnaryOperationTerm2 n A ->
      OpUnaryOperationTerm2 n A
    simplifyOpE _ _ (primOL2 x1) =
      primOL2 (simplifyOpE _ _ x1)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      UnaryOperation A ->
      UnaryOperationTerm -> A
    evalB _ Un (primL x1) =
      prim Un (evalB _ Un x1)
    evalCl :
      (A : Set) ->
      UnaryOperation A ->
      ClUnaryOperationTerm A -> A
    evalCl _ Un (sing x1) = x1
    evalCl _ Un (primCl x1) =
      prim Un (evalCl _ Un x1)
    evalOp :
      (A : Set) (n : Nat) ->
      UnaryOperation A ->
      Vec A n ->
      OpUnaryOperationTerm n -> A
    evalOp _ n Un vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Un vars (primOL x1) =
      prim Un (evalOp _ n Un vars x1)
    evalOpE :
      (A : Set) (n : Nat) ->
      UnaryOperation A ->
      Vec A n ->
      OpUnaryOperationTerm2 n A -> A
    evalOpE _ n Un vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Un vars (sing2 x1) =
      x1
    evalOpE _ n Un vars (primOL2
                         x1) =
      prim Un (evalOpE _ n Un vars x1)
    inductionB :
      (P : UnaryOperationTerm ->
           Set) ->
      ((x1 : UnaryOperationTerm) ->
       P x1 -> P (primL x1)) ->
      (x : UnaryOperationTerm) -> P x
    inductionB p ppriml (primL x1) =
      ppriml _
        (inductionB p ppriml x1)
    inductionCl :
      (A : Set)
      (P : ClUnaryOperationTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      ((x1 : ClUnaryOperationTerm
          A) -> P x1 -> P (primCl x1)) ->
      (x : ClUnaryOperationTerm A) ->
      P x
    inductionCl _ p psing pprimcl (sing
                                   x1) = psing x1
    inductionCl _ p psing pprimcl (primCl
                                   x1) =
      pprimcl _
        (inductionCl _ p psing pprimcl
           x1)
    inductionOp :
      (n : Nat)
      (P : OpUnaryOperationTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      ((x1 : OpUnaryOperationTerm
          n) -> P x1 -> P (primOL x1)) ->
      (x : OpUnaryOperationTerm n) ->
      P x
    inductionOp _ p pv pprimol (v
                                x1) = pv x1
    inductionOp _ p pv pprimol (primOL
                                x1) =
      pprimol _
        (inductionOp _ p pv pprimol x1)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpUnaryOperationTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      ((x1 : OpUnaryOperationTerm2 n
          A) -> P x1 -> P (primOL2 x1)) ->
      (x : OpUnaryOperationTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 pprimol2 (v2
                                            x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 (sing2
                                            x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 pprimol2 (primOL2
                                            x1) =
      pprimol2 _
        (inductionOpE _ _ p pv2 psing2
           pprimol2
           x1)
    primL' :
      UnaryOperationTerm ->
      UnaryOperationTerm
    primL' x1 = primL x1
    stageB :
      UnaryOperationTerm ->
      Staged UnaryOperationTerm
    stageB (primL x1) =
      stage1 _ _ primL'
        (codeLift1 _ _ primL')
        (stageB x1)
    primCl' :
      (A : Set) ->
      ClUnaryOperationTerm A ->
      ClUnaryOperationTerm A
    primCl' _ x1 = primCl x1
    stageCl :
      (A : Set) ->
      ClUnaryOperationTerm A ->
      Staged (ClUnaryOperationTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (primCl x1) =
      stage1 _ _ (primCl' _)
        (codeLift1 _ _ (primCl' _))
        (stageCl _ x1)
    primOL' :
      (n : Nat) ->
      OpUnaryOperationTerm n ->
      OpUnaryOperationTerm n
    primOL' _ x1 = primOL x1
    stageOp :
      (n : Nat) ->
      OpUnaryOperationTerm n ->
      Staged (OpUnaryOperationTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (primOL x1) =
      stage1 _ _ (primOL' _)
        (codeLift1 _ _ (primOL' _))
        (stageOp _ x1)
    primOL2' :
      (n : Nat) (A : Set) ->
      OpUnaryOperationTerm2 n A ->
      OpUnaryOperationTerm2 n A
    primOL2' _ _ x1 = primOL2 x1
    stageOpE :
      (n : Nat) (A : Set) ->
      OpUnaryOperationTerm2 n A ->
      Staged
        (OpUnaryOperationTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (primOL2 x1) =
      stage1 _ _ (primOL2' _ _)
        (codeLift1 _ _ (primOL2' _ _))
        (stageOpE _ _ x1)
    record UnaryOperationTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        primT : Repr A -> Repr A
  
  module UnipotentPointedMagma where
    record UnipotentPointedMagma
      (A : Set) : Set where
      constructor UnipotentPointedMagmaC
      field
        e : A
        op : A -> A -> A
        unipotence :
          (x : A) -> op x x == e
    record UnipotentPointedMagmaSig
      (AS : Set) : Set where
      constructor UnipotentPointedMagmaSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record UnipotentPointedMagmaProd
      (AP : Set) : Set where
      constructor UnipotentPointedMagmaProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        unipotenceP :
          (xP : Prod AP AP) ->
          opP xP xP == eP
    record UnipotentPointedMagmaHom
      (A1 : Set) (A2 : Set)
      (Un1 : UnipotentPointedMagma A1)
      (Un2 : UnipotentPointedMagma
         A2) : Set where
      constructor UnipotentPointedMagmaHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Un1) == e Un2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Un1 x1 x2) ==
            op Un2 (hom x1) (hom x2)
    record UnipotentPointedMagmaRelInterp
      (A1 : Set) (A2 : Set)
      (Un1 : UnipotentPointedMagma A1)
      (Un2 : UnipotentPointedMagma
         A2) : Set where
      constructor UnipotentPointedMagmaRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Un1) (e Un2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Un1 x1 x2)
            (op Un2 y1 y2)
    data UnipotentPointedMagmaTerm
      : Set where
      eL : UnipotentPointedMagmaTerm
      opL :
        UnipotentPointedMagmaTerm ->
        UnipotentPointedMagmaTerm ->
        UnipotentPointedMagmaTerm
    data ClUnipotentPointedMagmaTerm
      (A : Set) : Set where
      sing :
        A ->
        ClUnipotentPointedMagmaTerm A
      eCl :
        ClUnipotentPointedMagmaTerm A
      opCl :
        ClUnipotentPointedMagmaTerm A ->
        ClUnipotentPointedMagmaTerm A ->
        ClUnipotentPointedMagmaTerm A
    data OpUnipotentPointedMagmaTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpUnipotentPointedMagmaTerm n
      eOL :
        OpUnipotentPointedMagmaTerm n
      opOL :
        OpUnipotentPointedMagmaTerm n ->
        OpUnipotentPointedMagmaTerm n ->
        OpUnipotentPointedMagmaTerm n
    data OpUnipotentPointedMagmaTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpUnipotentPointedMagmaTerm2 n A
      sing2 :
        A ->
        OpUnipotentPointedMagmaTerm2 n A
      eOL2 :
        OpUnipotentPointedMagmaTerm2 n A
      opOL2 :
        OpUnipotentPointedMagmaTerm2 n
          A ->
        OpUnipotentPointedMagmaTerm2 n
          A ->
        OpUnipotentPointedMagmaTerm2 n A
    simplifyB :
      UnipotentPointedMagmaTerm ->
      UnipotentPointedMagmaTerm
    simplifyB (opL x x) = eL
    simplifyB (eL) = eL
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClUnipotentPointedMagmaTerm A ->
      ClUnipotentPointedMagmaTerm A
    simplifyCl _ (opCl x x) = eCl
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpUnipotentPointedMagmaTerm n ->
      OpUnipotentPointedMagmaTerm n
    simplifyOp _ (opOL x x) = eOL
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpUnipotentPointedMagmaTerm2 n
        A ->
      OpUnipotentPointedMagmaTerm2 n A
    simplifyOpE _ _ (opOL2 x x) =
      eOL2
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      UnipotentPointedMagma A ->
      UnipotentPointedMagmaTerm -> A
    evalB _ Un (eL) = e Un
    evalB _ Un (opL x1 x2) =
      op Un (evalB _ Un x1)
        (evalB _ Un x2)
    evalCl :
      (A : Set) ->
      UnipotentPointedMagma A ->
      ClUnipotentPointedMagmaTerm A ->
      A
    evalCl _ Un (sing x1) = x1
    evalCl _ Un (eCl) = e Un
    evalCl _ Un (opCl x1 x2) =
      op Un (evalCl _ Un x1)
        (evalCl _ Un x2)
    evalOp :
      (A : Set) (n : Nat) ->
      UnipotentPointedMagma A ->
      Vec A n ->
      OpUnipotentPointedMagmaTerm n ->
      A
    evalOp _ n Un vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Un vars (eOL) = e Un
    evalOp _ n Un vars (opOL
                        x1
                        x2) =
      op Un (evalOp _ n Un vars x1)
        (evalOp _ n Un vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      UnipotentPointedMagma A ->
      Vec A n ->
      OpUnipotentPointedMagmaTerm2 n
        A -> A
    evalOpE _ n Un vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Un vars (sing2 x1) =
      x1
    evalOpE _ n Un vars (eOL2) =
      e Un
    evalOpE _ n Un vars (opOL2
                         x1
                         x2) =
      op Un (evalOpE _ n Un vars x1)
        (evalOpE _ n Un vars x2)
    inductionB :
      (P : UnipotentPointedMagmaTerm ->
           Set) ->
      P eL ->
      ((x1 : UnipotentPointedMagmaTerm)
       (x2 : UnipotentPointedMagmaTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : UnipotentPointedMagmaTerm) ->
      P x
    inductionB p pel popl (eL) = pel
    inductionB p pel popl (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p pel popl x1)
        (inductionB p pel popl x2)
    inductionCl :
      (A : Set)
      (P : ClUnipotentPointedMagmaTerm
             A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P eCl ->
      ((x1 : ClUnipotentPointedMagmaTerm
          A)
       (x2 : ClUnipotentPointedMagmaTerm
          A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClUnipotentPointedMagmaTerm
         A) -> P x
    inductionCl _ p psing pecl popcl (sing
                                      x1) = psing x1
    inductionCl _ p psing pecl popcl (eCl) =
      pecl
    inductionCl _ p psing pecl popcl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing pecl
           popcl
           x1)
        (inductionCl _ p psing pecl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpUnipotentPointedMagmaTerm
             n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P eOL ->
      ((x1 : OpUnipotentPointedMagmaTerm
          n)
       (x2 : OpUnipotentPointedMagmaTerm
          n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpUnipotentPointedMagmaTerm
         n) -> P x
    inductionOp _ p pv peol popol (v
                                   x1) = pv x1
    inductionOp _ p pv peol popol (eOL) =
      peol
    inductionOp _ p pv peol popol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv peol popol
           x1)
        (inductionOp _ p pv peol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpUnipotentPointedMagmaTerm2
             n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P eOL2 ->
      ((x1 : OpUnipotentPointedMagmaTerm2
          n
          A)
       (x2 : OpUnipotentPointedMagmaTerm2
          n
          A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpUnipotentPointedMagmaTerm2
         n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x2)
    eL' : UnipotentPointedMagmaTerm
    eL' = eL
    opL' :
      UnipotentPointedMagmaTerm ->
      UnipotentPointedMagmaTerm ->
      UnipotentPointedMagmaTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      UnipotentPointedMagmaTerm ->
      Staged UnipotentPointedMagmaTerm
    stageB (eL) = Now eL
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    eCl' :
      (A : Set) ->
      ClUnipotentPointedMagmaTerm A
    eCl' _ = eCl
    opCl' :
      (A : Set) ->
      ClUnipotentPointedMagmaTerm A ->
      ClUnipotentPointedMagmaTerm A ->
      ClUnipotentPointedMagmaTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClUnipotentPointedMagmaTerm A ->
      Staged
        (ClUnipotentPointedMagmaTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (eCl) = Now eCl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    eOL' :
      (n : Nat) ->
      OpUnipotentPointedMagmaTerm n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      OpUnipotentPointedMagmaTerm n ->
      OpUnipotentPointedMagmaTerm n ->
      OpUnipotentPointedMagmaTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpUnipotentPointedMagmaTerm n ->
      Staged
        (OpUnipotentPointedMagmaTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (eOL) = Now eOL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    eOL2' :
      (n : Nat) (A : Set) ->
      OpUnipotentPointedMagmaTerm2 n A
    eOL2' _ _ = eOL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpUnipotentPointedMagmaTerm2 n
        A ->
      OpUnipotentPointedMagmaTerm2 n
        A ->
      OpUnipotentPointedMagmaTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpUnipotentPointedMagmaTerm2 n
        A ->
      Staged
        (OpUnipotentPointedMagmaTerm2 n
           A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record UnipotentPointedMagmaTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        eT : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module Unital where
    record Unital
      (A : Set) : Set where
      constructor UnitalC
      field
        e : A
        op : A -> A -> A
        lunit_e : (x : A) -> op e x == x
        runit_e : (x : A) -> op x e == x
    record UnitalSig
      (AS : Set) : Set where
      constructor UnitalSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record UnitalProd
      (AP : Set) : Set where
      constructor UnitalProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        lunit_eP :
          (xP : Prod AP AP) ->
          opP eP xP == xP
        runit_eP :
          (xP : Prod AP AP) ->
          opP xP eP == xP
    record UnitalHom
      (A1 : Set) (A2 : Set)
      (Un1 : Unital A1)
      (Un2 : Unital A2) : Set where
      constructor UnitalHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Un1) == e Un2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Un1 x1 x2) ==
            op Un2 (hom x1) (hom x2)
    record UnitalRelInterp
      (A1 : Set) (A2 : Set)
      (Un1 : Unital A1)
      (Un2 : Unital A2) : Set where
      constructor UnitalRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Un1) (e Un2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Un1 x1 x2)
            (op Un2 y1 y2)
    data UnitalTerm : Set where
      eL : UnitalTerm
      opL :
        UnitalTerm ->
        UnitalTerm -> UnitalTerm
    data ClUnitalTerm
      (A : Set) : Set where
      sing : A -> ClUnitalTerm A
      eCl : ClUnitalTerm A
      opCl :
        ClUnitalTerm A ->
        ClUnitalTerm A -> ClUnitalTerm A
    data OpUnitalTerm
      (n : Nat) : Set where
      v : Fin n -> OpUnitalTerm n
      eOL : OpUnitalTerm n
      opOL :
        OpUnitalTerm n ->
        OpUnitalTerm n -> OpUnitalTerm n
    data OpUnitalTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpUnitalTerm2 n A
      sing2 : A -> OpUnitalTerm2 n A
      eOL2 : OpUnitalTerm2 n A
      opOL2 :
        OpUnitalTerm2 n A ->
        OpUnitalTerm2 n A ->
        OpUnitalTerm2 n A
    simplifyB :
      UnitalTerm -> UnitalTerm
    simplifyB (opL (eL) x) = x
    simplifyB (opL x (eL)) = x
    simplifyB (eL) = eL
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClUnitalTerm A -> ClUnitalTerm A
    simplifyCl _ (opCl (eCl) x) = x
    simplifyCl _ (opCl x (eCl)) = x
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpUnitalTerm n -> OpUnitalTerm n
    simplifyOp _ (opOL (eOL) x) = x
    simplifyOp _ (opOL x (eOL)) = x
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpUnitalTerm2 n A ->
      OpUnitalTerm2 n A
    simplifyOpE _ _ (opOL2
                     (eOL2)
                     x) = x
    simplifyOpE _ _ (opOL2
                     x
                     (eOL2)) = x
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Unital A -> UnitalTerm -> A
    evalB _ Un (eL) = e Un
    evalB _ Un (opL x1 x2) =
      op Un (evalB _ Un x1)
        (evalB _ Un x2)
    evalCl :
      (A : Set) ->
      Unital A -> ClUnitalTerm A -> A
    evalCl _ Un (sing x1) = x1
    evalCl _ Un (eCl) = e Un
    evalCl _ Un (opCl x1 x2) =
      op Un (evalCl _ Un x1)
        (evalCl _ Un x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Unital A ->
      Vec A n -> OpUnitalTerm n -> A
    evalOp _ n Un vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Un vars (eOL) = e Un
    evalOp _ n Un vars (opOL
                        x1
                        x2) =
      op Un (evalOp _ n Un vars x1)
        (evalOp _ n Un vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Unital A ->
      Vec A n ->
      OpUnitalTerm2 n A -> A
    evalOpE _ n Un vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Un vars (sing2 x1) =
      x1
    evalOpE _ n Un vars (eOL2) =
      e Un
    evalOpE _ n Un vars (opOL2
                         x1
                         x2) =
      op Un (evalOpE _ n Un vars x1)
        (evalOpE _ n Un vars x2)
    inductionB :
      (P : UnitalTerm -> Set) ->
      P eL ->
      ((x1 : UnitalTerm)
       (x2 : UnitalTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : UnitalTerm) -> P x
    inductionB p pel popl (eL) = pel
    inductionB p pel popl (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p pel popl x1)
        (inductionB p pel popl x2)
    inductionCl :
      (A : Set)
      (P : ClUnitalTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P eCl ->
      ((x1 : ClUnitalTerm A)
       (x2 : ClUnitalTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClUnitalTerm A) -> P x
    inductionCl _ p psing pecl popcl (sing
                                      x1) = psing x1
    inductionCl _ p psing pecl popcl (eCl) =
      pecl
    inductionCl _ p psing pecl popcl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing pecl
           popcl
           x1)
        (inductionCl _ p psing pecl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpUnitalTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P eOL ->
      ((x1 : OpUnitalTerm n)
       (x2 : OpUnitalTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpUnitalTerm n) -> P x
    inductionOp _ p pv peol popol (v
                                   x1) = pv x1
    inductionOp _ p pv peol popol (eOL) =
      peol
    inductionOp _ p pv peol popol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv peol popol
           x1)
        (inductionOp _ p pv peol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpUnitalTerm2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P eOL2 ->
      ((x1 : OpUnitalTerm2 n A)
       (x2 : OpUnitalTerm2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpUnitalTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x2)
    eL' : UnitalTerm
    eL' = eL
    opL' :
      UnitalTerm ->
      UnitalTerm -> UnitalTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      UnitalTerm -> Staged UnitalTerm
    stageB (eL) = Now eL
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    eCl' :
      (A : Set) -> ClUnitalTerm A
    eCl' _ = eCl
    opCl' :
      (A : Set) ->
      ClUnitalTerm A ->
      ClUnitalTerm A -> ClUnitalTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClUnitalTerm A ->
      Staged (ClUnitalTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (eCl) = Now eCl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    eOL' :
      (n : Nat) -> OpUnitalTerm n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      OpUnitalTerm n ->
      OpUnitalTerm n -> OpUnitalTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpUnitalTerm n ->
      Staged (OpUnitalTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (eOL) = Now eOL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    eOL2' :
      (n : Nat) (A : Set) ->
      OpUnitalTerm2 n A
    eOL2' _ _ = eOL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpUnitalTerm2 n A ->
      OpUnitalTerm2 n A ->
      OpUnitalTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpUnitalTerm2 n A ->
      Staged (OpUnitalTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record UnitalTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        eT : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module Zero where
    record Zero
      (A : Set) : Set where
      constructor ZeroC
      field
        e : A
        op : A -> A -> A
        leftZero_op_e :
          (x : A) -> op e x == e
        rightZero_op_e :
          (x : A) -> op x e == e
    record ZeroSig
      (AS : Set) : Set where
      constructor ZeroSigSigC
      field
        eS : AS
        opS : AS -> AS -> AS
    record ZeroProd
      (AP : Set) : Set where
      constructor ZeroProdC
      field
        eP : Prod AP AP
        opP :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftZero_op_eP :
          (xP : Prod AP AP) ->
          opP eP xP == eP
        rightZero_op_eP :
          (xP : Prod AP AP) ->
          opP xP eP == eP
    record ZeroHom
      (A1 : Set) (A2 : Set)
      (Ze1 : Zero A1)
      (Ze2 : Zero A2) : Set where
      constructor ZeroHomC
      field
        hom : A1 -> A2
        pres-e : hom (e Ze1) == e Ze2
        pres-op :
          (x1 : A1) (x2 : A1) ->
          hom (op Ze1 x1 x2) ==
            op Ze2 (hom x1) (hom x2)
    record ZeroRelInterp
      (A1 : Set) (A2 : Set)
      (Ze1 : Zero A1)
      (Ze2 : Zero A2) : Set where
      constructor ZeroRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-e :
          interp (e Ze1) (e Ze2)
        interp-op :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (op Ze1 x1 x2)
            (op Ze2 y1 y2)
    data ZeroTerm : Set where
      eL : ZeroTerm
      opL :
        ZeroTerm -> ZeroTerm -> ZeroTerm
    data ClZeroTerm
      (A : Set) : Set where
      sing : A -> ClZeroTerm A
      eCl : ClZeroTerm A
      opCl :
        ClZeroTerm A ->
        ClZeroTerm A -> ClZeroTerm A
    data OpZeroTerm
      (n : Nat) : Set where
      v : Fin n -> OpZeroTerm n
      eOL : OpZeroTerm n
      opOL :
        OpZeroTerm n ->
        OpZeroTerm n -> OpZeroTerm n
    data OpZeroTerm2
      (n : Nat) (A : Set) : Set where
      v2 : Fin n -> OpZeroTerm2 n A
      sing2 : A -> OpZeroTerm2 n A
      eOL2 : OpZeroTerm2 n A
      opOL2 :
        OpZeroTerm2 n A ->
        OpZeroTerm2 n A ->
        OpZeroTerm2 n A
    simplifyB : ZeroTerm -> ZeroTerm
    simplifyB (opL (eL) x) = eL
    simplifyB (opL x (eL)) = eL
    simplifyB (eL) = eL
    simplifyB (opL x1 x2) =
      opL (simplifyB x1)
        (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClZeroTerm A -> ClZeroTerm A
    simplifyCl _ (opCl (eCl) x) =
      eCl
    simplifyCl _ (opCl x (eCl)) =
      eCl
    simplifyCl _ (eCl) = eCl
    simplifyCl _ (opCl x1 x2) =
      opCl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpZeroTerm n -> OpZeroTerm n
    simplifyOp _ (opOL (eOL) x) =
      eOL
    simplifyOp _ (opOL x (eOL)) =
      eOL
    simplifyOp _ (eOL) = eOL
    simplifyOp _ (opOL x1 x2) =
      opOL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpZeroTerm2 n A ->
      OpZeroTerm2 n A
    simplifyOpE _ _ (opOL2
                     (eOL2)
                     x) = eOL2
    simplifyOpE _ _ (opOL2
                     x
                     (eOL2)) = eOL2
    simplifyOpE _ _ (eOL2) = eOL2
    simplifyOpE _ _ (opOL2 x1 x2) =
      opOL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Zero A -> ZeroTerm -> A
    evalB _ Ze (eL) = e Ze
    evalB _ Ze (opL x1 x2) =
      op Ze (evalB _ Ze x1)
        (evalB _ Ze x2)
    evalCl :
      (A : Set) ->
      Zero A -> ClZeroTerm A -> A
    evalCl _ Ze (sing x1) = x1
    evalCl _ Ze (eCl) = e Ze
    evalCl _ Ze (opCl x1 x2) =
      op Ze (evalCl _ Ze x1)
        (evalCl _ Ze x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Zero A ->
      Vec A n -> OpZeroTerm n -> A
    evalOp _ n Ze vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ze vars (eOL) = e Ze
    evalOp _ n Ze vars (opOL
                        x1
                        x2) =
      op Ze (evalOp _ n Ze vars x1)
        (evalOp _ n Ze vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Zero A ->
      Vec A n -> OpZeroTerm2 n A -> A
    evalOpE _ n Ze vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ze vars (sing2 x1) =
      x1
    evalOpE _ n Ze vars (eOL2) =
      e Ze
    evalOpE _ n Ze vars (opOL2
                         x1
                         x2) =
      op Ze (evalOpE _ n Ze vars x1)
        (evalOpE _ n Ze vars x2)
    inductionB :
      (P : ZeroTerm -> Set) ->
      P eL ->
      ((x1 : ZeroTerm)
       (x2 : ZeroTerm) ->
       P x1 ->
       P x2 -> P (opL x1 x2)) ->
      (x : ZeroTerm) -> P x
    inductionB p pel popl (eL) = pel
    inductionB p pel popl (opL
                           x1
                           x2) =
      popl _ _
        (inductionB p pel popl x1)
        (inductionB p pel popl x2)
    inductionCl :
      (A : Set)
      (P : ClZeroTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P eCl ->
      ((x1 : ClZeroTerm A)
       (x2 : ClZeroTerm A) ->
       P x1 ->
       P x2 -> P (opCl x1 x2)) ->
      (x : ClZeroTerm A) -> P x
    inductionCl _ p psing pecl popcl (sing
                                      x1) = psing x1
    inductionCl _ p psing pecl popcl (eCl) =
      pecl
    inductionCl _ p psing pecl popcl (opCl
                                      x1
                                      x2) =
      popcl _ _
        (inductionCl _ p psing pecl
           popcl
           x1)
        (inductionCl _ p psing pecl
           popcl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpZeroTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P eOL ->
      ((x1 : OpZeroTerm n)
       (x2 : OpZeroTerm n) ->
       P x1 ->
       P x2 -> P (opOL x1 x2)) ->
      (x : OpZeroTerm n) -> P x
    inductionOp _ p pv peol popol (v
                                   x1) = pv x1
    inductionOp _ p pv peol popol (eOL) =
      peol
    inductionOp _ p pv peol popol (opOL
                                   x1
                                   x2) =
      popol _ _
        (inductionOp _ p pv peol popol
           x1)
        (inductionOp _ p pv peol popol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpZeroTerm2 n A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P eOL2 ->
      ((x1 : OpZeroTerm2 n A)
       (x2 : OpZeroTerm2 n A) ->
       P x1 ->
       P x2 -> P (opOL2 x1 x2)) ->
      (x : OpZeroTerm2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (v2
                                                x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (sing2
                                                x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (eOL2) =
      peol2
    inductionOpE _ _ p pv2 psing2 peol2 popol2 (opOL2
                                                x1
                                                x2) =
      popol2 _ _
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           peol2
           popol2
           x2)
    eL' : ZeroTerm
    eL' = eL
    opL' :
      ZeroTerm -> ZeroTerm -> ZeroTerm
    opL' x1 x2 = opL x1 x2
    stageB :
      ZeroTerm -> Staged ZeroTerm
    stageB (eL) = Now eL
    stageB (opL x1 x2) =
      stage2 _ _ _ opL'
        (codeLift2 _ _ _ opL')
        (stageB x1)
        (stageB x2)
    eCl' : (A : Set) -> ClZeroTerm A
    eCl' _ = eCl
    opCl' :
      (A : Set) ->
      ClZeroTerm A ->
      ClZeroTerm A -> ClZeroTerm A
    opCl' _ x1 x2 = opCl x1 x2
    stageCl :
      (A : Set) ->
      ClZeroTerm A ->
      Staged (ClZeroTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (eCl) = Now eCl
    stageCl _ (opCl x1 x2) =
      stage2 _ _ _ (opCl' _)
        (codeLift2 _ _ _ (opCl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    eOL' : (n : Nat) -> OpZeroTerm n
    eOL' _ = eOL
    opOL' :
      (n : Nat) ->
      OpZeroTerm n ->
      OpZeroTerm n -> OpZeroTerm n
    opOL' _ x1 x2 = opOL x1 x2
    stageOp :
      (n : Nat) ->
      OpZeroTerm n ->
      Staged (OpZeroTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (eOL) = Now eOL
    stageOp _ (opOL x1 x2) =
      stage2 _ _ _ (opOL' _)
        (codeLift2 _ _ _ (opOL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    eOL2' :
      (n : Nat) (A : Set) ->
      OpZeroTerm2 n A
    eOL2' _ _ = eOL2
    opOL2' :
      (n : Nat) (A : Set) ->
      OpZeroTerm2 n A ->
      OpZeroTerm2 n A ->
      OpZeroTerm2 n A
    opOL2' _ _ x1 x2 = opOL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpZeroTerm2 n A ->
      Staged (OpZeroTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (eOL2) = Now eOL2
    stageOpE _ _ (opOL2 x1 x2) =
      stage2 _ _ _ (opOL2' _ _)
        (codeLift2 _ _ _ (opOL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record ZeroTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        eT : Repr A
        opT : Repr A -> Repr A -> Repr A
  
  module Zero0 where
    record Zero0
      (A : Set) : Set where
      constructor Zero0C
      field
        0 : A
        * : A -> A -> A
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
    record Zero0Sig
      (AS : Set) : Set where
      constructor Zero0SigSigC
      field
        0S : AS
        *S : AS -> AS -> AS
    record Zero0Prod
      (AP : Set) : Set where
      constructor Zero0ProdC
      field
        0P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
    record Zero0Hom
      (A1 : Set) (A2 : Set)
      (Ze1 : Zero0 A1)
      (Ze2 : Zero0 A2) : Set where
      constructor Zero0HomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ze1) == 0 Ze2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ze1 x1 x2) ==
            * Ze2 (hom x1) (hom x2)
    record Zero0RelInterp
      (A1 : Set) (A2 : Set)
      (Ze1 : Zero0 A1)
      (Ze2 : Zero0 A2) : Set where
      constructor Zero0RelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ze1) (0 Ze2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ze1 x1 x2)
            (* Ze2 y1 y2)
    data Zero0LTerm : Set where
      0L : Zero0LTerm
      *L :
        Zero0LTerm ->
        Zero0LTerm -> Zero0LTerm
    data ClZero0ClTerm
      (A : Set) : Set where
      sing : A -> ClZero0ClTerm A
      0Cl : ClZero0ClTerm A
      *Cl :
        ClZero0ClTerm A ->
        ClZero0ClTerm A ->
        ClZero0ClTerm A
    data OpZero0OLTerm
      (n : Nat) : Set where
      v : Fin n -> OpZero0OLTerm n
      0OL : OpZero0OLTerm n
      *OL :
        OpZero0OLTerm n ->
        OpZero0OLTerm n ->
        OpZero0OLTerm n
    data OpZero0OL2Term2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n -> OpZero0OL2Term2 n A
      sing2 : A -> OpZero0OL2Term2 n A
      0OL2 : OpZero0OL2Term2 n A
      *OL2 :
        OpZero0OL2Term2 n A ->
        OpZero0OL2Term2 n A ->
        OpZero0OL2Term2 n A
    simplifyB :
      Zero0LTerm -> Zero0LTerm
    simplifyB (*L (0L) x) = 0L
    simplifyB (*L x (0L)) = 0L
    simplifyB (0L) = 0L
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClZero0ClTerm A ->
      ClZero0ClTerm A
    simplifyCl _ (*Cl (0Cl) x) = 0Cl
    simplifyCl _ (*Cl x (0Cl)) = 0Cl
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpZero0OLTerm n ->
      OpZero0OLTerm n
    simplifyOp _ (*OL (0OL) x) = 0OL
    simplifyOp _ (*OL x (0OL)) = 0OL
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpZero0OL2Term2 n A ->
      OpZero0OL2Term2 n A
    simplifyOpE _ _ (*OL2
                     (0OL2)
                     x) = 0OL2
    simplifyOpE _ _ (*OL2
                     x
                     (0OL2)) = 0OL2
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Zero0 A -> Zero0LTerm -> A
    evalB _ Ze (0L) = 0 Ze
    evalB _ Ze (*L x1 x2) =
      * Ze (evalB _ Ze x1)
        (evalB _ Ze x2)
    evalCl :
      (A : Set) ->
      Zero0 A -> ClZero0ClTerm A -> A
    evalCl _ Ze (sing x1) = x1
    evalCl _ Ze (0Cl) = 0 Ze
    evalCl _ Ze (*Cl x1 x2) =
      * Ze (evalCl _ Ze x1)
        (evalCl _ Ze x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Zero0 A ->
      Vec A n -> OpZero0OLTerm n -> A
    evalOp _ n Ze vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ze vars (0OL) = 0 Ze
    evalOp _ n Ze vars (*OL x1 x2) =
      * Ze (evalOp _ n Ze vars x1)
        (evalOp _ n Ze vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Zero0 A ->
      Vec A n ->
      OpZero0OL2Term2 n A -> A
    evalOpE _ n Ze vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ze vars (sing2 x1) =
      x1
    evalOpE _ n Ze vars (0OL2) =
      0 Ze
    evalOpE _ n Ze vars (*OL2
                         x1
                         x2) =
      * Ze (evalOpE _ n Ze vars x1)
        (evalOpE _ n Ze vars x2)
    inductionB :
      (P : Zero0LTerm -> Set) ->
      P 0L ->
      ((x1 : Zero0LTerm)
       (x2 : Zero0LTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      (x : Zero0LTerm) -> P x
    inductionB p p0l p*l (0L) = p0l
    inductionB p p0l p*l (*L
                          x1
                          x2) =
      p*l _ _
        (inductionB p p0l p*l x1)
        (inductionB p p0l p*l x2)
    inductionCl :
      (A : Set)
      (P : ClZero0ClTerm A -> Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 0Cl ->
      ((x1 : ClZero0ClTerm A)
       (x2 : ClZero0ClTerm A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      (x : ClZero0ClTerm A) -> P x
    inductionCl _ p psing p0cl p*cl (sing
                                     x1) = psing x1
    inductionCl _ p psing p0cl p*cl (0Cl) =
      p0cl
    inductionCl _ p psing p0cl p*cl (*Cl
                                     x1
                                     x2) =
      p*cl _ _
        (inductionCl _ p psing p0cl p*cl
           x1)
        (inductionCl _ p psing p0cl p*cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpZero0OLTerm n -> Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 0OL ->
      ((x1 : OpZero0OLTerm n)
       (x2 : OpZero0OLTerm n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      (x : OpZero0OLTerm n) -> P x
    inductionOp _ p pv p0ol p*ol (v
                                  x1) = pv x1
    inductionOp _ p pv p0ol p*ol (0OL) =
      p0ol
    inductionOp _ p pv p0ol p*ol (*OL
                                  x1
                                  x2) =
      p*ol _ _
        (inductionOp _ p pv p0ol p*ol
           x1)
        (inductionOp _ p pv p0ol p*ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpZero0OL2Term2 n A ->
           Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 0OL2 ->
      ((x1 : OpZero0OL2Term2 n A)
       (x2 : OpZero0OL2Term2 n A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      (x : OpZero0OL2Term2 n A) -> P x
    inductionOpE _ _ p pv2 psing2 p0ol2 p*ol2 (v2
                                               x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p*ol2 (sing2
                                               x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p*ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p0ol2 p*ol2 (*OL2
                                               x1
                                               x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p*ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p*ol2
           x2)
    0L' : Zero0LTerm
    0L' = 0L
    *L' :
      Zero0LTerm ->
      Zero0LTerm -> Zero0LTerm
    *L' x1 x2 = *L x1 x2
    stageB :
      Zero0LTerm -> Staged Zero0LTerm
    stageB (0L) = Now 0L
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    0Cl' :
      (A : Set) -> ClZero0ClTerm A
    0Cl' _ = 0Cl
    *Cl' :
      (A : Set) ->
      ClZero0ClTerm A ->
      ClZero0ClTerm A ->
      ClZero0ClTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    stageCl :
      (A : Set) ->
      ClZero0ClTerm A ->
      Staged (ClZero0ClTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    0OL' :
      (n : Nat) -> OpZero0OLTerm n
    0OL' _ = 0OL
    *OL' :
      (n : Nat) ->
      OpZero0OLTerm n ->
      OpZero0OLTerm n ->
      OpZero0OLTerm n
    *OL' _ x1 x2 = *OL x1 x2
    stageOp :
      (n : Nat) ->
      OpZero0OLTerm n ->
      Staged (OpZero0OLTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (0OL) = Now 0OL
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    0OL2' :
      (n : Nat) (A : Set) ->
      OpZero0OL2Term2 n A
    0OL2' _ _ = 0OL2
    *OL2' :
      (n : Nat) (A : Set) ->
      OpZero0OL2Term2 n A ->
      OpZero0OL2Term2 n A ->
      OpZero0OL2Term2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpZero0OL2Term2 n A ->
      Staged (OpZero0OL2Term2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record Zero0Tagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        0T : Repr A
        *T : Repr A -> Repr A -> Repr A
  
  module Zero_Ringoid0Sig where
    record Zero_Ringoid0Sig
      (A : Set) : Set where
      constructor Zero_Ringoid0SigC
      field
        0 : A
        * : A -> A -> A
        leftZero_op_0 :
          (x : A) -> * 0 x == 0
        rightZero_op_0 :
          (x : A) -> * x 0 == 0
        + : A -> A -> A
    record Zero_Ringoid0SigSig
      (AS : Set) : Set where
      constructor Zero_Ringoid0SigSigSigC
      field
        0S : AS
        *S : AS -> AS -> AS
        +S : AS -> AS -> AS
    record Zero_Ringoid0SigProd
      (AP : Set) : Set where
      constructor Zero_Ringoid0SigProdC
      field
        0P : Prod AP AP
        *P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        +P :
          Prod AP AP ->
          Prod AP AP -> Prod AP AP
        leftZero_op_0P :
          (xP : Prod AP AP) ->
          *P 0P xP == 0P
        rightZero_op_0P :
          (xP : Prod AP AP) ->
          *P xP 0P == 0P
    record Zero_Ringoid0SigHom
      (A1 : Set) (A2 : Set)
      (Ze1 : Zero_Ringoid0Sig A1)
      (Ze2 : Zero_Ringoid0Sig A2) :
      Set where
      constructor Zero_Ringoid0SigHomC
      field
        hom : A1 -> A2
        pres-0 : hom (0 Ze1) == 0 Ze2
        pres-* :
          (x1 : A1) (x2 : A1) ->
          hom (* Ze1 x1 x2) ==
            * Ze2 (hom x1) (hom x2)
        pres-+ :
          (x1 : A1) (x2 : A1) ->
          hom (+ Ze1 x1 x2) ==
            + Ze2 (hom x1) (hom x2)
    record Zero_Ringoid0SigRelInterp
      (A1 : Set) (A2 : Set)
      (Ze1 : Zero_Ringoid0Sig A1)
      (Ze2 : Zero_Ringoid0Sig A2) :
      Set where
      constructor Zero_Ringoid0SigRelInterpC
      field
        interp : A1 -> A2 -> Set
        interp-0 :
          interp (0 Ze1) (0 Ze2)
        interp-* :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (* Ze1 x1 x2)
            (* Ze2 y1 y2)
        interp-+ :
          (x1 : A1) (x2 : A1) (y1 : A2)
          (y2 : A2) ->
          interp x1 y1 ->
          interp x2 y2 ->
          interp (+ Ze1 x1 x2)
            (+ Ze2 y1 y2)
    data Zero_Ringoid0SigTerm
      : Set where
      0L : Zero_Ringoid0SigTerm
      *L :
        Zero_Ringoid0SigTerm ->
        Zero_Ringoid0SigTerm ->
        Zero_Ringoid0SigTerm
      +L :
        Zero_Ringoid0SigTerm ->
        Zero_Ringoid0SigTerm ->
        Zero_Ringoid0SigTerm
    data ClZero_Ringoid0SigTerm
      (A : Set) : Set where
      sing :
        A -> ClZero_Ringoid0SigTerm A
      0Cl : ClZero_Ringoid0SigTerm A
      *Cl :
        ClZero_Ringoid0SigTerm A ->
        ClZero_Ringoid0SigTerm A ->
        ClZero_Ringoid0SigTerm A
      +Cl :
        ClZero_Ringoid0SigTerm A ->
        ClZero_Ringoid0SigTerm A ->
        ClZero_Ringoid0SigTerm A
    data OpZero_Ringoid0SigTerm
      (n : Nat) : Set where
      v :
        Fin n ->
        OpZero_Ringoid0SigTerm n
      0OL : OpZero_Ringoid0SigTerm n
      *OL :
        OpZero_Ringoid0SigTerm n ->
        OpZero_Ringoid0SigTerm n ->
        OpZero_Ringoid0SigTerm n
      +OL :
        OpZero_Ringoid0SigTerm n ->
        OpZero_Ringoid0SigTerm n ->
        OpZero_Ringoid0SigTerm n
    data OpZero_Ringoid0SigTerm2
      (n : Nat) (A : Set) : Set where
      v2 :
        Fin n ->
        OpZero_Ringoid0SigTerm2 n A
      sing2 :
        A -> OpZero_Ringoid0SigTerm2 n A
      0OL2 :
        OpZero_Ringoid0SigTerm2 n A
      *OL2 :
        OpZero_Ringoid0SigTerm2 n A ->
        OpZero_Ringoid0SigTerm2 n A ->
        OpZero_Ringoid0SigTerm2 n A
      +OL2 :
        OpZero_Ringoid0SigTerm2 n A ->
        OpZero_Ringoid0SigTerm2 n A ->
        OpZero_Ringoid0SigTerm2 n A
    simplifyB :
      Zero_Ringoid0SigTerm ->
      Zero_Ringoid0SigTerm
    simplifyB (*L (0L) x) = 0L
    simplifyB (*L x (0L)) = 0L
    simplifyB (0L) = 0L
    simplifyB (*L x1 x2) =
      *L (simplifyB x1) (simplifyB x2)
    simplifyB (+L x1 x2) =
      +L (simplifyB x1) (simplifyB x2)
    simplifyCl :
      (A : Set) ->
      ClZero_Ringoid0SigTerm A ->
      ClZero_Ringoid0SigTerm A
    simplifyCl _ (*Cl (0Cl) x) = 0Cl
    simplifyCl _ (*Cl x (0Cl)) = 0Cl
    simplifyCl _ (0Cl) = 0Cl
    simplifyCl _ (*Cl x1 x2) =
      *Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (+Cl x1 x2) =
      +Cl (simplifyCl _ x1)
        (simplifyCl _ x2)
    simplifyCl _ (sing x1) = sing x1
    simplifyOp :
      (n : Nat) ->
      OpZero_Ringoid0SigTerm n ->
      OpZero_Ringoid0SigTerm n
    simplifyOp _ (*OL (0OL) x) = 0OL
    simplifyOp _ (*OL x (0OL)) = 0OL
    simplifyOp _ (0OL) = 0OL
    simplifyOp _ (*OL x1 x2) =
      *OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (+OL x1 x2) =
      +OL (simplifyOp _ x1)
        (simplifyOp _ x2)
    simplifyOp _ (v x1) = v x1
    simplifyOpE :
      (n : Nat) (A : Set) ->
      OpZero_Ringoid0SigTerm2 n A ->
      OpZero_Ringoid0SigTerm2 n A
    simplifyOpE _ _ (*OL2
                     (0OL2)
                     x) = 0OL2
    simplifyOpE _ _ (*OL2
                     x
                     (0OL2)) = 0OL2
    simplifyOpE _ _ (0OL2) = 0OL2
    simplifyOpE _ _ (*OL2 x1 x2) =
      *OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (+OL2 x1 x2) =
      +OL2 (simplifyOpE _ _ x1)
        (simplifyOpE _ _ x2)
    simplifyOpE _ _ (v2 x1) = v2 x1
    simplifyOpE _ _ (sing2 x1) =
      sing2 x1
    evalB :
      (A : Set) ->
      Zero_Ringoid0Sig A ->
      Zero_Ringoid0SigTerm -> A
    evalB _ Ze (0L) = 0 Ze
    evalB _ Ze (*L x1 x2) =
      * Ze (evalB _ Ze x1)
        (evalB _ Ze x2)
    evalB _ Ze (+L x1 x2) =
      + Ze (evalB _ Ze x1)
        (evalB _ Ze x2)
    evalCl :
      (A : Set) ->
      Zero_Ringoid0Sig A ->
      ClZero_Ringoid0SigTerm A -> A
    evalCl _ Ze (sing x1) = x1
    evalCl _ Ze (0Cl) = 0 Ze
    evalCl _ Ze (*Cl x1 x2) =
      * Ze (evalCl _ Ze x1)
        (evalCl _ Ze x2)
    evalCl _ Ze (+Cl x1 x2) =
      + Ze (evalCl _ Ze x1)
        (evalCl _ Ze x2)
    evalOp :
      (A : Set) (n : Nat) ->
      Zero_Ringoid0Sig A ->
      Vec A n ->
      OpZero_Ringoid0SigTerm n -> A
    evalOp _ n Ze vars (v x1) =
      lookup _ n x1 vars
    evalOp _ n Ze vars (0OL) = 0 Ze
    evalOp _ n Ze vars (*OL x1 x2) =
      * Ze (evalOp _ n Ze vars x1)
        (evalOp _ n Ze vars x2)
    evalOp _ n Ze vars (+OL x1 x2) =
      + Ze (evalOp _ n Ze vars x1)
        (evalOp _ n Ze vars x2)
    evalOpE :
      (A : Set) (n : Nat) ->
      Zero_Ringoid0Sig A ->
      Vec A n ->
      OpZero_Ringoid0SigTerm2 n A -> A
    evalOpE _ n Ze vars (v2 x1) =
      lookup _ n x1 vars
    evalOpE _ n Ze vars (sing2 x1) =
      x1
    evalOpE _ n Ze vars (0OL2) =
      0 Ze
    evalOpE _ n Ze vars (*OL2
                         x1
                         x2) =
      * Ze (evalOpE _ n Ze vars x1)
        (evalOpE _ n Ze vars x2)
    evalOpE _ n Ze vars (+OL2
                         x1
                         x2) =
      + Ze (evalOpE _ n Ze vars x1)
        (evalOpE _ n Ze vars x2)
    inductionB :
      (P : Zero_Ringoid0SigTerm ->
           Set) ->
      P 0L ->
      ((x1 : Zero_Ringoid0SigTerm)
       (x2 : Zero_Ringoid0SigTerm) ->
       P x1 -> P x2 -> P (*L x1 x2)) ->
      ((x1 : Zero_Ringoid0SigTerm)
       (x2 : Zero_Ringoid0SigTerm) ->
       P x1 -> P x2 -> P (+L x1 x2)) ->
      (x : Zero_Ringoid0SigTerm) ->
      P x
    inductionB p p0l p*l p+l (0L) =
      p0l
    inductionB p p0l p*l p+l (*L
                              x1
                              x2) =
      p*l _ _
        (inductionB p p0l p*l p+l x1)
        (inductionB p p0l p*l p+l x2)
    inductionB p p0l p*l p+l (+L
                              x1
                              x2) =
      p+l _ _
        (inductionB p p0l p*l p+l x1)
        (inductionB p p0l p*l p+l x2)
    inductionCl :
      (A : Set)
      (P : ClZero_Ringoid0SigTerm A ->
           Set) ->
      ((x1 : A) -> P (sing x1)) ->
      P 0Cl ->
      ((x1 : ClZero_Ringoid0SigTerm A)
       (x2 : ClZero_Ringoid0SigTerm
          A) ->
       P x1 ->
       P x2 -> P (*Cl x1 x2)) ->
      ((x1 : ClZero_Ringoid0SigTerm A)
       (x2 : ClZero_Ringoid0SigTerm
          A) ->
       P x1 ->
       P x2 -> P (+Cl x1 x2)) ->
      (x : ClZero_Ringoid0SigTerm
         A) -> P x
    inductionCl _ p psing p0cl p*cl p+cl (sing
                                          x1) = psing x1
    inductionCl _ p psing p0cl p*cl p+cl (0Cl) =
      p0cl
    inductionCl _ p psing p0cl p*cl p+cl (*Cl
                                          x1
                                          x2) =
      p*cl _ _
        (inductionCl _ p psing p0cl p*cl
           p+cl
           x1)
        (inductionCl _ p psing p0cl p*cl
           p+cl
           x2)
    inductionCl _ p psing p0cl p*cl p+cl (+Cl
                                          x1
                                          x2) =
      p+cl _ _
        (inductionCl _ p psing p0cl p*cl
           p+cl
           x1)
        (inductionCl _ p psing p0cl p*cl
           p+cl
           x2)
    inductionOp :
      (n : Nat)
      (P : OpZero_Ringoid0SigTerm n ->
           Set) ->
      ((fin : Fin n) -> P (v fin)) ->
      P 0OL ->
      ((x1 : OpZero_Ringoid0SigTerm n)
       (x2 : OpZero_Ringoid0SigTerm
          n) ->
       P x1 ->
       P x2 -> P (*OL x1 x2)) ->
      ((x1 : OpZero_Ringoid0SigTerm n)
       (x2 : OpZero_Ringoid0SigTerm
          n) ->
       P x1 ->
       P x2 -> P (+OL x1 x2)) ->
      (x : OpZero_Ringoid0SigTerm
         n) -> P x
    inductionOp _ p pv p0ol p*ol p+ol (v
                                       x1) = pv x1
    inductionOp _ p pv p0ol p*ol p+ol (0OL) =
      p0ol
    inductionOp _ p pv p0ol p*ol p+ol (*OL
                                       x1
                                       x2) =
      p*ol _ _
        (inductionOp _ p pv p0ol p*ol
           p+ol
           x1)
        (inductionOp _ p pv p0ol p*ol
           p+ol
           x2)
    inductionOp _ p pv p0ol p*ol p+ol (+OL
                                       x1
                                       x2) =
      p+ol _ _
        (inductionOp _ p pv p0ol p*ol
           p+ol
           x1)
        (inductionOp _ p pv p0ol p*ol
           p+ol
           x2)
    inductionOpE :
      (n : Nat) (A : Set)
      (P : OpZero_Ringoid0SigTerm2 n
             A -> Set) ->
      ((fin : Fin n) -> P (v2 fin)) ->
      ((x1 : A) -> P (sing2 x1)) ->
      P 0OL2 ->
      ((x1 : OpZero_Ringoid0SigTerm2 n
          A)
       (x2 : OpZero_Ringoid0SigTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (*OL2 x1 x2)) ->
      ((x1 : OpZero_Ringoid0SigTerm2 n
          A)
       (x2 : OpZero_Ringoid0SigTerm2 n
          A) ->
       P x1 ->
       P x2 -> P (+OL2 x1 x2)) ->
      (x : OpZero_Ringoid0SigTerm2 n
         A) -> P x
    inductionOpE _ _ p pv2 psing2 p0ol2 p*ol2 p+ol2 (v2
                                                     x1) = pv2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p*ol2 p+ol2 (sing2
                                                     x1) = psing2 x1
    inductionOpE _ _ p pv2 psing2 p0ol2 p*ol2 p+ol2 (0OL2) =
      p0ol2
    inductionOpE _ _ p pv2 psing2 p0ol2 p*ol2 p+ol2 (*OL2
                                                     x1
                                                     x2) =
      p*ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p*ol2
           p+ol2
           x2)
    inductionOpE _ _ p pv2 psing2 p0ol2 p*ol2 p+ol2 (+OL2
                                                     x1
                                                     x2) =
      p+ol2 _ _
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p*ol2
           p+ol2
           x1)
        (inductionOpE _ _ p pv2 psing2
           p0ol2
           p*ol2
           p+ol2
           x2)
    0L' : Zero_Ringoid0SigTerm
    0L' = 0L
    *L' :
      Zero_Ringoid0SigTerm ->
      Zero_Ringoid0SigTerm ->
      Zero_Ringoid0SigTerm
    *L' x1 x2 = *L x1 x2
    +L' :
      Zero_Ringoid0SigTerm ->
      Zero_Ringoid0SigTerm ->
      Zero_Ringoid0SigTerm
    +L' x1 x2 = +L x1 x2
    stageB :
      Zero_Ringoid0SigTerm ->
      Staged Zero_Ringoid0SigTerm
    stageB (0L) = Now 0L
    stageB (*L x1 x2) =
      stage2 _ _ _ *L'
        (codeLift2 _ _ _ *L')
        (stageB x1)
        (stageB x2)
    stageB (+L x1 x2) =
      stage2 _ _ _ +L'
        (codeLift2 _ _ _ +L')
        (stageB x1)
        (stageB x2)
    0Cl' :
      (A : Set) ->
      ClZero_Ringoid0SigTerm A
    0Cl' _ = 0Cl
    *Cl' :
      (A : Set) ->
      ClZero_Ringoid0SigTerm A ->
      ClZero_Ringoid0SigTerm A ->
      ClZero_Ringoid0SigTerm A
    *Cl' _ x1 x2 = *Cl x1 x2
    +Cl' :
      (A : Set) ->
      ClZero_Ringoid0SigTerm A ->
      ClZero_Ringoid0SigTerm A ->
      ClZero_Ringoid0SigTerm A
    +Cl' _ x1 x2 = +Cl x1 x2
    stageCl :
      (A : Set) ->
      ClZero_Ringoid0SigTerm A ->
      Staged
        (ClZero_Ringoid0SigTerm A)
    stageCl _ (sing x1) =
      Now (sing x1)
    stageCl _ (0Cl) = Now 0Cl
    stageCl _ (*Cl x1 x2) =
      stage2 _ _ _ (*Cl' _)
        (codeLift2 _ _ _ (*Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    stageCl _ (+Cl x1 x2) =
      stage2 _ _ _ (+Cl' _)
        (codeLift2 _ _ _ (+Cl' _))
        (stageCl _ x1)
        (stageCl _ x2)
    0OL' :
      (n : Nat) ->
      OpZero_Ringoid0SigTerm n
    0OL' _ = 0OL
    *OL' :
      (n : Nat) ->
      OpZero_Ringoid0SigTerm n ->
      OpZero_Ringoid0SigTerm n ->
      OpZero_Ringoid0SigTerm n
    *OL' _ x1 x2 = *OL x1 x2
    +OL' :
      (n : Nat) ->
      OpZero_Ringoid0SigTerm n ->
      OpZero_Ringoid0SigTerm n ->
      OpZero_Ringoid0SigTerm n
    +OL' _ x1 x2 = +OL x1 x2
    stageOp :
      (n : Nat) ->
      OpZero_Ringoid0SigTerm n ->
      Staged
        (OpZero_Ringoid0SigTerm n)
    stageOp _ (v x1) =
      const _ (code _ (v x1))
    stageOp _ (0OL) = Now 0OL
    stageOp _ (*OL x1 x2) =
      stage2 _ _ _ (*OL' _)
        (codeLift2 _ _ _ (*OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    stageOp _ (+OL x1 x2) =
      stage2 _ _ _ (+OL' _)
        (codeLift2 _ _ _ (+OL' _))
        (stageOp _ x1)
        (stageOp _ x2)
    0OL2' :
      (n : Nat) (A : Set) ->
      OpZero_Ringoid0SigTerm2 n A
    0OL2' _ _ = 0OL2
    *OL2' :
      (n : Nat) (A : Set) ->
      OpZero_Ringoid0SigTerm2 n A ->
      OpZero_Ringoid0SigTerm2 n A ->
      OpZero_Ringoid0SigTerm2 n A
    *OL2' _ _ x1 x2 = *OL2 x1 x2
    +OL2' :
      (n : Nat) (A : Set) ->
      OpZero_Ringoid0SigTerm2 n A ->
      OpZero_Ringoid0SigTerm2 n A ->
      OpZero_Ringoid0SigTerm2 n A
    +OL2' _ _ x1 x2 = +OL2 x1 x2
    stageOpE :
      (n : Nat) (A : Set) ->
      OpZero_Ringoid0SigTerm2 n A ->
      Staged
        (OpZero_Ringoid0SigTerm2 n A)
    stageOpE _ _ (sing2 x1) =
      Now (sing2 x1)
    stageOpE _ _ (v2 x1) =
      const _ (code _ (v2 x1))
    stageOpE _ _ (0OL2) = Now 0OL2
    stageOpE _ _ (*OL2 x1 x2) =
      stage2 _ _ _ (*OL2' _ _)
        (codeLift2 _ _ _ (*OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    stageOpE _ _ (+OL2 x1 x2) =
      stage2 _ _ _ (+OL2' _ _)
        (codeLift2 _ _ _ (+OL2' _ _))
        (stageOpE _ _ x1)
        (stageOpE _ _ x2)
    record Zero_Ringoid0SigTagless
      (A : Set) (Repr : Set -> Set) :
      Set where
      constructor tagless
      field
        0T : Repr A
        *T : Repr A -> Repr A -> Repr A
        +T : Repr A -> Repr A -> Repr A
  

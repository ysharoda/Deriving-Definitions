module MonoidTerms where 

-- Prelude 

module NatNums where
 data Nat : Set where
  zero : Nat
  suc  : Nat -> Nat

module Prelude where 

 open NatNums 

 pred : Nat -> Nat
 pred zero    = zero
 pred (suc n) = n

 data Fin (n : Nat) : Set where
  fzero : {m : Nat} (p : n == suc m) -> Fin n
  fsuc  : {m : Nat} (p : n == suc m) (i : Fin m) -> Fin n

 data Vec (A : Set) (n : Nat) : Set
 data Vec A n where
  nil  : n == zero -> Vec A n
  cons : {m : Nat} (p : n == suc m) (x : A) (xs : Vec A m) -> Vec A n

 data Unit : Set
 data Unit where
  unit : Unit

 Empty : Set
 Empty = (A : Set) -> A

 subst : {A : Set} {x y : A} (P : A -> Set) ->
        x == y -> P x -> P y
 subst P = J (\ x y _ -> P x -> P y) (\ x p -> p)

 sym : {A : Set} {x : A} {y : A} -> x == y -> y == x
 sym {A} {x} {y} p = subst (\ y -> y == x) p refl

 cong : {A B : Set} {x : A} {y : A} (f : A -> B) -> x == y -> f x == f y
 cong f p = subst (\ y -> f _ == f y) p refl

 IsZero : Nat -> Set
 IsZero zero    = Unit
 IsZero (suc n) = Empty

 zeroNOTsuc : {n : Nat} -> zero == suc n -> Empty
 zeroNOTsuc p = subst IsZero p unit

 trans : {A : Set} {x : A} {y : A} {z : A} -> x == y -> y == z -> x == z
 trans {A} {x} p q = subst (\ y -> x == y) q p

 lemma : {n m : Nat} -> n == suc m -> n == zero -> Empty
 lemma p q = zeroNOTsuc (trans (sym q) p)

 sucInj : {n m : Nat} -> suc n == suc m -> n == m
 sucInj p = cong pred p

 lookup : {A : Set} (n : Nat) (i : Fin n) (v : Vec A n) -> A
 lookup {A} n (fzero {m} p) (nil q)            = lemma p q A
 lookup {A} n (fzero {m} p) (cons {l} q x xs)  = x
 lookup {A} n (fsuc {m} p i) (nil q)           = lemma p q A
 lookup {A} n (fsuc {m} p i) (cons {l} q x xs) =
   lookup m i (subst (Vec A) (sucInj (trans (sym q) p)) xs)

module Code where

 open NatNums  

 data Wrap (A : Set) : Set where 
   Q : A -> Wrap A

 data Stage : Set where
   s0 : Stage
   s1 : Stage

 CodeRep : (A : Set) (s : Stage) -> Set
 CodeRep A s0 = A
 CodeRep A s1 = Wrap (CodeRep A s0) 

 uncode : {A : Set} -> CodeRep A s1 -> CodeRep A s0 
 uncode (Q x) = x

 code : {A : Set} -> CodeRep A s0 -> CodeRep A s1 
 code x = Q x

 run : {A : Set} -> CodeRep A s1 -> A
 run (Q x) = x

{-
 push-code : {A : Set} -> CodeRep A -> CodeRep A
 push-code (Q n x) = Q (suc n) x

 codeUnary : {A B : Set} -> (A -> B) -> (CodeRep A -> CodeRep B)
 codeUnary f x = code (f (run x))

 codeBinary : {A B C : Set} -> (A -> B -> C) -> (CodeRep A -> CodeRep B -> CodeRep C)
 codeBinary f x y = code (f (run x) (run y)) 
-}

module Staging where

 open Code 

 data Choice : Set where
  Expr  : Choice  
  Const : Choice

 data Comp (A : Set) (s : Stage) : Set where
  Computation : Choice -> CodeRep A s -> Comp A s
  
 data Staged (A : Set) : Set where
  Now : A -> Staged A 
  Later : Comp A s1 -> Staged A

 expr : {A : Set} -> CodeRep A s1 -> Staged A
 expr x = Later (Computation Expr x)

 const : {A : Set} -> CodeRep A s1 -> Staged A
 const x = Later (Computation Const x) 

 stage0 : {A : Set} -> A -> Staged A
 stage0 x = Now x

 stage1 : {A B : Set} -> (A -> B) -> (CodeRep A s1 -> CodeRep B s1) -> Staged A -> Staged B
 stage1 f g (Now x) = Now (f x)
 stage1 f g (Later (Computation _ x)) = expr (g x)

 stage2 : {A B C : Set} -> (A -> B -> C) -> (CodeRep A s1 -> CodeRep B s1 -> CodeRep C s1) ->
           Staged A -> Staged B -> Staged C
 stage2 f _ (Now x) (Now y) = stage0 (f x y)
 stage2 _ g (Now x) (Later (Computation _ y)) = expr (g (code x) y)
 stage2 _ g (Later (Computation _ x)) (Now y) = expr (g x (code y))
 stage2 _ g (Later (Computation _ x)) (Later (Computation _ y)) = expr (g x y)

 codeLift : {A B C : Set} -> (A -> B -> C) -> (CodeRep A s1 -> CodeRep B s1 -> CodeRep C s1)
 codeLift f (Q x) (Q y) = Q (f x y) 
{-
 liftVar : {A : Set} -> A -> Staged A
 liftVar x = Later (Computation Const (code x))

 liftConstant : {A : Set} -> A -> Staged A
 liftConstant x = Now x 

 liftUnary : {A B : Set} -> (A -> B) -> (Staged A -> Staged B)
 liftUnary f (Now x) = Now (f x)
 liftUnary f (Later (Computation _ x)) =
      Later (Computation Expr (code (f (run x)))) 

 liftBinary : {A B C : Set} -> (A -> B -> C) -> Staged A -> Staged B -> Staged C
 liftBinary f (Now x) (Now y) = Now (f x y)
 liftBinary f (Now x) (Later (Computation _ y)) =
  Later (Computation Expr (codeBinary f (code x) y))
 liftBinary f (Later (Computation _ x)) (Now y) =
  Later (Computation Expr (codeBinary f x (code y)))
 liftBinary f (Later (Computation _ x)) (Later (Computation _ y)) =
  Later (Computation Expr (codeBinary f x y))
-}
module Monoid where

 open NatNums
 open Prelude
 open Code 
 open Staging

 record Monoid (A : Set) : Set where
  constructor monoid
  field
    e  : A
    op : A -> A -> A
    lunit : {x : A} -> (op e x) == x
    runit : {x : A} -> (op x e) == x
    assoc : {x y z : A} -> (op x (op y z)) == (op (op x y) z)

 data MonTerm : Set where
  ee  : MonTerm
  opp : MonTerm -> MonTerm -> MonTerm

 eval : {A : Set} -> Monoid A -> MonTerm -> A
 eval M ee = (e M)
 eval M (opp x y) = (op M) (eval M x) (eval M y)

 liftMonExpr : MonTerm -> Staged MonTerm
 liftMonExpr x = Now x 

 simplify : MonTerm -> MonTerm
 simplify (opp ee x) = x
 simplify (opp x ee) = x
 simplify (opp x y) = opp (simplify x) (simplify y)

 induction : (P : MonTerm -> Set) -> P ee -> ((x y : MonTerm) -> P x -> P y -> P (opp x y)) -> (x : MonTerm) -> P x
 induction p pe _ ee = pe
 induction p pe f (opp e1 e2) = f _ _ (induction p pe f e1) (induction p pe f e2)

 data OpenMonTerm (n : Nat) : Set where
   v   : Fin n -> OpenMonTerm n 
   e'  : OpenMonTerm n 
   op' : OpenMonTerm n -> OpenMonTerm n -> OpenMonTerm n
   
 op'F : {n : Nat} -> OpenMonTerm n -> OpenMonTerm n -> OpenMonTerm n 
 op'F x y = op' x y 

 evalOpenTerm : {A : Set} -> (n : Nat) -> Monoid A -> OpenMonTerm n -> Vec A n -> A
 evalOpenTerm n mon (v fin) vars = lookup n fin vars
 evalOpenTerm _ mon (e') _ = (e mon) 
 evalOpenTerm n mon (op' x y) vars = (op mon) (evalOpenTerm n mon x vars) (evalOpenTerm n mon y vars) 

 liftOpenMonExpr : {n : Nat} -> OpenMonTerm n -> Staged (OpenMonTerm n)
 liftOpenMonExpr (v fin) = const (code (v fin))  
 liftOpenMonExpr e' = Now e'
 liftOpenMonExpr (op' x y) =
   stage2 (op'F) (codeLift (op'F)) (liftOpenMonExpr x) (liftOpenMonExpr y)

 record MonoidTagless (A : Set) (Repr : Set -> Set) : Set where
  constructor tagless 
  field
   eT : Repr A
   opT : Repr A -> Repr A -> Repr A

 record MonoidTagless2 (Repr : Set -> Set) : Set where
  constructor tagless2
  field
    AT2 : Set
    eT2 : Repr AT2
    opT2 : Repr AT2 -> Repr AT2 -> Repr AT2


 plus : Nat -> Nat -> Nat
 plus zero x = x
 plus x zero = x
 plus (suc x) (suc y) = suc (plus x (suc y))

 lunit-proof : (n : Nat) -> (plus zero n) == n
 lunit-proof n = refl

 runit-proof : (n : Nat) -> (plus n zero) == n
 runit-proof n = refl 

 postulate 
  assoc-proof : (x y z : Nat) -> (plus x (plus y z)) == (plus (plus x y) z)

 natIsMon : Monoid Nat
 natIsMon = monoid zero plus lunit-proof runit-proof assoc-proof

 data ClPmTerm (A : Set) : Set where
   singleton : A -> ClPmTerm A 
 
 induction2 : (A : Set) -> (P : ClPmTerm A -> Set) -> ((x1 : A) -> P (singleton x1)) -> (x : ClPmTerm A) -> P x
 induction2 _ p psing (singleton x) = psing x
 

-- inductionCl : (A : Set) -> (P : ClCarrierTerm A -> Set) -> ((x1 : A) -> P (sing x1)) -> (x : ClCarrierTerm A) -> P x
-- inductionCl _ p psing (sing x1) = psing


{-
 simp : {A : Set} -> ClPmTerm A -> ClPmTerm A
 simp eX = eX
 simp (opX x y) = opX (simp x) (simp y) -}